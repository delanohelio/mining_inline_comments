{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM5OTU1NzE2", "number": 8438, "title": "Create HistoryChange objects for killing and transforming units", "bodyText": "The HistoryChange objects will group the calls to add a history child\nevent and calls to add change objects. This will creating these objects\nwithout the need for the bridge and then returning them to callers where\nthe bridge is available.\nKillUnit object has been used in many of the places in the battle code\nthat removes units. In most of those places, transformation wasn't being\ndone, so this fixes that.\nKillUnit also makes it explicit that transported and unloaded units are\nkilled when it is killed. There is still some code (such as\nAbstractBattle#unitsLostInPrecedingBattle) which does some of this work,\nthough.\nRework how units are killed and transformed in MustFightBattle. The\noriginal logic went like:\n\nCreate a change object to kill a unit\nDetect if the unit needs to transform when it dies\nCreate a change object to also set its damage to the maximum\n\n\nAt this point, there is a change object to kill it and one to set its\ndamage\n\n\nAdd the units to a list of killed units during the round\nExecute the change objects\nLater, during the clearCasualty steps, go through the units hit as\nwell as the units that were previously killed in step 4\nTransform them\n\nIf the change object in 3 doesn't happen, then the unit won't transform\nbecause its damage won't match the settings.\nIf the unit isn't added to the list in 4, then the unit won't transform\nbecause it won't be seen in step 6.\nThe new logic now has the code to kill units moved to the KillUnits\nHistoryChange object. This object will call TransformUnits if needed.\nSo the new logic looks like this:\n\nCreate KillUnits object\nThis creates change objects to kill the units\nThis creates a TransformUnits object that creates change objects to\ntransform the units.\nLater, during the clearCasualty step, only the units that have been\nhit get passed into a TransformUnits object. The killed units from 1-3\nno longer need to be worried about.\n\nBecause of save compatibility reasons, the old killedDuringCurrentRound\nvariable is still around and is still being used in step 4. But it is no\nlonger being populated so it will only actually be used if the save is\nin the middle of a battle and has already populated it.\n\nTesting\n\nPlayed TWW and had a battle between battleships.  Tested both having the battleships dying and surviving (either as a retreat or as a win).  I did notice that I could move the damaged battleship after retreating.  It looks like that property (I think it is wasInCombat and alreadyMoved) isn't being transferred to the new units.  That issue already existed so I didn't include a fix for it.\nPlayed Global40 with transported allied air and infantry.  I also did an assault against an undefended territory and had the sea battle loose (so the infantry should die with the transport), an assault against a scrambled plane (with just a transport and infantry as well as a battleship, transport, and infantry), and an assault that had a sea battle before.\nPerformed a strategic bombing with an air battle that preceded it in Global40.  Had units on both sides die.\nI also tried to get a FinishedBattle as a dependent battle but I couldn't figure out a way to do that.  I could trigger a FinishedBattle through blitzes and navy movement through kamikaze or convoy spaces.  But I couldn't come up with a way to make it be dependent on another battle.\nScreens Shots\n\nAdditional Notes to Reviewer\n\nI thought about creating a smaller interface of IDelegateBridge that only has addChange and a default method for writing to IDelegateHistoryWriter.  This interface would be passed into the HistoryChange objects instead of the large IDelegateBridge interface.\nRelease Note", "createdAt": "2020-12-15T03:53:04Z", "url": "https://github.com/triplea-game/triplea/pull/8438", "merged": true, "mergeCommit": {"oid": "984624aff7ffe53f4ec07014f69190ace47d1c17"}, "closed": true, "closedAt": "2020-12-27T00:03:20Z", "author": {"login": "trevan"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdmRxmNgH2gAyNTM5OTU1NzE2OjM4NzU1MjViZjdlMjIyMjJlOWFhZWU4ZTAyYzYyMjlhYWFiNDdiY2U=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdqBu_QgH2gAyNTM5OTU1NzE2OmQ3ODM0YTQ1MGFlZDhhODczZjY2ZjNjYzQ0ZDhlMWMzYWYzZjAwMmE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "3875525bf7e22222e9aaee8e02c6229aaab47bce", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/3875525bf7e22222e9aaee8e02c6229aaab47bce", "committedDate": "2020-12-15T03:28:55Z", "message": "Create HistoryChange objects for killing and transforming units\n\nThe HistoryChange objects will group the calls to add a history child\nevent and calls to add change objects. This will creating these objects\nwithout the need for the bridge and then returning them to callers where\nthe bridge is available.\n\nKillUnit object has been used in many of the places in the battle code\nthat removes units. In most of those places, transformation wasn't being\ndone, so this fixes that.\n\nKillUnit also makes it explicit that transported and unloaded units are\nkilled when it is killed. There is still some code (such as\nAbstractBattle#unitsLostInPrecedingBattle) which does some of this work,\nthough.\n\nRework how units are killed and transformed in MustFightBattle. The\noriginal logic went like:\n1. Create a change object to kill a unit\n2. Detect if the unit needs to transform when it dies\n3. Create a change object to also set its damage to the maximum\n - At this point, there is a change object to kill it and one to set its\n damage\n4. Add the units to a list of killed units during the round\n5. Execute the change objects\n6. Later, during the clearCasualty steps, go through the units hit as\n well as the units that were previously killed in step 4\n7. Transform them\n\nIf the change object in 3 doesn't happen, then the unit won't transform\nbecause its damage won't match the settings.\nIf the unit isn't added to the list in 4, then the unit won't transform\nbecause it won't be seen in step 6.\n\nThe new logic now has the code to kill units moved to the KillUnits\nHistoryChange object. This object will call TransformUnits if needed.\nSo the new logic looks like this:\n1. Create KillUnits object\n2. This creates change objects to kill the units\n3. This creates a TransformUnits object that creates change objects to\n transform the units.\n4. Later, during the clearCasualty step, only the units that have been\nhit get passed into a TransformUnits object. The killed units from 1-3\nno longer need to be worried about.\n\nBecause of save compatibility reasons, the old killedDuringCurrentRound\nvariable is still around and is still being used in step 4. But it is no\nlonger being populated so it will only actually be used if the save is\nin the middle of a battle and has already populated it."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e09b57eb20ce78afa0fe6dbb789c626f223af424", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/e09b57eb20ce78afa0fe6dbb789c626f223af424", "committedDate": "2020-12-15T04:01:13Z", "message": "Remove unused constructor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "87b7a9ebba72ade584e2b76ddf5d625184dd3cfe", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/87b7a9ebba72ade584e2b76ddf5d625184dd3cfe", "committedDate": "2020-12-15T04:06:56Z", "message": "Don't call the unused constructor either"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU2MDU4Njg5", "url": "https://github.com/triplea-game/triplea/pull/8438#pullrequestreview-556058689", "createdAt": "2020-12-20T20:20:10Z", "commit": {"oid": "87b7a9ebba72ade584e2b76ddf5d625184dd3cfe"}, "state": "COMMENTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMFQyMDoyMDoxMFrOIJHhCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMFQyMDozODoyNVrOIJHo4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQzMTI0MQ==", "bodyText": "Any thoughts if 'kill' might be a confused with battle casualties? In battle, a unit when 'killed' is sent to the casualty bucket before being removed.\nSuggestion: Perhaps \"RemoveUnits\" might be a more flexible and clear name.", "url": "https://github.com/triplea-game/triplea/pull/8438#discussion_r546431241", "createdAt": "2020-12-20T20:20:10Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/engine/history/change/units/KillUnits.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package games.strategy.engine.history.change.units;\n+\n+import games.strategy.engine.data.CompositeChange;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.engine.history.change.HistoryChange;\n+import games.strategy.triplea.formatter.MyFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import lombok.Value;\n+import org.apache.commons.text.StringSubstitutor;\n+import org.triplea.java.collections.IntegerMap;\n+\n+/**\n+ * Kills a set of units in a location\n+ *\n+ * <p>Adds a history event for the killing\n+ *\n+ * <p>Transforms units to other units if needed. See {@link TransformUnits}\n+ */\n+@Value\n+public class KillUnits implements HistoryChange {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87b7a9ebba72ade584e2b76ddf5d625184dd3cfe"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQzMTM4Nw==", "bodyText": "Is the 'allArgsConstructor' of '@value' being used?\nAs-is, it looks like there are a lot of constructors for this object, enough so it might be hard to reason about how it is instantiated, which makes reasoning about the object state difficult and depend on tracing down call flows.\nIf we do not use the 'all args constructor', removing that can help the above problem and just replace this with 'getter, setter, and equalsAndHashcode'.", "url": "https://github.com/triplea-game/triplea/pull/8438#discussion_r546431387", "createdAt": "2020-12-20T20:21:55Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/engine/history/change/units/KillUnits.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package games.strategy.engine.history.change.units;\n+\n+import games.strategy.engine.data.CompositeChange;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.engine.history.change.HistoryChange;\n+import games.strategy.triplea.formatter.MyFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import lombok.Value;\n+import org.apache.commons.text.StringSubstitutor;\n+import org.triplea.java.collections.IntegerMap;\n+\n+/**\n+ * Kills a set of units in a location\n+ *\n+ * <p>Adds a history event for the killing\n+ *\n+ * <p>Transforms units to other units if needed. See {@link TransformUnits}\n+ */\n+@Value", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87b7a9ebba72ade584e2b76ddf5d625184dd3cfe"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQzMTQ3MA==", "bodyText": "Nit, comment can be condensed:\nAdds a history event for the removing units in a territory", "url": "https://github.com/triplea-game/triplea/pull/8438#discussion_r546431470", "createdAt": "2020-12-20T20:22:38Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/engine/history/change/units/KillUnits.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package games.strategy.engine.history.change.units;\n+\n+import games.strategy.engine.data.CompositeChange;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.engine.history.change.HistoryChange;\n+import games.strategy.triplea.formatter.MyFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import lombok.Value;\n+import org.apache.commons.text.StringSubstitutor;\n+import org.triplea.java.collections.IntegerMap;\n+\n+/**\n+ * Kills a set of units in a location", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87b7a9ebba72ade584e2b76ddf5d625184dd3cfe"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQzMTc4Nw==", "bodyText": "Does this assume that transported units are always killed? Could we instead make this logic the responsibility of the caller?\nKnowing that transported units are killed is a game-rule detail. This history object therefor not only tracks the history transformation, but it also encodes the rule that transported units are killed. If the caller were to handle this detail, and pass the list of transported units into the killed list, then this class would no longer be aware of that rule detail.", "url": "https://github.com/triplea-game/triplea/pull/8438#discussion_r546431787", "createdAt": "2020-12-20T20:25:28Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/engine/history/change/units/KillUnits.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package games.strategy.engine.history.change.units;\n+\n+import games.strategy.engine.data.CompositeChange;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.engine.history.change.HistoryChange;\n+import games.strategy.triplea.formatter.MyFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import lombok.Value;\n+import org.apache.commons.text.StringSubstitutor;\n+import org.triplea.java.collections.IntegerMap;\n+\n+/**\n+ * Kills a set of units in a location\n+ *\n+ * <p>Adds a history event for the killing\n+ *\n+ * <p>Transforms units to other units if needed. See {@link TransformUnits}\n+ */\n+@Value\n+public class KillUnits implements HistoryChange {\n+\n+  Territory location;\n+  Collection<Unit> killedUnits;\n+  Map<Territory, Collection<Unit>> unloadedUnits = new HashMap<>();\n+  TransformUnits transformUnits;\n+  String messageTemplate;\n+  /** Units that were killed */\n+  Collection<Unit> oldUnits = new ArrayList<>();\n+  /** The units that were created after a transformation */\n+  Collection<Unit> newUnits = new ArrayList<>();\n+\n+  public KillUnits(final Territory location, final Collection<Unit> killedUnits) {\n+    this(location, killedUnits, \"${units} lost in ${territory}\");\n+  }\n+\n+  /** @param messageTemplate ${units} and ${territory} will be replaced in this template */\n+  public KillUnits(\n+      final Territory location, final Collection<Unit> killedUnits, final String messageTemplate) {\n+    this.location = location;\n+    this.messageTemplate = messageTemplate;\n+\n+    // temporarily give the unit maximum damage so that TransformUnits will be able to\n+    // recognize units that need to be transformed when they are killed\n+    final IntegerMap<Unit> originalHits = new IntegerMap<>();\n+    killedUnits.forEach(\n+        unit -> {\n+          originalHits.add(unit, unit.getHits());\n+          unit.setHits(unit.getUnitAttachment().getHitPoints());\n+        });\n+\n+    transformUnits = new TransformUnits(location, killedUnits);\n+\n+    killedUnits.forEach(\n+        unit -> {\n+          unit.setHits(originalHits.getInt(unit));\n+        });\n+\n+    oldUnits.addAll(killedUnits);\n+    // ensure that any units that are being transported are also killed", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87b7a9ebba72ade584e2b76ddf5d625184dd3cfe"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQzMjAyOQ==", "bodyText": "nit, the collection copy and then 'removalAll' can be be avoided, EG:\nthis.killedUnits = oldUnits.stream().filter(oldUnit -> transformedUnits.getOldUnits().contains(oldUnit)).collect(...);", "url": "https://github.com/triplea-game/triplea/pull/8438#discussion_r546432029", "createdAt": "2020-12-20T20:27:10Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/engine/history/change/units/KillUnits.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package games.strategy.engine.history.change.units;\n+\n+import games.strategy.engine.data.CompositeChange;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.engine.history.change.HistoryChange;\n+import games.strategy.triplea.formatter.MyFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import lombok.Value;\n+import org.apache.commons.text.StringSubstitutor;\n+import org.triplea.java.collections.IntegerMap;\n+\n+/**\n+ * Kills a set of units in a location\n+ *\n+ * <p>Adds a history event for the killing\n+ *\n+ * <p>Transforms units to other units if needed. See {@link TransformUnits}\n+ */\n+@Value\n+public class KillUnits implements HistoryChange {\n+\n+  Territory location;\n+  Collection<Unit> killedUnits;\n+  Map<Territory, Collection<Unit>> unloadedUnits = new HashMap<>();\n+  TransformUnits transformUnits;\n+  String messageTemplate;\n+  /** Units that were killed */\n+  Collection<Unit> oldUnits = new ArrayList<>();\n+  /** The units that were created after a transformation */\n+  Collection<Unit> newUnits = new ArrayList<>();\n+\n+  public KillUnits(final Territory location, final Collection<Unit> killedUnits) {\n+    this(location, killedUnits, \"${units} lost in ${territory}\");\n+  }\n+\n+  /** @param messageTemplate ${units} and ${territory} will be replaced in this template */\n+  public KillUnits(\n+      final Territory location, final Collection<Unit> killedUnits, final String messageTemplate) {\n+    this.location = location;\n+    this.messageTemplate = messageTemplate;\n+\n+    // temporarily give the unit maximum damage so that TransformUnits will be able to\n+    // recognize units that need to be transformed when they are killed\n+    final IntegerMap<Unit> originalHits = new IntegerMap<>();\n+    killedUnits.forEach(\n+        unit -> {\n+          originalHits.add(unit, unit.getHits());\n+          unit.setHits(unit.getUnitAttachment().getHitPoints());\n+        });\n+\n+    transformUnits = new TransformUnits(location, killedUnits);\n+\n+    killedUnits.forEach(\n+        unit -> {\n+          unit.setHits(originalHits.getInt(unit));\n+        });\n+\n+    oldUnits.addAll(killedUnits);\n+    // ensure that any units that are being transported are also killed\n+    killedUnits.stream()\n+        .map(unit -> unit.getTransporting(location))\n+        .flatMap(Collection::stream)\n+        .forEach(oldUnits::add);\n+    // any unit that was unloaded during combat phase needs to be removed but it needs to be removed\n+    // from the territory it unloaded to\n+    killedUnits.stream()\n+        .map(Unit::getUnloaded)\n+        .flatMap(Collection::stream)\n+        .forEach(\n+            unloadedUnit -> {\n+              unloadedUnits\n+                  .computeIfAbsent(unloadedUnit.getUnloadedTo(), k -> new ArrayList<>())\n+                  .add(unloadedUnit);\n+              oldUnits.add(unloadedUnit);\n+            });\n+\n+    newUnits.addAll(transformUnits.getNewUnits());\n+\n+    this.killedUnits = new ArrayList<>(oldUnits);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87b7a9ebba72ade584e2b76ddf5d625184dd3cfe"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQzMjMzMQ==", "bodyText": "TransformUnits is possibly too generic of a name. Perhaps we can clarify this by getting the 'Damaged' word in there.\nSuggestions:\n\nDamagedUnitTransformation\nChangeDamagedUnitType", "url": "https://github.com/triplea-game/triplea/pull/8438#discussion_r546432331", "createdAt": "2020-12-20T20:30:13Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/engine/history/change/units/TransformUnits.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package games.strategy.engine.history.change.units;\n+\n+import games.strategy.engine.data.CompositeChange;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.engine.history.change.HistoryChange;\n+import games.strategy.triplea.UnitUtils;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.formatter.MyFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import lombok.Value;\n+import org.triplea.util.Tuple;\n+\n+/**\n+ * Transforms units into other unit types as determined by {@link\n+ * UnitAttachment#getWhenHitPointsDamagedChangesInto()}\n+ */\n+@Value\n+public class TransformUnits implements HistoryChange {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87b7a9ebba72ade584e2b76ddf5d625184dd3cfe"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQzMjM3NA==", "bodyText": "nit, this could use a quick leading comment to summarize what we are doing in this block, help make it easier to understand.\nThat could potentially be done by assigning the variable transformingUnits in this constructor, in which case the helper method would carry that information, eg:\ntransformingUnits = computeUnitTransformations(transformUnits);", "url": "https://github.com/triplea-game/triplea/pull/8438#discussion_r546432374", "createdAt": "2020-12-20T20:30:46Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/engine/history/change/units/TransformUnits.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package games.strategy.engine.history.change.units;\n+\n+import games.strategy.engine.data.CompositeChange;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.engine.history.change.HistoryChange;\n+import games.strategy.triplea.UnitUtils;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.formatter.MyFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import lombok.Value;\n+import org.triplea.util.Tuple;\n+\n+/**\n+ * Transforms units into other unit types as determined by {@link\n+ * UnitAttachment#getWhenHitPointsDamagedChangesInto()}\n+ */\n+@Value\n+public class TransformUnits implements HistoryChange {\n+\n+  Territory location;\n+  /** Map of old unit -> new unit */\n+  Map<Unit, Unit> transformingUnits = new HashMap<>();\n+\n+  CompositeChange attributeChanges = new CompositeChange();\n+\n+  public TransformUnits(final Territory location, final Collection<Unit> transformUnits) {\n+    this.location = location;\n+\n+    for (final Unit unit : transformUnits) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87b7a9ebba72ade584e2b76ddf5d625184dd3cfe"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQzMjU5Nw==", "bodyText": "It seems that transformUnits is conditional and not all the units passed in will be transformed. Named transformUnits,it sounds to me as if all the units would be transforming or already have transformed.\nIs this the list of damaged units? In that case, for consideration, damagedUnits could be a more descriptive name.", "url": "https://github.com/triplea-game/triplea/pull/8438#discussion_r546432597", "createdAt": "2020-12-20T20:33:16Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/engine/history/change/units/TransformUnits.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package games.strategy.engine.history.change.units;\n+\n+import games.strategy.engine.data.CompositeChange;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.engine.history.change.HistoryChange;\n+import games.strategy.triplea.UnitUtils;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.formatter.MyFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import lombok.Value;\n+import org.triplea.util.Tuple;\n+\n+/**\n+ * Transforms units into other unit types as determined by {@link\n+ * UnitAttachment#getWhenHitPointsDamagedChangesInto()}\n+ */\n+@Value\n+public class TransformUnits implements HistoryChange {\n+\n+  Territory location;\n+  /** Map of old unit -> new unit */\n+  Map<Unit, Unit> transformingUnits = new HashMap<>();\n+\n+  CompositeChange attributeChanges = new CompositeChange();\n+\n+  public TransformUnits(final Territory location, final Collection<Unit> transformUnits) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87b7a9ebba72ade584e2b76ddf5d625184dd3cfe"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQzMjcxNA==", "bodyText": "There is a lot going on in this block. Would you mind taking a second look to see if you can make this easier to understand? Let me know if you'd like suggestions or thoughts on how to achieve that, I'll be happy to help.", "url": "https://github.com/triplea-game/triplea/pull/8438#discussion_r546432714", "createdAt": "2020-12-20T20:34:09Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/engine/history/change/units/TransformUnits.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package games.strategy.engine.history.change.units;\n+\n+import games.strategy.engine.data.CompositeChange;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.engine.history.change.HistoryChange;\n+import games.strategy.triplea.UnitUtils;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.formatter.MyFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import lombok.Value;\n+import org.triplea.util.Tuple;\n+\n+/**\n+ * Transforms units into other unit types as determined by {@link\n+ * UnitAttachment#getWhenHitPointsDamagedChangesInto()}\n+ */\n+@Value\n+public class TransformUnits implements HistoryChange {\n+\n+  Territory location;\n+  /** Map of old unit -> new unit */\n+  Map<Unit, Unit> transformingUnits = new HashMap<>();\n+\n+  CompositeChange attributeChanges = new CompositeChange();\n+\n+  public TransformUnits(final Territory location, final Collection<Unit> transformUnits) {\n+    this.location = location;\n+\n+    for (final Unit unit : transformUnits) {\n+\n+      final Map<Integer, Tuple<Boolean, UnitType>> map =\n+          unit.getUnitAttachment().getWhenHitPointsDamagedChangesInto();\n+      if (map.containsKey(unit.getHits())) {\n+        final boolean translateAttributes = map.get(unit.getHits()).getFirst();\n+        final UnitType unitType = map.get(unit.getHits()).getSecond();\n+        final List<Unit> toAdd = unitType.create(1, unit.getOwner());\n+        if (translateAttributes) {\n+          attributeChanges.add(UnitUtils.translateAttributesToOtherUnits(unit, toAdd, location));\n+        }\n+        transformingUnits.put(unit, toAdd.get(0));\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void perform(final IDelegateBridge bridge) {\n+    if (transformingUnits.isEmpty()) {\n+      return;\n+    }\n+\n+    bridge.addChange(\n+        new CompositeChange(\n+            ChangeFactory.addUnits(location, getNewUnits()),\n+            ChangeFactory.removeUnits(location, getOldUnits()),\n+            attributeChanges));\n+\n+    // to reduce the amount of history text, group the transforming units by both the original and\n+    // new unit type\n+    transformingUnits.entrySet().stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87b7a9ebba72ade584e2b76ddf5d625184dd3cfe"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQzMjg2NA==", "bodyText": "nit, unnecessary intermediate variable. Can be a single line\nnew KillUnits(battleSite, killed).perform(bridge);\n\nSide-note: I think the above does reveal a code smell where the bridge should be in control of when the change happens. EG:\nbridge.addChange(new KillUnits(battleSite, killed);", "url": "https://github.com/triplea-game/triplea/pull/8438#discussion_r546432864", "createdAt": "2020-12-20T20:35:31Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/AirBattle.java", "diffHunk": "@@ -910,11 +911,9 @@ private void remove(\n       return;\n     }\n     final Collection<Unit> killed = getUnitsWithDependents(killedUnits);\n-    final Change killedChange = ChangeFactory.removeUnits(battleSite, killed);\n-    final String transcriptText =\n-        MyFormatter.unitsToText(killed) + \" lost in \" + battleSite.getName();\n-    bridge.getHistoryWriter().addChildToEvent(transcriptText, new ArrayList<>(killed));\n-    bridge.addChange(killedChange);\n+    final KillUnits killUnits = new KillUnits(battleSite, killed);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87b7a9ebba72ade584e2b76ddf5d625184dd3cfe"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQzMzI0OA==", "bodyText": "The formatting of the message pattern being a responsibility of the caller is concerning to me. This creates a coupling between the data and the formatting strings used internally by 'killUnits' and the caller. The caller must be aware of the string type. It does seem like the formatted string could become an implementation detail of KillUnits by adding a third constructor, eg:\nnew KillUnits(battleSite, killed, currentTypeAa)\nAt that point too I'd recommend to add a @Builder on that constructor so that the meaning of the parameters is more clear when reading the calling context.\nWDYT?", "url": "https://github.com/triplea-game/triplea/pull/8438#discussion_r546433248", "createdAt": "2020-12-20T20:38:25Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/StrategicBombingRaidBattle.java", "diffHunk": "@@ -663,18 +658,13 @@ private void removeAaHits(\n       final IDelegateBridge bridge, final CasualtyDetails casualties, final String currentTypeAa) {\n     final List<Unit> killed = casualties.getKilled();\n     if (!killed.isEmpty()) {\n-      bridge\n-          .getHistoryWriter()\n-          .addChildToEvent(\n-              MyFormatter.unitsToTextNoOwner(killed) + \" killed by \" + currentTypeAa,\n-              new ArrayList<>(killed));\n       final IntegerMap<UnitType> costs = TuvUtils.getCostsForTuv(attacker, gameData);\n       final int tuvLostAttacker = TuvUtils.getTuv(killed, attacker, costs, gameData);\n       attackerLostTuv += tuvLostAttacker;\n       // attackingUnits.removeAll(casualties);\n       removeAttackers(killed, false);\n-      final Change remove = ChangeFactory.removeUnits(battleSite, killed);\n-      bridge.addChange(remove);\n+      new KillUnits(battleSite, killed, \"${units} killed by \" + currentTypeAa + \" in ${territory}\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87b7a9ebba72ade584e2b76ddf5d625184dd3cfe"}, "originalPosition": 58}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7e5d98854918d1d95af01b7bb78dc3cc6ed24aa0", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/7e5d98854918d1d95af01b7bb78dc3cc6ed24aa0", "committedDate": "2020-12-20T22:55:06Z", "message": "Rename classes, add better comments, cleanup code\n\nAdded HistoryChangeFactory to create the history change objects.  This\nis similar to the ChangeFactory."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU2ODIzNzc3", "url": "https://github.com/triplea-game/triplea/pull/8438#pullrequestreview-556823777", "createdAt": "2020-12-22T05:15:30Z", "commit": {"oid": "7e5d98854918d1d95af01b7bb78dc3cc6ed24aa0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQwNToxNTozMFrOIJup1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQwNToxNTozMFrOIJup1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzA3MjQ2OQ==", "bodyText": "A quick javadoc could perhaps be useful to explain what constitutes a history change.\nI wonder though, wouldn't almost any change be eligible for the history? Is there a (ideally) a 1:1 correspondence between history change objects and game state changes? Are we going to have \"peer\" change objects in this manner?", "url": "https://github.com/triplea-game/triplea/pull/8438#discussion_r547072469", "createdAt": "2020-12-22T05:15:30Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/engine/history/change/HistoryChange.java", "diffHunk": "@@ -0,0 +1,8 @@\n+package games.strategy.engine.history.change;\n+\n+import games.strategy.engine.delegate.IDelegateBridge;\n+\n+public interface HistoryChange {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e5d98854918d1d95af01b7bb78dc3cc6ed24aa0"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "62b6c468a031c43dba57d58a9f6a52ad1b0c1659", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/62b6c468a031c43dba57d58a9f6a52ad1b0c1659", "committedDate": "2020-12-22T23:04:48Z", "message": "Add an invert method to HistoryChange"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU4NzUxODQw", "url": "https://github.com/triplea-game/triplea/pull/8438#pullrequestreview-558751840", "createdAt": "2020-12-25T04:26:22Z", "commit": {"oid": "62b6c468a031c43dba57d58a9f6a52ad1b0c1659"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yNVQwNDoyNjoyMlrOILX8bg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yNVQwNDozMTowM1rOILX-yA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc5NzU1MA==", "bodyText": "What other history change objects do you foresee? How many might we have total and will a single factory for them all scale well?", "url": "https://github.com/triplea-game/triplea/pull/8438#discussion_r548797550", "createdAt": "2020-12-25T04:26:22Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/engine/history/change/HistoryChangeFactory.java", "diffHunk": "@@ -0,0 +1,28 @@\n+package games.strategy.engine.history.change;\n+\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.history.change.units.RemoveUnits;\n+import games.strategy.engine.history.change.units.TransformDamagedUnits;\n+import java.util.Collection;\n+import lombok.experimental.UtilityClass;\n+\n+@UtilityClass\n+public class HistoryChangeFactory {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62b6c468a031c43dba57d58a9f6a52ad1b0c1659"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc5Nzg2Mw==", "bodyText": "side-note, we're trying to kill Tuple and replace it with value objects. For example TotalPowerAndRolls used to be a Tuple<Integer,Integer>,that conversion certainly lead to more legible code. In this case, the Boolean is very cryptic, it's kinda hard to know what the represents at first glance.", "url": "https://github.com/triplea-game/triplea/pull/8438#discussion_r548797863", "createdAt": "2020-12-25T04:28:38Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/engine/history/change/units/TransformDamagedUnits.java", "diffHunk": "@@ -0,0 +1,127 @@\n+package games.strategy.engine.history.change.units;\n+\n+import games.strategy.engine.data.Change;\n+import games.strategy.engine.data.CompositeChange;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.engine.history.change.HistoryChange;\n+import games.strategy.triplea.UnitUtils;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.formatter.MyFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import lombok.AccessLevel;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.Value;\n+import lombok.experimental.FieldDefaults;\n+import org.triplea.util.Tuple;\n+\n+/**\n+ * Transforms units into other unit types as determined by {@link\n+ * UnitAttachment#getWhenHitPointsDamagedChangesInto()}\n+ */\n+@FieldDefaults(makeFinal = true, level = AccessLevel.PRIVATE)\n+@Getter\n+@EqualsAndHashCode\n+public class TransformDamagedUnits implements HistoryChange {\n+\n+  CompositeChange change = new CompositeChange();\n+  Territory location;\n+  /** Map of old unit -> new unit */\n+  Map<Unit, Unit> transformingUnits = new HashMap<>();\n+\n+  CompositeChange attributeChanges = new CompositeChange();\n+\n+  public TransformDamagedUnits(final Territory location, final Collection<Unit> damagedUnits) {\n+    this.location = location;\n+\n+    // check if each of the damaged units are supposed to change when they take damage\n+    // if it is supposed to change, create the new unit and translate attributes from the old unit\n+    // to the new unit\n+    for (final Unit unit : damagedUnits) {\n+      final Map<Integer, Tuple<Boolean, UnitType>> map =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62b6c468a031c43dba57d58a9f6a52ad1b0c1659"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc5ODE1Mg==", "bodyText": "I do wonder if these objects should be suffixed with HistoryChange so that they are not quite so context dependent. WDYT @trevan ?", "url": "https://github.com/triplea-game/triplea/pull/8438#discussion_r548798152", "createdAt": "2020-12-25T04:31:03Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/engine/history/change/units/RemoveUnits.java", "diffHunk": "@@ -0,0 +1,136 @@\n+package games.strategy.engine.history.change.units;\n+\n+import games.strategy.engine.data.Change;\n+import games.strategy.engine.data.CompositeChange;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.engine.history.change.HistoryChange;\n+import games.strategy.triplea.formatter.MyFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import lombok.AccessLevel;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.experimental.FieldDefaults;\n+import org.apache.commons.text.StringSubstitutor;\n+import org.triplea.java.collections.IntegerMap;\n+\n+/**\n+ * Removes a set of units in a location and adds a history event\n+ *\n+ * <p>Transforms units to other units if needed. See {@link TransformDamagedUnits}\n+ */\n+@FieldDefaults(makeFinal = true, level = AccessLevel.PRIVATE)\n+@Getter\n+@EqualsAndHashCode\n+public class RemoveUnits implements HistoryChange {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62b6c468a031c43dba57d58a9f6a52ad1b0c1659"}, "originalPosition": 32}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d7834a450aed8a873f66f3cc44d8e1c3af3f002a", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/d7834a450aed8a873f66f3cc44d8e1c3af3f002a", "committedDate": "2020-12-26T19:03:17Z", "message": "Add HistoryChange suffix to classes"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3815, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}