{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI5MjA1MDQ0", "number": 8318, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQwMDowNzo1NFrOE-dNeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQwMzoyMjowNVrOE-e3Vw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzOTI1NzU0OnYy", "diffSide": "RIGHT", "path": "game-core/src/test/java/games/strategy/triplea/delegate/MockDelegateBridge.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQwMDowNzo1NFrOH7oc9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQwMjowNzowNFrOH7ptjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjI5MDgwNw==", "bodyText": "I modified this because the order of elements was wrong.  It is (expected, actual, description) and it is being used as (actual, expected, description).  I switched to assertThat while modifying this.", "url": "https://github.com/triplea-game/triplea/pull/8318#discussion_r532290807", "createdAt": "2020-11-30T00:07:54Z", "author": {"login": "trevan"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/MockDelegateBridge.java", "diffHunk": "@@ -58,7 +59,7 @@ public static IDelegateBridge newDelegateBridge(final GamePlayer gamePlayer) {\n   public static Answer<int[]> withValues(final int... values) {\n     return invocation -> {\n       final int count = invocation.getArgument(1);\n-      assertEquals(values.length, count, \"count of requested random values does not match\");\n+      assertThat(\"count of requested random values does not match\", values.length, is(count));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6709c140510a07443a8eade65e02b669344aef70"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjMwMzIzMg==", "bodyText": "Minor, there is a IsArrayWithSize.arrayWithSize() matcher that can be used here.\nSide-note/observation: It's really odd for there to be an assertion in mock code to begin with \ud83e\udd14", "url": "https://github.com/triplea-game/triplea/pull/8318#discussion_r532303232", "createdAt": "2020-11-30T01:26:29Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/MockDelegateBridge.java", "diffHunk": "@@ -58,7 +59,7 @@ public static IDelegateBridge newDelegateBridge(final GamePlayer gamePlayer) {\n   public static Answer<int[]> withValues(final int... values) {\n     return invocation -> {\n       final int count = invocation.getArgument(1);\n-      assertEquals(values.length, count, \"count of requested random values does not match\");\n+      assertThat(\"count of requested random values does not match\", values.length, is(count));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjI5MDgwNw=="}, "originalCommit": {"oid": "6709c140510a07443a8eade65e02b669344aef70"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjMxMTQzNg==", "bodyText": "That doesn't work with non-object types.  I'd have to convert values from an int[] to an Integer[].", "url": "https://github.com/triplea-game/triplea/pull/8318#discussion_r532311436", "createdAt": "2020-11-30T02:07:04Z", "author": {"login": "trevan"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/MockDelegateBridge.java", "diffHunk": "@@ -58,7 +59,7 @@ public static IDelegateBridge newDelegateBridge(final GamePlayer gamePlayer) {\n   public static Answer<int[]> withValues(final int... values) {\n     return invocation -> {\n       final int count = invocation.getArgument(1);\n-      assertEquals(values.length, count, \"count of requested random values does not match\");\n+      assertThat(\"count of requested random values does not match\", values.length, is(count));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjI5MDgwNw=="}, "originalCommit": {"oid": "6709c140510a07443a8eade65e02b669344aef70"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzOTM1MzE0OnYy", "diffSide": "RIGHT", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/casualty/AaCasualtySelectorTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQwMToyNzoxNFrOH7pOLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQwMToyNzoxNFrOH7pOLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjMwMzQwNQ==", "bodyText": "I want to say it's pretty amazing there was no coverage on this before, then again with 27% test coverage, maybe not so much : )\nThanks for adding coverage!", "url": "https://github.com/triplea-game/triplea/pull/8318#discussion_r532303405", "createdAt": "2020-11-30T01:27:14Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/casualty/AaCasualtySelectorTest.java", "diffHunk": "@@ -417,4 +419,606 @@ void hitsLessThanPlanesKillsAccordingToTheRolledDice() {\n           is(List.of(planes.get(0), planes.get(2), planes.get(4))));\n     }\n   }\n+\n+  @Nested\n+  class LowLuckCasualties {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "275273930a55eef32bec4fbf2c3dc97c1c93b940"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzOTM1NzMwOnYy", "diffSide": "RIGHT", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/casualty/AaCasualtySelectorTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQwMTozMDowMFrOH7pQUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQwMTozMDowMFrOH7pQUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjMwMzk1NA==", "bodyText": "observation, the setup is very beefy, lots of test-state is established. If we add a few more tests like this it will be more worthwhile to invest in easier setup. Ideally a test case can have relatively minimal fixture code around it. Just noting that I'm not sure this pattern will scale super gracefully with a lot more tests.", "url": "https://github.com/triplea-game/triplea/pull/8318#discussion_r532303954", "createdAt": "2020-11-30T01:30:00Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/casualty/AaCasualtySelectorTest.java", "diffHunk": "@@ -417,4 +419,606 @@ void hitsLessThanPlanesKillsAccordingToTheRolledDice() {\n           is(List.of(planes.get(0), planes.get(2), planes.get(4))));\n     }\n   }\n+\n+  @Nested\n+  class LowLuckCasualties {\n+    private IDelegateBridge bridge;\n+    @Mock private UnitType otherPlaneUnitType;\n+    @Mock private UnitType otherPlaneMultiHpUnitType;\n+    @Mock private UnitType powerfulAaUnitType;\n+\n+    @BeforeEach\n+    void setupPlayers() {\n+      when(hitPlayer.getName()).thenReturn(\"Hit Player\");\n+    }\n+\n+    @BeforeEach\n+    void initializeGameData() {\n+      gameData =\n+          givenGameData()\n+              .withDiceSides(6)\n+              .withEditMode(false)\n+              .withChooseAaCasualties(false)\n+              .withLowLuck(true)\n+              .build();\n+      bridge = mock(IDelegateBridge.class);\n+      when(bridge.getData()).thenReturn(gameData);\n+\n+      aaUnitType = new UnitType(\"aaUnitType\", gameData);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "275273930a55eef32bec4fbf2c3dc97c1c93b940"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzOTM1ODYzOnYy", "diffSide": "RIGHT", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/casualty/AaCasualtySelectorTest.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQwMTozMDo1MFrOH7pQ_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQwMzoyMzozOFrOH7qvNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjMwNDEyNg==", "bodyText": "This has been asserted a few times, is there any way that exactly one of these tests would have this assertion fail and not the others, or is it more the case that if one fails they all would fail?", "url": "https://github.com/triplea-game/triplea/pull/8318#discussion_r532304126", "createdAt": "2020-11-30T01:30:50Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/casualty/AaCasualtySelectorTest.java", "diffHunk": "@@ -417,4 +419,606 @@ void hitsLessThanPlanesKillsAccordingToTheRolledDice() {\n           is(List.of(planes.get(0), planes.get(2), planes.get(4))));\n     }\n   }\n+\n+  @Nested\n+  class LowLuckCasualties {\n+    private IDelegateBridge bridge;\n+    @Mock private UnitType otherPlaneUnitType;\n+    @Mock private UnitType otherPlaneMultiHpUnitType;\n+    @Mock private UnitType powerfulAaUnitType;\n+\n+    @BeforeEach\n+    void setupPlayers() {\n+      when(hitPlayer.getName()).thenReturn(\"Hit Player\");\n+    }\n+\n+    @BeforeEach\n+    void initializeGameData() {\n+      gameData =\n+          givenGameData()\n+              .withDiceSides(6)\n+              .withEditMode(false)\n+              .withChooseAaCasualties(false)\n+              .withLowLuck(true)\n+              .build();\n+      bridge = mock(IDelegateBridge.class);\n+      when(bridge.getData()).thenReturn(gameData);\n+\n+      aaUnitType = new UnitType(\"aaUnitType\", gameData);\n+      final UnitAttachment aaUnitAttachment =\n+          new UnitAttachment(\"aaUnitAttachment\", aaUnitType, gameData);\n+      aaUnitType.addAttachment(UNIT_ATTACHMENT_NAME, aaUnitAttachment);\n+\n+      damageableAaUnitType = new UnitType(\"damageableAaUnitType\", gameData);\n+      final UnitAttachment damageableAaUnitAttachment =\n+          new UnitAttachment(\"damageableAaUnitAttachment\", damageableAaUnitType, gameData);\n+      damageableAaUnitAttachment.setDamageableAa(true);\n+      damageableAaUnitType.addAttachment(UNIT_ATTACHMENT_NAME, damageableAaUnitAttachment);\n+\n+      powerfulAaUnitType = new UnitType(\"powerfulAaUnitType\", gameData);\n+      final UnitAttachment powerfulAaUnitAttachment =\n+          new UnitAttachment(\"powerfulAaUnitAttachment\", powerfulAaUnitType, gameData);\n+      powerfulAaUnitAttachment.setAttackAa(5);\n+      powerfulAaUnitType.addAttachment(UNIT_ATTACHMENT_NAME, powerfulAaUnitAttachment);\n+\n+      planeUnitType = new UnitType(\"planeUnitType\", gameData);\n+      final UnitAttachment planeUnitAttachment =\n+          new UnitAttachment(\"planeUnitAttachment\", aaUnitType, gameData);\n+      planeUnitType.addAttachment(UNIT_ATTACHMENT_NAME, planeUnitAttachment);\n+\n+      otherPlaneUnitType = new UnitType(\"otherPlaneUnitType\", gameData);\n+      final UnitAttachment otherPlaneUnitAttachment =\n+          new UnitAttachment(\"otherPlaneUnitAttachment\", aaUnitType, gameData);\n+      otherPlaneUnitType.addAttachment(UNIT_ATTACHMENT_NAME, otherPlaneUnitAttachment);\n+\n+      planeMultiHpUnitType = new UnitType(\"planeMultiHpUnitType\", gameData);\n+      final UnitAttachment planeMultiHpUnitAttachment =\n+          new UnitAttachment(\"planeMultiHpUnitAttachment\", aaUnitType, gameData);\n+      planeMultiHpUnitAttachment.setHitPoints(2);\n+      planeMultiHpUnitType.addAttachment(UNIT_ATTACHMENT_NAME, planeMultiHpUnitAttachment);\n+\n+      otherPlaneMultiHpUnitType = new UnitType(\"otherPlaneMultiHpUnitType\", gameData);\n+      final UnitAttachment otherPlaneMultiHpUnitAttachment =\n+          new UnitAttachment(\"otherPlaneMultiHpUnitAttachment\", aaUnitType, gameData);\n+      otherPlaneMultiHpUnitAttachment.setHitPoints(2);\n+      otherPlaneMultiHpUnitType.addAttachment(\n+          UNIT_ATTACHMENT_NAME, otherPlaneMultiHpUnitAttachment);\n+    }\n+\n+    @Test\n+    void oneTypeOfPlaneWithAmountEqualToDiceSides() {\n+\n+      final List<Unit> planes = planeUnitType.createTemp(6, hitPlayer);\n+\n+      final CasualtyDetails details =\n+          AaCasualtySelector.getAaCasualties(\n+              planes,\n+              aaUnitType.createTemp(1, aaPlayer),\n+              mock(CombatValue.class),\n+              givenAaCombatValue(),\n+              \"text\",\n+              // low luck would have 1 hit because 6 power / 6 dice side\n+              givenDiceRollWithHitSequence(true),\n+              bridge,\n+              hitPlayer,\n+              UUID.randomUUID(),\n+              mock(Territory.class));\n+\n+      assertThat(details.getKilled(), hasSize(1));\n+      assertThat(\n+          \"The planes have 1 hp so there can't be damaged planes\",\n+          details.getDamaged(),\n+          is(empty()));\n+    }\n+\n+    @Test\n+    void twoTypesOfPlanesAndBothHaveAmountEqualToDiceSides() {\n+\n+      final List<Unit> planes = planeUnitType.createTemp(6, hitPlayer);\n+      planes.addAll(otherPlaneUnitType.createTemp(6, hitPlayer));\n+\n+      final CasualtyDetails details =\n+          AaCasualtySelector.getAaCasualties(\n+              planes,\n+              aaUnitType.createTemp(1, aaPlayer),\n+              mock(CombatValue.class),\n+              givenAaCombatValue(),\n+              \"text\",\n+              // low luck would have 2 hits because 12 power / 6 dice side\n+              givenDiceRollWithHitSequence(true, true),\n+              bridge,\n+              hitPlayer,\n+              UUID.randomUUID(),\n+              mock(Territory.class));\n+\n+      assertThat(details.getKilled(), hasSize(2));\n+      assertThat(\n+          \"One of each plane type should be killed\",\n+          details.getKilled().stream().map(Unit::getType).collect(Collectors.toList()),\n+          containsInAnyOrder(planeUnitType, otherPlaneUnitType));\n+\n+      assertThat(\n+          \"The planes have 1 hp so there can't be damaged planes\",\n+          details.getDamaged(),\n+          is(empty()));\n+    }\n+\n+    @Test\n+    void twoTypesOfPlanesAndTogetherHaveAmountEqualToDiceSides() {\n+\n+      // need to randomly pick a plane to kill\n+      whenGetRandom(bridge).thenAnswer(withValues(1));\n+\n+      final List<Unit> planes = planeUnitType.createTemp(3, hitPlayer);\n+      planes.addAll(otherPlaneUnitType.createTemp(3, hitPlayer));\n+\n+      final CasualtyDetails details =\n+          AaCasualtySelector.getAaCasualties(\n+              planes,\n+              aaUnitType.createTemp(1, aaPlayer),\n+              mock(CombatValue.class),\n+              givenAaCombatValue(),\n+              \"text\",\n+              // low luck would have 1 hits because 6 power / 6 dice side\n+              givenDiceRollWithHitSequence(true),\n+              bridge,\n+              hitPlayer,\n+              UUID.randomUUID(),\n+              mock(Territory.class));\n+\n+      assertThat(details.getKilled(), hasSize(1));\n+      assertThat(\n+          \"The otherPlaneUnitType is killed because it's unitType is sorted before planeUnitType \"\n+              + \"(it sorts by unit type name) and there are 3 of them and the random selection was \"\n+              + \"for the second unit in the list.\",\n+          details.getKilled().stream().map(Unit::getType).collect(Collectors.toList()),\n+          containsInAnyOrder(otherPlaneUnitType));\n+\n+      assertThat(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "275273930a55eef32bec4fbf2c3dc97c1c93b940"}, "originalPosition": 217}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjMwODQ2OQ==", "bodyText": "If there are no multi-hp units and the aa can't damage, then I expect details.getDamaged() to always be empty.  But the code is really confusing and I wasn't exactly sure it would work that way.  Also, as someone refactors it, they could mess up and cause items to be damaged instead of being killed.  So, I put the assertion in each test to ensure that they don't get added to the damage list.", "url": "https://github.com/triplea-game/triplea/pull/8318#discussion_r532308469", "createdAt": "2020-11-30T01:52:25Z", "author": {"login": "trevan"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/casualty/AaCasualtySelectorTest.java", "diffHunk": "@@ -417,4 +419,606 @@ void hitsLessThanPlanesKillsAccordingToTheRolledDice() {\n           is(List.of(planes.get(0), planes.get(2), planes.get(4))));\n     }\n   }\n+\n+  @Nested\n+  class LowLuckCasualties {\n+    private IDelegateBridge bridge;\n+    @Mock private UnitType otherPlaneUnitType;\n+    @Mock private UnitType otherPlaneMultiHpUnitType;\n+    @Mock private UnitType powerfulAaUnitType;\n+\n+    @BeforeEach\n+    void setupPlayers() {\n+      when(hitPlayer.getName()).thenReturn(\"Hit Player\");\n+    }\n+\n+    @BeforeEach\n+    void initializeGameData() {\n+      gameData =\n+          givenGameData()\n+              .withDiceSides(6)\n+              .withEditMode(false)\n+              .withChooseAaCasualties(false)\n+              .withLowLuck(true)\n+              .build();\n+      bridge = mock(IDelegateBridge.class);\n+      when(bridge.getData()).thenReturn(gameData);\n+\n+      aaUnitType = new UnitType(\"aaUnitType\", gameData);\n+      final UnitAttachment aaUnitAttachment =\n+          new UnitAttachment(\"aaUnitAttachment\", aaUnitType, gameData);\n+      aaUnitType.addAttachment(UNIT_ATTACHMENT_NAME, aaUnitAttachment);\n+\n+      damageableAaUnitType = new UnitType(\"damageableAaUnitType\", gameData);\n+      final UnitAttachment damageableAaUnitAttachment =\n+          new UnitAttachment(\"damageableAaUnitAttachment\", damageableAaUnitType, gameData);\n+      damageableAaUnitAttachment.setDamageableAa(true);\n+      damageableAaUnitType.addAttachment(UNIT_ATTACHMENT_NAME, damageableAaUnitAttachment);\n+\n+      powerfulAaUnitType = new UnitType(\"powerfulAaUnitType\", gameData);\n+      final UnitAttachment powerfulAaUnitAttachment =\n+          new UnitAttachment(\"powerfulAaUnitAttachment\", powerfulAaUnitType, gameData);\n+      powerfulAaUnitAttachment.setAttackAa(5);\n+      powerfulAaUnitType.addAttachment(UNIT_ATTACHMENT_NAME, powerfulAaUnitAttachment);\n+\n+      planeUnitType = new UnitType(\"planeUnitType\", gameData);\n+      final UnitAttachment planeUnitAttachment =\n+          new UnitAttachment(\"planeUnitAttachment\", aaUnitType, gameData);\n+      planeUnitType.addAttachment(UNIT_ATTACHMENT_NAME, planeUnitAttachment);\n+\n+      otherPlaneUnitType = new UnitType(\"otherPlaneUnitType\", gameData);\n+      final UnitAttachment otherPlaneUnitAttachment =\n+          new UnitAttachment(\"otherPlaneUnitAttachment\", aaUnitType, gameData);\n+      otherPlaneUnitType.addAttachment(UNIT_ATTACHMENT_NAME, otherPlaneUnitAttachment);\n+\n+      planeMultiHpUnitType = new UnitType(\"planeMultiHpUnitType\", gameData);\n+      final UnitAttachment planeMultiHpUnitAttachment =\n+          new UnitAttachment(\"planeMultiHpUnitAttachment\", aaUnitType, gameData);\n+      planeMultiHpUnitAttachment.setHitPoints(2);\n+      planeMultiHpUnitType.addAttachment(UNIT_ATTACHMENT_NAME, planeMultiHpUnitAttachment);\n+\n+      otherPlaneMultiHpUnitType = new UnitType(\"otherPlaneMultiHpUnitType\", gameData);\n+      final UnitAttachment otherPlaneMultiHpUnitAttachment =\n+          new UnitAttachment(\"otherPlaneMultiHpUnitAttachment\", aaUnitType, gameData);\n+      otherPlaneMultiHpUnitAttachment.setHitPoints(2);\n+      otherPlaneMultiHpUnitType.addAttachment(\n+          UNIT_ATTACHMENT_NAME, otherPlaneMultiHpUnitAttachment);\n+    }\n+\n+    @Test\n+    void oneTypeOfPlaneWithAmountEqualToDiceSides() {\n+\n+      final List<Unit> planes = planeUnitType.createTemp(6, hitPlayer);\n+\n+      final CasualtyDetails details =\n+          AaCasualtySelector.getAaCasualties(\n+              planes,\n+              aaUnitType.createTemp(1, aaPlayer),\n+              mock(CombatValue.class),\n+              givenAaCombatValue(),\n+              \"text\",\n+              // low luck would have 1 hit because 6 power / 6 dice side\n+              givenDiceRollWithHitSequence(true),\n+              bridge,\n+              hitPlayer,\n+              UUID.randomUUID(),\n+              mock(Territory.class));\n+\n+      assertThat(details.getKilled(), hasSize(1));\n+      assertThat(\n+          \"The planes have 1 hp so there can't be damaged planes\",\n+          details.getDamaged(),\n+          is(empty()));\n+    }\n+\n+    @Test\n+    void twoTypesOfPlanesAndBothHaveAmountEqualToDiceSides() {\n+\n+      final List<Unit> planes = planeUnitType.createTemp(6, hitPlayer);\n+      planes.addAll(otherPlaneUnitType.createTemp(6, hitPlayer));\n+\n+      final CasualtyDetails details =\n+          AaCasualtySelector.getAaCasualties(\n+              planes,\n+              aaUnitType.createTemp(1, aaPlayer),\n+              mock(CombatValue.class),\n+              givenAaCombatValue(),\n+              \"text\",\n+              // low luck would have 2 hits because 12 power / 6 dice side\n+              givenDiceRollWithHitSequence(true, true),\n+              bridge,\n+              hitPlayer,\n+              UUID.randomUUID(),\n+              mock(Territory.class));\n+\n+      assertThat(details.getKilled(), hasSize(2));\n+      assertThat(\n+          \"One of each plane type should be killed\",\n+          details.getKilled().stream().map(Unit::getType).collect(Collectors.toList()),\n+          containsInAnyOrder(planeUnitType, otherPlaneUnitType));\n+\n+      assertThat(\n+          \"The planes have 1 hp so there can't be damaged planes\",\n+          details.getDamaged(),\n+          is(empty()));\n+    }\n+\n+    @Test\n+    void twoTypesOfPlanesAndTogetherHaveAmountEqualToDiceSides() {\n+\n+      // need to randomly pick a plane to kill\n+      whenGetRandom(bridge).thenAnswer(withValues(1));\n+\n+      final List<Unit> planes = planeUnitType.createTemp(3, hitPlayer);\n+      planes.addAll(otherPlaneUnitType.createTemp(3, hitPlayer));\n+\n+      final CasualtyDetails details =\n+          AaCasualtySelector.getAaCasualties(\n+              planes,\n+              aaUnitType.createTemp(1, aaPlayer),\n+              mock(CombatValue.class),\n+              givenAaCombatValue(),\n+              \"text\",\n+              // low luck would have 1 hits because 6 power / 6 dice side\n+              givenDiceRollWithHitSequence(true),\n+              bridge,\n+              hitPlayer,\n+              UUID.randomUUID(),\n+              mock(Territory.class));\n+\n+      assertThat(details.getKilled(), hasSize(1));\n+      assertThat(\n+          \"The otherPlaneUnitType is killed because it's unitType is sorted before planeUnitType \"\n+              + \"(it sorts by unit type name) and there are 3 of them and the random selection was \"\n+              + \"for the second unit in the list.\",\n+          details.getKilled().stream().map(Unit::getType).collect(Collectors.toList()),\n+          containsInAnyOrder(otherPlaneUnitType));\n+\n+      assertThat(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjMwNDEyNg=="}, "originalCommit": {"oid": "275273930a55eef32bec4fbf2c3dc97c1c93b940"}, "originalPosition": 217}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjMyODI0Nw==", "bodyText": "Okay, a heuristic for good tests is that they are independent. This means if you make a change then you wouldn't break all tests, just the specific ones regarding what was changed (which should be relatively targeted).", "url": "https://github.com/triplea-game/triplea/pull/8318#discussion_r532328247", "createdAt": "2020-11-30T03:23:38Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/casualty/AaCasualtySelectorTest.java", "diffHunk": "@@ -417,4 +419,606 @@ void hitsLessThanPlanesKillsAccordingToTheRolledDice() {\n           is(List.of(planes.get(0), planes.get(2), planes.get(4))));\n     }\n   }\n+\n+  @Nested\n+  class LowLuckCasualties {\n+    private IDelegateBridge bridge;\n+    @Mock private UnitType otherPlaneUnitType;\n+    @Mock private UnitType otherPlaneMultiHpUnitType;\n+    @Mock private UnitType powerfulAaUnitType;\n+\n+    @BeforeEach\n+    void setupPlayers() {\n+      when(hitPlayer.getName()).thenReturn(\"Hit Player\");\n+    }\n+\n+    @BeforeEach\n+    void initializeGameData() {\n+      gameData =\n+          givenGameData()\n+              .withDiceSides(6)\n+              .withEditMode(false)\n+              .withChooseAaCasualties(false)\n+              .withLowLuck(true)\n+              .build();\n+      bridge = mock(IDelegateBridge.class);\n+      when(bridge.getData()).thenReturn(gameData);\n+\n+      aaUnitType = new UnitType(\"aaUnitType\", gameData);\n+      final UnitAttachment aaUnitAttachment =\n+          new UnitAttachment(\"aaUnitAttachment\", aaUnitType, gameData);\n+      aaUnitType.addAttachment(UNIT_ATTACHMENT_NAME, aaUnitAttachment);\n+\n+      damageableAaUnitType = new UnitType(\"damageableAaUnitType\", gameData);\n+      final UnitAttachment damageableAaUnitAttachment =\n+          new UnitAttachment(\"damageableAaUnitAttachment\", damageableAaUnitType, gameData);\n+      damageableAaUnitAttachment.setDamageableAa(true);\n+      damageableAaUnitType.addAttachment(UNIT_ATTACHMENT_NAME, damageableAaUnitAttachment);\n+\n+      powerfulAaUnitType = new UnitType(\"powerfulAaUnitType\", gameData);\n+      final UnitAttachment powerfulAaUnitAttachment =\n+          new UnitAttachment(\"powerfulAaUnitAttachment\", powerfulAaUnitType, gameData);\n+      powerfulAaUnitAttachment.setAttackAa(5);\n+      powerfulAaUnitType.addAttachment(UNIT_ATTACHMENT_NAME, powerfulAaUnitAttachment);\n+\n+      planeUnitType = new UnitType(\"planeUnitType\", gameData);\n+      final UnitAttachment planeUnitAttachment =\n+          new UnitAttachment(\"planeUnitAttachment\", aaUnitType, gameData);\n+      planeUnitType.addAttachment(UNIT_ATTACHMENT_NAME, planeUnitAttachment);\n+\n+      otherPlaneUnitType = new UnitType(\"otherPlaneUnitType\", gameData);\n+      final UnitAttachment otherPlaneUnitAttachment =\n+          new UnitAttachment(\"otherPlaneUnitAttachment\", aaUnitType, gameData);\n+      otherPlaneUnitType.addAttachment(UNIT_ATTACHMENT_NAME, otherPlaneUnitAttachment);\n+\n+      planeMultiHpUnitType = new UnitType(\"planeMultiHpUnitType\", gameData);\n+      final UnitAttachment planeMultiHpUnitAttachment =\n+          new UnitAttachment(\"planeMultiHpUnitAttachment\", aaUnitType, gameData);\n+      planeMultiHpUnitAttachment.setHitPoints(2);\n+      planeMultiHpUnitType.addAttachment(UNIT_ATTACHMENT_NAME, planeMultiHpUnitAttachment);\n+\n+      otherPlaneMultiHpUnitType = new UnitType(\"otherPlaneMultiHpUnitType\", gameData);\n+      final UnitAttachment otherPlaneMultiHpUnitAttachment =\n+          new UnitAttachment(\"otherPlaneMultiHpUnitAttachment\", aaUnitType, gameData);\n+      otherPlaneMultiHpUnitAttachment.setHitPoints(2);\n+      otherPlaneMultiHpUnitType.addAttachment(\n+          UNIT_ATTACHMENT_NAME, otherPlaneMultiHpUnitAttachment);\n+    }\n+\n+    @Test\n+    void oneTypeOfPlaneWithAmountEqualToDiceSides() {\n+\n+      final List<Unit> planes = planeUnitType.createTemp(6, hitPlayer);\n+\n+      final CasualtyDetails details =\n+          AaCasualtySelector.getAaCasualties(\n+              planes,\n+              aaUnitType.createTemp(1, aaPlayer),\n+              mock(CombatValue.class),\n+              givenAaCombatValue(),\n+              \"text\",\n+              // low luck would have 1 hit because 6 power / 6 dice side\n+              givenDiceRollWithHitSequence(true),\n+              bridge,\n+              hitPlayer,\n+              UUID.randomUUID(),\n+              mock(Territory.class));\n+\n+      assertThat(details.getKilled(), hasSize(1));\n+      assertThat(\n+          \"The planes have 1 hp so there can't be damaged planes\",\n+          details.getDamaged(),\n+          is(empty()));\n+    }\n+\n+    @Test\n+    void twoTypesOfPlanesAndBothHaveAmountEqualToDiceSides() {\n+\n+      final List<Unit> planes = planeUnitType.createTemp(6, hitPlayer);\n+      planes.addAll(otherPlaneUnitType.createTemp(6, hitPlayer));\n+\n+      final CasualtyDetails details =\n+          AaCasualtySelector.getAaCasualties(\n+              planes,\n+              aaUnitType.createTemp(1, aaPlayer),\n+              mock(CombatValue.class),\n+              givenAaCombatValue(),\n+              \"text\",\n+              // low luck would have 2 hits because 12 power / 6 dice side\n+              givenDiceRollWithHitSequence(true, true),\n+              bridge,\n+              hitPlayer,\n+              UUID.randomUUID(),\n+              mock(Territory.class));\n+\n+      assertThat(details.getKilled(), hasSize(2));\n+      assertThat(\n+          \"One of each plane type should be killed\",\n+          details.getKilled().stream().map(Unit::getType).collect(Collectors.toList()),\n+          containsInAnyOrder(planeUnitType, otherPlaneUnitType));\n+\n+      assertThat(\n+          \"The planes have 1 hp so there can't be damaged planes\",\n+          details.getDamaged(),\n+          is(empty()));\n+    }\n+\n+    @Test\n+    void twoTypesOfPlanesAndTogetherHaveAmountEqualToDiceSides() {\n+\n+      // need to randomly pick a plane to kill\n+      whenGetRandom(bridge).thenAnswer(withValues(1));\n+\n+      final List<Unit> planes = planeUnitType.createTemp(3, hitPlayer);\n+      planes.addAll(otherPlaneUnitType.createTemp(3, hitPlayer));\n+\n+      final CasualtyDetails details =\n+          AaCasualtySelector.getAaCasualties(\n+              planes,\n+              aaUnitType.createTemp(1, aaPlayer),\n+              mock(CombatValue.class),\n+              givenAaCombatValue(),\n+              \"text\",\n+              // low luck would have 1 hits because 6 power / 6 dice side\n+              givenDiceRollWithHitSequence(true),\n+              bridge,\n+              hitPlayer,\n+              UUID.randomUUID(),\n+              mock(Territory.class));\n+\n+      assertThat(details.getKilled(), hasSize(1));\n+      assertThat(\n+          \"The otherPlaneUnitType is killed because it's unitType is sorted before planeUnitType \"\n+              + \"(it sorts by unit type name) and there are 3 of them and the random selection was \"\n+              + \"for the second unit in the list.\",\n+          details.getKilled().stream().map(Unit::getType).collect(Collectors.toList()),\n+          containsInAnyOrder(otherPlaneUnitType));\n+\n+      assertThat(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjMwNDEyNg=="}, "originalCommit": {"oid": "275273930a55eef32bec4fbf2c3dc97c1c93b940"}, "originalPosition": 217}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzOTM2NTcwOnYy", "diffSide": "RIGHT", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/casualty/AaCasualtySelectorTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQwMTozNTo1N1rOH7pU2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQwMTozNTo1N1rOH7pU2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjMwNTExMg==", "bodyText": "WDYT to rename this method \"givenSingleDiceRollWithOneHit\", then it might not have to be commented? Or something like givenLowLuckGuaranteedHit\nI'm wondering about ways we can make this clear without needing the additional comment.", "url": "https://github.com/triplea-game/triplea/pull/8318#discussion_r532305112", "createdAt": "2020-11-30T01:35:57Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/casualty/AaCasualtySelectorTest.java", "diffHunk": "@@ -417,4 +419,606 @@ void hitsLessThanPlanesKillsAccordingToTheRolledDice() {\n           is(List.of(planes.get(0), planes.get(2), planes.get(4))));\n     }\n   }\n+\n+  @Nested\n+  class LowLuckCasualties {\n+    private IDelegateBridge bridge;\n+    @Mock private UnitType otherPlaneUnitType;\n+    @Mock private UnitType otherPlaneMultiHpUnitType;\n+    @Mock private UnitType powerfulAaUnitType;\n+\n+    @BeforeEach\n+    void setupPlayers() {\n+      when(hitPlayer.getName()).thenReturn(\"Hit Player\");\n+    }\n+\n+    @BeforeEach\n+    void initializeGameData() {\n+      gameData =\n+          givenGameData()\n+              .withDiceSides(6)\n+              .withEditMode(false)\n+              .withChooseAaCasualties(false)\n+              .withLowLuck(true)\n+              .build();\n+      bridge = mock(IDelegateBridge.class);\n+      when(bridge.getData()).thenReturn(gameData);\n+\n+      aaUnitType = new UnitType(\"aaUnitType\", gameData);\n+      final UnitAttachment aaUnitAttachment =\n+          new UnitAttachment(\"aaUnitAttachment\", aaUnitType, gameData);\n+      aaUnitType.addAttachment(UNIT_ATTACHMENT_NAME, aaUnitAttachment);\n+\n+      damageableAaUnitType = new UnitType(\"damageableAaUnitType\", gameData);\n+      final UnitAttachment damageableAaUnitAttachment =\n+          new UnitAttachment(\"damageableAaUnitAttachment\", damageableAaUnitType, gameData);\n+      damageableAaUnitAttachment.setDamageableAa(true);\n+      damageableAaUnitType.addAttachment(UNIT_ATTACHMENT_NAME, damageableAaUnitAttachment);\n+\n+      powerfulAaUnitType = new UnitType(\"powerfulAaUnitType\", gameData);\n+      final UnitAttachment powerfulAaUnitAttachment =\n+          new UnitAttachment(\"powerfulAaUnitAttachment\", powerfulAaUnitType, gameData);\n+      powerfulAaUnitAttachment.setAttackAa(5);\n+      powerfulAaUnitType.addAttachment(UNIT_ATTACHMENT_NAME, powerfulAaUnitAttachment);\n+\n+      planeUnitType = new UnitType(\"planeUnitType\", gameData);\n+      final UnitAttachment planeUnitAttachment =\n+          new UnitAttachment(\"planeUnitAttachment\", aaUnitType, gameData);\n+      planeUnitType.addAttachment(UNIT_ATTACHMENT_NAME, planeUnitAttachment);\n+\n+      otherPlaneUnitType = new UnitType(\"otherPlaneUnitType\", gameData);\n+      final UnitAttachment otherPlaneUnitAttachment =\n+          new UnitAttachment(\"otherPlaneUnitAttachment\", aaUnitType, gameData);\n+      otherPlaneUnitType.addAttachment(UNIT_ATTACHMENT_NAME, otherPlaneUnitAttachment);\n+\n+      planeMultiHpUnitType = new UnitType(\"planeMultiHpUnitType\", gameData);\n+      final UnitAttachment planeMultiHpUnitAttachment =\n+          new UnitAttachment(\"planeMultiHpUnitAttachment\", aaUnitType, gameData);\n+      planeMultiHpUnitAttachment.setHitPoints(2);\n+      planeMultiHpUnitType.addAttachment(UNIT_ATTACHMENT_NAME, planeMultiHpUnitAttachment);\n+\n+      otherPlaneMultiHpUnitType = new UnitType(\"otherPlaneMultiHpUnitType\", gameData);\n+      final UnitAttachment otherPlaneMultiHpUnitAttachment =\n+          new UnitAttachment(\"otherPlaneMultiHpUnitAttachment\", aaUnitType, gameData);\n+      otherPlaneMultiHpUnitAttachment.setHitPoints(2);\n+      otherPlaneMultiHpUnitType.addAttachment(\n+          UNIT_ATTACHMENT_NAME, otherPlaneMultiHpUnitAttachment);\n+    }\n+\n+    @Test\n+    void oneTypeOfPlaneWithAmountEqualToDiceSides() {\n+\n+      final List<Unit> planes = planeUnitType.createTemp(6, hitPlayer);\n+\n+      final CasualtyDetails details =\n+          AaCasualtySelector.getAaCasualties(\n+              planes,\n+              aaUnitType.createTemp(1, aaPlayer),\n+              mock(CombatValue.class),\n+              givenAaCombatValue(),\n+              \"text\",\n+              // low luck would have 1 hit because 6 power / 6 dice side\n+              givenDiceRollWithHitSequence(true),\n+              bridge,\n+              hitPlayer,\n+              UUID.randomUUID(),\n+              mock(Territory.class));\n+\n+      assertThat(details.getKilled(), hasSize(1));\n+      assertThat(\n+          \"The planes have 1 hp so there can't be damaged planes\",\n+          details.getDamaged(),\n+          is(empty()));\n+    }\n+\n+    @Test\n+    void twoTypesOfPlanesAndBothHaveAmountEqualToDiceSides() {\n+\n+      final List<Unit> planes = planeUnitType.createTemp(6, hitPlayer);\n+      planes.addAll(otherPlaneUnitType.createTemp(6, hitPlayer));\n+\n+      final CasualtyDetails details =\n+          AaCasualtySelector.getAaCasualties(\n+              planes,\n+              aaUnitType.createTemp(1, aaPlayer),\n+              mock(CombatValue.class),\n+              givenAaCombatValue(),\n+              \"text\",\n+              // low luck would have 2 hits because 12 power / 6 dice side\n+              givenDiceRollWithHitSequence(true, true),\n+              bridge,\n+              hitPlayer,\n+              UUID.randomUUID(),\n+              mock(Territory.class));\n+\n+      assertThat(details.getKilled(), hasSize(2));\n+      assertThat(\n+          \"One of each plane type should be killed\",\n+          details.getKilled().stream().map(Unit::getType).collect(Collectors.toList()),\n+          containsInAnyOrder(planeUnitType, otherPlaneUnitType));\n+\n+      assertThat(\n+          \"The planes have 1 hp so there can't be damaged planes\",\n+          details.getDamaged(),\n+          is(empty()));\n+    }\n+\n+    @Test\n+    void twoTypesOfPlanesAndTogetherHaveAmountEqualToDiceSides() {\n+\n+      // need to randomly pick a plane to kill\n+      whenGetRandom(bridge).thenAnswer(withValues(1));\n+\n+      final List<Unit> planes = planeUnitType.createTemp(3, hitPlayer);\n+      planes.addAll(otherPlaneUnitType.createTemp(3, hitPlayer));\n+\n+      final CasualtyDetails details =\n+          AaCasualtySelector.getAaCasualties(\n+              planes,\n+              aaUnitType.createTemp(1, aaPlayer),\n+              mock(CombatValue.class),\n+              givenAaCombatValue(),\n+              \"text\",\n+              // low luck would have 1 hits because 6 power / 6 dice side\n+              givenDiceRollWithHitSequence(true),\n+              bridge,\n+              hitPlayer,\n+              UUID.randomUUID(),\n+              mock(Territory.class));\n+\n+      assertThat(details.getKilled(), hasSize(1));\n+      assertThat(\n+          \"The otherPlaneUnitType is killed because it's unitType is sorted before planeUnitType \"\n+              + \"(it sorts by unit type name) and there are 3 of them and the random selection was \"\n+              + \"for the second unit in the list.\",\n+          details.getKilled().stream().map(Unit::getType).collect(Collectors.toList()),\n+          containsInAnyOrder(otherPlaneUnitType));\n+\n+      assertThat(\n+          \"The planes have 1 hp so there can't be damaged planes\",\n+          details.getDamaged(),\n+          is(empty()));\n+    }\n+\n+    @Test\n+    void oneTypeOfMultiHpPlaneWithAmountEqualToDiceSides() {\n+\n+      whenGetRandom(bridge).thenAnswer(withValues(1));\n+\n+      final List<Unit> planes = planeMultiHpUnitType.createTemp(6, hitPlayer);\n+\n+      final CasualtyDetails details =\n+          AaCasualtySelector.getAaCasualties(\n+              planes,\n+              damageableAaUnitType.createTemp(1, aaPlayer),\n+              mock(CombatValue.class),\n+              givenAaCombatValue(),\n+              \"text\",\n+              // low luck would have 1 hit because 6 power / 6 dice side\n+              givenDiceRollWithHitSequence(true),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "275273930a55eef32bec4fbf2c3dc97c1c93b940"}, "originalPosition": 238}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzOTUyODU1OnYy", "diffSide": "RIGHT", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/casualty/AaCasualtySelectorTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQwMzoyMjowNVrOH7quJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQwMzoyMjowNVrOH7quJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjMyNzk3NQ==", "bodyText": "IMHO - a comment on this method would go a long way, what is this method doing?", "url": "https://github.com/triplea-game/triplea/pull/8318#discussion_r532327975", "createdAt": "2020-11-30T03:22:05Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/casualty/AaCasualtySelectorTest.java", "diffHunk": "@@ -511,21 +512,60 @@ void oneTypeOfPlaneWithAmountEqualToDiceSides() {\n           is(empty()));\n     }\n \n+    private DiceRoll givenLowLuckDiceRoll(final List<Unit> aaUnits, final List<Unit> planes) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "31ab9e296b0a88a09feb494cc3efafe04ea423b6"}, "originalPosition": 32}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2622, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}