{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI1NTUwMjY4", "number": 6549, "title": "MustFightBattle#determineStepStrings unittests", "bodyText": "This moves MustFightBattle#determineStepStrings into a helper class called BattleSteps.  I also moved several methods that were used by determineStepStrings and other parts of MustFightBattle into utility classes named RetreatChecks and SubChecks.\nI didn't change any of the logic in any of the functions that were moved.  This will NOT pass the codeclimate checks.\nI wrote unit tests for the new class BattleSteps.  It has 100% code coverage.  I believe I handle all of the possible code paths.  While working on the unittests, I found a few situations that I feel are bugs and I left a TODO there.\nFunctional Changes\n\n[] New map or map update\n[] New Feature\n[] Feature update or enhancement\n[] Feature Removal\n[X] Code Cleanup or refactor\n[] Configuration Change\n[] Problem fix:  \n[] Other:   \nTesting\nI performed no manually tests.\nAdditional Review Notes\nI've written at https://forums.triplea-game.org/topic/2011/refactoring-mustfightbattle some of the rational behind this change.\nThe unit test file is the majority of this PR.  It is >2000 lines.", "createdAt": "2020-05-31T02:27:55Z", "url": "https://github.com/triplea-game/triplea/pull/6549", "merged": true, "mergeCommit": {"oid": "9ae67d07cf141ea58311dd56dbc47556a2605fa6"}, "closed": true, "closedAt": "2020-06-01T02:45:51Z", "author": {"login": "trevan"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcmYg56AH2gAyNDI1NTUwMjY4OmY5ODZjNTY4NWM0NTM5NDJmOGE4Mzc0MmI4NTdkMzgzMDc1ZWVlNGE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcm2qKkAH2gAyNDI1NTUwMjY4OjNkNDM2ZTNkMjdjMjJjYzFhNzdkMjhkODg1MmFiM2MwYTQzOGFmMmE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "f986c5685c453942f8a83742b857d383075eee4a", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/f986c5685c453942f8a83742b857d383075eee4a", "committedDate": "2020-05-30T15:08:52Z", "message": "Move determineStepStrings to a utility class for refactoring"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxNDU2NDYz", "url": "https://github.com/triplea-game/triplea/pull/6549#pullrequestreview-421456463", "createdAt": "2020-05-31T02:29:21Z", "commit": {"oid": "2ccde7081470c53de9f4c67f877cef2adae047fa"}, "state": "COMMENTED", "comments": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMVQwMjoyOToyMVrOGc2VHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMVQwMjoyOToyNVrOGc2VMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkwMzQ1Mw==", "bodyText": "Consider simplifying this complex logical expression.", "url": "https://github.com/triplea-game/triplea/pull/6549#discussion_r432903453", "createdAt": "2020-05-31T02:29:21Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/BattleSteps.java", "diffHunk": "@@ -0,0 +1,244 @@\n+package games.strategy.triplea.delegate.battle.steps;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.attachments.TechAttachment;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.battle.BattleStepStrings;\n+import games.strategy.triplea.delegate.battle.MustFightBattle.ReturnFire;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import lombok.Builder;\n+import lombok.NonNull;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Get the steps that will occurr in the battle */\n+@Builder\n+public class BattleSteps implements BattleStepStrings {\n+\n+  final @NonNull Boolean canFireOffensiveAa;\n+  final @NonNull Boolean canFireDefendingAa;\n+  final @NonNull Boolean showFirstRun;\n+  final @NonNull GamePlayer attacker;\n+  final @NonNull GamePlayer defender;\n+  final @NonNull Collection<Unit> offensiveAa;\n+  final @NonNull Collection<Unit> defendingAa;\n+  final @NonNull Collection<Unit> attackingUnits;\n+  final @NonNull Collection<Unit> defendingUnits;\n+  final @NonNull Collection<Unit> attackingWaitingToDie;\n+  final @NonNull Collection<Unit> defendingWaitingToDie;\n+  final @NonNull Territory battleSite;\n+  final @NonNull GameData gameData;\n+  final @NonNull Collection<Unit> bombardingUnits;\n+  final @NonNull Function<Collection<Unit>, Collection<Unit>> getDependentUnits;\n+  final @NonNull Boolean isBattleSiteWater;\n+  final @NonNull Boolean isAmphibious;\n+  final @NonNull Supplier<Collection<Territory>> getAttackerRetreatTerritories;\n+  final @NonNull BiFunction<GamePlayer, Collection<Unit>, Collection<Territory>>\n+      getEmptyOrFriendlySeaNeighbors;\n+\n+  public List<String> get() {\n+\n+    final List<String> steps = new ArrayList<>();\n+    if (canFireOffensiveAa) {\n+      for (final String typeAa : UnitAttachment.getAllOfTypeAas(offensiveAa)) {\n+        steps.add(attacker.getName() + \" \" + typeAa + AA_GUNS_FIRE_SUFFIX);\n+        steps.add(defender.getName() + SELECT_PREFIX + typeAa + CASUALTIES_SUFFIX);\n+        steps.add(defender.getName() + REMOVE_PREFIX + typeAa + CASUALTIES_SUFFIX);\n+      }\n+    }\n+    if (canFireDefendingAa) {\n+      for (final String typeAa : UnitAttachment.getAllOfTypeAas(defendingAa)) {\n+        steps.add(defender.getName() + \" \" + typeAa + AA_GUNS_FIRE_SUFFIX);\n+        steps.add(attacker.getName() + SELECT_PREFIX + typeAa + CASUALTIES_SUFFIX);\n+        steps.add(attacker.getName() + REMOVE_PREFIX + typeAa + CASUALTIES_SUFFIX);\n+      }\n+    }\n+    if (showFirstRun) {\n+      if (!isBattleSiteWater && !bombardingUnits.isEmpty()) {\n+        steps.add(NAVAL_BOMBARDMENT);\n+        steps.add(SELECT_NAVAL_BOMBARDMENT_CASUALTIES);\n+      }\n+      if (!isBattleSiteWater && TechAttachment.isAirTransportable(attacker)) {\n+        final Collection<Unit> bombers =\n+            CollectionUtils.getMatches(battleSite.getUnits(), Matches.unitIsAirTransport());\n+        if (!bombers.isEmpty()) {\n+          final Collection<Unit> dependents = getDependentUnits.apply(bombers);\n+          if (!dependents.isEmpty()) {\n+            steps.add(LAND_PARATROOPS);\n+          }\n+        }\n+      }\n+    }\n+    // Check if defending subs can submerge before battle\n+    if (Properties.getSubRetreatBeforeBattle(gameData)) {\n+      if (defendingUnits.stream().noneMatch(Matches.unitIsDestroyer())\n+          && attackingUnits.stream().anyMatch(Matches.unitCanEvade())) {\n+        steps.add(attacker.getName() + SUBS_SUBMERGE);\n+      }\n+      if (attackingUnits.stream().noneMatch(Matches.unitIsDestroyer())\n+          && defendingUnits.stream().anyMatch(Matches.unitCanEvade())) {\n+        steps.add(defender.getName() + SUBS_SUBMERGE);\n+      }\n+    }\n+    // See if there any unescorted transports\n+    if (isBattleSiteWater && Properties.getTransportCasualtiesRestricted(gameData)) {\n+      if (attackingUnits.stream().anyMatch(Matches.unitIsTransport())\n+          || defendingUnits.stream().anyMatch(Matches.unitIsTransport())) {\n+        steps.add(REMOVE_UNESCORTED_TRANSPORTS);\n+      }\n+    }\n+    final boolean defenderSubsFireFirst =\n+        SubsChecks.defenderSubsFireFirst(attackingUnits, defendingUnits, gameData);\n+    final ReturnFire returnFireAgainstAttackingSubs =\n+        SubsChecks.returnFireAgainstAttackingSubs(attackingUnits, defendingUnits, gameData);\n+    final ReturnFire returnFireAgainstDefendingSubs =\n+        SubsChecks.returnFireAgainstDefendingSubs(attackingUnits, defendingUnits, gameData);\n+    // if attacker has no sneak attack subs, then defender sneak attack subs fire first and remove\n+    // casualties\n+    if (defenderSubsFireFirst && defendingUnits.stream().anyMatch(Matches.unitIsFirstStrike())) {\n+      steps.add(defender.getName() + FIRST_STRIKE_UNITS_FIRE);\n+      steps.add(attacker.getName() + SELECT_FIRST_STRIKE_CASUALTIES);\n+      steps.add(REMOVE_SNEAK_ATTACK_CASUALTIES);\n+    }\n+    final boolean onlyAttackerSneakAttack =\n+        !defenderSubsFireFirst\n+            && returnFireAgainstAttackingSubs == ReturnFire.NONE\n+            && returnFireAgainstDefendingSubs == ReturnFire.ALL;\n+    // attacker subs sneak attack, no sneak attack if destroyers are present\n+    if (attackingUnits.stream().anyMatch(Matches.unitIsFirstStrike())) {\n+      steps.add(attacker.getName() + FIRST_STRIKE_UNITS_FIRE);\n+      steps.add(defender.getName() + SELECT_FIRST_STRIKE_CASUALTIES);\n+      if (onlyAttackerSneakAttack) {\n+        steps.add(REMOVE_SNEAK_ATTACK_CASUALTIES);\n+      }\n+    }\n+    // ww2v2 rules, all subs fire FIRST in combat, regardless of presence of destroyers.\n+    final boolean defendingSubsFireWithAllDefenders =\n+        !defenderSubsFireFirst\n+            && !Properties.getWW2V2(gameData)\n+            && returnFireAgainstDefendingSubs == ReturnFire.ALL;\n+    // defender subs sneak attack, no sneak attack in Pacific/Europe Theaters or if destroyers are\n+    // present\n+    final boolean defendingSubsFireWithAllDefendersAlways =\n+        !SubsChecks.defendingSubsSneakAttack(gameData);\n+    if (!defendingSubsFireWithAllDefendersAlways\n+        && !defendingSubsFireWithAllDefenders\n+        && !defenderSubsFireFirst\n+        && defendingUnits.stream().anyMatch(Matches.unitIsFirstStrike())) {\n+      steps.add(defender.getName() + FIRST_STRIKE_UNITS_FIRE);\n+      steps.add(attacker.getName() + SELECT_FIRST_STRIKE_CASUALTIES);\n+    }\n+    if ((attackingUnits.stream().anyMatch(Matches.unitIsFirstStrike())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ccde7081470c53de9f4c67f877cef2adae047fa"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkwMzQ1NA==", "bodyText": "Similar blocks of code found in 2 locations. Consider refactoring.", "url": "https://github.com/triplea-game/triplea/pull/6549#discussion_r432903454", "createdAt": "2020-05-31T02:29:21Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/SubsChecks.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package games.strategy.triplea.delegate.battle.steps;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import java.util.Collection;\n+import lombok.NonNull;\n+import lombok.experimental.UtilityClass;\n+\n+@UtilityClass\n+public class SubsChecks {\n+  public static boolean defenderSubsFireFirst(\n+      final @NonNull Collection<Unit> attackingUnits,\n+      final @NonNull Collection<Unit> defendingUnits,\n+      final @NonNull GameData gameData) {\n+    return returnFireAgainstAttackingSubs(attackingUnits, defendingUnits, gameData)\n+            == MustFightBattle.ReturnFire.ALL\n+        && returnFireAgainstDefendingSubs(attackingUnits, defendingUnits, gameData)\n+            == MustFightBattle.ReturnFire.NONE;\n+  }\n+\n+  public static MustFightBattle.ReturnFire returnFireAgainstAttackingSubs(\n+      final @NonNull Collection<Unit> attackingUnits,\n+      final @NonNull Collection<Unit> defendingUnits,\n+      final @NonNull GameData gameData) {\n+    final boolean attackingSubsSneakAttack =\n+        defendingUnits.stream().noneMatch(Matches.unitIsDestroyer());\n+    final boolean defendingSubsSneakAttack =\n+        defendingSubsSneakAttackAndNoAttackingDestroyers(attackingUnits, gameData);\n+    final MustFightBattle.ReturnFire returnFireAgainstAttackingSubs;\n+    if (!attackingSubsSneakAttack) {\n+      returnFireAgainstAttackingSubs = MustFightBattle.ReturnFire.ALL;\n+    } else if (defendingSubsSneakAttack || Properties.getWW2V2(gameData)) {\n+      returnFireAgainstAttackingSubs = MustFightBattle.ReturnFire.SUBS;\n+    } else {\n+      returnFireAgainstAttackingSubs = MustFightBattle.ReturnFire.NONE;\n+    }\n+    return returnFireAgainstAttackingSubs;\n+  }\n+\n+  public static MustFightBattle.ReturnFire returnFireAgainstDefendingSubs(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ccde7081470c53de9f4c67f877cef2adae047fa"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkwMzQ1NQ==", "bodyText": "Similar blocks of code found in 2 locations. Consider refactoring.", "url": "https://github.com/triplea-game/triplea/pull/6549#discussion_r432903455", "createdAt": "2020-05-31T02:29:22Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/SubsChecks.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package games.strategy.triplea.delegate.battle.steps;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import java.util.Collection;\n+import lombok.NonNull;\n+import lombok.experimental.UtilityClass;\n+\n+@UtilityClass\n+public class SubsChecks {\n+  public static boolean defenderSubsFireFirst(\n+      final @NonNull Collection<Unit> attackingUnits,\n+      final @NonNull Collection<Unit> defendingUnits,\n+      final @NonNull GameData gameData) {\n+    return returnFireAgainstAttackingSubs(attackingUnits, defendingUnits, gameData)\n+            == MustFightBattle.ReturnFire.ALL\n+        && returnFireAgainstDefendingSubs(attackingUnits, defendingUnits, gameData)\n+            == MustFightBattle.ReturnFire.NONE;\n+  }\n+\n+  public static MustFightBattle.ReturnFire returnFireAgainstAttackingSubs(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ccde7081470c53de9f4c67f877cef2adae047fa"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkwMzQ1Ng==", "bodyText": "Identical blocks of code found in 2 locations. Consider refactoring.", "url": "https://github.com/triplea-game/triplea/pull/6549#discussion_r432903456", "createdAt": "2020-05-31T02:29:22Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/BattleSteps.java", "diffHunk": "@@ -0,0 +1,244 @@\n+package games.strategy.triplea.delegate.battle.steps;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.attachments.TechAttachment;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.battle.BattleStepStrings;\n+import games.strategy.triplea.delegate.battle.MustFightBattle.ReturnFire;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import lombok.Builder;\n+import lombok.NonNull;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Get the steps that will occurr in the battle */\n+@Builder\n+public class BattleSteps implements BattleStepStrings {\n+\n+  final @NonNull Boolean canFireOffensiveAa;\n+  final @NonNull Boolean canFireDefendingAa;\n+  final @NonNull Boolean showFirstRun;\n+  final @NonNull GamePlayer attacker;\n+  final @NonNull GamePlayer defender;\n+  final @NonNull Collection<Unit> offensiveAa;\n+  final @NonNull Collection<Unit> defendingAa;\n+  final @NonNull Collection<Unit> attackingUnits;\n+  final @NonNull Collection<Unit> defendingUnits;\n+  final @NonNull Collection<Unit> attackingWaitingToDie;\n+  final @NonNull Collection<Unit> defendingWaitingToDie;\n+  final @NonNull Territory battleSite;\n+  final @NonNull GameData gameData;\n+  final @NonNull Collection<Unit> bombardingUnits;\n+  final @NonNull Function<Collection<Unit>, Collection<Unit>> getDependentUnits;\n+  final @NonNull Boolean isBattleSiteWater;\n+  final @NonNull Boolean isAmphibious;\n+  final @NonNull Supplier<Collection<Territory>> getAttackerRetreatTerritories;\n+  final @NonNull BiFunction<GamePlayer, Collection<Unit>, Collection<Territory>>\n+      getEmptyOrFriendlySeaNeighbors;\n+\n+  public List<String> get() {\n+\n+    final List<String> steps = new ArrayList<>();\n+    if (canFireOffensiveAa) {\n+      for (final String typeAa : UnitAttachment.getAllOfTypeAas(offensiveAa)) {\n+        steps.add(attacker.getName() + \" \" + typeAa + AA_GUNS_FIRE_SUFFIX);\n+        steps.add(defender.getName() + SELECT_PREFIX + typeAa + CASUALTIES_SUFFIX);\n+        steps.add(defender.getName() + REMOVE_PREFIX + typeAa + CASUALTIES_SUFFIX);\n+      }\n+    }\n+    if (canFireDefendingAa) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ccde7081470c53de9f4c67f877cef2adae047fa"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkwMzQ1Nw==", "bodyText": "Method get has 161 lines of code (exceeds 30 allowed). Consider refactoring.", "url": "https://github.com/triplea-game/triplea/pull/6549#discussion_r432903457", "createdAt": "2020-05-31T02:29:22Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/BattleSteps.java", "diffHunk": "@@ -0,0 +1,244 @@\n+package games.strategy.triplea.delegate.battle.steps;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.attachments.TechAttachment;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.battle.BattleStepStrings;\n+import games.strategy.triplea.delegate.battle.MustFightBattle.ReturnFire;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import lombok.Builder;\n+import lombok.NonNull;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Get the steps that will occurr in the battle */\n+@Builder\n+public class BattleSteps implements BattleStepStrings {\n+\n+  final @NonNull Boolean canFireOffensiveAa;\n+  final @NonNull Boolean canFireDefendingAa;\n+  final @NonNull Boolean showFirstRun;\n+  final @NonNull GamePlayer attacker;\n+  final @NonNull GamePlayer defender;\n+  final @NonNull Collection<Unit> offensiveAa;\n+  final @NonNull Collection<Unit> defendingAa;\n+  final @NonNull Collection<Unit> attackingUnits;\n+  final @NonNull Collection<Unit> defendingUnits;\n+  final @NonNull Collection<Unit> attackingWaitingToDie;\n+  final @NonNull Collection<Unit> defendingWaitingToDie;\n+  final @NonNull Territory battleSite;\n+  final @NonNull GameData gameData;\n+  final @NonNull Collection<Unit> bombardingUnits;\n+  final @NonNull Function<Collection<Unit>, Collection<Unit>> getDependentUnits;\n+  final @NonNull Boolean isBattleSiteWater;\n+  final @NonNull Boolean isAmphibious;\n+  final @NonNull Supplier<Collection<Territory>> getAttackerRetreatTerritories;\n+  final @NonNull BiFunction<GamePlayer, Collection<Unit>, Collection<Territory>>\n+      getEmptyOrFriendlySeaNeighbors;\n+\n+  public List<String> get() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ccde7081470c53de9f4c67f877cef2adae047fa"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkwMzQ1OA==", "bodyText": "Identical blocks of code found in 2 locations. Consider refactoring.", "url": "https://github.com/triplea-game/triplea/pull/6549#discussion_r432903458", "createdAt": "2020-05-31T02:29:22Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/BattleSteps.java", "diffHunk": "@@ -0,0 +1,244 @@\n+package games.strategy.triplea.delegate.battle.steps;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.attachments.TechAttachment;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.battle.BattleStepStrings;\n+import games.strategy.triplea.delegate.battle.MustFightBattle.ReturnFire;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import lombok.Builder;\n+import lombok.NonNull;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Get the steps that will occurr in the battle */\n+@Builder\n+public class BattleSteps implements BattleStepStrings {\n+\n+  final @NonNull Boolean canFireOffensiveAa;\n+  final @NonNull Boolean canFireDefendingAa;\n+  final @NonNull Boolean showFirstRun;\n+  final @NonNull GamePlayer attacker;\n+  final @NonNull GamePlayer defender;\n+  final @NonNull Collection<Unit> offensiveAa;\n+  final @NonNull Collection<Unit> defendingAa;\n+  final @NonNull Collection<Unit> attackingUnits;\n+  final @NonNull Collection<Unit> defendingUnits;\n+  final @NonNull Collection<Unit> attackingWaitingToDie;\n+  final @NonNull Collection<Unit> defendingWaitingToDie;\n+  final @NonNull Territory battleSite;\n+  final @NonNull GameData gameData;\n+  final @NonNull Collection<Unit> bombardingUnits;\n+  final @NonNull Function<Collection<Unit>, Collection<Unit>> getDependentUnits;\n+  final @NonNull Boolean isBattleSiteWater;\n+  final @NonNull Boolean isAmphibious;\n+  final @NonNull Supplier<Collection<Territory>> getAttackerRetreatTerritories;\n+  final @NonNull BiFunction<GamePlayer, Collection<Unit>, Collection<Territory>>\n+      getEmptyOrFriendlySeaNeighbors;\n+\n+  public List<String> get() {\n+\n+    final List<String> steps = new ArrayList<>();\n+    if (canFireOffensiveAa) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ccde7081470c53de9f4c67f877cef2adae047fa"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkwMzQ1OQ==", "bodyText": "Identical blocks of code found in 2 locations. Consider refactoring.", "url": "https://github.com/triplea-game/triplea/pull/6549#discussion_r432903459", "createdAt": "2020-05-31T02:29:22Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/BattleSteps.java", "diffHunk": "@@ -0,0 +1,244 @@\n+package games.strategy.triplea.delegate.battle.steps;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.attachments.TechAttachment;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.battle.BattleStepStrings;\n+import games.strategy.triplea.delegate.battle.MustFightBattle.ReturnFire;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import lombok.Builder;\n+import lombok.NonNull;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Get the steps that will occurr in the battle */\n+@Builder\n+public class BattleSteps implements BattleStepStrings {\n+\n+  final @NonNull Boolean canFireOffensiveAa;\n+  final @NonNull Boolean canFireDefendingAa;\n+  final @NonNull Boolean showFirstRun;\n+  final @NonNull GamePlayer attacker;\n+  final @NonNull GamePlayer defender;\n+  final @NonNull Collection<Unit> offensiveAa;\n+  final @NonNull Collection<Unit> defendingAa;\n+  final @NonNull Collection<Unit> attackingUnits;\n+  final @NonNull Collection<Unit> defendingUnits;\n+  final @NonNull Collection<Unit> attackingWaitingToDie;\n+  final @NonNull Collection<Unit> defendingWaitingToDie;\n+  final @NonNull Territory battleSite;\n+  final @NonNull GameData gameData;\n+  final @NonNull Collection<Unit> bombardingUnits;\n+  final @NonNull Function<Collection<Unit>, Collection<Unit>> getDependentUnits;\n+  final @NonNull Boolean isBattleSiteWater;\n+  final @NonNull Boolean isAmphibious;\n+  final @NonNull Supplier<Collection<Territory>> getAttackerRetreatTerritories;\n+  final @NonNull BiFunction<GamePlayer, Collection<Unit>, Collection<Territory>>\n+      getEmptyOrFriendlySeaNeighbors;\n+\n+  public List<String> get() {\n+\n+    final List<String> steps = new ArrayList<>();\n+    if (canFireOffensiveAa) {\n+      for (final String typeAa : UnitAttachment.getAllOfTypeAas(offensiveAa)) {\n+        steps.add(attacker.getName() + \" \" + typeAa + AA_GUNS_FIRE_SUFFIX);\n+        steps.add(defender.getName() + SELECT_PREFIX + typeAa + CASUALTIES_SUFFIX);\n+        steps.add(defender.getName() + REMOVE_PREFIX + typeAa + CASUALTIES_SUFFIX);\n+      }\n+    }\n+    if (canFireDefendingAa) {\n+      for (final String typeAa : UnitAttachment.getAllOfTypeAas(defendingAa)) {\n+        steps.add(defender.getName() + \" \" + typeAa + AA_GUNS_FIRE_SUFFIX);\n+        steps.add(attacker.getName() + SELECT_PREFIX + typeAa + CASUALTIES_SUFFIX);\n+        steps.add(attacker.getName() + REMOVE_PREFIX + typeAa + CASUALTIES_SUFFIX);\n+      }\n+    }\n+    if (showFirstRun) {\n+      if (!isBattleSiteWater && !bombardingUnits.isEmpty()) {\n+        steps.add(NAVAL_BOMBARDMENT);\n+        steps.add(SELECT_NAVAL_BOMBARDMENT_CASUALTIES);\n+      }\n+      if (!isBattleSiteWater && TechAttachment.isAirTransportable(attacker)) {\n+        final Collection<Unit> bombers =\n+            CollectionUtils.getMatches(battleSite.getUnits(), Matches.unitIsAirTransport());\n+        if (!bombers.isEmpty()) {\n+          final Collection<Unit> dependents = getDependentUnits.apply(bombers);\n+          if (!dependents.isEmpty()) {\n+            steps.add(LAND_PARATROOPS);\n+          }\n+        }\n+      }\n+    }\n+    // Check if defending subs can submerge before battle\n+    if (Properties.getSubRetreatBeforeBattle(gameData)) {\n+      if (defendingUnits.stream().noneMatch(Matches.unitIsDestroyer())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ccde7081470c53de9f4c67f877cef2adae047fa"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkwMzQ2MA==", "bodyText": "Method canAttackerRetreatSubs has 5 arguments (exceeds 4 allowed). Consider refactoring.", "url": "https://github.com/triplea-game/triplea/pull/6549#discussion_r432903460", "createdAt": "2020-05-31T02:29:23Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/RetreatChecks.java", "diffHunk": "@@ -0,0 +1,103 @@\n+package games.strategy.triplea.delegate.battle.steps;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.function.BiFunction;\n+import java.util.function.Supplier;\n+import lombok.NonNull;\n+import lombok.experimental.UtilityClass;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+@UtilityClass\n+public class RetreatChecks {\n+  public static boolean canAttackerRetreatSubs(\n+      final @NonNull Collection<Unit> defendingUnits,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ccde7081470c53de9f4c67f877cef2adae047fa"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkwMzQ2MQ==", "bodyText": "Method canDefenderRetreatSubs has 6 arguments (exceeds 4 allowed). Consider refactoring.", "url": "https://github.com/triplea-game/triplea/pull/6549#discussion_r432903461", "createdAt": "2020-05-31T02:29:23Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/RetreatChecks.java", "diffHunk": "@@ -0,0 +1,103 @@\n+package games.strategy.triplea.delegate.battle.steps;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.function.BiFunction;\n+import java.util.function.Supplier;\n+import lombok.NonNull;\n+import lombok.experimental.UtilityClass;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+@UtilityClass\n+public class RetreatChecks {\n+  public static boolean canAttackerRetreatSubs(\n+      final @NonNull Collection<Unit> defendingUnits,\n+      final @NonNull Collection<Unit> defendingWaitingToDie,\n+      final @NonNull GameData gameData,\n+      final @NonNull Supplier<Collection<Territory>> getAttackerRetreatTerritories,\n+      final @NonNull Boolean isAmphibious) {\n+    if (defendingUnits.stream().anyMatch(Matches.unitIsDestroyer())) {\n+      return false;\n+    }\n+    return defendingWaitingToDie.stream().noneMatch(Matches.unitIsDestroyer())\n+        && (canAttackerRetreat(\n+                defendingUnits, gameData, getAttackerRetreatTerritories, isAmphibious)\n+            || Properties.getSubmersibleSubs(gameData));\n+  }\n+\n+  public static boolean canDefenderRetreatSubs(\n+      final @NonNull Collection<Unit> attackingUnits,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ccde7081470c53de9f4c67f877cef2adae047fa"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkwMzQ2Mg==", "bodyText": "Identical blocks of code found in 2 locations. Consider refactoring.", "url": "https://github.com/triplea-game/triplea/pull/6549#discussion_r432903462", "createdAt": "2020-05-31T02:29:23Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/BattleSteps.java", "diffHunk": "@@ -0,0 +1,244 @@\n+package games.strategy.triplea.delegate.battle.steps;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.attachments.TechAttachment;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.battle.BattleStepStrings;\n+import games.strategy.triplea.delegate.battle.MustFightBattle.ReturnFire;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import lombok.Builder;\n+import lombok.NonNull;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Get the steps that will occurr in the battle */\n+@Builder\n+public class BattleSteps implements BattleStepStrings {\n+\n+  final @NonNull Boolean canFireOffensiveAa;\n+  final @NonNull Boolean canFireDefendingAa;\n+  final @NonNull Boolean showFirstRun;\n+  final @NonNull GamePlayer attacker;\n+  final @NonNull GamePlayer defender;\n+  final @NonNull Collection<Unit> offensiveAa;\n+  final @NonNull Collection<Unit> defendingAa;\n+  final @NonNull Collection<Unit> attackingUnits;\n+  final @NonNull Collection<Unit> defendingUnits;\n+  final @NonNull Collection<Unit> attackingWaitingToDie;\n+  final @NonNull Collection<Unit> defendingWaitingToDie;\n+  final @NonNull Territory battleSite;\n+  final @NonNull GameData gameData;\n+  final @NonNull Collection<Unit> bombardingUnits;\n+  final @NonNull Function<Collection<Unit>, Collection<Unit>> getDependentUnits;\n+  final @NonNull Boolean isBattleSiteWater;\n+  final @NonNull Boolean isAmphibious;\n+  final @NonNull Supplier<Collection<Territory>> getAttackerRetreatTerritories;\n+  final @NonNull BiFunction<GamePlayer, Collection<Unit>, Collection<Territory>>\n+      getEmptyOrFriendlySeaNeighbors;\n+\n+  public List<String> get() {\n+\n+    final List<String> steps = new ArrayList<>();\n+    if (canFireOffensiveAa) {\n+      for (final String typeAa : UnitAttachment.getAllOfTypeAas(offensiveAa)) {\n+        steps.add(attacker.getName() + \" \" + typeAa + AA_GUNS_FIRE_SUFFIX);\n+        steps.add(defender.getName() + SELECT_PREFIX + typeAa + CASUALTIES_SUFFIX);\n+        steps.add(defender.getName() + REMOVE_PREFIX + typeAa + CASUALTIES_SUFFIX);\n+      }\n+    }\n+    if (canFireDefendingAa) {\n+      for (final String typeAa : UnitAttachment.getAllOfTypeAas(defendingAa)) {\n+        steps.add(defender.getName() + \" \" + typeAa + AA_GUNS_FIRE_SUFFIX);\n+        steps.add(attacker.getName() + SELECT_PREFIX + typeAa + CASUALTIES_SUFFIX);\n+        steps.add(attacker.getName() + REMOVE_PREFIX + typeAa + CASUALTIES_SUFFIX);\n+      }\n+    }\n+    if (showFirstRun) {\n+      if (!isBattleSiteWater && !bombardingUnits.isEmpty()) {\n+        steps.add(NAVAL_BOMBARDMENT);\n+        steps.add(SELECT_NAVAL_BOMBARDMENT_CASUALTIES);\n+      }\n+      if (!isBattleSiteWater && TechAttachment.isAirTransportable(attacker)) {\n+        final Collection<Unit> bombers =\n+            CollectionUtils.getMatches(battleSite.getUnits(), Matches.unitIsAirTransport());\n+        if (!bombers.isEmpty()) {\n+          final Collection<Unit> dependents = getDependentUnits.apply(bombers);\n+          if (!dependents.isEmpty()) {\n+            steps.add(LAND_PARATROOPS);\n+          }\n+        }\n+      }\n+    }\n+    // Check if defending subs can submerge before battle\n+    if (Properties.getSubRetreatBeforeBattle(gameData)) {\n+      if (defendingUnits.stream().noneMatch(Matches.unitIsDestroyer())\n+          && attackingUnits.stream().anyMatch(Matches.unitCanEvade())) {\n+        steps.add(attacker.getName() + SUBS_SUBMERGE);\n+      }\n+      if (attackingUnits.stream().noneMatch(Matches.unitIsDestroyer())\n+          && defendingUnits.stream().anyMatch(Matches.unitCanEvade())) {\n+        steps.add(defender.getName() + SUBS_SUBMERGE);\n+      }\n+    }\n+    // See if there any unescorted transports\n+    if (isBattleSiteWater && Properties.getTransportCasualtiesRestricted(gameData)) {\n+      if (attackingUnits.stream().anyMatch(Matches.unitIsTransport())\n+          || defendingUnits.stream().anyMatch(Matches.unitIsTransport())) {\n+        steps.add(REMOVE_UNESCORTED_TRANSPORTS);\n+      }\n+    }\n+    final boolean defenderSubsFireFirst =\n+        SubsChecks.defenderSubsFireFirst(attackingUnits, defendingUnits, gameData);\n+    final ReturnFire returnFireAgainstAttackingSubs =\n+        SubsChecks.returnFireAgainstAttackingSubs(attackingUnits, defendingUnits, gameData);\n+    final ReturnFire returnFireAgainstDefendingSubs =\n+        SubsChecks.returnFireAgainstDefendingSubs(attackingUnits, defendingUnits, gameData);\n+    // if attacker has no sneak attack subs, then defender sneak attack subs fire first and remove\n+    // casualties\n+    if (defenderSubsFireFirst && defendingUnits.stream().anyMatch(Matches.unitIsFirstStrike())) {\n+      steps.add(defender.getName() + FIRST_STRIKE_UNITS_FIRE);\n+      steps.add(attacker.getName() + SELECT_FIRST_STRIKE_CASUALTIES);\n+      steps.add(REMOVE_SNEAK_ATTACK_CASUALTIES);\n+    }\n+    final boolean onlyAttackerSneakAttack =\n+        !defenderSubsFireFirst\n+            && returnFireAgainstAttackingSubs == ReturnFire.NONE\n+            && returnFireAgainstDefendingSubs == ReturnFire.ALL;\n+    // attacker subs sneak attack, no sneak attack if destroyers are present\n+    if (attackingUnits.stream().anyMatch(Matches.unitIsFirstStrike())) {\n+      steps.add(attacker.getName() + FIRST_STRIKE_UNITS_FIRE);\n+      steps.add(defender.getName() + SELECT_FIRST_STRIKE_CASUALTIES);\n+      if (onlyAttackerSneakAttack) {\n+        steps.add(REMOVE_SNEAK_ATTACK_CASUALTIES);\n+      }\n+    }\n+    // ww2v2 rules, all subs fire FIRST in combat, regardless of presence of destroyers.\n+    final boolean defendingSubsFireWithAllDefenders =\n+        !defenderSubsFireFirst\n+            && !Properties.getWW2V2(gameData)\n+            && returnFireAgainstDefendingSubs == ReturnFire.ALL;\n+    // defender subs sneak attack, no sneak attack in Pacific/Europe Theaters or if destroyers are\n+    // present\n+    final boolean defendingSubsFireWithAllDefendersAlways =\n+        !SubsChecks.defendingSubsSneakAttack(gameData);\n+    if (!defendingSubsFireWithAllDefendersAlways\n+        && !defendingSubsFireWithAllDefenders\n+        && !defenderSubsFireFirst\n+        && defendingUnits.stream().anyMatch(Matches.unitIsFirstStrike())) {\n+      steps.add(defender.getName() + FIRST_STRIKE_UNITS_FIRE);\n+      steps.add(attacker.getName() + SELECT_FIRST_STRIKE_CASUALTIES);\n+    }\n+    if ((attackingUnits.stream().anyMatch(Matches.unitIsFirstStrike())\n+            || defendingUnits.stream().anyMatch(Matches.unitIsFirstStrike()))\n+        && !defenderSubsFireFirst\n+        && !onlyAttackerSneakAttack\n+        && (returnFireAgainstDefendingSubs != ReturnFire.ALL\n+            || returnFireAgainstAttackingSubs != ReturnFire.ALL)) {\n+      steps.add(REMOVE_SNEAK_ATTACK_CASUALTIES);\n+    }\n+    // Air units can't attack subs without Destroyers present\n+    if (attackingUnits.stream().anyMatch(Matches.unitIsAir())\n+        && defendingUnits.stream().anyMatch(Matches.unitCanNotBeTargetedByAll())\n+        && !canAirAttackSubs(defendingUnits, attackingUnits)) {\n+      steps.add(SUBMERGE_SUBS_VS_AIR_ONLY);\n+      steps.add(AIR_ATTACK_NON_SUBS);\n+    }\n+    if (attackingUnits.stream().anyMatch(Matches.unitIsFirstStrike().negate())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ccde7081470c53de9f4c67f877cef2adae047fa"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkwMzQ2Mw==", "bodyText": "Identical blocks of code found in 2 locations. Consider refactoring.", "url": "https://github.com/triplea-game/triplea/pull/6549#discussion_r432903463", "createdAt": "2020-05-31T02:29:23Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/BattleSteps.java", "diffHunk": "@@ -0,0 +1,244 @@\n+package games.strategy.triplea.delegate.battle.steps;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.attachments.TechAttachment;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.battle.BattleStepStrings;\n+import games.strategy.triplea.delegate.battle.MustFightBattle.ReturnFire;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import lombok.Builder;\n+import lombok.NonNull;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Get the steps that will occurr in the battle */\n+@Builder\n+public class BattleSteps implements BattleStepStrings {\n+\n+  final @NonNull Boolean canFireOffensiveAa;\n+  final @NonNull Boolean canFireDefendingAa;\n+  final @NonNull Boolean showFirstRun;\n+  final @NonNull GamePlayer attacker;\n+  final @NonNull GamePlayer defender;\n+  final @NonNull Collection<Unit> offensiveAa;\n+  final @NonNull Collection<Unit> defendingAa;\n+  final @NonNull Collection<Unit> attackingUnits;\n+  final @NonNull Collection<Unit> defendingUnits;\n+  final @NonNull Collection<Unit> attackingWaitingToDie;\n+  final @NonNull Collection<Unit> defendingWaitingToDie;\n+  final @NonNull Territory battleSite;\n+  final @NonNull GameData gameData;\n+  final @NonNull Collection<Unit> bombardingUnits;\n+  final @NonNull Function<Collection<Unit>, Collection<Unit>> getDependentUnits;\n+  final @NonNull Boolean isBattleSiteWater;\n+  final @NonNull Boolean isAmphibious;\n+  final @NonNull Supplier<Collection<Territory>> getAttackerRetreatTerritories;\n+  final @NonNull BiFunction<GamePlayer, Collection<Unit>, Collection<Territory>>\n+      getEmptyOrFriendlySeaNeighbors;\n+\n+  public List<String> get() {\n+\n+    final List<String> steps = new ArrayList<>();\n+    if (canFireOffensiveAa) {\n+      for (final String typeAa : UnitAttachment.getAllOfTypeAas(offensiveAa)) {\n+        steps.add(attacker.getName() + \" \" + typeAa + AA_GUNS_FIRE_SUFFIX);\n+        steps.add(defender.getName() + SELECT_PREFIX + typeAa + CASUALTIES_SUFFIX);\n+        steps.add(defender.getName() + REMOVE_PREFIX + typeAa + CASUALTIES_SUFFIX);\n+      }\n+    }\n+    if (canFireDefendingAa) {\n+      for (final String typeAa : UnitAttachment.getAllOfTypeAas(defendingAa)) {\n+        steps.add(defender.getName() + \" \" + typeAa + AA_GUNS_FIRE_SUFFIX);\n+        steps.add(attacker.getName() + SELECT_PREFIX + typeAa + CASUALTIES_SUFFIX);\n+        steps.add(attacker.getName() + REMOVE_PREFIX + typeAa + CASUALTIES_SUFFIX);\n+      }\n+    }\n+    if (showFirstRun) {\n+      if (!isBattleSiteWater && !bombardingUnits.isEmpty()) {\n+        steps.add(NAVAL_BOMBARDMENT);\n+        steps.add(SELECT_NAVAL_BOMBARDMENT_CASUALTIES);\n+      }\n+      if (!isBattleSiteWater && TechAttachment.isAirTransportable(attacker)) {\n+        final Collection<Unit> bombers =\n+            CollectionUtils.getMatches(battleSite.getUnits(), Matches.unitIsAirTransport());\n+        if (!bombers.isEmpty()) {\n+          final Collection<Unit> dependents = getDependentUnits.apply(bombers);\n+          if (!dependents.isEmpty()) {\n+            steps.add(LAND_PARATROOPS);\n+          }\n+        }\n+      }\n+    }\n+    // Check if defending subs can submerge before battle\n+    if (Properties.getSubRetreatBeforeBattle(gameData)) {\n+      if (defendingUnits.stream().noneMatch(Matches.unitIsDestroyer())\n+          && attackingUnits.stream().anyMatch(Matches.unitCanEvade())) {\n+        steps.add(attacker.getName() + SUBS_SUBMERGE);\n+      }\n+      if (attackingUnits.stream().noneMatch(Matches.unitIsDestroyer())\n+          && defendingUnits.stream().anyMatch(Matches.unitCanEvade())) {\n+        steps.add(defender.getName() + SUBS_SUBMERGE);\n+      }\n+    }\n+    // See if there any unescorted transports\n+    if (isBattleSiteWater && Properties.getTransportCasualtiesRestricted(gameData)) {\n+      if (attackingUnits.stream().anyMatch(Matches.unitIsTransport())\n+          || defendingUnits.stream().anyMatch(Matches.unitIsTransport())) {\n+        steps.add(REMOVE_UNESCORTED_TRANSPORTS);\n+      }\n+    }\n+    final boolean defenderSubsFireFirst =\n+        SubsChecks.defenderSubsFireFirst(attackingUnits, defendingUnits, gameData);\n+    final ReturnFire returnFireAgainstAttackingSubs =\n+        SubsChecks.returnFireAgainstAttackingSubs(attackingUnits, defendingUnits, gameData);\n+    final ReturnFire returnFireAgainstDefendingSubs =\n+        SubsChecks.returnFireAgainstDefendingSubs(attackingUnits, defendingUnits, gameData);\n+    // if attacker has no sneak attack subs, then defender sneak attack subs fire first and remove\n+    // casualties\n+    if (defenderSubsFireFirst && defendingUnits.stream().anyMatch(Matches.unitIsFirstStrike())) {\n+      steps.add(defender.getName() + FIRST_STRIKE_UNITS_FIRE);\n+      steps.add(attacker.getName() + SELECT_FIRST_STRIKE_CASUALTIES);\n+      steps.add(REMOVE_SNEAK_ATTACK_CASUALTIES);\n+    }\n+    final boolean onlyAttackerSneakAttack =\n+        !defenderSubsFireFirst\n+            && returnFireAgainstAttackingSubs == ReturnFire.NONE\n+            && returnFireAgainstDefendingSubs == ReturnFire.ALL;\n+    // attacker subs sneak attack, no sneak attack if destroyers are present\n+    if (attackingUnits.stream().anyMatch(Matches.unitIsFirstStrike())) {\n+      steps.add(attacker.getName() + FIRST_STRIKE_UNITS_FIRE);\n+      steps.add(defender.getName() + SELECT_FIRST_STRIKE_CASUALTIES);\n+      if (onlyAttackerSneakAttack) {\n+        steps.add(REMOVE_SNEAK_ATTACK_CASUALTIES);\n+      }\n+    }\n+    // ww2v2 rules, all subs fire FIRST in combat, regardless of presence of destroyers.\n+    final boolean defendingSubsFireWithAllDefenders =\n+        !defenderSubsFireFirst\n+            && !Properties.getWW2V2(gameData)\n+            && returnFireAgainstDefendingSubs == ReturnFire.ALL;\n+    // defender subs sneak attack, no sneak attack in Pacific/Europe Theaters or if destroyers are\n+    // present\n+    final boolean defendingSubsFireWithAllDefendersAlways =\n+        !SubsChecks.defendingSubsSneakAttack(gameData);\n+    if (!defendingSubsFireWithAllDefendersAlways\n+        && !defendingSubsFireWithAllDefenders\n+        && !defenderSubsFireFirst\n+        && defendingUnits.stream().anyMatch(Matches.unitIsFirstStrike())) {\n+      steps.add(defender.getName() + FIRST_STRIKE_UNITS_FIRE);\n+      steps.add(attacker.getName() + SELECT_FIRST_STRIKE_CASUALTIES);\n+    }\n+    if ((attackingUnits.stream().anyMatch(Matches.unitIsFirstStrike())\n+            || defendingUnits.stream().anyMatch(Matches.unitIsFirstStrike()))\n+        && !defenderSubsFireFirst\n+        && !onlyAttackerSneakAttack\n+        && (returnFireAgainstDefendingSubs != ReturnFire.ALL\n+            || returnFireAgainstAttackingSubs != ReturnFire.ALL)) {\n+      steps.add(REMOVE_SNEAK_ATTACK_CASUALTIES);\n+    }\n+    // Air units can't attack subs without Destroyers present\n+    if (attackingUnits.stream().anyMatch(Matches.unitIsAir())\n+        && defendingUnits.stream().anyMatch(Matches.unitCanNotBeTargetedByAll())\n+        && !canAirAttackSubs(defendingUnits, attackingUnits)) {\n+      steps.add(SUBMERGE_SUBS_VS_AIR_ONLY);\n+      steps.add(AIR_ATTACK_NON_SUBS);\n+    }\n+    if (attackingUnits.stream().anyMatch(Matches.unitIsFirstStrike().negate())) {\n+      steps.add(attacker.getName() + FIRE);\n+      steps.add(defender.getName() + SELECT_CASUALTIES);\n+    }\n+    // classic rules, subs fire with all defenders\n+    // also, ww2v3/global rules, defending subs without sneak attack fire with all defenders\n+    final Collection<Unit> defendingUnitsAliveAndDamaged = new ArrayList<>(defendingUnits);\n+    // TODO: BUG? defendingWaitingToDie is always empty since this function is only called\n+    //       at the beginning of the battle and at the end of each round.\n+    defendingUnitsAliveAndDamaged.addAll(defendingWaitingToDie);\n+    // TODO: BUG? why is unitCanNotTargetAll used instead of unitIsFirstStrike?\n+    if (defendingUnitsAliveAndDamaged.stream().anyMatch(Matches.unitCanNotTargetAll())\n+        && !defenderSubsFireFirst\n+        && (defendingSubsFireWithAllDefenders || defendingSubsFireWithAllDefendersAlways)) {\n+      steps.add(defender.getName() + FIRST_STRIKE_UNITS_FIRE);\n+      steps.add(attacker.getName() + SELECT_FIRST_STRIKE_CASUALTIES);\n+    }\n+    // Air Units can't attack subs without Destroyers present\n+    if (defendingUnits.stream().anyMatch(Matches.unitIsAir())\n+        && attackingUnits.stream().anyMatch(Matches.unitCanNotBeTargetedByAll())\n+        && !canAirAttackSubs(attackingUnits, defendingUnitsAliveAndDamaged)) {\n+      steps.add(AIR_DEFEND_NON_SUBS);\n+    }\n+    if (defendingUnits.stream().anyMatch(Matches.unitIsFirstStrike().negate())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ccde7081470c53de9f4c67f877cef2adae047fa"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkwMzQ2NA==", "bodyText": "Method get has a Cognitive Complexity of 77 (exceeds 7 allowed). Consider refactoring.", "url": "https://github.com/triplea-game/triplea/pull/6549#discussion_r432903464", "createdAt": "2020-05-31T02:29:24Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/BattleSteps.java", "diffHunk": "@@ -0,0 +1,244 @@\n+package games.strategy.triplea.delegate.battle.steps;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.attachments.TechAttachment;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.battle.BattleStepStrings;\n+import games.strategy.triplea.delegate.battle.MustFightBattle.ReturnFire;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import lombok.Builder;\n+import lombok.NonNull;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Get the steps that will occurr in the battle */\n+@Builder\n+public class BattleSteps implements BattleStepStrings {\n+\n+  final @NonNull Boolean canFireOffensiveAa;\n+  final @NonNull Boolean canFireDefendingAa;\n+  final @NonNull Boolean showFirstRun;\n+  final @NonNull GamePlayer attacker;\n+  final @NonNull GamePlayer defender;\n+  final @NonNull Collection<Unit> offensiveAa;\n+  final @NonNull Collection<Unit> defendingAa;\n+  final @NonNull Collection<Unit> attackingUnits;\n+  final @NonNull Collection<Unit> defendingUnits;\n+  final @NonNull Collection<Unit> attackingWaitingToDie;\n+  final @NonNull Collection<Unit> defendingWaitingToDie;\n+  final @NonNull Territory battleSite;\n+  final @NonNull GameData gameData;\n+  final @NonNull Collection<Unit> bombardingUnits;\n+  final @NonNull Function<Collection<Unit>, Collection<Unit>> getDependentUnits;\n+  final @NonNull Boolean isBattleSiteWater;\n+  final @NonNull Boolean isAmphibious;\n+  final @NonNull Supplier<Collection<Territory>> getAttackerRetreatTerritories;\n+  final @NonNull BiFunction<GamePlayer, Collection<Unit>, Collection<Territory>>\n+      getEmptyOrFriendlySeaNeighbors;\n+\n+  public List<String> get() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ccde7081470c53de9f4c67f877cef2adae047fa"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkwMzQ2NQ==", "bodyText": "Identical blocks of code found in 2 locations. Consider refactoring.", "url": "https://github.com/triplea-game/triplea/pull/6549#discussion_r432903465", "createdAt": "2020-05-31T02:29:24Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/BattleSteps.java", "diffHunk": "@@ -0,0 +1,244 @@\n+package games.strategy.triplea.delegate.battle.steps;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.attachments.TechAttachment;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.battle.BattleStepStrings;\n+import games.strategy.triplea.delegate.battle.MustFightBattle.ReturnFire;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import lombok.Builder;\n+import lombok.NonNull;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Get the steps that will occurr in the battle */\n+@Builder\n+public class BattleSteps implements BattleStepStrings {\n+\n+  final @NonNull Boolean canFireOffensiveAa;\n+  final @NonNull Boolean canFireDefendingAa;\n+  final @NonNull Boolean showFirstRun;\n+  final @NonNull GamePlayer attacker;\n+  final @NonNull GamePlayer defender;\n+  final @NonNull Collection<Unit> offensiveAa;\n+  final @NonNull Collection<Unit> defendingAa;\n+  final @NonNull Collection<Unit> attackingUnits;\n+  final @NonNull Collection<Unit> defendingUnits;\n+  final @NonNull Collection<Unit> attackingWaitingToDie;\n+  final @NonNull Collection<Unit> defendingWaitingToDie;\n+  final @NonNull Territory battleSite;\n+  final @NonNull GameData gameData;\n+  final @NonNull Collection<Unit> bombardingUnits;\n+  final @NonNull Function<Collection<Unit>, Collection<Unit>> getDependentUnits;\n+  final @NonNull Boolean isBattleSiteWater;\n+  final @NonNull Boolean isAmphibious;\n+  final @NonNull Supplier<Collection<Territory>> getAttackerRetreatTerritories;\n+  final @NonNull BiFunction<GamePlayer, Collection<Unit>, Collection<Territory>>\n+      getEmptyOrFriendlySeaNeighbors;\n+\n+  public List<String> get() {\n+\n+    final List<String> steps = new ArrayList<>();\n+    if (canFireOffensiveAa) {\n+      for (final String typeAa : UnitAttachment.getAllOfTypeAas(offensiveAa)) {\n+        steps.add(attacker.getName() + \" \" + typeAa + AA_GUNS_FIRE_SUFFIX);\n+        steps.add(defender.getName() + SELECT_PREFIX + typeAa + CASUALTIES_SUFFIX);\n+        steps.add(defender.getName() + REMOVE_PREFIX + typeAa + CASUALTIES_SUFFIX);\n+      }\n+    }\n+    if (canFireDefendingAa) {\n+      for (final String typeAa : UnitAttachment.getAllOfTypeAas(defendingAa)) {\n+        steps.add(defender.getName() + \" \" + typeAa + AA_GUNS_FIRE_SUFFIX);\n+        steps.add(attacker.getName() + SELECT_PREFIX + typeAa + CASUALTIES_SUFFIX);\n+        steps.add(attacker.getName() + REMOVE_PREFIX + typeAa + CASUALTIES_SUFFIX);\n+      }\n+    }\n+    if (showFirstRun) {\n+      if (!isBattleSiteWater && !bombardingUnits.isEmpty()) {\n+        steps.add(NAVAL_BOMBARDMENT);\n+        steps.add(SELECT_NAVAL_BOMBARDMENT_CASUALTIES);\n+      }\n+      if (!isBattleSiteWater && TechAttachment.isAirTransportable(attacker)) {\n+        final Collection<Unit> bombers =\n+            CollectionUtils.getMatches(battleSite.getUnits(), Matches.unitIsAirTransport());\n+        if (!bombers.isEmpty()) {\n+          final Collection<Unit> dependents = getDependentUnits.apply(bombers);\n+          if (!dependents.isEmpty()) {\n+            steps.add(LAND_PARATROOPS);\n+          }\n+        }\n+      }\n+    }\n+    // Check if defending subs can submerge before battle\n+    if (Properties.getSubRetreatBeforeBattle(gameData)) {\n+      if (defendingUnits.stream().noneMatch(Matches.unitIsDestroyer())\n+          && attackingUnits.stream().anyMatch(Matches.unitCanEvade())) {\n+        steps.add(attacker.getName() + SUBS_SUBMERGE);\n+      }\n+      if (attackingUnits.stream().noneMatch(Matches.unitIsDestroyer())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ccde7081470c53de9f4c67f877cef2adae047fa"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkwMzQ2Ng==", "bodyText": "TODO found", "url": "https://github.com/triplea-game/triplea/pull/6549#discussion_r432903466", "createdAt": "2020-05-31T02:29:24Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/RetreatChecks.java", "diffHunk": "@@ -0,0 +1,103 @@\n+package games.strategy.triplea.delegate.battle.steps;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.function.BiFunction;\n+import java.util.function.Supplier;\n+import lombok.NonNull;\n+import lombok.experimental.UtilityClass;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+@UtilityClass\n+public class RetreatChecks {\n+  public static boolean canAttackerRetreatSubs(\n+      final @NonNull Collection<Unit> defendingUnits,\n+      final @NonNull Collection<Unit> defendingWaitingToDie,\n+      final @NonNull GameData gameData,\n+      final @NonNull Supplier<Collection<Territory>> getAttackerRetreatTerritories,\n+      final @NonNull Boolean isAmphibious) {\n+    if (defendingUnits.stream().anyMatch(Matches.unitIsDestroyer())) {\n+      return false;\n+    }\n+    return defendingWaitingToDie.stream().noneMatch(Matches.unitIsDestroyer())\n+        && (canAttackerRetreat(\n+                defendingUnits, gameData, getAttackerRetreatTerritories, isAmphibious)\n+            || Properties.getSubmersibleSubs(gameData));\n+  }\n+\n+  public static boolean canDefenderRetreatSubs(\n+      final @NonNull Collection<Unit> attackingUnits,\n+      final @NonNull Collection<Unit> attackingWaitingToDie,\n+      final @NonNull GamePlayer defender,\n+      final @NonNull Collection<Unit> defendingUnits,\n+      final @NonNull GameData gameData,\n+      final @NonNull BiFunction<GamePlayer, Collection<Unit>, Collection<Territory>>\n+              getEmptyOrFriendlySeaNeighbors) {\n+    if (attackingUnits.stream().anyMatch(Matches.unitIsDestroyer())) {\n+      return false;\n+    }\n+    return attackingWaitingToDie.stream().noneMatch(Matches.unitIsDestroyer())\n+        && (getEmptyOrFriendlySeaNeighbors\n+                    .apply(\n+                        defender,\n+                        CollectionUtils.getMatches(defendingUnits, Matches.unitCanEvade()))\n+                    .size()\n+                != 0\n+            || Properties.getSubmersibleSubs(gameData));\n+  }\n+\n+  public static boolean canAttackerRetreatPartialAmphib(\n+      final @NonNull Collection<Unit> attackingUnits,\n+      final @NonNull GameData gameData,\n+      final @NonNull Boolean isAmphibious) {\n+    if (isAmphibious && Properties.getPartialAmphibiousRetreat(gameData)) {\n+      // Only include land units when checking for allow amphibious retreat\n+      final List<Unit> landUnits = CollectionUtils.getMatches(attackingUnits, Matches.unitIsLand());\n+      for (final Unit unit : landUnits) {\n+        if (!unit.getWasAmphibious()) {\n+          return true;\n+        }\n+      }\n+    }\n+    return false;\n+  }\n+\n+  public static boolean canAttackerRetreatPlanes(\n+      final @NonNull Collection<Unit> attackingUnits,\n+      final @NonNull GameData gameData,\n+      final @NonNull Boolean isAmphibious) {\n+    // TODO: BUG? Why must it be amphibious to retreat planes", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ccde7081470c53de9f4c67f877cef2adae047fa"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkwMzQ2Nw==", "bodyText": "BUG found", "url": "https://github.com/triplea-game/triplea/pull/6549#discussion_r432903467", "createdAt": "2020-05-31T02:29:24Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/RetreatChecks.java", "diffHunk": "@@ -0,0 +1,103 @@\n+package games.strategy.triplea.delegate.battle.steps;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.function.BiFunction;\n+import java.util.function.Supplier;\n+import lombok.NonNull;\n+import lombok.experimental.UtilityClass;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+@UtilityClass\n+public class RetreatChecks {\n+  public static boolean canAttackerRetreatSubs(\n+      final @NonNull Collection<Unit> defendingUnits,\n+      final @NonNull Collection<Unit> defendingWaitingToDie,\n+      final @NonNull GameData gameData,\n+      final @NonNull Supplier<Collection<Territory>> getAttackerRetreatTerritories,\n+      final @NonNull Boolean isAmphibious) {\n+    if (defendingUnits.stream().anyMatch(Matches.unitIsDestroyer())) {\n+      return false;\n+    }\n+    return defendingWaitingToDie.stream().noneMatch(Matches.unitIsDestroyer())\n+        && (canAttackerRetreat(\n+                defendingUnits, gameData, getAttackerRetreatTerritories, isAmphibious)\n+            || Properties.getSubmersibleSubs(gameData));\n+  }\n+\n+  public static boolean canDefenderRetreatSubs(\n+      final @NonNull Collection<Unit> attackingUnits,\n+      final @NonNull Collection<Unit> attackingWaitingToDie,\n+      final @NonNull GamePlayer defender,\n+      final @NonNull Collection<Unit> defendingUnits,\n+      final @NonNull GameData gameData,\n+      final @NonNull BiFunction<GamePlayer, Collection<Unit>, Collection<Territory>>\n+              getEmptyOrFriendlySeaNeighbors) {\n+    if (attackingUnits.stream().anyMatch(Matches.unitIsDestroyer())) {\n+      return false;\n+    }\n+    return attackingWaitingToDie.stream().noneMatch(Matches.unitIsDestroyer())\n+        && (getEmptyOrFriendlySeaNeighbors\n+                    .apply(\n+                        defender,\n+                        CollectionUtils.getMatches(defendingUnits, Matches.unitCanEvade()))\n+                    .size()\n+                != 0\n+            || Properties.getSubmersibleSubs(gameData));\n+  }\n+\n+  public static boolean canAttackerRetreatPartialAmphib(\n+      final @NonNull Collection<Unit> attackingUnits,\n+      final @NonNull GameData gameData,\n+      final @NonNull Boolean isAmphibious) {\n+    if (isAmphibious && Properties.getPartialAmphibiousRetreat(gameData)) {\n+      // Only include land units when checking for allow amphibious retreat\n+      final List<Unit> landUnits = CollectionUtils.getMatches(attackingUnits, Matches.unitIsLand());\n+      for (final Unit unit : landUnits) {\n+        if (!unit.getWasAmphibious()) {\n+          return true;\n+        }\n+      }\n+    }\n+    return false;\n+  }\n+\n+  public static boolean canAttackerRetreatPlanes(\n+      final @NonNull Collection<Unit> attackingUnits,\n+      final @NonNull GameData gameData,\n+      final @NonNull Boolean isAmphibious) {\n+    // TODO: BUG? Why must it be amphibious to retreat planes", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ccde7081470c53de9f4c67f877cef2adae047fa"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkwMzQ2OA==", "bodyText": "TODO found", "url": "https://github.com/triplea-game/triplea/pull/6549#discussion_r432903468", "createdAt": "2020-05-31T02:29:24Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/BattleSteps.java", "diffHunk": "@@ -0,0 +1,244 @@\n+package games.strategy.triplea.delegate.battle.steps;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.attachments.TechAttachment;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.battle.BattleStepStrings;\n+import games.strategy.triplea.delegate.battle.MustFightBattle.ReturnFire;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import lombok.Builder;\n+import lombok.NonNull;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Get the steps that will occurr in the battle */\n+@Builder\n+public class BattleSteps implements BattleStepStrings {\n+\n+  final @NonNull Boolean canFireOffensiveAa;\n+  final @NonNull Boolean canFireDefendingAa;\n+  final @NonNull Boolean showFirstRun;\n+  final @NonNull GamePlayer attacker;\n+  final @NonNull GamePlayer defender;\n+  final @NonNull Collection<Unit> offensiveAa;\n+  final @NonNull Collection<Unit> defendingAa;\n+  final @NonNull Collection<Unit> attackingUnits;\n+  final @NonNull Collection<Unit> defendingUnits;\n+  final @NonNull Collection<Unit> attackingWaitingToDie;\n+  final @NonNull Collection<Unit> defendingWaitingToDie;\n+  final @NonNull Territory battleSite;\n+  final @NonNull GameData gameData;\n+  final @NonNull Collection<Unit> bombardingUnits;\n+  final @NonNull Function<Collection<Unit>, Collection<Unit>> getDependentUnits;\n+  final @NonNull Boolean isBattleSiteWater;\n+  final @NonNull Boolean isAmphibious;\n+  final @NonNull Supplier<Collection<Territory>> getAttackerRetreatTerritories;\n+  final @NonNull BiFunction<GamePlayer, Collection<Unit>, Collection<Territory>>\n+      getEmptyOrFriendlySeaNeighbors;\n+\n+  public List<String> get() {\n+\n+    final List<String> steps = new ArrayList<>();\n+    if (canFireOffensiveAa) {\n+      for (final String typeAa : UnitAttachment.getAllOfTypeAas(offensiveAa)) {\n+        steps.add(attacker.getName() + \" \" + typeAa + AA_GUNS_FIRE_SUFFIX);\n+        steps.add(defender.getName() + SELECT_PREFIX + typeAa + CASUALTIES_SUFFIX);\n+        steps.add(defender.getName() + REMOVE_PREFIX + typeAa + CASUALTIES_SUFFIX);\n+      }\n+    }\n+    if (canFireDefendingAa) {\n+      for (final String typeAa : UnitAttachment.getAllOfTypeAas(defendingAa)) {\n+        steps.add(defender.getName() + \" \" + typeAa + AA_GUNS_FIRE_SUFFIX);\n+        steps.add(attacker.getName() + SELECT_PREFIX + typeAa + CASUALTIES_SUFFIX);\n+        steps.add(attacker.getName() + REMOVE_PREFIX + typeAa + CASUALTIES_SUFFIX);\n+      }\n+    }\n+    if (showFirstRun) {\n+      if (!isBattleSiteWater && !bombardingUnits.isEmpty()) {\n+        steps.add(NAVAL_BOMBARDMENT);\n+        steps.add(SELECT_NAVAL_BOMBARDMENT_CASUALTIES);\n+      }\n+      if (!isBattleSiteWater && TechAttachment.isAirTransportable(attacker)) {\n+        final Collection<Unit> bombers =\n+            CollectionUtils.getMatches(battleSite.getUnits(), Matches.unitIsAirTransport());\n+        if (!bombers.isEmpty()) {\n+          final Collection<Unit> dependents = getDependentUnits.apply(bombers);\n+          if (!dependents.isEmpty()) {\n+            steps.add(LAND_PARATROOPS);\n+          }\n+        }\n+      }\n+    }\n+    // Check if defending subs can submerge before battle\n+    if (Properties.getSubRetreatBeforeBattle(gameData)) {\n+      if (defendingUnits.stream().noneMatch(Matches.unitIsDestroyer())\n+          && attackingUnits.stream().anyMatch(Matches.unitCanEvade())) {\n+        steps.add(attacker.getName() + SUBS_SUBMERGE);\n+      }\n+      if (attackingUnits.stream().noneMatch(Matches.unitIsDestroyer())\n+          && defendingUnits.stream().anyMatch(Matches.unitCanEvade())) {\n+        steps.add(defender.getName() + SUBS_SUBMERGE);\n+      }\n+    }\n+    // See if there any unescorted transports\n+    if (isBattleSiteWater && Properties.getTransportCasualtiesRestricted(gameData)) {\n+      if (attackingUnits.stream().anyMatch(Matches.unitIsTransport())\n+          || defendingUnits.stream().anyMatch(Matches.unitIsTransport())) {\n+        steps.add(REMOVE_UNESCORTED_TRANSPORTS);\n+      }\n+    }\n+    final boolean defenderSubsFireFirst =\n+        SubsChecks.defenderSubsFireFirst(attackingUnits, defendingUnits, gameData);\n+    final ReturnFire returnFireAgainstAttackingSubs =\n+        SubsChecks.returnFireAgainstAttackingSubs(attackingUnits, defendingUnits, gameData);\n+    final ReturnFire returnFireAgainstDefendingSubs =\n+        SubsChecks.returnFireAgainstDefendingSubs(attackingUnits, defendingUnits, gameData);\n+    // if attacker has no sneak attack subs, then defender sneak attack subs fire first and remove\n+    // casualties\n+    if (defenderSubsFireFirst && defendingUnits.stream().anyMatch(Matches.unitIsFirstStrike())) {\n+      steps.add(defender.getName() + FIRST_STRIKE_UNITS_FIRE);\n+      steps.add(attacker.getName() + SELECT_FIRST_STRIKE_CASUALTIES);\n+      steps.add(REMOVE_SNEAK_ATTACK_CASUALTIES);\n+    }\n+    final boolean onlyAttackerSneakAttack =\n+        !defenderSubsFireFirst\n+            && returnFireAgainstAttackingSubs == ReturnFire.NONE\n+            && returnFireAgainstDefendingSubs == ReturnFire.ALL;\n+    // attacker subs sneak attack, no sneak attack if destroyers are present\n+    if (attackingUnits.stream().anyMatch(Matches.unitIsFirstStrike())) {\n+      steps.add(attacker.getName() + FIRST_STRIKE_UNITS_FIRE);\n+      steps.add(defender.getName() + SELECT_FIRST_STRIKE_CASUALTIES);\n+      if (onlyAttackerSneakAttack) {\n+        steps.add(REMOVE_SNEAK_ATTACK_CASUALTIES);\n+      }\n+    }\n+    // ww2v2 rules, all subs fire FIRST in combat, regardless of presence of destroyers.\n+    final boolean defendingSubsFireWithAllDefenders =\n+        !defenderSubsFireFirst\n+            && !Properties.getWW2V2(gameData)\n+            && returnFireAgainstDefendingSubs == ReturnFire.ALL;\n+    // defender subs sneak attack, no sneak attack in Pacific/Europe Theaters or if destroyers are\n+    // present\n+    final boolean defendingSubsFireWithAllDefendersAlways =\n+        !SubsChecks.defendingSubsSneakAttack(gameData);\n+    if (!defendingSubsFireWithAllDefendersAlways\n+        && !defendingSubsFireWithAllDefenders\n+        && !defenderSubsFireFirst\n+        && defendingUnits.stream().anyMatch(Matches.unitIsFirstStrike())) {\n+      steps.add(defender.getName() + FIRST_STRIKE_UNITS_FIRE);\n+      steps.add(attacker.getName() + SELECT_FIRST_STRIKE_CASUALTIES);\n+    }\n+    if ((attackingUnits.stream().anyMatch(Matches.unitIsFirstStrike())\n+            || defendingUnits.stream().anyMatch(Matches.unitIsFirstStrike()))\n+        && !defenderSubsFireFirst\n+        && !onlyAttackerSneakAttack\n+        && (returnFireAgainstDefendingSubs != ReturnFire.ALL\n+            || returnFireAgainstAttackingSubs != ReturnFire.ALL)) {\n+      steps.add(REMOVE_SNEAK_ATTACK_CASUALTIES);\n+    }\n+    // Air units can't attack subs without Destroyers present\n+    if (attackingUnits.stream().anyMatch(Matches.unitIsAir())\n+        && defendingUnits.stream().anyMatch(Matches.unitCanNotBeTargetedByAll())\n+        && !canAirAttackSubs(defendingUnits, attackingUnits)) {\n+      steps.add(SUBMERGE_SUBS_VS_AIR_ONLY);\n+      steps.add(AIR_ATTACK_NON_SUBS);\n+    }\n+    if (attackingUnits.stream().anyMatch(Matches.unitIsFirstStrike().negate())) {\n+      steps.add(attacker.getName() + FIRE);\n+      steps.add(defender.getName() + SELECT_CASUALTIES);\n+    }\n+    // classic rules, subs fire with all defenders\n+    // also, ww2v3/global rules, defending subs without sneak attack fire with all defenders\n+    final Collection<Unit> defendingUnitsAliveAndDamaged = new ArrayList<>(defendingUnits);\n+    // TODO: BUG? defendingWaitingToDie is always empty since this function is only called", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ccde7081470c53de9f4c67f877cef2adae047fa"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkwMzQ2OQ==", "bodyText": "BUG found", "url": "https://github.com/triplea-game/triplea/pull/6549#discussion_r432903469", "createdAt": "2020-05-31T02:29:24Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/BattleSteps.java", "diffHunk": "@@ -0,0 +1,244 @@\n+package games.strategy.triplea.delegate.battle.steps;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.attachments.TechAttachment;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.battle.BattleStepStrings;\n+import games.strategy.triplea.delegate.battle.MustFightBattle.ReturnFire;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import lombok.Builder;\n+import lombok.NonNull;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Get the steps that will occurr in the battle */\n+@Builder\n+public class BattleSteps implements BattleStepStrings {\n+\n+  final @NonNull Boolean canFireOffensiveAa;\n+  final @NonNull Boolean canFireDefendingAa;\n+  final @NonNull Boolean showFirstRun;\n+  final @NonNull GamePlayer attacker;\n+  final @NonNull GamePlayer defender;\n+  final @NonNull Collection<Unit> offensiveAa;\n+  final @NonNull Collection<Unit> defendingAa;\n+  final @NonNull Collection<Unit> attackingUnits;\n+  final @NonNull Collection<Unit> defendingUnits;\n+  final @NonNull Collection<Unit> attackingWaitingToDie;\n+  final @NonNull Collection<Unit> defendingWaitingToDie;\n+  final @NonNull Territory battleSite;\n+  final @NonNull GameData gameData;\n+  final @NonNull Collection<Unit> bombardingUnits;\n+  final @NonNull Function<Collection<Unit>, Collection<Unit>> getDependentUnits;\n+  final @NonNull Boolean isBattleSiteWater;\n+  final @NonNull Boolean isAmphibious;\n+  final @NonNull Supplier<Collection<Territory>> getAttackerRetreatTerritories;\n+  final @NonNull BiFunction<GamePlayer, Collection<Unit>, Collection<Territory>>\n+      getEmptyOrFriendlySeaNeighbors;\n+\n+  public List<String> get() {\n+\n+    final List<String> steps = new ArrayList<>();\n+    if (canFireOffensiveAa) {\n+      for (final String typeAa : UnitAttachment.getAllOfTypeAas(offensiveAa)) {\n+        steps.add(attacker.getName() + \" \" + typeAa + AA_GUNS_FIRE_SUFFIX);\n+        steps.add(defender.getName() + SELECT_PREFIX + typeAa + CASUALTIES_SUFFIX);\n+        steps.add(defender.getName() + REMOVE_PREFIX + typeAa + CASUALTIES_SUFFIX);\n+      }\n+    }\n+    if (canFireDefendingAa) {\n+      for (final String typeAa : UnitAttachment.getAllOfTypeAas(defendingAa)) {\n+        steps.add(defender.getName() + \" \" + typeAa + AA_GUNS_FIRE_SUFFIX);\n+        steps.add(attacker.getName() + SELECT_PREFIX + typeAa + CASUALTIES_SUFFIX);\n+        steps.add(attacker.getName() + REMOVE_PREFIX + typeAa + CASUALTIES_SUFFIX);\n+      }\n+    }\n+    if (showFirstRun) {\n+      if (!isBattleSiteWater && !bombardingUnits.isEmpty()) {\n+        steps.add(NAVAL_BOMBARDMENT);\n+        steps.add(SELECT_NAVAL_BOMBARDMENT_CASUALTIES);\n+      }\n+      if (!isBattleSiteWater && TechAttachment.isAirTransportable(attacker)) {\n+        final Collection<Unit> bombers =\n+            CollectionUtils.getMatches(battleSite.getUnits(), Matches.unitIsAirTransport());\n+        if (!bombers.isEmpty()) {\n+          final Collection<Unit> dependents = getDependentUnits.apply(bombers);\n+          if (!dependents.isEmpty()) {\n+            steps.add(LAND_PARATROOPS);\n+          }\n+        }\n+      }\n+    }\n+    // Check if defending subs can submerge before battle\n+    if (Properties.getSubRetreatBeforeBattle(gameData)) {\n+      if (defendingUnits.stream().noneMatch(Matches.unitIsDestroyer())\n+          && attackingUnits.stream().anyMatch(Matches.unitCanEvade())) {\n+        steps.add(attacker.getName() + SUBS_SUBMERGE);\n+      }\n+      if (attackingUnits.stream().noneMatch(Matches.unitIsDestroyer())\n+          && defendingUnits.stream().anyMatch(Matches.unitCanEvade())) {\n+        steps.add(defender.getName() + SUBS_SUBMERGE);\n+      }\n+    }\n+    // See if there any unescorted transports\n+    if (isBattleSiteWater && Properties.getTransportCasualtiesRestricted(gameData)) {\n+      if (attackingUnits.stream().anyMatch(Matches.unitIsTransport())\n+          || defendingUnits.stream().anyMatch(Matches.unitIsTransport())) {\n+        steps.add(REMOVE_UNESCORTED_TRANSPORTS);\n+      }\n+    }\n+    final boolean defenderSubsFireFirst =\n+        SubsChecks.defenderSubsFireFirst(attackingUnits, defendingUnits, gameData);\n+    final ReturnFire returnFireAgainstAttackingSubs =\n+        SubsChecks.returnFireAgainstAttackingSubs(attackingUnits, defendingUnits, gameData);\n+    final ReturnFire returnFireAgainstDefendingSubs =\n+        SubsChecks.returnFireAgainstDefendingSubs(attackingUnits, defendingUnits, gameData);\n+    // if attacker has no sneak attack subs, then defender sneak attack subs fire first and remove\n+    // casualties\n+    if (defenderSubsFireFirst && defendingUnits.stream().anyMatch(Matches.unitIsFirstStrike())) {\n+      steps.add(defender.getName() + FIRST_STRIKE_UNITS_FIRE);\n+      steps.add(attacker.getName() + SELECT_FIRST_STRIKE_CASUALTIES);\n+      steps.add(REMOVE_SNEAK_ATTACK_CASUALTIES);\n+    }\n+    final boolean onlyAttackerSneakAttack =\n+        !defenderSubsFireFirst\n+            && returnFireAgainstAttackingSubs == ReturnFire.NONE\n+            && returnFireAgainstDefendingSubs == ReturnFire.ALL;\n+    // attacker subs sneak attack, no sneak attack if destroyers are present\n+    if (attackingUnits.stream().anyMatch(Matches.unitIsFirstStrike())) {\n+      steps.add(attacker.getName() + FIRST_STRIKE_UNITS_FIRE);\n+      steps.add(defender.getName() + SELECT_FIRST_STRIKE_CASUALTIES);\n+      if (onlyAttackerSneakAttack) {\n+        steps.add(REMOVE_SNEAK_ATTACK_CASUALTIES);\n+      }\n+    }\n+    // ww2v2 rules, all subs fire FIRST in combat, regardless of presence of destroyers.\n+    final boolean defendingSubsFireWithAllDefenders =\n+        !defenderSubsFireFirst\n+            && !Properties.getWW2V2(gameData)\n+            && returnFireAgainstDefendingSubs == ReturnFire.ALL;\n+    // defender subs sneak attack, no sneak attack in Pacific/Europe Theaters or if destroyers are\n+    // present\n+    final boolean defendingSubsFireWithAllDefendersAlways =\n+        !SubsChecks.defendingSubsSneakAttack(gameData);\n+    if (!defendingSubsFireWithAllDefendersAlways\n+        && !defendingSubsFireWithAllDefenders\n+        && !defenderSubsFireFirst\n+        && defendingUnits.stream().anyMatch(Matches.unitIsFirstStrike())) {\n+      steps.add(defender.getName() + FIRST_STRIKE_UNITS_FIRE);\n+      steps.add(attacker.getName() + SELECT_FIRST_STRIKE_CASUALTIES);\n+    }\n+    if ((attackingUnits.stream().anyMatch(Matches.unitIsFirstStrike())\n+            || defendingUnits.stream().anyMatch(Matches.unitIsFirstStrike()))\n+        && !defenderSubsFireFirst\n+        && !onlyAttackerSneakAttack\n+        && (returnFireAgainstDefendingSubs != ReturnFire.ALL\n+            || returnFireAgainstAttackingSubs != ReturnFire.ALL)) {\n+      steps.add(REMOVE_SNEAK_ATTACK_CASUALTIES);\n+    }\n+    // Air units can't attack subs without Destroyers present\n+    if (attackingUnits.stream().anyMatch(Matches.unitIsAir())\n+        && defendingUnits.stream().anyMatch(Matches.unitCanNotBeTargetedByAll())\n+        && !canAirAttackSubs(defendingUnits, attackingUnits)) {\n+      steps.add(SUBMERGE_SUBS_VS_AIR_ONLY);\n+      steps.add(AIR_ATTACK_NON_SUBS);\n+    }\n+    if (attackingUnits.stream().anyMatch(Matches.unitIsFirstStrike().negate())) {\n+      steps.add(attacker.getName() + FIRE);\n+      steps.add(defender.getName() + SELECT_CASUALTIES);\n+    }\n+    // classic rules, subs fire with all defenders\n+    // also, ww2v3/global rules, defending subs without sneak attack fire with all defenders\n+    final Collection<Unit> defendingUnitsAliveAndDamaged = new ArrayList<>(defendingUnits);\n+    // TODO: BUG? defendingWaitingToDie is always empty since this function is only called", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ccde7081470c53de9f4c67f877cef2adae047fa"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkwMzQ3MA==", "bodyText": "TODO found", "url": "https://github.com/triplea-game/triplea/pull/6549#discussion_r432903470", "createdAt": "2020-05-31T02:29:24Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/BattleSteps.java", "diffHunk": "@@ -0,0 +1,244 @@\n+package games.strategy.triplea.delegate.battle.steps;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.attachments.TechAttachment;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.battle.BattleStepStrings;\n+import games.strategy.triplea.delegate.battle.MustFightBattle.ReturnFire;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import lombok.Builder;\n+import lombok.NonNull;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Get the steps that will occurr in the battle */\n+@Builder\n+public class BattleSteps implements BattleStepStrings {\n+\n+  final @NonNull Boolean canFireOffensiveAa;\n+  final @NonNull Boolean canFireDefendingAa;\n+  final @NonNull Boolean showFirstRun;\n+  final @NonNull GamePlayer attacker;\n+  final @NonNull GamePlayer defender;\n+  final @NonNull Collection<Unit> offensiveAa;\n+  final @NonNull Collection<Unit> defendingAa;\n+  final @NonNull Collection<Unit> attackingUnits;\n+  final @NonNull Collection<Unit> defendingUnits;\n+  final @NonNull Collection<Unit> attackingWaitingToDie;\n+  final @NonNull Collection<Unit> defendingWaitingToDie;\n+  final @NonNull Territory battleSite;\n+  final @NonNull GameData gameData;\n+  final @NonNull Collection<Unit> bombardingUnits;\n+  final @NonNull Function<Collection<Unit>, Collection<Unit>> getDependentUnits;\n+  final @NonNull Boolean isBattleSiteWater;\n+  final @NonNull Boolean isAmphibious;\n+  final @NonNull Supplier<Collection<Territory>> getAttackerRetreatTerritories;\n+  final @NonNull BiFunction<GamePlayer, Collection<Unit>, Collection<Territory>>\n+      getEmptyOrFriendlySeaNeighbors;\n+\n+  public List<String> get() {\n+\n+    final List<String> steps = new ArrayList<>();\n+    if (canFireOffensiveAa) {\n+      for (final String typeAa : UnitAttachment.getAllOfTypeAas(offensiveAa)) {\n+        steps.add(attacker.getName() + \" \" + typeAa + AA_GUNS_FIRE_SUFFIX);\n+        steps.add(defender.getName() + SELECT_PREFIX + typeAa + CASUALTIES_SUFFIX);\n+        steps.add(defender.getName() + REMOVE_PREFIX + typeAa + CASUALTIES_SUFFIX);\n+      }\n+    }\n+    if (canFireDefendingAa) {\n+      for (final String typeAa : UnitAttachment.getAllOfTypeAas(defendingAa)) {\n+        steps.add(defender.getName() + \" \" + typeAa + AA_GUNS_FIRE_SUFFIX);\n+        steps.add(attacker.getName() + SELECT_PREFIX + typeAa + CASUALTIES_SUFFIX);\n+        steps.add(attacker.getName() + REMOVE_PREFIX + typeAa + CASUALTIES_SUFFIX);\n+      }\n+    }\n+    if (showFirstRun) {\n+      if (!isBattleSiteWater && !bombardingUnits.isEmpty()) {\n+        steps.add(NAVAL_BOMBARDMENT);\n+        steps.add(SELECT_NAVAL_BOMBARDMENT_CASUALTIES);\n+      }\n+      if (!isBattleSiteWater && TechAttachment.isAirTransportable(attacker)) {\n+        final Collection<Unit> bombers =\n+            CollectionUtils.getMatches(battleSite.getUnits(), Matches.unitIsAirTransport());\n+        if (!bombers.isEmpty()) {\n+          final Collection<Unit> dependents = getDependentUnits.apply(bombers);\n+          if (!dependents.isEmpty()) {\n+            steps.add(LAND_PARATROOPS);\n+          }\n+        }\n+      }\n+    }\n+    // Check if defending subs can submerge before battle\n+    if (Properties.getSubRetreatBeforeBattle(gameData)) {\n+      if (defendingUnits.stream().noneMatch(Matches.unitIsDestroyer())\n+          && attackingUnits.stream().anyMatch(Matches.unitCanEvade())) {\n+        steps.add(attacker.getName() + SUBS_SUBMERGE);\n+      }\n+      if (attackingUnits.stream().noneMatch(Matches.unitIsDestroyer())\n+          && defendingUnits.stream().anyMatch(Matches.unitCanEvade())) {\n+        steps.add(defender.getName() + SUBS_SUBMERGE);\n+      }\n+    }\n+    // See if there any unescorted transports\n+    if (isBattleSiteWater && Properties.getTransportCasualtiesRestricted(gameData)) {\n+      if (attackingUnits.stream().anyMatch(Matches.unitIsTransport())\n+          || defendingUnits.stream().anyMatch(Matches.unitIsTransport())) {\n+        steps.add(REMOVE_UNESCORTED_TRANSPORTS);\n+      }\n+    }\n+    final boolean defenderSubsFireFirst =\n+        SubsChecks.defenderSubsFireFirst(attackingUnits, defendingUnits, gameData);\n+    final ReturnFire returnFireAgainstAttackingSubs =\n+        SubsChecks.returnFireAgainstAttackingSubs(attackingUnits, defendingUnits, gameData);\n+    final ReturnFire returnFireAgainstDefendingSubs =\n+        SubsChecks.returnFireAgainstDefendingSubs(attackingUnits, defendingUnits, gameData);\n+    // if attacker has no sneak attack subs, then defender sneak attack subs fire first and remove\n+    // casualties\n+    if (defenderSubsFireFirst && defendingUnits.stream().anyMatch(Matches.unitIsFirstStrike())) {\n+      steps.add(defender.getName() + FIRST_STRIKE_UNITS_FIRE);\n+      steps.add(attacker.getName() + SELECT_FIRST_STRIKE_CASUALTIES);\n+      steps.add(REMOVE_SNEAK_ATTACK_CASUALTIES);\n+    }\n+    final boolean onlyAttackerSneakAttack =\n+        !defenderSubsFireFirst\n+            && returnFireAgainstAttackingSubs == ReturnFire.NONE\n+            && returnFireAgainstDefendingSubs == ReturnFire.ALL;\n+    // attacker subs sneak attack, no sneak attack if destroyers are present\n+    if (attackingUnits.stream().anyMatch(Matches.unitIsFirstStrike())) {\n+      steps.add(attacker.getName() + FIRST_STRIKE_UNITS_FIRE);\n+      steps.add(defender.getName() + SELECT_FIRST_STRIKE_CASUALTIES);\n+      if (onlyAttackerSneakAttack) {\n+        steps.add(REMOVE_SNEAK_ATTACK_CASUALTIES);\n+      }\n+    }\n+    // ww2v2 rules, all subs fire FIRST in combat, regardless of presence of destroyers.\n+    final boolean defendingSubsFireWithAllDefenders =\n+        !defenderSubsFireFirst\n+            && !Properties.getWW2V2(gameData)\n+            && returnFireAgainstDefendingSubs == ReturnFire.ALL;\n+    // defender subs sneak attack, no sneak attack in Pacific/Europe Theaters or if destroyers are\n+    // present\n+    final boolean defendingSubsFireWithAllDefendersAlways =\n+        !SubsChecks.defendingSubsSneakAttack(gameData);\n+    if (!defendingSubsFireWithAllDefendersAlways\n+        && !defendingSubsFireWithAllDefenders\n+        && !defenderSubsFireFirst\n+        && defendingUnits.stream().anyMatch(Matches.unitIsFirstStrike())) {\n+      steps.add(defender.getName() + FIRST_STRIKE_UNITS_FIRE);\n+      steps.add(attacker.getName() + SELECT_FIRST_STRIKE_CASUALTIES);\n+    }\n+    if ((attackingUnits.stream().anyMatch(Matches.unitIsFirstStrike())\n+            || defendingUnits.stream().anyMatch(Matches.unitIsFirstStrike()))\n+        && !defenderSubsFireFirst\n+        && !onlyAttackerSneakAttack\n+        && (returnFireAgainstDefendingSubs != ReturnFire.ALL\n+            || returnFireAgainstAttackingSubs != ReturnFire.ALL)) {\n+      steps.add(REMOVE_SNEAK_ATTACK_CASUALTIES);\n+    }\n+    // Air units can't attack subs without Destroyers present\n+    if (attackingUnits.stream().anyMatch(Matches.unitIsAir())\n+        && defendingUnits.stream().anyMatch(Matches.unitCanNotBeTargetedByAll())\n+        && !canAirAttackSubs(defendingUnits, attackingUnits)) {\n+      steps.add(SUBMERGE_SUBS_VS_AIR_ONLY);\n+      steps.add(AIR_ATTACK_NON_SUBS);\n+    }\n+    if (attackingUnits.stream().anyMatch(Matches.unitIsFirstStrike().negate())) {\n+      steps.add(attacker.getName() + FIRE);\n+      steps.add(defender.getName() + SELECT_CASUALTIES);\n+    }\n+    // classic rules, subs fire with all defenders\n+    // also, ww2v3/global rules, defending subs without sneak attack fire with all defenders\n+    final Collection<Unit> defendingUnitsAliveAndDamaged = new ArrayList<>(defendingUnits);\n+    // TODO: BUG? defendingWaitingToDie is always empty since this function is only called\n+    //       at the beginning of the battle and at the end of each round.\n+    defendingUnitsAliveAndDamaged.addAll(defendingWaitingToDie);\n+    // TODO: BUG? why is unitCanNotTargetAll used instead of unitIsFirstStrike?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ccde7081470c53de9f4c67f877cef2adae047fa"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkwMzQ3MQ==", "bodyText": "BUG found", "url": "https://github.com/triplea-game/triplea/pull/6549#discussion_r432903471", "createdAt": "2020-05-31T02:29:25Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/BattleSteps.java", "diffHunk": "@@ -0,0 +1,244 @@\n+package games.strategy.triplea.delegate.battle.steps;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.attachments.TechAttachment;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.battle.BattleStepStrings;\n+import games.strategy.triplea.delegate.battle.MustFightBattle.ReturnFire;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import lombok.Builder;\n+import lombok.NonNull;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Get the steps that will occurr in the battle */\n+@Builder\n+public class BattleSteps implements BattleStepStrings {\n+\n+  final @NonNull Boolean canFireOffensiveAa;\n+  final @NonNull Boolean canFireDefendingAa;\n+  final @NonNull Boolean showFirstRun;\n+  final @NonNull GamePlayer attacker;\n+  final @NonNull GamePlayer defender;\n+  final @NonNull Collection<Unit> offensiveAa;\n+  final @NonNull Collection<Unit> defendingAa;\n+  final @NonNull Collection<Unit> attackingUnits;\n+  final @NonNull Collection<Unit> defendingUnits;\n+  final @NonNull Collection<Unit> attackingWaitingToDie;\n+  final @NonNull Collection<Unit> defendingWaitingToDie;\n+  final @NonNull Territory battleSite;\n+  final @NonNull GameData gameData;\n+  final @NonNull Collection<Unit> bombardingUnits;\n+  final @NonNull Function<Collection<Unit>, Collection<Unit>> getDependentUnits;\n+  final @NonNull Boolean isBattleSiteWater;\n+  final @NonNull Boolean isAmphibious;\n+  final @NonNull Supplier<Collection<Territory>> getAttackerRetreatTerritories;\n+  final @NonNull BiFunction<GamePlayer, Collection<Unit>, Collection<Territory>>\n+      getEmptyOrFriendlySeaNeighbors;\n+\n+  public List<String> get() {\n+\n+    final List<String> steps = new ArrayList<>();\n+    if (canFireOffensiveAa) {\n+      for (final String typeAa : UnitAttachment.getAllOfTypeAas(offensiveAa)) {\n+        steps.add(attacker.getName() + \" \" + typeAa + AA_GUNS_FIRE_SUFFIX);\n+        steps.add(defender.getName() + SELECT_PREFIX + typeAa + CASUALTIES_SUFFIX);\n+        steps.add(defender.getName() + REMOVE_PREFIX + typeAa + CASUALTIES_SUFFIX);\n+      }\n+    }\n+    if (canFireDefendingAa) {\n+      for (final String typeAa : UnitAttachment.getAllOfTypeAas(defendingAa)) {\n+        steps.add(defender.getName() + \" \" + typeAa + AA_GUNS_FIRE_SUFFIX);\n+        steps.add(attacker.getName() + SELECT_PREFIX + typeAa + CASUALTIES_SUFFIX);\n+        steps.add(attacker.getName() + REMOVE_PREFIX + typeAa + CASUALTIES_SUFFIX);\n+      }\n+    }\n+    if (showFirstRun) {\n+      if (!isBattleSiteWater && !bombardingUnits.isEmpty()) {\n+        steps.add(NAVAL_BOMBARDMENT);\n+        steps.add(SELECT_NAVAL_BOMBARDMENT_CASUALTIES);\n+      }\n+      if (!isBattleSiteWater && TechAttachment.isAirTransportable(attacker)) {\n+        final Collection<Unit> bombers =\n+            CollectionUtils.getMatches(battleSite.getUnits(), Matches.unitIsAirTransport());\n+        if (!bombers.isEmpty()) {\n+          final Collection<Unit> dependents = getDependentUnits.apply(bombers);\n+          if (!dependents.isEmpty()) {\n+            steps.add(LAND_PARATROOPS);\n+          }\n+        }\n+      }\n+    }\n+    // Check if defending subs can submerge before battle\n+    if (Properties.getSubRetreatBeforeBattle(gameData)) {\n+      if (defendingUnits.stream().noneMatch(Matches.unitIsDestroyer())\n+          && attackingUnits.stream().anyMatch(Matches.unitCanEvade())) {\n+        steps.add(attacker.getName() + SUBS_SUBMERGE);\n+      }\n+      if (attackingUnits.stream().noneMatch(Matches.unitIsDestroyer())\n+          && defendingUnits.stream().anyMatch(Matches.unitCanEvade())) {\n+        steps.add(defender.getName() + SUBS_SUBMERGE);\n+      }\n+    }\n+    // See if there any unescorted transports\n+    if (isBattleSiteWater && Properties.getTransportCasualtiesRestricted(gameData)) {\n+      if (attackingUnits.stream().anyMatch(Matches.unitIsTransport())\n+          || defendingUnits.stream().anyMatch(Matches.unitIsTransport())) {\n+        steps.add(REMOVE_UNESCORTED_TRANSPORTS);\n+      }\n+    }\n+    final boolean defenderSubsFireFirst =\n+        SubsChecks.defenderSubsFireFirst(attackingUnits, defendingUnits, gameData);\n+    final ReturnFire returnFireAgainstAttackingSubs =\n+        SubsChecks.returnFireAgainstAttackingSubs(attackingUnits, defendingUnits, gameData);\n+    final ReturnFire returnFireAgainstDefendingSubs =\n+        SubsChecks.returnFireAgainstDefendingSubs(attackingUnits, defendingUnits, gameData);\n+    // if attacker has no sneak attack subs, then defender sneak attack subs fire first and remove\n+    // casualties\n+    if (defenderSubsFireFirst && defendingUnits.stream().anyMatch(Matches.unitIsFirstStrike())) {\n+      steps.add(defender.getName() + FIRST_STRIKE_UNITS_FIRE);\n+      steps.add(attacker.getName() + SELECT_FIRST_STRIKE_CASUALTIES);\n+      steps.add(REMOVE_SNEAK_ATTACK_CASUALTIES);\n+    }\n+    final boolean onlyAttackerSneakAttack =\n+        !defenderSubsFireFirst\n+            && returnFireAgainstAttackingSubs == ReturnFire.NONE\n+            && returnFireAgainstDefendingSubs == ReturnFire.ALL;\n+    // attacker subs sneak attack, no sneak attack if destroyers are present\n+    if (attackingUnits.stream().anyMatch(Matches.unitIsFirstStrike())) {\n+      steps.add(attacker.getName() + FIRST_STRIKE_UNITS_FIRE);\n+      steps.add(defender.getName() + SELECT_FIRST_STRIKE_CASUALTIES);\n+      if (onlyAttackerSneakAttack) {\n+        steps.add(REMOVE_SNEAK_ATTACK_CASUALTIES);\n+      }\n+    }\n+    // ww2v2 rules, all subs fire FIRST in combat, regardless of presence of destroyers.\n+    final boolean defendingSubsFireWithAllDefenders =\n+        !defenderSubsFireFirst\n+            && !Properties.getWW2V2(gameData)\n+            && returnFireAgainstDefendingSubs == ReturnFire.ALL;\n+    // defender subs sneak attack, no sneak attack in Pacific/Europe Theaters or if destroyers are\n+    // present\n+    final boolean defendingSubsFireWithAllDefendersAlways =\n+        !SubsChecks.defendingSubsSneakAttack(gameData);\n+    if (!defendingSubsFireWithAllDefendersAlways\n+        && !defendingSubsFireWithAllDefenders\n+        && !defenderSubsFireFirst\n+        && defendingUnits.stream().anyMatch(Matches.unitIsFirstStrike())) {\n+      steps.add(defender.getName() + FIRST_STRIKE_UNITS_FIRE);\n+      steps.add(attacker.getName() + SELECT_FIRST_STRIKE_CASUALTIES);\n+    }\n+    if ((attackingUnits.stream().anyMatch(Matches.unitIsFirstStrike())\n+            || defendingUnits.stream().anyMatch(Matches.unitIsFirstStrike()))\n+        && !defenderSubsFireFirst\n+        && !onlyAttackerSneakAttack\n+        && (returnFireAgainstDefendingSubs != ReturnFire.ALL\n+            || returnFireAgainstAttackingSubs != ReturnFire.ALL)) {\n+      steps.add(REMOVE_SNEAK_ATTACK_CASUALTIES);\n+    }\n+    // Air units can't attack subs without Destroyers present\n+    if (attackingUnits.stream().anyMatch(Matches.unitIsAir())\n+        && defendingUnits.stream().anyMatch(Matches.unitCanNotBeTargetedByAll())\n+        && !canAirAttackSubs(defendingUnits, attackingUnits)) {\n+      steps.add(SUBMERGE_SUBS_VS_AIR_ONLY);\n+      steps.add(AIR_ATTACK_NON_SUBS);\n+    }\n+    if (attackingUnits.stream().anyMatch(Matches.unitIsFirstStrike().negate())) {\n+      steps.add(attacker.getName() + FIRE);\n+      steps.add(defender.getName() + SELECT_CASUALTIES);\n+    }\n+    // classic rules, subs fire with all defenders\n+    // also, ww2v3/global rules, defending subs without sneak attack fire with all defenders\n+    final Collection<Unit> defendingUnitsAliveAndDamaged = new ArrayList<>(defendingUnits);\n+    // TODO: BUG? defendingWaitingToDie is always empty since this function is only called\n+    //       at the beginning of the battle and at the end of each round.\n+    defendingUnitsAliveAndDamaged.addAll(defendingWaitingToDie);\n+    // TODO: BUG? why is unitCanNotTargetAll used instead of unitIsFirstStrike?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ccde7081470c53de9f4c67f877cef2adae047fa"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkwMzQ3Mg==", "bodyText": "TODO found", "url": "https://github.com/triplea-game/triplea/pull/6549#discussion_r432903472", "createdAt": "2020-05-31T02:29:25Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/BattleSteps.java", "diffHunk": "@@ -0,0 +1,244 @@\n+package games.strategy.triplea.delegate.battle.steps;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.attachments.TechAttachment;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.battle.BattleStepStrings;\n+import games.strategy.triplea.delegate.battle.MustFightBattle.ReturnFire;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import lombok.Builder;\n+import lombok.NonNull;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Get the steps that will occurr in the battle */\n+@Builder\n+public class BattleSteps implements BattleStepStrings {\n+\n+  final @NonNull Boolean canFireOffensiveAa;\n+  final @NonNull Boolean canFireDefendingAa;\n+  final @NonNull Boolean showFirstRun;\n+  final @NonNull GamePlayer attacker;\n+  final @NonNull GamePlayer defender;\n+  final @NonNull Collection<Unit> offensiveAa;\n+  final @NonNull Collection<Unit> defendingAa;\n+  final @NonNull Collection<Unit> attackingUnits;\n+  final @NonNull Collection<Unit> defendingUnits;\n+  final @NonNull Collection<Unit> attackingWaitingToDie;\n+  final @NonNull Collection<Unit> defendingWaitingToDie;\n+  final @NonNull Territory battleSite;\n+  final @NonNull GameData gameData;\n+  final @NonNull Collection<Unit> bombardingUnits;\n+  final @NonNull Function<Collection<Unit>, Collection<Unit>> getDependentUnits;\n+  final @NonNull Boolean isBattleSiteWater;\n+  final @NonNull Boolean isAmphibious;\n+  final @NonNull Supplier<Collection<Territory>> getAttackerRetreatTerritories;\n+  final @NonNull BiFunction<GamePlayer, Collection<Unit>, Collection<Territory>>\n+      getEmptyOrFriendlySeaNeighbors;\n+\n+  public List<String> get() {\n+\n+    final List<String> steps = new ArrayList<>();\n+    if (canFireOffensiveAa) {\n+      for (final String typeAa : UnitAttachment.getAllOfTypeAas(offensiveAa)) {\n+        steps.add(attacker.getName() + \" \" + typeAa + AA_GUNS_FIRE_SUFFIX);\n+        steps.add(defender.getName() + SELECT_PREFIX + typeAa + CASUALTIES_SUFFIX);\n+        steps.add(defender.getName() + REMOVE_PREFIX + typeAa + CASUALTIES_SUFFIX);\n+      }\n+    }\n+    if (canFireDefendingAa) {\n+      for (final String typeAa : UnitAttachment.getAllOfTypeAas(defendingAa)) {\n+        steps.add(defender.getName() + \" \" + typeAa + AA_GUNS_FIRE_SUFFIX);\n+        steps.add(attacker.getName() + SELECT_PREFIX + typeAa + CASUALTIES_SUFFIX);\n+        steps.add(attacker.getName() + REMOVE_PREFIX + typeAa + CASUALTIES_SUFFIX);\n+      }\n+    }\n+    if (showFirstRun) {\n+      if (!isBattleSiteWater && !bombardingUnits.isEmpty()) {\n+        steps.add(NAVAL_BOMBARDMENT);\n+        steps.add(SELECT_NAVAL_BOMBARDMENT_CASUALTIES);\n+      }\n+      if (!isBattleSiteWater && TechAttachment.isAirTransportable(attacker)) {\n+        final Collection<Unit> bombers =\n+            CollectionUtils.getMatches(battleSite.getUnits(), Matches.unitIsAirTransport());\n+        if (!bombers.isEmpty()) {\n+          final Collection<Unit> dependents = getDependentUnits.apply(bombers);\n+          if (!dependents.isEmpty()) {\n+            steps.add(LAND_PARATROOPS);\n+          }\n+        }\n+      }\n+    }\n+    // Check if defending subs can submerge before battle\n+    if (Properties.getSubRetreatBeforeBattle(gameData)) {\n+      if (defendingUnits.stream().noneMatch(Matches.unitIsDestroyer())\n+          && attackingUnits.stream().anyMatch(Matches.unitCanEvade())) {\n+        steps.add(attacker.getName() + SUBS_SUBMERGE);\n+      }\n+      if (attackingUnits.stream().noneMatch(Matches.unitIsDestroyer())\n+          && defendingUnits.stream().anyMatch(Matches.unitCanEvade())) {\n+        steps.add(defender.getName() + SUBS_SUBMERGE);\n+      }\n+    }\n+    // See if there any unescorted transports\n+    if (isBattleSiteWater && Properties.getTransportCasualtiesRestricted(gameData)) {\n+      if (attackingUnits.stream().anyMatch(Matches.unitIsTransport())\n+          || defendingUnits.stream().anyMatch(Matches.unitIsTransport())) {\n+        steps.add(REMOVE_UNESCORTED_TRANSPORTS);\n+      }\n+    }\n+    final boolean defenderSubsFireFirst =\n+        SubsChecks.defenderSubsFireFirst(attackingUnits, defendingUnits, gameData);\n+    final ReturnFire returnFireAgainstAttackingSubs =\n+        SubsChecks.returnFireAgainstAttackingSubs(attackingUnits, defendingUnits, gameData);\n+    final ReturnFire returnFireAgainstDefendingSubs =\n+        SubsChecks.returnFireAgainstDefendingSubs(attackingUnits, defendingUnits, gameData);\n+    // if attacker has no sneak attack subs, then defender sneak attack subs fire first and remove\n+    // casualties\n+    if (defenderSubsFireFirst && defendingUnits.stream().anyMatch(Matches.unitIsFirstStrike())) {\n+      steps.add(defender.getName() + FIRST_STRIKE_UNITS_FIRE);\n+      steps.add(attacker.getName() + SELECT_FIRST_STRIKE_CASUALTIES);\n+      steps.add(REMOVE_SNEAK_ATTACK_CASUALTIES);\n+    }\n+    final boolean onlyAttackerSneakAttack =\n+        !defenderSubsFireFirst\n+            && returnFireAgainstAttackingSubs == ReturnFire.NONE\n+            && returnFireAgainstDefendingSubs == ReturnFire.ALL;\n+    // attacker subs sneak attack, no sneak attack if destroyers are present\n+    if (attackingUnits.stream().anyMatch(Matches.unitIsFirstStrike())) {\n+      steps.add(attacker.getName() + FIRST_STRIKE_UNITS_FIRE);\n+      steps.add(defender.getName() + SELECT_FIRST_STRIKE_CASUALTIES);\n+      if (onlyAttackerSneakAttack) {\n+        steps.add(REMOVE_SNEAK_ATTACK_CASUALTIES);\n+      }\n+    }\n+    // ww2v2 rules, all subs fire FIRST in combat, regardless of presence of destroyers.\n+    final boolean defendingSubsFireWithAllDefenders =\n+        !defenderSubsFireFirst\n+            && !Properties.getWW2V2(gameData)\n+            && returnFireAgainstDefendingSubs == ReturnFire.ALL;\n+    // defender subs sneak attack, no sneak attack in Pacific/Europe Theaters or if destroyers are\n+    // present\n+    final boolean defendingSubsFireWithAllDefendersAlways =\n+        !SubsChecks.defendingSubsSneakAttack(gameData);\n+    if (!defendingSubsFireWithAllDefendersAlways\n+        && !defendingSubsFireWithAllDefenders\n+        && !defenderSubsFireFirst\n+        && defendingUnits.stream().anyMatch(Matches.unitIsFirstStrike())) {\n+      steps.add(defender.getName() + FIRST_STRIKE_UNITS_FIRE);\n+      steps.add(attacker.getName() + SELECT_FIRST_STRIKE_CASUALTIES);\n+    }\n+    if ((attackingUnits.stream().anyMatch(Matches.unitIsFirstStrike())\n+            || defendingUnits.stream().anyMatch(Matches.unitIsFirstStrike()))\n+        && !defenderSubsFireFirst\n+        && !onlyAttackerSneakAttack\n+        && (returnFireAgainstDefendingSubs != ReturnFire.ALL\n+            || returnFireAgainstAttackingSubs != ReturnFire.ALL)) {\n+      steps.add(REMOVE_SNEAK_ATTACK_CASUALTIES);\n+    }\n+    // Air units can't attack subs without Destroyers present\n+    if (attackingUnits.stream().anyMatch(Matches.unitIsAir())\n+        && defendingUnits.stream().anyMatch(Matches.unitCanNotBeTargetedByAll())\n+        && !canAirAttackSubs(defendingUnits, attackingUnits)) {\n+      steps.add(SUBMERGE_SUBS_VS_AIR_ONLY);\n+      steps.add(AIR_ATTACK_NON_SUBS);\n+    }\n+    if (attackingUnits.stream().anyMatch(Matches.unitIsFirstStrike().negate())) {\n+      steps.add(attacker.getName() + FIRE);\n+      steps.add(defender.getName() + SELECT_CASUALTIES);\n+    }\n+    // classic rules, subs fire with all defenders\n+    // also, ww2v3/global rules, defending subs without sneak attack fire with all defenders\n+    final Collection<Unit> defendingUnitsAliveAndDamaged = new ArrayList<>(defendingUnits);\n+    // TODO: BUG? defendingWaitingToDie is always empty since this function is only called\n+    //       at the beginning of the battle and at the end of each round.\n+    defendingUnitsAliveAndDamaged.addAll(defendingWaitingToDie);\n+    // TODO: BUG? why is unitCanNotTargetAll used instead of unitIsFirstStrike?\n+    if (defendingUnitsAliveAndDamaged.stream().anyMatch(Matches.unitCanNotTargetAll())\n+        && !defenderSubsFireFirst\n+        && (defendingSubsFireWithAllDefenders || defendingSubsFireWithAllDefendersAlways)) {\n+      steps.add(defender.getName() + FIRST_STRIKE_UNITS_FIRE);\n+      steps.add(attacker.getName() + SELECT_FIRST_STRIKE_CASUALTIES);\n+    }\n+    // Air Units can't attack subs without Destroyers present\n+    if (defendingUnits.stream().anyMatch(Matches.unitIsAir())\n+        && attackingUnits.stream().anyMatch(Matches.unitCanNotBeTargetedByAll())\n+        && !canAirAttackSubs(attackingUnits, defendingUnitsAliveAndDamaged)) {\n+      steps.add(AIR_DEFEND_NON_SUBS);\n+    }\n+    if (defendingUnits.stream().anyMatch(Matches.unitIsFirstStrike().negate())) {\n+      steps.add(defender.getName() + FIRE);\n+      steps.add(attacker.getName() + SELECT_CASUALTIES);\n+    }\n+    // remove casualties\n+    steps.add(REMOVE_CASUALTIES);\n+    // retreat attacking subs\n+    if (attackingUnits.stream().anyMatch(Matches.unitCanEvade())) {\n+      if (Properties.getSubmersibleSubs(gameData)) {\n+        // TODO: BUG? Should the presence of destroyers be checked?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ccde7081470c53de9f4c67f877cef2adae047fa"}, "originalPosition": 187}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ebd38a18d7e085e879ba158c77bc2b13c2335982", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/ebd38a18d7e085e879ba158c77bc2b13c2335982", "committedDate": "2020-05-31T02:43:17Z", "message": "Rename StepStrings to BattleSteps and test it"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "56ff38338f32166fef90bdf64269795a1908dddf", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/56ff38338f32166fef90bdf64269795a1908dddf", "committedDate": "2020-05-31T02:43:17Z", "message": "Move shared code into utility classes"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2ccde7081470c53de9f4c67f877cef2adae047fa", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/2ccde7081470c53de9f4c67f877cef2adae047fa", "committedDate": "2020-05-30T15:41:33Z", "message": "Move shared code into utility classes"}, "afterCommit": {"oid": "56ff38338f32166fef90bdf64269795a1908dddf", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/56ff38338f32166fef90bdf64269795a1908dddf", "committedDate": "2020-05-31T02:43:17Z", "message": "Move shared code into utility classes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxNDU3MDEx", "url": "https://github.com/triplea-game/triplea/pull/6549#pullrequestreview-421457011", "createdAt": "2020-05-31T02:45:02Z", "commit": {"oid": "56ff38338f32166fef90bdf64269795a1908dddf"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMVQwMjo0NTowMlrOGc2X2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMVQwMjo0NTowMlrOGc2X2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkwNDE1Mg==", "bodyText": "BUG found", "url": "https://github.com/triplea-game/triplea/pull/6549#discussion_r432904152", "createdAt": "2020-05-31T02:45:02Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/BattleSteps.java", "diffHunk": "@@ -0,0 +1,242 @@\n+package games.strategy.triplea.delegate.battle.steps;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.attachments.TechAttachment;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.battle.BattleStepStrings;\n+import games.strategy.triplea.delegate.battle.MustFightBattle.ReturnFire;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import lombok.Builder;\n+import lombok.NonNull;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Get the steps that will occurr in the battle */\n+@Builder\n+public class BattleSteps implements BattleStepStrings {\n+\n+  final @NonNull Boolean canFireOffensiveAa;\n+  final @NonNull Boolean canFireDefendingAa;\n+  final @NonNull Boolean showFirstRun;\n+  final @NonNull GamePlayer attacker;\n+  final @NonNull GamePlayer defender;\n+  final @NonNull Collection<Unit> offensiveAa;\n+  final @NonNull Collection<Unit> defendingAa;\n+  final @NonNull Collection<Unit> attackingUnits;\n+  final @NonNull Collection<Unit> defendingUnits;\n+  final @NonNull Collection<Unit> attackingWaitingToDie;\n+  final @NonNull Collection<Unit> defendingWaitingToDie;\n+  final @NonNull Territory battleSite;\n+  final @NonNull GameData gameData;\n+  final @NonNull Collection<Unit> bombardingUnits;\n+  final @NonNull Function<Collection<Unit>, Collection<Unit>> getDependentUnits;\n+  final @NonNull Boolean isBattleSiteWater;\n+  final @NonNull Boolean isAmphibious;\n+  final @NonNull Supplier<Collection<Territory>> getAttackerRetreatTerritories;\n+  final @NonNull BiFunction<GamePlayer, Collection<Unit>, Collection<Territory>>\n+      getEmptyOrFriendlySeaNeighbors;\n+\n+  public List<String> get() {\n+\n+    final List<String> steps = new ArrayList<>();\n+    if (canFireOffensiveAa) {\n+      for (final String typeAa : UnitAttachment.getAllOfTypeAas(offensiveAa)) {\n+        steps.add(attacker.getName() + \" \" + typeAa + AA_GUNS_FIRE_SUFFIX);\n+        steps.add(defender.getName() + SELECT_PREFIX + typeAa + CASUALTIES_SUFFIX);\n+        steps.add(defender.getName() + REMOVE_PREFIX + typeAa + CASUALTIES_SUFFIX);\n+      }\n+    }\n+    if (canFireDefendingAa) {\n+      for (final String typeAa : UnitAttachment.getAllOfTypeAas(defendingAa)) {\n+        steps.add(defender.getName() + \" \" + typeAa + AA_GUNS_FIRE_SUFFIX);\n+        steps.add(attacker.getName() + SELECT_PREFIX + typeAa + CASUALTIES_SUFFIX);\n+        steps.add(attacker.getName() + REMOVE_PREFIX + typeAa + CASUALTIES_SUFFIX);\n+      }\n+    }\n+    if (showFirstRun) {\n+      if (!isBattleSiteWater && !bombardingUnits.isEmpty()) {\n+        steps.add(NAVAL_BOMBARDMENT);\n+        steps.add(SELECT_NAVAL_BOMBARDMENT_CASUALTIES);\n+      }\n+      if (!isBattleSiteWater && TechAttachment.isAirTransportable(attacker)) {\n+        final Collection<Unit> bombers =\n+            CollectionUtils.getMatches(battleSite.getUnits(), Matches.unitIsAirTransport());\n+        if (!bombers.isEmpty()) {\n+          final Collection<Unit> dependents = getDependentUnits.apply(bombers);\n+          if (!dependents.isEmpty()) {\n+            steps.add(LAND_PARATROOPS);\n+          }\n+        }\n+      }\n+    }\n+    // Check if defending subs can submerge before battle\n+    if (Properties.getSubRetreatBeforeBattle(gameData)) {\n+      if (defendingUnits.stream().noneMatch(Matches.unitIsDestroyer())\n+          && attackingUnits.stream().anyMatch(Matches.unitCanEvade())) {\n+        steps.add(attacker.getName() + SUBS_SUBMERGE);\n+      }\n+      if (attackingUnits.stream().noneMatch(Matches.unitIsDestroyer())\n+          && defendingUnits.stream().anyMatch(Matches.unitCanEvade())) {\n+        steps.add(defender.getName() + SUBS_SUBMERGE);\n+      }\n+    }\n+    // See if there any unescorted transports\n+    if (isBattleSiteWater && Properties.getTransportCasualtiesRestricted(gameData)) {\n+      if (attackingUnits.stream().anyMatch(Matches.unitIsTransport())\n+          || defendingUnits.stream().anyMatch(Matches.unitIsTransport())) {\n+        steps.add(REMOVE_UNESCORTED_TRANSPORTS);\n+      }\n+    }\n+    final boolean defenderSubsFireFirst =\n+        SubsChecks.defenderSubsFireFirst(attackingUnits, defendingUnits, gameData);\n+    final ReturnFire returnFireAgainstAttackingSubs =\n+        SubsChecks.returnFireAgainstAttackingSubs(attackingUnits, defendingUnits, gameData);\n+    final ReturnFire returnFireAgainstDefendingSubs =\n+        SubsChecks.returnFireAgainstDefendingSubs(attackingUnits, defendingUnits, gameData);\n+    // if attacker has no sneak attack subs, then defender sneak attack subs fire first and remove\n+    // casualties\n+    if (defenderSubsFireFirst && defendingUnits.stream().anyMatch(Matches.unitIsFirstStrike())) {\n+      steps.add(defender.getName() + FIRST_STRIKE_UNITS_FIRE);\n+      steps.add(attacker.getName() + SELECT_FIRST_STRIKE_CASUALTIES);\n+      steps.add(REMOVE_SNEAK_ATTACK_CASUALTIES);\n+    }\n+    final boolean onlyAttackerSneakAttack =\n+        !defenderSubsFireFirst\n+            && returnFireAgainstAttackingSubs == ReturnFire.NONE\n+            && returnFireAgainstDefendingSubs == ReturnFire.ALL;\n+    // attacker subs sneak attack, no sneak attack if destroyers are present\n+    if (attackingUnits.stream().anyMatch(Matches.unitIsFirstStrike())) {\n+      steps.add(attacker.getName() + FIRST_STRIKE_UNITS_FIRE);\n+      steps.add(defender.getName() + SELECT_FIRST_STRIKE_CASUALTIES);\n+      if (onlyAttackerSneakAttack) {\n+        steps.add(REMOVE_SNEAK_ATTACK_CASUALTIES);\n+      }\n+    }\n+    // ww2v2 rules, all subs fire FIRST in combat, regardless of presence of destroyers.\n+    final boolean defendingSubsFireWithAllDefenders =\n+        !defenderSubsFireFirst\n+            && !Properties.getWW2V2(gameData)\n+            && returnFireAgainstDefendingSubs == ReturnFire.ALL;\n+    // defender subs sneak attack, no sneak attack in Pacific/Europe Theaters or if destroyers are\n+    // present\n+    final boolean defendingSubsFireWithAllDefendersAlways =\n+        !SubsChecks.defendingSubsSneakAttack(gameData);\n+    if (!defendingSubsFireWithAllDefendersAlways\n+        && !defendingSubsFireWithAllDefenders\n+        && !defenderSubsFireFirst\n+        && defendingUnits.stream().anyMatch(Matches.unitIsFirstStrike())) {\n+      steps.add(defender.getName() + FIRST_STRIKE_UNITS_FIRE);\n+      steps.add(attacker.getName() + SELECT_FIRST_STRIKE_CASUALTIES);\n+    }\n+    if ((attackingUnits.stream().anyMatch(Matches.unitIsFirstStrike())\n+            || defendingUnits.stream().anyMatch(Matches.unitIsFirstStrike()))\n+        && !defenderSubsFireFirst\n+        && !onlyAttackerSneakAttack\n+        && (returnFireAgainstDefendingSubs != ReturnFire.ALL\n+            || returnFireAgainstAttackingSubs != ReturnFire.ALL)) {\n+      steps.add(REMOVE_SNEAK_ATTACK_CASUALTIES);\n+    }\n+    // Air units can't attack subs without Destroyers present\n+    if (attackingUnits.stream().anyMatch(Matches.unitIsAir())\n+        && defendingUnits.stream().anyMatch(Matches.unitCanNotBeTargetedByAll())\n+        && !canAirAttackSubs(defendingUnits, attackingUnits)) {\n+      steps.add(SUBMERGE_SUBS_VS_AIR_ONLY);\n+      steps.add(AIR_ATTACK_NON_SUBS);\n+    }\n+    if (attackingUnits.stream().anyMatch(Matches.unitIsFirstStrike().negate())) {\n+      steps.add(attacker.getName() + FIRE);\n+      steps.add(defender.getName() + SELECT_CASUALTIES);\n+    }\n+    // classic rules, subs fire with all defenders\n+    // also, ww2v3/global rules, defending subs without sneak attack fire with all defenders\n+    final Collection<Unit> defendingUnitsAliveAndDamaged = new ArrayList<>(defendingUnits);\n+    defendingUnitsAliveAndDamaged.addAll(defendingWaitingToDie);\n+    // TODO: BUG? why is unitCanNotTargetAll used instead of unitIsFirstStrike?\n+    if (defendingUnitsAliveAndDamaged.stream().anyMatch(Matches.unitCanNotTargetAll())\n+        && !defenderSubsFireFirst\n+        && (defendingSubsFireWithAllDefenders || defendingSubsFireWithAllDefendersAlways)) {\n+      steps.add(defender.getName() + FIRST_STRIKE_UNITS_FIRE);\n+      steps.add(attacker.getName() + SELECT_FIRST_STRIKE_CASUALTIES);\n+    }\n+    // Air Units can't attack subs without Destroyers present\n+    if (defendingUnits.stream().anyMatch(Matches.unitIsAir())\n+        && attackingUnits.stream().anyMatch(Matches.unitCanNotBeTargetedByAll())\n+        && !canAirAttackSubs(attackingUnits, defendingUnitsAliveAndDamaged)) {\n+      steps.add(AIR_DEFEND_NON_SUBS);\n+    }\n+    if (defendingUnits.stream().anyMatch(Matches.unitIsFirstStrike().negate())) {\n+      steps.add(defender.getName() + FIRE);\n+      steps.add(attacker.getName() + SELECT_CASUALTIES);\n+    }\n+    // remove casualties\n+    steps.add(REMOVE_CASUALTIES);\n+    // retreat attacking subs\n+    if (attackingUnits.stream().anyMatch(Matches.unitCanEvade())) {\n+      if (Properties.getSubmersibleSubs(gameData)) {\n+        // TODO: BUG? Should the presence of destroyers be checked?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56ff38338f32166fef90bdf64269795a1908dddf"}, "originalPosition": 185}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkwNDE1Mw==", "bodyText": "TODO found", "url": "https://github.com/triplea-game/triplea/pull/6549#discussion_r432904153", "createdAt": "2020-05-31T02:45:02Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/BattleSteps.java", "diffHunk": "@@ -0,0 +1,242 @@\n+package games.strategy.triplea.delegate.battle.steps;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.attachments.TechAttachment;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.battle.BattleStepStrings;\n+import games.strategy.triplea.delegate.battle.MustFightBattle.ReturnFire;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import lombok.Builder;\n+import lombok.NonNull;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Get the steps that will occurr in the battle */\n+@Builder\n+public class BattleSteps implements BattleStepStrings {\n+\n+  final @NonNull Boolean canFireOffensiveAa;\n+  final @NonNull Boolean canFireDefendingAa;\n+  final @NonNull Boolean showFirstRun;\n+  final @NonNull GamePlayer attacker;\n+  final @NonNull GamePlayer defender;\n+  final @NonNull Collection<Unit> offensiveAa;\n+  final @NonNull Collection<Unit> defendingAa;\n+  final @NonNull Collection<Unit> attackingUnits;\n+  final @NonNull Collection<Unit> defendingUnits;\n+  final @NonNull Collection<Unit> attackingWaitingToDie;\n+  final @NonNull Collection<Unit> defendingWaitingToDie;\n+  final @NonNull Territory battleSite;\n+  final @NonNull GameData gameData;\n+  final @NonNull Collection<Unit> bombardingUnits;\n+  final @NonNull Function<Collection<Unit>, Collection<Unit>> getDependentUnits;\n+  final @NonNull Boolean isBattleSiteWater;\n+  final @NonNull Boolean isAmphibious;\n+  final @NonNull Supplier<Collection<Territory>> getAttackerRetreatTerritories;\n+  final @NonNull BiFunction<GamePlayer, Collection<Unit>, Collection<Territory>>\n+      getEmptyOrFriendlySeaNeighbors;\n+\n+  public List<String> get() {\n+\n+    final List<String> steps = new ArrayList<>();\n+    if (canFireOffensiveAa) {\n+      for (final String typeAa : UnitAttachment.getAllOfTypeAas(offensiveAa)) {\n+        steps.add(attacker.getName() + \" \" + typeAa + AA_GUNS_FIRE_SUFFIX);\n+        steps.add(defender.getName() + SELECT_PREFIX + typeAa + CASUALTIES_SUFFIX);\n+        steps.add(defender.getName() + REMOVE_PREFIX + typeAa + CASUALTIES_SUFFIX);\n+      }\n+    }\n+    if (canFireDefendingAa) {\n+      for (final String typeAa : UnitAttachment.getAllOfTypeAas(defendingAa)) {\n+        steps.add(defender.getName() + \" \" + typeAa + AA_GUNS_FIRE_SUFFIX);\n+        steps.add(attacker.getName() + SELECT_PREFIX + typeAa + CASUALTIES_SUFFIX);\n+        steps.add(attacker.getName() + REMOVE_PREFIX + typeAa + CASUALTIES_SUFFIX);\n+      }\n+    }\n+    if (showFirstRun) {\n+      if (!isBattleSiteWater && !bombardingUnits.isEmpty()) {\n+        steps.add(NAVAL_BOMBARDMENT);\n+        steps.add(SELECT_NAVAL_BOMBARDMENT_CASUALTIES);\n+      }\n+      if (!isBattleSiteWater && TechAttachment.isAirTransportable(attacker)) {\n+        final Collection<Unit> bombers =\n+            CollectionUtils.getMatches(battleSite.getUnits(), Matches.unitIsAirTransport());\n+        if (!bombers.isEmpty()) {\n+          final Collection<Unit> dependents = getDependentUnits.apply(bombers);\n+          if (!dependents.isEmpty()) {\n+            steps.add(LAND_PARATROOPS);\n+          }\n+        }\n+      }\n+    }\n+    // Check if defending subs can submerge before battle\n+    if (Properties.getSubRetreatBeforeBattle(gameData)) {\n+      if (defendingUnits.stream().noneMatch(Matches.unitIsDestroyer())\n+          && attackingUnits.stream().anyMatch(Matches.unitCanEvade())) {\n+        steps.add(attacker.getName() + SUBS_SUBMERGE);\n+      }\n+      if (attackingUnits.stream().noneMatch(Matches.unitIsDestroyer())\n+          && defendingUnits.stream().anyMatch(Matches.unitCanEvade())) {\n+        steps.add(defender.getName() + SUBS_SUBMERGE);\n+      }\n+    }\n+    // See if there any unescorted transports\n+    if (isBattleSiteWater && Properties.getTransportCasualtiesRestricted(gameData)) {\n+      if (attackingUnits.stream().anyMatch(Matches.unitIsTransport())\n+          || defendingUnits.stream().anyMatch(Matches.unitIsTransport())) {\n+        steps.add(REMOVE_UNESCORTED_TRANSPORTS);\n+      }\n+    }\n+    final boolean defenderSubsFireFirst =\n+        SubsChecks.defenderSubsFireFirst(attackingUnits, defendingUnits, gameData);\n+    final ReturnFire returnFireAgainstAttackingSubs =\n+        SubsChecks.returnFireAgainstAttackingSubs(attackingUnits, defendingUnits, gameData);\n+    final ReturnFire returnFireAgainstDefendingSubs =\n+        SubsChecks.returnFireAgainstDefendingSubs(attackingUnits, defendingUnits, gameData);\n+    // if attacker has no sneak attack subs, then defender sneak attack subs fire first and remove\n+    // casualties\n+    if (defenderSubsFireFirst && defendingUnits.stream().anyMatch(Matches.unitIsFirstStrike())) {\n+      steps.add(defender.getName() + FIRST_STRIKE_UNITS_FIRE);\n+      steps.add(attacker.getName() + SELECT_FIRST_STRIKE_CASUALTIES);\n+      steps.add(REMOVE_SNEAK_ATTACK_CASUALTIES);\n+    }\n+    final boolean onlyAttackerSneakAttack =\n+        !defenderSubsFireFirst\n+            && returnFireAgainstAttackingSubs == ReturnFire.NONE\n+            && returnFireAgainstDefendingSubs == ReturnFire.ALL;\n+    // attacker subs sneak attack, no sneak attack if destroyers are present\n+    if (attackingUnits.stream().anyMatch(Matches.unitIsFirstStrike())) {\n+      steps.add(attacker.getName() + FIRST_STRIKE_UNITS_FIRE);\n+      steps.add(defender.getName() + SELECT_FIRST_STRIKE_CASUALTIES);\n+      if (onlyAttackerSneakAttack) {\n+        steps.add(REMOVE_SNEAK_ATTACK_CASUALTIES);\n+      }\n+    }\n+    // ww2v2 rules, all subs fire FIRST in combat, regardless of presence of destroyers.\n+    final boolean defendingSubsFireWithAllDefenders =\n+        !defenderSubsFireFirst\n+            && !Properties.getWW2V2(gameData)\n+            && returnFireAgainstDefendingSubs == ReturnFire.ALL;\n+    // defender subs sneak attack, no sneak attack in Pacific/Europe Theaters or if destroyers are\n+    // present\n+    final boolean defendingSubsFireWithAllDefendersAlways =\n+        !SubsChecks.defendingSubsSneakAttack(gameData);\n+    if (!defendingSubsFireWithAllDefendersAlways\n+        && !defendingSubsFireWithAllDefenders\n+        && !defenderSubsFireFirst\n+        && defendingUnits.stream().anyMatch(Matches.unitIsFirstStrike())) {\n+      steps.add(defender.getName() + FIRST_STRIKE_UNITS_FIRE);\n+      steps.add(attacker.getName() + SELECT_FIRST_STRIKE_CASUALTIES);\n+    }\n+    if ((attackingUnits.stream().anyMatch(Matches.unitIsFirstStrike())\n+            || defendingUnits.stream().anyMatch(Matches.unitIsFirstStrike()))\n+        && !defenderSubsFireFirst\n+        && !onlyAttackerSneakAttack\n+        && (returnFireAgainstDefendingSubs != ReturnFire.ALL\n+            || returnFireAgainstAttackingSubs != ReturnFire.ALL)) {\n+      steps.add(REMOVE_SNEAK_ATTACK_CASUALTIES);\n+    }\n+    // Air units can't attack subs without Destroyers present\n+    if (attackingUnits.stream().anyMatch(Matches.unitIsAir())\n+        && defendingUnits.stream().anyMatch(Matches.unitCanNotBeTargetedByAll())\n+        && !canAirAttackSubs(defendingUnits, attackingUnits)) {\n+      steps.add(SUBMERGE_SUBS_VS_AIR_ONLY);\n+      steps.add(AIR_ATTACK_NON_SUBS);\n+    }\n+    if (attackingUnits.stream().anyMatch(Matches.unitIsFirstStrike().negate())) {\n+      steps.add(attacker.getName() + FIRE);\n+      steps.add(defender.getName() + SELECT_CASUALTIES);\n+    }\n+    // classic rules, subs fire with all defenders\n+    // also, ww2v3/global rules, defending subs without sneak attack fire with all defenders\n+    final Collection<Unit> defendingUnitsAliveAndDamaged = new ArrayList<>(defendingUnits);\n+    defendingUnitsAliveAndDamaged.addAll(defendingWaitingToDie);\n+    // TODO: BUG? why is unitCanNotTargetAll used instead of unitIsFirstStrike?\n+    if (defendingUnitsAliveAndDamaged.stream().anyMatch(Matches.unitCanNotTargetAll())\n+        && !defenderSubsFireFirst\n+        && (defendingSubsFireWithAllDefenders || defendingSubsFireWithAllDefendersAlways)) {\n+      steps.add(defender.getName() + FIRST_STRIKE_UNITS_FIRE);\n+      steps.add(attacker.getName() + SELECT_FIRST_STRIKE_CASUALTIES);\n+    }\n+    // Air Units can't attack subs without Destroyers present\n+    if (defendingUnits.stream().anyMatch(Matches.unitIsAir())\n+        && attackingUnits.stream().anyMatch(Matches.unitCanNotBeTargetedByAll())\n+        && !canAirAttackSubs(attackingUnits, defendingUnitsAliveAndDamaged)) {\n+      steps.add(AIR_DEFEND_NON_SUBS);\n+    }\n+    if (defendingUnits.stream().anyMatch(Matches.unitIsFirstStrike().negate())) {\n+      steps.add(defender.getName() + FIRE);\n+      steps.add(attacker.getName() + SELECT_CASUALTIES);\n+    }\n+    // remove casualties\n+    steps.add(REMOVE_CASUALTIES);\n+    // retreat attacking subs\n+    if (attackingUnits.stream().anyMatch(Matches.unitCanEvade())) {\n+      if (Properties.getSubmersibleSubs(gameData)) {\n+        // TODO: BUG? Should the presence of destroyers be checked?\n+        if (!Properties.getSubRetreatBeforeBattle(gameData)) {\n+          steps.add(attacker.getName() + SUBS_SUBMERGE);\n+        }\n+      } else {\n+        if (RetreatChecks.canAttackerRetreatSubs(\n+            defendingUnits,\n+            defendingWaitingToDie,\n+            gameData,\n+            getAttackerRetreatTerritories,\n+            isAmphibious)) {\n+          steps.add(attacker.getName() + SUBS_WITHDRAW);\n+        }\n+      }\n+    }\n+    // if we are a sea zone, then we may not be able to retreat\n+    // (ie a sub traveled under another unit to get to the battle site)\n+    // or an enemy sub retreated to our sea zone\n+    // however, if all our sea units die, then the air units can still retreat, so if we have any\n+    // air units attacking in\n+    // a sea zone, we always have to have the retreat option shown\n+    // later, if our sea units die, we may ask the user to retreat\n+    final boolean someAirAtSea =\n+        isBattleSiteWater && attackingUnits.stream().anyMatch(Matches.unitIsAir());\n+    if (RetreatChecks.canAttackerRetreat(\n+            defendingUnits, gameData, getAttackerRetreatTerritories, isAmphibious)\n+        || someAirAtSea\n+        || RetreatChecks.canAttackerRetreatPartialAmphib(attackingUnits, gameData, isAmphibious)\n+        || RetreatChecks.canAttackerRetreatPlanes(attackingUnits, gameData, isAmphibious)) {\n+      steps.add(attacker.getName() + ATTACKER_WITHDRAW);\n+    }\n+    // retreat defending subs\n+    if (defendingUnits.stream().anyMatch(Matches.unitCanEvade())) {\n+      if (Properties.getSubmersibleSubs(gameData)) {\n+        // TODO: BUG? Should the presence of destroyers be checked?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56ff38338f32166fef90bdf64269795a1908dddf"}, "originalPosition": 219}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkwNDE1NA==", "bodyText": "BUG found", "url": "https://github.com/triplea-game/triplea/pull/6549#discussion_r432904154", "createdAt": "2020-05-31T02:45:02Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/BattleSteps.java", "diffHunk": "@@ -0,0 +1,242 @@\n+package games.strategy.triplea.delegate.battle.steps;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.attachments.TechAttachment;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.battle.BattleStepStrings;\n+import games.strategy.triplea.delegate.battle.MustFightBattle.ReturnFire;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import lombok.Builder;\n+import lombok.NonNull;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Get the steps that will occurr in the battle */\n+@Builder\n+public class BattleSteps implements BattleStepStrings {\n+\n+  final @NonNull Boolean canFireOffensiveAa;\n+  final @NonNull Boolean canFireDefendingAa;\n+  final @NonNull Boolean showFirstRun;\n+  final @NonNull GamePlayer attacker;\n+  final @NonNull GamePlayer defender;\n+  final @NonNull Collection<Unit> offensiveAa;\n+  final @NonNull Collection<Unit> defendingAa;\n+  final @NonNull Collection<Unit> attackingUnits;\n+  final @NonNull Collection<Unit> defendingUnits;\n+  final @NonNull Collection<Unit> attackingWaitingToDie;\n+  final @NonNull Collection<Unit> defendingWaitingToDie;\n+  final @NonNull Territory battleSite;\n+  final @NonNull GameData gameData;\n+  final @NonNull Collection<Unit> bombardingUnits;\n+  final @NonNull Function<Collection<Unit>, Collection<Unit>> getDependentUnits;\n+  final @NonNull Boolean isBattleSiteWater;\n+  final @NonNull Boolean isAmphibious;\n+  final @NonNull Supplier<Collection<Territory>> getAttackerRetreatTerritories;\n+  final @NonNull BiFunction<GamePlayer, Collection<Unit>, Collection<Territory>>\n+      getEmptyOrFriendlySeaNeighbors;\n+\n+  public List<String> get() {\n+\n+    final List<String> steps = new ArrayList<>();\n+    if (canFireOffensiveAa) {\n+      for (final String typeAa : UnitAttachment.getAllOfTypeAas(offensiveAa)) {\n+        steps.add(attacker.getName() + \" \" + typeAa + AA_GUNS_FIRE_SUFFIX);\n+        steps.add(defender.getName() + SELECT_PREFIX + typeAa + CASUALTIES_SUFFIX);\n+        steps.add(defender.getName() + REMOVE_PREFIX + typeAa + CASUALTIES_SUFFIX);\n+      }\n+    }\n+    if (canFireDefendingAa) {\n+      for (final String typeAa : UnitAttachment.getAllOfTypeAas(defendingAa)) {\n+        steps.add(defender.getName() + \" \" + typeAa + AA_GUNS_FIRE_SUFFIX);\n+        steps.add(attacker.getName() + SELECT_PREFIX + typeAa + CASUALTIES_SUFFIX);\n+        steps.add(attacker.getName() + REMOVE_PREFIX + typeAa + CASUALTIES_SUFFIX);\n+      }\n+    }\n+    if (showFirstRun) {\n+      if (!isBattleSiteWater && !bombardingUnits.isEmpty()) {\n+        steps.add(NAVAL_BOMBARDMENT);\n+        steps.add(SELECT_NAVAL_BOMBARDMENT_CASUALTIES);\n+      }\n+      if (!isBattleSiteWater && TechAttachment.isAirTransportable(attacker)) {\n+        final Collection<Unit> bombers =\n+            CollectionUtils.getMatches(battleSite.getUnits(), Matches.unitIsAirTransport());\n+        if (!bombers.isEmpty()) {\n+          final Collection<Unit> dependents = getDependentUnits.apply(bombers);\n+          if (!dependents.isEmpty()) {\n+            steps.add(LAND_PARATROOPS);\n+          }\n+        }\n+      }\n+    }\n+    // Check if defending subs can submerge before battle\n+    if (Properties.getSubRetreatBeforeBattle(gameData)) {\n+      if (defendingUnits.stream().noneMatch(Matches.unitIsDestroyer())\n+          && attackingUnits.stream().anyMatch(Matches.unitCanEvade())) {\n+        steps.add(attacker.getName() + SUBS_SUBMERGE);\n+      }\n+      if (attackingUnits.stream().noneMatch(Matches.unitIsDestroyer())\n+          && defendingUnits.stream().anyMatch(Matches.unitCanEvade())) {\n+        steps.add(defender.getName() + SUBS_SUBMERGE);\n+      }\n+    }\n+    // See if there any unescorted transports\n+    if (isBattleSiteWater && Properties.getTransportCasualtiesRestricted(gameData)) {\n+      if (attackingUnits.stream().anyMatch(Matches.unitIsTransport())\n+          || defendingUnits.stream().anyMatch(Matches.unitIsTransport())) {\n+        steps.add(REMOVE_UNESCORTED_TRANSPORTS);\n+      }\n+    }\n+    final boolean defenderSubsFireFirst =\n+        SubsChecks.defenderSubsFireFirst(attackingUnits, defendingUnits, gameData);\n+    final ReturnFire returnFireAgainstAttackingSubs =\n+        SubsChecks.returnFireAgainstAttackingSubs(attackingUnits, defendingUnits, gameData);\n+    final ReturnFire returnFireAgainstDefendingSubs =\n+        SubsChecks.returnFireAgainstDefendingSubs(attackingUnits, defendingUnits, gameData);\n+    // if attacker has no sneak attack subs, then defender sneak attack subs fire first and remove\n+    // casualties\n+    if (defenderSubsFireFirst && defendingUnits.stream().anyMatch(Matches.unitIsFirstStrike())) {\n+      steps.add(defender.getName() + FIRST_STRIKE_UNITS_FIRE);\n+      steps.add(attacker.getName() + SELECT_FIRST_STRIKE_CASUALTIES);\n+      steps.add(REMOVE_SNEAK_ATTACK_CASUALTIES);\n+    }\n+    final boolean onlyAttackerSneakAttack =\n+        !defenderSubsFireFirst\n+            && returnFireAgainstAttackingSubs == ReturnFire.NONE\n+            && returnFireAgainstDefendingSubs == ReturnFire.ALL;\n+    // attacker subs sneak attack, no sneak attack if destroyers are present\n+    if (attackingUnits.stream().anyMatch(Matches.unitIsFirstStrike())) {\n+      steps.add(attacker.getName() + FIRST_STRIKE_UNITS_FIRE);\n+      steps.add(defender.getName() + SELECT_FIRST_STRIKE_CASUALTIES);\n+      if (onlyAttackerSneakAttack) {\n+        steps.add(REMOVE_SNEAK_ATTACK_CASUALTIES);\n+      }\n+    }\n+    // ww2v2 rules, all subs fire FIRST in combat, regardless of presence of destroyers.\n+    final boolean defendingSubsFireWithAllDefenders =\n+        !defenderSubsFireFirst\n+            && !Properties.getWW2V2(gameData)\n+            && returnFireAgainstDefendingSubs == ReturnFire.ALL;\n+    // defender subs sneak attack, no sneak attack in Pacific/Europe Theaters or if destroyers are\n+    // present\n+    final boolean defendingSubsFireWithAllDefendersAlways =\n+        !SubsChecks.defendingSubsSneakAttack(gameData);\n+    if (!defendingSubsFireWithAllDefendersAlways\n+        && !defendingSubsFireWithAllDefenders\n+        && !defenderSubsFireFirst\n+        && defendingUnits.stream().anyMatch(Matches.unitIsFirstStrike())) {\n+      steps.add(defender.getName() + FIRST_STRIKE_UNITS_FIRE);\n+      steps.add(attacker.getName() + SELECT_FIRST_STRIKE_CASUALTIES);\n+    }\n+    if ((attackingUnits.stream().anyMatch(Matches.unitIsFirstStrike())\n+            || defendingUnits.stream().anyMatch(Matches.unitIsFirstStrike()))\n+        && !defenderSubsFireFirst\n+        && !onlyAttackerSneakAttack\n+        && (returnFireAgainstDefendingSubs != ReturnFire.ALL\n+            || returnFireAgainstAttackingSubs != ReturnFire.ALL)) {\n+      steps.add(REMOVE_SNEAK_ATTACK_CASUALTIES);\n+    }\n+    // Air units can't attack subs without Destroyers present\n+    if (attackingUnits.stream().anyMatch(Matches.unitIsAir())\n+        && defendingUnits.stream().anyMatch(Matches.unitCanNotBeTargetedByAll())\n+        && !canAirAttackSubs(defendingUnits, attackingUnits)) {\n+      steps.add(SUBMERGE_SUBS_VS_AIR_ONLY);\n+      steps.add(AIR_ATTACK_NON_SUBS);\n+    }\n+    if (attackingUnits.stream().anyMatch(Matches.unitIsFirstStrike().negate())) {\n+      steps.add(attacker.getName() + FIRE);\n+      steps.add(defender.getName() + SELECT_CASUALTIES);\n+    }\n+    // classic rules, subs fire with all defenders\n+    // also, ww2v3/global rules, defending subs without sneak attack fire with all defenders\n+    final Collection<Unit> defendingUnitsAliveAndDamaged = new ArrayList<>(defendingUnits);\n+    defendingUnitsAliveAndDamaged.addAll(defendingWaitingToDie);\n+    // TODO: BUG? why is unitCanNotTargetAll used instead of unitIsFirstStrike?\n+    if (defendingUnitsAliveAndDamaged.stream().anyMatch(Matches.unitCanNotTargetAll())\n+        && !defenderSubsFireFirst\n+        && (defendingSubsFireWithAllDefenders || defendingSubsFireWithAllDefendersAlways)) {\n+      steps.add(defender.getName() + FIRST_STRIKE_UNITS_FIRE);\n+      steps.add(attacker.getName() + SELECT_FIRST_STRIKE_CASUALTIES);\n+    }\n+    // Air Units can't attack subs without Destroyers present\n+    if (defendingUnits.stream().anyMatch(Matches.unitIsAir())\n+        && attackingUnits.stream().anyMatch(Matches.unitCanNotBeTargetedByAll())\n+        && !canAirAttackSubs(attackingUnits, defendingUnitsAliveAndDamaged)) {\n+      steps.add(AIR_DEFEND_NON_SUBS);\n+    }\n+    if (defendingUnits.stream().anyMatch(Matches.unitIsFirstStrike().negate())) {\n+      steps.add(defender.getName() + FIRE);\n+      steps.add(attacker.getName() + SELECT_CASUALTIES);\n+    }\n+    // remove casualties\n+    steps.add(REMOVE_CASUALTIES);\n+    // retreat attacking subs\n+    if (attackingUnits.stream().anyMatch(Matches.unitCanEvade())) {\n+      if (Properties.getSubmersibleSubs(gameData)) {\n+        // TODO: BUG? Should the presence of destroyers be checked?\n+        if (!Properties.getSubRetreatBeforeBattle(gameData)) {\n+          steps.add(attacker.getName() + SUBS_SUBMERGE);\n+        }\n+      } else {\n+        if (RetreatChecks.canAttackerRetreatSubs(\n+            defendingUnits,\n+            defendingWaitingToDie,\n+            gameData,\n+            getAttackerRetreatTerritories,\n+            isAmphibious)) {\n+          steps.add(attacker.getName() + SUBS_WITHDRAW);\n+        }\n+      }\n+    }\n+    // if we are a sea zone, then we may not be able to retreat\n+    // (ie a sub traveled under another unit to get to the battle site)\n+    // or an enemy sub retreated to our sea zone\n+    // however, if all our sea units die, then the air units can still retreat, so if we have any\n+    // air units attacking in\n+    // a sea zone, we always have to have the retreat option shown\n+    // later, if our sea units die, we may ask the user to retreat\n+    final boolean someAirAtSea =\n+        isBattleSiteWater && attackingUnits.stream().anyMatch(Matches.unitIsAir());\n+    if (RetreatChecks.canAttackerRetreat(\n+            defendingUnits, gameData, getAttackerRetreatTerritories, isAmphibious)\n+        || someAirAtSea\n+        || RetreatChecks.canAttackerRetreatPartialAmphib(attackingUnits, gameData, isAmphibious)\n+        || RetreatChecks.canAttackerRetreatPlanes(attackingUnits, gameData, isAmphibious)) {\n+      steps.add(attacker.getName() + ATTACKER_WITHDRAW);\n+    }\n+    // retreat defending subs\n+    if (defendingUnits.stream().anyMatch(Matches.unitCanEvade())) {\n+      if (Properties.getSubmersibleSubs(gameData)) {\n+        // TODO: BUG? Should the presence of destroyers be checked?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56ff38338f32166fef90bdf64269795a1908dddf"}, "originalPosition": 219}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxNTMyMjQ1", "url": "https://github.com/triplea-game/triplea/pull/6549#pullrequestreview-421532245", "createdAt": "2020-05-31T22:10:25Z", "commit": {"oid": "56ff38338f32166fef90bdf64269795a1908dddf"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMVQyMjoxMDoyNVrOGc7lXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMVQyMjozNTo1NVrOGc7s1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk4OTUzMg==", "bodyText": "Would you mind describing the reasoning to implement BattleStepStrings?", "url": "https://github.com/triplea-game/triplea/pull/6549#discussion_r432989532", "createdAt": "2020-05-31T22:10:25Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/BattleSteps.java", "diffHunk": "@@ -0,0 +1,242 @@\n+package games.strategy.triplea.delegate.battle.steps;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.attachments.TechAttachment;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.battle.BattleStepStrings;\n+import games.strategy.triplea.delegate.battle.MustFightBattle.ReturnFire;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import lombok.Builder;\n+import lombok.NonNull;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Get the steps that will occurr in the battle */\n+@Builder\n+public class BattleSteps implements BattleStepStrings {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56ff38338f32166fef90bdf64269795a1908dddf"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk4OTY0Ng==", "bodyText": "get() is the method for a Supplier, should this class implement  Supplier<List<String>>?\nOtherwise, seeing the usage, I would have thought that this class were a supplier.", "url": "https://github.com/triplea-game/triplea/pull/6549#discussion_r432989646", "createdAt": "2020-05-31T22:11:42Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/BattleSteps.java", "diffHunk": "@@ -0,0 +1,242 @@\n+package games.strategy.triplea.delegate.battle.steps;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.attachments.TechAttachment;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.battle.BattleStepStrings;\n+import games.strategy.triplea.delegate.battle.MustFightBattle.ReturnFire;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import lombok.Builder;\n+import lombok.NonNull;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Get the steps that will occurr in the battle */\n+@Builder\n+public class BattleSteps implements BattleStepStrings {\n+\n+  final @NonNull Boolean canFireOffensiveAa;\n+  final @NonNull Boolean canFireDefendingAa;\n+  final @NonNull Boolean showFirstRun;\n+  final @NonNull GamePlayer attacker;\n+  final @NonNull GamePlayer defender;\n+  final @NonNull Collection<Unit> offensiveAa;\n+  final @NonNull Collection<Unit> defendingAa;\n+  final @NonNull Collection<Unit> attackingUnits;\n+  final @NonNull Collection<Unit> defendingUnits;\n+  final @NonNull Collection<Unit> attackingWaitingToDie;\n+  final @NonNull Collection<Unit> defendingWaitingToDie;\n+  final @NonNull Territory battleSite;\n+  final @NonNull GameData gameData;\n+  final @NonNull Collection<Unit> bombardingUnits;\n+  final @NonNull Function<Collection<Unit>, Collection<Unit>> getDependentUnits;\n+  final @NonNull Boolean isBattleSiteWater;\n+  final @NonNull Boolean isAmphibious;\n+  final @NonNull Supplier<Collection<Territory>> getAttackerRetreatTerritories;\n+  final @NonNull BiFunction<GamePlayer, Collection<Unit>, Collection<Territory>>\n+      getEmptyOrFriendlySeaNeighbors;\n+\n+  public List<String> get() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56ff38338f32166fef90bdf64269795a1908dddf"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk5MDgwOA==", "bodyText": "Have you consider decomposing this class further?  It would likely simplify the testing substantially as well as this class itself.\nTo illustrate, the main 'get' method of this class would look something like this:\nfinal List<String> steps = new ArrayList<>();\nsteps.addAll(aaBattleStepBuilder.apply(battleStepParameters);\nsteps.addAll(firstRunBattleStepBuilder.apply(battleStepParameters);\nsteps.addAll(submergeSubsBattleStepBuilder.apply(battleStepParameters);\n:\n:\n\nImplied in the above, the class properties here would be extracted to a value object that would hold all of the parameters.\nTo enable test you would want to be able to inject implementations. That could be done by making the class have the following structure:\n@Builder\npublic class BattleSteps {\n  @Nonnull private final Function<BattleStepParameters, List<String>> aaBattleStepBuilder;\n  :\n  :\n\n  // This method call it from test code but do nothing with it, just verify you can invoke this and \n  // and have no errors, that everything can be constructed, that will be an integration test.\n  static newBattleStepBuilder() {\n     return builder()\n           .aaBattleStepBuilder(new AaBattleStepBuilder())\n           :\n           .build();\n  }\n\n} \n\nIn the above, you can use test code to call builder() and inject mock implementations. Then when testing get all you need to do is to verify that you invoked each battle step builder, have each one return a stubbed value and then be sure that all of the stubbed values are present on the returned list.\nEG:\n\n@Mock\nprivate Function<BattleStepParameters, List<String>> aaBatttleStepBuilder;\n\nprivate BattleSteps battleSteps;\n\n@Mock\nprivate BattleStepParameters battleStepParameters;\n\n@BeforeEach\nvoid setup() {\n  battleSteps = BattleSteps.builder()\n     .aaBattleStepBuilder(aaBattleStepBuilder)\n    :\n    :\n    .build();\n}\n\n@Test\nvoid get() {\nwhen(aaBattleStepBuilder.apply(battleStepParameters)).thenReturn(\"aaBattleStep\"));\n:\n:\n\nList<String> battleSteps = battleSteps.get(battleStepParameters);\n\n// using explicit static imports as an example, favor statically importing the matchers below\nassertThat(battleSteps, IsCollectionWithSize.hasSize( x ));\nassertThat(battleSteps, IsIterativeWithItems.hasItems(\n   \"aaBattleSteps\",\n   :\n   :\n   ));\n}\n\nFinally from there, you can implement each set of battle steps one-by-one and test them each individually.\nWDYT?", "url": "https://github.com/triplea-game/triplea/pull/6549#discussion_r432990808", "createdAt": "2020-05-31T22:26:25Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/BattleSteps.java", "diffHunk": "@@ -0,0 +1,242 @@\n+package games.strategy.triplea.delegate.battle.steps;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.attachments.TechAttachment;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.battle.BattleStepStrings;\n+import games.strategy.triplea.delegate.battle.MustFightBattle.ReturnFire;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import lombok.Builder;\n+import lombok.NonNull;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Get the steps that will occurr in the battle */\n+@Builder\n+public class BattleSteps implements BattleStepStrings {\n+\n+  final @NonNull Boolean canFireOffensiveAa;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56ff38338f32166fef90bdf64269795a1908dddf"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk5MTE2OA==", "bodyText": "Explicit input/output of test setup methods can help make for more explicit unit tests. This method for example could possibly be changed to:\nprivate Unit givenUnitWithAttachment(UnitAttachment unitAttachment) {\n  Unit unit = mock(Unit.class);\n  UnitType unitType = mock(UnitType.class);\n  when(unit.getType).thenReturn(unitType);\n  when(unitType.getAttachment(anyString()).thenReturn(unitAttachment);\n  return unit;\n}\n\nThen a test, for at least this, can be a bit more self-contained, eg:\n    players();\n    attackerRetreat();\n    Unit unit1 = givenUnitWithAttachment(mockUnit1Attachment);\n    unit2();\n    final List<String> steps =\n        getStepBuilder()\n            .attackingUnits(List.of(unit1))\n            .defendingUnits(List.of(unit2))\n            .isBattleSiteWater(false)\n            .build()\n            .get();\n\nIn the above, it's pretty clear the usage of 'unitAttachment' is a side-effect somewhere. Following the above pattern should eventually have unitAttachment become a parameter or a return value of some setup method, so at least you could see where it is configured (which should make the test a bit more self-explanatory and self-contained).\nWDYT of this approach?", "url": "https://github.com/triplea-game/triplea/pull/6549#discussion_r432991168", "createdAt": "2020-05-31T22:31:58Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/BattleStepsTest.java", "diffHunk": "@@ -0,0 +1,2199 @@\n+package games.strategy.triplea.delegate.battle.steps;\n+\n+import static games.strategy.triplea.Constants.ATTACKER_RETREAT_PLANES;\n+import static games.strategy.triplea.Constants.DEFENDING_SUBS_SNEAK_ATTACK;\n+import static games.strategy.triplea.Constants.PARTIAL_AMPHIBIOUS_RETREAT;\n+import static games.strategy.triplea.Constants.SUBMERSIBLE_SUBS;\n+import static games.strategy.triplea.Constants.SUB_RETREAT_BEFORE_BATTLE;\n+import static games.strategy.triplea.Constants.TRANSPORT_CASUALTIES_RESTRICTED;\n+import static games.strategy.triplea.Constants.WW2V2;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.AA_GUNS_FIRE_SUFFIX;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.AIR_ATTACK_NON_SUBS;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.AIR_DEFEND_NON_SUBS;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.ATTACKER_WITHDRAW;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.CASUALTIES_SUFFIX;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.FIRST_STRIKE_UNITS_FIRE;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.LAND_PARATROOPS;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.NAVAL_BOMBARDMENT;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.REMOVE_CASUALTIES;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.REMOVE_PREFIX;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.REMOVE_SNEAK_ATTACK_CASUALTIES;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.REMOVE_UNESCORTED_TRANSPORTS;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.SELECT_CASUALTIES;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.SELECT_FIRST_STRIKE_CASUALTIES;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.SELECT_NAVAL_BOMBARDMENT_CASUALTIES;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.SELECT_PREFIX;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.SUBMERGE_SUBS_VS_AIR_ONLY;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.SUBS_SUBMERGE;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.SUBS_WITHDRAW;\n+import static games.strategy.triplea.delegate.battle.steps.BattleSteps.FIRE;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.engine.data.properties.GameProperties;\n+import games.strategy.triplea.Constants;\n+import games.strategy.triplea.attachments.TechAttachment;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+class BattleStepsTest {\n+\n+  @Mock GameData mockGameData;\n+  @Mock GameProperties mockGameProperties;\n+  @Mock Function<Collection<Unit>, Collection<Unit>> mockGetDependentUnits;\n+  @Mock Supplier<Collection<Territory>> getAttackerRetreatTerritories;\n+\n+  @Mock\n+  BiFunction<GamePlayer, Collection<Unit>, Collection<Territory>> getEmptyOrFriendlySeaNeighbors;\n+\n+  @Mock Territory mockBattleSite;\n+  @Mock GamePlayer attacker;\n+  @Mock GamePlayer defender;\n+  @Mock TechAttachment techAttachment;\n+  @Mock Unit unit1;\n+  @Mock UnitType mockUnit1Type;\n+  @Mock UnitAttachment mockUnit1Attachment;\n+  @Mock Unit unit2;\n+  @Mock UnitType mockUnit2Type;\n+  @Mock UnitAttachment mockUnit2Attachment;\n+  @Mock Unit unit3;\n+  @Mock UnitType mockUnit3Type;\n+  @Mock UnitAttachment mockUnit3Attachment;\n+  @Mock Unit unit4;\n+  @Mock UnitType mockUnit4Type;\n+  @Mock UnitAttachment mockUnit4Attachment;\n+\n+  @BeforeEach\n+  void setupMocks() {\n+    when(mockGameData.getProperties()).thenReturn(mockGameProperties);\n+  }\n+\n+  private void players() {\n+    when(attacker.getName()).thenReturn(\"mockAttacker\");\n+    when(defender.getName()).thenReturn(\"mockDefender\");\n+  }\n+\n+  private void unit1() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56ff38338f32166fef90bdf64269795a1908dddf"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk5MTI1MQ==", "bodyText": "nit: I used to personally have a style of prefixing mocks with mock, I think that style is a bit outdated now and the preference is to omit the mock prefix on mock variable names. IE: this variable would be just battleSite.", "url": "https://github.com/triplea-game/triplea/pull/6549#discussion_r432991251", "createdAt": "2020-05-31T22:32:59Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/BattleStepsTest.java", "diffHunk": "@@ -0,0 +1,2199 @@\n+package games.strategy.triplea.delegate.battle.steps;\n+\n+import static games.strategy.triplea.Constants.ATTACKER_RETREAT_PLANES;\n+import static games.strategy.triplea.Constants.DEFENDING_SUBS_SNEAK_ATTACK;\n+import static games.strategy.triplea.Constants.PARTIAL_AMPHIBIOUS_RETREAT;\n+import static games.strategy.triplea.Constants.SUBMERSIBLE_SUBS;\n+import static games.strategy.triplea.Constants.SUB_RETREAT_BEFORE_BATTLE;\n+import static games.strategy.triplea.Constants.TRANSPORT_CASUALTIES_RESTRICTED;\n+import static games.strategy.triplea.Constants.WW2V2;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.AA_GUNS_FIRE_SUFFIX;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.AIR_ATTACK_NON_SUBS;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.AIR_DEFEND_NON_SUBS;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.ATTACKER_WITHDRAW;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.CASUALTIES_SUFFIX;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.FIRST_STRIKE_UNITS_FIRE;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.LAND_PARATROOPS;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.NAVAL_BOMBARDMENT;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.REMOVE_CASUALTIES;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.REMOVE_PREFIX;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.REMOVE_SNEAK_ATTACK_CASUALTIES;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.REMOVE_UNESCORTED_TRANSPORTS;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.SELECT_CASUALTIES;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.SELECT_FIRST_STRIKE_CASUALTIES;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.SELECT_NAVAL_BOMBARDMENT_CASUALTIES;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.SELECT_PREFIX;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.SUBMERGE_SUBS_VS_AIR_ONLY;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.SUBS_SUBMERGE;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.SUBS_WITHDRAW;\n+import static games.strategy.triplea.delegate.battle.steps.BattleSteps.FIRE;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.engine.data.properties.GameProperties;\n+import games.strategy.triplea.Constants;\n+import games.strategy.triplea.attachments.TechAttachment;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+class BattleStepsTest {\n+\n+  @Mock GameData mockGameData;\n+  @Mock GameProperties mockGameProperties;\n+  @Mock Function<Collection<Unit>, Collection<Unit>> mockGetDependentUnits;\n+  @Mock Supplier<Collection<Territory>> getAttackerRetreatTerritories;\n+\n+  @Mock\n+  BiFunction<GamePlayer, Collection<Unit>, Collection<Territory>> getEmptyOrFriendlySeaNeighbors;\n+\n+  @Mock Territory mockBattleSite;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56ff38338f32166fef90bdf64269795a1908dddf"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk5MTQ0Nw==", "bodyText": "The helper setup methods are good things \ud83d\udc4d\nExplicit input/output for them would not be bad though, as mentioned in another comment.\nAnother way to do the explicit input/output, for this method, as an example, woudl be:\nprivate static void givneUnitHasAttachment(Unit unit, UnitAttachment unitAttachment) {\n  UnitAttachment unitAttachment = mock(UnitAttachment.class);\n   when(unit.getType).thenReturn(unitAttachment);\n   when(unitAttachment.getAttachment(anyString()).thenReturn(unitAttachment);\n}\n\nThen as usage:\ngivenUnitHasAttachment(unit3, mockUnit3Attachment);\n\nIn the above you can see explicitly which variables are being configured.\nThese should complement well, how tests are done, for example:\nUnit aaUnit = givenUnitWithAttachment(unitAttachment1);\nwhen(unitAttachment.getTypeAa()).thenReturn(\"AntiAirGun\");\n\nUnit notAaUnit = givenUnitWithAttachment(unitAttachment2);\nwhen(unitAttachment.getTypeAa()).thenReturn(\"\");\n\nIn the above, later when you use aaUnit and notAaUnit it'll be a bit more explicit how they were configured and why we have expectations for one unit or another to be in an output list.\nIf you go the route of breaking up BattleStep, then it'll potentially start to make sense to have even more involved helper methods for the test, ie:\nUnit aaUnit = givenUnitWithAaType(\"AntiAirGun\");\nUnit notAaUnit = givenUnitWithAaType(\"\");\n:\n:", "url": "https://github.com/triplea-game/triplea/pull/6549#discussion_r432991447", "createdAt": "2020-05-31T22:35:55Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/BattleStepsTest.java", "diffHunk": "@@ -0,0 +1,2199 @@\n+package games.strategy.triplea.delegate.battle.steps;\n+\n+import static games.strategy.triplea.Constants.ATTACKER_RETREAT_PLANES;\n+import static games.strategy.triplea.Constants.DEFENDING_SUBS_SNEAK_ATTACK;\n+import static games.strategy.triplea.Constants.PARTIAL_AMPHIBIOUS_RETREAT;\n+import static games.strategy.triplea.Constants.SUBMERSIBLE_SUBS;\n+import static games.strategy.triplea.Constants.SUB_RETREAT_BEFORE_BATTLE;\n+import static games.strategy.triplea.Constants.TRANSPORT_CASUALTIES_RESTRICTED;\n+import static games.strategy.triplea.Constants.WW2V2;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.AA_GUNS_FIRE_SUFFIX;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.AIR_ATTACK_NON_SUBS;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.AIR_DEFEND_NON_SUBS;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.ATTACKER_WITHDRAW;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.CASUALTIES_SUFFIX;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.FIRST_STRIKE_UNITS_FIRE;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.LAND_PARATROOPS;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.NAVAL_BOMBARDMENT;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.REMOVE_CASUALTIES;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.REMOVE_PREFIX;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.REMOVE_SNEAK_ATTACK_CASUALTIES;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.REMOVE_UNESCORTED_TRANSPORTS;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.SELECT_CASUALTIES;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.SELECT_FIRST_STRIKE_CASUALTIES;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.SELECT_NAVAL_BOMBARDMENT_CASUALTIES;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.SELECT_PREFIX;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.SUBMERGE_SUBS_VS_AIR_ONLY;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.SUBS_SUBMERGE;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.SUBS_WITHDRAW;\n+import static games.strategy.triplea.delegate.battle.steps.BattleSteps.FIRE;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.engine.data.properties.GameProperties;\n+import games.strategy.triplea.Constants;\n+import games.strategy.triplea.attachments.TechAttachment;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+class BattleStepsTest {\n+\n+  @Mock GameData mockGameData;\n+  @Mock GameProperties mockGameProperties;\n+  @Mock Function<Collection<Unit>, Collection<Unit>> mockGetDependentUnits;\n+  @Mock Supplier<Collection<Territory>> getAttackerRetreatTerritories;\n+\n+  @Mock\n+  BiFunction<GamePlayer, Collection<Unit>, Collection<Territory>> getEmptyOrFriendlySeaNeighbors;\n+\n+  @Mock Territory mockBattleSite;\n+  @Mock GamePlayer attacker;\n+  @Mock GamePlayer defender;\n+  @Mock TechAttachment techAttachment;\n+  @Mock Unit unit1;\n+  @Mock UnitType mockUnit1Type;\n+  @Mock UnitAttachment mockUnit1Attachment;\n+  @Mock Unit unit2;\n+  @Mock UnitType mockUnit2Type;\n+  @Mock UnitAttachment mockUnit2Attachment;\n+  @Mock Unit unit3;\n+  @Mock UnitType mockUnit3Type;\n+  @Mock UnitAttachment mockUnit3Attachment;\n+  @Mock Unit unit4;\n+  @Mock UnitType mockUnit4Type;\n+  @Mock UnitAttachment mockUnit4Attachment;\n+\n+  @BeforeEach\n+  void setupMocks() {\n+    when(mockGameData.getProperties()).thenReturn(mockGameProperties);\n+  }\n+\n+  private void players() {\n+    when(attacker.getName()).thenReturn(\"mockAttacker\");\n+    when(defender.getName()).thenReturn(\"mockDefender\");\n+  }\n+\n+  private void unit1() {\n+    when(unit1.getType()).thenReturn(mockUnit1Type);\n+    when(mockUnit1Type.getAttachment(anyString())).thenReturn(mockUnit1Attachment);\n+  }\n+\n+  private void unit2() {\n+    when(unit2.getType()).thenReturn(mockUnit2Type);\n+    when(mockUnit2Type.getAttachment(anyString())).thenReturn(mockUnit2Attachment);\n+  }\n+\n+  private void unit3() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56ff38338f32166fef90bdf64269795a1908dddf"}, "originalPosition": 110}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4c044c6a6d6206b6047681a664f858b6f1f844ce", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/4c044c6a6d6206b6047681a664f858b6f1f844ce", "committedDate": "2020-05-31T23:19:19Z", "message": "Remove mock prefix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3d436e3d27c22cc1a77d28d8852ab3c0a438af2a", "author": {"user": {"login": "DanVanAtta", "name": "Dan Van Atta"}}, "url": "https://github.com/triplea-game/triplea/commit/3d436e3d27c22cc1a77d28d8852ab3c0a438af2a", "committedDate": "2020-06-01T02:16:08Z", "message": "Merge remote-tracking branch 'origin/master' into step-strings-unittest"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3470, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}