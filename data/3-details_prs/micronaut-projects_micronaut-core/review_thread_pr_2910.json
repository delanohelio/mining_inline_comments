{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg2NjYwMTQy", "number": 2910, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNDo0MTo1M1rODnGufw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNDo0Nzo1NVrODnG59g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMzMxMjYzOnYy", "diffSide": "RIGHT", "path": "http-server-netty/src/main/java/io/micronaut/http/server/netty/NettyHttpServer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNDo0MTo1M1rOF06CFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNzoxODowOVrOF1A6LQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTAyMTA3Ng==", "bodyText": "Don't you need to use serverConfiguration.isValidateHeaders() here?", "url": "https://github.com/micronaut-projects/micronaut-core/pull/2910#discussion_r391021076", "createdAt": "2020-03-11T14:41:53Z", "author": {"login": "croudet"}, "path": "http-server-netty/src/main/java/io/micronaut/http/server/netty/NettyHttpServer.java", "diffHunk": "@@ -657,4 +604,221 @@ public ChannelGroup getChannelGroup() {\n     public WebSocketSessionRepository getWebSocketSessionRepository() {\n         return this;\n     }\n+\n+    private HttpToHttp2ConnectionHandler newHttpToHttp2ConnectionHandler() {\n+        Http2Connection connection = new DefaultHttp2Connection(true);\n+        final InboundHttp2ToHttpAdapter http2ToHttpAdapter = new InboundHttp2ToHttpAdapterBuilder(connection)\n+                .validateHttpHeaders(true)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba95be15ecd62a6089f544db4b33c9a6bc98bd14"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTEzMzc0MQ==", "bodyText": "Good catch", "url": "https://github.com/micronaut-projects/micronaut-core/pull/2910#discussion_r391133741", "createdAt": "2020-03-11T17:18:09Z", "author": {"login": "graemerocher"}, "path": "http-server-netty/src/main/java/io/micronaut/http/server/netty/NettyHttpServer.java", "diffHunk": "@@ -657,4 +604,221 @@ public ChannelGroup getChannelGroup() {\n     public WebSocketSessionRepository getWebSocketSessionRepository() {\n         return this;\n     }\n+\n+    private HttpToHttp2ConnectionHandler newHttpToHttp2ConnectionHandler() {\n+        Http2Connection connection = new DefaultHttp2Connection(true);\n+        final InboundHttp2ToHttpAdapter http2ToHttpAdapter = new InboundHttp2ToHttpAdapterBuilder(connection)\n+                .validateHttpHeaders(true)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTAyMTA3Ng=="}, "originalCommit": {"oid": "ba95be15ecd62a6089f544db4b33c9a6bc98bd14"}, "originalPosition": 198}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMzM0MTk4OnYy", "diffSide": "RIGHT", "path": "http-server-netty/src/main/java/io/micronaut/http/server/netty/NettyHttpServer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNDo0Nzo1NVrOF06UbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNzoxOTowNFrOF1A85A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTAyNTc3Mw==", "bodyText": "HttpRequestCertificateHandler and RoutingInBoundHandler are @Sharable. Same instance can be used in all channels.", "url": "https://github.com/micronaut-projects/micronaut-core/pull/2910#discussion_r391025773", "createdAt": "2020-03-11T14:47:55Z", "author": {"login": "croudet"}, "path": "http-server-netty/src/main/java/io/micronaut/http/server/netty/NettyHttpServer.java", "diffHunk": "@@ -657,4 +604,221 @@ public ChannelGroup getChannelGroup() {\n     public WebSocketSessionRepository getWebSocketSessionRepository() {\n         return this;\n     }\n+\n+    private HttpToHttp2ConnectionHandler newHttpToHttp2ConnectionHandler() {\n+        Http2Connection connection = new DefaultHttp2Connection(true);\n+        final InboundHttp2ToHttpAdapter http2ToHttpAdapter = new InboundHttp2ToHttpAdapterBuilder(connection)\n+                .validateHttpHeaders(true)\n+                .maxContentLength((int) serverConfiguration.getMaxRequestSize())\n+                .build();\n+\n+        final HttpToHttp2ConnectionHandlerBuilder builder = new HttpToHttp2ConnectionHandlerBuilder()\n+                .frameListener(http2ToHttpAdapter);\n+\n+        serverConfiguration.getLogLevel().ifPresent(logLevel ->\n+                builder.frameLogger(new Http2FrameLogger(logLevel, NettyHttpServer.class))\n+        );\n+        return builder.connection(connection).build();\n+    }\n+\n+    /**\n+     * Negotiates with the browser if HTTP2 or HTTP is going to be used. Once decided, the Netty\n+     * pipeline is setup with the correct handlers for the selected protocol.\n+     */\n+    private final class Http2OrHttpHandler extends ApplicationProtocolNegotiationHandler {\n+\n+        private final SslContext sslContext;\n+\n+        /**\n+         * Default constructor.\n+         * @param sslContext The SSL context\n+         * @param fallbackProtocol The fallback protocol\n+         */\n+        Http2OrHttpHandler(SslContext sslContext, String fallbackProtocol) {\n+            super(fallbackProtocol);\n+            this.sslContext = sslContext;\n+        }\n+\n+        @Override\n+        public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n+            if (evt instanceof SslHandshakeCompletionEvent) {\n+                SslHandshakeCompletionEvent event = (SslHandshakeCompletionEvent) evt;\n+                if (!event.isSuccess()) {\n+                    final Throwable cause = event.cause();\n+                    if (!(cause instanceof ClosedChannelException)) {\n+                        super.userEventTriggered(ctx, evt);\n+                    } else {\n+                        return;\n+                    }\n+                }\n+            }\n+            super.userEventTriggered(ctx, evt);\n+        }\n+\n+        @Override\n+        protected void configurePipeline(ChannelHandlerContext ctx, String protocol) {\n+            final ChannelPipeline pipeline = ctx.pipeline();\n+            configurePipeline(protocol, pipeline);\n+        }\n+\n+        private void configurePipeline(String protocol, ChannelPipeline pipeline) {\n+            Map<String, ChannelHandler> handlers = getHandlerForProtocol(protocol);\n+            handlers.forEach(pipeline::addLast);\n+        }\n+\n+        @NotNull\n+        private Map<String, ChannelHandler> getHandlerForProtocol(@Nullable String protocol) {\n+            final HttpRequestDecoder requestDecoder = new HttpRequestDecoder(NettyHttpServer.this, environment, serverConfiguration);\n+            final HttpRequestCertificateHandler requestCertificateHandler = new HttpRequestCertificateHandler();\n+            final HttpResponseEncoder responseDecoder = new HttpResponseEncoder(mediaTypeCodecRegistry, serverConfiguration);\n+            final RoutingInBoundHandler routingHandler = new RoutingInBoundHandler(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba95be15ecd62a6089f544db4b33c9a6bc98bd14"}, "originalPosition": 261}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTEzNDQzNg==", "bodyText": "Will look at this thanks", "url": "https://github.com/micronaut-projects/micronaut-core/pull/2910#discussion_r391134436", "createdAt": "2020-03-11T17:19:04Z", "author": {"login": "graemerocher"}, "path": "http-server-netty/src/main/java/io/micronaut/http/server/netty/NettyHttpServer.java", "diffHunk": "@@ -657,4 +604,221 @@ public ChannelGroup getChannelGroup() {\n     public WebSocketSessionRepository getWebSocketSessionRepository() {\n         return this;\n     }\n+\n+    private HttpToHttp2ConnectionHandler newHttpToHttp2ConnectionHandler() {\n+        Http2Connection connection = new DefaultHttp2Connection(true);\n+        final InboundHttp2ToHttpAdapter http2ToHttpAdapter = new InboundHttp2ToHttpAdapterBuilder(connection)\n+                .validateHttpHeaders(true)\n+                .maxContentLength((int) serverConfiguration.getMaxRequestSize())\n+                .build();\n+\n+        final HttpToHttp2ConnectionHandlerBuilder builder = new HttpToHttp2ConnectionHandlerBuilder()\n+                .frameListener(http2ToHttpAdapter);\n+\n+        serverConfiguration.getLogLevel().ifPresent(logLevel ->\n+                builder.frameLogger(new Http2FrameLogger(logLevel, NettyHttpServer.class))\n+        );\n+        return builder.connection(connection).build();\n+    }\n+\n+    /**\n+     * Negotiates with the browser if HTTP2 or HTTP is going to be used. Once decided, the Netty\n+     * pipeline is setup with the correct handlers for the selected protocol.\n+     */\n+    private final class Http2OrHttpHandler extends ApplicationProtocolNegotiationHandler {\n+\n+        private final SslContext sslContext;\n+\n+        /**\n+         * Default constructor.\n+         * @param sslContext The SSL context\n+         * @param fallbackProtocol The fallback protocol\n+         */\n+        Http2OrHttpHandler(SslContext sslContext, String fallbackProtocol) {\n+            super(fallbackProtocol);\n+            this.sslContext = sslContext;\n+        }\n+\n+        @Override\n+        public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n+            if (evt instanceof SslHandshakeCompletionEvent) {\n+                SslHandshakeCompletionEvent event = (SslHandshakeCompletionEvent) evt;\n+                if (!event.isSuccess()) {\n+                    final Throwable cause = event.cause();\n+                    if (!(cause instanceof ClosedChannelException)) {\n+                        super.userEventTriggered(ctx, evt);\n+                    } else {\n+                        return;\n+                    }\n+                }\n+            }\n+            super.userEventTriggered(ctx, evt);\n+        }\n+\n+        @Override\n+        protected void configurePipeline(ChannelHandlerContext ctx, String protocol) {\n+            final ChannelPipeline pipeline = ctx.pipeline();\n+            configurePipeline(protocol, pipeline);\n+        }\n+\n+        private void configurePipeline(String protocol, ChannelPipeline pipeline) {\n+            Map<String, ChannelHandler> handlers = getHandlerForProtocol(protocol);\n+            handlers.forEach(pipeline::addLast);\n+        }\n+\n+        @NotNull\n+        private Map<String, ChannelHandler> getHandlerForProtocol(@Nullable String protocol) {\n+            final HttpRequestDecoder requestDecoder = new HttpRequestDecoder(NettyHttpServer.this, environment, serverConfiguration);\n+            final HttpRequestCertificateHandler requestCertificateHandler = new HttpRequestCertificateHandler();\n+            final HttpResponseEncoder responseDecoder = new HttpResponseEncoder(mediaTypeCodecRegistry, serverConfiguration);\n+            final RoutingInBoundHandler routingHandler = new RoutingInBoundHandler(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTAyNTc3Mw=="}, "originalCommit": {"oid": "ba95be15ecd62a6089f544db4b33c9a6bc98bd14"}, "originalPosition": 261}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1373, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}