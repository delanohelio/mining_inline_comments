{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ2OTU4OTEy", "number": 3699, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwNzozMzo1NFrOENLBFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwNzozMzo1NFrOENLBFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMjQ3NDQ0OnYy", "diffSide": "RIGHT", "path": "http-server-netty/src/main/java/io/micronaut/http/server/netty/RoutingInBoundHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwNzozMzo1NFrOGvtAgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxMzoyMTo1OVrOGv3H-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY3MzY2NQ==", "bodyText": "Isn't it just more efficient to use Flowable.create instead of Single.create if we are just converting it to a flowable afterwards? Only different in the code would be you would have to call onNext(..) then onComplete()", "url": "https://github.com/micronaut-projects/micronaut-core/pull/3699#discussion_r452673665", "createdAt": "2020-07-10T07:33:54Z", "author": {"login": "graemerocher"}, "path": "http-server-netty/src/main/java/io/micronaut/http/server/netty/RoutingInBoundHandler.java", "diffHunk": "@@ -1407,49 +1408,47 @@ protected void doOnError(Throwable t) {\n                                 routeMatch instanceof MethodBasedRouteMatch &&\n                                         isKotlinFunctionReturnTypeUnit(((MethodBasedRouteMatch) routeMatch).getExecutableMethod());\n                         final Supplier<CompletableFuture<?>> supplier = ContinuationArgumentBinder.extractContinuationCompletableFutureSupplier(incomingRequest);\n-                        Object suspendedBody;\n                         if (isKotlinCoroutineSuspended(body)) {\n-                            if (isKotlinFunctionReturnTypeUnit) {\n-                                suspendedBody = Completable.create(emitter -> {\n-                                    CompletableFuture<?> f = supplier.get();\n-                                    f.whenComplete((BiConsumer<Object, Throwable>) (o, throwable) -> {\n-                                        if (throwable != null) {\n-                                            emitter.onError(throwable);\n-                                        } else {\n-                                            emitter.onComplete();\n-                                        }\n-                                    });\n-                                });\n-                            } else {\n-                                suspendedBody = Single.create(emitter -> {\n-                                    CompletableFuture<?> f = supplier.get();\n-                                    f.whenComplete((BiConsumer<Object, Throwable>) (o, throwable) -> {\n-                                        if (throwable != null) {\n-                                            emitter.onError(throwable);\n+                            return Single.<MutableHttpResponse<?>>create(emitter -> {\n+                                CompletableFuture<?> f = supplier.get();\n+                                f.whenComplete((o, throwable) -> {\n+                                    if (throwable != null) {\n+                                        emitter.onError(throwable);\n+                                    } else {\n+                                        MutableHttpResponse<?> response;\n+                                        if (o instanceof MutableHttpResponse) {\n+                                            response = (MutableHttpResponse<?>) o;\n                                         } else {\n-                                            emitter.onSuccess(o);\n+                                            response = forStatus(routeMatch.getAnnotationMetadata(), defaultHttpStatus);\n+                                            if (!isKotlinFunctionReturnTypeUnit) {\n+                                                response = response.body(o);\n+                                            }\n                                         }\n-                                    });\n+                                        response.setAttribute(HttpAttributes.ROUTE_MATCH, finalRoute);\n+                                        emitter.onSuccess(response);\n+                                    }\n                                 });\n-                            }\n+                            }).toFlowable();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c93654a3811afc7bc776b57221cebce726f0f4be"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgzOTQxNw==", "bodyText": "Probably - I'll update it", "url": "https://github.com/micronaut-projects/micronaut-core/pull/3699#discussion_r452839417", "createdAt": "2020-07-10T13:21:59Z", "author": {"login": "jameskleeh"}, "path": "http-server-netty/src/main/java/io/micronaut/http/server/netty/RoutingInBoundHandler.java", "diffHunk": "@@ -1407,49 +1408,47 @@ protected void doOnError(Throwable t) {\n                                 routeMatch instanceof MethodBasedRouteMatch &&\n                                         isKotlinFunctionReturnTypeUnit(((MethodBasedRouteMatch) routeMatch).getExecutableMethod());\n                         final Supplier<CompletableFuture<?>> supplier = ContinuationArgumentBinder.extractContinuationCompletableFutureSupplier(incomingRequest);\n-                        Object suspendedBody;\n                         if (isKotlinCoroutineSuspended(body)) {\n-                            if (isKotlinFunctionReturnTypeUnit) {\n-                                suspendedBody = Completable.create(emitter -> {\n-                                    CompletableFuture<?> f = supplier.get();\n-                                    f.whenComplete((BiConsumer<Object, Throwable>) (o, throwable) -> {\n-                                        if (throwable != null) {\n-                                            emitter.onError(throwable);\n-                                        } else {\n-                                            emitter.onComplete();\n-                                        }\n-                                    });\n-                                });\n-                            } else {\n-                                suspendedBody = Single.create(emitter -> {\n-                                    CompletableFuture<?> f = supplier.get();\n-                                    f.whenComplete((BiConsumer<Object, Throwable>) (o, throwable) -> {\n-                                        if (throwable != null) {\n-                                            emitter.onError(throwable);\n+                            return Single.<MutableHttpResponse<?>>create(emitter -> {\n+                                CompletableFuture<?> f = supplier.get();\n+                                f.whenComplete((o, throwable) -> {\n+                                    if (throwable != null) {\n+                                        emitter.onError(throwable);\n+                                    } else {\n+                                        MutableHttpResponse<?> response;\n+                                        if (o instanceof MutableHttpResponse) {\n+                                            response = (MutableHttpResponse<?>) o;\n                                         } else {\n-                                            emitter.onSuccess(o);\n+                                            response = forStatus(routeMatch.getAnnotationMetadata(), defaultHttpStatus);\n+                                            if (!isKotlinFunctionReturnTypeUnit) {\n+                                                response = response.body(o);\n+                                            }\n                                         }\n-                                    });\n+                                        response.setAttribute(HttpAttributes.ROUTE_MATCH, finalRoute);\n+                                        emitter.onSuccess(response);\n+                                    }\n                                 });\n-                            }\n+                            }).toFlowable();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY3MzY2NQ=="}, "originalCommit": {"oid": "c93654a3811afc7bc776b57221cebce726f0f4be"}, "originalPosition": 62}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1304, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}