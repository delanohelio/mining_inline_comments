{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg1NjcxODM4", "number": 2067, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxMDoyMDoxM1rODnA7kA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxMTo1Mzo0NVrODqwf6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMjM2MzA0OnYy", "diffSide": "RIGHT", "path": "reactor-core/src/test/java/reactor/core/publisher/scenarios/FluxTests.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxMDoyMDoxM1rOF0w1cg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxMTo0ODo0MVrOF0zrYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDg3MDM4Ng==", "bodyText": "WDYT about splitting it into multiple tests (maybe with some parameterization)?\nIt will be a bit weird when we break one to not know which one exactly :)", "url": "https://github.com/reactor/reactor-core/pull/2067#discussion_r390870386", "createdAt": "2020-03-11T10:20:13Z", "author": {"login": "bsideup"}, "path": "reactor-core/src/test/java/reactor/core/publisher/scenarios/FluxTests.java", "diffHunk": "@@ -1591,6 +1593,48 @@ public void splitBugEventuallyHappens() throws Exception {\n \n \t}\n \n+\t@Test\n+\tpublic void fluxFromCallsAssemblyHook() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eca636e5a66bcad7211ad9c0cc8e307d13ec1d07"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDkwNjU0OQ==", "bodyText": "I could split and do the whole onEachOperator ceremony in multiple shorter tests, but note that we'll know which case breaks exactly thanks to the as description of each assert...", "url": "https://github.com/reactor/reactor-core/pull/2067#discussion_r390906549", "createdAt": "2020-03-11T11:27:53Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/test/java/reactor/core/publisher/scenarios/FluxTests.java", "diffHunk": "@@ -1591,6 +1593,48 @@ public void splitBugEventuallyHappens() throws Exception {\n \n \t}\n \n+\t@Test\n+\tpublic void fluxFromCallsAssemblyHook() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDg3MDM4Ng=="}, "originalCommit": {"oid": "eca636e5a66bcad7211ad9c0cc8e307d13ec1d07"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDkxNjk2Mw==", "bodyText": "btw resetOnEachOperator can to go @AfterTest, so that the test becomes a 2-3 liner\nas is nice, but I have bad memory about debugging sequential tests (at least without soft assertions) \ud83d\ude05", "url": "https://github.com/reactor/reactor-core/pull/2067#discussion_r390916963", "createdAt": "2020-03-11T11:48:41Z", "author": {"login": "bsideup"}, "path": "reactor-core/src/test/java/reactor/core/publisher/scenarios/FluxTests.java", "diffHunk": "@@ -1591,6 +1593,48 @@ public void splitBugEventuallyHappens() throws Exception {\n \n \t}\n \n+\t@Test\n+\tpublic void fluxFromCallsAssemblyHook() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDg3MDM4Ng=="}, "originalCommit": {"oid": "eca636e5a66bcad7211ad9c0cc8e307d13ec1d07"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MTYwMDkyOnYy", "diffSide": "RIGHT", "path": "reactor-core/src/main/java/reactor/core/publisher/Mono.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxMTo0OTo1NlrOF6spkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxMTo0OTo1NlrOF6spkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA5MzI2NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tif(source instanceof Fuseable){\n          \n          \n            \n            \t\tif(source instanceof Fuseable) {", "url": "https://github.com/reactor/reactor-core/pull/2067#discussion_r397093264", "createdAt": "2020-03-24T11:49:56Z", "author": {"login": "bsideup"}, "path": "reactor-core/src/main/java/reactor/core/publisher/Mono.java", "diffHunk": "@@ -4532,6 +4529,57 @@ public String toString() {\n \t\t\t\tonCancel));\n \t}\n \n+\t/**\n+\t * Unchecked wrap of {@link Publisher} as {@link Mono}, supporting {@link Fuseable} sources.\n+\t * When converting a {@link Mono} or {@link Mono Monos} that have been converted to a {@link Flux} and back,\n+\t * the original {@link Mono} is returned unwrapped.\n+\t * Note that this bypasses {@link Hooks#onEachOperator(String, Function) assembly hooks}.\n+\t *\n+\t * @param source the {@link Publisher} to wrap\n+\t * @param enforceMonoContract {@code} true to wrap publishers without assumption about their cardinality\n+\t * (first {@link Subscriber#onNext(Object)} will cancel the source), {@code false} to behave like {@link #fromDirect(Publisher)}.\n+\t * @param <T> input upstream type\n+\t * @return a wrapped {@link Mono}\n+\t */\n+\tstatic <T> Mono<T> wrap(Publisher<T> source, boolean enforceMonoContract) {\n+\t\t//some sources can be considered already assembled monos\n+\t\t//all conversion methods (from, fromDirect, wrap) must accommodate for this\n+\t\tif (source instanceof Mono) {\n+\t\t\treturn (Mono<T>) source;\n+\t\t}\n+\t\tif (source instanceof FluxSourceMono\n+\t\t\t\t|| source instanceof FluxSourceMonoFuseable) {\n+\t\t\tFluxFromMonoOperator<T, T> wrapper = (FluxFromMonoOperator<T,T>) source;\n+\t\t\t@SuppressWarnings(\"unchecked\")\n+\t\t\tMono<T> extracted = (Mono<T>) wrapper.source;\n+\t\t\treturn extracted;\n+\t\t}\n+\n+\t\t//equivalent to what from used to be, without assembly hooks\n+\t\tif (enforceMonoContract) {\n+\t\t\tif (source instanceof Flux && source instanceof Callable) {\n+\t\t\t\t\t@SuppressWarnings(\"unchecked\") Callable<T> m = (Callable<T>) source;\n+\t\t\t\t\treturn Flux.wrapToMono(m);\n+\t\t\t}\n+\t\t\tif (source instanceof Flux) {\n+\t\t\t\treturn new MonoNext<>((Flux<T>) source);\n+\t\t\t}\n+\t\t\treturn new MonoFromPublisher<>(source);\n+\t\t}\n+\n+\t\t//equivalent to what fromDirect used to be without onAssembly\n+\t\tif(source instanceof Flux && source instanceof Fuseable) {\n+\t\t\treturn new MonoSourceFluxFuseable<>((Flux<T>) source);\n+\t\t}\n+\t\tif (source instanceof Flux) {\n+\t\t\treturn new MonoSourceFlux<>((Flux<T>) source);\n+\t\t}\n+\t\tif(source instanceof Fuseable){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28bebd02482f36161955392ed69c0959f0503da4"}, "originalPosition": 165}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MTYxMzg0OnYy", "diffSide": "RIGHT", "path": "reactor-core/src/test/java/reactor/core/publisher/scenarios/MonoTests.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxMTo1Mzo0NVrOF6sxjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxMzoyNDoxMFrOF6v-hQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA5NTMwOA==", "bodyText": "May I ask why not parameterized? :)", "url": "https://github.com/reactor/reactor-core/pull/2067#discussion_r397095308", "createdAt": "2020-03-24T11:53:45Z", "author": {"login": "bsideup"}, "path": "reactor-core/src/test/java/reactor/core/publisher/scenarios/MonoTests.java", "diffHunk": "@@ -304,4 +314,156 @@ public void monoCacheContextHistory() {\n \t\tAssertions.assertThat(cacheHit3).as(\"cacheHit3\").isEqualTo(\"GOOD1\");\n \t\tAssertions.assertThat(contextFillCount).as(\"cacheHit3\").hasValue(4);\n \t}\n+\n+\t@Test\n+\tpublic void monoFromMonoDoesntCallAssemblyHook() {\n+\t\tfinal Mono<Integer> source = Mono.just(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28bebd02482f36161955392ed69c0959f0503da4"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzE0Nzc4MQ==", "bodyText": "didn't go through the trouble, as splitting the test was enough vs changing the test runner and dealing with the boilerplate of providing params (plus with independent tests the name can reflect the style of source, not the concrete name of the operator used)", "url": "https://github.com/reactor/reactor-core/pull/2067#discussion_r397147781", "createdAt": "2020-03-24T13:24:10Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/test/java/reactor/core/publisher/scenarios/MonoTests.java", "diffHunk": "@@ -304,4 +314,156 @@ public void monoCacheContextHistory() {\n \t\tAssertions.assertThat(cacheHit3).as(\"cacheHit3\").isEqualTo(\"GOOD1\");\n \t\tAssertions.assertThat(contextFillCount).as(\"cacheHit3\").hasValue(4);\n \t}\n+\n+\t@Test\n+\tpublic void monoFromMonoDoesntCallAssemblyHook() {\n+\t\tfinal Mono<Integer> source = Mono.just(1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA5NTMwOA=="}, "originalCommit": {"oid": "28bebd02482f36161955392ed69c0959f0503da4"}, "originalPosition": 47}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1006, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}