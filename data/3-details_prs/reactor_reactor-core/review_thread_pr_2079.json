{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkwOTkxMzc3", "number": 2079, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxMzoyNjoyMVrODpgXSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxNjoxMDoyNlrODpk4JA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0ODQ4NDU5OnYy", "diffSide": "RIGHT", "path": "reactor-core/src/main/java/reactor/util/retry/Retry.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxMzoyNjoyMVrOF4uQYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxMzoyNjoyMVrOF4uQYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTAyMjQzNQ==", "bodyText": "in an abstract class, you may want to have a final method that wraps the user-provided one, so that we keep some control. Usually it makes it easier to make changes in future", "url": "https://github.com/reactor/reactor-core/pull/2079#discussion_r395022435", "createdAt": "2020-03-19T13:26:21Z", "author": {"login": "bsideup"}, "path": "reactor-core/src/main/java/reactor/util/retry/Retry.java", "diffHunk": "@@ -41,19 +54,19 @@\n \t * the attempt is delayed as well. This method generates the companion, out of a {@link Flux} of {@link RetrySignal},\n \t * which itself can serve as the simplest form of retry companion (indefinitely and immediately retry on any error).\n \t *\n-\t * @param retrySignalCompanion the original {@link Flux} of {@link RetrySignal}, notifying of each source error that\n-\t * _might_ result in a retry attempt, with context around the error and current retry cycle.\n+\t * @param retrySignals the original {@link Flux} of {@link RetrySignal}, notifying of each source error that\n+\t * <i>might</i> result in a retry attempt, with context around the error and current retry cycle.\n \t * @return the actual companion to use, which might delay or limit retry attempts\n \t */\n-\tPublisher<?> generateCompanion(Flux<RetrySignal> retrySignalCompanion);\n+\tpublic abstract Publisher<?> generateCompanion(Flux<RetrySignal> retrySignals);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "518d204e82efa2f83dbe0d8270163a1c2b00e92b"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0ODQ4ODM1OnYy", "diffSide": "RIGHT", "path": "reactor-core/src/main/java/reactor/util/retry/Retry.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxMzoyNzoyMVrOF4uS1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxNDowMToyOVrOF4vxFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTAyMzA2MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tpublic static RetryBackoffSpec fixedDelays(long maxAttempts, Duration fixedDelay) {\n          \n          \n            \n            \tpublic static RetryBackoffSpec fixedDelay(long maxAttempts, Duration fixedDelay) {\n          \n      \n    \n    \n  \n\nAlso, it would be nice to have one without maxAttempts", "url": "https://github.com/reactor/reactor-core/pull/2079#discussion_r395023061", "createdAt": "2020-03-19T13:27:21Z", "author": {"login": "bsideup"}, "path": "reactor-core/src/main/java/reactor/util/retry/Retry.java", "diffHunk": "@@ -98,24 +111,47 @@ default RetrySignal copy() {\n \t *\n \t * @param maxAttempts the maximum number of retry attempts to allow\n \t * @param minBackoff the minimum {@link Duration} for the first backoff\n-\t * @return the builder for further configuration\n+\t * @return the exponential backoff spec for further configuration\n \t * @see RetryBackoffSpec#maxAttempts(long)\n \t * @see RetryBackoffSpec#minBackoff(Duration)\n \t */\n-\tstatic RetryBackoffSpec backoff(long maxAttempts, Duration minBackoff) {\n+\t//FIXME marble diagram\n+\tpublic static RetryBackoffSpec backoff(long maxAttempts, Duration minBackoff) {\n \t\treturn new RetryBackoffSpec(maxAttempts, t -> true, false, minBackoff, MAX_BACKOFF, 0.5d, Schedulers.parallel(),\n \t\t\t\tNO_OP_CONSUMER, NO_OP_CONSUMER, NO_OP_BIFUNCTION, NO_OP_BIFUNCTION,\n \t\t\t\tRetryBackoffSpec.BACKOFF_EXCEPTION_GENERATOR);\n \t}\n \n+\t/**\n+\t * A {@link RetryBackoffSpec} preconfigured for fixed delays (min backoff equals max backoff, no jitter), given a maximum number of retry attempts\n+\t * and the fixed {@link Duration} for the backoff.\n+\t * <p>\n+\t * Note that calling {@link RetryBackoffSpec#minBackoff(Duration)} or {@link RetryBackoffSpec#maxBackoff(Duration)} would switch\n+\t * back to an exponential backoff strategy.\n+\t *\n+\t * @param maxAttempts the maximum number of retry attempts to allow\n+\t * @param fixedDelay the {@link Duration} of the fixed delays\n+\t * @return the fixed delays spec for further configuration\n+\t * @see RetryBackoffSpec#maxAttempts(long)\n+\t * @see RetryBackoffSpec#minBackoff(Duration)\n+\t * @see RetryBackoffSpec#maxBackoff(Duration)\n+\t */\n+\t//FIXME marble diagram\n+\tpublic static RetryBackoffSpec fixedDelays(long maxAttempts, Duration fixedDelay) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "518d204e82efa2f83dbe0d8270163a1c2b00e92b"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTAzMjQ1Ng==", "bodyText": "all of these start from maxAttempts though, except immediately()... I wonder about that last one tbh, and about whether or not we should encourage infinite attempts at all (even though the specs make it possible via maxAttempts(Long.MAX_VALUE) in effect)", "url": "https://github.com/reactor/reactor-core/pull/2079#discussion_r395032456", "createdAt": "2020-03-19T13:41:25Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/util/retry/Retry.java", "diffHunk": "@@ -98,24 +111,47 @@ default RetrySignal copy() {\n \t *\n \t * @param maxAttempts the maximum number of retry attempts to allow\n \t * @param minBackoff the minimum {@link Duration} for the first backoff\n-\t * @return the builder for further configuration\n+\t * @return the exponential backoff spec for further configuration\n \t * @see RetryBackoffSpec#maxAttempts(long)\n \t * @see RetryBackoffSpec#minBackoff(Duration)\n \t */\n-\tstatic RetryBackoffSpec backoff(long maxAttempts, Duration minBackoff) {\n+\t//FIXME marble diagram\n+\tpublic static RetryBackoffSpec backoff(long maxAttempts, Duration minBackoff) {\n \t\treturn new RetryBackoffSpec(maxAttempts, t -> true, false, minBackoff, MAX_BACKOFF, 0.5d, Schedulers.parallel(),\n \t\t\t\tNO_OP_CONSUMER, NO_OP_CONSUMER, NO_OP_BIFUNCTION, NO_OP_BIFUNCTION,\n \t\t\t\tRetryBackoffSpec.BACKOFF_EXCEPTION_GENERATOR);\n \t}\n \n+\t/**\n+\t * A {@link RetryBackoffSpec} preconfigured for fixed delays (min backoff equals max backoff, no jitter), given a maximum number of retry attempts\n+\t * and the fixed {@link Duration} for the backoff.\n+\t * <p>\n+\t * Note that calling {@link RetryBackoffSpec#minBackoff(Duration)} or {@link RetryBackoffSpec#maxBackoff(Duration)} would switch\n+\t * back to an exponential backoff strategy.\n+\t *\n+\t * @param maxAttempts the maximum number of retry attempts to allow\n+\t * @param fixedDelay the {@link Duration} of the fixed delays\n+\t * @return the fixed delays spec for further configuration\n+\t * @see RetryBackoffSpec#maxAttempts(long)\n+\t * @see RetryBackoffSpec#minBackoff(Duration)\n+\t * @see RetryBackoffSpec#maxBackoff(Duration)\n+\t */\n+\t//FIXME marble diagram\n+\tpublic static RetryBackoffSpec fixedDelays(long maxAttempts, Duration fixedDelay) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTAyMzA2MQ=="}, "originalCommit": {"oid": "518d204e82efa2f83dbe0d8270163a1c2b00e92b"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA0NzE4OA==", "bodyText": "I see no issue with infinite attempts, given that spec supports cancellation, and there can and most probably will be .timeout downstream", "url": "https://github.com/reactor/reactor-core/pull/2079#discussion_r395047188", "createdAt": "2020-03-19T14:01:29Z", "author": {"login": "bsideup"}, "path": "reactor-core/src/main/java/reactor/util/retry/Retry.java", "diffHunk": "@@ -98,24 +111,47 @@ default RetrySignal copy() {\n \t *\n \t * @param maxAttempts the maximum number of retry attempts to allow\n \t * @param minBackoff the minimum {@link Duration} for the first backoff\n-\t * @return the builder for further configuration\n+\t * @return the exponential backoff spec for further configuration\n \t * @see RetryBackoffSpec#maxAttempts(long)\n \t * @see RetryBackoffSpec#minBackoff(Duration)\n \t */\n-\tstatic RetryBackoffSpec backoff(long maxAttempts, Duration minBackoff) {\n+\t//FIXME marble diagram\n+\tpublic static RetryBackoffSpec backoff(long maxAttempts, Duration minBackoff) {\n \t\treturn new RetryBackoffSpec(maxAttempts, t -> true, false, minBackoff, MAX_BACKOFF, 0.5d, Schedulers.parallel(),\n \t\t\t\tNO_OP_CONSUMER, NO_OP_CONSUMER, NO_OP_BIFUNCTION, NO_OP_BIFUNCTION,\n \t\t\t\tRetryBackoffSpec.BACKOFF_EXCEPTION_GENERATOR);\n \t}\n \n+\t/**\n+\t * A {@link RetryBackoffSpec} preconfigured for fixed delays (min backoff equals max backoff, no jitter), given a maximum number of retry attempts\n+\t * and the fixed {@link Duration} for the backoff.\n+\t * <p>\n+\t * Note that calling {@link RetryBackoffSpec#minBackoff(Duration)} or {@link RetryBackoffSpec#maxBackoff(Duration)} would switch\n+\t * back to an exponential backoff strategy.\n+\t *\n+\t * @param maxAttempts the maximum number of retry attempts to allow\n+\t * @param fixedDelay the {@link Duration} of the fixed delays\n+\t * @return the fixed delays spec for further configuration\n+\t * @see RetryBackoffSpec#maxAttempts(long)\n+\t * @see RetryBackoffSpec#minBackoff(Duration)\n+\t * @see RetryBackoffSpec#maxBackoff(Duration)\n+\t */\n+\t//FIXME marble diagram\n+\tpublic static RetryBackoffSpec fixedDelays(long maxAttempts, Duration fixedDelay) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTAyMzA2MQ=="}, "originalCommit": {"oid": "518d204e82efa2f83dbe0d8270163a1c2b00e92b"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0OTIyNDA0OnYy", "diffSide": "RIGHT", "path": "reactor-core/src/main/java/reactor/util/retry/Retry.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxNjoxMDoyNlrOF41t1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxODowNTozMlrOF46bPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE0NDY2MA==", "bodyText": "How about just from as the method name?", "url": "https://github.com/reactor/reactor-core/pull/2079#discussion_r395144660", "createdAt": "2020-03-19T16:10:26Z", "author": {"login": "rstoyanchev"}, "path": "reactor-core/src/main/java/reactor/util/retry/Retry.java", "diffHunk": "@@ -126,13 +162,40 @@ static RetrySpec max(long max) {\n \t * errors resets the counter (see {@link RetrySpec#transientErrors(boolean)}).\n \t *\n \t * @param maxInARow the maximum number of retry attempts to allow in a row, reset by successful onNext\n-\t * @return the builder for further configuration\n+\t * @return the max in a row spec for further configuration\n \t * @see RetrySpec#maxAttempts(long)\n \t * @see RetrySpec#transientErrors(boolean)\n \t */\n-\tstatic RetrySpec maxInARow(long maxInARow) {\n+\t//FIXME marble diagram, point to it in RetrySpec#transientErrors javadoc\n+\tpublic static RetrySpec maxInARow(long maxInARow) {\n \t\treturn new RetrySpec(maxInARow, t -> true, true, NO_OP_CONSUMER, NO_OP_CONSUMER, NO_OP_BIFUNCTION, NO_OP_BIFUNCTION,\n \t\t\t\tRETRY_EXCEPTION_GENERATOR);\n \t}\n \n+\t/**\n+\t * A {@link RetrySpec} preconfigured for the most simplistic retry strategy: retry immediately and indefinitely\n+\t * (similar to {@link Flux#retry()}).\n+\t *\n+\t * @return the retry indefinitely spec for further configuration\n+\t */\n+\tpublic static RetrySpec indefinitely() {\n+\t\treturn new RetrySpec(Long.MAX_VALUE, t -> true, false, NO_OP_CONSUMER, NO_OP_CONSUMER, NO_OP_BIFUNCTION, NO_OP_BIFUNCTION,\n+\t\t\t\tRetrySpec.RETRY_EXCEPTION_GENERATOR);\n+\t}\n+\n+\t/**\n+\t * A wrapper around {@link Function} to provide {@link Retry} by using lambda expressions.\n+\t *\n+\t * @param function the {@link Function} representing the desired {@link Retry} strategy as a lambda\n+\t * @return the {@link Retry} strategy adapted from the {@link Function}\n+\t */\n+\tpublic static final Retry fromFunction(Function<Flux<RetrySignal>, Publisher<?>> function) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e90adb1b409dcbdbad98cb71465f77132e61be0"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTIyMTgyMA==", "bodyText": "sounds good", "url": "https://github.com/reactor/reactor-core/pull/2079#discussion_r395221820", "createdAt": "2020-03-19T18:05:32Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/util/retry/Retry.java", "diffHunk": "@@ -126,13 +162,40 @@ static RetrySpec max(long max) {\n \t * errors resets the counter (see {@link RetrySpec#transientErrors(boolean)}).\n \t *\n \t * @param maxInARow the maximum number of retry attempts to allow in a row, reset by successful onNext\n-\t * @return the builder for further configuration\n+\t * @return the max in a row spec for further configuration\n \t * @see RetrySpec#maxAttempts(long)\n \t * @see RetrySpec#transientErrors(boolean)\n \t */\n-\tstatic RetrySpec maxInARow(long maxInARow) {\n+\t//FIXME marble diagram, point to it in RetrySpec#transientErrors javadoc\n+\tpublic static RetrySpec maxInARow(long maxInARow) {\n \t\treturn new RetrySpec(maxInARow, t -> true, true, NO_OP_CONSUMER, NO_OP_CONSUMER, NO_OP_BIFUNCTION, NO_OP_BIFUNCTION,\n \t\t\t\tRETRY_EXCEPTION_GENERATOR);\n \t}\n \n+\t/**\n+\t * A {@link RetrySpec} preconfigured for the most simplistic retry strategy: retry immediately and indefinitely\n+\t * (similar to {@link Flux#retry()}).\n+\t *\n+\t * @return the retry indefinitely spec for further configuration\n+\t */\n+\tpublic static RetrySpec indefinitely() {\n+\t\treturn new RetrySpec(Long.MAX_VALUE, t -> true, false, NO_OP_CONSUMER, NO_OP_CONSUMER, NO_OP_BIFUNCTION, NO_OP_BIFUNCTION,\n+\t\t\t\tRetrySpec.RETRY_EXCEPTION_GENERATOR);\n+\t}\n+\n+\t/**\n+\t * A wrapper around {@link Function} to provide {@link Retry} by using lambda expressions.\n+\t *\n+\t * @param function the {@link Function} representing the desired {@link Retry} strategy as a lambda\n+\t * @return the {@link Retry} strategy adapted from the {@link Function}\n+\t */\n+\tpublic static final Retry fromFunction(Function<Flux<RetrySignal>, Publisher<?>> function) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE0NDY2MA=="}, "originalCommit": {"oid": "3e90adb1b409dcbdbad98cb71465f77132e61be0"}, "originalPosition": 147}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1011, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}