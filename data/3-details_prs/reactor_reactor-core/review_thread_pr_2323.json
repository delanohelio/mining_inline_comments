{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY2ODMxMTUz", "number": 2323, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNToxNzowM1rOEYGfBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNToxNzowM1rOEYGfBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNzA3NTI1OnYy", "diffSide": "RIGHT", "path": "reactor-core/src/test/java/reactor/core/publisher/FluxFlatMapTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNToxNzowM1rOHAQVEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNzowNzowMlrOHAUlFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDAyOTU4Nw==", "bodyText": "nit: WDYT about doing \"one arg per line\" here?", "url": "https://github.com/reactor/reactor-core/pull/2323#discussion_r470029587", "createdAt": "2020-08-13T15:17:03Z", "author": {"login": "bsideup"}, "path": "reactor-core/src/test/java/reactor/core/publisher/FluxFlatMapTest.java", "diffHunk": "@@ -46,6 +59,81 @@\n \n public class FluxFlatMapTest {\n \n+\t@Rule\n+\tpublic AutoDisposingRule afterTest = new AutoDisposingRule();\n+\n+\t@Test\n+\t@Ignore(\"causes too much GC pressure and OutOfMemoryError\")\n+\tpublic void flatmapInnerShouldntRequestInFusionModeSync_gcHeavy() {\n+\t\t/*\n+\t\tSee original reproduction case in https://github.com/reactor/reactor-core/issues/2318\n+\t\tThis simplified test attempts to trigger the bad state of the inner subscription a bit more directly,\n+\t\tand allows asserting said state rather than detecting a consequence / symptom (NoSuchElementException).\n+\t\tAs such it runs (a bit) faster but may reproduce a bit less reliably.\n+\t\t*/\n+\t\tfinal Scheduler scheduler = afterTest.autoDispose(Schedulers.newParallel(\"flatmapInnerShouldntRequestInFusionModeSync\", 2));\n+\t\tfinal List<AssertQueueSubscription<Integer>> innerQueueSubscriptions = Collections.synchronizedList(new ArrayList<>());\n+\t\tfinal List<Integer> innerContent = Arrays.asList(1, 2, 3, 4, 5);\n+\n+\t\tFlux.fromStream(IntStream.range(0, 32).boxed())\n+\t\t    .flatMap(number -> {\n+\t\t\t    final ExecutorService executor = Executors.newSingleThreadExecutor();\n+\t\t\t    return Flux.<Long>create(sink -> sink.onRequest(requested -> executor.submit(() -> LongStream.range(0, requested).forEach(sink::next))))\n+\t\t\t\t\t    .flatMap(x -> {\n+\t\t\t\t\t\t    AssertQueueSubscription<Integer> assertQueueSubscription = new AssertQueueSubscription<Integer>() {\n+\t\t\t\t\t\t\t    @Override\n+\t\t\t\t\t\t\t    public int requestFusion(int requestedMode) {\n+\t\t\t\t\t\t\t\t    if (requestedMode != Fuseable.NONE) {\n+\t\t\t\t\t\t\t\t\t    return Fuseable.SYNC;\n+\t\t\t\t\t\t\t\t    }\n+\t\t\t\t\t\t\t\t    return Fuseable.NONE;\n+\t\t\t\t\t\t\t    }\n+\t\t\t\t\t\t    };\n+\t\t\t\t\t\t    assertQueueSubscription.addAll(innerContent);\n+\n+\t\t\t\t\t\t    innerQueueSubscriptions.add(assertQueueSubscription);\n+\t\t\t\t\t\t    return subscriber -> subscriber.onSubscribe(assertQueueSubscription);\n+\t\t\t\t\t    }, 8, 4)\n+\t\t\t\t\t    .publishOn(scheduler)\n+\t\t\t\t\t    .take(Duration.ofSeconds(5));\n+\t\t    })\n+\t\t    .blockLast();\n+\n+\t\t//queuesubscription cannot be represented as string by assertj so we avoid allSatisfy, instead we manually loop\n+\t\tinnerQueueSubscriptions.forEach(aqs -> assertThat(aqs.requested)\n+\t\t\t\t.withFailMessage(\"Inner publisher shouldn't be requested by FlatMapInner, got <request(%s)>\", aqs.requested)\n+\t\t\t\t.isZero());\n+\t}\n+\n+\t@Test\n+\tpublic void flatmapInnerShouldntRequestInFusionModeSync() {\n+\t\t/*\n+\t\tSee original reproduction case in https://github.com/reactor/reactor-core/issues/2318\n+\t\tThis simplified test directly triggers the fusion/request, reliably reproducing the\n+\t\troot cause behind the NoSuchElementError in an efficient way.\n+\t\t*/\n+\t\tfinal AssertQueueSubscription<Integer> inner = new AssertQueueSubscription<Integer>() {\n+\t\t\t@Override\n+\t\t\tpublic int requestFusion(int requestedMode) {\n+\t\t\t\tif ((requestedMode & Fuseable.SYNC) != 0) {\n+\t\t\t\t\treturn Fuseable.SYNC;\n+\t\t\t\t}\n+\t\t\t\treturn Fuseable.NONE;\n+\t\t\t}\n+\t\t};\n+\t\tinner.addAll(Arrays.asList(1, 2, 3, 4, 5));\n+\n+\t\tFluxFlatMap.FlatMapMain<?, Integer> parent = new FluxFlatMap.FlatMapMain<>(\n+\t\t\t\tAssertSubscriber.create(0), v -> Mono.empty(), false, 8, Queues.small(), 4, Queues.small());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d3aeef0b72d65cd9edeef8ecb1127f55acae59a"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA5OTIyMg==", "bodyText": "done. once approved I'll squash the last 3 commits to merge with rebase", "url": "https://github.com/reactor/reactor-core/pull/2323#discussion_r470099222", "createdAt": "2020-08-13T17:07:02Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/test/java/reactor/core/publisher/FluxFlatMapTest.java", "diffHunk": "@@ -46,6 +59,81 @@\n \n public class FluxFlatMapTest {\n \n+\t@Rule\n+\tpublic AutoDisposingRule afterTest = new AutoDisposingRule();\n+\n+\t@Test\n+\t@Ignore(\"causes too much GC pressure and OutOfMemoryError\")\n+\tpublic void flatmapInnerShouldntRequestInFusionModeSync_gcHeavy() {\n+\t\t/*\n+\t\tSee original reproduction case in https://github.com/reactor/reactor-core/issues/2318\n+\t\tThis simplified test attempts to trigger the bad state of the inner subscription a bit more directly,\n+\t\tand allows asserting said state rather than detecting a consequence / symptom (NoSuchElementException).\n+\t\tAs such it runs (a bit) faster but may reproduce a bit less reliably.\n+\t\t*/\n+\t\tfinal Scheduler scheduler = afterTest.autoDispose(Schedulers.newParallel(\"flatmapInnerShouldntRequestInFusionModeSync\", 2));\n+\t\tfinal List<AssertQueueSubscription<Integer>> innerQueueSubscriptions = Collections.synchronizedList(new ArrayList<>());\n+\t\tfinal List<Integer> innerContent = Arrays.asList(1, 2, 3, 4, 5);\n+\n+\t\tFlux.fromStream(IntStream.range(0, 32).boxed())\n+\t\t    .flatMap(number -> {\n+\t\t\t    final ExecutorService executor = Executors.newSingleThreadExecutor();\n+\t\t\t    return Flux.<Long>create(sink -> sink.onRequest(requested -> executor.submit(() -> LongStream.range(0, requested).forEach(sink::next))))\n+\t\t\t\t\t    .flatMap(x -> {\n+\t\t\t\t\t\t    AssertQueueSubscription<Integer> assertQueueSubscription = new AssertQueueSubscription<Integer>() {\n+\t\t\t\t\t\t\t    @Override\n+\t\t\t\t\t\t\t    public int requestFusion(int requestedMode) {\n+\t\t\t\t\t\t\t\t    if (requestedMode != Fuseable.NONE) {\n+\t\t\t\t\t\t\t\t\t    return Fuseable.SYNC;\n+\t\t\t\t\t\t\t\t    }\n+\t\t\t\t\t\t\t\t    return Fuseable.NONE;\n+\t\t\t\t\t\t\t    }\n+\t\t\t\t\t\t    };\n+\t\t\t\t\t\t    assertQueueSubscription.addAll(innerContent);\n+\n+\t\t\t\t\t\t    innerQueueSubscriptions.add(assertQueueSubscription);\n+\t\t\t\t\t\t    return subscriber -> subscriber.onSubscribe(assertQueueSubscription);\n+\t\t\t\t\t    }, 8, 4)\n+\t\t\t\t\t    .publishOn(scheduler)\n+\t\t\t\t\t    .take(Duration.ofSeconds(5));\n+\t\t    })\n+\t\t    .blockLast();\n+\n+\t\t//queuesubscription cannot be represented as string by assertj so we avoid allSatisfy, instead we manually loop\n+\t\tinnerQueueSubscriptions.forEach(aqs -> assertThat(aqs.requested)\n+\t\t\t\t.withFailMessage(\"Inner publisher shouldn't be requested by FlatMapInner, got <request(%s)>\", aqs.requested)\n+\t\t\t\t.isZero());\n+\t}\n+\n+\t@Test\n+\tpublic void flatmapInnerShouldntRequestInFusionModeSync() {\n+\t\t/*\n+\t\tSee original reproduction case in https://github.com/reactor/reactor-core/issues/2318\n+\t\tThis simplified test directly triggers the fusion/request, reliably reproducing the\n+\t\troot cause behind the NoSuchElementError in an efficient way.\n+\t\t*/\n+\t\tfinal AssertQueueSubscription<Integer> inner = new AssertQueueSubscription<Integer>() {\n+\t\t\t@Override\n+\t\t\tpublic int requestFusion(int requestedMode) {\n+\t\t\t\tif ((requestedMode & Fuseable.SYNC) != 0) {\n+\t\t\t\t\treturn Fuseable.SYNC;\n+\t\t\t\t}\n+\t\t\t\treturn Fuseable.NONE;\n+\t\t\t}\n+\t\t};\n+\t\tinner.addAll(Arrays.asList(1, 2, 3, 4, 5));\n+\n+\t\tFluxFlatMap.FlatMapMain<?, Integer> parent = new FluxFlatMap.FlatMapMain<>(\n+\t\t\t\tAssertSubscriber.create(0), v -> Mono.empty(), false, 8, Queues.small(), 4, Queues.small());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDAyOTU4Nw=="}, "originalCommit": {"oid": "6d3aeef0b72d65cd9edeef8ecb1127f55acae59a"}, "originalPosition": 107}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 920, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}