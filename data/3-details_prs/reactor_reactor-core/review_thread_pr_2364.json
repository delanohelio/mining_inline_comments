{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDgxOTgyMDEx", "number": 2364, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxMTo0MjozNVrOEhNHIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxMTo0MzoyM1rOEhNIMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzMjUzMjgxOnYy", "diffSide": "RIGHT", "path": "reactor-core/src/main/java/reactor/core/publisher/FluxBufferPredicate.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxMTo0MjozNVrOHOZBIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwOTo1MTo1M1rOHPsAHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDg1MjAwMA==", "bodyText": "why not getAndSet?", "url": "https://github.com/reactor/reactor-core/pull/2364#discussion_r484852000", "createdAt": "2020-09-08T11:42:35Z", "author": {"login": "bsideup"}, "path": "reactor-core/src/main/java/reactor/core/publisher/FluxBufferPredicate.java", "diffHunk": "@@ -176,8 +178,13 @@ public void request(long n) {\n \n \t\t@Override\n \t\tpublic void cancel() {\n+\t\t\tC b;\n+\t\t\tsynchronized (this) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42d8b5107df873d6302a74c18c4bf34135bb3a47"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjIxMTYxNQ==", "bodyText": "I should probably eliminate the volatile above. overall for this issue getAndSet and CAS operations doesn't cut it because the onNext could still capture the buffer just in time and perform the add despite cancel swapping out the buffer.", "url": "https://github.com/reactor/reactor-core/pull/2364#discussion_r486211615", "createdAt": "2020-09-10T09:51:53Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/FluxBufferPredicate.java", "diffHunk": "@@ -176,8 +178,13 @@ public void request(long n) {\n \n \t\t@Override\n \t\tpublic void cancel() {\n+\t\t\tC b;\n+\t\t\tsynchronized (this) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDg1MjAwMA=="}, "originalCommit": {"oid": "42d8b5107df873d6302a74c18c4bf34135bb3a47"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzMjUzNTU0OnYy", "diffSide": "RIGHT", "path": "reactor-core/src/test/java/reactor/core/publisher/FluxBufferPredicateTest.java", "isResolved": true, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxMTo0MzoyM1rOHOZCyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxMDozODo1N1rOHPtnkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDg1MjQyNQ==", "bodyText": "this one could really use a stress test instead", "url": "https://github.com/reactor/reactor-core/pull/2364#discussion_r484852425", "createdAt": "2020-09-08T11:43:23Z", "author": {"login": "bsideup"}, "path": "reactor-core/src/test/java/reactor/core/publisher/FluxBufferPredicateTest.java", "diffHunk": "@@ -912,6 +916,153 @@ public void discardOnError() {\n \t\t            .hasDiscardedExactly(1, 2, 3);\n \t}\n \n+\tstatic private final Context DISCARD_RACE_WITH_ON_NEXT_CTX = Context.of(Hooks.KEY_ON_DISCARD, (Consumer<?>) (Object o) -> ((AtomicInteger) o).incrementAndGet());\n+\n+\tBaseSubscriber<ArrayList<AtomicInteger>> createDiscardRaceWithOnNextDownstream(final AtomicLong receivedCounter) {\n+\t\treturn new BaseSubscriber<ArrayList<AtomicInteger>>() {\n+\t\t\t@Override\n+\t\t\tpublic Context currentContext() {\n+\t\t\t\treturn DISCARD_RACE_WITH_ON_NEXT_CTX;\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tprotected void hookOnNext(ArrayList<AtomicInteger> value) {\n+\t\t\t\treceivedCounter.addAndGet(value.size());\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\t@Test\n+\tpublic void discardRaceWithOnNext_bufferAdds() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42d8b5107df873d6302a74c18c4bf34135bb3a47"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjIxMDA5OQ==", "bodyText": "no time for this unfortunately, too much on my plate. can you open a follow up issue?", "url": "https://github.com/reactor/reactor-core/pull/2364#discussion_r486210099", "createdAt": "2020-09-10T09:49:23Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/test/java/reactor/core/publisher/FluxBufferPredicateTest.java", "diffHunk": "@@ -912,6 +916,153 @@ public void discardOnError() {\n \t\t            .hasDiscardedExactly(1, 2, 3);\n \t}\n \n+\tstatic private final Context DISCARD_RACE_WITH_ON_NEXT_CTX = Context.of(Hooks.KEY_ON_DISCARD, (Consumer<?>) (Object o) -> ((AtomicInteger) o).incrementAndGet());\n+\n+\tBaseSubscriber<ArrayList<AtomicInteger>> createDiscardRaceWithOnNextDownstream(final AtomicLong receivedCounter) {\n+\t\treturn new BaseSubscriber<ArrayList<AtomicInteger>>() {\n+\t\t\t@Override\n+\t\t\tpublic Context currentContext() {\n+\t\t\t\treturn DISCARD_RACE_WITH_ON_NEXT_CTX;\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tprotected void hookOnNext(ArrayList<AtomicInteger> value) {\n+\t\t\t\treceivedCounter.addAndGet(value.size());\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\t@Test\n+\tpublic void discardRaceWithOnNext_bufferAdds() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDg1MjQyNQ=="}, "originalCommit": {"oid": "42d8b5107df873d6302a74c18c4bf34135bb3a47"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjIxNTk4OA==", "bodyText": "mhm... okay \ud83d\ude05", "url": "https://github.com/reactor/reactor-core/pull/2364#discussion_r486215988", "createdAt": "2020-09-10T09:59:03Z", "author": {"login": "bsideup"}, "path": "reactor-core/src/test/java/reactor/core/publisher/FluxBufferPredicateTest.java", "diffHunk": "@@ -912,6 +916,153 @@ public void discardOnError() {\n \t\t            .hasDiscardedExactly(1, 2, 3);\n \t}\n \n+\tstatic private final Context DISCARD_RACE_WITH_ON_NEXT_CTX = Context.of(Hooks.KEY_ON_DISCARD, (Consumer<?>) (Object o) -> ((AtomicInteger) o).incrementAndGet());\n+\n+\tBaseSubscriber<ArrayList<AtomicInteger>> createDiscardRaceWithOnNextDownstream(final AtomicLong receivedCounter) {\n+\t\treturn new BaseSubscriber<ArrayList<AtomicInteger>>() {\n+\t\t\t@Override\n+\t\t\tpublic Context currentContext() {\n+\t\t\t\treturn DISCARD_RACE_WITH_ON_NEXT_CTX;\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tprotected void hookOnNext(ArrayList<AtomicInteger> value) {\n+\t\t\t\treceivedCounter.addAndGet(value.size());\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\t@Test\n+\tpublic void discardRaceWithOnNext_bufferAdds() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDg1MjQyNQ=="}, "originalCommit": {"oid": "42d8b5107df873d6302a74c18c4bf34135bb3a47"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjIyMTIxMw==", "bodyText": "(plus jcstress was added in master, this is targeting 3.2 so it would have to be done separately anyway)", "url": "https://github.com/reactor/reactor-core/pull/2364#discussion_r486221213", "createdAt": "2020-09-10T10:08:18Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/test/java/reactor/core/publisher/FluxBufferPredicateTest.java", "diffHunk": "@@ -912,6 +916,153 @@ public void discardOnError() {\n \t\t            .hasDiscardedExactly(1, 2, 3);\n \t}\n \n+\tstatic private final Context DISCARD_RACE_WITH_ON_NEXT_CTX = Context.of(Hooks.KEY_ON_DISCARD, (Consumer<?>) (Object o) -> ((AtomicInteger) o).incrementAndGet());\n+\n+\tBaseSubscriber<ArrayList<AtomicInteger>> createDiscardRaceWithOnNextDownstream(final AtomicLong receivedCounter) {\n+\t\treturn new BaseSubscriber<ArrayList<AtomicInteger>>() {\n+\t\t\t@Override\n+\t\t\tpublic Context currentContext() {\n+\t\t\t\treturn DISCARD_RACE_WITH_ON_NEXT_CTX;\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tprotected void hookOnNext(ArrayList<AtomicInteger> value) {\n+\t\t\t\treceivedCounter.addAndGet(value.size());\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\t@Test\n+\tpublic void discardRaceWithOnNext_bufferAdds() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDg1MjQyNQ=="}, "originalCommit": {"oid": "42d8b5107df873d6302a74c18c4bf34135bb3a47"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjIyNDk4Mw==", "bodyText": "Maybe we can remove the test from this PR and add it in master later as a follow up? These really make the test execution longer and more heavyweight...", "url": "https://github.com/reactor/reactor-core/pull/2364#discussion_r486224983", "createdAt": "2020-09-10T10:15:10Z", "author": {"login": "bsideup"}, "path": "reactor-core/src/test/java/reactor/core/publisher/FluxBufferPredicateTest.java", "diffHunk": "@@ -912,6 +916,153 @@ public void discardOnError() {\n \t\t            .hasDiscardedExactly(1, 2, 3);\n \t}\n \n+\tstatic private final Context DISCARD_RACE_WITH_ON_NEXT_CTX = Context.of(Hooks.KEY_ON_DISCARD, (Consumer<?>) (Object o) -> ((AtomicInteger) o).incrementAndGet());\n+\n+\tBaseSubscriber<ArrayList<AtomicInteger>> createDiscardRaceWithOnNextDownstream(final AtomicLong receivedCounter) {\n+\t\treturn new BaseSubscriber<ArrayList<AtomicInteger>>() {\n+\t\t\t@Override\n+\t\t\tpublic Context currentContext() {\n+\t\t\t\treturn DISCARD_RACE_WITH_ON_NEXT_CTX;\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tprotected void hookOnNext(ArrayList<AtomicInteger> value) {\n+\t\t\t\treceivedCounter.addAndGet(value.size());\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\t@Test\n+\tpublic void discardRaceWithOnNext_bufferAdds() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDg1MjQyNQ=="}, "originalCommit": {"oid": "42d8b5107df873d6302a74c18c4bf34135bb3a47"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjIzNjc0OA==", "bodyText": "I can do smaller loops, to at least keep a minimum of testing while not impacting the time too much?", "url": "https://github.com/reactor/reactor-core/pull/2364#discussion_r486236748", "createdAt": "2020-09-10T10:36:14Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/test/java/reactor/core/publisher/FluxBufferPredicateTest.java", "diffHunk": "@@ -912,6 +916,153 @@ public void discardOnError() {\n \t\t            .hasDiscardedExactly(1, 2, 3);\n \t}\n \n+\tstatic private final Context DISCARD_RACE_WITH_ON_NEXT_CTX = Context.of(Hooks.KEY_ON_DISCARD, (Consumer<?>) (Object o) -> ((AtomicInteger) o).incrementAndGet());\n+\n+\tBaseSubscriber<ArrayList<AtomicInteger>> createDiscardRaceWithOnNextDownstream(final AtomicLong receivedCounter) {\n+\t\treturn new BaseSubscriber<ArrayList<AtomicInteger>>() {\n+\t\t\t@Override\n+\t\t\tpublic Context currentContext() {\n+\t\t\t\treturn DISCARD_RACE_WITH_ON_NEXT_CTX;\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tprotected void hookOnNext(ArrayList<AtomicInteger> value) {\n+\t\t\t\treceivedCounter.addAndGet(value.size());\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\t@Test\n+\tpublic void discardRaceWithOnNext_bufferAdds() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDg1MjQyNQ=="}, "originalCommit": {"oid": "42d8b5107df873d6302a74c18c4bf34135bb3a47"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjIzODA5OA==", "bodyText": "to be honest the worst offender seems to be pre-existing requestRaceWithOnNextLoops (32s)", "url": "https://github.com/reactor/reactor-core/pull/2364#discussion_r486238098", "createdAt": "2020-09-10T10:38:57Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/test/java/reactor/core/publisher/FluxBufferPredicateTest.java", "diffHunk": "@@ -912,6 +916,153 @@ public void discardOnError() {\n \t\t            .hasDiscardedExactly(1, 2, 3);\n \t}\n \n+\tstatic private final Context DISCARD_RACE_WITH_ON_NEXT_CTX = Context.of(Hooks.KEY_ON_DISCARD, (Consumer<?>) (Object o) -> ((AtomicInteger) o).incrementAndGet());\n+\n+\tBaseSubscriber<ArrayList<AtomicInteger>> createDiscardRaceWithOnNextDownstream(final AtomicLong receivedCounter) {\n+\t\treturn new BaseSubscriber<ArrayList<AtomicInteger>>() {\n+\t\t\t@Override\n+\t\t\tpublic Context currentContext() {\n+\t\t\t\treturn DISCARD_RACE_WITH_ON_NEXT_CTX;\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tprotected void hookOnNext(ArrayList<AtomicInteger> value) {\n+\t\t\t\treceivedCounter.addAndGet(value.size());\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\t@Test\n+\tpublic void discardRaceWithOnNext_bufferAdds() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDg1MjQyNQ=="}, "originalCommit": {"oid": "42d8b5107df873d6302a74c18c4bf34135bb3a47"}, "originalPosition": 104}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 958, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}