{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMzMTQxODYy", "number": 2188, "reviewThreads": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNTozMDowMlrOEEu_2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwOToxNzo1NlrOEHDIog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMzk5NzY4OnYy", "diffSide": "RIGHT", "path": "reactor-core/src/main/java/reactor/core/publisher/DirectProcessor.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNTozMDowMlrOGiipjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNzoxMzo0N1rOGim78g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg3MjQ2Mg==", "bodyText": "Can these wait until a major to be removed?", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r438872462", "createdAt": "2020-06-11T15:30:02Z", "author": {"login": "spencergibb"}, "path": "reactor-core/src/main/java/reactor/core/publisher/DirectProcessor.java", "diffHunk": "@@ -77,7 +78,9 @@\n  * </p>\n  *\n  * @param <T> the input and output value type\n+ * @deprecated Prefer clear cut usage of either {@link Processors} or {@link Sinks}, to be removed in 3.5", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e26ada7999dd24f5a65a8a7781c5e835839b3e53"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg4OTYwNg==", "bodyText": "can you expand on your concern ? if we follow the history of Reactor (2.x > 3.0 > 3.1 > 3.2 and now 3.3), a \"major\" would be a significant event that would probably mean a complete re-architecture, to the point that the whole ecosystem around Reactor would probably need heavy re-architecturing too, or break (see Reactor 2 vs Reactor 3). The only other drives for a Reactor 4 that I could think about are a change in the Java baseline or the advent of a Reactive Streams v2. In any case, very unlikely at this point.", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r438889606", "createdAt": "2020-06-11T15:48:59Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/DirectProcessor.java", "diffHunk": "@@ -77,7 +78,9 @@\n  * </p>\n  *\n  * @param <T> the input and output value type\n+ * @deprecated Prefer clear cut usage of either {@link Processors} or {@link Sinks}, to be removed in 3.5", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg3MjQ2Mg=="}, "originalCommit": {"oid": "e26ada7999dd24f5a65a8a7781c5e835839b3e53"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg5OTA4NQ==", "bodyText": "deprecating one release and removing the next just breaks backward compatibility quickly. With boot moving to a 6-month cadence for minors, they are deprecating, then waiting an extra release to remove. So deprecate in x.1, do nothing in x.2 and remove in x.3.", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r438899085", "createdAt": "2020-06-11T16:00:39Z", "author": {"login": "spencergibb"}, "path": "reactor-core/src/main/java/reactor/core/publisher/DirectProcessor.java", "diffHunk": "@@ -77,7 +78,9 @@\n  * </p>\n  *\n  * @param <T> the input and output value type\n+ * @deprecated Prefer clear cut usage of either {@link Processors} or {@link Sinks}, to be removed in 3.5", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg3MjQ2Mg=="}, "originalCommit": {"oid": "e26ada7999dd24f5a65a8a7781c5e835839b3e53"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkyOTQyNA==", "bodyText": "I see. But unlike Boot, we haven't switched to a 6 month cadence. So deprecating these now would mean that the concrete classes would disappear from the public API in a year or so. Initially, there was an issue to directly remove them without the deprecation, but I agree this would be overkill. Note that TopicProcessor and WorkQueueProcessor are slated to be removed though (since deprecated in 3.3.0)", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r438929424", "createdAt": "2020-06-11T16:50:21Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/DirectProcessor.java", "diffHunk": "@@ -77,7 +78,9 @@\n  * </p>\n  *\n  * @param <T> the input and output value type\n+ * @deprecated Prefer clear cut usage of either {@link Processors} or {@link Sinks}, to be removed in 3.5", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg3MjQ2Mg=="}, "originalCommit": {"oid": "e26ada7999dd24f5a65a8a7781c5e835839b3e53"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk0MjcwNg==", "bodyText": "\ud83d\udc4d got it. thanks for taking the time to explain.", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r438942706", "createdAt": "2020-06-11T17:13:47Z", "author": {"login": "spencergibb"}, "path": "reactor-core/src/main/java/reactor/core/publisher/DirectProcessor.java", "diffHunk": "@@ -77,7 +78,9 @@\n  * </p>\n  *\n  * @param <T> the input and output value type\n+ * @deprecated Prefer clear cut usage of either {@link Processors} or {@link Sinks}, to be removed in 3.5", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg3MjQ2Mg=="}, "originalCommit": {"oid": "e26ada7999dd24f5a65a8a7781c5e835839b3e53"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1Njg3Mzc4OnYy", "diffSide": "RIGHT", "path": "reactor-core/src/main/java/reactor/core/publisher/Sinks.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMToxNzo0MFrOGmAiVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQxNDoyMzo1NVrOGmWpyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUwNzg2MQ==", "bodyText": "Since asFlux() exposes Flux<T> but not concrete Processor onEachOperator hook could be applied here.\nSince FluxProcessors are ASYNC Publishers it could help with Thread context propagations", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442507861", "createdAt": "2020-06-18T21:17:40Z", "author": {"login": "robotmrv"}, "path": "reactor-core/src/main/java/reactor/core/publisher/Sinks.java", "diffHunk": "@@ -0,0 +1,262 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import org.reactivestreams.Subscriber;\n+\n+import reactor.util.annotation.Nullable;\n+import reactor.util.concurrent.Queues;\n+import reactor.util.context.Context;\n+\n+/**\n+ * A collection of standalone sinks ({@link StandaloneFluxSink} and\n+ * {@link StandaloneMonoSink}).\n+ *\n+ * @author Simon Basl\u00e9\n+ */\n+public final class Sinks {\n+\n+\tprivate Sinks() { }\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand by conforming to the lowest demand in case\n+\t *     of multiple subscribers.</li>\n+\t *     <li>Replaying: No replay. Only forwards to a {@link Subscriber} the elements that have been\n+\t *     pushed to the sink AFTER this subscriber was subscribed. To the exception of the first\n+\t *     subscriber (see below).</li>\n+\t *     <li>Without {@link Subscriber}: warm up. Remembers up to {@link Queues#SMALL_BUFFER_SIZE}\n+\t *     elements pushed before the first {@link Subscriber} is registered.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> multicast() {\n+\t\treturn new FluxProcessorSink<>(EmitterProcessor.create(Queues.SMALL_BUFFER_SIZE));\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n+\t *     <li>Replaying: No replay. Only forwards to a {@link Subscriber} the elements that have been\n+\t *     pushed to the sink AFTER this subscriber was subscribed.</li>\n+\t *     <li>Without {@link Subscriber}: Discarding. Pushing elements while there are no {@link Subscriber}\n+\t *     registered will simply discard these elements instead of \"warming up\" the sink.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> multicastNoWarmup() {\n+\t\treturn new FluxProcessorSink<>(ReplayProcessor.create(0));\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n+\t *     <li>Replaying: by {@code historySize}. Keeps the last {@code historySize} elements and\n+\t *     replays them instantly to new subscribers before continuing with \"live\" elements.</li>\n+\t *     <li>Without {@link Subscriber}: buffers enough elements pushed without a subscriber to\n+\t *     honor the {@code historySize}.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> replay(int historySize) {\n+\t\treturn new FluxProcessorSink<>(ReplayProcessor.create(historySize));\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n+\t *     <li>Replaying: all elements pushed to this sink are replayed to new subscribers.</li>\n+\t *     <li>Without {@link Subscriber}: all elements pushed to this sink are remembered,\n+\t *     even when there is no subscriber.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> replayAll() {\n+\t\treturn new FluxProcessorSink<>(ReplayProcessor.create());\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li><strong>Unicast</strong>: contrary to most other {@link StandaloneFluxSink}, the\n+\t *     {@link Flux} view rejects {@link Subscriber subscribers} past the first one.</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of its single {@link Subscriber}.</li>\n+\t *     <li>Replaying: non-applicable, since only one {@link Subscriber} can register.</li>\n+\t *     <li>Without {@link Subscriber}: all elements pushed to this sink are remembered and will\n+\t *     be replayed once the {@link Subscriber} subscribes.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> unicast() {\n+\t\treturn new FluxProcessorSink<>(UnicastProcessor.create());\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneMonoSink} that can be triggered at any time by either of\n+\t * the three completions: {@link ScalarSink#success(Object) valued completion},\n+\t * {@link ScalarSink#success() empty completions} or {@link ScalarSink#error(Throwable) error}.\n+\t * This completion is replayed to late subscribers.\n+\t */\n+\tpublic static <T> StandaloneMonoSink<T> trigger() {\n+\t\treturn new MonoProcessorSink<>(MonoProcessor.create());\n+\t}\n+\n+\t// == interfaces ==\n+\n+\t/**\n+\t * A flavor of {@link SequenceSink} that is not attached to a single {@link Subscriber}\n+\t * but rather viewable {@link #asFlux() as a Flux}. Most likely, such a {@link SequenceSink}\n+\t * is capable of multicasting to several subscribers. However implementations can chose\n+\t * to be unicast instead, and only accept one {@link Subscriber} at a time (as allowed\n+\t * by the {@link org.reactivestreams.Publisher} specification).\n+\t *\n+\t * @param <T> the type of elements that can be emitted through this sink\n+\t */\n+\tpublic interface StandaloneFluxSink<T> extends SequenceSink<T> {\n+\n+\t\t@Override\n+\t\tStandaloneFluxSink<T> next(T t);\n+\n+\t\t/**\n+\t\t * Return the companion {@link Flux} instance that is backed by this sink.\n+\t\t * All calls to this method return the same instance.\n+\t\t *\n+\t\t * @return the {@link Flux} view associated to this {@link StandaloneFluxSink}\n+\t\t */\n+\t\tFlux<T> asFlux();\n+\n+\t}\n+\n+\t/**\n+\t * A flavor of {@link ScalarSink} that is not attached to a single {@link Subscriber}\n+\t * but rather viewable {@link #asMono() as a Mono}. Most likely, such a {@link ScalarSink}\n+\t * is capable of multicasting to several subscribers. However implementations can chose\n+\t * to be unicast instead, and only accept one {@link Subscriber} at a time (as allowed\n+\t * by the {@link org.reactivestreams.Publisher} specification).\n+\t *\n+\t * @param <T> the type of elements that can be emitted through this sink\n+\t */\n+\tpublic interface StandaloneMonoSink<T> extends ScalarSink<T> {\n+\n+\t\t/**\n+\t\t * Return the companion {@link Mono} instance that is backed by this sink.\n+\t\t * All calls to this method return the same instance.\n+\t\t *\n+\t\t * @return the {@link Mono} view associated to this {@link StandaloneMonoSink}\n+\t\t */\n+\t\tMono<T> asMono();\n+\t}\n+\n+\t// == concrete classes ==\n+\n+\tstatic final class FluxProcessorSink<T>\n+\t\t\timplements StandaloneFluxSink<T> {\n+\n+\t\tfinal FluxSink<T>         delegateSink;\n+\t\tfinal FluxProcessor<T, T> processor;\n+\n+\t\t@SuppressWarnings(\"deprecation\")\n+\t\tFluxProcessorSink(FluxProcessor<T, T> processor) {\n+\t\t\tthis.processor = processor;\n+\t\t\tthis.delegateSink = processor.sink();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Flux<T> asFlux() {\n+\t\t\treturn processor;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "299a170088e47afaa060b550a7d9a4772169af30"}, "originalPosition": 188}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY5ODk5Mw==", "bodyText": "the processor in question is only fed via manual interactions, so I'm not sure how that would help eg. if the user decides to do a new Thread(() -> sink.next(1)).start()...", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442698993", "createdAt": "2020-06-19T08:12:26Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/Sinks.java", "diffHunk": "@@ -0,0 +1,262 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import org.reactivestreams.Subscriber;\n+\n+import reactor.util.annotation.Nullable;\n+import reactor.util.concurrent.Queues;\n+import reactor.util.context.Context;\n+\n+/**\n+ * A collection of standalone sinks ({@link StandaloneFluxSink} and\n+ * {@link StandaloneMonoSink}).\n+ *\n+ * @author Simon Basl\u00e9\n+ */\n+public final class Sinks {\n+\n+\tprivate Sinks() { }\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand by conforming to the lowest demand in case\n+\t *     of multiple subscribers.</li>\n+\t *     <li>Replaying: No replay. Only forwards to a {@link Subscriber} the elements that have been\n+\t *     pushed to the sink AFTER this subscriber was subscribed. To the exception of the first\n+\t *     subscriber (see below).</li>\n+\t *     <li>Without {@link Subscriber}: warm up. Remembers up to {@link Queues#SMALL_BUFFER_SIZE}\n+\t *     elements pushed before the first {@link Subscriber} is registered.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> multicast() {\n+\t\treturn new FluxProcessorSink<>(EmitterProcessor.create(Queues.SMALL_BUFFER_SIZE));\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n+\t *     <li>Replaying: No replay. Only forwards to a {@link Subscriber} the elements that have been\n+\t *     pushed to the sink AFTER this subscriber was subscribed.</li>\n+\t *     <li>Without {@link Subscriber}: Discarding. Pushing elements while there are no {@link Subscriber}\n+\t *     registered will simply discard these elements instead of \"warming up\" the sink.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> multicastNoWarmup() {\n+\t\treturn new FluxProcessorSink<>(ReplayProcessor.create(0));\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n+\t *     <li>Replaying: by {@code historySize}. Keeps the last {@code historySize} elements and\n+\t *     replays them instantly to new subscribers before continuing with \"live\" elements.</li>\n+\t *     <li>Without {@link Subscriber}: buffers enough elements pushed without a subscriber to\n+\t *     honor the {@code historySize}.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> replay(int historySize) {\n+\t\treturn new FluxProcessorSink<>(ReplayProcessor.create(historySize));\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n+\t *     <li>Replaying: all elements pushed to this sink are replayed to new subscribers.</li>\n+\t *     <li>Without {@link Subscriber}: all elements pushed to this sink are remembered,\n+\t *     even when there is no subscriber.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> replayAll() {\n+\t\treturn new FluxProcessorSink<>(ReplayProcessor.create());\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li><strong>Unicast</strong>: contrary to most other {@link StandaloneFluxSink}, the\n+\t *     {@link Flux} view rejects {@link Subscriber subscribers} past the first one.</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of its single {@link Subscriber}.</li>\n+\t *     <li>Replaying: non-applicable, since only one {@link Subscriber} can register.</li>\n+\t *     <li>Without {@link Subscriber}: all elements pushed to this sink are remembered and will\n+\t *     be replayed once the {@link Subscriber} subscribes.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> unicast() {\n+\t\treturn new FluxProcessorSink<>(UnicastProcessor.create());\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneMonoSink} that can be triggered at any time by either of\n+\t * the three completions: {@link ScalarSink#success(Object) valued completion},\n+\t * {@link ScalarSink#success() empty completions} or {@link ScalarSink#error(Throwable) error}.\n+\t * This completion is replayed to late subscribers.\n+\t */\n+\tpublic static <T> StandaloneMonoSink<T> trigger() {\n+\t\treturn new MonoProcessorSink<>(MonoProcessor.create());\n+\t}\n+\n+\t// == interfaces ==\n+\n+\t/**\n+\t * A flavor of {@link SequenceSink} that is not attached to a single {@link Subscriber}\n+\t * but rather viewable {@link #asFlux() as a Flux}. Most likely, such a {@link SequenceSink}\n+\t * is capable of multicasting to several subscribers. However implementations can chose\n+\t * to be unicast instead, and only accept one {@link Subscriber} at a time (as allowed\n+\t * by the {@link org.reactivestreams.Publisher} specification).\n+\t *\n+\t * @param <T> the type of elements that can be emitted through this sink\n+\t */\n+\tpublic interface StandaloneFluxSink<T> extends SequenceSink<T> {\n+\n+\t\t@Override\n+\t\tStandaloneFluxSink<T> next(T t);\n+\n+\t\t/**\n+\t\t * Return the companion {@link Flux} instance that is backed by this sink.\n+\t\t * All calls to this method return the same instance.\n+\t\t *\n+\t\t * @return the {@link Flux} view associated to this {@link StandaloneFluxSink}\n+\t\t */\n+\t\tFlux<T> asFlux();\n+\n+\t}\n+\n+\t/**\n+\t * A flavor of {@link ScalarSink} that is not attached to a single {@link Subscriber}\n+\t * but rather viewable {@link #asMono() as a Mono}. Most likely, such a {@link ScalarSink}\n+\t * is capable of multicasting to several subscribers. However implementations can chose\n+\t * to be unicast instead, and only accept one {@link Subscriber} at a time (as allowed\n+\t * by the {@link org.reactivestreams.Publisher} specification).\n+\t *\n+\t * @param <T> the type of elements that can be emitted through this sink\n+\t */\n+\tpublic interface StandaloneMonoSink<T> extends ScalarSink<T> {\n+\n+\t\t/**\n+\t\t * Return the companion {@link Mono} instance that is backed by this sink.\n+\t\t * All calls to this method return the same instance.\n+\t\t *\n+\t\t * @return the {@link Mono} view associated to this {@link StandaloneMonoSink}\n+\t\t */\n+\t\tMono<T> asMono();\n+\t}\n+\n+\t// == concrete classes ==\n+\n+\tstatic final class FluxProcessorSink<T>\n+\t\t\timplements StandaloneFluxSink<T> {\n+\n+\t\tfinal FluxSink<T>         delegateSink;\n+\t\tfinal FluxProcessor<T, T> processor;\n+\n+\t\t@SuppressWarnings(\"deprecation\")\n+\t\tFluxProcessorSink(FluxProcessor<T, T> processor) {\n+\t\t\tthis.processor = processor;\n+\t\t\tthis.delegateSink = processor.sink();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Flux<T> asFlux() {\n+\t\t\treturn processor;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUwNzg2MQ=="}, "originalCommit": {"oid": "299a170088e47afaa060b550a7d9a4772169af30"}, "originalPosition": 188}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcxNTMwMA==", "bodyText": "it would help downstream consumers as processor could be decorated and values would be emitted within context for them.\nhere the example of the problem\n//add hook that propagates value from Reactor `Context` to the `ThreadLocal`\n....\nString testValue = \"testValue\";\nsetTL(testValue);\nMonoProcessor<Integer> processor = MonoProcessor.create();\nMono.delay(Duration.ofMillis(500))\n        .doOnNext(it -> processor.onNext(1))\n        .subscribe();\n\nString value = processor\n//        .doOnNext(it -> {}) // works only with dummy operator as it decorates downstream\n        .map(it -> getValueFromTL())// value was not propagated because hook was not applied to the source\n        .block();\nAssertions.assertThat(value).isEqualTo(testValue);", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442715300", "createdAt": "2020-06-19T08:49:44Z", "author": {"login": "robotmrv"}, "path": "reactor-core/src/main/java/reactor/core/publisher/Sinks.java", "diffHunk": "@@ -0,0 +1,262 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import org.reactivestreams.Subscriber;\n+\n+import reactor.util.annotation.Nullable;\n+import reactor.util.concurrent.Queues;\n+import reactor.util.context.Context;\n+\n+/**\n+ * A collection of standalone sinks ({@link StandaloneFluxSink} and\n+ * {@link StandaloneMonoSink}).\n+ *\n+ * @author Simon Basl\u00e9\n+ */\n+public final class Sinks {\n+\n+\tprivate Sinks() { }\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand by conforming to the lowest demand in case\n+\t *     of multiple subscribers.</li>\n+\t *     <li>Replaying: No replay. Only forwards to a {@link Subscriber} the elements that have been\n+\t *     pushed to the sink AFTER this subscriber was subscribed. To the exception of the first\n+\t *     subscriber (see below).</li>\n+\t *     <li>Without {@link Subscriber}: warm up. Remembers up to {@link Queues#SMALL_BUFFER_SIZE}\n+\t *     elements pushed before the first {@link Subscriber} is registered.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> multicast() {\n+\t\treturn new FluxProcessorSink<>(EmitterProcessor.create(Queues.SMALL_BUFFER_SIZE));\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n+\t *     <li>Replaying: No replay. Only forwards to a {@link Subscriber} the elements that have been\n+\t *     pushed to the sink AFTER this subscriber was subscribed.</li>\n+\t *     <li>Without {@link Subscriber}: Discarding. Pushing elements while there are no {@link Subscriber}\n+\t *     registered will simply discard these elements instead of \"warming up\" the sink.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> multicastNoWarmup() {\n+\t\treturn new FluxProcessorSink<>(ReplayProcessor.create(0));\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n+\t *     <li>Replaying: by {@code historySize}. Keeps the last {@code historySize} elements and\n+\t *     replays them instantly to new subscribers before continuing with \"live\" elements.</li>\n+\t *     <li>Without {@link Subscriber}: buffers enough elements pushed without a subscriber to\n+\t *     honor the {@code historySize}.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> replay(int historySize) {\n+\t\treturn new FluxProcessorSink<>(ReplayProcessor.create(historySize));\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n+\t *     <li>Replaying: all elements pushed to this sink are replayed to new subscribers.</li>\n+\t *     <li>Without {@link Subscriber}: all elements pushed to this sink are remembered,\n+\t *     even when there is no subscriber.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> replayAll() {\n+\t\treturn new FluxProcessorSink<>(ReplayProcessor.create());\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li><strong>Unicast</strong>: contrary to most other {@link StandaloneFluxSink}, the\n+\t *     {@link Flux} view rejects {@link Subscriber subscribers} past the first one.</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of its single {@link Subscriber}.</li>\n+\t *     <li>Replaying: non-applicable, since only one {@link Subscriber} can register.</li>\n+\t *     <li>Without {@link Subscriber}: all elements pushed to this sink are remembered and will\n+\t *     be replayed once the {@link Subscriber} subscribes.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> unicast() {\n+\t\treturn new FluxProcessorSink<>(UnicastProcessor.create());\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneMonoSink} that can be triggered at any time by either of\n+\t * the three completions: {@link ScalarSink#success(Object) valued completion},\n+\t * {@link ScalarSink#success() empty completions} or {@link ScalarSink#error(Throwable) error}.\n+\t * This completion is replayed to late subscribers.\n+\t */\n+\tpublic static <T> StandaloneMonoSink<T> trigger() {\n+\t\treturn new MonoProcessorSink<>(MonoProcessor.create());\n+\t}\n+\n+\t// == interfaces ==\n+\n+\t/**\n+\t * A flavor of {@link SequenceSink} that is not attached to a single {@link Subscriber}\n+\t * but rather viewable {@link #asFlux() as a Flux}. Most likely, such a {@link SequenceSink}\n+\t * is capable of multicasting to several subscribers. However implementations can chose\n+\t * to be unicast instead, and only accept one {@link Subscriber} at a time (as allowed\n+\t * by the {@link org.reactivestreams.Publisher} specification).\n+\t *\n+\t * @param <T> the type of elements that can be emitted through this sink\n+\t */\n+\tpublic interface StandaloneFluxSink<T> extends SequenceSink<T> {\n+\n+\t\t@Override\n+\t\tStandaloneFluxSink<T> next(T t);\n+\n+\t\t/**\n+\t\t * Return the companion {@link Flux} instance that is backed by this sink.\n+\t\t * All calls to this method return the same instance.\n+\t\t *\n+\t\t * @return the {@link Flux} view associated to this {@link StandaloneFluxSink}\n+\t\t */\n+\t\tFlux<T> asFlux();\n+\n+\t}\n+\n+\t/**\n+\t * A flavor of {@link ScalarSink} that is not attached to a single {@link Subscriber}\n+\t * but rather viewable {@link #asMono() as a Mono}. Most likely, such a {@link ScalarSink}\n+\t * is capable of multicasting to several subscribers. However implementations can chose\n+\t * to be unicast instead, and only accept one {@link Subscriber} at a time (as allowed\n+\t * by the {@link org.reactivestreams.Publisher} specification).\n+\t *\n+\t * @param <T> the type of elements that can be emitted through this sink\n+\t */\n+\tpublic interface StandaloneMonoSink<T> extends ScalarSink<T> {\n+\n+\t\t/**\n+\t\t * Return the companion {@link Mono} instance that is backed by this sink.\n+\t\t * All calls to this method return the same instance.\n+\t\t *\n+\t\t * @return the {@link Mono} view associated to this {@link StandaloneMonoSink}\n+\t\t */\n+\t\tMono<T> asMono();\n+\t}\n+\n+\t// == concrete classes ==\n+\n+\tstatic final class FluxProcessorSink<T>\n+\t\t\timplements StandaloneFluxSink<T> {\n+\n+\t\tfinal FluxSink<T>         delegateSink;\n+\t\tfinal FluxProcessor<T, T> processor;\n+\n+\t\t@SuppressWarnings(\"deprecation\")\n+\t\tFluxProcessorSink(FluxProcessor<T, T> processor) {\n+\t\t\tthis.processor = processor;\n+\t\t\tthis.delegateSink = processor.sink();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Flux<T> asFlux() {\n+\t\t\treturn processor;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUwNzg2MQ=="}, "originalCommit": {"oid": "299a170088e47afaa060b550a7d9a4772169af30"}, "originalPosition": 188}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjg3MDIxOA==", "bodyText": "I need to look deeper into the consequences of that, not sure applying the hooks to the processor will work naturally. plus currently there is no such thing with processors. can you chime back in once M1 is released (eg creating an issue for M2) ?", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442870218", "createdAt": "2020-06-19T14:23:55Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/Sinks.java", "diffHunk": "@@ -0,0 +1,262 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import org.reactivestreams.Subscriber;\n+\n+import reactor.util.annotation.Nullable;\n+import reactor.util.concurrent.Queues;\n+import reactor.util.context.Context;\n+\n+/**\n+ * A collection of standalone sinks ({@link StandaloneFluxSink} and\n+ * {@link StandaloneMonoSink}).\n+ *\n+ * @author Simon Basl\u00e9\n+ */\n+public final class Sinks {\n+\n+\tprivate Sinks() { }\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand by conforming to the lowest demand in case\n+\t *     of multiple subscribers.</li>\n+\t *     <li>Replaying: No replay. Only forwards to a {@link Subscriber} the elements that have been\n+\t *     pushed to the sink AFTER this subscriber was subscribed. To the exception of the first\n+\t *     subscriber (see below).</li>\n+\t *     <li>Without {@link Subscriber}: warm up. Remembers up to {@link Queues#SMALL_BUFFER_SIZE}\n+\t *     elements pushed before the first {@link Subscriber} is registered.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> multicast() {\n+\t\treturn new FluxProcessorSink<>(EmitterProcessor.create(Queues.SMALL_BUFFER_SIZE));\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n+\t *     <li>Replaying: No replay. Only forwards to a {@link Subscriber} the elements that have been\n+\t *     pushed to the sink AFTER this subscriber was subscribed.</li>\n+\t *     <li>Without {@link Subscriber}: Discarding. Pushing elements while there are no {@link Subscriber}\n+\t *     registered will simply discard these elements instead of \"warming up\" the sink.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> multicastNoWarmup() {\n+\t\treturn new FluxProcessorSink<>(ReplayProcessor.create(0));\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n+\t *     <li>Replaying: by {@code historySize}. Keeps the last {@code historySize} elements and\n+\t *     replays them instantly to new subscribers before continuing with \"live\" elements.</li>\n+\t *     <li>Without {@link Subscriber}: buffers enough elements pushed without a subscriber to\n+\t *     honor the {@code historySize}.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> replay(int historySize) {\n+\t\treturn new FluxProcessorSink<>(ReplayProcessor.create(historySize));\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n+\t *     <li>Replaying: all elements pushed to this sink are replayed to new subscribers.</li>\n+\t *     <li>Without {@link Subscriber}: all elements pushed to this sink are remembered,\n+\t *     even when there is no subscriber.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> replayAll() {\n+\t\treturn new FluxProcessorSink<>(ReplayProcessor.create());\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li><strong>Unicast</strong>: contrary to most other {@link StandaloneFluxSink}, the\n+\t *     {@link Flux} view rejects {@link Subscriber subscribers} past the first one.</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of its single {@link Subscriber}.</li>\n+\t *     <li>Replaying: non-applicable, since only one {@link Subscriber} can register.</li>\n+\t *     <li>Without {@link Subscriber}: all elements pushed to this sink are remembered and will\n+\t *     be replayed once the {@link Subscriber} subscribes.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> unicast() {\n+\t\treturn new FluxProcessorSink<>(UnicastProcessor.create());\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneMonoSink} that can be triggered at any time by either of\n+\t * the three completions: {@link ScalarSink#success(Object) valued completion},\n+\t * {@link ScalarSink#success() empty completions} or {@link ScalarSink#error(Throwable) error}.\n+\t * This completion is replayed to late subscribers.\n+\t */\n+\tpublic static <T> StandaloneMonoSink<T> trigger() {\n+\t\treturn new MonoProcessorSink<>(MonoProcessor.create());\n+\t}\n+\n+\t// == interfaces ==\n+\n+\t/**\n+\t * A flavor of {@link SequenceSink} that is not attached to a single {@link Subscriber}\n+\t * but rather viewable {@link #asFlux() as a Flux}. Most likely, such a {@link SequenceSink}\n+\t * is capable of multicasting to several subscribers. However implementations can chose\n+\t * to be unicast instead, and only accept one {@link Subscriber} at a time (as allowed\n+\t * by the {@link org.reactivestreams.Publisher} specification).\n+\t *\n+\t * @param <T> the type of elements that can be emitted through this sink\n+\t */\n+\tpublic interface StandaloneFluxSink<T> extends SequenceSink<T> {\n+\n+\t\t@Override\n+\t\tStandaloneFluxSink<T> next(T t);\n+\n+\t\t/**\n+\t\t * Return the companion {@link Flux} instance that is backed by this sink.\n+\t\t * All calls to this method return the same instance.\n+\t\t *\n+\t\t * @return the {@link Flux} view associated to this {@link StandaloneFluxSink}\n+\t\t */\n+\t\tFlux<T> asFlux();\n+\n+\t}\n+\n+\t/**\n+\t * A flavor of {@link ScalarSink} that is not attached to a single {@link Subscriber}\n+\t * but rather viewable {@link #asMono() as a Mono}. Most likely, such a {@link ScalarSink}\n+\t * is capable of multicasting to several subscribers. However implementations can chose\n+\t * to be unicast instead, and only accept one {@link Subscriber} at a time (as allowed\n+\t * by the {@link org.reactivestreams.Publisher} specification).\n+\t *\n+\t * @param <T> the type of elements that can be emitted through this sink\n+\t */\n+\tpublic interface StandaloneMonoSink<T> extends ScalarSink<T> {\n+\n+\t\t/**\n+\t\t * Return the companion {@link Mono} instance that is backed by this sink.\n+\t\t * All calls to this method return the same instance.\n+\t\t *\n+\t\t * @return the {@link Mono} view associated to this {@link StandaloneMonoSink}\n+\t\t */\n+\t\tMono<T> asMono();\n+\t}\n+\n+\t// == concrete classes ==\n+\n+\tstatic final class FluxProcessorSink<T>\n+\t\t\timplements StandaloneFluxSink<T> {\n+\n+\t\tfinal FluxSink<T>         delegateSink;\n+\t\tfinal FluxProcessor<T, T> processor;\n+\n+\t\t@SuppressWarnings(\"deprecation\")\n+\t\tFluxProcessorSink(FluxProcessor<T, T> processor) {\n+\t\t\tthis.processor = processor;\n+\t\t\tthis.delegateSink = processor.sink();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Flux<T> asFlux() {\n+\t\t\treturn processor;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUwNzg2MQ=="}, "originalCommit": {"oid": "299a170088e47afaa060b550a7d9a4772169af30"}, "originalPosition": 188}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1ODE4MDUxOnYy", "diffSide": "RIGHT", "path": "reactor-core/src/main/java/reactor/core/publisher/FluxSink.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwODo0MTozNFrOGmNEkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQxMzoxNDowOVrOGmUYrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcxMzIzMw==", "bodyText": "shouldn't it inherit the javadocs?", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442713233", "createdAt": "2020-06-19T08:41:34Z", "author": {"login": "bsideup"}, "path": "reactor-core/src/main/java/reactor/core/publisher/FluxSink.java", "diffHunk": "@@ -31,12 +31,10 @@\n  * <p>\n  * @param <T> the value type\n  */\n-public interface FluxSink<T> {\n+public interface FluxSink<T> extends SequenceSink<T> {\n \n-\t/**\n-     * @see Subscriber#onComplete()\n-     */\n-    void complete();\n+\t@Override", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "299a170088e47afaa060b550a7d9a4772169af30"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjgzMzA2OA==", "bodyText": "the javadoc is automatically copied, inheritDoc is only if you want to supplement it with additional content while including the super content", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442833068", "createdAt": "2020-06-19T13:14:09Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/FluxSink.java", "diffHunk": "@@ -31,12 +31,10 @@\n  * <p>\n  * @param <T> the value type\n  */\n-public interface FluxSink<T> {\n+public interface FluxSink<T> extends SequenceSink<T> {\n \n-\t/**\n-     * @see Subscriber#onComplete()\n-     */\n-    void complete();\n+\t@Override", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcxMzIzMw=="}, "originalCommit": {"oid": "299a170088e47afaa060b550a7d9a4772169af30"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1ODE4OTA3OnYy", "diffSide": "RIGHT", "path": "reactor-core/src/main/java/reactor/core/publisher/Processors.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwODo0NjowMFrOGmNJhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQxNToyNDowNVrOGmYqrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcxNDUwMg==", "bodyText": "FYI one of the reasons why I was choosing concrete type over FluxProcessor is because having to specify the type argument twice was a bit cumbersome.\nAs this is a new API, perhaps we can do something about it? especially given that now it is always <T, T>", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442714502", "createdAt": "2020-06-19T08:46:00Z", "author": {"login": "bsideup"}, "path": "reactor-core/src/main/java/reactor/core/publisher/Processors.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import java.time.Duration;\n+import java.util.Queue;\n+import java.util.function.Consumer;\n+\n+import reactor.core.Disposable;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.util.annotation.Nullable;\n+\n+/**\n+ * @author Simon Basl\u00e9\n+ */\n+public final class Processors {\n+\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static final <T> FluxProcessor<T, T> unicast() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "299a170088e47afaa060b550a7d9a4772169af30"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyMzAxNA==", "bodyText": "the number of new interfaces / classes was a concern in the original proposal back then, but there's probably little way around the current split into 4 sink interfaces (plus 2 additional utility classes).\nwe could improve that <T,T> situation but it means adding FluxIdentityProcessor<T> at least... Maybe Processors can be turned into both interface and factory.\nIt raises another issue, which is the misalignment between FluxProcessor<A,B> and MonoProcessor<A> (mono processor has a single concrete implementation, and thus doesn't help with representing processing stages). That'll be a concern for either M2 or 3.5 now :/", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442723014", "createdAt": "2020-06-19T09:08:27Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/Processors.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import java.time.Duration;\n+import java.util.Queue;\n+import java.util.function.Consumer;\n+\n+import reactor.core.Disposable;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.util.annotation.Nullable;\n+\n+/**\n+ * @author Simon Basl\u00e9\n+ */\n+public final class Processors {\n+\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static final <T> FluxProcessor<T, T> unicast() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcxNDUwMg=="}, "originalCommit": {"oid": "299a170088e47afaa060b550a7d9a4772169af30"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjkwMzIxNQ==", "bodyText": "actually it cannot be melded with Processors, the FluxProcessor being an abstract class (due to the need to extend Flux)... furthermore replay factory method on Processors would clash with Flux#replay(), and the factory methods would be lost in the noise of Flux API.\nInstead I went ahead and added an abstract intermediate FluxIdentityProcessor<T> extends FluxProcessor<T, T>", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442903215", "createdAt": "2020-06-19T15:24:05Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/Processors.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import java.time.Duration;\n+import java.util.Queue;\n+import java.util.function.Consumer;\n+\n+import reactor.core.Disposable;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.util.annotation.Nullable;\n+\n+/**\n+ * @author Simon Basl\u00e9\n+ */\n+public final class Processors {\n+\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static final <T> FluxProcessor<T, T> unicast() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcxNDUwMg=="}, "originalCommit": {"oid": "299a170088e47afaa060b550a7d9a4772169af30"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1ODE5NTM1OnYy", "diffSide": "RIGHT", "path": "reactor-core/src/main/java/reactor/core/publisher/Sinks.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwODo1MDoxMlrOGmNNIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQxNDoxNDozN1rOGmWWVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcxNTQyNA==", "bodyText": "\"warmup\" sounds like a new term added. And, TBH, I struggle to understand it (even after reading the javadoc) \ud83d\ude05\nCould you please help me understanding the concept?", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442715424", "createdAt": "2020-06-19T08:50:12Z", "author": {"login": "bsideup"}, "path": "reactor-core/src/main/java/reactor/core/publisher/Sinks.java", "diffHunk": "@@ -0,0 +1,262 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import org.reactivestreams.Subscriber;\n+\n+import reactor.util.annotation.Nullable;\n+import reactor.util.concurrent.Queues;\n+import reactor.util.context.Context;\n+\n+/**\n+ * A collection of standalone sinks ({@link StandaloneFluxSink} and\n+ * {@link StandaloneMonoSink}).\n+ *\n+ * @author Simon Basl\u00e9\n+ */\n+public final class Sinks {\n+\n+\tprivate Sinks() { }\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand by conforming to the lowest demand in case\n+\t *     of multiple subscribers.</li>\n+\t *     <li>Replaying: No replay. Only forwards to a {@link Subscriber} the elements that have been\n+\t *     pushed to the sink AFTER this subscriber was subscribed. To the exception of the first\n+\t *     subscriber (see below).</li>\n+\t *     <li>Without {@link Subscriber}: warm up. Remembers up to {@link Queues#SMALL_BUFFER_SIZE}\n+\t *     elements pushed before the first {@link Subscriber} is registered.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> multicast() {\n+\t\treturn new FluxProcessorSink<>(EmitterProcessor.create(Queues.SMALL_BUFFER_SIZE));\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n+\t *     <li>Replaying: No replay. Only forwards to a {@link Subscriber} the elements that have been\n+\t *     pushed to the sink AFTER this subscriber was subscribed.</li>\n+\t *     <li>Without {@link Subscriber}: Discarding. Pushing elements while there are no {@link Subscriber}\n+\t *     registered will simply discard these elements instead of \"warming up\" the sink.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> multicastNoWarmup() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "299a170088e47afaa060b550a7d9a4772169af30"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcxOTAwNQ==", "bodyText": "yeah I'm having trouble finding a better term. It's the way some processors will \"remember\" upstream onNext (or in our case sink.next) that come in BEFORE the first Subscriber subscribes. But then the second Subscriber would only see live pushes.\n\\ denotes a subscription\n<-warmup------><---------hot ---------->\n\n--(1)---(2)----\\---------\\----(3)------>   sink\n              -\\(1)(2)--------(3)------>   sub1\n                        -\\----(3)------>   sub2", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442719005", "createdAt": "2020-06-19T08:59:39Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/Sinks.java", "diffHunk": "@@ -0,0 +1,262 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import org.reactivestreams.Subscriber;\n+\n+import reactor.util.annotation.Nullable;\n+import reactor.util.concurrent.Queues;\n+import reactor.util.context.Context;\n+\n+/**\n+ * A collection of standalone sinks ({@link StandaloneFluxSink} and\n+ * {@link StandaloneMonoSink}).\n+ *\n+ * @author Simon Basl\u00e9\n+ */\n+public final class Sinks {\n+\n+\tprivate Sinks() { }\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand by conforming to the lowest demand in case\n+\t *     of multiple subscribers.</li>\n+\t *     <li>Replaying: No replay. Only forwards to a {@link Subscriber} the elements that have been\n+\t *     pushed to the sink AFTER this subscriber was subscribed. To the exception of the first\n+\t *     subscriber (see below).</li>\n+\t *     <li>Without {@link Subscriber}: warm up. Remembers up to {@link Queues#SMALL_BUFFER_SIZE}\n+\t *     elements pushed before the first {@link Subscriber} is registered.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> multicast() {\n+\t\treturn new FluxProcessorSink<>(EmitterProcessor.create(Queues.SMALL_BUFFER_SIZE));\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n+\t *     <li>Replaying: No replay. Only forwards to a {@link Subscriber} the elements that have been\n+\t *     pushed to the sink AFTER this subscriber was subscribed.</li>\n+\t *     <li>Without {@link Subscriber}: Discarding. Pushing elements while there are no {@link Subscriber}\n+\t *     registered will simply discard these elements instead of \"warming up\" the sink.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> multicastNoWarmup() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcxNTQyNA=="}, "originalCommit": {"oid": "299a170088e47afaa060b550a7d9a4772169af30"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjc0NzAzNg==", "bodyText": "Thanks, the diagram really helps! Maybe let's add it to the javadoc?", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442747036", "createdAt": "2020-06-19T09:57:09Z", "author": {"login": "bsideup"}, "path": "reactor-core/src/main/java/reactor/core/publisher/Sinks.java", "diffHunk": "@@ -0,0 +1,262 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import org.reactivestreams.Subscriber;\n+\n+import reactor.util.annotation.Nullable;\n+import reactor.util.concurrent.Queues;\n+import reactor.util.context.Context;\n+\n+/**\n+ * A collection of standalone sinks ({@link StandaloneFluxSink} and\n+ * {@link StandaloneMonoSink}).\n+ *\n+ * @author Simon Basl\u00e9\n+ */\n+public final class Sinks {\n+\n+\tprivate Sinks() { }\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand by conforming to the lowest demand in case\n+\t *     of multiple subscribers.</li>\n+\t *     <li>Replaying: No replay. Only forwards to a {@link Subscriber} the elements that have been\n+\t *     pushed to the sink AFTER this subscriber was subscribed. To the exception of the first\n+\t *     subscriber (see below).</li>\n+\t *     <li>Without {@link Subscriber}: warm up. Remembers up to {@link Queues#SMALL_BUFFER_SIZE}\n+\t *     elements pushed before the first {@link Subscriber} is registered.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> multicast() {\n+\t\treturn new FluxProcessorSink<>(EmitterProcessor.create(Queues.SMALL_BUFFER_SIZE));\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n+\t *     <li>Replaying: No replay. Only forwards to a {@link Subscriber} the elements that have been\n+\t *     pushed to the sink AFTER this subscriber was subscribed.</li>\n+\t *     <li>Without {@link Subscriber}: Discarding. Pushing elements while there are no {@link Subscriber}\n+\t *     registered will simply discard these elements instead of \"warming up\" the sink.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> multicastNoWarmup() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcxNTQyNA=="}, "originalCommit": {"oid": "299a170088e47afaa060b550a7d9a4772169af30"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjg2NTIzNw==", "bodyText": "I'll add a quick SVG version for both multicast() and multicastNoWarmup()", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442865237", "createdAt": "2020-06-19T14:14:37Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/Sinks.java", "diffHunk": "@@ -0,0 +1,262 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import org.reactivestreams.Subscriber;\n+\n+import reactor.util.annotation.Nullable;\n+import reactor.util.concurrent.Queues;\n+import reactor.util.context.Context;\n+\n+/**\n+ * A collection of standalone sinks ({@link StandaloneFluxSink} and\n+ * {@link StandaloneMonoSink}).\n+ *\n+ * @author Simon Basl\u00e9\n+ */\n+public final class Sinks {\n+\n+\tprivate Sinks() { }\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand by conforming to the lowest demand in case\n+\t *     of multiple subscribers.</li>\n+\t *     <li>Replaying: No replay. Only forwards to a {@link Subscriber} the elements that have been\n+\t *     pushed to the sink AFTER this subscriber was subscribed. To the exception of the first\n+\t *     subscriber (see below).</li>\n+\t *     <li>Without {@link Subscriber}: warm up. Remembers up to {@link Queues#SMALL_BUFFER_SIZE}\n+\t *     elements pushed before the first {@link Subscriber} is registered.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> multicast() {\n+\t\treturn new FluxProcessorSink<>(EmitterProcessor.create(Queues.SMALL_BUFFER_SIZE));\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n+\t *     <li>Replaying: No replay. Only forwards to a {@link Subscriber} the elements that have been\n+\t *     pushed to the sink AFTER this subscriber was subscribed.</li>\n+\t *     <li>Without {@link Subscriber}: Discarding. Pushing elements while there are no {@link Subscriber}\n+\t *     registered will simply discard these elements instead of \"warming up\" the sink.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> multicastNoWarmup() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcxNTQyNA=="}, "originalCommit": {"oid": "299a170088e47afaa060b550a7d9a4772169af30"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1ODIxODk2OnYy", "diffSide": "RIGHT", "path": "reactor-core/src/main/java/reactor/core/publisher/Sinks.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwOTowMDozOVrOGmNc3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQxNDoyNjo1MVrOGmWwNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcxOTQ1NQ==", "bodyText": "WDYT about promise or future? trigger is too verb-ish", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442719455", "createdAt": "2020-06-19T09:00:39Z", "author": {"login": "bsideup"}, "path": "reactor-core/src/main/java/reactor/core/publisher/Sinks.java", "diffHunk": "@@ -0,0 +1,262 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import org.reactivestreams.Subscriber;\n+\n+import reactor.util.annotation.Nullable;\n+import reactor.util.concurrent.Queues;\n+import reactor.util.context.Context;\n+\n+/**\n+ * A collection of standalone sinks ({@link StandaloneFluxSink} and\n+ * {@link StandaloneMonoSink}).\n+ *\n+ * @author Simon Basl\u00e9\n+ */\n+public final class Sinks {\n+\n+\tprivate Sinks() { }\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand by conforming to the lowest demand in case\n+\t *     of multiple subscribers.</li>\n+\t *     <li>Replaying: No replay. Only forwards to a {@link Subscriber} the elements that have been\n+\t *     pushed to the sink AFTER this subscriber was subscribed. To the exception of the first\n+\t *     subscriber (see below).</li>\n+\t *     <li>Without {@link Subscriber}: warm up. Remembers up to {@link Queues#SMALL_BUFFER_SIZE}\n+\t *     elements pushed before the first {@link Subscriber} is registered.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> multicast() {\n+\t\treturn new FluxProcessorSink<>(EmitterProcessor.create(Queues.SMALL_BUFFER_SIZE));\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n+\t *     <li>Replaying: No replay. Only forwards to a {@link Subscriber} the elements that have been\n+\t *     pushed to the sink AFTER this subscriber was subscribed.</li>\n+\t *     <li>Without {@link Subscriber}: Discarding. Pushing elements while there are no {@link Subscriber}\n+\t *     registered will simply discard these elements instead of \"warming up\" the sink.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> multicastNoWarmup() {\n+\t\treturn new FluxProcessorSink<>(ReplayProcessor.create(0));\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n+\t *     <li>Replaying: by {@code historySize}. Keeps the last {@code historySize} elements and\n+\t *     replays them instantly to new subscribers before continuing with \"live\" elements.</li>\n+\t *     <li>Without {@link Subscriber}: buffers enough elements pushed without a subscriber to\n+\t *     honor the {@code historySize}.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> replay(int historySize) {\n+\t\treturn new FluxProcessorSink<>(ReplayProcessor.create(historySize));\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n+\t *     <li>Replaying: all elements pushed to this sink are replayed to new subscribers.</li>\n+\t *     <li>Without {@link Subscriber}: all elements pushed to this sink are remembered,\n+\t *     even when there is no subscriber.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> replayAll() {\n+\t\treturn new FluxProcessorSink<>(ReplayProcessor.create());\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li><strong>Unicast</strong>: contrary to most other {@link StandaloneFluxSink}, the\n+\t *     {@link Flux} view rejects {@link Subscriber subscribers} past the first one.</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of its single {@link Subscriber}.</li>\n+\t *     <li>Replaying: non-applicable, since only one {@link Subscriber} can register.</li>\n+\t *     <li>Without {@link Subscriber}: all elements pushed to this sink are remembered and will\n+\t *     be replayed once the {@link Subscriber} subscribes.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> unicast() {\n+\t\treturn new FluxProcessorSink<>(UnicastProcessor.create());\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneMonoSink} that can be triggered at any time by either of\n+\t * the three completions: {@link ScalarSink#success(Object) valued completion},\n+\t * {@link ScalarSink#success() empty completions} or {@link ScalarSink#error(Throwable) error}.\n+\t * This completion is replayed to late subscribers.\n+\t */\n+\tpublic static <T> StandaloneMonoSink<T> trigger() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "299a170088e47afaa060b550a7d9a4772169af30"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyNTAyMg==", "bodyText": "I don't really like trigger either, future and promise sound too overloaded. Maybe completable to echo both CompletableFuture and Completable in RxJava? By I fear this becomes overloaded too...", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442725022", "createdAt": "2020-06-19T09:12:36Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/Sinks.java", "diffHunk": "@@ -0,0 +1,262 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import org.reactivestreams.Subscriber;\n+\n+import reactor.util.annotation.Nullable;\n+import reactor.util.concurrent.Queues;\n+import reactor.util.context.Context;\n+\n+/**\n+ * A collection of standalone sinks ({@link StandaloneFluxSink} and\n+ * {@link StandaloneMonoSink}).\n+ *\n+ * @author Simon Basl\u00e9\n+ */\n+public final class Sinks {\n+\n+\tprivate Sinks() { }\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand by conforming to the lowest demand in case\n+\t *     of multiple subscribers.</li>\n+\t *     <li>Replaying: No replay. Only forwards to a {@link Subscriber} the elements that have been\n+\t *     pushed to the sink AFTER this subscriber was subscribed. To the exception of the first\n+\t *     subscriber (see below).</li>\n+\t *     <li>Without {@link Subscriber}: warm up. Remembers up to {@link Queues#SMALL_BUFFER_SIZE}\n+\t *     elements pushed before the first {@link Subscriber} is registered.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> multicast() {\n+\t\treturn new FluxProcessorSink<>(EmitterProcessor.create(Queues.SMALL_BUFFER_SIZE));\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n+\t *     <li>Replaying: No replay. Only forwards to a {@link Subscriber} the elements that have been\n+\t *     pushed to the sink AFTER this subscriber was subscribed.</li>\n+\t *     <li>Without {@link Subscriber}: Discarding. Pushing elements while there are no {@link Subscriber}\n+\t *     registered will simply discard these elements instead of \"warming up\" the sink.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> multicastNoWarmup() {\n+\t\treturn new FluxProcessorSink<>(ReplayProcessor.create(0));\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n+\t *     <li>Replaying: by {@code historySize}. Keeps the last {@code historySize} elements and\n+\t *     replays them instantly to new subscribers before continuing with \"live\" elements.</li>\n+\t *     <li>Without {@link Subscriber}: buffers enough elements pushed without a subscriber to\n+\t *     honor the {@code historySize}.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> replay(int historySize) {\n+\t\treturn new FluxProcessorSink<>(ReplayProcessor.create(historySize));\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n+\t *     <li>Replaying: all elements pushed to this sink are replayed to new subscribers.</li>\n+\t *     <li>Without {@link Subscriber}: all elements pushed to this sink are remembered,\n+\t *     even when there is no subscriber.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> replayAll() {\n+\t\treturn new FluxProcessorSink<>(ReplayProcessor.create());\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li><strong>Unicast</strong>: contrary to most other {@link StandaloneFluxSink}, the\n+\t *     {@link Flux} view rejects {@link Subscriber subscribers} past the first one.</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of its single {@link Subscriber}.</li>\n+\t *     <li>Replaying: non-applicable, since only one {@link Subscriber} can register.</li>\n+\t *     <li>Without {@link Subscriber}: all elements pushed to this sink are remembered and will\n+\t *     be replayed once the {@link Subscriber} subscribes.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> unicast() {\n+\t\treturn new FluxProcessorSink<>(UnicastProcessor.create());\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneMonoSink} that can be triggered at any time by either of\n+\t * the three completions: {@link ScalarSink#success(Object) valued completion},\n+\t * {@link ScalarSink#success() empty completions} or {@link ScalarSink#error(Throwable) error}.\n+\t * This completion is replayed to late subscribers.\n+\t */\n+\tpublic static <T> StandaloneMonoSink<T> trigger() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcxOTQ1NQ=="}, "originalCommit": {"oid": "299a170088e47afaa060b550a7d9a4772169af30"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjc0NzcyOA==", "bodyText": "IIRC Completable in RxJava is Publisher<Void>. It does sound too overloaded but we're talking about method's name, not type, so I think we're fine as it helps understanding the return value much better.", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442747728", "createdAt": "2020-06-19T09:58:34Z", "author": {"login": "bsideup"}, "path": "reactor-core/src/main/java/reactor/core/publisher/Sinks.java", "diffHunk": "@@ -0,0 +1,262 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import org.reactivestreams.Subscriber;\n+\n+import reactor.util.annotation.Nullable;\n+import reactor.util.concurrent.Queues;\n+import reactor.util.context.Context;\n+\n+/**\n+ * A collection of standalone sinks ({@link StandaloneFluxSink} and\n+ * {@link StandaloneMonoSink}).\n+ *\n+ * @author Simon Basl\u00e9\n+ */\n+public final class Sinks {\n+\n+\tprivate Sinks() { }\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand by conforming to the lowest demand in case\n+\t *     of multiple subscribers.</li>\n+\t *     <li>Replaying: No replay. Only forwards to a {@link Subscriber} the elements that have been\n+\t *     pushed to the sink AFTER this subscriber was subscribed. To the exception of the first\n+\t *     subscriber (see below).</li>\n+\t *     <li>Without {@link Subscriber}: warm up. Remembers up to {@link Queues#SMALL_BUFFER_SIZE}\n+\t *     elements pushed before the first {@link Subscriber} is registered.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> multicast() {\n+\t\treturn new FluxProcessorSink<>(EmitterProcessor.create(Queues.SMALL_BUFFER_SIZE));\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n+\t *     <li>Replaying: No replay. Only forwards to a {@link Subscriber} the elements that have been\n+\t *     pushed to the sink AFTER this subscriber was subscribed.</li>\n+\t *     <li>Without {@link Subscriber}: Discarding. Pushing elements while there are no {@link Subscriber}\n+\t *     registered will simply discard these elements instead of \"warming up\" the sink.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> multicastNoWarmup() {\n+\t\treturn new FluxProcessorSink<>(ReplayProcessor.create(0));\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n+\t *     <li>Replaying: by {@code historySize}. Keeps the last {@code historySize} elements and\n+\t *     replays them instantly to new subscribers before continuing with \"live\" elements.</li>\n+\t *     <li>Without {@link Subscriber}: buffers enough elements pushed without a subscriber to\n+\t *     honor the {@code historySize}.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> replay(int historySize) {\n+\t\treturn new FluxProcessorSink<>(ReplayProcessor.create(historySize));\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n+\t *     <li>Replaying: all elements pushed to this sink are replayed to new subscribers.</li>\n+\t *     <li>Without {@link Subscriber}: all elements pushed to this sink are remembered,\n+\t *     even when there is no subscriber.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> replayAll() {\n+\t\treturn new FluxProcessorSink<>(ReplayProcessor.create());\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li><strong>Unicast</strong>: contrary to most other {@link StandaloneFluxSink}, the\n+\t *     {@link Flux} view rejects {@link Subscriber subscribers} past the first one.</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of its single {@link Subscriber}.</li>\n+\t *     <li>Replaying: non-applicable, since only one {@link Subscriber} can register.</li>\n+\t *     <li>Without {@link Subscriber}: all elements pushed to this sink are remembered and will\n+\t *     be replayed once the {@link Subscriber} subscribes.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> unicast() {\n+\t\treturn new FluxProcessorSink<>(UnicastProcessor.create());\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneMonoSink} that can be triggered at any time by either of\n+\t * the three completions: {@link ScalarSink#success(Object) valued completion},\n+\t * {@link ScalarSink#success() empty completions} or {@link ScalarSink#error(Throwable) error}.\n+\t * This completion is replayed to late subscribers.\n+\t */\n+\tpublic static <T> StandaloneMonoSink<T> trigger() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcxOTQ1NQ=="}, "originalCommit": {"oid": "299a170088e47afaa060b550a7d9a4772169af30"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjg3MTg2Mw==", "bodyText": "ok, I'll go with promise actually...", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442871863", "createdAt": "2020-06-19T14:26:51Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/Sinks.java", "diffHunk": "@@ -0,0 +1,262 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import org.reactivestreams.Subscriber;\n+\n+import reactor.util.annotation.Nullable;\n+import reactor.util.concurrent.Queues;\n+import reactor.util.context.Context;\n+\n+/**\n+ * A collection of standalone sinks ({@link StandaloneFluxSink} and\n+ * {@link StandaloneMonoSink}).\n+ *\n+ * @author Simon Basl\u00e9\n+ */\n+public final class Sinks {\n+\n+\tprivate Sinks() { }\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand by conforming to the lowest demand in case\n+\t *     of multiple subscribers.</li>\n+\t *     <li>Replaying: No replay. Only forwards to a {@link Subscriber} the elements that have been\n+\t *     pushed to the sink AFTER this subscriber was subscribed. To the exception of the first\n+\t *     subscriber (see below).</li>\n+\t *     <li>Without {@link Subscriber}: warm up. Remembers up to {@link Queues#SMALL_BUFFER_SIZE}\n+\t *     elements pushed before the first {@link Subscriber} is registered.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> multicast() {\n+\t\treturn new FluxProcessorSink<>(EmitterProcessor.create(Queues.SMALL_BUFFER_SIZE));\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n+\t *     <li>Replaying: No replay. Only forwards to a {@link Subscriber} the elements that have been\n+\t *     pushed to the sink AFTER this subscriber was subscribed.</li>\n+\t *     <li>Without {@link Subscriber}: Discarding. Pushing elements while there are no {@link Subscriber}\n+\t *     registered will simply discard these elements instead of \"warming up\" the sink.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> multicastNoWarmup() {\n+\t\treturn new FluxProcessorSink<>(ReplayProcessor.create(0));\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n+\t *     <li>Replaying: by {@code historySize}. Keeps the last {@code historySize} elements and\n+\t *     replays them instantly to new subscribers before continuing with \"live\" elements.</li>\n+\t *     <li>Without {@link Subscriber}: buffers enough elements pushed without a subscriber to\n+\t *     honor the {@code historySize}.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> replay(int historySize) {\n+\t\treturn new FluxProcessorSink<>(ReplayProcessor.create(historySize));\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n+\t *     <li>Replaying: all elements pushed to this sink are replayed to new subscribers.</li>\n+\t *     <li>Without {@link Subscriber}: all elements pushed to this sink are remembered,\n+\t *     even when there is no subscriber.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> replayAll() {\n+\t\treturn new FluxProcessorSink<>(ReplayProcessor.create());\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li><strong>Unicast</strong>: contrary to most other {@link StandaloneFluxSink}, the\n+\t *     {@link Flux} view rejects {@link Subscriber subscribers} past the first one.</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of its single {@link Subscriber}.</li>\n+\t *     <li>Replaying: non-applicable, since only one {@link Subscriber} can register.</li>\n+\t *     <li>Without {@link Subscriber}: all elements pushed to this sink are remembered and will\n+\t *     be replayed once the {@link Subscriber} subscribes.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> unicast() {\n+\t\treturn new FluxProcessorSink<>(UnicastProcessor.create());\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneMonoSink} that can be triggered at any time by either of\n+\t * the three completions: {@link ScalarSink#success(Object) valued completion},\n+\t * {@link ScalarSink#success() empty completions} or {@link ScalarSink#error(Throwable) error}.\n+\t * This completion is replayed to late subscribers.\n+\t */\n+\tpublic static <T> StandaloneMonoSink<T> trigger() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcxOTQ1NQ=="}, "originalCommit": {"oid": "299a170088e47afaa060b550a7d9a4772169af30"}, "originalPosition": 122}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1ODIzMzU4OnYy", "diffSide": "RIGHT", "path": "reactor-core/src/main/java/reactor/core/publisher/Sinks.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwOTowNjoxMVrOGmNmVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwOToxMDoyOVrOGmNuww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyMTg3Nw==", "bodyText": "Just curious, why not using CAS?", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442721877", "createdAt": "2020-06-19T09:06:11Z", "author": {"login": "bsideup"}, "path": "reactor-core/src/main/java/reactor/core/publisher/Sinks.java", "diffHunk": "@@ -0,0 +1,262 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import org.reactivestreams.Subscriber;\n+\n+import reactor.util.annotation.Nullable;\n+import reactor.util.concurrent.Queues;\n+import reactor.util.context.Context;\n+\n+/**\n+ * A collection of standalone sinks ({@link StandaloneFluxSink} and\n+ * {@link StandaloneMonoSink}).\n+ *\n+ * @author Simon Basl\u00e9\n+ */\n+public final class Sinks {\n+\n+\tprivate Sinks() { }\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand by conforming to the lowest demand in case\n+\t *     of multiple subscribers.</li>\n+\t *     <li>Replaying: No replay. Only forwards to a {@link Subscriber} the elements that have been\n+\t *     pushed to the sink AFTER this subscriber was subscribed. To the exception of the first\n+\t *     subscriber (see below).</li>\n+\t *     <li>Without {@link Subscriber}: warm up. Remembers up to {@link Queues#SMALL_BUFFER_SIZE}\n+\t *     elements pushed before the first {@link Subscriber} is registered.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> multicast() {\n+\t\treturn new FluxProcessorSink<>(EmitterProcessor.create(Queues.SMALL_BUFFER_SIZE));\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n+\t *     <li>Replaying: No replay. Only forwards to a {@link Subscriber} the elements that have been\n+\t *     pushed to the sink AFTER this subscriber was subscribed.</li>\n+\t *     <li>Without {@link Subscriber}: Discarding. Pushing elements while there are no {@link Subscriber}\n+\t *     registered will simply discard these elements instead of \"warming up\" the sink.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> multicastNoWarmup() {\n+\t\treturn new FluxProcessorSink<>(ReplayProcessor.create(0));\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n+\t *     <li>Replaying: by {@code historySize}. Keeps the last {@code historySize} elements and\n+\t *     replays them instantly to new subscribers before continuing with \"live\" elements.</li>\n+\t *     <li>Without {@link Subscriber}: buffers enough elements pushed without a subscriber to\n+\t *     honor the {@code historySize}.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> replay(int historySize) {\n+\t\treturn new FluxProcessorSink<>(ReplayProcessor.create(historySize));\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n+\t *     <li>Replaying: all elements pushed to this sink are replayed to new subscribers.</li>\n+\t *     <li>Without {@link Subscriber}: all elements pushed to this sink are remembered,\n+\t *     even when there is no subscriber.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> replayAll() {\n+\t\treturn new FluxProcessorSink<>(ReplayProcessor.create());\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li><strong>Unicast</strong>: contrary to most other {@link StandaloneFluxSink}, the\n+\t *     {@link Flux} view rejects {@link Subscriber subscribers} past the first one.</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of its single {@link Subscriber}.</li>\n+\t *     <li>Replaying: non-applicable, since only one {@link Subscriber} can register.</li>\n+\t *     <li>Without {@link Subscriber}: all elements pushed to this sink are remembered and will\n+\t *     be replayed once the {@link Subscriber} subscribes.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> unicast() {\n+\t\treturn new FluxProcessorSink<>(UnicastProcessor.create());\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneMonoSink} that can be triggered at any time by either of\n+\t * the three completions: {@link ScalarSink#success(Object) valued completion},\n+\t * {@link ScalarSink#success() empty completions} or {@link ScalarSink#error(Throwable) error}.\n+\t * This completion is replayed to late subscribers.\n+\t */\n+\tpublic static <T> StandaloneMonoSink<T> trigger() {\n+\t\treturn new MonoProcessorSink<>(MonoProcessor.create());\n+\t}\n+\n+\t// == interfaces ==\n+\n+\t/**\n+\t * A flavor of {@link SequenceSink} that is not attached to a single {@link Subscriber}\n+\t * but rather viewable {@link #asFlux() as a Flux}. Most likely, such a {@link SequenceSink}\n+\t * is capable of multicasting to several subscribers. However implementations can chose\n+\t * to be unicast instead, and only accept one {@link Subscriber} at a time (as allowed\n+\t * by the {@link org.reactivestreams.Publisher} specification).\n+\t *\n+\t * @param <T> the type of elements that can be emitted through this sink\n+\t */\n+\tpublic interface StandaloneFluxSink<T> extends SequenceSink<T> {\n+\n+\t\t@Override\n+\t\tStandaloneFluxSink<T> next(T t);\n+\n+\t\t/**\n+\t\t * Return the companion {@link Flux} instance that is backed by this sink.\n+\t\t * All calls to this method return the same instance.\n+\t\t *\n+\t\t * @return the {@link Flux} view associated to this {@link StandaloneFluxSink}\n+\t\t */\n+\t\tFlux<T> asFlux();\n+\n+\t}\n+\n+\t/**\n+\t * A flavor of {@link ScalarSink} that is not attached to a single {@link Subscriber}\n+\t * but rather viewable {@link #asMono() as a Mono}. Most likely, such a {@link ScalarSink}\n+\t * is capable of multicasting to several subscribers. However implementations can chose\n+\t * to be unicast instead, and only accept one {@link Subscriber} at a time (as allowed\n+\t * by the {@link org.reactivestreams.Publisher} specification).\n+\t *\n+\t * @param <T> the type of elements that can be emitted through this sink\n+\t */\n+\tpublic interface StandaloneMonoSink<T> extends ScalarSink<T> {\n+\n+\t\t/**\n+\t\t * Return the companion {@link Mono} instance that is backed by this sink.\n+\t\t * All calls to this method return the same instance.\n+\t\t *\n+\t\t * @return the {@link Mono} view associated to this {@link StandaloneMonoSink}\n+\t\t */\n+\t\tMono<T> asMono();\n+\t}\n+\n+\t// == concrete classes ==\n+\n+\tstatic final class FluxProcessorSink<T>\n+\t\t\timplements StandaloneFluxSink<T> {\n+\n+\t\tfinal FluxSink<T>         delegateSink;\n+\t\tfinal FluxProcessor<T, T> processor;\n+\n+\t\t@SuppressWarnings(\"deprecation\")\n+\t\tFluxProcessorSink(FluxProcessor<T, T> processor) {\n+\t\t\tthis.processor = processor;\n+\t\t\tthis.delegateSink = processor.sink();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Flux<T> asFlux() {\n+\t\t\treturn processor;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void complete() {\n+\t\t\tdelegateSink.complete();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void error(Throwable e) {\n+\t\t\tdelegateSink.error(e);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic StandaloneFluxSink<T> next(T t) {\n+\t\t\tdelegateSink.next(t);\n+\t\t\treturn this;\n+\t\t}\n+\t}\n+\n+\tstatic final class MonoProcessorSink<T> implements StandaloneMonoSink<T> {\n+\n+\t\tfinal MonoProcessor<T> processor;\n+\t\tboolean done;\n+\n+\t\tMonoProcessorSink(MonoProcessor<T> processor) {\n+\t\t\tthis.processor = processor;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Mono<T> asMono() {\n+\t\t\treturn this.processor;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void success() {\n+\t\t\tsynchronized (processor) {\n+\t\t\t\tif (done) {\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t\tdone = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "299a170088e47afaa060b550a7d9a4772169af30"}, "originalPosition": 228}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyNDAzNQ==", "bodyText": "too much on my plate to have the perfect implementation in time for M1 :(", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442724035", "createdAt": "2020-06-19T09:10:29Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/Sinks.java", "diffHunk": "@@ -0,0 +1,262 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import org.reactivestreams.Subscriber;\n+\n+import reactor.util.annotation.Nullable;\n+import reactor.util.concurrent.Queues;\n+import reactor.util.context.Context;\n+\n+/**\n+ * A collection of standalone sinks ({@link StandaloneFluxSink} and\n+ * {@link StandaloneMonoSink}).\n+ *\n+ * @author Simon Basl\u00e9\n+ */\n+public final class Sinks {\n+\n+\tprivate Sinks() { }\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand by conforming to the lowest demand in case\n+\t *     of multiple subscribers.</li>\n+\t *     <li>Replaying: No replay. Only forwards to a {@link Subscriber} the elements that have been\n+\t *     pushed to the sink AFTER this subscriber was subscribed. To the exception of the first\n+\t *     subscriber (see below).</li>\n+\t *     <li>Without {@link Subscriber}: warm up. Remembers up to {@link Queues#SMALL_BUFFER_SIZE}\n+\t *     elements pushed before the first {@link Subscriber} is registered.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> multicast() {\n+\t\treturn new FluxProcessorSink<>(EmitterProcessor.create(Queues.SMALL_BUFFER_SIZE));\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n+\t *     <li>Replaying: No replay. Only forwards to a {@link Subscriber} the elements that have been\n+\t *     pushed to the sink AFTER this subscriber was subscribed.</li>\n+\t *     <li>Without {@link Subscriber}: Discarding. Pushing elements while there are no {@link Subscriber}\n+\t *     registered will simply discard these elements instead of \"warming up\" the sink.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> multicastNoWarmup() {\n+\t\treturn new FluxProcessorSink<>(ReplayProcessor.create(0));\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n+\t *     <li>Replaying: by {@code historySize}. Keeps the last {@code historySize} elements and\n+\t *     replays them instantly to new subscribers before continuing with \"live\" elements.</li>\n+\t *     <li>Without {@link Subscriber}: buffers enough elements pushed without a subscriber to\n+\t *     honor the {@code historySize}.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> replay(int historySize) {\n+\t\treturn new FluxProcessorSink<>(ReplayProcessor.create(historySize));\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n+\t *     <li>Replaying: all elements pushed to this sink are replayed to new subscribers.</li>\n+\t *     <li>Without {@link Subscriber}: all elements pushed to this sink are remembered,\n+\t *     even when there is no subscriber.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> replayAll() {\n+\t\treturn new FluxProcessorSink<>(ReplayProcessor.create());\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li><strong>Unicast</strong>: contrary to most other {@link StandaloneFluxSink}, the\n+\t *     {@link Flux} view rejects {@link Subscriber subscribers} past the first one.</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of its single {@link Subscriber}.</li>\n+\t *     <li>Replaying: non-applicable, since only one {@link Subscriber} can register.</li>\n+\t *     <li>Without {@link Subscriber}: all elements pushed to this sink are remembered and will\n+\t *     be replayed once the {@link Subscriber} subscribes.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> unicast() {\n+\t\treturn new FluxProcessorSink<>(UnicastProcessor.create());\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneMonoSink} that can be triggered at any time by either of\n+\t * the three completions: {@link ScalarSink#success(Object) valued completion},\n+\t * {@link ScalarSink#success() empty completions} or {@link ScalarSink#error(Throwable) error}.\n+\t * This completion is replayed to late subscribers.\n+\t */\n+\tpublic static <T> StandaloneMonoSink<T> trigger() {\n+\t\treturn new MonoProcessorSink<>(MonoProcessor.create());\n+\t}\n+\n+\t// == interfaces ==\n+\n+\t/**\n+\t * A flavor of {@link SequenceSink} that is not attached to a single {@link Subscriber}\n+\t * but rather viewable {@link #asFlux() as a Flux}. Most likely, such a {@link SequenceSink}\n+\t * is capable of multicasting to several subscribers. However implementations can chose\n+\t * to be unicast instead, and only accept one {@link Subscriber} at a time (as allowed\n+\t * by the {@link org.reactivestreams.Publisher} specification).\n+\t *\n+\t * @param <T> the type of elements that can be emitted through this sink\n+\t */\n+\tpublic interface StandaloneFluxSink<T> extends SequenceSink<T> {\n+\n+\t\t@Override\n+\t\tStandaloneFluxSink<T> next(T t);\n+\n+\t\t/**\n+\t\t * Return the companion {@link Flux} instance that is backed by this sink.\n+\t\t * All calls to this method return the same instance.\n+\t\t *\n+\t\t * @return the {@link Flux} view associated to this {@link StandaloneFluxSink}\n+\t\t */\n+\t\tFlux<T> asFlux();\n+\n+\t}\n+\n+\t/**\n+\t * A flavor of {@link ScalarSink} that is not attached to a single {@link Subscriber}\n+\t * but rather viewable {@link #asMono() as a Mono}. Most likely, such a {@link ScalarSink}\n+\t * is capable of multicasting to several subscribers. However implementations can chose\n+\t * to be unicast instead, and only accept one {@link Subscriber} at a time (as allowed\n+\t * by the {@link org.reactivestreams.Publisher} specification).\n+\t *\n+\t * @param <T> the type of elements that can be emitted through this sink\n+\t */\n+\tpublic interface StandaloneMonoSink<T> extends ScalarSink<T> {\n+\n+\t\t/**\n+\t\t * Return the companion {@link Mono} instance that is backed by this sink.\n+\t\t * All calls to this method return the same instance.\n+\t\t *\n+\t\t * @return the {@link Mono} view associated to this {@link StandaloneMonoSink}\n+\t\t */\n+\t\tMono<T> asMono();\n+\t}\n+\n+\t// == concrete classes ==\n+\n+\tstatic final class FluxProcessorSink<T>\n+\t\t\timplements StandaloneFluxSink<T> {\n+\n+\t\tfinal FluxSink<T>         delegateSink;\n+\t\tfinal FluxProcessor<T, T> processor;\n+\n+\t\t@SuppressWarnings(\"deprecation\")\n+\t\tFluxProcessorSink(FluxProcessor<T, T> processor) {\n+\t\t\tthis.processor = processor;\n+\t\t\tthis.delegateSink = processor.sink();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Flux<T> asFlux() {\n+\t\t\treturn processor;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void complete() {\n+\t\t\tdelegateSink.complete();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void error(Throwable e) {\n+\t\t\tdelegateSink.error(e);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic StandaloneFluxSink<T> next(T t) {\n+\t\t\tdelegateSink.next(t);\n+\t\t\treturn this;\n+\t\t}\n+\t}\n+\n+\tstatic final class MonoProcessorSink<T> implements StandaloneMonoSink<T> {\n+\n+\t\tfinal MonoProcessor<T> processor;\n+\t\tboolean done;\n+\n+\t\tMonoProcessorSink(MonoProcessor<T> processor) {\n+\t\t\tthis.processor = processor;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Mono<T> asMono() {\n+\t\t\treturn this.processor;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void success() {\n+\t\t\tsynchronized (processor) {\n+\t\t\t\tif (done) {\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t\tdone = true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyMTg3Nw=="}, "originalCommit": {"oid": "299a170088e47afaa060b550a7d9a4772169af30"}, "originalPosition": 228}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1ODI0OTk4OnYy", "diffSide": "RIGHT", "path": "reactor-core/src/test/java/reactor/core/publisher/SinksTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwOToxMTozN1rOGmNwuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQxNToyNjoyOFrOGmYv4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyNDUzNw==", "bodyText": "Should be destroyed after the test to avoid dangling Threads", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442724537", "createdAt": "2020-06-19T09:11:37Z", "author": {"login": "bsideup"}, "path": "reactor-core/src/test/java/reactor/core/publisher/SinksTest.java", "diffHunk": "@@ -0,0 +1,721 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.awaitility.Awaitility;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+\n+import reactor.test.StepVerifier;\n+import reactor.test.subscriber.AssertSubscriber;\n+import reactor.util.concurrent.Queues;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatCode;\n+\n+/**\n+ * @author Simon Basl\u00e9\n+ */\n+class SinksTest {\n+\n+\t@Nested\n+\tclass MulticastNoWarmup {\n+\n+\t\tprivate Sinks.StandaloneFluxSink<Integer> sink;\n+\t\tprivate Flux<Integer> flux;\n+\n+\t\t@BeforeEach\n+\t\tvoid createInstance() {\n+\t\t\tsink = Sinks.multicastNoWarmup();\n+\t\t\tflux = sink.asFlux();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid fluxViewReturnsSameInstance() {\n+\t\t\tassertThat(flux).isSameAs(sink.asFlux());\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid isAcceptingMoreThatOneSubscriber() {\n+\t\t\tassertThatCode(() -> {\n+\t\t\t\tflux.subscribe();\n+\t\t\t\tflux.subscribe();\n+\t\t\t}).doesNotThrowAnyException();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid honorsMultipleSubscribersBackpressure()\n+\t\t\t\tthrows InterruptedException, ExecutionException {\n+\t\t\tExecutorService es = Executors.newFixedThreadPool(2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "299a170088e47afaa060b550a7d9a4772169af30"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjkwNDU0Ng==", "bodyText": "done in the dynamic test version", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442904546", "createdAt": "2020-06-19T15:26:28Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/test/java/reactor/core/publisher/SinksTest.java", "diffHunk": "@@ -0,0 +1,721 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.awaitility.Awaitility;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+\n+import reactor.test.StepVerifier;\n+import reactor.test.subscriber.AssertSubscriber;\n+import reactor.util.concurrent.Queues;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatCode;\n+\n+/**\n+ * @author Simon Basl\u00e9\n+ */\n+class SinksTest {\n+\n+\t@Nested\n+\tclass MulticastNoWarmup {\n+\n+\t\tprivate Sinks.StandaloneFluxSink<Integer> sink;\n+\t\tprivate Flux<Integer> flux;\n+\n+\t\t@BeforeEach\n+\t\tvoid createInstance() {\n+\t\t\tsink = Sinks.multicastNoWarmup();\n+\t\t\tflux = sink.asFlux();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid fluxViewReturnsSameInstance() {\n+\t\t\tassertThat(flux).isSameAs(sink.asFlux());\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid isAcceptingMoreThatOneSubscriber() {\n+\t\t\tassertThatCode(() -> {\n+\t\t\t\tflux.subscribe();\n+\t\t\t\tflux.subscribe();\n+\t\t\t}).doesNotThrowAnyException();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid honorsMultipleSubscribersBackpressure()\n+\t\t\t\tthrows InterruptedException, ExecutionException {\n+\t\t\tExecutorService es = Executors.newFixedThreadPool(2);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyNDUzNw=="}, "originalCommit": {"oid": "299a170088e47afaa060b550a7d9a4772169af30"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1ODI1NDkzOnYy", "diffSide": "RIGHT", "path": "reactor-core/src/test/java/reactor/core/publisher/SinksTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwOToxMzoxMFrOGmNzrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQxNToyNjoxMVrOGmYvVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyNTI5Mw==", "bodyText": "cleanup is missing", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442725293", "createdAt": "2020-06-19T09:13:10Z", "author": {"login": "bsideup"}, "path": "reactor-core/src/test/java/reactor/core/publisher/SinksTest.java", "diffHunk": "@@ -0,0 +1,721 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.awaitility.Awaitility;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+\n+import reactor.test.StepVerifier;\n+import reactor.test.subscriber.AssertSubscriber;\n+import reactor.util.concurrent.Queues;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatCode;\n+\n+/**\n+ * @author Simon Basl\u00e9\n+ */\n+class SinksTest {\n+\n+\t@Nested\n+\tclass MulticastNoWarmup {\n+\n+\t\tprivate Sinks.StandaloneFluxSink<Integer> sink;\n+\t\tprivate Flux<Integer> flux;\n+\n+\t\t@BeforeEach\n+\t\tvoid createInstance() {\n+\t\t\tsink = Sinks.multicastNoWarmup();\n+\t\t\tflux = sink.asFlux();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid fluxViewReturnsSameInstance() {\n+\t\t\tassertThat(flux).isSameAs(sink.asFlux());\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid isAcceptingMoreThatOneSubscriber() {\n+\t\t\tassertThatCode(() -> {\n+\t\t\t\tflux.subscribe();\n+\t\t\t\tflux.subscribe();\n+\t\t\t}).doesNotThrowAnyException();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid honorsMultipleSubscribersBackpressure()\n+\t\t\t\tthrows InterruptedException, ExecutionException {\n+\t\t\tExecutorService es = Executors.newFixedThreadPool(2);\n+\t\t\tCountDownLatch requestLatch = new CountDownLatch(2);\n+\t\t\tfinal Future<?> f1 = es.submit(() -> {\n+\t\t\t\tAssertSubscriber<Integer> test1 = AssertSubscriber.create(2);\n+\t\t\t\tflux.subscribe(test1);\n+\t\t\t\ttest1.assertNoValues();\n+\t\t\t\trequestLatch.countDown();\n+\n+\t\t\t\ttest1.awaitAndAssertNextValues(1, 2);\n+\t\t\t\ttry {\n+\t\t\t\t\tAwaitility.await().atMost(2, TimeUnit.SECONDS)\n+\t\t\t\t\t          .with().pollDelay(1, TimeUnit.SECONDS)\n+\t\t\t\t\t          .untilAsserted(() -> test1.assertValueCount(2));\n+\t\t\t\t}\n+\t\t\t\tfinally {\n+\t\t\t\t\ttest1.cancel();\n+\t\t\t\t}\n+\t\t\t});\n+\t\t\tfinal Future<?> f2 = es.submit(() -> {\n+\t\t\t\tAssertSubscriber<Integer> test2 = AssertSubscriber.create(1);\n+\t\t\t\tflux.subscribe(test2);\n+\t\t\t\trequestLatch.countDown();\n+\n+\t\t\t\ttest2.awaitAndAssertNextValues(1);\n+\t\t\t\ttry {\n+\t\t\t\t\tAwaitility.await().atMost(2, TimeUnit.SECONDS)\n+\t\t\t\t\t          .with().pollDelay(1, TimeUnit.SECONDS)\n+\t\t\t\t\t          .untilAsserted(() -> test2.assertValueCount(1));\n+\t\t\t\t}\n+\t\t\t\tfinally {\n+\t\t\t\t\ttest2.cancel();\n+\t\t\t\t}\n+\t\t\t});\n+\n+\t\t\trequestLatch.await(1, TimeUnit.SECONDS);\n+\t\t\tsink.next(1)\n+\t\t\t    .next(2)\n+\t\t\t    .next(3)\n+\t\t\t    .next(4)\n+\t\t\t    .complete();\n+\n+\t\t\tf1.get();\n+\t\t\tf2.get();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid doesNotReplayToLateSubscribers() {\n+\t\t\tAssertSubscriber<Integer> s1 = AssertSubscriber.create();\n+\t\t\tAssertSubscriber<Integer> s2 = AssertSubscriber.create();\n+\n+\t\t\tflux.subscribe(s1);\n+\t\t\tsink.next(1).next(2).next(3);\n+\t\t\ts1.assertValues(1, 2, 3);\n+\n+\t\t\tflux.subscribe(s2);\n+\t\t\ts2.assertNoValues().assertNotComplete();\n+\n+\t\t\tsink.complete();\n+\t\t\ts1.assertValueCount(3).assertComplete();\n+\t\t\ts2.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void doesNotBufferBeforeFirstSubscriber() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).next(2).next(3);\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertNoValues().assertNotComplete();\n+\n+\t\t\tsink.complete();\n+\t\t\tfirst.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyCompleteFirstSubscriber() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).complete();\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyErrorFirstSubscriber() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).error(new IllegalStateException(\"boom\"));\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertNoValues().assertErrorMessage(\"boom\");\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyCompleteLateSubscriber() {\n+\t\t\tflux.subscribe(); //first subscriber\n+\t\t\tAssertSubscriber<Integer> late = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).complete();\n+\t\t\tflux.subscribe(late);\n+\n+\t\t\tlate.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyErrorLateSubscriber() {\n+\t\t\tflux.onErrorReturn(-1).subscribe(); //first subscriber, ignore errors\n+\t\t\tAssertSubscriber<Integer> late = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).error(new IllegalStateException(\"boom\"));\n+\t\t\tflux.subscribe(late);\n+\n+\t\t\tlate.assertNoValues().assertErrorMessage(\"boom\");\n+\t\t}\n+\t}\n+\n+\t@Nested\n+\tclass Multicast {\n+\n+\t\tprivate Sinks.StandaloneFluxSink<Integer> sink;\n+\t\tprivate Flux<Integer> flux;\n+\n+\t\t@BeforeEach\n+\t\tvoid createInstance() {\n+\t\t\tsink = Sinks.multicast();\n+\t\t\tflux = sink.asFlux();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid fluxViewReturnsSameInstance() {\n+\t\t\tassertThat(flux).isSameAs(sink.asFlux());\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid isAcceptingMoreThatOneSubscriber() {\n+\t\t\tassertThatCode(() -> {\n+\t\t\t\tflux.subscribe();\n+\t\t\t\tflux.subscribe();\n+\t\t\t}).doesNotThrowAnyException();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid honorsMultipleSubscribersBackpressure()\n+\t\t\t\tthrows InterruptedException, ExecutionException {\n+\t\t\tExecutorService es = Executors.newFixedThreadPool(2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "299a170088e47afaa060b550a7d9a4772169af30"}, "originalPosition": 217}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjkwNDQwNA==", "bodyText": "done in the dynamic test version", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442904404", "createdAt": "2020-06-19T15:26:11Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/test/java/reactor/core/publisher/SinksTest.java", "diffHunk": "@@ -0,0 +1,721 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.awaitility.Awaitility;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+\n+import reactor.test.StepVerifier;\n+import reactor.test.subscriber.AssertSubscriber;\n+import reactor.util.concurrent.Queues;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatCode;\n+\n+/**\n+ * @author Simon Basl\u00e9\n+ */\n+class SinksTest {\n+\n+\t@Nested\n+\tclass MulticastNoWarmup {\n+\n+\t\tprivate Sinks.StandaloneFluxSink<Integer> sink;\n+\t\tprivate Flux<Integer> flux;\n+\n+\t\t@BeforeEach\n+\t\tvoid createInstance() {\n+\t\t\tsink = Sinks.multicastNoWarmup();\n+\t\t\tflux = sink.asFlux();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid fluxViewReturnsSameInstance() {\n+\t\t\tassertThat(flux).isSameAs(sink.asFlux());\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid isAcceptingMoreThatOneSubscriber() {\n+\t\t\tassertThatCode(() -> {\n+\t\t\t\tflux.subscribe();\n+\t\t\t\tflux.subscribe();\n+\t\t\t}).doesNotThrowAnyException();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid honorsMultipleSubscribersBackpressure()\n+\t\t\t\tthrows InterruptedException, ExecutionException {\n+\t\t\tExecutorService es = Executors.newFixedThreadPool(2);\n+\t\t\tCountDownLatch requestLatch = new CountDownLatch(2);\n+\t\t\tfinal Future<?> f1 = es.submit(() -> {\n+\t\t\t\tAssertSubscriber<Integer> test1 = AssertSubscriber.create(2);\n+\t\t\t\tflux.subscribe(test1);\n+\t\t\t\ttest1.assertNoValues();\n+\t\t\t\trequestLatch.countDown();\n+\n+\t\t\t\ttest1.awaitAndAssertNextValues(1, 2);\n+\t\t\t\ttry {\n+\t\t\t\t\tAwaitility.await().atMost(2, TimeUnit.SECONDS)\n+\t\t\t\t\t          .with().pollDelay(1, TimeUnit.SECONDS)\n+\t\t\t\t\t          .untilAsserted(() -> test1.assertValueCount(2));\n+\t\t\t\t}\n+\t\t\t\tfinally {\n+\t\t\t\t\ttest1.cancel();\n+\t\t\t\t}\n+\t\t\t});\n+\t\t\tfinal Future<?> f2 = es.submit(() -> {\n+\t\t\t\tAssertSubscriber<Integer> test2 = AssertSubscriber.create(1);\n+\t\t\t\tflux.subscribe(test2);\n+\t\t\t\trequestLatch.countDown();\n+\n+\t\t\t\ttest2.awaitAndAssertNextValues(1);\n+\t\t\t\ttry {\n+\t\t\t\t\tAwaitility.await().atMost(2, TimeUnit.SECONDS)\n+\t\t\t\t\t          .with().pollDelay(1, TimeUnit.SECONDS)\n+\t\t\t\t\t          .untilAsserted(() -> test2.assertValueCount(1));\n+\t\t\t\t}\n+\t\t\t\tfinally {\n+\t\t\t\t\ttest2.cancel();\n+\t\t\t\t}\n+\t\t\t});\n+\n+\t\t\trequestLatch.await(1, TimeUnit.SECONDS);\n+\t\t\tsink.next(1)\n+\t\t\t    .next(2)\n+\t\t\t    .next(3)\n+\t\t\t    .next(4)\n+\t\t\t    .complete();\n+\n+\t\t\tf1.get();\n+\t\t\tf2.get();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid doesNotReplayToLateSubscribers() {\n+\t\t\tAssertSubscriber<Integer> s1 = AssertSubscriber.create();\n+\t\t\tAssertSubscriber<Integer> s2 = AssertSubscriber.create();\n+\n+\t\t\tflux.subscribe(s1);\n+\t\t\tsink.next(1).next(2).next(3);\n+\t\t\ts1.assertValues(1, 2, 3);\n+\n+\t\t\tflux.subscribe(s2);\n+\t\t\ts2.assertNoValues().assertNotComplete();\n+\n+\t\t\tsink.complete();\n+\t\t\ts1.assertValueCount(3).assertComplete();\n+\t\t\ts2.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void doesNotBufferBeforeFirstSubscriber() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).next(2).next(3);\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertNoValues().assertNotComplete();\n+\n+\t\t\tsink.complete();\n+\t\t\tfirst.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyCompleteFirstSubscriber() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).complete();\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyErrorFirstSubscriber() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).error(new IllegalStateException(\"boom\"));\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertNoValues().assertErrorMessage(\"boom\");\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyCompleteLateSubscriber() {\n+\t\t\tflux.subscribe(); //first subscriber\n+\t\t\tAssertSubscriber<Integer> late = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).complete();\n+\t\t\tflux.subscribe(late);\n+\n+\t\t\tlate.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyErrorLateSubscriber() {\n+\t\t\tflux.onErrorReturn(-1).subscribe(); //first subscriber, ignore errors\n+\t\t\tAssertSubscriber<Integer> late = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).error(new IllegalStateException(\"boom\"));\n+\t\t\tflux.subscribe(late);\n+\n+\t\t\tlate.assertNoValues().assertErrorMessage(\"boom\");\n+\t\t}\n+\t}\n+\n+\t@Nested\n+\tclass Multicast {\n+\n+\t\tprivate Sinks.StandaloneFluxSink<Integer> sink;\n+\t\tprivate Flux<Integer> flux;\n+\n+\t\t@BeforeEach\n+\t\tvoid createInstance() {\n+\t\t\tsink = Sinks.multicast();\n+\t\t\tflux = sink.asFlux();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid fluxViewReturnsSameInstance() {\n+\t\t\tassertThat(flux).isSameAs(sink.asFlux());\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid isAcceptingMoreThatOneSubscriber() {\n+\t\t\tassertThatCode(() -> {\n+\t\t\t\tflux.subscribe();\n+\t\t\t\tflux.subscribe();\n+\t\t\t}).doesNotThrowAnyException();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid honorsMultipleSubscribersBackpressure()\n+\t\t\t\tthrows InterruptedException, ExecutionException {\n+\t\t\tExecutorService es = Executors.newFixedThreadPool(2);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyNTI5Mw=="}, "originalCommit": {"oid": "299a170088e47afaa060b550a7d9a4772169af30"}, "originalPosition": 217}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1ODI1NzUwOnYy", "diffSide": "RIGHT", "path": "reactor-core/src/test/java/reactor/core/publisher/SinksTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwOToxNDowOFrOGmN1Vg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQxNToyNjowMlrOGmYvCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyNTcxOA==", "bodyText": "could use an abstract parent class that checks common behaviours like this one", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442725718", "createdAt": "2020-06-19T09:14:08Z", "author": {"login": "bsideup"}, "path": "reactor-core/src/test/java/reactor/core/publisher/SinksTest.java", "diffHunk": "@@ -0,0 +1,721 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.awaitility.Awaitility;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+\n+import reactor.test.StepVerifier;\n+import reactor.test.subscriber.AssertSubscriber;\n+import reactor.util.concurrent.Queues;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatCode;\n+\n+/**\n+ * @author Simon Basl\u00e9\n+ */\n+class SinksTest {\n+\n+\t@Nested\n+\tclass MulticastNoWarmup {\n+\n+\t\tprivate Sinks.StandaloneFluxSink<Integer> sink;\n+\t\tprivate Flux<Integer> flux;\n+\n+\t\t@BeforeEach\n+\t\tvoid createInstance() {\n+\t\t\tsink = Sinks.multicastNoWarmup();\n+\t\t\tflux = sink.asFlux();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid fluxViewReturnsSameInstance() {\n+\t\t\tassertThat(flux).isSameAs(sink.asFlux());\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid isAcceptingMoreThatOneSubscriber() {\n+\t\t\tassertThatCode(() -> {\n+\t\t\t\tflux.subscribe();\n+\t\t\t\tflux.subscribe();\n+\t\t\t}).doesNotThrowAnyException();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid honorsMultipleSubscribersBackpressure()\n+\t\t\t\tthrows InterruptedException, ExecutionException {\n+\t\t\tExecutorService es = Executors.newFixedThreadPool(2);\n+\t\t\tCountDownLatch requestLatch = new CountDownLatch(2);\n+\t\t\tfinal Future<?> f1 = es.submit(() -> {\n+\t\t\t\tAssertSubscriber<Integer> test1 = AssertSubscriber.create(2);\n+\t\t\t\tflux.subscribe(test1);\n+\t\t\t\ttest1.assertNoValues();\n+\t\t\t\trequestLatch.countDown();\n+\n+\t\t\t\ttest1.awaitAndAssertNextValues(1, 2);\n+\t\t\t\ttry {\n+\t\t\t\t\tAwaitility.await().atMost(2, TimeUnit.SECONDS)\n+\t\t\t\t\t          .with().pollDelay(1, TimeUnit.SECONDS)\n+\t\t\t\t\t          .untilAsserted(() -> test1.assertValueCount(2));\n+\t\t\t\t}\n+\t\t\t\tfinally {\n+\t\t\t\t\ttest1.cancel();\n+\t\t\t\t}\n+\t\t\t});\n+\t\t\tfinal Future<?> f2 = es.submit(() -> {\n+\t\t\t\tAssertSubscriber<Integer> test2 = AssertSubscriber.create(1);\n+\t\t\t\tflux.subscribe(test2);\n+\t\t\t\trequestLatch.countDown();\n+\n+\t\t\t\ttest2.awaitAndAssertNextValues(1);\n+\t\t\t\ttry {\n+\t\t\t\t\tAwaitility.await().atMost(2, TimeUnit.SECONDS)\n+\t\t\t\t\t          .with().pollDelay(1, TimeUnit.SECONDS)\n+\t\t\t\t\t          .untilAsserted(() -> test2.assertValueCount(1));\n+\t\t\t\t}\n+\t\t\t\tfinally {\n+\t\t\t\t\ttest2.cancel();\n+\t\t\t\t}\n+\t\t\t});\n+\n+\t\t\trequestLatch.await(1, TimeUnit.SECONDS);\n+\t\t\tsink.next(1)\n+\t\t\t    .next(2)\n+\t\t\t    .next(3)\n+\t\t\t    .next(4)\n+\t\t\t    .complete();\n+\n+\t\t\tf1.get();\n+\t\t\tf2.get();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid doesNotReplayToLateSubscribers() {\n+\t\t\tAssertSubscriber<Integer> s1 = AssertSubscriber.create();\n+\t\t\tAssertSubscriber<Integer> s2 = AssertSubscriber.create();\n+\n+\t\t\tflux.subscribe(s1);\n+\t\t\tsink.next(1).next(2).next(3);\n+\t\t\ts1.assertValues(1, 2, 3);\n+\n+\t\t\tflux.subscribe(s2);\n+\t\t\ts2.assertNoValues().assertNotComplete();\n+\n+\t\t\tsink.complete();\n+\t\t\ts1.assertValueCount(3).assertComplete();\n+\t\t\ts2.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void doesNotBufferBeforeFirstSubscriber() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).next(2).next(3);\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertNoValues().assertNotComplete();\n+\n+\t\t\tsink.complete();\n+\t\t\tfirst.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyCompleteFirstSubscriber() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).complete();\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyErrorFirstSubscriber() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).error(new IllegalStateException(\"boom\"));\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertNoValues().assertErrorMessage(\"boom\");\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyCompleteLateSubscriber() {\n+\t\t\tflux.subscribe(); //first subscriber\n+\t\t\tAssertSubscriber<Integer> late = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).complete();\n+\t\t\tflux.subscribe(late);\n+\n+\t\t\tlate.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyErrorLateSubscriber() {\n+\t\t\tflux.onErrorReturn(-1).subscribe(); //first subscriber, ignore errors\n+\t\t\tAssertSubscriber<Integer> late = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).error(new IllegalStateException(\"boom\"));\n+\t\t\tflux.subscribe(late);\n+\n+\t\t\tlate.assertNoValues().assertErrorMessage(\"boom\");\n+\t\t}\n+\t}\n+\n+\t@Nested\n+\tclass Multicast {\n+\n+\t\tprivate Sinks.StandaloneFluxSink<Integer> sink;\n+\t\tprivate Flux<Integer> flux;\n+\n+\t\t@BeforeEach\n+\t\tvoid createInstance() {\n+\t\t\tsink = Sinks.multicast();\n+\t\t\tflux = sink.asFlux();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid fluxViewReturnsSameInstance() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "299a170088e47afaa060b550a7d9a4772169af30"}, "originalPosition": 202}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjkwNDMzMA==", "bodyText": "done: made a dynamic test generation to express more directly the semantics found in the javadocs", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442904330", "createdAt": "2020-06-19T15:26:02Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/test/java/reactor/core/publisher/SinksTest.java", "diffHunk": "@@ -0,0 +1,721 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.awaitility.Awaitility;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+\n+import reactor.test.StepVerifier;\n+import reactor.test.subscriber.AssertSubscriber;\n+import reactor.util.concurrent.Queues;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatCode;\n+\n+/**\n+ * @author Simon Basl\u00e9\n+ */\n+class SinksTest {\n+\n+\t@Nested\n+\tclass MulticastNoWarmup {\n+\n+\t\tprivate Sinks.StandaloneFluxSink<Integer> sink;\n+\t\tprivate Flux<Integer> flux;\n+\n+\t\t@BeforeEach\n+\t\tvoid createInstance() {\n+\t\t\tsink = Sinks.multicastNoWarmup();\n+\t\t\tflux = sink.asFlux();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid fluxViewReturnsSameInstance() {\n+\t\t\tassertThat(flux).isSameAs(sink.asFlux());\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid isAcceptingMoreThatOneSubscriber() {\n+\t\t\tassertThatCode(() -> {\n+\t\t\t\tflux.subscribe();\n+\t\t\t\tflux.subscribe();\n+\t\t\t}).doesNotThrowAnyException();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid honorsMultipleSubscribersBackpressure()\n+\t\t\t\tthrows InterruptedException, ExecutionException {\n+\t\t\tExecutorService es = Executors.newFixedThreadPool(2);\n+\t\t\tCountDownLatch requestLatch = new CountDownLatch(2);\n+\t\t\tfinal Future<?> f1 = es.submit(() -> {\n+\t\t\t\tAssertSubscriber<Integer> test1 = AssertSubscriber.create(2);\n+\t\t\t\tflux.subscribe(test1);\n+\t\t\t\ttest1.assertNoValues();\n+\t\t\t\trequestLatch.countDown();\n+\n+\t\t\t\ttest1.awaitAndAssertNextValues(1, 2);\n+\t\t\t\ttry {\n+\t\t\t\t\tAwaitility.await().atMost(2, TimeUnit.SECONDS)\n+\t\t\t\t\t          .with().pollDelay(1, TimeUnit.SECONDS)\n+\t\t\t\t\t          .untilAsserted(() -> test1.assertValueCount(2));\n+\t\t\t\t}\n+\t\t\t\tfinally {\n+\t\t\t\t\ttest1.cancel();\n+\t\t\t\t}\n+\t\t\t});\n+\t\t\tfinal Future<?> f2 = es.submit(() -> {\n+\t\t\t\tAssertSubscriber<Integer> test2 = AssertSubscriber.create(1);\n+\t\t\t\tflux.subscribe(test2);\n+\t\t\t\trequestLatch.countDown();\n+\n+\t\t\t\ttest2.awaitAndAssertNextValues(1);\n+\t\t\t\ttry {\n+\t\t\t\t\tAwaitility.await().atMost(2, TimeUnit.SECONDS)\n+\t\t\t\t\t          .with().pollDelay(1, TimeUnit.SECONDS)\n+\t\t\t\t\t          .untilAsserted(() -> test2.assertValueCount(1));\n+\t\t\t\t}\n+\t\t\t\tfinally {\n+\t\t\t\t\ttest2.cancel();\n+\t\t\t\t}\n+\t\t\t});\n+\n+\t\t\trequestLatch.await(1, TimeUnit.SECONDS);\n+\t\t\tsink.next(1)\n+\t\t\t    .next(2)\n+\t\t\t    .next(3)\n+\t\t\t    .next(4)\n+\t\t\t    .complete();\n+\n+\t\t\tf1.get();\n+\t\t\tf2.get();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid doesNotReplayToLateSubscribers() {\n+\t\t\tAssertSubscriber<Integer> s1 = AssertSubscriber.create();\n+\t\t\tAssertSubscriber<Integer> s2 = AssertSubscriber.create();\n+\n+\t\t\tflux.subscribe(s1);\n+\t\t\tsink.next(1).next(2).next(3);\n+\t\t\ts1.assertValues(1, 2, 3);\n+\n+\t\t\tflux.subscribe(s2);\n+\t\t\ts2.assertNoValues().assertNotComplete();\n+\n+\t\t\tsink.complete();\n+\t\t\ts1.assertValueCount(3).assertComplete();\n+\t\t\ts2.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void doesNotBufferBeforeFirstSubscriber() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).next(2).next(3);\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertNoValues().assertNotComplete();\n+\n+\t\t\tsink.complete();\n+\t\t\tfirst.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyCompleteFirstSubscriber() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).complete();\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyErrorFirstSubscriber() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).error(new IllegalStateException(\"boom\"));\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertNoValues().assertErrorMessage(\"boom\");\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyCompleteLateSubscriber() {\n+\t\t\tflux.subscribe(); //first subscriber\n+\t\t\tAssertSubscriber<Integer> late = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).complete();\n+\t\t\tflux.subscribe(late);\n+\n+\t\t\tlate.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyErrorLateSubscriber() {\n+\t\t\tflux.onErrorReturn(-1).subscribe(); //first subscriber, ignore errors\n+\t\t\tAssertSubscriber<Integer> late = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).error(new IllegalStateException(\"boom\"));\n+\t\t\tflux.subscribe(late);\n+\n+\t\t\tlate.assertNoValues().assertErrorMessage(\"boom\");\n+\t\t}\n+\t}\n+\n+\t@Nested\n+\tclass Multicast {\n+\n+\t\tprivate Sinks.StandaloneFluxSink<Integer> sink;\n+\t\tprivate Flux<Integer> flux;\n+\n+\t\t@BeforeEach\n+\t\tvoid createInstance() {\n+\t\t\tsink = Sinks.multicast();\n+\t\t\tflux = sink.asFlux();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid fluxViewReturnsSameInstance() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyNTcxOA=="}, "originalCommit": {"oid": "299a170088e47afaa060b550a7d9a4772169af30"}, "originalPosition": 202}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1ODI2MTQwOnYy", "diffSide": "RIGHT", "path": "reactor-core/src/test/java/reactor/core/publisher/SinksTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwOToxNToyMlrOGmN3uQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQxNToyNDo0M1rOGmYsIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyNjMyOQ==", "bodyText": "Probably not. Especially if onErrorResume is used on the returning Flux", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442726329", "createdAt": "2020-06-19T09:15:22Z", "author": {"login": "bsideup"}, "path": "reactor-core/src/test/java/reactor/core/publisher/SinksTest.java", "diffHunk": "@@ -0,0 +1,721 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.awaitility.Awaitility;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+\n+import reactor.test.StepVerifier;\n+import reactor.test.subscriber.AssertSubscriber;\n+import reactor.util.concurrent.Queues;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatCode;\n+\n+/**\n+ * @author Simon Basl\u00e9\n+ */\n+class SinksTest {\n+\n+\t@Nested\n+\tclass MulticastNoWarmup {\n+\n+\t\tprivate Sinks.StandaloneFluxSink<Integer> sink;\n+\t\tprivate Flux<Integer> flux;\n+\n+\t\t@BeforeEach\n+\t\tvoid createInstance() {\n+\t\t\tsink = Sinks.multicastNoWarmup();\n+\t\t\tflux = sink.asFlux();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid fluxViewReturnsSameInstance() {\n+\t\t\tassertThat(flux).isSameAs(sink.asFlux());\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid isAcceptingMoreThatOneSubscriber() {\n+\t\t\tassertThatCode(() -> {\n+\t\t\t\tflux.subscribe();\n+\t\t\t\tflux.subscribe();\n+\t\t\t}).doesNotThrowAnyException();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid honorsMultipleSubscribersBackpressure()\n+\t\t\t\tthrows InterruptedException, ExecutionException {\n+\t\t\tExecutorService es = Executors.newFixedThreadPool(2);\n+\t\t\tCountDownLatch requestLatch = new CountDownLatch(2);\n+\t\t\tfinal Future<?> f1 = es.submit(() -> {\n+\t\t\t\tAssertSubscriber<Integer> test1 = AssertSubscriber.create(2);\n+\t\t\t\tflux.subscribe(test1);\n+\t\t\t\ttest1.assertNoValues();\n+\t\t\t\trequestLatch.countDown();\n+\n+\t\t\t\ttest1.awaitAndAssertNextValues(1, 2);\n+\t\t\t\ttry {\n+\t\t\t\t\tAwaitility.await().atMost(2, TimeUnit.SECONDS)\n+\t\t\t\t\t          .with().pollDelay(1, TimeUnit.SECONDS)\n+\t\t\t\t\t          .untilAsserted(() -> test1.assertValueCount(2));\n+\t\t\t\t}\n+\t\t\t\tfinally {\n+\t\t\t\t\ttest1.cancel();\n+\t\t\t\t}\n+\t\t\t});\n+\t\t\tfinal Future<?> f2 = es.submit(() -> {\n+\t\t\t\tAssertSubscriber<Integer> test2 = AssertSubscriber.create(1);\n+\t\t\t\tflux.subscribe(test2);\n+\t\t\t\trequestLatch.countDown();\n+\n+\t\t\t\ttest2.awaitAndAssertNextValues(1);\n+\t\t\t\ttry {\n+\t\t\t\t\tAwaitility.await().atMost(2, TimeUnit.SECONDS)\n+\t\t\t\t\t          .with().pollDelay(1, TimeUnit.SECONDS)\n+\t\t\t\t\t          .untilAsserted(() -> test2.assertValueCount(1));\n+\t\t\t\t}\n+\t\t\t\tfinally {\n+\t\t\t\t\ttest2.cancel();\n+\t\t\t\t}\n+\t\t\t});\n+\n+\t\t\trequestLatch.await(1, TimeUnit.SECONDS);\n+\t\t\tsink.next(1)\n+\t\t\t    .next(2)\n+\t\t\t    .next(3)\n+\t\t\t    .next(4)\n+\t\t\t    .complete();\n+\n+\t\t\tf1.get();\n+\t\t\tf2.get();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid doesNotReplayToLateSubscribers() {\n+\t\t\tAssertSubscriber<Integer> s1 = AssertSubscriber.create();\n+\t\t\tAssertSubscriber<Integer> s2 = AssertSubscriber.create();\n+\n+\t\t\tflux.subscribe(s1);\n+\t\t\tsink.next(1).next(2).next(3);\n+\t\t\ts1.assertValues(1, 2, 3);\n+\n+\t\t\tflux.subscribe(s2);\n+\t\t\ts2.assertNoValues().assertNotComplete();\n+\n+\t\t\tsink.complete();\n+\t\t\ts1.assertValueCount(3).assertComplete();\n+\t\t\ts2.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void doesNotBufferBeforeFirstSubscriber() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).next(2).next(3);\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertNoValues().assertNotComplete();\n+\n+\t\t\tsink.complete();\n+\t\t\tfirst.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyCompleteFirstSubscriber() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).complete();\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyErrorFirstSubscriber() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).error(new IllegalStateException(\"boom\"));\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertNoValues().assertErrorMessage(\"boom\");\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyCompleteLateSubscriber() {\n+\t\t\tflux.subscribe(); //first subscriber\n+\t\t\tAssertSubscriber<Integer> late = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).complete();\n+\t\t\tflux.subscribe(late);\n+\n+\t\t\tlate.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyErrorLateSubscriber() {\n+\t\t\tflux.onErrorReturn(-1).subscribe(); //first subscriber, ignore errors\n+\t\t\tAssertSubscriber<Integer> late = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).error(new IllegalStateException(\"boom\"));\n+\t\t\tflux.subscribe(late);\n+\n+\t\t\tlate.assertNoValues().assertErrorMessage(\"boom\");\n+\t\t}\n+\t}\n+\n+\t@Nested\n+\tclass Multicast {\n+\n+\t\tprivate Sinks.StandaloneFluxSink<Integer> sink;\n+\t\tprivate Flux<Integer> flux;\n+\n+\t\t@BeforeEach\n+\t\tvoid createInstance() {\n+\t\t\tsink = Sinks.multicast();\n+\t\t\tflux = sink.asFlux();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid fluxViewReturnsSameInstance() {\n+\t\t\tassertThat(flux).isSameAs(sink.asFlux());\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid isAcceptingMoreThatOneSubscriber() {\n+\t\t\tassertThatCode(() -> {\n+\t\t\t\tflux.subscribe();\n+\t\t\t\tflux.subscribe();\n+\t\t\t}).doesNotThrowAnyException();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid honorsMultipleSubscribersBackpressure()\n+\t\t\t\tthrows InterruptedException, ExecutionException {\n+\t\t\tExecutorService es = Executors.newFixedThreadPool(2);\n+\t\t\tCountDownLatch requestLatch = new CountDownLatch(2);\n+\t\t\tfinal Future<?> f1 = es.submit(() -> {\n+\t\t\t\tAssertSubscriber<Integer> test1 = AssertSubscriber.create(2);\n+\t\t\t\tflux.subscribe(test1);\n+\t\t\t\ttest1.assertNoValues();\n+\t\t\t\trequestLatch.countDown();\n+\n+\t\t\t\ttest1.awaitAndAssertNextValues(1, 2);\n+\t\t\t\ttry {\n+\t\t\t\t\tAwaitility.await().atMost(2, TimeUnit.SECONDS)\n+\t\t\t\t\t          .with().pollDelay(1, TimeUnit.SECONDS)\n+\t\t\t\t\t          .untilAsserted(() -> test1.assertValueCount(2));\n+\t\t\t\t}\n+\t\t\t\tfinally {\n+\t\t\t\t\ttest1.cancel();\n+\t\t\t\t}\n+\t\t\t});\n+\t\t\tfinal Future<?> f2 = es.submit(() -> {\n+\t\t\t\tAssertSubscriber<Integer> test2 = AssertSubscriber.create(1);\n+\t\t\t\tflux.subscribe(test2);\n+\t\t\t\trequestLatch.countDown();\n+\n+\t\t\t\ttest2.awaitAndAssertNextValues(1);\n+\t\t\t\ttry {\n+\t\t\t\t\tAwaitility.await().atMost(2, TimeUnit.SECONDS)\n+\t\t\t\t\t          .with().pollDelay(1, TimeUnit.SECONDS)\n+\t\t\t\t\t          .untilAsserted(() -> test2.assertValueCount(1));\n+\t\t\t\t}\n+\t\t\t\tfinally {\n+\t\t\t\t\ttest2.cancel();\n+\t\t\t\t}\n+\t\t\t});\n+\n+\t\t\trequestLatch.await(1, TimeUnit.SECONDS);\n+\t\t\tsink.next(1)\n+\t\t\t    .next(2)\n+\t\t\t    .next(3)\n+\t\t\t    .next(4)\n+\t\t\t    .complete();\n+\n+\t\t\tf1.get();\n+\t\t\tf2.get();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid doesNotReplayToLateSubscribers() {\n+\t\t\tAssertSubscriber<Integer> s1 = AssertSubscriber.create();\n+\t\t\tAssertSubscriber<Integer> s2 = AssertSubscriber.create();\n+\n+\t\t\tflux.subscribe(s1);\n+\t\t\tsink.next(1).next(2).next(3);\n+\t\t\ts1.assertValues(1, 2, 3);\n+\n+\t\t\tflux.subscribe(s2);\n+\t\t\ts2.assertNoValues().assertNotComplete();\n+\n+\t\t\tsink.complete();\n+\t\t\ts1.assertValueCount(3).assertComplete();\n+\t\t\ts2.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void doesBufferBeforeFirstSubscriber() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).next(2).next(3);\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertValues(1, 2, 3).assertNotComplete();\n+\n+\t\t\tsink.complete();\n+\t\t\tfirst.assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void replayAndCompleteFirstSubscriber() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).complete();\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertValues(1).assertComplete();\n+\t\t}\n+\n+\t\t@Test //TODO is that acceptable that EmitterProcessor doesn't replay in case of errors?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "299a170088e47afaa060b550a7d9a4772169af30"}, "originalPosition": 302}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjkwMzU4Nw==", "bodyText": "isolated that in the test a bit more, will have to decide what to do by GA", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442903587", "createdAt": "2020-06-19T15:24:43Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/test/java/reactor/core/publisher/SinksTest.java", "diffHunk": "@@ -0,0 +1,721 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.awaitility.Awaitility;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+\n+import reactor.test.StepVerifier;\n+import reactor.test.subscriber.AssertSubscriber;\n+import reactor.util.concurrent.Queues;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatCode;\n+\n+/**\n+ * @author Simon Basl\u00e9\n+ */\n+class SinksTest {\n+\n+\t@Nested\n+\tclass MulticastNoWarmup {\n+\n+\t\tprivate Sinks.StandaloneFluxSink<Integer> sink;\n+\t\tprivate Flux<Integer> flux;\n+\n+\t\t@BeforeEach\n+\t\tvoid createInstance() {\n+\t\t\tsink = Sinks.multicastNoWarmup();\n+\t\t\tflux = sink.asFlux();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid fluxViewReturnsSameInstance() {\n+\t\t\tassertThat(flux).isSameAs(sink.asFlux());\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid isAcceptingMoreThatOneSubscriber() {\n+\t\t\tassertThatCode(() -> {\n+\t\t\t\tflux.subscribe();\n+\t\t\t\tflux.subscribe();\n+\t\t\t}).doesNotThrowAnyException();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid honorsMultipleSubscribersBackpressure()\n+\t\t\t\tthrows InterruptedException, ExecutionException {\n+\t\t\tExecutorService es = Executors.newFixedThreadPool(2);\n+\t\t\tCountDownLatch requestLatch = new CountDownLatch(2);\n+\t\t\tfinal Future<?> f1 = es.submit(() -> {\n+\t\t\t\tAssertSubscriber<Integer> test1 = AssertSubscriber.create(2);\n+\t\t\t\tflux.subscribe(test1);\n+\t\t\t\ttest1.assertNoValues();\n+\t\t\t\trequestLatch.countDown();\n+\n+\t\t\t\ttest1.awaitAndAssertNextValues(1, 2);\n+\t\t\t\ttry {\n+\t\t\t\t\tAwaitility.await().atMost(2, TimeUnit.SECONDS)\n+\t\t\t\t\t          .with().pollDelay(1, TimeUnit.SECONDS)\n+\t\t\t\t\t          .untilAsserted(() -> test1.assertValueCount(2));\n+\t\t\t\t}\n+\t\t\t\tfinally {\n+\t\t\t\t\ttest1.cancel();\n+\t\t\t\t}\n+\t\t\t});\n+\t\t\tfinal Future<?> f2 = es.submit(() -> {\n+\t\t\t\tAssertSubscriber<Integer> test2 = AssertSubscriber.create(1);\n+\t\t\t\tflux.subscribe(test2);\n+\t\t\t\trequestLatch.countDown();\n+\n+\t\t\t\ttest2.awaitAndAssertNextValues(1);\n+\t\t\t\ttry {\n+\t\t\t\t\tAwaitility.await().atMost(2, TimeUnit.SECONDS)\n+\t\t\t\t\t          .with().pollDelay(1, TimeUnit.SECONDS)\n+\t\t\t\t\t          .untilAsserted(() -> test2.assertValueCount(1));\n+\t\t\t\t}\n+\t\t\t\tfinally {\n+\t\t\t\t\ttest2.cancel();\n+\t\t\t\t}\n+\t\t\t});\n+\n+\t\t\trequestLatch.await(1, TimeUnit.SECONDS);\n+\t\t\tsink.next(1)\n+\t\t\t    .next(2)\n+\t\t\t    .next(3)\n+\t\t\t    .next(4)\n+\t\t\t    .complete();\n+\n+\t\t\tf1.get();\n+\t\t\tf2.get();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid doesNotReplayToLateSubscribers() {\n+\t\t\tAssertSubscriber<Integer> s1 = AssertSubscriber.create();\n+\t\t\tAssertSubscriber<Integer> s2 = AssertSubscriber.create();\n+\n+\t\t\tflux.subscribe(s1);\n+\t\t\tsink.next(1).next(2).next(3);\n+\t\t\ts1.assertValues(1, 2, 3);\n+\n+\t\t\tflux.subscribe(s2);\n+\t\t\ts2.assertNoValues().assertNotComplete();\n+\n+\t\t\tsink.complete();\n+\t\t\ts1.assertValueCount(3).assertComplete();\n+\t\t\ts2.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void doesNotBufferBeforeFirstSubscriber() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).next(2).next(3);\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertNoValues().assertNotComplete();\n+\n+\t\t\tsink.complete();\n+\t\t\tfirst.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyCompleteFirstSubscriber() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).complete();\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyErrorFirstSubscriber() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).error(new IllegalStateException(\"boom\"));\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertNoValues().assertErrorMessage(\"boom\");\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyCompleteLateSubscriber() {\n+\t\t\tflux.subscribe(); //first subscriber\n+\t\t\tAssertSubscriber<Integer> late = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).complete();\n+\t\t\tflux.subscribe(late);\n+\n+\t\t\tlate.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyErrorLateSubscriber() {\n+\t\t\tflux.onErrorReturn(-1).subscribe(); //first subscriber, ignore errors\n+\t\t\tAssertSubscriber<Integer> late = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).error(new IllegalStateException(\"boom\"));\n+\t\t\tflux.subscribe(late);\n+\n+\t\t\tlate.assertNoValues().assertErrorMessage(\"boom\");\n+\t\t}\n+\t}\n+\n+\t@Nested\n+\tclass Multicast {\n+\n+\t\tprivate Sinks.StandaloneFluxSink<Integer> sink;\n+\t\tprivate Flux<Integer> flux;\n+\n+\t\t@BeforeEach\n+\t\tvoid createInstance() {\n+\t\t\tsink = Sinks.multicast();\n+\t\t\tflux = sink.asFlux();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid fluxViewReturnsSameInstance() {\n+\t\t\tassertThat(flux).isSameAs(sink.asFlux());\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid isAcceptingMoreThatOneSubscriber() {\n+\t\t\tassertThatCode(() -> {\n+\t\t\t\tflux.subscribe();\n+\t\t\t\tflux.subscribe();\n+\t\t\t}).doesNotThrowAnyException();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid honorsMultipleSubscribersBackpressure()\n+\t\t\t\tthrows InterruptedException, ExecutionException {\n+\t\t\tExecutorService es = Executors.newFixedThreadPool(2);\n+\t\t\tCountDownLatch requestLatch = new CountDownLatch(2);\n+\t\t\tfinal Future<?> f1 = es.submit(() -> {\n+\t\t\t\tAssertSubscriber<Integer> test1 = AssertSubscriber.create(2);\n+\t\t\t\tflux.subscribe(test1);\n+\t\t\t\ttest1.assertNoValues();\n+\t\t\t\trequestLatch.countDown();\n+\n+\t\t\t\ttest1.awaitAndAssertNextValues(1, 2);\n+\t\t\t\ttry {\n+\t\t\t\t\tAwaitility.await().atMost(2, TimeUnit.SECONDS)\n+\t\t\t\t\t          .with().pollDelay(1, TimeUnit.SECONDS)\n+\t\t\t\t\t          .untilAsserted(() -> test1.assertValueCount(2));\n+\t\t\t\t}\n+\t\t\t\tfinally {\n+\t\t\t\t\ttest1.cancel();\n+\t\t\t\t}\n+\t\t\t});\n+\t\t\tfinal Future<?> f2 = es.submit(() -> {\n+\t\t\t\tAssertSubscriber<Integer> test2 = AssertSubscriber.create(1);\n+\t\t\t\tflux.subscribe(test2);\n+\t\t\t\trequestLatch.countDown();\n+\n+\t\t\t\ttest2.awaitAndAssertNextValues(1);\n+\t\t\t\ttry {\n+\t\t\t\t\tAwaitility.await().atMost(2, TimeUnit.SECONDS)\n+\t\t\t\t\t          .with().pollDelay(1, TimeUnit.SECONDS)\n+\t\t\t\t\t          .untilAsserted(() -> test2.assertValueCount(1));\n+\t\t\t\t}\n+\t\t\t\tfinally {\n+\t\t\t\t\ttest2.cancel();\n+\t\t\t\t}\n+\t\t\t});\n+\n+\t\t\trequestLatch.await(1, TimeUnit.SECONDS);\n+\t\t\tsink.next(1)\n+\t\t\t    .next(2)\n+\t\t\t    .next(3)\n+\t\t\t    .next(4)\n+\t\t\t    .complete();\n+\n+\t\t\tf1.get();\n+\t\t\tf2.get();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid doesNotReplayToLateSubscribers() {\n+\t\t\tAssertSubscriber<Integer> s1 = AssertSubscriber.create();\n+\t\t\tAssertSubscriber<Integer> s2 = AssertSubscriber.create();\n+\n+\t\t\tflux.subscribe(s1);\n+\t\t\tsink.next(1).next(2).next(3);\n+\t\t\ts1.assertValues(1, 2, 3);\n+\n+\t\t\tflux.subscribe(s2);\n+\t\t\ts2.assertNoValues().assertNotComplete();\n+\n+\t\t\tsink.complete();\n+\t\t\ts1.assertValueCount(3).assertComplete();\n+\t\t\ts2.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void doesBufferBeforeFirstSubscriber() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).next(2).next(3);\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertValues(1, 2, 3).assertNotComplete();\n+\n+\t\t\tsink.complete();\n+\t\t\tfirst.assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void replayAndCompleteFirstSubscriber() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).complete();\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertValues(1).assertComplete();\n+\t\t}\n+\n+\t\t@Test //TODO is that acceptable that EmitterProcessor doesn't replay in case of errors?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyNjMyOQ=="}, "originalCommit": {"oid": "299a170088e47afaa060b550a7d9a4772169af30"}, "originalPosition": 302}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1ODI2ODUwOnYy", "diffSide": "RIGHT", "path": "reactor-core/src/test/java/reactor/core/publisher/SinksTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwOToxNzo1NlrOGmN8VA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQxNToyNToxNFrOGmYtTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyNzUwOA==", "bodyText": "ditto (the cleanup)", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442727508", "createdAt": "2020-06-19T09:17:56Z", "author": {"login": "bsideup"}, "path": "reactor-core/src/test/java/reactor/core/publisher/SinksTest.java", "diffHunk": "@@ -0,0 +1,721 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.awaitility.Awaitility;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+\n+import reactor.test.StepVerifier;\n+import reactor.test.subscriber.AssertSubscriber;\n+import reactor.util.concurrent.Queues;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatCode;\n+\n+/**\n+ * @author Simon Basl\u00e9\n+ */\n+class SinksTest {\n+\n+\t@Nested\n+\tclass MulticastNoWarmup {\n+\n+\t\tprivate Sinks.StandaloneFluxSink<Integer> sink;\n+\t\tprivate Flux<Integer> flux;\n+\n+\t\t@BeforeEach\n+\t\tvoid createInstance() {\n+\t\t\tsink = Sinks.multicastNoWarmup();\n+\t\t\tflux = sink.asFlux();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid fluxViewReturnsSameInstance() {\n+\t\t\tassertThat(flux).isSameAs(sink.asFlux());\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid isAcceptingMoreThatOneSubscriber() {\n+\t\t\tassertThatCode(() -> {\n+\t\t\t\tflux.subscribe();\n+\t\t\t\tflux.subscribe();\n+\t\t\t}).doesNotThrowAnyException();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid honorsMultipleSubscribersBackpressure()\n+\t\t\t\tthrows InterruptedException, ExecutionException {\n+\t\t\tExecutorService es = Executors.newFixedThreadPool(2);\n+\t\t\tCountDownLatch requestLatch = new CountDownLatch(2);\n+\t\t\tfinal Future<?> f1 = es.submit(() -> {\n+\t\t\t\tAssertSubscriber<Integer> test1 = AssertSubscriber.create(2);\n+\t\t\t\tflux.subscribe(test1);\n+\t\t\t\ttest1.assertNoValues();\n+\t\t\t\trequestLatch.countDown();\n+\n+\t\t\t\ttest1.awaitAndAssertNextValues(1, 2);\n+\t\t\t\ttry {\n+\t\t\t\t\tAwaitility.await().atMost(2, TimeUnit.SECONDS)\n+\t\t\t\t\t          .with().pollDelay(1, TimeUnit.SECONDS)\n+\t\t\t\t\t          .untilAsserted(() -> test1.assertValueCount(2));\n+\t\t\t\t}\n+\t\t\t\tfinally {\n+\t\t\t\t\ttest1.cancel();\n+\t\t\t\t}\n+\t\t\t});\n+\t\t\tfinal Future<?> f2 = es.submit(() -> {\n+\t\t\t\tAssertSubscriber<Integer> test2 = AssertSubscriber.create(1);\n+\t\t\t\tflux.subscribe(test2);\n+\t\t\t\trequestLatch.countDown();\n+\n+\t\t\t\ttest2.awaitAndAssertNextValues(1);\n+\t\t\t\ttry {\n+\t\t\t\t\tAwaitility.await().atMost(2, TimeUnit.SECONDS)\n+\t\t\t\t\t          .with().pollDelay(1, TimeUnit.SECONDS)\n+\t\t\t\t\t          .untilAsserted(() -> test2.assertValueCount(1));\n+\t\t\t\t}\n+\t\t\t\tfinally {\n+\t\t\t\t\ttest2.cancel();\n+\t\t\t\t}\n+\t\t\t});\n+\n+\t\t\trequestLatch.await(1, TimeUnit.SECONDS);\n+\t\t\tsink.next(1)\n+\t\t\t    .next(2)\n+\t\t\t    .next(3)\n+\t\t\t    .next(4)\n+\t\t\t    .complete();\n+\n+\t\t\tf1.get();\n+\t\t\tf2.get();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid doesNotReplayToLateSubscribers() {\n+\t\t\tAssertSubscriber<Integer> s1 = AssertSubscriber.create();\n+\t\t\tAssertSubscriber<Integer> s2 = AssertSubscriber.create();\n+\n+\t\t\tflux.subscribe(s1);\n+\t\t\tsink.next(1).next(2).next(3);\n+\t\t\ts1.assertValues(1, 2, 3);\n+\n+\t\t\tflux.subscribe(s2);\n+\t\t\ts2.assertNoValues().assertNotComplete();\n+\n+\t\t\tsink.complete();\n+\t\t\ts1.assertValueCount(3).assertComplete();\n+\t\t\ts2.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void doesNotBufferBeforeFirstSubscriber() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).next(2).next(3);\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertNoValues().assertNotComplete();\n+\n+\t\t\tsink.complete();\n+\t\t\tfirst.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyCompleteFirstSubscriber() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).complete();\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyErrorFirstSubscriber() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).error(new IllegalStateException(\"boom\"));\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertNoValues().assertErrorMessage(\"boom\");\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyCompleteLateSubscriber() {\n+\t\t\tflux.subscribe(); //first subscriber\n+\t\t\tAssertSubscriber<Integer> late = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).complete();\n+\t\t\tflux.subscribe(late);\n+\n+\t\t\tlate.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyErrorLateSubscriber() {\n+\t\t\tflux.onErrorReturn(-1).subscribe(); //first subscriber, ignore errors\n+\t\t\tAssertSubscriber<Integer> late = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).error(new IllegalStateException(\"boom\"));\n+\t\t\tflux.subscribe(late);\n+\n+\t\t\tlate.assertNoValues().assertErrorMessage(\"boom\");\n+\t\t}\n+\t}\n+\n+\t@Nested\n+\tclass Multicast {\n+\n+\t\tprivate Sinks.StandaloneFluxSink<Integer> sink;\n+\t\tprivate Flux<Integer> flux;\n+\n+\t\t@BeforeEach\n+\t\tvoid createInstance() {\n+\t\t\tsink = Sinks.multicast();\n+\t\t\tflux = sink.asFlux();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid fluxViewReturnsSameInstance() {\n+\t\t\tassertThat(flux).isSameAs(sink.asFlux());\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid isAcceptingMoreThatOneSubscriber() {\n+\t\t\tassertThatCode(() -> {\n+\t\t\t\tflux.subscribe();\n+\t\t\t\tflux.subscribe();\n+\t\t\t}).doesNotThrowAnyException();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid honorsMultipleSubscribersBackpressure()\n+\t\t\t\tthrows InterruptedException, ExecutionException {\n+\t\t\tExecutorService es = Executors.newFixedThreadPool(2);\n+\t\t\tCountDownLatch requestLatch = new CountDownLatch(2);\n+\t\t\tfinal Future<?> f1 = es.submit(() -> {\n+\t\t\t\tAssertSubscriber<Integer> test1 = AssertSubscriber.create(2);\n+\t\t\t\tflux.subscribe(test1);\n+\t\t\t\ttest1.assertNoValues();\n+\t\t\t\trequestLatch.countDown();\n+\n+\t\t\t\ttest1.awaitAndAssertNextValues(1, 2);\n+\t\t\t\ttry {\n+\t\t\t\t\tAwaitility.await().atMost(2, TimeUnit.SECONDS)\n+\t\t\t\t\t          .with().pollDelay(1, TimeUnit.SECONDS)\n+\t\t\t\t\t          .untilAsserted(() -> test1.assertValueCount(2));\n+\t\t\t\t}\n+\t\t\t\tfinally {\n+\t\t\t\t\ttest1.cancel();\n+\t\t\t\t}\n+\t\t\t});\n+\t\t\tfinal Future<?> f2 = es.submit(() -> {\n+\t\t\t\tAssertSubscriber<Integer> test2 = AssertSubscriber.create(1);\n+\t\t\t\tflux.subscribe(test2);\n+\t\t\t\trequestLatch.countDown();\n+\n+\t\t\t\ttest2.awaitAndAssertNextValues(1);\n+\t\t\t\ttry {\n+\t\t\t\t\tAwaitility.await().atMost(2, TimeUnit.SECONDS)\n+\t\t\t\t\t          .with().pollDelay(1, TimeUnit.SECONDS)\n+\t\t\t\t\t          .untilAsserted(() -> test2.assertValueCount(1));\n+\t\t\t\t}\n+\t\t\t\tfinally {\n+\t\t\t\t\ttest2.cancel();\n+\t\t\t\t}\n+\t\t\t});\n+\n+\t\t\trequestLatch.await(1, TimeUnit.SECONDS);\n+\t\t\tsink.next(1)\n+\t\t\t    .next(2)\n+\t\t\t    .next(3)\n+\t\t\t    .next(4)\n+\t\t\t    .complete();\n+\n+\t\t\tf1.get();\n+\t\t\tf2.get();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid doesNotReplayToLateSubscribers() {\n+\t\t\tAssertSubscriber<Integer> s1 = AssertSubscriber.create();\n+\t\t\tAssertSubscriber<Integer> s2 = AssertSubscriber.create();\n+\n+\t\t\tflux.subscribe(s1);\n+\t\t\tsink.next(1).next(2).next(3);\n+\t\t\ts1.assertValues(1, 2, 3);\n+\n+\t\t\tflux.subscribe(s2);\n+\t\t\ts2.assertNoValues().assertNotComplete();\n+\n+\t\t\tsink.complete();\n+\t\t\ts1.assertValueCount(3).assertComplete();\n+\t\t\ts2.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void doesBufferBeforeFirstSubscriber() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).next(2).next(3);\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertValues(1, 2, 3).assertNotComplete();\n+\n+\t\t\tsink.complete();\n+\t\t\tfirst.assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void replayAndCompleteFirstSubscriber() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).complete();\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertValues(1).assertComplete();\n+\t\t}\n+\n+\t\t@Test //TODO is that acceptable that EmitterProcessor doesn't replay in case of errors?\n+\t\tpublic void noReplayBeforeFirstSubscriberIfEarlyError() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).next(2).next(3).error(new IllegalStateException(\"boom\"));\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertNoValues().assertErrorMessage(\"boom\");\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyCompleteLateSubscriber() {\n+\t\t\tflux.subscribe(); //first subscriber\n+\t\t\tAssertSubscriber<Integer> late = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).complete();\n+\t\t\tflux.subscribe(late);\n+\n+\t\t\tlate.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyErrorLateSubscriber() {\n+\t\t\tflux.onErrorReturn(-1).subscribe(); //first subscriber, ignore errors\n+\t\t\tAssertSubscriber<Integer> late = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).error(new IllegalStateException(\"boom\"));\n+\t\t\tflux.subscribe(late);\n+\n+\t\t\tlate.assertNoValues().assertErrorMessage(\"boom\");\n+\t\t}\n+\t}\n+\n+\t@Nested\n+\tclass MulticastReplayAll {\n+\n+\t\tprivate Sinks.StandaloneFluxSink<Integer> sink;\n+\t\tprivate Flux<Integer> flux;\n+\n+\t\t@BeforeEach\n+\t\tvoid createInstance() {\n+\t\t\tsink = Sinks.replayAll();\n+\t\t\tflux = sink.asFlux();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid fluxViewReturnsSameInstance() {\n+\t\t\tassertThat(flux).isSameAs(sink.asFlux());\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid isAcceptingMoreThatOneSubscriber() {\n+\t\t\tassertThatCode(() -> {\n+\t\t\t\tflux.subscribe();\n+\t\t\t\tflux.subscribe();\n+\t\t\t}).doesNotThrowAnyException();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid honorsMultipleSubscribersBackpressure()\n+\t\t\t\tthrows InterruptedException, ExecutionException {\n+\t\t\tExecutorService es = Executors.newFixedThreadPool(2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "299a170088e47afaa060b550a7d9a4772169af30"}, "originalPosition": 363}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjkwMzg4Ng==", "bodyText": "done in the dynamic test", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442903886", "createdAt": "2020-06-19T15:25:14Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/test/java/reactor/core/publisher/SinksTest.java", "diffHunk": "@@ -0,0 +1,721 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.awaitility.Awaitility;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+\n+import reactor.test.StepVerifier;\n+import reactor.test.subscriber.AssertSubscriber;\n+import reactor.util.concurrent.Queues;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatCode;\n+\n+/**\n+ * @author Simon Basl\u00e9\n+ */\n+class SinksTest {\n+\n+\t@Nested\n+\tclass MulticastNoWarmup {\n+\n+\t\tprivate Sinks.StandaloneFluxSink<Integer> sink;\n+\t\tprivate Flux<Integer> flux;\n+\n+\t\t@BeforeEach\n+\t\tvoid createInstance() {\n+\t\t\tsink = Sinks.multicastNoWarmup();\n+\t\t\tflux = sink.asFlux();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid fluxViewReturnsSameInstance() {\n+\t\t\tassertThat(flux).isSameAs(sink.asFlux());\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid isAcceptingMoreThatOneSubscriber() {\n+\t\t\tassertThatCode(() -> {\n+\t\t\t\tflux.subscribe();\n+\t\t\t\tflux.subscribe();\n+\t\t\t}).doesNotThrowAnyException();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid honorsMultipleSubscribersBackpressure()\n+\t\t\t\tthrows InterruptedException, ExecutionException {\n+\t\t\tExecutorService es = Executors.newFixedThreadPool(2);\n+\t\t\tCountDownLatch requestLatch = new CountDownLatch(2);\n+\t\t\tfinal Future<?> f1 = es.submit(() -> {\n+\t\t\t\tAssertSubscriber<Integer> test1 = AssertSubscriber.create(2);\n+\t\t\t\tflux.subscribe(test1);\n+\t\t\t\ttest1.assertNoValues();\n+\t\t\t\trequestLatch.countDown();\n+\n+\t\t\t\ttest1.awaitAndAssertNextValues(1, 2);\n+\t\t\t\ttry {\n+\t\t\t\t\tAwaitility.await().atMost(2, TimeUnit.SECONDS)\n+\t\t\t\t\t          .with().pollDelay(1, TimeUnit.SECONDS)\n+\t\t\t\t\t          .untilAsserted(() -> test1.assertValueCount(2));\n+\t\t\t\t}\n+\t\t\t\tfinally {\n+\t\t\t\t\ttest1.cancel();\n+\t\t\t\t}\n+\t\t\t});\n+\t\t\tfinal Future<?> f2 = es.submit(() -> {\n+\t\t\t\tAssertSubscriber<Integer> test2 = AssertSubscriber.create(1);\n+\t\t\t\tflux.subscribe(test2);\n+\t\t\t\trequestLatch.countDown();\n+\n+\t\t\t\ttest2.awaitAndAssertNextValues(1);\n+\t\t\t\ttry {\n+\t\t\t\t\tAwaitility.await().atMost(2, TimeUnit.SECONDS)\n+\t\t\t\t\t          .with().pollDelay(1, TimeUnit.SECONDS)\n+\t\t\t\t\t          .untilAsserted(() -> test2.assertValueCount(1));\n+\t\t\t\t}\n+\t\t\t\tfinally {\n+\t\t\t\t\ttest2.cancel();\n+\t\t\t\t}\n+\t\t\t});\n+\n+\t\t\trequestLatch.await(1, TimeUnit.SECONDS);\n+\t\t\tsink.next(1)\n+\t\t\t    .next(2)\n+\t\t\t    .next(3)\n+\t\t\t    .next(4)\n+\t\t\t    .complete();\n+\n+\t\t\tf1.get();\n+\t\t\tf2.get();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid doesNotReplayToLateSubscribers() {\n+\t\t\tAssertSubscriber<Integer> s1 = AssertSubscriber.create();\n+\t\t\tAssertSubscriber<Integer> s2 = AssertSubscriber.create();\n+\n+\t\t\tflux.subscribe(s1);\n+\t\t\tsink.next(1).next(2).next(3);\n+\t\t\ts1.assertValues(1, 2, 3);\n+\n+\t\t\tflux.subscribe(s2);\n+\t\t\ts2.assertNoValues().assertNotComplete();\n+\n+\t\t\tsink.complete();\n+\t\t\ts1.assertValueCount(3).assertComplete();\n+\t\t\ts2.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void doesNotBufferBeforeFirstSubscriber() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).next(2).next(3);\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertNoValues().assertNotComplete();\n+\n+\t\t\tsink.complete();\n+\t\t\tfirst.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyCompleteFirstSubscriber() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).complete();\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyErrorFirstSubscriber() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).error(new IllegalStateException(\"boom\"));\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertNoValues().assertErrorMessage(\"boom\");\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyCompleteLateSubscriber() {\n+\t\t\tflux.subscribe(); //first subscriber\n+\t\t\tAssertSubscriber<Integer> late = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).complete();\n+\t\t\tflux.subscribe(late);\n+\n+\t\t\tlate.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyErrorLateSubscriber() {\n+\t\t\tflux.onErrorReturn(-1).subscribe(); //first subscriber, ignore errors\n+\t\t\tAssertSubscriber<Integer> late = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).error(new IllegalStateException(\"boom\"));\n+\t\t\tflux.subscribe(late);\n+\n+\t\t\tlate.assertNoValues().assertErrorMessage(\"boom\");\n+\t\t}\n+\t}\n+\n+\t@Nested\n+\tclass Multicast {\n+\n+\t\tprivate Sinks.StandaloneFluxSink<Integer> sink;\n+\t\tprivate Flux<Integer> flux;\n+\n+\t\t@BeforeEach\n+\t\tvoid createInstance() {\n+\t\t\tsink = Sinks.multicast();\n+\t\t\tflux = sink.asFlux();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid fluxViewReturnsSameInstance() {\n+\t\t\tassertThat(flux).isSameAs(sink.asFlux());\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid isAcceptingMoreThatOneSubscriber() {\n+\t\t\tassertThatCode(() -> {\n+\t\t\t\tflux.subscribe();\n+\t\t\t\tflux.subscribe();\n+\t\t\t}).doesNotThrowAnyException();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid honorsMultipleSubscribersBackpressure()\n+\t\t\t\tthrows InterruptedException, ExecutionException {\n+\t\t\tExecutorService es = Executors.newFixedThreadPool(2);\n+\t\t\tCountDownLatch requestLatch = new CountDownLatch(2);\n+\t\t\tfinal Future<?> f1 = es.submit(() -> {\n+\t\t\t\tAssertSubscriber<Integer> test1 = AssertSubscriber.create(2);\n+\t\t\t\tflux.subscribe(test1);\n+\t\t\t\ttest1.assertNoValues();\n+\t\t\t\trequestLatch.countDown();\n+\n+\t\t\t\ttest1.awaitAndAssertNextValues(1, 2);\n+\t\t\t\ttry {\n+\t\t\t\t\tAwaitility.await().atMost(2, TimeUnit.SECONDS)\n+\t\t\t\t\t          .with().pollDelay(1, TimeUnit.SECONDS)\n+\t\t\t\t\t          .untilAsserted(() -> test1.assertValueCount(2));\n+\t\t\t\t}\n+\t\t\t\tfinally {\n+\t\t\t\t\ttest1.cancel();\n+\t\t\t\t}\n+\t\t\t});\n+\t\t\tfinal Future<?> f2 = es.submit(() -> {\n+\t\t\t\tAssertSubscriber<Integer> test2 = AssertSubscriber.create(1);\n+\t\t\t\tflux.subscribe(test2);\n+\t\t\t\trequestLatch.countDown();\n+\n+\t\t\t\ttest2.awaitAndAssertNextValues(1);\n+\t\t\t\ttry {\n+\t\t\t\t\tAwaitility.await().atMost(2, TimeUnit.SECONDS)\n+\t\t\t\t\t          .with().pollDelay(1, TimeUnit.SECONDS)\n+\t\t\t\t\t          .untilAsserted(() -> test2.assertValueCount(1));\n+\t\t\t\t}\n+\t\t\t\tfinally {\n+\t\t\t\t\ttest2.cancel();\n+\t\t\t\t}\n+\t\t\t});\n+\n+\t\t\trequestLatch.await(1, TimeUnit.SECONDS);\n+\t\t\tsink.next(1)\n+\t\t\t    .next(2)\n+\t\t\t    .next(3)\n+\t\t\t    .next(4)\n+\t\t\t    .complete();\n+\n+\t\t\tf1.get();\n+\t\t\tf2.get();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid doesNotReplayToLateSubscribers() {\n+\t\t\tAssertSubscriber<Integer> s1 = AssertSubscriber.create();\n+\t\t\tAssertSubscriber<Integer> s2 = AssertSubscriber.create();\n+\n+\t\t\tflux.subscribe(s1);\n+\t\t\tsink.next(1).next(2).next(3);\n+\t\t\ts1.assertValues(1, 2, 3);\n+\n+\t\t\tflux.subscribe(s2);\n+\t\t\ts2.assertNoValues().assertNotComplete();\n+\n+\t\t\tsink.complete();\n+\t\t\ts1.assertValueCount(3).assertComplete();\n+\t\t\ts2.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void doesBufferBeforeFirstSubscriber() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).next(2).next(3);\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertValues(1, 2, 3).assertNotComplete();\n+\n+\t\t\tsink.complete();\n+\t\t\tfirst.assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void replayAndCompleteFirstSubscriber() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).complete();\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertValues(1).assertComplete();\n+\t\t}\n+\n+\t\t@Test //TODO is that acceptable that EmitterProcessor doesn't replay in case of errors?\n+\t\tpublic void noReplayBeforeFirstSubscriberIfEarlyError() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).next(2).next(3).error(new IllegalStateException(\"boom\"));\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertNoValues().assertErrorMessage(\"boom\");\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyCompleteLateSubscriber() {\n+\t\t\tflux.subscribe(); //first subscriber\n+\t\t\tAssertSubscriber<Integer> late = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).complete();\n+\t\t\tflux.subscribe(late);\n+\n+\t\t\tlate.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyErrorLateSubscriber() {\n+\t\t\tflux.onErrorReturn(-1).subscribe(); //first subscriber, ignore errors\n+\t\t\tAssertSubscriber<Integer> late = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).error(new IllegalStateException(\"boom\"));\n+\t\t\tflux.subscribe(late);\n+\n+\t\t\tlate.assertNoValues().assertErrorMessage(\"boom\");\n+\t\t}\n+\t}\n+\n+\t@Nested\n+\tclass MulticastReplayAll {\n+\n+\t\tprivate Sinks.StandaloneFluxSink<Integer> sink;\n+\t\tprivate Flux<Integer> flux;\n+\n+\t\t@BeforeEach\n+\t\tvoid createInstance() {\n+\t\t\tsink = Sinks.replayAll();\n+\t\t\tflux = sink.asFlux();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid fluxViewReturnsSameInstance() {\n+\t\t\tassertThat(flux).isSameAs(sink.asFlux());\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid isAcceptingMoreThatOneSubscriber() {\n+\t\t\tassertThatCode(() -> {\n+\t\t\t\tflux.subscribe();\n+\t\t\t\tflux.subscribe();\n+\t\t\t}).doesNotThrowAnyException();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid honorsMultipleSubscribersBackpressure()\n+\t\t\t\tthrows InterruptedException, ExecutionException {\n+\t\t\tExecutorService es = Executors.newFixedThreadPool(2);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyNzUwOA=="}, "originalCommit": {"oid": "299a170088e47afaa060b550a7d9a4772169af30"}, "originalPosition": 363}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2009, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}