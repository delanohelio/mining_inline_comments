{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM2NTY2NDMy", "number": 2202, "title": "Allow \"0\" prefetch value in `concatMap`", "bodyText": "concatMap can be very helpful in combination with window(n).\nBut the current implementation enforces the mandatory prefetch,\nmaking it request another window without waiting for the completion of the inner Publisher.\nGiven concatMap's nature, we can make it accept 0 prefetch value,\nso that it will request an item on a first request, and next request will be\non inner Publisher's completion.\n\nImplementation Details\nAs an experiment, I decided to try the state-based approach when implementing it.\nThe end result was benchmarked against more \"classic\" implementation (by @OlegDokuka).\nThe benchmark results how that this approach performs well and sometimes even outperforms:\n\nBenchmark                                                     Mode  Cnt         Score        Error  Units\nFluxConcatMapNoPrefetchBenchmark.state                      sample  304  50641650.526 \u00b1 662739.360  ns/op\nFluxConcatMapNoPrefetchBenchmark.state:state\u00b7p0.00          sample       46727168.000               ns/op\nFluxConcatMapNoPrefetchBenchmark.state:state\u00b7p0.50          sample       49676288.000               ns/op\nFluxConcatMapNoPrefetchBenchmark.state:state\u00b7p0.90          sample       54198272.000               ns/op\nFluxConcatMapNoPrefetchBenchmark.state:state\u00b7p0.95          sample       59097088.000               ns/op\nFluxConcatMapNoPrefetchBenchmark.state:state\u00b7p0.99          sample       65745715.200               ns/op\nFluxConcatMapNoPrefetchBenchmark.state:state\u00b7p0.999         sample       66519040.000               ns/op\nFluxConcatMapNoPrefetchBenchmark.state:state\u00b7p0.9999        sample       66519040.000               ns/op\nFluxConcatMapNoPrefetchBenchmark.state:state\u00b7p1.00          sample       66519040.000               ns/op\nFluxConcatMapNoPrefetchBenchmark.zclassic                   sample  300  51276021.760 \u00b1 547219.851  ns/op\nFluxConcatMapNoPrefetchBenchmark.zclassic:zclassic\u00b7p0.00    sample       47316992.000               ns/op\nFluxConcatMapNoPrefetchBenchmark.zclassic:zclassic\u00b7p0.50    sample       50462720.000               ns/op\nFluxConcatMapNoPrefetchBenchmark.zclassic:zclassic\u00b7p0.90    sample       54899507.200               ns/op\nFluxConcatMapNoPrefetchBenchmark.zclassic:zclassic\u00b7p0.95    sample       57668403.200               ns/op\nFluxConcatMapNoPrefetchBenchmark.zclassic:zclassic\u00b7p0.99    sample       63562055.680               ns/op\nFluxConcatMapNoPrefetchBenchmark.zclassic:zclassic\u00b7p0.999   sample       64487424.000               ns/op\nFluxConcatMapNoPrefetchBenchmark.zclassic:zclassic\u00b7p0.9999  sample       64487424.000               ns/op\nFluxConcatMapNoPrefetchBenchmark.zclassic:zclassic\u00b7p1.00    sample       64487424.000               ns/op\n\nStress testing\nTo verify the implementation, I added JCstress-based tests.\nJCstress is a great framework for testing race conditions, and it is very easy to use (as seen in the implemented tests).", "createdAt": "2020-06-18T15:40:27Z", "url": "https://github.com/reactor/reactor-core/pull/2202", "merged": true, "mergeCommit": {"oid": "c4480e9ca75407c56601b7e4cf736badc39bd7a9"}, "closed": true, "closedAt": "2020-07-01T08:53:52Z", "author": {"login": "bsideup"}, "timelineItems": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcsgSybAH2gAyNDM2NTY2NDMyOmEzOGZmY2M4ZGM4ZmFkZDA5MzdhODI1NjQ5NmY1ZmRiYjg3ZmQ3OTI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcwmHszgFqTQ0MDY2Mzc3OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "a38ffcc8dc8fadd0937a8256496f5fdbb87fd792", "author": {"user": {"login": "bsideup", "name": "Sergei Egorov"}}, "url": "https://github.com/reactor/reactor-core/commit/a38ffcc8dc8fadd0937a8256496f5fdbb87fd792", "committedDate": "2020-06-18T15:36:14Z", "message": "Allow \"0\" prefetch value in `concatMap`"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3cc49e762e75f3cea608ea0d2702232c1af29369", "author": {"user": {"login": "bsideup", "name": "Sergei Egorov"}}, "url": "https://github.com/reactor/reactor-core/commit/3cc49e762e75f3cea608ea0d2702232c1af29369", "committedDate": "2020-06-18T16:55:50Z", "message": "Try to fix the build file"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2NzczMTA4", "url": "https://github.com/reactor/reactor-core/pull/2202#pullrequestreview-436773108", "createdAt": "2020-06-24T15:41:11Z", "commit": {"oid": "3cc49e762e75f3cea608ea0d2702232c1af29369"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e565a244f56eef68e50b38c2e4f2f324563064e1", "author": {"user": {"login": "bsideup", "name": "Sergei Egorov"}}, "url": "https://github.com/reactor/reactor-core/commit/e565a244f56eef68e50b38c2e4f2f324563064e1", "committedDate": "2020-06-25T09:58:19Z", "message": "Add discard/drop"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0dda46d64bc03677a6a9fddaded4da6d3d10a4a2", "author": {"user": {"login": "bsideup", "name": "Sergei Egorov"}}, "url": "https://github.com/reactor/reactor-core/commit/0dda46d64bc03677a6a9fddaded4da6d3d10a4a2", "committedDate": "2020-06-25T10:06:12Z", "message": "fix japicmp Gradle task"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "33dd747b7d7ae919b99eecb7594444c7febb818b", "author": {"user": {"login": "bsideup", "name": "Sergei Egorov"}}, "url": "https://github.com/reactor/reactor-core/commit/33dd747b7d7ae919b99eecb7594444c7febb818b", "committedDate": "2020-06-25T10:51:14Z", "message": "remove `finalizedBy`"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3MzcxOTk1", "url": "https://github.com/reactor/reactor-core/pull/2202#pullrequestreview-437371995", "createdAt": "2020-06-25T10:38:21Z", "commit": {"oid": "0dda46d64bc03677a6a9fddaded4da6d3d10a4a2"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxMDozODoyMlrOGo1FwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxMToxMToxMVrOGo2ChQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ2NjA0OQ==", "bodyText": "can be removed, this is not an historical operator from RSC", "url": "https://github.com/reactor/reactor-core/pull/2202#discussion_r445466049", "createdAt": "2020-06-25T10:38:22Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/FluxConcatMapNoPrefetch.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * Copyright (c) 2020-Present Pivotal Software Inc, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package reactor.core.publisher;\n+\n+import java.util.Objects;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.FluxConcatMap.ConcatMapInner;\n+import reactor.core.publisher.FluxConcatMap.FluxConcatMapSupport;\n+import reactor.core.publisher.FluxConcatMap.WeakScalarSubscription;\n+import reactor.util.annotation.Nullable;\n+import reactor.util.context.Context;\n+\n+/**\n+ * Maps each upstream value into a Publisher and concatenates them into one\n+ * sequence of items.\n+ *\n+ * @param <T> the source value type\n+ * @param <R> the output value type\n+ *\n+ * @see <a href=\"https://github.com/reactor/reactive-streams-commons\">Reactive-Streams-Commons</a>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0dda46d64bc03677a6a9fddaded4da6d3d10a4a2"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ2Njc2NQ==", "bodyText": "intentional blank line?", "url": "https://github.com/reactor/reactor-core/pull/2202#discussion_r445466765", "createdAt": "2020-06-25T10:39:58Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/FluxConcatMapNoPrefetch.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * Copyright (c) 2020-Present Pivotal Software Inc, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package reactor.core.publisher;\n+\n+import java.util.Objects;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.FluxConcatMap.ConcatMapInner;\n+import reactor.core.publisher.FluxConcatMap.FluxConcatMapSupport;\n+import reactor.core.publisher.FluxConcatMap.WeakScalarSubscription;\n+import reactor.util.annotation.Nullable;\n+import reactor.util.context.Context;\n+\n+/**\n+ * Maps each upstream value into a Publisher and concatenates them into one\n+ * sequence of items.\n+ *\n+ * @param <T> the source value type\n+ * @param <R> the output value type\n+ *\n+ * @see <a href=\"https://github.com/reactor/reactive-streams-commons\">Reactive-Streams-Commons</a>\n+ */\n+final class FluxConcatMapNoPrefetch<T, R> extends InternalFluxOperator<T, R> {\n+\n+\tfinal Function<? super T, ? extends Publisher<? extends R>> mapper;\n+\n+\tFluxConcatMapNoPrefetch(\n+\t\t\tFlux<? extends T> source,\n+\t\t\tFunction<? super T, ? extends Publisher<? extends R>> mapper\n+\t) {\n+\t\tsuper(source);\n+\t\tthis.mapper = Objects.requireNonNull(mapper, \"mapper\");\n+\t}\n+\n+\t@Override\n+\tpublic CoreSubscriber<? super T> subscribeOrReturn(CoreSubscriber<? super R> actual) {\n+\t\tif (FluxFlatMap.trySubscribeScalarMap(source, actual, mapper, false, true)) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\treturn new FluxConcatMapNoPrefetchSubscriber<>(actual, mapper);\n+\t}\n+\n+\tstatic final class FluxConcatMapNoPrefetchSubscriber<T, R> implements FluxConcatMapSupport<T, R> {\n+\n+\t\tenum State {\n+\t\t\tINITIAL,\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0dda46d64bc03677a6a9fddaded4da6d3d10a4a2"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ3MzcxMg==", "bodyText": "Even if it is redundant, I would consider using State.ACTIVE in the compareAndSet instead of previousState. I find it slightly easier to grok when just scanning the CAS", "url": "https://github.com/reactor/reactor-core/pull/2202#discussion_r445473712", "createdAt": "2020-06-25T10:54:15Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/FluxConcatMapNoPrefetch.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * Copyright (c) 2020-Present Pivotal Software Inc, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package reactor.core.publisher;\n+\n+import java.util.Objects;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.FluxConcatMap.ConcatMapInner;\n+import reactor.core.publisher.FluxConcatMap.FluxConcatMapSupport;\n+import reactor.core.publisher.FluxConcatMap.WeakScalarSubscription;\n+import reactor.util.annotation.Nullable;\n+import reactor.util.context.Context;\n+\n+/**\n+ * Maps each upstream value into a Publisher and concatenates them into one\n+ * sequence of items.\n+ *\n+ * @param <T> the source value type\n+ * @param <R> the output value type\n+ *\n+ * @see <a href=\"https://github.com/reactor/reactive-streams-commons\">Reactive-Streams-Commons</a>\n+ */\n+final class FluxConcatMapNoPrefetch<T, R> extends InternalFluxOperator<T, R> {\n+\n+\tfinal Function<? super T, ? extends Publisher<? extends R>> mapper;\n+\n+\tFluxConcatMapNoPrefetch(\n+\t\t\tFlux<? extends T> source,\n+\t\t\tFunction<? super T, ? extends Publisher<? extends R>> mapper\n+\t) {\n+\t\tsuper(source);\n+\t\tthis.mapper = Objects.requireNonNull(mapper, \"mapper\");\n+\t}\n+\n+\t@Override\n+\tpublic CoreSubscriber<? super T> subscribeOrReturn(CoreSubscriber<? super R> actual) {\n+\t\tif (FluxFlatMap.trySubscribeScalarMap(source, actual, mapper, false, true)) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\treturn new FluxConcatMapNoPrefetchSubscriber<>(actual, mapper);\n+\t}\n+\n+\tstatic final class FluxConcatMapNoPrefetchSubscriber<T, R> implements FluxConcatMapSupport<T, R> {\n+\n+\t\tenum State {\n+\t\t\tINITIAL,\n+\n+\t\t\tREQUESTED,\n+\t\t\tACTIVE,\n+\t\t\tLAST_ACTIVE,\n+\t\t\tTERMINATED,\n+\t\t\tCANCELED,\n+\t\t}\n+\n+\t\tvolatile State state;\n+\n+\t\t@SuppressWarnings(\"rawtypes\")\n+\t\tstatic final AtomicReferenceFieldUpdater<FluxConcatMapNoPrefetchSubscriber, State> STATE = AtomicReferenceFieldUpdater.newUpdater(\n+\t\t\t\tFluxConcatMapNoPrefetchSubscriber.class,\n+\t\t\t\tState.class,\n+\t\t\t\t\"state\"\n+\t\t);\n+\n+\t\tfinal CoreSubscriber<? super R> actual;\n+\n+\t\tfinal ConcatMapInner<R> inner;\n+\n+\t\tfinal Function<? super T, ? extends Publisher<? extends R>> mapper;\n+\n+\t\tSubscription upstream;\n+\n+\t\tFluxConcatMapNoPrefetchSubscriber(\n+\t\t\t\tCoreSubscriber<? super R> actual,\n+\t\t\t\tFunction<? super T, ? extends Publisher<? extends R>> mapper\n+\t\t) {\n+\t\t\tthis.actual = actual;\n+\t\t\tthis.mapper = mapper;\n+\t\t\tthis.inner = new ConcatMapInner<>(this);\n+\t\t\tSTATE.lazySet(this, State.INITIAL);\n+\t\t}\n+\n+\t\t@Override\n+\t\t@Nullable\n+\t\tpublic Object scanUnsafe(Attr key) {\n+\t\t\tif (key == Attr.PARENT) return upstream;\n+\t\t\tif (key == Attr.TERMINATED) return state == State.TERMINATED;\n+\t\t\tif (key == Attr.CANCELLED) return state == State.CANCELED;\n+\n+\t\t\treturn FluxConcatMapSupport.super.scanUnsafe(key);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic CoreSubscriber<? super R> actual() {\n+\t\t\treturn actual;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void onSubscribe(Subscription s) {\n+\t\t\tif (Operators.validate(this.upstream, s)) {\n+\t\t\t\tthis.upstream = s;\n+\n+\t\t\t\tactual.onSubscribe(this);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void onNext(T t) {\n+\t\t\tif (!STATE.compareAndSet(this, State.REQUESTED, State.ACTIVE)) {\n+\t\t\t\tswitch (state) {\n+\t\t\t\t\tcase CANCELED:\n+\t\t\t\t\t\tOperators.onDiscard(t, currentContext());\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase TERMINATED:\n+\t\t\t\t\t\tOperators.onNextDropped(t, currentContext());\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t\treturn;\n+\t\t\t}\n+\n+\t\t\ttry {\n+\t\t\t\tPublisher<? extends R> p = mapper.apply(t);\n+\t\t\t\tObjects.requireNonNull(p, \"The mapper returned a null Publisher\");\n+\n+\t\t\t\tif (p instanceof Callable) {\n+\t\t\t\t\tCallable<R> callable = (Callable<R>) p;\n+\n+\t\t\t\t\tR result = callable.call();\n+\t\t\t\t\tif (result == null) {\n+\t\t\t\t\t\tinnerComplete();\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tif (inner.isUnbounded()) {\n+\t\t\t\t\t\tactual.onNext(result);\n+\t\t\t\t\t\tinnerComplete();\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tinner.set(new WeakScalarSubscription<>(result, inner));\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\n+\t\t\t\tp.subscribe(inner);\n+\t\t\t}\n+\t\t\tcatch (Throwable e) {\n+\t\t\t\tContext ctx = actual.currentContext();\n+\t\t\t\tOperators.onDiscard(t, ctx);\n+\n+\t\t\t\tThrowable e_ = Operators.onNextError(t, e, ctx, upstream);\n+\t\t\t\tif (e_ == null) {\n+\t\t\t\t\tinnerComplete();\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t\tSTATE.lazySet(this, State.TERMINATED);\n+\t\t\t\tactual.onError(Operators.onOperatorError(upstream, e, t, ctx));\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void onError(Throwable t) {\n+\t\t\tfor (State previousState = this.state; ; previousState = this.state) {\n+\t\t\t\tswitch (previousState) {\n+\t\t\t\t\tcase CANCELED:\n+\t\t\t\t\tcase TERMINATED:\n+\t\t\t\t\t\tOperators.onErrorDropped(t, currentContext());\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\tdefault:\n+\t\t\t\t\t\tif (!STATE.compareAndSet(this, previousState, State.TERMINATED)) {\n+\t\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tinner.cancel();\n+\t\t\t\t\t\tsynchronized (this) {\n+\t\t\t\t\t\t\tactual.onError(t);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void onComplete() {\n+\t\t\tfor (State previousState = this.state; ; previousState = this.state) {\n+\t\t\t\tswitch (previousState) {\n+\t\t\t\t\tcase INITIAL:\n+\t\t\t\t\tcase REQUESTED:\n+\t\t\t\t\t\tif (!STATE.compareAndSet(this, previousState, State.TERMINATED)) {\n+\t\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tactual.onComplete();\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\tcase ACTIVE:\n+\t\t\t\t\t\tif (!STATE.compareAndSet(this, previousState, State.LAST_ACTIVE)) {\n+\t\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\tdefault:\n+\t\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic synchronized void innerNext(R value) {\n+\t\t\tswitch (state) {\n+\t\t\t\tcase ACTIVE:\n+\t\t\t\tcase LAST_ACTIVE:\n+\t\t\t\t\tactual.onNext(value);\n+\t\t\t\t\tbreak;\n+\t\t\t\tdefault:\n+\t\t\t\t\tOperators.onDiscard(value, currentContext());\n+\t\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void innerComplete() {\n+\t\t\tfor (State previousState = this.state; ; previousState = this.state) {\n+\t\t\t\tswitch (previousState) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0dda46d64bc03677a6a9fddaded4da6d3d10a4a2"}, "originalPosition": 238}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ4MDM3Mw==", "bodyText": "here I think it is worth it detailing the behavior in a comment:\n\nthe fact that obviously the only time a downstream request directly results in an upstream request is the first time\ndetail of what happens when request(10) is done but the inner only serves eg. 3 elements (3 inner next will be tracked as produced by the ConcatMapInner, then inner onComplete will update the requested tracker, then innerComplete will transition to REQUESTED state and request one more source, swap the subscription and request the 7 remaining demand)", "url": "https://github.com/reactor/reactor-core/pull/2202#discussion_r445480373", "createdAt": "2020-06-25T11:08:29Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/FluxConcatMapNoPrefetch.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * Copyright (c) 2020-Present Pivotal Software Inc, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package reactor.core.publisher;\n+\n+import java.util.Objects;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.FluxConcatMap.ConcatMapInner;\n+import reactor.core.publisher.FluxConcatMap.FluxConcatMapSupport;\n+import reactor.core.publisher.FluxConcatMap.WeakScalarSubscription;\n+import reactor.util.annotation.Nullable;\n+import reactor.util.context.Context;\n+\n+/**\n+ * Maps each upstream value into a Publisher and concatenates them into one\n+ * sequence of items.\n+ *\n+ * @param <T> the source value type\n+ * @param <R> the output value type\n+ *\n+ * @see <a href=\"https://github.com/reactor/reactive-streams-commons\">Reactive-Streams-Commons</a>\n+ */\n+final class FluxConcatMapNoPrefetch<T, R> extends InternalFluxOperator<T, R> {\n+\n+\tfinal Function<? super T, ? extends Publisher<? extends R>> mapper;\n+\n+\tFluxConcatMapNoPrefetch(\n+\t\t\tFlux<? extends T> source,\n+\t\t\tFunction<? super T, ? extends Publisher<? extends R>> mapper\n+\t) {\n+\t\tsuper(source);\n+\t\tthis.mapper = Objects.requireNonNull(mapper, \"mapper\");\n+\t}\n+\n+\t@Override\n+\tpublic CoreSubscriber<? super T> subscribeOrReturn(CoreSubscriber<? super R> actual) {\n+\t\tif (FluxFlatMap.trySubscribeScalarMap(source, actual, mapper, false, true)) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\treturn new FluxConcatMapNoPrefetchSubscriber<>(actual, mapper);\n+\t}\n+\n+\tstatic final class FluxConcatMapNoPrefetchSubscriber<T, R> implements FluxConcatMapSupport<T, R> {\n+\n+\t\tenum State {\n+\t\t\tINITIAL,\n+\n+\t\t\tREQUESTED,\n+\t\t\tACTIVE,\n+\t\t\tLAST_ACTIVE,\n+\t\t\tTERMINATED,\n+\t\t\tCANCELED,\n+\t\t}\n+\n+\t\tvolatile State state;\n+\n+\t\t@SuppressWarnings(\"rawtypes\")\n+\t\tstatic final AtomicReferenceFieldUpdater<FluxConcatMapNoPrefetchSubscriber, State> STATE = AtomicReferenceFieldUpdater.newUpdater(\n+\t\t\t\tFluxConcatMapNoPrefetchSubscriber.class,\n+\t\t\t\tState.class,\n+\t\t\t\t\"state\"\n+\t\t);\n+\n+\t\tfinal CoreSubscriber<? super R> actual;\n+\n+\t\tfinal ConcatMapInner<R> inner;\n+\n+\t\tfinal Function<? super T, ? extends Publisher<? extends R>> mapper;\n+\n+\t\tSubscription upstream;\n+\n+\t\tFluxConcatMapNoPrefetchSubscriber(\n+\t\t\t\tCoreSubscriber<? super R> actual,\n+\t\t\t\tFunction<? super T, ? extends Publisher<? extends R>> mapper\n+\t\t) {\n+\t\t\tthis.actual = actual;\n+\t\t\tthis.mapper = mapper;\n+\t\t\tthis.inner = new ConcatMapInner<>(this);\n+\t\t\tSTATE.lazySet(this, State.INITIAL);\n+\t\t}\n+\n+\t\t@Override\n+\t\t@Nullable\n+\t\tpublic Object scanUnsafe(Attr key) {\n+\t\t\tif (key == Attr.PARENT) return upstream;\n+\t\t\tif (key == Attr.TERMINATED) return state == State.TERMINATED;\n+\t\t\tif (key == Attr.CANCELLED) return state == State.CANCELED;\n+\n+\t\t\treturn FluxConcatMapSupport.super.scanUnsafe(key);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic CoreSubscriber<? super R> actual() {\n+\t\t\treturn actual;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void onSubscribe(Subscription s) {\n+\t\t\tif (Operators.validate(this.upstream, s)) {\n+\t\t\t\tthis.upstream = s;\n+\n+\t\t\t\tactual.onSubscribe(this);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void onNext(T t) {\n+\t\t\tif (!STATE.compareAndSet(this, State.REQUESTED, State.ACTIVE)) {\n+\t\t\t\tswitch (state) {\n+\t\t\t\t\tcase CANCELED:\n+\t\t\t\t\t\tOperators.onDiscard(t, currentContext());\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase TERMINATED:\n+\t\t\t\t\t\tOperators.onNextDropped(t, currentContext());\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t\treturn;\n+\t\t\t}\n+\n+\t\t\ttry {\n+\t\t\t\tPublisher<? extends R> p = mapper.apply(t);\n+\t\t\t\tObjects.requireNonNull(p, \"The mapper returned a null Publisher\");\n+\n+\t\t\t\tif (p instanceof Callable) {\n+\t\t\t\t\tCallable<R> callable = (Callable<R>) p;\n+\n+\t\t\t\t\tR result = callable.call();\n+\t\t\t\t\tif (result == null) {\n+\t\t\t\t\t\tinnerComplete();\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tif (inner.isUnbounded()) {\n+\t\t\t\t\t\tactual.onNext(result);\n+\t\t\t\t\t\tinnerComplete();\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tinner.set(new WeakScalarSubscription<>(result, inner));\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\n+\t\t\t\tp.subscribe(inner);\n+\t\t\t}\n+\t\t\tcatch (Throwable e) {\n+\t\t\t\tContext ctx = actual.currentContext();\n+\t\t\t\tOperators.onDiscard(t, ctx);\n+\n+\t\t\t\tThrowable e_ = Operators.onNextError(t, e, ctx, upstream);\n+\t\t\t\tif (e_ == null) {\n+\t\t\t\t\tinnerComplete();\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t\tSTATE.lazySet(this, State.TERMINATED);\n+\t\t\t\tactual.onError(Operators.onOperatorError(upstream, e, t, ctx));\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void onError(Throwable t) {\n+\t\t\tfor (State previousState = this.state; ; previousState = this.state) {\n+\t\t\t\tswitch (previousState) {\n+\t\t\t\t\tcase CANCELED:\n+\t\t\t\t\tcase TERMINATED:\n+\t\t\t\t\t\tOperators.onErrorDropped(t, currentContext());\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\tdefault:\n+\t\t\t\t\t\tif (!STATE.compareAndSet(this, previousState, State.TERMINATED)) {\n+\t\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tinner.cancel();\n+\t\t\t\t\t\tsynchronized (this) {\n+\t\t\t\t\t\t\tactual.onError(t);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void onComplete() {\n+\t\t\tfor (State previousState = this.state; ; previousState = this.state) {\n+\t\t\t\tswitch (previousState) {\n+\t\t\t\t\tcase INITIAL:\n+\t\t\t\t\tcase REQUESTED:\n+\t\t\t\t\t\tif (!STATE.compareAndSet(this, previousState, State.TERMINATED)) {\n+\t\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tactual.onComplete();\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\tcase ACTIVE:\n+\t\t\t\t\t\tif (!STATE.compareAndSet(this, previousState, State.LAST_ACTIVE)) {\n+\t\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\tdefault:\n+\t\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic synchronized void innerNext(R value) {\n+\t\t\tswitch (state) {\n+\t\t\t\tcase ACTIVE:\n+\t\t\t\tcase LAST_ACTIVE:\n+\t\t\t\t\tactual.onNext(value);\n+\t\t\t\t\tbreak;\n+\t\t\t\tdefault:\n+\t\t\t\t\tOperators.onDiscard(value, currentContext());\n+\t\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void innerComplete() {\n+\t\t\tfor (State previousState = this.state; ; previousState = this.state) {\n+\t\t\t\tswitch (previousState) {\n+\t\t\t\t\tcase ACTIVE:\n+\t\t\t\t\t\tif (!STATE.compareAndSet(this, previousState, State.REQUESTED)) {\n+\t\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tupstream.request(1);\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\tcase LAST_ACTIVE:\n+\t\t\t\t\t\tif (!STATE.compareAndSet(this, previousState, State.TERMINATED)) {\n+\t\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tactual.onComplete();\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\tdefault:\n+\t\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void innerError(Throwable e) {\n+\t\t\tfor (State previousState = this.state; ; previousState = this.state) {\n+\t\t\t\tswitch (previousState) {\n+\t\t\t\t\tcase ACTIVE:\n+\t\t\t\t\tcase LAST_ACTIVE:\n+\t\t\t\t\t\tif (!STATE.compareAndSet(this, previousState, State.TERMINATED)) {\n+\t\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tupstream.cancel();\n+\t\t\t\t\t\tinner.cancel();\n+\t\t\t\t\t\tactual.onError(e);\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\tdefault:\n+\t\t\t\t\t\tOperators.onErrorDropped(e, currentContext());\n+\t\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void request(long n) {\n+\t\t\tif (STATE.compareAndSet(this, State.INITIAL, State.REQUESTED)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33dd747b7d7ae919b99eecb7594444c7febb818b"}, "originalPosition": 279}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ4MDYxNw==", "bodyText": "(this is absolutely not necessary, but after reviewing that was the one spot I had to double back over)", "url": "https://github.com/reactor/reactor-core/pull/2202#discussion_r445480617", "createdAt": "2020-06-25T11:09:03Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/FluxConcatMapNoPrefetch.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * Copyright (c) 2020-Present Pivotal Software Inc, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package reactor.core.publisher;\n+\n+import java.util.Objects;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.FluxConcatMap.ConcatMapInner;\n+import reactor.core.publisher.FluxConcatMap.FluxConcatMapSupport;\n+import reactor.core.publisher.FluxConcatMap.WeakScalarSubscription;\n+import reactor.util.annotation.Nullable;\n+import reactor.util.context.Context;\n+\n+/**\n+ * Maps each upstream value into a Publisher and concatenates them into one\n+ * sequence of items.\n+ *\n+ * @param <T> the source value type\n+ * @param <R> the output value type\n+ *\n+ * @see <a href=\"https://github.com/reactor/reactive-streams-commons\">Reactive-Streams-Commons</a>\n+ */\n+final class FluxConcatMapNoPrefetch<T, R> extends InternalFluxOperator<T, R> {\n+\n+\tfinal Function<? super T, ? extends Publisher<? extends R>> mapper;\n+\n+\tFluxConcatMapNoPrefetch(\n+\t\t\tFlux<? extends T> source,\n+\t\t\tFunction<? super T, ? extends Publisher<? extends R>> mapper\n+\t) {\n+\t\tsuper(source);\n+\t\tthis.mapper = Objects.requireNonNull(mapper, \"mapper\");\n+\t}\n+\n+\t@Override\n+\tpublic CoreSubscriber<? super T> subscribeOrReturn(CoreSubscriber<? super R> actual) {\n+\t\tif (FluxFlatMap.trySubscribeScalarMap(source, actual, mapper, false, true)) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\treturn new FluxConcatMapNoPrefetchSubscriber<>(actual, mapper);\n+\t}\n+\n+\tstatic final class FluxConcatMapNoPrefetchSubscriber<T, R> implements FluxConcatMapSupport<T, R> {\n+\n+\t\tenum State {\n+\t\t\tINITIAL,\n+\n+\t\t\tREQUESTED,\n+\t\t\tACTIVE,\n+\t\t\tLAST_ACTIVE,\n+\t\t\tTERMINATED,\n+\t\t\tCANCELED,\n+\t\t}\n+\n+\t\tvolatile State state;\n+\n+\t\t@SuppressWarnings(\"rawtypes\")\n+\t\tstatic final AtomicReferenceFieldUpdater<FluxConcatMapNoPrefetchSubscriber, State> STATE = AtomicReferenceFieldUpdater.newUpdater(\n+\t\t\t\tFluxConcatMapNoPrefetchSubscriber.class,\n+\t\t\t\tState.class,\n+\t\t\t\t\"state\"\n+\t\t);\n+\n+\t\tfinal CoreSubscriber<? super R> actual;\n+\n+\t\tfinal ConcatMapInner<R> inner;\n+\n+\t\tfinal Function<? super T, ? extends Publisher<? extends R>> mapper;\n+\n+\t\tSubscription upstream;\n+\n+\t\tFluxConcatMapNoPrefetchSubscriber(\n+\t\t\t\tCoreSubscriber<? super R> actual,\n+\t\t\t\tFunction<? super T, ? extends Publisher<? extends R>> mapper\n+\t\t) {\n+\t\t\tthis.actual = actual;\n+\t\t\tthis.mapper = mapper;\n+\t\t\tthis.inner = new ConcatMapInner<>(this);\n+\t\t\tSTATE.lazySet(this, State.INITIAL);\n+\t\t}\n+\n+\t\t@Override\n+\t\t@Nullable\n+\t\tpublic Object scanUnsafe(Attr key) {\n+\t\t\tif (key == Attr.PARENT) return upstream;\n+\t\t\tif (key == Attr.TERMINATED) return state == State.TERMINATED;\n+\t\t\tif (key == Attr.CANCELLED) return state == State.CANCELED;\n+\n+\t\t\treturn FluxConcatMapSupport.super.scanUnsafe(key);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic CoreSubscriber<? super R> actual() {\n+\t\t\treturn actual;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void onSubscribe(Subscription s) {\n+\t\t\tif (Operators.validate(this.upstream, s)) {\n+\t\t\t\tthis.upstream = s;\n+\n+\t\t\t\tactual.onSubscribe(this);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void onNext(T t) {\n+\t\t\tif (!STATE.compareAndSet(this, State.REQUESTED, State.ACTIVE)) {\n+\t\t\t\tswitch (state) {\n+\t\t\t\t\tcase CANCELED:\n+\t\t\t\t\t\tOperators.onDiscard(t, currentContext());\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase TERMINATED:\n+\t\t\t\t\t\tOperators.onNextDropped(t, currentContext());\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t\treturn;\n+\t\t\t}\n+\n+\t\t\ttry {\n+\t\t\t\tPublisher<? extends R> p = mapper.apply(t);\n+\t\t\t\tObjects.requireNonNull(p, \"The mapper returned a null Publisher\");\n+\n+\t\t\t\tif (p instanceof Callable) {\n+\t\t\t\t\tCallable<R> callable = (Callable<R>) p;\n+\n+\t\t\t\t\tR result = callable.call();\n+\t\t\t\t\tif (result == null) {\n+\t\t\t\t\t\tinnerComplete();\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tif (inner.isUnbounded()) {\n+\t\t\t\t\t\tactual.onNext(result);\n+\t\t\t\t\t\tinnerComplete();\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tinner.set(new WeakScalarSubscription<>(result, inner));\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\n+\t\t\t\tp.subscribe(inner);\n+\t\t\t}\n+\t\t\tcatch (Throwable e) {\n+\t\t\t\tContext ctx = actual.currentContext();\n+\t\t\t\tOperators.onDiscard(t, ctx);\n+\n+\t\t\t\tThrowable e_ = Operators.onNextError(t, e, ctx, upstream);\n+\t\t\t\tif (e_ == null) {\n+\t\t\t\t\tinnerComplete();\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t\tSTATE.lazySet(this, State.TERMINATED);\n+\t\t\t\tactual.onError(Operators.onOperatorError(upstream, e, t, ctx));\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void onError(Throwable t) {\n+\t\t\tfor (State previousState = this.state; ; previousState = this.state) {\n+\t\t\t\tswitch (previousState) {\n+\t\t\t\t\tcase CANCELED:\n+\t\t\t\t\tcase TERMINATED:\n+\t\t\t\t\t\tOperators.onErrorDropped(t, currentContext());\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\tdefault:\n+\t\t\t\t\t\tif (!STATE.compareAndSet(this, previousState, State.TERMINATED)) {\n+\t\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tinner.cancel();\n+\t\t\t\t\t\tsynchronized (this) {\n+\t\t\t\t\t\t\tactual.onError(t);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void onComplete() {\n+\t\t\tfor (State previousState = this.state; ; previousState = this.state) {\n+\t\t\t\tswitch (previousState) {\n+\t\t\t\t\tcase INITIAL:\n+\t\t\t\t\tcase REQUESTED:\n+\t\t\t\t\t\tif (!STATE.compareAndSet(this, previousState, State.TERMINATED)) {\n+\t\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tactual.onComplete();\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\tcase ACTIVE:\n+\t\t\t\t\t\tif (!STATE.compareAndSet(this, previousState, State.LAST_ACTIVE)) {\n+\t\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\tdefault:\n+\t\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic synchronized void innerNext(R value) {\n+\t\t\tswitch (state) {\n+\t\t\t\tcase ACTIVE:\n+\t\t\t\tcase LAST_ACTIVE:\n+\t\t\t\t\tactual.onNext(value);\n+\t\t\t\t\tbreak;\n+\t\t\t\tdefault:\n+\t\t\t\t\tOperators.onDiscard(value, currentContext());\n+\t\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void innerComplete() {\n+\t\t\tfor (State previousState = this.state; ; previousState = this.state) {\n+\t\t\t\tswitch (previousState) {\n+\t\t\t\t\tcase ACTIVE:\n+\t\t\t\t\t\tif (!STATE.compareAndSet(this, previousState, State.REQUESTED)) {\n+\t\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tupstream.request(1);\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\tcase LAST_ACTIVE:\n+\t\t\t\t\t\tif (!STATE.compareAndSet(this, previousState, State.TERMINATED)) {\n+\t\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tactual.onComplete();\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\tdefault:\n+\t\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void innerError(Throwable e) {\n+\t\t\tfor (State previousState = this.state; ; previousState = this.state) {\n+\t\t\t\tswitch (previousState) {\n+\t\t\t\t\tcase ACTIVE:\n+\t\t\t\t\tcase LAST_ACTIVE:\n+\t\t\t\t\t\tif (!STATE.compareAndSet(this, previousState, State.TERMINATED)) {\n+\t\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tupstream.cancel();\n+\t\t\t\t\t\tinner.cancel();\n+\t\t\t\t\t\tactual.onError(e);\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\tdefault:\n+\t\t\t\t\t\tOperators.onErrorDropped(e, currentContext());\n+\t\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void request(long n) {\n+\t\t\tif (STATE.compareAndSet(this, State.INITIAL, State.REQUESTED)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ4MDM3Mw=="}, "originalCommit": {"oid": "33dd747b7d7ae919b99eecb7594444c7febb818b"}, "originalPosition": 279}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ4MTYwNQ==", "bodyText": "would it make sense to have additional tests for the concrete class in a separate test case, on top of that one (which tests the API goes down the FluxConcatMapNoPrefetch path I guess) and the stress test ? There might not be much left to test other than the Scannable, that said, but still... this test can actually be done in the separate test class as well.", "url": "https://github.com/reactor/reactor-core/pull/2202#discussion_r445481605", "createdAt": "2020-06-25T11:11:11Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/test/java/reactor/core/publisher/FluxConcatMapTest.java", "diffHunk": "@@ -1226,4 +1227,46 @@ public void discardDelayedOnDrainMapperError() {\n \t\t            .verifyThenAssertThat()\n \t\t            .hasDiscardedExactly(1);\n \t}\n+\n+\t@Test\n+\tpublic void noRequestBeforeOnCompleteWithZeroPrefetch() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33dd747b7d7ae919b99eecb7594444c7febb818b"}, "originalPosition": 14}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "160a95cdb5011a1d6eddd1b087147395d48ebca7", "author": {"user": {"login": "bsideup", "name": "Sergei Egorov"}}, "url": "https://github.com/reactor/reactor-core/commit/160a95cdb5011a1d6eddd1b087147395d48ebca7", "committedDate": "2020-06-25T11:40:07Z", "message": "remove the RSC reference, drop the unnecessary empty line"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2f99b8e76eb50084d4ff532284a258fec6be320b", "author": {"user": {"login": "bsideup", "name": "Sergei Egorov"}}, "url": "https://github.com/reactor/reactor-core/commit/2f99b8e76eb50084d4ff532284a258fec6be320b", "committedDate": "2020-06-25T12:56:17Z", "message": "Merge branch 'master' into zero_prefetch_concatMap\n\n# Conflicts:\n#\treactor-core/build.gradle\n#\treactor-test/build.gradle"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3NDc0MjY4", "url": "https://github.com/reactor/reactor-core/pull/2202#pullrequestreview-437474268", "createdAt": "2020-06-25T13:07:10Z", "commit": {"oid": "2f99b8e76eb50084d4ff532284a258fec6be320b"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxMzowNzoxMVrOGo50rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxMzowOTo1NlrOGo57dA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTU0MzU5OA==", "bodyText": "wait there's actually an inconsistency. your implementation seem to always delay errors, so it should be an overload of concatMapDelayErrors", "url": "https://github.com/reactor/reactor-core/pull/2202#discussion_r445543598", "createdAt": "2020-06-25T13:07:11Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/Flux.java", "diffHunk": "@@ -3663,13 +3663,16 @@ public final T blockLast(Duration timeout) {\n \t * @reactor.discard This operator discards elements it internally queued for backpressure upon cancellation.\n \t *\n \t * @param mapper the function to transform this sequence of T into concatenated sequences of V\n-\t * @param prefetch the inner source produced demand\n+\t * @param prefetch the inner source produced demand (set it to 0 if you don't want it to prefetch)\n \t * @param <V> the produced concatenated type\n \t *\n \t * @return a concatenated {@link Flux}\n \t */\n \tpublic final <V> Flux<V> concatMap(Function<? super T, ? extends Publisher<? extends V>>\n \t\t\tmapper, int prefetch) {\n+\t\tif (prefetch == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f99b8e76eb50084d4ff532284a258fec6be320b"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTU0MzkxMA==", "bodyText": "see comment on Flux relative to that second boolean (expectDelayErrors) being true.", "url": "https://github.com/reactor/reactor-core/pull/2202#discussion_r445543910", "createdAt": "2020-06-25T13:07:39Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/FluxConcatMapNoPrefetch.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/*\n+ * Copyright (c) 2020-Present Pivotal Software Inc, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package reactor.core.publisher;\n+\n+import java.util.Objects;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.FluxConcatMap.ConcatMapInner;\n+import reactor.core.publisher.FluxConcatMap.FluxConcatMapSupport;\n+import reactor.core.publisher.FluxConcatMap.WeakScalarSubscription;\n+import reactor.util.annotation.Nullable;\n+import reactor.util.context.Context;\n+\n+/**\n+ * Maps each upstream value into a Publisher and concatenates them into one\n+ * sequence of items.\n+ *\n+ * @param <T> the source value type\n+ * @param <R> the output value type\n+ *\n+ * @see FluxConcatMap\n+ */\n+final class FluxConcatMapNoPrefetch<T, R> extends InternalFluxOperator<T, R> {\n+\n+\tfinal Function<? super T, ? extends Publisher<? extends R>> mapper;\n+\n+\tFluxConcatMapNoPrefetch(\n+\t\t\tFlux<? extends T> source,\n+\t\t\tFunction<? super T, ? extends Publisher<? extends R>> mapper\n+\t) {\n+\t\tsuper(source);\n+\t\tthis.mapper = Objects.requireNonNull(mapper, \"mapper\");\n+\t}\n+\n+\t@Override\n+\tpublic CoreSubscriber<? super T> subscribeOrReturn(CoreSubscriber<? super R> actual) {\n+\t\tif (FluxFlatMap.trySubscribeScalarMap(source, actual, mapper, false, true)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f99b8e76eb50084d4ff532284a258fec6be320b"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTU0NDE4Mg==", "bodyText": "ok, that makes sense as well. let's keep it that way then.", "url": "https://github.com/reactor/reactor-core/pull/2202#discussion_r445544182", "createdAt": "2020-06-25T13:08:05Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/FluxConcatMapNoPrefetch.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * Copyright (c) 2020-Present Pivotal Software Inc, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package reactor.core.publisher;\n+\n+import java.util.Objects;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.FluxConcatMap.ConcatMapInner;\n+import reactor.core.publisher.FluxConcatMap.FluxConcatMapSupport;\n+import reactor.core.publisher.FluxConcatMap.WeakScalarSubscription;\n+import reactor.util.annotation.Nullable;\n+import reactor.util.context.Context;\n+\n+/**\n+ * Maps each upstream value into a Publisher and concatenates them into one\n+ * sequence of items.\n+ *\n+ * @param <T> the source value type\n+ * @param <R> the output value type\n+ *\n+ * @see <a href=\"https://github.com/reactor/reactive-streams-commons\">Reactive-Streams-Commons</a>\n+ */\n+final class FluxConcatMapNoPrefetch<T, R> extends InternalFluxOperator<T, R> {\n+\n+\tfinal Function<? super T, ? extends Publisher<? extends R>> mapper;\n+\n+\tFluxConcatMapNoPrefetch(\n+\t\t\tFlux<? extends T> source,\n+\t\t\tFunction<? super T, ? extends Publisher<? extends R>> mapper\n+\t) {\n+\t\tsuper(source);\n+\t\tthis.mapper = Objects.requireNonNull(mapper, \"mapper\");\n+\t}\n+\n+\t@Override\n+\tpublic CoreSubscriber<? super T> subscribeOrReturn(CoreSubscriber<? super R> actual) {\n+\t\tif (FluxFlatMap.trySubscribeScalarMap(source, actual, mapper, false, true)) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\treturn new FluxConcatMapNoPrefetchSubscriber<>(actual, mapper);\n+\t}\n+\n+\tstatic final class FluxConcatMapNoPrefetchSubscriber<T, R> implements FluxConcatMapSupport<T, R> {\n+\n+\t\tenum State {\n+\t\t\tINITIAL,\n+\n+\t\t\tREQUESTED,\n+\t\t\tACTIVE,\n+\t\t\tLAST_ACTIVE,\n+\t\t\tTERMINATED,\n+\t\t\tCANCELED,\n+\t\t}\n+\n+\t\tvolatile State state;\n+\n+\t\t@SuppressWarnings(\"rawtypes\")\n+\t\tstatic final AtomicReferenceFieldUpdater<FluxConcatMapNoPrefetchSubscriber, State> STATE = AtomicReferenceFieldUpdater.newUpdater(\n+\t\t\t\tFluxConcatMapNoPrefetchSubscriber.class,\n+\t\t\t\tState.class,\n+\t\t\t\t\"state\"\n+\t\t);\n+\n+\t\tfinal CoreSubscriber<? super R> actual;\n+\n+\t\tfinal ConcatMapInner<R> inner;\n+\n+\t\tfinal Function<? super T, ? extends Publisher<? extends R>> mapper;\n+\n+\t\tSubscription upstream;\n+\n+\t\tFluxConcatMapNoPrefetchSubscriber(\n+\t\t\t\tCoreSubscriber<? super R> actual,\n+\t\t\t\tFunction<? super T, ? extends Publisher<? extends R>> mapper\n+\t\t) {\n+\t\t\tthis.actual = actual;\n+\t\t\tthis.mapper = mapper;\n+\t\t\tthis.inner = new ConcatMapInner<>(this);\n+\t\t\tSTATE.lazySet(this, State.INITIAL);\n+\t\t}\n+\n+\t\t@Override\n+\t\t@Nullable\n+\t\tpublic Object scanUnsafe(Attr key) {\n+\t\t\tif (key == Attr.PARENT) return upstream;\n+\t\t\tif (key == Attr.TERMINATED) return state == State.TERMINATED;\n+\t\t\tif (key == Attr.CANCELLED) return state == State.CANCELED;\n+\n+\t\t\treturn FluxConcatMapSupport.super.scanUnsafe(key);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic CoreSubscriber<? super R> actual() {\n+\t\t\treturn actual;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void onSubscribe(Subscription s) {\n+\t\t\tif (Operators.validate(this.upstream, s)) {\n+\t\t\t\tthis.upstream = s;\n+\n+\t\t\t\tactual.onSubscribe(this);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void onNext(T t) {\n+\t\t\tif (!STATE.compareAndSet(this, State.REQUESTED, State.ACTIVE)) {\n+\t\t\t\tswitch (state) {\n+\t\t\t\t\tcase CANCELED:\n+\t\t\t\t\t\tOperators.onDiscard(t, currentContext());\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase TERMINATED:\n+\t\t\t\t\t\tOperators.onNextDropped(t, currentContext());\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t\treturn;\n+\t\t\t}\n+\n+\t\t\ttry {\n+\t\t\t\tPublisher<? extends R> p = mapper.apply(t);\n+\t\t\t\tObjects.requireNonNull(p, \"The mapper returned a null Publisher\");\n+\n+\t\t\t\tif (p instanceof Callable) {\n+\t\t\t\t\tCallable<R> callable = (Callable<R>) p;\n+\n+\t\t\t\t\tR result = callable.call();\n+\t\t\t\t\tif (result == null) {\n+\t\t\t\t\t\tinnerComplete();\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tif (inner.isUnbounded()) {\n+\t\t\t\t\t\tactual.onNext(result);\n+\t\t\t\t\t\tinnerComplete();\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tinner.set(new WeakScalarSubscription<>(result, inner));\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\n+\t\t\t\tp.subscribe(inner);\n+\t\t\t}\n+\t\t\tcatch (Throwable e) {\n+\t\t\t\tContext ctx = actual.currentContext();\n+\t\t\t\tOperators.onDiscard(t, ctx);\n+\n+\t\t\t\tThrowable e_ = Operators.onNextError(t, e, ctx, upstream);\n+\t\t\t\tif (e_ == null) {\n+\t\t\t\t\tinnerComplete();\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t\tSTATE.lazySet(this, State.TERMINATED);\n+\t\t\t\tactual.onError(Operators.onOperatorError(upstream, e, t, ctx));\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void onError(Throwable t) {\n+\t\t\tfor (State previousState = this.state; ; previousState = this.state) {\n+\t\t\t\tswitch (previousState) {\n+\t\t\t\t\tcase CANCELED:\n+\t\t\t\t\tcase TERMINATED:\n+\t\t\t\t\t\tOperators.onErrorDropped(t, currentContext());\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\tdefault:\n+\t\t\t\t\t\tif (!STATE.compareAndSet(this, previousState, State.TERMINATED)) {\n+\t\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tinner.cancel();\n+\t\t\t\t\t\tsynchronized (this) {\n+\t\t\t\t\t\t\tactual.onError(t);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void onComplete() {\n+\t\t\tfor (State previousState = this.state; ; previousState = this.state) {\n+\t\t\t\tswitch (previousState) {\n+\t\t\t\t\tcase INITIAL:\n+\t\t\t\t\tcase REQUESTED:\n+\t\t\t\t\t\tif (!STATE.compareAndSet(this, previousState, State.TERMINATED)) {\n+\t\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tactual.onComplete();\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\tcase ACTIVE:\n+\t\t\t\t\t\tif (!STATE.compareAndSet(this, previousState, State.LAST_ACTIVE)) {\n+\t\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\tdefault:\n+\t\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic synchronized void innerNext(R value) {\n+\t\t\tswitch (state) {\n+\t\t\t\tcase ACTIVE:\n+\t\t\t\tcase LAST_ACTIVE:\n+\t\t\t\t\tactual.onNext(value);\n+\t\t\t\t\tbreak;\n+\t\t\t\tdefault:\n+\t\t\t\t\tOperators.onDiscard(value, currentContext());\n+\t\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void innerComplete() {\n+\t\t\tfor (State previousState = this.state; ; previousState = this.state) {\n+\t\t\t\tswitch (previousState) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ3MzcxMg=="}, "originalCommit": {"oid": "0dda46d64bc03677a6a9fddaded4da6d3d10a4a2"}, "originalPosition": 238}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTU0NTMzMg==", "bodyText": "are you talking about mutualizing the test code, or duplicating the relevant tests? I would definitely agree on duplicating, but if reusing I'm expecting only a subset of the tests make sense for FluxConcatMapNoPrefetch?", "url": "https://github.com/reactor/reactor-core/pull/2202#discussion_r445545332", "createdAt": "2020-06-25T13:09:56Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/test/java/reactor/core/publisher/FluxConcatMapTest.java", "diffHunk": "@@ -1226,4 +1227,46 @@ public void discardDelayedOnDrainMapperError() {\n \t\t            .verifyThenAssertThat()\n \t\t            .hasDiscardedExactly(1);\n \t}\n+\n+\t@Test\n+\tpublic void noRequestBeforeOnCompleteWithZeroPrefetch() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ4MTYwNQ=="}, "originalCommit": {"oid": "33dd747b7d7ae919b99eecb7594444c7febb818b"}, "originalPosition": 14}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4MTYwOTAx", "url": "https://github.com/reactor/reactor-core/pull/2202#pullrequestreview-438160901", "createdAt": "2020-06-26T09:45:49Z", "commit": {"oid": "2f99b8e76eb50084d4ff532284a258fec6be320b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwOTo0NTo0OVrOGpat-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwOTo0NTo0OVrOGpat-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA4MjU1Mg==", "bodyText": "Could you document the transition diagram, or at least explain the states in more detail (in particular LAST_ACTIVE)?", "url": "https://github.com/reactor/reactor-core/pull/2202#discussion_r446082552", "createdAt": "2020-06-26T09:45:49Z", "author": {"login": "ericbottard"}, "path": "reactor-core/src/main/java/reactor/core/publisher/FluxConcatMapNoPrefetch.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/*\n+ * Copyright (c) 2020-Present Pivotal Software Inc, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package reactor.core.publisher;\n+\n+import java.util.Objects;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.FluxConcatMap.ConcatMapInner;\n+import reactor.core.publisher.FluxConcatMap.FluxConcatMapSupport;\n+import reactor.core.publisher.FluxConcatMap.WeakScalarSubscription;\n+import reactor.util.annotation.Nullable;\n+import reactor.util.context.Context;\n+\n+/**\n+ * Maps each upstream value into a Publisher and concatenates them into one\n+ * sequence of items.\n+ *\n+ * @param <T> the source value type\n+ * @param <R> the output value type\n+ *\n+ * @see FluxConcatMap\n+ */\n+final class FluxConcatMapNoPrefetch<T, R> extends InternalFluxOperator<T, R> {\n+\n+\tfinal Function<? super T, ? extends Publisher<? extends R>> mapper;\n+\n+\tFluxConcatMapNoPrefetch(\n+\t\t\tFlux<? extends T> source,\n+\t\t\tFunction<? super T, ? extends Publisher<? extends R>> mapper\n+\t) {\n+\t\tsuper(source);\n+\t\tthis.mapper = Objects.requireNonNull(mapper, \"mapper\");\n+\t}\n+\n+\t@Override\n+\tpublic CoreSubscriber<? super T> subscribeOrReturn(CoreSubscriber<? super R> actual) {\n+\t\tif (FluxFlatMap.trySubscribeScalarMap(source, actual, mapper, false, true)) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\treturn new FluxConcatMapNoPrefetchSubscriber<>(actual, mapper);\n+\t}\n+\n+\tstatic final class FluxConcatMapNoPrefetchSubscriber<T, R> implements FluxConcatMapSupport<T, R> {\n+\n+\t\tenum State {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f99b8e76eb50084d4ff532284a258fec6be320b"}, "originalPosition": 64}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "042ff01ff09ef2952853d4227fc786454cc3a4fb", "author": {"user": {"login": "bsideup", "name": "Sergei Egorov"}}, "url": "https://github.com/reactor/reactor-core/commit/042ff01ff09ef2952853d4227fc786454cc3a4fb", "committedDate": "2020-06-26T10:11:26Z", "message": "support `ErrorMode`"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aba5aa0950733c58cc1ac56bcefc22d52f5eb74c", "author": {"user": {"login": "bsideup", "name": "Sergei Egorov"}}, "url": "https://github.com/reactor/reactor-core/commit/aba5aa0950733c58cc1ac56bcefc22d52f5eb74c", "committedDate": "2020-06-26T10:12:33Z", "message": "Extract `AbstractFluxConcatMapTest`"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "76f9fefc15c95921e9a6b83895e09407c7e80721", "author": {"user": {"login": "bsideup", "name": "Sergei Egorov"}}, "url": "https://github.com/reactor/reactor-core/commit/76f9fefc15c95921e9a6b83895e09407c7e80721", "committedDate": "2020-06-26T15:48:00Z", "message": "simplify error handling, document states"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "669fcc954a1bc0d75351b3cf369abf0e6027c8cc", "author": {"user": {"login": "bsideup", "name": "Sergei Egorov"}}, "url": "https://github.com/reactor/reactor-core/commit/669fcc954a1bc0d75351b3cf369abf0e6027c8cc", "committedDate": "2020-06-29T13:57:31Z", "message": "Merge branch 'master' into zero_prefetch_concatMap\n\n# Conflicts:\n#\treactor-core/src/test/java/reactor/core/publisher/FluxConcatMapTest.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2fcd373c4184ae6749ee5b5a7effa6e258487484", "author": {"user": {"login": "bsideup", "name": "Sergei Egorov"}}, "url": "https://github.com/reactor/reactor-core/commit/2fcd373c4184ae6749ee5b5a7effa6e258487484", "committedDate": "2020-06-29T14:00:22Z", "message": "Remove `Schedulers.elastic()` usage"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8f57fa020f8fb635f4c2e5372970912561dc25d9", "author": {"user": {"login": "bsideup", "name": "Sergei Egorov"}}, "url": "https://github.com/reactor/reactor-core/commit/8f57fa020f8fb635f4c2e5372970912561dc25d9", "committedDate": "2020-06-29T14:18:39Z", "message": "Fix the indentation in `build.gradle`"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5MjIyODM0", "url": "https://github.com/reactor/reactor-core/pull/2202#pullrequestreview-439222834", "createdAt": "2020-06-29T14:50:26Z", "commit": {"oid": "8f57fa020f8fb635f4c2e5372970912561dc25d9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNDo1MDoyNlrOGqUmCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNDo1MDoyNlrOGqUmCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAzMDc5Mw==", "bodyText": "\ud83d\udc4d, please just mention this change in the body of the commit message", "url": "https://github.com/reactor/reactor-core/pull/2202#discussion_r447030793", "createdAt": "2020-06-29T14:50:26Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/Flux.java", "diffHunk": "@@ -472,10 +472,7 @@\n \t * @return a new {@link Flux} concatenating all inner sources sequences\n \t */\n \tpublic static <T> Flux<T> concat(Publisher<? extends Publisher<? extends T>> sources, int prefetch) {\n-\t\treturn onAssembly(new FluxConcatMap<>(from(sources),\n-\t\t\t\tidentityFunction(),\n-\t\t\t\tQueues.get(prefetch), prefetch,\n-\t\t\t\tFluxConcatMap.ErrorMode.IMMEDIATE));\n+\t\treturn wrap(sources).concatMap(identityFunction(), prefetch);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f57fa020f8fb635f4c2e5372970912561dc25d9"}, "originalPosition": 8}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5MjI1MDI3", "url": "https://github.com/reactor/reactor-core/pull/2202#pullrequestreview-439225027", "createdAt": "2020-06-29T14:52:37Z", "commit": {"oid": "8f57fa020f8fb635f4c2e5372970912561dc25d9"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNDo1MjozN1rOGqUszA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNDo1NjoyMlrOGqU3wA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAzMjUyNA==", "bodyText": "the second boolean should be this.errorMode != ErrorMode.IMMEDIATE I think", "url": "https://github.com/reactor/reactor-core/pull/2202#discussion_r447032524", "createdAt": "2020-06-29T14:52:37Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/FluxConcatMapNoPrefetch.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/*\n+ * Copyright (c) 2020-Present Pivotal Software Inc, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package reactor.core.publisher;\n+\n+import java.util.Objects;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.FluxConcatMap.ConcatMapInner;\n+import reactor.core.publisher.FluxConcatMap.FluxConcatMapSupport;\n+import reactor.core.publisher.FluxConcatMap.WeakScalarSubscription;\n+import reactor.util.annotation.Nullable;\n+import reactor.util.context.Context;\n+\n+/**\n+ * Maps each upstream value into a Publisher and concatenates them into one\n+ * sequence of items.\n+ *\n+ * @param <T> the source value type\n+ * @param <R> the output value type\n+ *\n+ * @see FluxConcatMap\n+ */\n+final class FluxConcatMapNoPrefetch<T, R> extends InternalFluxOperator<T, R> {\n+\n+\tfinal Function<? super T, ? extends Publisher<? extends R>> mapper;\n+\n+\tFluxConcatMapNoPrefetch(\n+\t\t\tFlux<? extends T> source,\n+\t\t\tFunction<? super T, ? extends Publisher<? extends R>> mapper\n+\t) {\n+\t\tsuper(source);\n+\t\tthis.mapper = Objects.requireNonNull(mapper, \"mapper\");\n+\t}\n+\n+\t@Override\n+\tpublic CoreSubscriber<? super T> subscribeOrReturn(CoreSubscriber<? super R> actual) {\n+\t\tif (FluxFlatMap.trySubscribeScalarMap(source, actual, mapper, false, true)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTU0MzkxMA=="}, "originalCommit": {"oid": "2f99b8e76eb50084d4ff532284a258fec6be320b"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAzNTMyOA==", "bodyText": "a minor nitpick, and a departure from our usual choice of American English spelling over British English spelling, but we use CANCELLED in most places (all but one actually...), including the public Scannable.Attr.CANCELLED", "url": "https://github.com/reactor/reactor-core/pull/2202#discussion_r447035328", "createdAt": "2020-06-29T14:56:22Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/FluxConcatMapNoPrefetch.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ * Copyright (c) 2020-Present Pivotal Software Inc, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package reactor.core.publisher;\n+\n+import java.util.Objects;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.FluxConcatMap.ConcatMapInner;\n+import reactor.core.publisher.FluxConcatMap.ErrorMode;\n+import reactor.core.publisher.FluxConcatMap.FluxConcatMapSupport;\n+import reactor.core.publisher.FluxConcatMap.WeakScalarSubscription;\n+import reactor.util.annotation.Nullable;\n+import reactor.util.context.Context;\n+\n+/**\n+ * Maps each upstream value into a Publisher and concatenates them into one\n+ * sequence of items.\n+ *\n+ * @param <T> the source value type\n+ * @param <R> the output value type\n+ *\n+ * @see FluxConcatMap\n+ */\n+final class FluxConcatMapNoPrefetch<T, R> extends InternalFluxOperator<T, R> {\n+\n+\tfinal Function<? super T, ? extends Publisher<? extends R>> mapper;\n+\n+\tfinal ErrorMode errorMode;\n+\n+\tFluxConcatMapNoPrefetch(\n+\t\t\tFlux<? extends T> source,\n+\t\t\tFunction<? super T, ? extends Publisher<? extends R>> mapper,\n+\t\t\tErrorMode errorMode\n+\t) {\n+\t\tsuper(source);\n+\t\tthis.mapper = Objects.requireNonNull(mapper, \"mapper\");\n+\t\tthis.errorMode = errorMode;\n+\t}\n+\n+\t@Override\n+\tpublic CoreSubscriber<? super T> subscribeOrReturn(CoreSubscriber<? super R> actual) {\n+\t\tif (FluxFlatMap.trySubscribeScalarMap(source, actual, mapper, false, true)) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\treturn new FluxConcatMapNoPrefetchSubscriber<>(actual, mapper, errorMode);\n+\t}\n+\n+\tstatic final class FluxConcatMapNoPrefetchSubscriber<T, R> implements FluxConcatMapSupport<T, R> {\n+\n+\t\tenum State {\n+\t\t\tINITIAL,\n+\t\t\t/**\n+\t\t\t * Requested from {@link #upstream}, waiting for {@link #onNext(Object)}\n+\t\t\t */\n+\t\t\tREQUESTED,\n+\t\t\t/**\n+\t\t\t * {@link #onNext(Object)} received, listening on {@link #inner}\n+\t\t\t */\n+\t\t\tACTIVE,\n+\t\t\t/**\n+\t\t\t * Received outer {@link #onComplete()}, waiting for {@link #inner} to complete\n+\t\t\t */\n+\t\t\tLAST_ACTIVE,\n+\t\t\t/**\n+\t\t\t * Terminated either successfully or after an error\n+\t\t\t */\n+\t\t\tTERMINATED,\n+\t\t\tCANCELED,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f57fa020f8fb635f4c2e5372970912561dc25d9"}, "originalPosition": 87}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3ec9518e593154af18962d86d6cf5930e0d5f544", "author": {"user": {"login": "bsideup", "name": "Sergei Egorov"}}, "url": "https://github.com/reactor/reactor-core/commit/3ec9518e593154af18962d86d6cf5930e0d5f544", "committedDate": "2020-06-30T08:50:11Z", "message": "`CANCELED` -> `CANCELLED`"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cb587aa1d28ab1545308306203761f60f8f3c940", "author": {"user": {"login": "bsideup", "name": "Sergei Egorov"}}, "url": "https://github.com/reactor/reactor-core/commit/cb587aa1d28ab1545308306203761f60f8f3c940", "committedDate": "2020-06-30T08:51:19Z", "message": "`wrap` -> `from`"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwNjYzNzc5", "url": "https://github.com/reactor/reactor-core/pull/2202#pullrequestreview-440663779", "createdAt": "2020-07-01T08:39:15Z", "commit": {"oid": "cb587aa1d28ab1545308306203761f60f8f3c940"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2999, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}