{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIyNTM4ODUw", "number": 2492, "reviewThreads": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQwOTozMjoyMVrOE6eecg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNjoyNToyMlrOE7IqOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5NzUyMTc4OnYy", "diffSide": "RIGHT", "path": "reactor-core/src/test/java/reactor/test/LoggerUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQwOTozMjoyMVrOH1kvZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxMDowMzo1NlrOH1mDtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTkzODUzNQ==", "bodyText": "since we don't need classWithLogger I'd remove that parameter here and in resetAppender. The class is public but in the /test sourceset so this shouldn't be an issue. (although the end goal is to make this part of reactor-test prod sourceset)", "url": "https://github.com/reactor/reactor-core/pull/2492#discussion_r525938535", "createdAt": "2020-11-18T09:32:21Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/test/java/reactor/test/LoggerUtils.java", "diffHunk": "@@ -1,59 +1,208 @@\n package reactor.test;\n \n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+\n import ch.qos.logback.classic.Level;\n-import ch.qos.logback.classic.Logger;\n import ch.qos.logback.classic.pattern.ThrowableProxyConverter;\n import ch.qos.logback.classic.spi.ILoggingEvent;\n import ch.qos.logback.core.UnsynchronizedAppenderBase;\n-import org.slf4j.LoggerFactory;\n import reactor.test.util.TestLogger;\n+import reactor.util.Logger;\n+import reactor.util.Loggers;\n \n public class LoggerUtils {\n-\tstatic final String TEST_APPENDER_NAME = \"TestAppender\";\n+\tprivate static TestLogger testLogger;\n \n \tpublic static void addAppender(TestLogger testLogger, Class<?> classWithLogger) {\n-\t\torg.slf4j.Logger slf4jLogger = LoggerFactory.getLogger(classWithLogger);\n-\t\tif (slf4jLogger instanceof Logger) {\n-\t\t\tLogger logbackLogger = (Logger) slf4jLogger;\n-\t\t\tTestAppender appender = new TestAppender(testLogger);\n-\t\t\tappender.start();\n-\t\t\tlogbackLogger.addAppender(appender);\n-\t\t}\n+\t\tLoggerUtils.testLogger = testLogger;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "065378d00adcd05262bafbdf6ed6ad8cdd5e094c"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk2MDExOA==", "bodyText": "I think there is still value to provide a TestLogger as opposed to letting the method create one internally and return it. see comment about tuning logging levels.", "url": "https://github.com/reactor/reactor-core/pull/2492#discussion_r525960118", "createdAt": "2020-11-18T10:03:56Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/test/java/reactor/test/LoggerUtils.java", "diffHunk": "@@ -1,59 +1,208 @@\n package reactor.test;\n \n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+\n import ch.qos.logback.classic.Level;\n-import ch.qos.logback.classic.Logger;\n import ch.qos.logback.classic.pattern.ThrowableProxyConverter;\n import ch.qos.logback.classic.spi.ILoggingEvent;\n import ch.qos.logback.core.UnsynchronizedAppenderBase;\n-import org.slf4j.LoggerFactory;\n import reactor.test.util.TestLogger;\n+import reactor.util.Logger;\n+import reactor.util.Loggers;\n \n public class LoggerUtils {\n-\tstatic final String TEST_APPENDER_NAME = \"TestAppender\";\n+\tprivate static TestLogger testLogger;\n \n \tpublic static void addAppender(TestLogger testLogger, Class<?> classWithLogger) {\n-\t\torg.slf4j.Logger slf4jLogger = LoggerFactory.getLogger(classWithLogger);\n-\t\tif (slf4jLogger instanceof Logger) {\n-\t\t\tLogger logbackLogger = (Logger) slf4jLogger;\n-\t\t\tTestAppender appender = new TestAppender(testLogger);\n-\t\t\tappender.start();\n-\t\t\tlogbackLogger.addAppender(appender);\n-\t\t}\n+\t\tLoggerUtils.testLogger = testLogger;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTkzODUzNQ=="}, "originalCommit": {"oid": "065378d00adcd05262bafbdf6ed6ad8cdd5e094c"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5NzU3MDE5OnYy", "diffSide": "RIGHT", "path": "reactor-core/src/test/java/reactor/test/LoggerUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQwOTo0Mzo0NVrOH1lM-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQwOTo0Mzo0NVrOH1lM-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk0NjEwNA==", "bodyText": "rather than using reflexion maybe we should look into making Loggers return the previous factory ? or at least a Function<String, Logger> getCurrentFactory() getter?", "url": "https://github.com/reactor/reactor-core/pull/2492#discussion_r525946104", "createdAt": "2020-11-18T09:43:45Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/test/java/reactor/test/LoggerUtils.java", "diffHunk": "@@ -1,59 +1,208 @@\n package reactor.test;\n \n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+\n import ch.qos.logback.classic.Level;\n-import ch.qos.logback.classic.Logger;\n import ch.qos.logback.classic.pattern.ThrowableProxyConverter;\n import ch.qos.logback.classic.spi.ILoggingEvent;\n import ch.qos.logback.core.UnsynchronizedAppenderBase;\n-import org.slf4j.LoggerFactory;\n import reactor.test.util.TestLogger;\n+import reactor.util.Logger;\n+import reactor.util.Loggers;\n \n public class LoggerUtils {\n-\tstatic final String TEST_APPENDER_NAME = \"TestAppender\";\n+\tprivate static TestLogger testLogger;\n \n \tpublic static void addAppender(TestLogger testLogger, Class<?> classWithLogger) {\n-\t\torg.slf4j.Logger slf4jLogger = LoggerFactory.getLogger(classWithLogger);\n-\t\tif (slf4jLogger instanceof Logger) {\n-\t\t\tLogger logbackLogger = (Logger) slf4jLogger;\n-\t\t\tTestAppender appender = new TestAppender(testLogger);\n-\t\t\tappender.start();\n-\t\t\tlogbackLogger.addAppender(appender);\n-\t\t}\n+\t\tLoggerUtils.testLogger = testLogger;\n \t}\n \n \tpublic static void resetAppender(Class<?> classWithLogger) {\n-\t\torg.slf4j.Logger slf4jLogger = LoggerFactory.getLogger(classWithLogger);\n-\t\tif (slf4jLogger instanceof Logger) {\n-\t\t\tLogger logbackLogger = (Logger) slf4jLogger;\n-\t\t\tlogbackLogger.detachAppender(TEST_APPENDER_NAME);\n+\t\tLoggerUtils.testLogger = null;\n+\t}\n+\n+\tpublic static void installQueryableLogger() {\n+\t\tLoggers.resetLoggerFactory();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "065378d00adcd05262bafbdf6ed6ad8cdd5e094c"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5NzYyNTAzOnYy", "diffSide": "RIGHT", "path": "reactor-core/src/test/java/reactor/test/LoggerUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQwOTo1NTo0OFrOH1ltyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQwOTo1NTo0OFrOH1ltyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk1NDUwNg==", "bodyText": "another interesting feature that this opens up is to \"force\" a logging level via the TestLogger. This can be done in a separate issue, but if TestLogger was to have configurable loglevel, isXxxEnabled here could be an OR combination of the delegate and the root TestLogger. A special TestLogger subclass for the DivertingLogger could even have a Map<String, LogLevel> internally, to selectively filter out logs from some sources.", "url": "https://github.com/reactor/reactor-core/pull/2492#discussion_r525954506", "createdAt": "2020-11-18T09:55:48Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/test/java/reactor/test/LoggerUtils.java", "diffHunk": "@@ -1,59 +1,208 @@\n package reactor.test;\n \n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+\n import ch.qos.logback.classic.Level;\n-import ch.qos.logback.classic.Logger;\n import ch.qos.logback.classic.pattern.ThrowableProxyConverter;\n import ch.qos.logback.classic.spi.ILoggingEvent;\n import ch.qos.logback.core.UnsynchronizedAppenderBase;\n-import org.slf4j.LoggerFactory;\n import reactor.test.util.TestLogger;\n+import reactor.util.Logger;\n+import reactor.util.Loggers;\n \n public class LoggerUtils {\n-\tstatic final String TEST_APPENDER_NAME = \"TestAppender\";\n+\tprivate static TestLogger testLogger;\n \n \tpublic static void addAppender(TestLogger testLogger, Class<?> classWithLogger) {\n-\t\torg.slf4j.Logger slf4jLogger = LoggerFactory.getLogger(classWithLogger);\n-\t\tif (slf4jLogger instanceof Logger) {\n-\t\t\tLogger logbackLogger = (Logger) slf4jLogger;\n-\t\t\tTestAppender appender = new TestAppender(testLogger);\n-\t\t\tappender.start();\n-\t\t\tlogbackLogger.addAppender(appender);\n-\t\t}\n+\t\tLoggerUtils.testLogger = testLogger;\n \t}\n \n \tpublic static void resetAppender(Class<?> classWithLogger) {\n-\t\torg.slf4j.Logger slf4jLogger = LoggerFactory.getLogger(classWithLogger);\n-\t\tif (slf4jLogger instanceof Logger) {\n-\t\t\tLogger logbackLogger = (Logger) slf4jLogger;\n-\t\t\tlogbackLogger.detachAppender(TEST_APPENDER_NAME);\n+\t\tLoggerUtils.testLogger = null;\n+\t}\n+\n+\tpublic static void installQueryableLogger() {\n+\t\tLoggers.resetLoggerFactory();\n+\t\ttry {\n+\t\t\tField lfField = Loggers.class.getDeclaredField(\"LOGGER_FACTORY\");\n+\t\t\tlfField.setAccessible(true);\n+\t\t\tObject factoryObject = lfField.get(Loggers.class);\n+\t\t\tMethod factoryMethod = factoryObject.getClass().getMethod(\"getLogger\", String.class);\n+\t\t\tfactoryMethod.setAccessible(true);\n+\n+\t\t\tLoggers.useCustomLoggers(category -> {\n+\t\t\t\ttry {\n+\t\t\t\t\tLogger original = (Logger) factoryMethod.invoke(factoryObject, category);\n+\t\t\t\t\treturn new DivertingLogger(original);\n+\t\t\t\t}\n+\t\t\t\tcatch (IllegalAccessException | InvocationTargetException e) {\n+\t\t\t\t\tthrow new RuntimeException(e);\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\t\tcatch (NoSuchFieldException | IllegalAccessException | NoSuchMethodException e) {\n+\t\t\tthrow new RuntimeException(\"Could not install custom logger\", e);\n \t\t}\n \t}\n \n-\tstatic class TestAppender extends UnsynchronizedAppenderBase<ILoggingEvent> {\n+\tprivate static class DivertingLogger implements reactor.util.Logger {\n+\n+\t\tprivate final reactor.util.Logger delegate;\n \n-\t\tprivate final TestLogger testLogger;\n-\t\tprivate final ThrowableProxyConverter throwableProxyConverter = new ThrowableProxyConverter();\n+\t\tprivate DivertingLogger(Logger delegate) {\n+\t\t\tthis.delegate = delegate;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String getName() {\n+\t\t\treturn delegate.getName();\n+\t\t}\n \n-\t\tTestAppender(TestLogger testLogger) {\n-\t\t\tthis.testLogger = testLogger;\n+\t\t@Override\n+\t\tpublic boolean isTraceEnabled() {\n+\t\t\treturn delegate.isTraceEnabled();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "065378d00adcd05262bafbdf6ed6ad8cdd5e094c"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5NzYyOTQ0OnYy", "diffSide": "RIGHT", "path": "reactor-core/src/test/java/reactor/test/LoggerUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQwOTo1Njo1MlrOH1lwpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNjoyNjoyMlrOH2m4Qw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk1NTIzOA==", "bodyText": "maybe add a global parameter along testLogger to decide whether or not the delegate should also receive log instructions", "url": "https://github.com/reactor/reactor-core/pull/2492#discussion_r525955238", "createdAt": "2020-11-18T09:56:52Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/test/java/reactor/test/LoggerUtils.java", "diffHunk": "@@ -1,59 +1,208 @@\n package reactor.test;\n \n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+\n import ch.qos.logback.classic.Level;\n-import ch.qos.logback.classic.Logger;\n import ch.qos.logback.classic.pattern.ThrowableProxyConverter;\n import ch.qos.logback.classic.spi.ILoggingEvent;\n import ch.qos.logback.core.UnsynchronizedAppenderBase;\n-import org.slf4j.LoggerFactory;\n import reactor.test.util.TestLogger;\n+import reactor.util.Logger;\n+import reactor.util.Loggers;\n \n public class LoggerUtils {\n-\tstatic final String TEST_APPENDER_NAME = \"TestAppender\";\n+\tprivate static TestLogger testLogger;\n \n \tpublic static void addAppender(TestLogger testLogger, Class<?> classWithLogger) {\n-\t\torg.slf4j.Logger slf4jLogger = LoggerFactory.getLogger(classWithLogger);\n-\t\tif (slf4jLogger instanceof Logger) {\n-\t\t\tLogger logbackLogger = (Logger) slf4jLogger;\n-\t\t\tTestAppender appender = new TestAppender(testLogger);\n-\t\t\tappender.start();\n-\t\t\tlogbackLogger.addAppender(appender);\n-\t\t}\n+\t\tLoggerUtils.testLogger = testLogger;\n \t}\n \n \tpublic static void resetAppender(Class<?> classWithLogger) {\n-\t\torg.slf4j.Logger slf4jLogger = LoggerFactory.getLogger(classWithLogger);\n-\t\tif (slf4jLogger instanceof Logger) {\n-\t\t\tLogger logbackLogger = (Logger) slf4jLogger;\n-\t\t\tlogbackLogger.detachAppender(TEST_APPENDER_NAME);\n+\t\tLoggerUtils.testLogger = null;\n+\t}\n+\n+\tpublic static void installQueryableLogger() {\n+\t\tLoggers.resetLoggerFactory();\n+\t\ttry {\n+\t\t\tField lfField = Loggers.class.getDeclaredField(\"LOGGER_FACTORY\");\n+\t\t\tlfField.setAccessible(true);\n+\t\t\tObject factoryObject = lfField.get(Loggers.class);\n+\t\t\tMethod factoryMethod = factoryObject.getClass().getMethod(\"getLogger\", String.class);\n+\t\t\tfactoryMethod.setAccessible(true);\n+\n+\t\t\tLoggers.useCustomLoggers(category -> {\n+\t\t\t\ttry {\n+\t\t\t\t\tLogger original = (Logger) factoryMethod.invoke(factoryObject, category);\n+\t\t\t\t\treturn new DivertingLogger(original);\n+\t\t\t\t}\n+\t\t\t\tcatch (IllegalAccessException | InvocationTargetException e) {\n+\t\t\t\t\tthrow new RuntimeException(e);\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\t\tcatch (NoSuchFieldException | IllegalAccessException | NoSuchMethodException e) {\n+\t\t\tthrow new RuntimeException(\"Could not install custom logger\", e);\n \t\t}\n \t}\n \n-\tstatic class TestAppender extends UnsynchronizedAppenderBase<ILoggingEvent> {\n+\tprivate static class DivertingLogger implements reactor.util.Logger {\n+\n+\t\tprivate final reactor.util.Logger delegate;\n \n-\t\tprivate final TestLogger testLogger;\n-\t\tprivate final ThrowableProxyConverter throwableProxyConverter = new ThrowableProxyConverter();\n+\t\tprivate DivertingLogger(Logger delegate) {\n+\t\t\tthis.delegate = delegate;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String getName() {\n+\t\t\treturn delegate.getName();\n+\t\t}\n \n-\t\tTestAppender(TestLogger testLogger) {\n-\t\t\tthis.testLogger = testLogger;\n+\t\t@Override\n+\t\tpublic boolean isTraceEnabled() {\n+\t\t\treturn delegate.isTraceEnabled();\n \t\t}\n \n \t\t@Override\n-\t\tprotected void append(ILoggingEvent eventObject) {\n-\t\t\tif (eventObject.getLevel() == Level.ERROR) {\n-\t\t\t\ttestLogger.error(eventObject.getFormattedMessage()\n-\t\t\t\t                            .concat(\"\\n\")\n-\t\t\t\t                            .concat(throwableProxyConverter.convert(eventObject)));\n+\t\tpublic void trace(String msg) {\n+\t\t\tif (LoggerUtils.testLogger != null) {\n+\t\t\t\tLoggerUtils.testLogger.trace(msg);\n+\t\t\t}\n+\t\t\tdelegate.trace(msg);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "065378d00adcd05262bafbdf6ed6ad8cdd5e094c"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAyMjE0Nw==", "bodyText": "defering this until somebody actually \"complains\" about the double output", "url": "https://github.com/reactor/reactor-core/pull/2492#discussion_r527022147", "createdAt": "2020-11-19T16:26:22Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/test/java/reactor/test/LoggerUtils.java", "diffHunk": "@@ -1,59 +1,208 @@\n package reactor.test;\n \n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+\n import ch.qos.logback.classic.Level;\n-import ch.qos.logback.classic.Logger;\n import ch.qos.logback.classic.pattern.ThrowableProxyConverter;\n import ch.qos.logback.classic.spi.ILoggingEvent;\n import ch.qos.logback.core.UnsynchronizedAppenderBase;\n-import org.slf4j.LoggerFactory;\n import reactor.test.util.TestLogger;\n+import reactor.util.Logger;\n+import reactor.util.Loggers;\n \n public class LoggerUtils {\n-\tstatic final String TEST_APPENDER_NAME = \"TestAppender\";\n+\tprivate static TestLogger testLogger;\n \n \tpublic static void addAppender(TestLogger testLogger, Class<?> classWithLogger) {\n-\t\torg.slf4j.Logger slf4jLogger = LoggerFactory.getLogger(classWithLogger);\n-\t\tif (slf4jLogger instanceof Logger) {\n-\t\t\tLogger logbackLogger = (Logger) slf4jLogger;\n-\t\t\tTestAppender appender = new TestAppender(testLogger);\n-\t\t\tappender.start();\n-\t\t\tlogbackLogger.addAppender(appender);\n-\t\t}\n+\t\tLoggerUtils.testLogger = testLogger;\n \t}\n \n \tpublic static void resetAppender(Class<?> classWithLogger) {\n-\t\torg.slf4j.Logger slf4jLogger = LoggerFactory.getLogger(classWithLogger);\n-\t\tif (slf4jLogger instanceof Logger) {\n-\t\t\tLogger logbackLogger = (Logger) slf4jLogger;\n-\t\t\tlogbackLogger.detachAppender(TEST_APPENDER_NAME);\n+\t\tLoggerUtils.testLogger = null;\n+\t}\n+\n+\tpublic static void installQueryableLogger() {\n+\t\tLoggers.resetLoggerFactory();\n+\t\ttry {\n+\t\t\tField lfField = Loggers.class.getDeclaredField(\"LOGGER_FACTORY\");\n+\t\t\tlfField.setAccessible(true);\n+\t\t\tObject factoryObject = lfField.get(Loggers.class);\n+\t\t\tMethod factoryMethod = factoryObject.getClass().getMethod(\"getLogger\", String.class);\n+\t\t\tfactoryMethod.setAccessible(true);\n+\n+\t\t\tLoggers.useCustomLoggers(category -> {\n+\t\t\t\ttry {\n+\t\t\t\t\tLogger original = (Logger) factoryMethod.invoke(factoryObject, category);\n+\t\t\t\t\treturn new DivertingLogger(original);\n+\t\t\t\t}\n+\t\t\t\tcatch (IllegalAccessException | InvocationTargetException e) {\n+\t\t\t\t\tthrow new RuntimeException(e);\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\t\tcatch (NoSuchFieldException | IllegalAccessException | NoSuchMethodException e) {\n+\t\t\tthrow new RuntimeException(\"Could not install custom logger\", e);\n \t\t}\n \t}\n \n-\tstatic class TestAppender extends UnsynchronizedAppenderBase<ILoggingEvent> {\n+\tprivate static class DivertingLogger implements reactor.util.Logger {\n+\n+\t\tprivate final reactor.util.Logger delegate;\n \n-\t\tprivate final TestLogger testLogger;\n-\t\tprivate final ThrowableProxyConverter throwableProxyConverter = new ThrowableProxyConverter();\n+\t\tprivate DivertingLogger(Logger delegate) {\n+\t\t\tthis.delegate = delegate;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String getName() {\n+\t\t\treturn delegate.getName();\n+\t\t}\n \n-\t\tTestAppender(TestLogger testLogger) {\n-\t\t\tthis.testLogger = testLogger;\n+\t\t@Override\n+\t\tpublic boolean isTraceEnabled() {\n+\t\t\treturn delegate.isTraceEnabled();\n \t\t}\n \n \t\t@Override\n-\t\tprotected void append(ILoggingEvent eventObject) {\n-\t\t\tif (eventObject.getLevel() == Level.ERROR) {\n-\t\t\t\ttestLogger.error(eventObject.getFormattedMessage()\n-\t\t\t\t                            .concat(\"\\n\")\n-\t\t\t\t                            .concat(throwableProxyConverter.convert(eventObject)));\n+\t\tpublic void trace(String msg) {\n+\t\t\tif (LoggerUtils.testLogger != null) {\n+\t\t\t\tLoggerUtils.testLogger.trace(msg);\n+\t\t\t}\n+\t\t\tdelegate.trace(msg);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk1NTIzOA=="}, "originalCommit": {"oid": "065378d00adcd05262bafbdf6ed6ad8cdd5e094c"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5NzYzMTQxOnYy", "diffSide": "LEFT", "path": "reactor-core/src/test/java/reactor/test/publisher/BaseOperatorTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQwOTo1NzoxNlrOH1lx3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQwOTo1NzoxNlrOH1lx3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk1NTU0OQ==", "bodyText": "yeah this is dead code, but it should be done in a separate PR", "url": "https://github.com/reactor/reactor-core/pull/2492#discussion_r525955549", "createdAt": "2020-11-18T09:57:16Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/test/java/reactor/test/publisher/BaseOperatorTest.java", "diffHunk": "@@ -440,40 +440,6 @@ public I next() {\n \t\t}\n \t}\n \n-\tfinal <S extends OperatorScenario<I, PI, O, PO>> void forEachScenario(List<S> scenarios,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "065378d00adcd05262bafbdf6ed6ad8cdd5e094c"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5NzY1Mjg1OnYy", "diffSide": "RIGHT", "path": "reactor-core/src/main/java/reactor/util/Loggers.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxMDowMjoxM1rOH1l_gA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxMDowMjoxM1rOH1l_gA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk1OTA0MA==", "bodyText": "why removing the finals in this file ?", "url": "https://github.com/reactor/reactor-core/pull/2492#discussion_r525959040", "createdAt": "2020-11-18T10:02:13Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/util/Loggers.java", "diffHunk": "@@ -64,7 +64,7 @@\n \t * @see #useConsoleLoggers()\n \t * @see #useVerboseConsoleLoggers()\n \t */\n-\tpublic static final void resetLoggerFactory() {\n+\tpublic static void resetLoggerFactory() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "065378d00adcd05262bafbdf6ed6ad8cdd5e094c"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5NzY1NDg3OnYy", "diffSide": "RIGHT", "path": "reactor-core/src/test/java/reactor/core/publisher/OperatorsTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxMDowMjo0N1rOH1mA0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxMDowMjo0N1rOH1mA0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk1OTM3Nw==", "bodyText": "(need a TODO to complete this test, no assertion)", "url": "https://github.com/reactor/reactor-core/pull/2492#discussion_r525959377", "createdAt": "2020-11-18T10:02:47Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/test/java/reactor/core/publisher/OperatorsTest.java", "diffHunk": "@@ -972,4 +972,11 @@ public void reportThrowInSubscribeWithFuseableErrorResumed() {\n \n \t\tassertSubscriber.assertNoError().awaitAndAssertNextValues(123);\n \t}\n+\n+\t@Test\n+\tpublic void onDiscardCallbackErrorsLog() {\n+\t\tContext context = Operators.enableOnDiscard(Context.empty(), t -> {throw new RuntimeException(\"Boom\");});\n+\t\tOperators.onDiscard(\"Foo\", context);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "065378d00adcd05262bafbdf6ed6ad8cdd5e094c"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwMjc4MDUzOnYy", "diffSide": "RIGHT", "path": "reactor-core/src/test/java/reactor/test/LoggerUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxMDozNjoyNFrOH2WuXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxMDozNjoyNFrOH2WuXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc1NzQ2OA==", "bodyText": "for the condition, capture the testLogger into a local variable (the testLogger could be nulled out between the != null test and the isTraceEnabled() call)", "url": "https://github.com/reactor/reactor-core/pull/2492#discussion_r526757468", "createdAt": "2020-11-19T10:36:24Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/test/java/reactor/test/LoggerUtils.java", "diffHunk": "@@ -62,7 +68,7 @@ public String getName() {\n \n \t\t@Override\n \t\tpublic boolean isTraceEnabled() {\n-\t\t\treturn delegate.isTraceEnabled();\n+\t\t\treturn delegate.isTraceEnabled() || (LoggerUtils.testLogger != null && LoggerUtils.testLogger.isTraceEnabled());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3786997bbe39d8b08ad707c7669133b5a4c0be16"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwMjgyNTQ3OnYy", "diffSide": "RIGHT", "path": "reactor-core/src/test/java/reactor/test/LoggerUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxMDo0NzowOVrOH2XJSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxMDo0NzowOVrOH2XJSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc2NDM2Mw==", "bodyText": "same comment as above about testLogger capture", "url": "https://github.com/reactor/reactor-core/pull/2492#discussion_r526764363", "createdAt": "2020-11-19T10:47:09Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/test/java/reactor/test/LoggerUtils.java", "diffHunk": "@@ -1,59 +1,214 @@\n package reactor.test;\n \n-import ch.qos.logback.classic.Level;\n-import ch.qos.logback.classic.Logger;\n-import ch.qos.logback.classic.pattern.ThrowableProxyConverter;\n-import ch.qos.logback.classic.spi.ILoggingEvent;\n-import ch.qos.logback.core.UnsynchronizedAppenderBase;\n-import org.slf4j.LoggerFactory;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.function.Function;\n+\n import reactor.test.util.TestLogger;\n+import reactor.util.Logger;\n+import reactor.util.Loggers;\n \n public class LoggerUtils {\n-\tstatic final String TEST_APPENDER_NAME = \"TestAppender\";\n+\tprivate static Logger testLogger;\n \n-\tpublic static void addAppender(TestLogger testLogger, Class<?> classWithLogger) {\n-\t\torg.slf4j.Logger slf4jLogger = LoggerFactory.getLogger(classWithLogger);\n-\t\tif (slf4jLogger instanceof Logger) {\n-\t\t\tLogger logbackLogger = (Logger) slf4jLogger;\n-\t\t\tTestAppender appender = new TestAppender(testLogger);\n-\t\t\tappender.start();\n-\t\t\tlogbackLogger.addAppender(appender);\n-\t\t}\n+\tpublic static void installAdditionalLogger(Logger testLogger) {\n+\t\tLoggerUtils.testLogger = testLogger;\n \t}\n \n-\tpublic static void resetAppender(Class<?> classWithLogger) {\n-\t\torg.slf4j.Logger slf4jLogger = LoggerFactory.getLogger(classWithLogger);\n-\t\tif (slf4jLogger instanceof Logger) {\n-\t\t\tLogger logbackLogger = (Logger) slf4jLogger;\n-\t\t\tlogbackLogger.detachAppender(TEST_APPENDER_NAME);\n+\tpublic static void resetAdditionalLogger() {\n+\t\tLoggerUtils.testLogger = null;\n+\t}\n+\n+\t/**\n+\t * Sets a {@link Loggers#useCustomLoggers(Function) logger factory} that will return loggers that not only use the\n+\t * original logging framework used by reactor, but also use the logger set via {@link #installAdditionalLogger(Logger)}, irrespective\n+\t * of its name or how it was obtained. The expectation here is that tests that want to assess that something is\n+\t * logged by reactor will pass a {@link TestLogger} instance to {@link #installAdditionalLogger(Logger)}, trigger the operation\n+\t * under scrutiny, assert the logger contents and reset state by calling {@link #resetAdditionalLogger()}.\n+\t */\n+\tpublic static void setupDivertingLoggerFactory() {\n+\t\ttry {\n+\t\t\tField lfField = Loggers.class.getDeclaredField(\"LOGGER_FACTORY\");\n+\t\t\tlfField.setAccessible(true);\n+\t\t\tObject factoryObject = lfField.get(Loggers.class);\n+\t\t\tMethod factoryMethod = factoryObject.getClass().getMethod(\"getLogger\", String.class);\n+\t\t\tfactoryMethod.setAccessible(true);\n+\n+\t\t\tLoggers.useCustomLoggers(category -> {\n+\t\t\t\ttry {\n+\t\t\t\t\tLogger original = (Logger) factoryMethod.invoke(factoryObject, category);\n+\t\t\t\t\treturn new DivertingLogger(original);\n+\t\t\t\t}\n+\t\t\t\tcatch (IllegalAccessException | InvocationTargetException e) {\n+\t\t\t\t\tthrow new RuntimeException(e);\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\t\tcatch (NoSuchFieldException | IllegalAccessException | NoSuchMethodException e) {\n+\t\t\tthrow new RuntimeException(\"Could not install custom logger\", e);\n \t\t}\n \t}\n \n-\tstatic class TestAppender extends UnsynchronizedAppenderBase<ILoggingEvent> {\n+\t/**\n+\t * A Logger that behaves like its {@link #delegate} but also logs to {@link LoggerUtils#testLogger} if it is set.\n+\t */\n+\tprivate static class DivertingLogger implements reactor.util.Logger {\n+\n+\t\tprivate final reactor.util.Logger delegate;\n \n-\t\tprivate final TestLogger testLogger;\n-\t\tprivate final ThrowableProxyConverter throwableProxyConverter = new ThrowableProxyConverter();\n+\t\tprivate DivertingLogger(Logger delegate) {\n+\t\t\tthis.delegate = delegate;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String getName() {\n+\t\t\treturn delegate.getName();\n+\t\t}\n \n-\t\tTestAppender(TestLogger testLogger) {\n-\t\t\tthis.testLogger = testLogger;\n+\t\t@Override\n+\t\tpublic boolean isTraceEnabled() {\n+\t\t\treturn delegate.isTraceEnabled() || (LoggerUtils.testLogger != null && LoggerUtils.testLogger.isTraceEnabled());\n \t\t}\n \n \t\t@Override\n-\t\tprotected void append(ILoggingEvent eventObject) {\n-\t\t\tif (eventObject.getLevel() == Level.ERROR) {\n-\t\t\t\ttestLogger.error(eventObject.getFormattedMessage()\n-\t\t\t\t                            .concat(\"\\n\")\n-\t\t\t\t                            .concat(throwableProxyConverter.convert(eventObject)));\n+\t\tpublic void trace(String msg) {\n+\t\t\tif (LoggerUtils.testLogger != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3786997bbe39d8b08ad707c7669133b5a4c0be16"}, "originalPosition": 106}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwMjgzMjcxOnYy", "diffSide": "RIGHT", "path": "reactor-core/src/test/java/reactor/test/LoggerUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxMDo0ODo0M1rOH2XNaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxMDo0ODo0M1rOH2XNaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc2NTQxNw==", "bodyText": "I'm on the fence about the method actually setting up the logger factory, vs returning a \"factory\" (as a Function) to pass to Loggers.useCustomLoggers.", "url": "https://github.com/reactor/reactor-core/pull/2492#discussion_r526765417", "createdAt": "2020-11-19T10:48:43Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/test/java/reactor/test/LoggerUtils.java", "diffHunk": "@@ -1,59 +1,214 @@\n package reactor.test;\n \n-import ch.qos.logback.classic.Level;\n-import ch.qos.logback.classic.Logger;\n-import ch.qos.logback.classic.pattern.ThrowableProxyConverter;\n-import ch.qos.logback.classic.spi.ILoggingEvent;\n-import ch.qos.logback.core.UnsynchronizedAppenderBase;\n-import org.slf4j.LoggerFactory;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.function.Function;\n+\n import reactor.test.util.TestLogger;\n+import reactor.util.Logger;\n+import reactor.util.Loggers;\n \n public class LoggerUtils {\n-\tstatic final String TEST_APPENDER_NAME = \"TestAppender\";\n+\tprivate static Logger testLogger;\n \n-\tpublic static void addAppender(TestLogger testLogger, Class<?> classWithLogger) {\n-\t\torg.slf4j.Logger slf4jLogger = LoggerFactory.getLogger(classWithLogger);\n-\t\tif (slf4jLogger instanceof Logger) {\n-\t\t\tLogger logbackLogger = (Logger) slf4jLogger;\n-\t\t\tTestAppender appender = new TestAppender(testLogger);\n-\t\t\tappender.start();\n-\t\t\tlogbackLogger.addAppender(appender);\n-\t\t}\n+\tpublic static void installAdditionalLogger(Logger testLogger) {\n+\t\tLoggerUtils.testLogger = testLogger;\n \t}\n \n-\tpublic static void resetAppender(Class<?> classWithLogger) {\n-\t\torg.slf4j.Logger slf4jLogger = LoggerFactory.getLogger(classWithLogger);\n-\t\tif (slf4jLogger instanceof Logger) {\n-\t\t\tLogger logbackLogger = (Logger) slf4jLogger;\n-\t\t\tlogbackLogger.detachAppender(TEST_APPENDER_NAME);\n+\tpublic static void resetAdditionalLogger() {\n+\t\tLoggerUtils.testLogger = null;\n+\t}\n+\n+\t/**\n+\t * Sets a {@link Loggers#useCustomLoggers(Function) logger factory} that will return loggers that not only use the\n+\t * original logging framework used by reactor, but also use the logger set via {@link #installAdditionalLogger(Logger)}, irrespective\n+\t * of its name or how it was obtained. The expectation here is that tests that want to assess that something is\n+\t * logged by reactor will pass a {@link TestLogger} instance to {@link #installAdditionalLogger(Logger)}, trigger the operation\n+\t * under scrutiny, assert the logger contents and reset state by calling {@link #resetAdditionalLogger()}.\n+\t */\n+\tpublic static void setupDivertingLoggerFactory() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3786997bbe39d8b08ad707c7669133b5a4c0be16"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNDM5OTczOnYy", "diffSide": "RIGHT", "path": "reactor-core/src/test/java/reactor/ReactorTestExecutionListener.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNjoxODowOVrOH2mf3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNjoxODowOVrOH2mf3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAxNTkwMw==", "bodyText": "still needs to remove the call to old reset() method in BaseOperatorTest", "url": "https://github.com/reactor/reactor-core/pull/2492#discussion_r527015903", "createdAt": "2020-11-19T16:18:09Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/test/java/reactor/ReactorTestExecutionListener.java", "diffHunk": "@@ -24,10 +25,21 @@\n import reactor.core.publisher.Hooks;\n import reactor.core.scheduler.Schedulers;\n import reactor.test.AssertionsUtils;\n+import reactor.test.util.LoggerUtils;\n+import reactor.util.Logger;\n \n+/**\n+ * A custom TestExecutionListener that helps with tests in reactor:<ul>\n+ *     <li>resets {@link Hooks} once a test is finished, making sure no dirty state remains,</li>\n+ *     <li>resets {@link Schedulers} related infrastructure, making sure no dirty state remains,</li>\n+ *     <li>installs custom assertJ {@link Representation} for some of reactor types,</li>\n+ *     <li>installs a custom {@link Logger} factory <strong>very</strong> early in the suite lifecycle, so that loggers\n+ *     in reactor (which are typically static members initialized early) can be diverted and asserted in tests.</li>\n+ * </ul>\n+ */\n public class ReactorTestExecutionListener implements TestExecutionListener {\n \n-\tpublic static void reset() {\n+\tprivate static void resetHooksAndSchedulers() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a37d55852eef6a2a7f143fba29baf35ec1d68a8d"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNDQyNTA4OnYy", "diffSide": "RIGHT", "path": "reactor-test/src/main/java/reactor/test/util/LoggerUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNjoyMzo0NFrOH2mwMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNjoyMzo0NFrOH2mwMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAyMDA4Mw==", "bodyText": "nitpick: I'd put the static methods above both static inner classes, and add basic documentation", "url": "https://github.com/reactor/reactor-core/pull/2492#discussion_r527020083", "createdAt": "2020-11-19T16:23:44Z", "author": {"login": "simonbasle"}, "path": "reactor-test/src/main/java/reactor/test/util/LoggerUtils.java", "diffHunk": "@@ -0,0 +1,281 @@\n+package reactor.test.util;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.function.Function;\n+\n+import reactor.core.Disposable;\n+import reactor.util.Logger;\n+import reactor.util.Loggers;\n+\n+/**\n+ * This class eases testing interested in what reactor classes emit using {@link Logger loggers}.\n+ *\n+ * @author Eric Bottard\n+ */\n+public final class LoggerUtils {\n+\tprivate static Logger testLogger;\n+\n+\tprivate LoggerUtils() {\n+\t}\n+\n+\t/**\n+\t * Sets a {@link Loggers#useCustomLoggers(Function) logger factory} that will return loggers that not only use the\n+\t * original logging framework used by reactor, but also use the logger set via {@link #enableCaptureWith(Logger)}, irrespective\n+\t * of its name or how it was obtained. The expectation here is that tests that want to assess that something is\n+\t * logged by reactor will pass a {@link TestLogger} instance to {@link #enableCaptureWith(Logger)}, trigger the operation\n+\t * under scrutiny, assert the logger contents and reset state by calling {@link #disableCapture()}.\n+\t *\n+\t * <p>This method should be called very early in the application/tests lifecycle, before reactor classes have created\n+\t * their loggers.</p>\n+\t *\n+\t * @return a disposable that re-installs the original factory when disposed\n+\t */\n+\tpublic static Disposable useCurrentLoggersWithCapture() {\n+\t\ttry {\n+\t\t\tCapturingFactory capturingFactory = new CapturingFactory();\n+\t\t\tLoggers.useCustomLoggers(capturingFactory);\n+\t\t\treturn capturingFactory;\n+\t\t}\n+\t\tcatch (NoSuchFieldException | IllegalAccessException | NoSuchMethodException e) {\n+\t\t\tthrow new RuntimeException(\"Could not install custom logger\", e);\n+\t\t}\n+\t}\n+\n+\tprivate static class CapturingFactory implements Function<String, Logger>, Disposable {\n+\n+\t\tprivate final Method originalFactoryMethod;\n+\n+\t\tprivate final Object orginalFactory;\n+\n+\t\tprivate CapturingFactory() throws NoSuchFieldException, IllegalAccessException, NoSuchMethodException {\n+\t\t\tField lfField = Loggers.class.getDeclaredField(\"LOGGER_FACTORY\");\n+\t\t\tlfField.setAccessible(true);\n+\t\t\torginalFactory = lfField.get(Loggers.class);\n+\t\t\toriginalFactoryMethod = orginalFactory.getClass().getMethod(\"getLogger\", String.class);\n+\t\t\toriginalFactoryMethod.setAccessible(true);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Logger apply(String category) {\n+\t\t\ttry {\n+\t\t\t\tLogger original = (Logger) originalFactoryMethod.invoke(orginalFactory, category);\n+\t\t\t\treturn new DivertingLogger(original);\n+\t\t\t}\n+\t\t\tcatch (IllegalAccessException | InvocationTargetException e) {\n+\t\t\t\tthrow new RuntimeException(e);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void dispose() {\n+\t\t\ttry {\n+\t\t\t\tField lfField = Loggers.class.getDeclaredField(\"LOGGER_FACTORY\");\n+\t\t\t\tlfField.setAccessible(true);\n+\t\t\t\tObject o = lfField.get(Loggers.class);\n+\n+\t\t\t\tif (!(Loggers.getLogger(LoggerUtils.class) instanceof DivertingLogger)) {\n+\t\t\t\t\tthrow new IllegalStateException(\"Expected the current factory to be \" + this + \", found \" + o + \" instead\");\n+\t\t\t\t}\n+\t\t\t\tlfField.set(Loggers.class, orginalFactory);\n+\t\t\t}\n+\t\t\tcatch (NoSuchFieldException | IllegalAccessException e) {\n+\t\t\t\tthrow new RuntimeException(e);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic static void enableCaptureWith(Logger testLogger) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a37d55852eef6a2a7f143fba29baf35ec1d68a8d"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNDQzMzIzOnYy", "diffSide": "RIGHT", "path": "reactor-test/src/test/java/reactor/test/util/LoggerUtilsTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNjoyNToyMlrOH2m1aA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNjoyNToyMlrOH2m1aA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAyMTQxNg==", "bodyText": "the message should be asserted", "url": "https://github.com/reactor/reactor-core/pull/2492#discussion_r527021416", "createdAt": "2020-11-19T16:25:22Z", "author": {"login": "simonbasle"}, "path": "reactor-test/src/test/java/reactor/test/util/LoggerUtilsTest.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * Copyright (c) 2011-2018 Pivotal Software Inc, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package reactor.test.util;\n+\n+import org.junit.jupiter.api.Test;\n+import reactor.core.Disposable;\n+import reactor.util.Logger;\n+import reactor.util.Loggers;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatExceptionOfType;\n+\n+class LoggerUtilsTest {\n+\n+\t@Test\n+\tvoid installsFactory() {\n+\t\tDisposable disposable = LoggerUtils.useCurrentLoggersWithCapture();\n+\t\tTestLogger testLogger = new TestLogger();\n+\t\ttry {\n+\t\t\tLogger frameworkLogger = Loggers.getLogger(\"category\"); // simulates an early creation of a logger\n+\n+\t\t\tLoggerUtils.enableCaptureWith(testLogger);\n+\t\t\tframeworkLogger.debug(\"Look ma!, I'm debugging!\");\n+\t\t\tassertThat(testLogger.getOutContent()).contains(\"Look ma!, I'm debugging!\");\n+\t\t\tLoggerUtils.disableCapture();\n+\t\t\tframeworkLogger.debug(\"This won't be captured\");\n+\t\t\tassertThat(testLogger.getOutContent()).doesNotContain(\"This won't be captured\");\n+\t\t} finally {\n+\t\t\tdisposable.dispose();\n+\n+\t\t\t// The following tests that once disposed, capturing is no longer in effect\n+\t\t\tLoggerUtils.enableCaptureWith(testLogger);\n+\t\t\tLogger otherLogger = Loggers.getLogger(\"another\");\n+\t\t\totherLogger.debug(\"This won't be captured either\");\n+\t\t\tassertThat(testLogger.getOutContent()).doesNotContain(\"This won't be captured either\");\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tvoid disposeOnlyUninstallsItelf() {\n+\t\tDisposable disposable = LoggerUtils.useCurrentLoggersWithCapture();\n+\t\tassertThatExceptionOfType(IllegalStateException.class).isThrownBy(() -> {\n+\t\t\tLoggers.resetLoggerFactory(); // Overwrites our custom logger\n+\t\t\tdisposable.dispose();\n+\t\t});", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a37d55852eef6a2a7f143fba29baf35ec1d68a8d"}, "originalPosition": 58}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 841, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}