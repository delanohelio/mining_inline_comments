{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkwMTk5Mjc4", "number": 2392, "title": "Add multicast sink with best effort/drop on backpressure", "bodyText": "This commit adds a new Sinks.Many with multicast semantics close to\nDirectProcessor but not quite like it: it doesn't buffer but tries to\npush elements to fast subscribers when encountering a mix of fast and\nslow subscribers. In that case, Emission.OK is returned as soon as at\nleast one subscriber had enough demand to be pushed the value to. If\nnone of the subscribers have demand, then Emission.FAIL_OVERFLOW is\nreturned instead.\nIt can also be configured to fail fast: the whole array of Subscribers\nis checked for demand and if at least one has not enough demand, the\nelement is not pushed at all. In that case, the Emission.FAIL_OVERFLOW\nresult is returned.", "createdAt": "2020-09-21T10:36:20Z", "url": "https://github.com/reactor/reactor-core/pull/2392", "merged": true, "mergeCommit": {"oid": "95cd741a292bcaa31b1cc282b9590ac3a5cf0c80"}, "closed": true, "closedAt": "2020-09-30T14:51:50Z", "author": {"login": "simonbasle"}, "timelineItems": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdLA_2ygFqTQ5MjQ3MDIxOQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdN8brNgBqjM4MjQzODc5MTc=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyNDcwMjE5", "url": "https://github.com/reactor/reactor-core/pull/2392#pullrequestreview-492470219", "createdAt": "2020-09-21T10:40:09Z", "commit": {"oid": "102b2bd8b103cd46f40571054ea1515e5081cad3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxMDo0MDowOVrOHVJ8Yg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxMDo0MDowOVrOHVJ8Yg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk0NTA1OA==", "bodyText": "\"all cancelled\" is not handled", "url": "https://github.com/reactor/reactor-core/pull/2392#discussion_r491945058", "createdAt": "2020-09-21T10:40:09Z", "author": {"login": "bsideup"}, "path": "reactor-core/src/main/java/reactor/core/publisher/SinkManyBestEffort.java", "diffHunk": "@@ -0,0 +1,385 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.stream.Stream;\n+\n+import reactor.core.CoreSubscriber;\n+import reactor.core.Exceptions;\n+import reactor.core.Scannable;\n+import reactor.core.publisher.Sinks.Emission;\n+import reactor.util.annotation.Nullable;\n+import reactor.util.context.Context;\n+\n+/**\n+ * @author Simon Basl\u00e9\n+ */\n+final class SinkManyBestEffort<T> extends Flux<T> implements Sinks.Many<T>, ContextHolder,\n+                                                             Scannable {\n+\n+\tprivate static final Inner[] EMPTY = new Inner[0];\n+\tprivate static final Inner[] TERMINATED = new Inner[0];\n+\n+\tstatic final <T> SinkManyBestEffort<T> createBestEffort() {\n+\t\treturn new SinkManyBestEffort<>(false);\n+\t}\n+\n+\tstatic final <T> SinkManyBestEffort<T> createAllOrNothing() {\n+\t\treturn new SinkManyBestEffort<>(true);\n+\t}\n+\n+\tfinal boolean allOrNothing;\n+\n+\t/**\n+\t * Stores the error that terminated this sink, for immediate replay to late subscribers\n+\t */\n+\tThrowable error;\n+\n+\tvolatile     Inner<T>[]                                               subscribers;\n+\t@SuppressWarnings(\"rawtypes\")\n+\tstatic final AtomicReferenceFieldUpdater<SinkManyBestEffort, Inner[]> SUBSCRIBERS =\n+\t\t\tAtomicReferenceFieldUpdater.newUpdater(SinkManyBestEffort.class, Inner[].class, \"subscribers\");\n+\n+\tSinkManyBestEffort(boolean allOrNothing) {\n+\t\tthis.allOrNothing = allOrNothing;\n+\t\tSUBSCRIBERS.lazySet(this, EMPTY);\n+\t}\n+\n+\tpublic Context currentContext() {\n+\t\treturn Operators.multiSubscribersContext(subscribers);\n+\t}\n+\n+\t@Override\n+\tpublic Stream<? extends Scannable> inners() {\n+\t\treturn Stream.of(subscribers);\n+\t}\n+\n+\t@Nullable\n+\t@Override\n+\tpublic Object scanUnsafe(Attr key) {\n+\t\tif (key == Attr.TERMINATED) return subscribers == TERMINATED;\n+\t\tif (key == Attr.ERROR) return error;\n+\n+\t\treturn null;\n+\t}\n+\n+\t@Override\n+\tpublic Emission tryEmitNext(T t) {\n+\t\tObjects.requireNonNull(t, \"tryEmitNext(null) is forbidden\");\n+\n+\t\tInner<T>[] subs = subscribers;\n+\n+\t\tif (subs == EMPTY) {\n+\t\t\treturn Emission.FAIL_ZERO_SUBSCRIBER;\n+\t\t}\n+\t\tif (subs == TERMINATED) {\n+\t\t\treturn Emission.FAIL_TERMINATED;\n+\t\t}\n+\n+\t\tif (allOrNothing) {\n+\t\t\tlong commonRequest = Long.MAX_VALUE;\n+\t\t\tfor (Inner<T> sub : subs) {\n+\t\t\t\tlong subRequest = sub.requested;\n+\t\t\t\tif (sub.isCancelled()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "102b2bd8b103cd46f40571054ea1515e5081cad3"}, "originalPosition": 101}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyNDcxMTc4", "url": "https://github.com/reactor/reactor-core/pull/2392#pullrequestreview-492471178", "createdAt": "2020-09-21T10:41:42Z", "commit": {"oid": "102b2bd8b103cd46f40571054ea1515e5081cad3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxMDo0MTo0MlrOHVJ_GQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxMDo0MTo0MlrOHVJ_GQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk0NTc1Mw==", "bodyText": "should we even check for cancelled? I assume it would get removed, and we will only get a cancelled instance due to a race, but that's okay to still push things to a cancelled subscription since cancel() is not guaranteed to be instantly delivered", "url": "https://github.com/reactor/reactor-core/pull/2392#discussion_r491945753", "createdAt": "2020-09-21T10:41:42Z", "author": {"login": "bsideup"}, "path": "reactor-core/src/main/java/reactor/core/publisher/SinkManyBestEffort.java", "diffHunk": "@@ -0,0 +1,385 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.stream.Stream;\n+\n+import reactor.core.CoreSubscriber;\n+import reactor.core.Exceptions;\n+import reactor.core.Scannable;\n+import reactor.core.publisher.Sinks.Emission;\n+import reactor.util.annotation.Nullable;\n+import reactor.util.context.Context;\n+\n+/**\n+ * @author Simon Basl\u00e9\n+ */\n+final class SinkManyBestEffort<T> extends Flux<T> implements Sinks.Many<T>, ContextHolder,\n+                                                             Scannable {\n+\n+\tprivate static final Inner[] EMPTY = new Inner[0];\n+\tprivate static final Inner[] TERMINATED = new Inner[0];\n+\n+\tstatic final <T> SinkManyBestEffort<T> createBestEffort() {\n+\t\treturn new SinkManyBestEffort<>(false);\n+\t}\n+\n+\tstatic final <T> SinkManyBestEffort<T> createAllOrNothing() {\n+\t\treturn new SinkManyBestEffort<>(true);\n+\t}\n+\n+\tfinal boolean allOrNothing;\n+\n+\t/**\n+\t * Stores the error that terminated this sink, for immediate replay to late subscribers\n+\t */\n+\tThrowable error;\n+\n+\tvolatile     Inner<T>[]                                               subscribers;\n+\t@SuppressWarnings(\"rawtypes\")\n+\tstatic final AtomicReferenceFieldUpdater<SinkManyBestEffort, Inner[]> SUBSCRIBERS =\n+\t\t\tAtomicReferenceFieldUpdater.newUpdater(SinkManyBestEffort.class, Inner[].class, \"subscribers\");\n+\n+\tSinkManyBestEffort(boolean allOrNothing) {\n+\t\tthis.allOrNothing = allOrNothing;\n+\t\tSUBSCRIBERS.lazySet(this, EMPTY);\n+\t}\n+\n+\tpublic Context currentContext() {\n+\t\treturn Operators.multiSubscribersContext(subscribers);\n+\t}\n+\n+\t@Override\n+\tpublic Stream<? extends Scannable> inners() {\n+\t\treturn Stream.of(subscribers);\n+\t}\n+\n+\t@Nullable\n+\t@Override\n+\tpublic Object scanUnsafe(Attr key) {\n+\t\tif (key == Attr.TERMINATED) return subscribers == TERMINATED;\n+\t\tif (key == Attr.ERROR) return error;\n+\n+\t\treturn null;\n+\t}\n+\n+\t@Override\n+\tpublic Emission tryEmitNext(T t) {\n+\t\tObjects.requireNonNull(t, \"tryEmitNext(null) is forbidden\");\n+\n+\t\tInner<T>[] subs = subscribers;\n+\n+\t\tif (subs == EMPTY) {\n+\t\t\treturn Emission.FAIL_ZERO_SUBSCRIBER;\n+\t\t}\n+\t\tif (subs == TERMINATED) {\n+\t\t\treturn Emission.FAIL_TERMINATED;\n+\t\t}\n+\n+\t\tif (allOrNothing) {\n+\t\t\tlong commonRequest = Long.MAX_VALUE;\n+\t\t\tfor (Inner<T> sub : subs) {\n+\t\t\t\tlong subRequest = sub.requested;\n+\t\t\t\tif (sub.isCancelled()) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t\tif (subRequest < commonRequest) {\n+\t\t\t\t\tcommonRequest = subRequest;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (commonRequest == 0) {\n+\t\t\t\treturn Emission.FAIL_OVERFLOW;\n+\t\t\t}\n+\t\t}\n+\n+\t\tint expectedEmitted = subs.length;\n+\t\tint emittedCount = 0;\n+\t\tint cancelledCount = 0;\n+\t\tfor (Inner<T> sub : subs) {\n+\t\t\tif (sub.isCancelled()) {\n+\t\t\t\tcancelledCount++;\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tif (sub.tryEmitNext(t)) {\n+\t\t\t\temittedCount++;\n+\t\t\t}\n+\t\t\telse if (sub.isCancelled()) {\n+\t\t\t\tcancelledCount++;\n+\t\t\t}\n+\t\t}\n+\t\tif (cancelledCount == expectedEmitted) {\n+\t\t\treturn Emission.FAIL_ZERO_SUBSCRIBER; //TODO should it be FAIL_CANCELLED ? but technically the sink would still be usable", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "102b2bd8b103cd46f40571054ea1515e5081cad3"}, "originalPosition": 129}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyNDcxNzU4", "url": "https://github.com/reactor/reactor-core/pull/2392#pullrequestreview-492471758", "createdAt": "2020-09-21T10:42:40Z", "commit": {"oid": "102b2bd8b103cd46f40571054ea1515e5081cad3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxMDo0Mjo0MFrOHVKA2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxMDo0Mjo0MFrOHVKA2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk0NjIwMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tswitch(tryEmitNext(value)) {\n          \n          \n            \n            \t\tswitch (tryEmitNext(value)) {", "url": "https://github.com/reactor/reactor-core/pull/2392#discussion_r491946202", "createdAt": "2020-09-21T10:42:40Z", "author": {"login": "bsideup"}, "path": "reactor-core/src/main/java/reactor/core/publisher/SinkManyBestEffort.java", "diffHunk": "@@ -0,0 +1,385 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.stream.Stream;\n+\n+import reactor.core.CoreSubscriber;\n+import reactor.core.Exceptions;\n+import reactor.core.Scannable;\n+import reactor.core.publisher.Sinks.Emission;\n+import reactor.util.annotation.Nullable;\n+import reactor.util.context.Context;\n+\n+/**\n+ * @author Simon Basl\u00e9\n+ */\n+final class SinkManyBestEffort<T> extends Flux<T> implements Sinks.Many<T>, ContextHolder,\n+                                                             Scannable {\n+\n+\tprivate static final Inner[] EMPTY = new Inner[0];\n+\tprivate static final Inner[] TERMINATED = new Inner[0];\n+\n+\tstatic final <T> SinkManyBestEffort<T> createBestEffort() {\n+\t\treturn new SinkManyBestEffort<>(false);\n+\t}\n+\n+\tstatic final <T> SinkManyBestEffort<T> createAllOrNothing() {\n+\t\treturn new SinkManyBestEffort<>(true);\n+\t}\n+\n+\tfinal boolean allOrNothing;\n+\n+\t/**\n+\t * Stores the error that terminated this sink, for immediate replay to late subscribers\n+\t */\n+\tThrowable error;\n+\n+\tvolatile     Inner<T>[]                                               subscribers;\n+\t@SuppressWarnings(\"rawtypes\")\n+\tstatic final AtomicReferenceFieldUpdater<SinkManyBestEffort, Inner[]> SUBSCRIBERS =\n+\t\t\tAtomicReferenceFieldUpdater.newUpdater(SinkManyBestEffort.class, Inner[].class, \"subscribers\");\n+\n+\tSinkManyBestEffort(boolean allOrNothing) {\n+\t\tthis.allOrNothing = allOrNothing;\n+\t\tSUBSCRIBERS.lazySet(this, EMPTY);\n+\t}\n+\n+\tpublic Context currentContext() {\n+\t\treturn Operators.multiSubscribersContext(subscribers);\n+\t}\n+\n+\t@Override\n+\tpublic Stream<? extends Scannable> inners() {\n+\t\treturn Stream.of(subscribers);\n+\t}\n+\n+\t@Nullable\n+\t@Override\n+\tpublic Object scanUnsafe(Attr key) {\n+\t\tif (key == Attr.TERMINATED) return subscribers == TERMINATED;\n+\t\tif (key == Attr.ERROR) return error;\n+\n+\t\treturn null;\n+\t}\n+\n+\t@Override\n+\tpublic Emission tryEmitNext(T t) {\n+\t\tObjects.requireNonNull(t, \"tryEmitNext(null) is forbidden\");\n+\n+\t\tInner<T>[] subs = subscribers;\n+\n+\t\tif (subs == EMPTY) {\n+\t\t\treturn Emission.FAIL_ZERO_SUBSCRIBER;\n+\t\t}\n+\t\tif (subs == TERMINATED) {\n+\t\t\treturn Emission.FAIL_TERMINATED;\n+\t\t}\n+\n+\t\tif (allOrNothing) {\n+\t\t\tlong commonRequest = Long.MAX_VALUE;\n+\t\t\tfor (Inner<T> sub : subs) {\n+\t\t\t\tlong subRequest = sub.requested;\n+\t\t\t\tif (sub.isCancelled()) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t\tif (subRequest < commonRequest) {\n+\t\t\t\t\tcommonRequest = subRequest;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (commonRequest == 0) {\n+\t\t\t\treturn Emission.FAIL_OVERFLOW;\n+\t\t\t}\n+\t\t}\n+\n+\t\tint expectedEmitted = subs.length;\n+\t\tint emittedCount = 0;\n+\t\tint cancelledCount = 0;\n+\t\tfor (Inner<T> sub : subs) {\n+\t\t\tif (sub.isCancelled()) {\n+\t\t\t\tcancelledCount++;\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tif (sub.tryEmitNext(t)) {\n+\t\t\t\temittedCount++;\n+\t\t\t}\n+\t\t\telse if (sub.isCancelled()) {\n+\t\t\t\tcancelledCount++;\n+\t\t\t}\n+\t\t}\n+\t\tif (cancelledCount == expectedEmitted) {\n+\t\t\treturn Emission.FAIL_ZERO_SUBSCRIBER; //TODO should it be FAIL_CANCELLED ? but technically the sink would still be usable\n+\t\t}\n+\t\telse if (cancelledCount + emittedCount == expectedEmitted) {\n+\t\t\treturn Emission.OK;\n+\t\t}\n+\t\telse {\n+\t\t\treturn Emission.FAIL_OVERFLOW;\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic Emission tryEmitComplete() {\n+\t\t@SuppressWarnings(\"unchecked\")\n+\t\tInner<T>[] subs = SUBSCRIBERS.getAndSet(this, TERMINATED);\n+\n+\t\tif (subs == TERMINATED) {\n+\t\t\treturn Emission.FAIL_TERMINATED;\n+\t\t}\n+\n+\t\tfor (Inner<?> s : subs) {\n+\t\t\ts.emitComplete();\n+\t\t}\n+\t\treturn Emission.OK;\n+\t}\n+\n+\t@Override\n+\tpublic Emission tryEmitError(Throwable error) {\n+\t\tObjects.requireNonNull(error, \"tryEmitError(null) is forbidden\");\n+\t\t@SuppressWarnings(\"unchecked\")\n+\t\tInner<T>[] subs = SUBSCRIBERS.getAndSet(this, TERMINATED);\n+\n+\t\tif (subs == TERMINATED) {\n+\t\t\treturn Emission.FAIL_TERMINATED;\n+\t\t}\n+\n+\t\tthis.error = error;\n+\n+\t\tfor (Inner<?> s : subs) {\n+\t\t\ts.emitError(error);\n+\t\t}\n+\t\treturn Emission.OK;\n+\t}\n+\n+\t@Override\n+\tpublic void emitComplete() {\n+\t\t//no particular error condition handling for onComplete\n+\t\t@SuppressWarnings(\"unused\")\n+\t\tEmission emission = tryEmitComplete();\n+\t}\n+\n+\t@Override\n+\tpublic void emitError(Throwable error) {\n+\t\tEmission result = tryEmitError(error);\n+\t\tif (result == Emission.FAIL_TERMINATED) {\n+\t\t\tOperators.onErrorDroppedMulticast(error, subscribers);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void emitNext(T value) {\n+\t\tswitch(tryEmitNext(value)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "102b2bd8b103cd46f40571054ea1515e5081cad3"}, "originalPosition": 189}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyNDcyMjQw", "url": "https://github.com/reactor/reactor-core/pull/2392#pullrequestreview-492472240", "createdAt": "2020-09-21T10:43:28Z", "commit": {"oid": "102b2bd8b103cd46f40571054ea1515e5081cad3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxMDo0MzoyOFrOHVKCVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxMDo0MzoyOFrOHVKCVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk0NjU4MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\tcase FAIL_NON_SERIALIZED:\n          \n          \n            \n            \t\t\tdefault:", "url": "https://github.com/reactor/reactor-core/pull/2392#discussion_r491946580", "createdAt": "2020-09-21T10:43:28Z", "author": {"login": "bsideup"}, "path": "reactor-core/src/main/java/reactor/core/publisher/SinkManyBestEffort.java", "diffHunk": "@@ -0,0 +1,385 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.stream.Stream;\n+\n+import reactor.core.CoreSubscriber;\n+import reactor.core.Exceptions;\n+import reactor.core.Scannable;\n+import reactor.core.publisher.Sinks.Emission;\n+import reactor.util.annotation.Nullable;\n+import reactor.util.context.Context;\n+\n+/**\n+ * @author Simon Basl\u00e9\n+ */\n+final class SinkManyBestEffort<T> extends Flux<T> implements Sinks.Many<T>, ContextHolder,\n+                                                             Scannable {\n+\n+\tprivate static final Inner[] EMPTY = new Inner[0];\n+\tprivate static final Inner[] TERMINATED = new Inner[0];\n+\n+\tstatic final <T> SinkManyBestEffort<T> createBestEffort() {\n+\t\treturn new SinkManyBestEffort<>(false);\n+\t}\n+\n+\tstatic final <T> SinkManyBestEffort<T> createAllOrNothing() {\n+\t\treturn new SinkManyBestEffort<>(true);\n+\t}\n+\n+\tfinal boolean allOrNothing;\n+\n+\t/**\n+\t * Stores the error that terminated this sink, for immediate replay to late subscribers\n+\t */\n+\tThrowable error;\n+\n+\tvolatile     Inner<T>[]                                               subscribers;\n+\t@SuppressWarnings(\"rawtypes\")\n+\tstatic final AtomicReferenceFieldUpdater<SinkManyBestEffort, Inner[]> SUBSCRIBERS =\n+\t\t\tAtomicReferenceFieldUpdater.newUpdater(SinkManyBestEffort.class, Inner[].class, \"subscribers\");\n+\n+\tSinkManyBestEffort(boolean allOrNothing) {\n+\t\tthis.allOrNothing = allOrNothing;\n+\t\tSUBSCRIBERS.lazySet(this, EMPTY);\n+\t}\n+\n+\tpublic Context currentContext() {\n+\t\treturn Operators.multiSubscribersContext(subscribers);\n+\t}\n+\n+\t@Override\n+\tpublic Stream<? extends Scannable> inners() {\n+\t\treturn Stream.of(subscribers);\n+\t}\n+\n+\t@Nullable\n+\t@Override\n+\tpublic Object scanUnsafe(Attr key) {\n+\t\tif (key == Attr.TERMINATED) return subscribers == TERMINATED;\n+\t\tif (key == Attr.ERROR) return error;\n+\n+\t\treturn null;\n+\t}\n+\n+\t@Override\n+\tpublic Emission tryEmitNext(T t) {\n+\t\tObjects.requireNonNull(t, \"tryEmitNext(null) is forbidden\");\n+\n+\t\tInner<T>[] subs = subscribers;\n+\n+\t\tif (subs == EMPTY) {\n+\t\t\treturn Emission.FAIL_ZERO_SUBSCRIBER;\n+\t\t}\n+\t\tif (subs == TERMINATED) {\n+\t\t\treturn Emission.FAIL_TERMINATED;\n+\t\t}\n+\n+\t\tif (allOrNothing) {\n+\t\t\tlong commonRequest = Long.MAX_VALUE;\n+\t\t\tfor (Inner<T> sub : subs) {\n+\t\t\t\tlong subRequest = sub.requested;\n+\t\t\t\tif (sub.isCancelled()) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t\tif (subRequest < commonRequest) {\n+\t\t\t\t\tcommonRequest = subRequest;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (commonRequest == 0) {\n+\t\t\t\treturn Emission.FAIL_OVERFLOW;\n+\t\t\t}\n+\t\t}\n+\n+\t\tint expectedEmitted = subs.length;\n+\t\tint emittedCount = 0;\n+\t\tint cancelledCount = 0;\n+\t\tfor (Inner<T> sub : subs) {\n+\t\t\tif (sub.isCancelled()) {\n+\t\t\t\tcancelledCount++;\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tif (sub.tryEmitNext(t)) {\n+\t\t\t\temittedCount++;\n+\t\t\t}\n+\t\t\telse if (sub.isCancelled()) {\n+\t\t\t\tcancelledCount++;\n+\t\t\t}\n+\t\t}\n+\t\tif (cancelledCount == expectedEmitted) {\n+\t\t\treturn Emission.FAIL_ZERO_SUBSCRIBER; //TODO should it be FAIL_CANCELLED ? but technically the sink would still be usable\n+\t\t}\n+\t\telse if (cancelledCount + emittedCount == expectedEmitted) {\n+\t\t\treturn Emission.OK;\n+\t\t}\n+\t\telse {\n+\t\t\treturn Emission.FAIL_OVERFLOW;\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic Emission tryEmitComplete() {\n+\t\t@SuppressWarnings(\"unchecked\")\n+\t\tInner<T>[] subs = SUBSCRIBERS.getAndSet(this, TERMINATED);\n+\n+\t\tif (subs == TERMINATED) {\n+\t\t\treturn Emission.FAIL_TERMINATED;\n+\t\t}\n+\n+\t\tfor (Inner<?> s : subs) {\n+\t\t\ts.emitComplete();\n+\t\t}\n+\t\treturn Emission.OK;\n+\t}\n+\n+\t@Override\n+\tpublic Emission tryEmitError(Throwable error) {\n+\t\tObjects.requireNonNull(error, \"tryEmitError(null) is forbidden\");\n+\t\t@SuppressWarnings(\"unchecked\")\n+\t\tInner<T>[] subs = SUBSCRIBERS.getAndSet(this, TERMINATED);\n+\n+\t\tif (subs == TERMINATED) {\n+\t\t\treturn Emission.FAIL_TERMINATED;\n+\t\t}\n+\n+\t\tthis.error = error;\n+\n+\t\tfor (Inner<?> s : subs) {\n+\t\t\ts.emitError(error);\n+\t\t}\n+\t\treturn Emission.OK;\n+\t}\n+\n+\t@Override\n+\tpublic void emitComplete() {\n+\t\t//no particular error condition handling for onComplete\n+\t\t@SuppressWarnings(\"unused\")\n+\t\tEmission emission = tryEmitComplete();\n+\t}\n+\n+\t@Override\n+\tpublic void emitError(Throwable error) {\n+\t\tEmission result = tryEmitError(error);\n+\t\tif (result == Emission.FAIL_TERMINATED) {\n+\t\t\tOperators.onErrorDroppedMulticast(error, subscribers);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void emitNext(T value) {\n+\t\tswitch(tryEmitNext(value)) {\n+\t\t\tcase FAIL_ZERO_SUBSCRIBER:\n+\t\t\t\t//we want to \"discard\" without rendering the sink terminated.\n+\t\t\t\t// effectively NO-OP cause there's no subscriber, so no context :(\n+\t\t\t\tbreak;\n+\t\t\tcase FAIL_OVERFLOW:\n+\t\t\t\tOperators.onDiscard(value, currentContext());\n+\t\t\t\t//the emitError will onErrorDropped if already terminated\n+\t\t\t\temitError(Exceptions.failWithOverflow(\"Backpressure overflow during Sinks.Many#emitNext\"));\n+\t\t\t\tbreak;\n+\t\t\tcase FAIL_CANCELLED:\n+\t\t\t\tOperators.onDiscard(value, currentContext());\n+\t\t\t\tbreak;\n+\t\t\tcase FAIL_TERMINATED:\n+\t\t\t\tOperators.onNextDroppedMulticast(value, subscribers);\n+\t\t\t\tbreak;\n+\t\t\tcase OK:\n+\t\t\t\tbreak;\n+\t\t\tcase FAIL_NON_SERIALIZED:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "102b2bd8b103cd46f40571054ea1515e5081cad3"}, "originalPosition": 207}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyNDcyNTk5", "url": "https://github.com/reactor/reactor-core/pull/2392#pullrequestreview-492472599", "createdAt": "2020-09-21T10:44:03Z", "commit": {"oid": "102b2bd8b103cd46f40571054ea1515e5081cad3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxMDo0NDowM1rOHVKDdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxMDo0NDowM1rOHVKDdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk0Njg2OA==", "bodyText": "can't we reuse at least the inner class between this Sink and the existing processor?", "url": "https://github.com/reactor/reactor-core/pull/2392#discussion_r491946868", "createdAt": "2020-09-21T10:44:03Z", "author": {"login": "bsideup"}, "path": "reactor-core/src/main/java/reactor/core/publisher/SinkManyBestEffort.java", "diffHunk": "@@ -0,0 +1,385 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.stream.Stream;\n+\n+import reactor.core.CoreSubscriber;\n+import reactor.core.Exceptions;\n+import reactor.core.Scannable;\n+import reactor.core.publisher.Sinks.Emission;\n+import reactor.util.annotation.Nullable;\n+import reactor.util.context.Context;\n+\n+/**\n+ * @author Simon Basl\u00e9\n+ */\n+final class SinkManyBestEffort<T> extends Flux<T> implements Sinks.Many<T>, ContextHolder,\n+                                                             Scannable {\n+\n+\tprivate static final Inner[] EMPTY = new Inner[0];\n+\tprivate static final Inner[] TERMINATED = new Inner[0];\n+\n+\tstatic final <T> SinkManyBestEffort<T> createBestEffort() {\n+\t\treturn new SinkManyBestEffort<>(false);\n+\t}\n+\n+\tstatic final <T> SinkManyBestEffort<T> createAllOrNothing() {\n+\t\treturn new SinkManyBestEffort<>(true);\n+\t}\n+\n+\tfinal boolean allOrNothing;\n+\n+\t/**\n+\t * Stores the error that terminated this sink, for immediate replay to late subscribers\n+\t */\n+\tThrowable error;\n+\n+\tvolatile     Inner<T>[]                                               subscribers;\n+\t@SuppressWarnings(\"rawtypes\")\n+\tstatic final AtomicReferenceFieldUpdater<SinkManyBestEffort, Inner[]> SUBSCRIBERS =\n+\t\t\tAtomicReferenceFieldUpdater.newUpdater(SinkManyBestEffort.class, Inner[].class, \"subscribers\");\n+\n+\tSinkManyBestEffort(boolean allOrNothing) {\n+\t\tthis.allOrNothing = allOrNothing;\n+\t\tSUBSCRIBERS.lazySet(this, EMPTY);\n+\t}\n+\n+\tpublic Context currentContext() {\n+\t\treturn Operators.multiSubscribersContext(subscribers);\n+\t}\n+\n+\t@Override\n+\tpublic Stream<? extends Scannable> inners() {\n+\t\treturn Stream.of(subscribers);\n+\t}\n+\n+\t@Nullable\n+\t@Override\n+\tpublic Object scanUnsafe(Attr key) {\n+\t\tif (key == Attr.TERMINATED) return subscribers == TERMINATED;\n+\t\tif (key == Attr.ERROR) return error;\n+\n+\t\treturn null;\n+\t}\n+\n+\t@Override\n+\tpublic Emission tryEmitNext(T t) {\n+\t\tObjects.requireNonNull(t, \"tryEmitNext(null) is forbidden\");\n+\n+\t\tInner<T>[] subs = subscribers;\n+\n+\t\tif (subs == EMPTY) {\n+\t\t\treturn Emission.FAIL_ZERO_SUBSCRIBER;\n+\t\t}\n+\t\tif (subs == TERMINATED) {\n+\t\t\treturn Emission.FAIL_TERMINATED;\n+\t\t}\n+\n+\t\tif (allOrNothing) {\n+\t\t\tlong commonRequest = Long.MAX_VALUE;\n+\t\t\tfor (Inner<T> sub : subs) {\n+\t\t\t\tlong subRequest = sub.requested;\n+\t\t\t\tif (sub.isCancelled()) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t\tif (subRequest < commonRequest) {\n+\t\t\t\t\tcommonRequest = subRequest;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (commonRequest == 0) {\n+\t\t\t\treturn Emission.FAIL_OVERFLOW;\n+\t\t\t}\n+\t\t}\n+\n+\t\tint expectedEmitted = subs.length;\n+\t\tint emittedCount = 0;\n+\t\tint cancelledCount = 0;\n+\t\tfor (Inner<T> sub : subs) {\n+\t\t\tif (sub.isCancelled()) {\n+\t\t\t\tcancelledCount++;\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tif (sub.tryEmitNext(t)) {\n+\t\t\t\temittedCount++;\n+\t\t\t}\n+\t\t\telse if (sub.isCancelled()) {\n+\t\t\t\tcancelledCount++;\n+\t\t\t}\n+\t\t}\n+\t\tif (cancelledCount == expectedEmitted) {\n+\t\t\treturn Emission.FAIL_ZERO_SUBSCRIBER; //TODO should it be FAIL_CANCELLED ? but technically the sink would still be usable\n+\t\t}\n+\t\telse if (cancelledCount + emittedCount == expectedEmitted) {\n+\t\t\treturn Emission.OK;\n+\t\t}\n+\t\telse {\n+\t\t\treturn Emission.FAIL_OVERFLOW;\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic Emission tryEmitComplete() {\n+\t\t@SuppressWarnings(\"unchecked\")\n+\t\tInner<T>[] subs = SUBSCRIBERS.getAndSet(this, TERMINATED);\n+\n+\t\tif (subs == TERMINATED) {\n+\t\t\treturn Emission.FAIL_TERMINATED;\n+\t\t}\n+\n+\t\tfor (Inner<?> s : subs) {\n+\t\t\ts.emitComplete();\n+\t\t}\n+\t\treturn Emission.OK;\n+\t}\n+\n+\t@Override\n+\tpublic Emission tryEmitError(Throwable error) {\n+\t\tObjects.requireNonNull(error, \"tryEmitError(null) is forbidden\");\n+\t\t@SuppressWarnings(\"unchecked\")\n+\t\tInner<T>[] subs = SUBSCRIBERS.getAndSet(this, TERMINATED);\n+\n+\t\tif (subs == TERMINATED) {\n+\t\t\treturn Emission.FAIL_TERMINATED;\n+\t\t}\n+\n+\t\tthis.error = error;\n+\n+\t\tfor (Inner<?> s : subs) {\n+\t\t\ts.emitError(error);\n+\t\t}\n+\t\treturn Emission.OK;\n+\t}\n+\n+\t@Override\n+\tpublic void emitComplete() {\n+\t\t//no particular error condition handling for onComplete\n+\t\t@SuppressWarnings(\"unused\")\n+\t\tEmission emission = tryEmitComplete();\n+\t}\n+\n+\t@Override\n+\tpublic void emitError(Throwable error) {\n+\t\tEmission result = tryEmitError(error);\n+\t\tif (result == Emission.FAIL_TERMINATED) {\n+\t\t\tOperators.onErrorDroppedMulticast(error, subscribers);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void emitNext(T value) {\n+\t\tswitch(tryEmitNext(value)) {\n+\t\t\tcase FAIL_ZERO_SUBSCRIBER:\n+\t\t\t\t//we want to \"discard\" without rendering the sink terminated.\n+\t\t\t\t// effectively NO-OP cause there's no subscriber, so no context :(\n+\t\t\t\tbreak;\n+\t\t\tcase FAIL_OVERFLOW:\n+\t\t\t\tOperators.onDiscard(value, currentContext());\n+\t\t\t\t//the emitError will onErrorDropped if already terminated\n+\t\t\t\temitError(Exceptions.failWithOverflow(\"Backpressure overflow during Sinks.Many#emitNext\"));\n+\t\t\t\tbreak;\n+\t\t\tcase FAIL_CANCELLED:\n+\t\t\t\tOperators.onDiscard(value, currentContext());\n+\t\t\t\tbreak;\n+\t\t\tcase FAIL_TERMINATED:\n+\t\t\t\tOperators.onNextDroppedMulticast(value, subscribers);\n+\t\t\t\tbreak;\n+\t\t\tcase OK:\n+\t\t\t\tbreak;\n+\t\t\tcase FAIL_NON_SERIALIZED:\n+\t\t\t\tthrow new IllegalStateException(\"Unexpected return code\");\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic int currentSubscriberCount() {\n+\t\treturn subscribers.length;\n+\t}\n+\n+\t@Override\n+\tpublic Flux<T> asFlux() {\n+\t\treturn this;\n+\t}\n+\n+\t@Override\n+\tpublic void subscribe(CoreSubscriber<? super T> actual) {\n+\t\tObjects.requireNonNull(actual, \"subscribe(null) is forbidden\");\n+\n+\t\tInner<T> p = new Inner<>(actual, this);\n+\t\tactual.onSubscribe(p);\n+\n+\t\tif (p.isCancelled()) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tif (add(p)) {\n+\t\t\tif (p.isCancelled()) {\n+\t\t\t\tremove(p);\n+\t\t\t}\n+\t\t}\n+\t\telse {\n+\t\t\tThrowable e = error;\n+\t\t\tif (e != null) {\n+\t\t\t\tactual.onError(e);\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tactual.onComplete();\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tboolean add(Inner<T> s) {\n+\t\tInner<T>[] a = subscribers;\n+\t\tif (a == TERMINATED) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tsynchronized (this) {\n+\t\t\ta = subscribers;\n+\t\t\tif (a == TERMINATED) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tint len = a.length;\n+\n+\t\t\t@SuppressWarnings(\"unchecked\")\n+\t\t\tInner<T>[] b = new Inner[len + 1];\n+\t\t\tSystem.arraycopy(a, 0, b, 0, len);\n+\t\t\tb[len] = s;\n+\n+\t\t\tsubscribers = b;\n+\n+\t\t\treturn true;\n+\t\t}\n+\t}\n+\n+\t@SuppressWarnings(\"unchecked\")\n+\tvoid remove(Inner<T> s) {\n+\t\tInner<T>[] a = subscribers;\n+\t\tif (a == TERMINATED || a == EMPTY) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tsynchronized (this) {\n+\t\t\ta = subscribers;\n+\t\t\tif (a == TERMINATED || a == EMPTY) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tint len = a.length;\n+\n+\t\t\tint j = -1;\n+\n+\t\t\tfor (int i = 0; i < len; i++) {\n+\t\t\t\tif (a[i] == s) {\n+\t\t\t\t\tj = i;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (j < 0) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tif (len == 1) {\n+\t\t\t\tsubscribers = EMPTY;\n+\t\t\t\treturn;\n+\t\t\t}\n+\n+\t\t\tInner<T>[] b = new Inner[len - 1];\n+\t\t\tSystem.arraycopy(a, 0, b, 0, j);\n+\t\t\tSystem.arraycopy(a, j + 1, b, j, len - j - 1);\n+\n+\t\t\tsubscribers = b;\n+\t\t}\n+\t}\n+\n+\tstatic class Inner<T> extends AtomicBoolean implements InnerProducer<T> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "102b2bd8b103cd46f40571054ea1515e5081cad3"}, "originalPosition": 311}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyNTAyODU4", "url": "https://github.com/reactor/reactor-core/pull/2392#pullrequestreview-492502858", "createdAt": "2020-09-21T11:30:55Z", "commit": {"oid": "102b2bd8b103cd46f40571054ea1515e5081cad3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxMTozMDo1NlrOHVLeTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxMTozMDo1NlrOHVLeTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk3MDEyNA==", "bodyText": "I'd suggest to not use onBackpressureXxx at all since it is misleading anyways (we only return an Emission and not actually perform anything on backpressure)\nMaybe Sinks.many().multicast().toAnyRequested() and Sinks.many().multicast().allOrNothing() or something similar?", "url": "https://github.com/reactor/reactor-core/pull/2392#discussion_r491970124", "createdAt": "2020-09-21T11:30:56Z", "author": {"login": "bsideup"}, "path": "reactor-core/src/main/java/reactor/core/publisher/Sinks.java", "diffHunk": "@@ -355,6 +355,48 @@ public Emission getReason() {\n \t\t * @param autoCancel should the sink fully shutdowns (not publishing anymore) when the last subscriber cancels\n \t\t */\n \t\t<T> Sinks.Many<T> onBackpressureBuffer(int bufferSize, boolean autoCancel);\n+\n+\t\t/**\n+\t\t A {@link Sinks.Many} with the following characteristics:\n+\t\t * <ul>\n+\t\t *     <li>Multicast</li>\n+\t\t *     <li>Without {@link Subscriber}: fail fast on {@link Many#tryEmitNext(Object) tryEmitNext}.</li>\n+\t\t *     <li>Backpressure : notify the caller with {@link Emission#FAIL_OVERFLOW} if any of the subscribers\n+\t\t *     cannot process an element, failing fast and backing off from emitting the element at all.\n+\t\t * \t   From the perspective of subscribers, data is dropped and never seen but they are not terminated.\n+\t\t *     </li>\n+\t\t *     <li>Replaying: No replay of elements. Only forwards to a {@link Subscriber} the elements that\n+\t\t *     have been pushed to the sink AFTER this subscriber was subscribed, provided all of the subscribers\n+\t\t *     have demand.</li>\n+\t\t * </ul>\n+\t\t * <p>\n+\t\t *\n+\t\t * @param <T> the type of elements to emit\n+\t\t * @return a multicast {@link Sinks.Many} that \"drops\" in case any subscriber is too slow\n+\t\t */\n+\t\t//TODO marble <img class=\"marble\" src=\"doc-files/marbles/sinkWarmup.svg\" alt=\"\">\n+\t\t<T> Sinks.Many<T> onBackpressureDropForAll();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "102b2bd8b103cd46f40571054ea1515e5081cad3"}, "originalPosition": 24}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "902ea9d80164805c582b6a3d318be927ef1b2a7f", "author": {"user": {"login": "simonbasle", "name": "Simon Basl\u00e9"}}, "url": "https://github.com/reactor/reactor-core/commit/902ea9d80164805c582b6a3d318be927ef1b2a7f", "committedDate": "2020-09-21T16:13:16Z", "message": "Add marble diagrams (optimized)"}, "afterCommit": {"oid": "e2ddb120b22f2dcd121439b88839aa39b519eddd", "author": {"user": {"login": "simonbasle", "name": "Simon Basl\u00e9"}}, "url": "https://github.com/reactor/reactor-core/commit/e2ddb120b22f2dcd121439b88839aa39b519eddd", "committedDate": "2020-09-22T08:30:43Z", "message": "Add marble diagrams (optimized)"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk2NTQ1MTQ1", "url": "https://github.com/reactor/reactor-core/pull/2392#pullrequestreview-496545145", "createdAt": "2020-09-25T15:51:55Z", "commit": {"oid": "e2ddb120b22f2dcd121439b88839aa39b519eddd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxNTo1MTo1NlrOHYJRXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxNTo1MTo1NlrOHYJRXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA3OTc3NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t * @return a multicast {@link Sinks.Many} that \"drops\" in case any subscriber is too slow\n          \n          \n            \n            \t\t * @return a multicast {@link Sinks.Many} that \"drops\" in case of no demand from any subscriber", "url": "https://github.com/reactor/reactor-core/pull/2392#discussion_r495079774", "createdAt": "2020-09-25T15:51:56Z", "author": {"login": "bsideup"}, "path": "reactor-core/src/main/java/reactor/core/publisher/Sinks.java", "diffHunk": "@@ -355,6 +355,48 @@ public Emission getReason() {\n \t\t * @param autoCancel should the sink fully shutdowns (not publishing anymore) when the last subscriber cancels\n \t\t */\n \t\t<T> Sinks.Many<T> onBackpressureBuffer(int bufferSize, boolean autoCancel);\n+\n+\t\t/**\n+\t\t A {@link Sinks.Many} with the following characteristics:\n+\t\t * <ul>\n+\t\t *     <li>Multicast</li>\n+\t\t *     <li>Without {@link Subscriber}: fail fast on {@link Many#tryEmitNext(Object) tryEmitNext}.</li>\n+\t\t *     <li>Backpressure : notify the caller with {@link Emission#FAIL_OVERFLOW} if any of the subscribers\n+\t\t *     cannot process an element, failing fast and backing off from emitting the element at all (all or nothing).\n+\t\t * \t   From the perspective of subscribers, data is dropped and never seen but they are not terminated.\n+\t\t *     </li>\n+\t\t *     <li>Replaying: No replay of elements. Only forwards to a {@link Subscriber} the elements that\n+\t\t *     have been pushed to the sink AFTER this subscriber was subscribed, provided all of the subscribers\n+\t\t *     have demand.</li>\n+\t\t * </ul>\n+\t\t * <p>\n+\t\t * <img class=\"marble\" src=\"doc-files/marbles/sinkDirectAllOrNothing.svg\" alt=\"\">\n+\t\t *\n+\t\t * @param <T> the type of elements to emit\n+\t\t * @return a multicast {@link Sinks.Many} that \"drops\" in case any subscriber is too slow\n+\t\t */\n+\t\t<T> Sinks.Many<T> directAllOrNothing();\n+\n+\t\t/**\n+\t\t A {@link Sinks.Many} with the following characteristics:\n+\t\t * <ul>\n+\t\t *     <li>Multicast</li>\n+\t\t *     <li>Without {@link Subscriber}: fail fast on {@link Many#tryEmitNext(Object) tryEmitNext}.</li>\n+\t\t *     <li>Backpressure : notify the caller with {@link Emission#FAIL_OVERFLOW} if <strong>none</strong>\n+\t\t *     of the subscribers can process an element. Otherwise, it ignores slow subscribers and emits the\n+\t\t *     element to fast ones as a best effort. From the perspective of slow subscribers, data is dropped\n+\t\t *     and never seen, but they are not terminated.\n+\t\t *     </li>\n+\t\t *     <li>Replaying: No replay of elements. Only forwards to a {@link Subscriber} the elements that\n+\t\t *     have been pushed to the sink AFTER this subscriber was subscribed.</li>\n+\t\t * </ul>\n+\t\t * <p>\n+\t\t * <img class=\"marble\" src=\"doc-files/marbles/sinkDirectBestEffort.svg\" alt=\"\">\n+\t\t *\n+\t\t * @param <T> the type of elements to emit\n+\t\t * @return a multicast {@link Sinks.Many} that \"drops\" in case any subscriber is too slow", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2ddb120b22f2dcd121439b88839aa39b519eddd"}, "originalPosition": 43}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk2NTQ5NTkz", "url": "https://github.com/reactor/reactor-core/pull/2392#pullrequestreview-496549593", "createdAt": "2020-09-25T15:57:18Z", "commit": {"oid": "e2ddb120b22f2dcd121439b88839aa39b519eddd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxNTo1NzoxOFrOHYJewQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxNTo1NzoxOFrOHYJewQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA4MzIwMQ==", "bodyText": "I get a feeling that we will never start using JCstress if we will keep adding these for-based ones :(\nthis is a new code, goes into master where JCstress is configured, and I see no reason not to use it.", "url": "https://github.com/reactor/reactor-core/pull/2392#discussion_r495083201", "createdAt": "2020-09-25T15:57:18Z", "author": {"login": "bsideup"}, "path": "reactor-core/src/test/java/reactor/core/publisher/SinkManyBestEffortTest.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.reactivestreams.Subscription;\n+\n+import reactor.core.Disposable;\n+import reactor.core.Scannable;\n+import reactor.core.publisher.Sinks.Emission;\n+import reactor.test.StepVerifier;\n+import reactor.test.subscriber.AssertSubscriber;\n+import reactor.util.context.Context;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.fail;\n+\n+class SinkManyBestEffortTest {\n+\n+\t@Test\n+\tvoid currentContextReflectSubscriberContext() {\n+\t\tSinkManyBestEffort<Integer> sink = SinkManyBestEffort.createBestEffort();\n+\n+\t\tassertThat(sink.currentContext()).isSameAs(Context.empty());\n+\n+\t\tAssertSubscriber<Integer> subscriber1 = new AssertSubscriber<>(Context.of(\"key\", \"value1\"));\n+\t\tAssertSubscriber<Integer> subscriber2 = new AssertSubscriber<>(Context.of(\"key\", \"value2\"));\n+\t\tsink.subscribe(subscriber1);\n+\t\tsink.subscribe(subscriber2);\n+\n+\t\tassertThat(sink.currentContext()).isEqualTo(subscriber1.currentContext());\n+\t}\n+\n+\t@Test\n+\tvoid tryEmitNextNoSubscribers() {\n+\t\tSinkManyBestEffort<Integer> sink = SinkManyBestEffort.createBestEffort();\n+\n+\t\tassertThat(sink.tryEmitNext(1)).as(\"tryEmitNext\").isEqualTo(Emission.FAIL_ZERO_SUBSCRIBER);\n+\t}\n+\n+\t@Test\n+\tvoid tryEmitNextOnTerminated() {\n+\t\tSinkManyBestEffort<Integer> sink = SinkManyBestEffort.createBestEffort();\n+\t\tsink.tryEmitComplete().orThrow();\n+\n+\t\tassertThat(sink.tryEmitNext(1)).as(\"tryEmitNext\").isEqualTo(Emission.FAIL_TERMINATED);\n+\t}\n+\n+\t@Test\n+\tvoid tryEmitCompleteNoSubscribersRetains() {\n+\t\tSinkManyBestEffort<Integer> sink = SinkManyBestEffort.createBestEffort();\n+\n+\t\tassertThat(sink.tryEmitComplete()).as(\"tryEmitComplete\").isEqualTo(Emission.OK);\n+\n+\t\tStepVerifier.create(sink.asFlux())\n+\t\t            .verifyComplete();\n+\t}\n+\n+\t@Test\n+\tvoid tryEmitCompleteOnTerminated() {\n+\t\tSinkManyBestEffort<Integer> sink = SinkManyBestEffort.createBestEffort();\n+\t\tsink.tryEmitComplete().orThrow();\n+\n+\t\tassertThat(sink.tryEmitComplete()).as(\"tryEmitComplete\").isEqualTo(Emission.FAIL_TERMINATED);\n+\t}\n+\n+\t@Test\n+\tvoid tryEmitErrorNoSubscribersRetains() {\n+\t\tSinkManyBestEffort<Integer> sink = SinkManyBestEffort.createBestEffort();\n+\n+\t\tassertThat(sink.tryEmitError(new IllegalStateException(\"boom\"))).as(\"tryEmitError\").isEqualTo(Emission.OK);\n+\n+\t\tStepVerifier.create(sink.asFlux())\n+\t\t            .verifyErrorMessage(\"boom\");\n+\t}\n+\n+\t@Test\n+\tvoid tryEmitErrorOnTerminated() {\n+\t\tSinkManyBestEffort<Integer> sink = SinkManyBestEffort.createBestEffort();\n+\t\tsink.tryEmitError(new IllegalStateException(\"boom\")).orThrow();\n+\n+\t\tassertThat(sink.tryEmitError(new IllegalStateException(\"boom ignored\"))).as(\"tryEmitError\").isEqualTo(Emission.FAIL_TERMINATED);\n+\n+\t\tStepVerifier.create(sink.asFlux())\n+\t\t            .verifyErrorMessage(\"boom\");\n+\t}\n+\n+\t@Test\n+\tvoid tryEmitErrorOnSubscribers() {\n+\t\tSinkManyBestEffort<Integer> sink = SinkManyBestEffort.createBestEffort();\n+\n+\t\tAssertSubscriber<Integer> sub1 = AssertSubscriber.create();\n+\t\tAssertSubscriber<Integer> sub2 = AssertSubscriber.create(0);\n+\t\tsink.subscribe(sub1);\n+\t\tsink.subscribe(sub2);\n+\n+\t\tassertThat(sink.tryEmitError(new IllegalStateException(\"boom\"))).as(\"tryEmitError\").isEqualTo(Emission.OK);\n+\n+\t\tsub1.assertErrorMessage(\"boom\");\n+\t\tsub2.assertErrorMessage(\"boom\");\n+\t}\n+\n+\t@Test\n+\tvoid addSubscriberThatCancelsOnSubscription() {\n+\t\tSinkManyBestEffort<Integer> sink = SinkManyBestEffort.createBestEffort();\n+\n+\t\tsink.subscribe(new BaseSubscriber<Integer>() {\n+\t\t\t@Override\n+\t\t\tprotected void hookOnSubscribe(Subscription subscription) {\n+\t\t\t\tsubscription.cancel();\n+\t\t\t}\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tvoid innersReflectsSubscribers() {\n+\t\tSinkManyBestEffort<Integer> sink = SinkManyBestEffort.createBestEffort();\n+\n+\t\tassertThat(sink.inners()).as(\"before subscribers\").isEmpty();\n+\n+\t\tDisposable sub1 = sink.subscribe();\n+\t\tDisposable sub2 = sink.subscribe();\n+\n+\t\tassertThat(sink.inners()).hasSize(2);\n+\t\tassertThat(sink.inners().map(inner -> inner.scanUnsafe(Scannable.Attr.ACTUAL)))\n+\t\t\t\t.containsExactly(sub1, sub2);\n+\t}\n+\n+\t@Test\n+\tvoid scanSink() {\n+\t\tSinkManyBestEffort<Integer> sinkNormal = SinkManyBestEffort.createBestEffort();\n+\n+\t\tassertThat(sinkNormal.scan(Scannable.Attr.TERMINATED)).as(\"normal not terminated\").isFalse();\n+\t\tsinkNormal.tryEmitComplete().orThrow();\n+\t\tassertThat(sinkNormal.scan(Scannable.Attr.TERMINATED)).as(\"normal terminated\").isTrue();\n+\n+\t\tSinkManyBestEffort<Integer> sinkError = SinkManyBestEffort.createBestEffort();\n+\t\tThrowable expectedError = new IllegalStateException(\"boom\");\n+\t\tsinkError.tryEmitError(expectedError).orThrow();\n+\n+\t\tassertThat(sinkError.scan(Scannable.Attr.TERMINATED)).as(\"error terminated\").isTrue();\n+\t\tassertThat(sinkError.scan(Scannable.Attr.ERROR)).as(\"error captured\").isSameAs(expectedError);\n+\t}\n+\n+\t@Nested\n+\tclass RaceConditionsAndLoops {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2ddb120b22f2dcd121439b88839aa39b519eddd"}, "originalPosition": 166}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk2NTUxMjAx", "url": "https://github.com/reactor/reactor-core/pull/2392#pullrequestreview-496551201", "createdAt": "2020-09-25T15:59:19Z", "commit": {"oid": "e2ddb120b22f2dcd121439b88839aa39b519eddd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxNTo1OToxOVrOHYJjxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxNTo1OToxOVrOHYJjxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA4NDQ4Ng==", "bodyText": "this test does not seem to assert anything", "url": "https://github.com/reactor/reactor-core/pull/2392#discussion_r495084486", "createdAt": "2020-09-25T15:59:19Z", "author": {"login": "bsideup"}, "path": "reactor-core/src/test/java/reactor/core/publisher/SinkManyBestEffortTest.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.reactivestreams.Subscription;\n+\n+import reactor.core.Disposable;\n+import reactor.core.Scannable;\n+import reactor.core.publisher.Sinks.Emission;\n+import reactor.test.StepVerifier;\n+import reactor.test.subscriber.AssertSubscriber;\n+import reactor.util.context.Context;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.fail;\n+\n+class SinkManyBestEffortTest {\n+\n+\t@Test\n+\tvoid currentContextReflectSubscriberContext() {\n+\t\tSinkManyBestEffort<Integer> sink = SinkManyBestEffort.createBestEffort();\n+\n+\t\tassertThat(sink.currentContext()).isSameAs(Context.empty());\n+\n+\t\tAssertSubscriber<Integer> subscriber1 = new AssertSubscriber<>(Context.of(\"key\", \"value1\"));\n+\t\tAssertSubscriber<Integer> subscriber2 = new AssertSubscriber<>(Context.of(\"key\", \"value2\"));\n+\t\tsink.subscribe(subscriber1);\n+\t\tsink.subscribe(subscriber2);\n+\n+\t\tassertThat(sink.currentContext()).isEqualTo(subscriber1.currentContext());\n+\t}\n+\n+\t@Test\n+\tvoid tryEmitNextNoSubscribers() {\n+\t\tSinkManyBestEffort<Integer> sink = SinkManyBestEffort.createBestEffort();\n+\n+\t\tassertThat(sink.tryEmitNext(1)).as(\"tryEmitNext\").isEqualTo(Emission.FAIL_ZERO_SUBSCRIBER);\n+\t}\n+\n+\t@Test\n+\tvoid tryEmitNextOnTerminated() {\n+\t\tSinkManyBestEffort<Integer> sink = SinkManyBestEffort.createBestEffort();\n+\t\tsink.tryEmitComplete().orThrow();\n+\n+\t\tassertThat(sink.tryEmitNext(1)).as(\"tryEmitNext\").isEqualTo(Emission.FAIL_TERMINATED);\n+\t}\n+\n+\t@Test\n+\tvoid tryEmitCompleteNoSubscribersRetains() {\n+\t\tSinkManyBestEffort<Integer> sink = SinkManyBestEffort.createBestEffort();\n+\n+\t\tassertThat(sink.tryEmitComplete()).as(\"tryEmitComplete\").isEqualTo(Emission.OK);\n+\n+\t\tStepVerifier.create(sink.asFlux())\n+\t\t            .verifyComplete();\n+\t}\n+\n+\t@Test\n+\tvoid tryEmitCompleteOnTerminated() {\n+\t\tSinkManyBestEffort<Integer> sink = SinkManyBestEffort.createBestEffort();\n+\t\tsink.tryEmitComplete().orThrow();\n+\n+\t\tassertThat(sink.tryEmitComplete()).as(\"tryEmitComplete\").isEqualTo(Emission.FAIL_TERMINATED);\n+\t}\n+\n+\t@Test\n+\tvoid tryEmitErrorNoSubscribersRetains() {\n+\t\tSinkManyBestEffort<Integer> sink = SinkManyBestEffort.createBestEffort();\n+\n+\t\tassertThat(sink.tryEmitError(new IllegalStateException(\"boom\"))).as(\"tryEmitError\").isEqualTo(Emission.OK);\n+\n+\t\tStepVerifier.create(sink.asFlux())\n+\t\t            .verifyErrorMessage(\"boom\");\n+\t}\n+\n+\t@Test\n+\tvoid tryEmitErrorOnTerminated() {\n+\t\tSinkManyBestEffort<Integer> sink = SinkManyBestEffort.createBestEffort();\n+\t\tsink.tryEmitError(new IllegalStateException(\"boom\")).orThrow();\n+\n+\t\tassertThat(sink.tryEmitError(new IllegalStateException(\"boom ignored\"))).as(\"tryEmitError\").isEqualTo(Emission.FAIL_TERMINATED);\n+\n+\t\tStepVerifier.create(sink.asFlux())\n+\t\t            .verifyErrorMessage(\"boom\");\n+\t}\n+\n+\t@Test\n+\tvoid tryEmitErrorOnSubscribers() {\n+\t\tSinkManyBestEffort<Integer> sink = SinkManyBestEffort.createBestEffort();\n+\n+\t\tAssertSubscriber<Integer> sub1 = AssertSubscriber.create();\n+\t\tAssertSubscriber<Integer> sub2 = AssertSubscriber.create(0);\n+\t\tsink.subscribe(sub1);\n+\t\tsink.subscribe(sub2);\n+\n+\t\tassertThat(sink.tryEmitError(new IllegalStateException(\"boom\"))).as(\"tryEmitError\").isEqualTo(Emission.OK);\n+\n+\t\tsub1.assertErrorMessage(\"boom\");\n+\t\tsub2.assertErrorMessage(\"boom\");\n+\t}\n+\n+\t@Test\n+\tvoid addSubscriberThatCancelsOnSubscription() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2ddb120b22f2dcd121439b88839aa39b519eddd"}, "originalPosition": 124}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3MjgzMDM1", "url": "https://github.com/reactor/reactor-core/pull/2392#pullrequestreview-497283035", "createdAt": "2020-09-28T08:16:18Z", "commit": {"oid": "29953f844bf3bbfadd9d3c08e92d830ab8f80cac"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwODoxNjoxOFrOHYzDrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwODoxNjoxOFrOHYzDrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc2NDM5Ng==", "bodyText": "if there is no shared code than the abstract class can be avoided (it is not required by JCstress or anything like that)", "url": "https://github.com/reactor/reactor-core/pull/2392#discussion_r495764396", "createdAt": "2020-09-28T08:16:18Z", "author": {"login": "bsideup"}, "path": "reactor-core/src/jcstress/java/reactor/core/publisher/SinkManyBestEffortStressTest.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Copyright (c) 2020-Present Pivotal Software Inc, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package reactor.core.publisher;\n+\n+import org.openjdk.jcstress.annotations.Actor;\n+import org.openjdk.jcstress.annotations.Arbiter;\n+import org.openjdk.jcstress.annotations.JCStressTest;\n+import org.openjdk.jcstress.annotations.Outcome;\n+import org.openjdk.jcstress.annotations.State;\n+import org.openjdk.jcstress.infra.results.I_Result;\n+import org.openjdk.jcstress.infra.results.LI_Result;\n+import org.reactivestreams.Subscription;\n+\n+import static org.openjdk.jcstress.annotations.Expect.*;\n+\n+public abstract class SinkManyBestEffortStressTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29953f844bf3bbfadd9d3c08e92d830ab8f80cac"}, "originalPosition": 29}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3MjgzNDQ0", "url": "https://github.com/reactor/reactor-core/pull/2392#pullrequestreview-497283444", "createdAt": "2020-09-28T08:16:50Z", "commit": {"oid": "29953f844bf3bbfadd9d3c08e92d830ab8f80cac"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwODoxNjo1MFrOHYzEzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwODoxNjo1MFrOHYzEzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc2NDY4Ng==", "bodyText": "a stress test with a single actor does not make any sense", "url": "https://github.com/reactor/reactor-core/pull/2392#discussion_r495764686", "createdAt": "2020-09-28T08:16:50Z", "author": {"login": "bsideup"}, "path": "reactor-core/src/jcstress/java/reactor/core/publisher/SinkManyBestEffortStressTest.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Copyright (c) 2020-Present Pivotal Software Inc, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package reactor.core.publisher;\n+\n+import org.openjdk.jcstress.annotations.Actor;\n+import org.openjdk.jcstress.annotations.Arbiter;\n+import org.openjdk.jcstress.annotations.JCStressTest;\n+import org.openjdk.jcstress.annotations.Outcome;\n+import org.openjdk.jcstress.annotations.State;\n+import org.openjdk.jcstress.infra.results.I_Result;\n+import org.openjdk.jcstress.infra.results.LI_Result;\n+import org.reactivestreams.Subscription;\n+\n+import static org.openjdk.jcstress.annotations.Expect.*;\n+\n+public abstract class SinkManyBestEffortStressTest {\n+\n+\t@JCStressTest\n+\t@Outcome(id = {\"6\"}, expect = ACCEPTABLE, desc = \"Six parallel subscribes\")\n+\t@State\n+\tpublic static class ParallelSubscribersStressTest {\n+\n+\t\tfinal SinkManyBestEffort<Integer> sink = SinkManyBestEffort.createBestEffort();\n+\n+\t\t@Actor\n+\t\tpublic void one() {\n+\t\t\tsink.subscribe(new StressSubscriber<>());\n+\t\t}\n+\n+\t\t@Actor\n+\t\tpublic void two() {\n+\t\t\tsink.subscribe(new StressSubscriber<>());\n+\t\t}\n+\n+\t\t@Actor\n+\t\tpublic void three() {\n+\t\t\tsink.subscribe(new StressSubscriber<>());\n+\t\t}\n+\n+\t\t@Actor\n+\t\tpublic void four() {\n+\t\t\tsink.subscribe(new StressSubscriber<>());\n+\t\t}\n+\n+\t\t@Actor\n+\t\tpublic void five() {\n+\t\t\tsink.subscribe(new StressSubscriber<>());\n+\t\t}\n+\n+\t\t@Actor\n+\t\tpublic void six() {\n+\t\t\tsink.subscribe(new StressSubscriber<>());\n+\t\t}\n+\n+\t\t@Arbiter\n+\t\tpublic void arbiter(I_Result r) {\n+\t\t\tr.r1 = sink.currentSubscriberCount();\n+\t\t}\n+\t}\n+\n+\t@JCStressTest\n+\t@Outcome(id = {\"0\"}, expect = ACCEPTABLE, desc = \"No subscriber counted\")\n+\t@State\n+\tpublic static class CancelOnSubscribeOneSubscribersStressTest {\n+\n+\t\tfinal SinkManyBestEffort<Integer> sink = SinkManyBestEffort.createBestEffort();\n+\n+\t\t@Actor", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29953f844bf3bbfadd9d3c08e92d830ab8f80cac"}, "originalPosition": 81}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3Mjg0NzQ4", "url": "https://github.com/reactor/reactor-core/pull/2392#pullrequestreview-497284748", "createdAt": "2020-09-28T08:18:39Z", "commit": {"oid": "29953f844bf3bbfadd9d3c08e92d830ab8f80cac"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwODoxODozOVrOHYzIgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwODoxODozOVrOHYzIgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc2NTYzNA==", "bodyText": "the whole point of JCstress is to run actors in parallel, so it won't always be \"before\", but before, at the same time and after the subscription", "url": "https://github.com/reactor/reactor-core/pull/2392#discussion_r495765634", "createdAt": "2020-09-28T08:18:39Z", "author": {"login": "bsideup"}, "path": "reactor-core/src/jcstress/java/reactor/core/publisher/SinkManyBestEffortStressTest.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Copyright (c) 2020-Present Pivotal Software Inc, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package reactor.core.publisher;\n+\n+import org.openjdk.jcstress.annotations.Actor;\n+import org.openjdk.jcstress.annotations.Arbiter;\n+import org.openjdk.jcstress.annotations.JCStressTest;\n+import org.openjdk.jcstress.annotations.Outcome;\n+import org.openjdk.jcstress.annotations.State;\n+import org.openjdk.jcstress.infra.results.I_Result;\n+import org.openjdk.jcstress.infra.results.LI_Result;\n+import org.reactivestreams.Subscription;\n+\n+import static org.openjdk.jcstress.annotations.Expect.*;\n+\n+public abstract class SinkManyBestEffortStressTest {\n+\n+\t@JCStressTest\n+\t@Outcome(id = {\"6\"}, expect = ACCEPTABLE, desc = \"Six parallel subscribes\")\n+\t@State\n+\tpublic static class ParallelSubscribersStressTest {\n+\n+\t\tfinal SinkManyBestEffort<Integer> sink = SinkManyBestEffort.createBestEffort();\n+\n+\t\t@Actor\n+\t\tpublic void one() {\n+\t\t\tsink.subscribe(new StressSubscriber<>());\n+\t\t}\n+\n+\t\t@Actor\n+\t\tpublic void two() {\n+\t\t\tsink.subscribe(new StressSubscriber<>());\n+\t\t}\n+\n+\t\t@Actor\n+\t\tpublic void three() {\n+\t\t\tsink.subscribe(new StressSubscriber<>());\n+\t\t}\n+\n+\t\t@Actor\n+\t\tpublic void four() {\n+\t\t\tsink.subscribe(new StressSubscriber<>());\n+\t\t}\n+\n+\t\t@Actor\n+\t\tpublic void five() {\n+\t\t\tsink.subscribe(new StressSubscriber<>());\n+\t\t}\n+\n+\t\t@Actor\n+\t\tpublic void six() {\n+\t\t\tsink.subscribe(new StressSubscriber<>());\n+\t\t}\n+\n+\t\t@Arbiter\n+\t\tpublic void arbiter(I_Result r) {\n+\t\t\tr.r1 = sink.currentSubscriberCount();\n+\t\t}\n+\t}\n+\n+\t@JCStressTest\n+\t@Outcome(id = {\"0\"}, expect = ACCEPTABLE, desc = \"No subscriber counted\")\n+\t@State\n+\tpublic static class CancelOnSubscribeOneSubscribersStressTest {\n+\n+\t\tfinal SinkManyBestEffort<Integer> sink = SinkManyBestEffort.createBestEffort();\n+\n+\t\t@Actor\n+\t\tpublic void one() {\n+\t\t\tsink.subscribe(new BaseSubscriber<Integer>() {\n+\t\t\t\t@Override\n+\t\t\t\tprotected void hookOnSubscribe(Subscription subscription) {\n+\t\t\t\t\tsubscription.cancel();\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\n+\t\t@Arbiter\n+\t\tpublic void arbiter(I_Result r) {\n+\t\t\tr.r1 = sink.currentSubscriberCount();\n+\t\t}\n+\t}\n+\n+\t@JCStressTest\n+\t@Outcome(id = {\"1\"}, expect = ACCEPTABLE, desc = \"One subscriber counted\")\n+\t@State\n+\tpublic static class CancelOnSubscribeTwoSubscribersStressTest {\n+\n+\t\tfinal SinkManyBestEffort<Integer> sink = SinkManyBestEffort.createBestEffort();\n+\n+\t\t@Actor\n+\t\tpublic void one() {\n+\t\t\tsink.subscribe(new StressSubscriber<>(0));\n+\t\t}\n+\n+\t\t@Actor\n+\t\tpublic void two() {\n+\t\t\tsink.subscribe(new BaseSubscriber<Integer>() {\n+\t\t\t\t@Override\n+\t\t\t\tprotected void hookOnSubscribe(Subscription subscription) {\n+\t\t\t\t\tsubscription.cancel();\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\n+\t\t@Arbiter\n+\t\tpublic void arbiter(I_Result r) {\n+\t\t\tr.r1 = sink.currentSubscriberCount();\n+\t\t}\n+\t}\n+\n+\t@JCStressTest\n+\t@Outcome(id = {\"0\"}, expect = ACCEPTABLE, desc = \"No subscriber counted\")\n+\t@State\n+\tpublic static class CancelledBeforeSubscribeOneSubscriberStressTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29953f844bf3bbfadd9d3c08e92d830ab8f80cac"}, "originalPosition": 128}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3Mjg1Mzg2", "url": "https://github.com/reactor/reactor-core/pull/2392#pullrequestreview-497285386", "createdAt": "2020-09-28T08:19:30Z", "commit": {"oid": "29953f844bf3bbfadd9d3c08e92d830ab8f80cac"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwODoxOTozMFrOHYzKTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwODoxOTozMFrOHYzKTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc2NjA5NQ==", "bodyText": "these two can be field initializers", "url": "https://github.com/reactor/reactor-core/pull/2392#discussion_r495766095", "createdAt": "2020-09-28T08:19:30Z", "author": {"login": "bsideup"}, "path": "reactor-core/src/jcstress/java/reactor/core/publisher/SinkManyBestEffortStressTest.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Copyright (c) 2020-Present Pivotal Software Inc, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package reactor.core.publisher;\n+\n+import org.openjdk.jcstress.annotations.Actor;\n+import org.openjdk.jcstress.annotations.Arbiter;\n+import org.openjdk.jcstress.annotations.JCStressTest;\n+import org.openjdk.jcstress.annotations.Outcome;\n+import org.openjdk.jcstress.annotations.State;\n+import org.openjdk.jcstress.infra.results.I_Result;\n+import org.openjdk.jcstress.infra.results.LI_Result;\n+import org.reactivestreams.Subscription;\n+\n+import static org.openjdk.jcstress.annotations.Expect.*;\n+\n+public abstract class SinkManyBestEffortStressTest {\n+\n+\t@JCStressTest\n+\t@Outcome(id = {\"6\"}, expect = ACCEPTABLE, desc = \"Six parallel subscribes\")\n+\t@State\n+\tpublic static class ParallelSubscribersStressTest {\n+\n+\t\tfinal SinkManyBestEffort<Integer> sink = SinkManyBestEffort.createBestEffort();\n+\n+\t\t@Actor\n+\t\tpublic void one() {\n+\t\t\tsink.subscribe(new StressSubscriber<>());\n+\t\t}\n+\n+\t\t@Actor\n+\t\tpublic void two() {\n+\t\t\tsink.subscribe(new StressSubscriber<>());\n+\t\t}\n+\n+\t\t@Actor\n+\t\tpublic void three() {\n+\t\t\tsink.subscribe(new StressSubscriber<>());\n+\t\t}\n+\n+\t\t@Actor\n+\t\tpublic void four() {\n+\t\t\tsink.subscribe(new StressSubscriber<>());\n+\t\t}\n+\n+\t\t@Actor\n+\t\tpublic void five() {\n+\t\t\tsink.subscribe(new StressSubscriber<>());\n+\t\t}\n+\n+\t\t@Actor\n+\t\tpublic void six() {\n+\t\t\tsink.subscribe(new StressSubscriber<>());\n+\t\t}\n+\n+\t\t@Arbiter\n+\t\tpublic void arbiter(I_Result r) {\n+\t\t\tr.r1 = sink.currentSubscriberCount();\n+\t\t}\n+\t}\n+\n+\t@JCStressTest\n+\t@Outcome(id = {\"0\"}, expect = ACCEPTABLE, desc = \"No subscriber counted\")\n+\t@State\n+\tpublic static class CancelOnSubscribeOneSubscribersStressTest {\n+\n+\t\tfinal SinkManyBestEffort<Integer> sink = SinkManyBestEffort.createBestEffort();\n+\n+\t\t@Actor\n+\t\tpublic void one() {\n+\t\t\tsink.subscribe(new BaseSubscriber<Integer>() {\n+\t\t\t\t@Override\n+\t\t\t\tprotected void hookOnSubscribe(Subscription subscription) {\n+\t\t\t\t\tsubscription.cancel();\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\n+\t\t@Arbiter\n+\t\tpublic void arbiter(I_Result r) {\n+\t\t\tr.r1 = sink.currentSubscriberCount();\n+\t\t}\n+\t}\n+\n+\t@JCStressTest\n+\t@Outcome(id = {\"1\"}, expect = ACCEPTABLE, desc = \"One subscriber counted\")\n+\t@State\n+\tpublic static class CancelOnSubscribeTwoSubscribersStressTest {\n+\n+\t\tfinal SinkManyBestEffort<Integer> sink = SinkManyBestEffort.createBestEffort();\n+\n+\t\t@Actor\n+\t\tpublic void one() {\n+\t\t\tsink.subscribe(new StressSubscriber<>(0));\n+\t\t}\n+\n+\t\t@Actor\n+\t\tpublic void two() {\n+\t\t\tsink.subscribe(new BaseSubscriber<Integer>() {\n+\t\t\t\t@Override\n+\t\t\t\tprotected void hookOnSubscribe(Subscription subscription) {\n+\t\t\t\t\tsubscription.cancel();\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\n+\t\t@Arbiter\n+\t\tpublic void arbiter(I_Result r) {\n+\t\t\tr.r1 = sink.currentSubscriberCount();\n+\t\t}\n+\t}\n+\n+\t@JCStressTest\n+\t@Outcome(id = {\"0\"}, expect = ACCEPTABLE, desc = \"No subscriber counted\")\n+\t@State\n+\tpublic static class CancelledBeforeSubscribeOneSubscriberStressTest {\n+\n+\t\tfinal SinkManyBestEffort<Integer> sink = SinkManyBestEffort.createBestEffort();\n+\t\tfinal StressSubscriber<Integer> sub = new StressSubscriber<>(0);\n+\n+\t\t@Actor\n+\t\tpublic void cancellingSub() {\n+\t\t\tsub.cancel();\n+\t\t}\n+\n+\t\t@Actor\n+\t\tpublic void subscribingSub() {\n+\t\t\tsink.subscribe(sub);\n+\t\t}\n+\n+\t\t@Arbiter\n+\t\tpublic void arbiter(I_Result r) {\n+\t\t\tr.r1 = sink.currentSubscriberCount();\n+\t\t}\n+\t}\n+\n+\t@JCStressTest\n+\t@Outcome(id = {\"1\"}, expect = ACCEPTABLE, desc = \"One subscriber counted\")\n+\t@State\n+\tpublic static class CancelledBeforeSubscribeTwoSubscribersStressTest {\n+\n+\t\tfinal SinkManyBestEffort<Integer> sink = SinkManyBestEffort.createBestEffort();\n+\t\tfinal StressSubscriber<Integer> sub2 = new StressSubscriber<>(0);\n+\n+\t\t@Actor\n+\t\tpublic void subscribingSub1() {\n+\t\t\tsink.subscribe(new StressSubscriber<>(0));\n+\t\t}\n+\n+\t\t@Actor\n+\t\tpublic void subscribingSub2() {\n+\t\t\tsink.subscribe(sub2);\n+\t\t}\n+\n+\t\t@Actor\n+\t\tpublic void cancellingSub2() {\n+\t\t\tsub2.cancel();\n+\t\t}\n+\n+\t\t@Arbiter\n+\t\tpublic void arbiter(I_Result r) {\n+\t\t\tr.r1 = sink.currentSubscriberCount();\n+\t\t}\n+\t}\n+\n+\t@JCStressTest\n+\t@Outcome(id = {\"FAIL_ZERO_SUBSCRIBER, 0\"}, expect = ACCEPTABLE, desc = \"Zero Subscriber because cancelled\")\n+\t@Outcome(id = {\"FAIL_OVERFLOW, 0\"}, expect = ACCEPTABLE, desc = \"Overflow because not cancelled nor requested\")\n+\t@Outcome(id = {\"OK, 1\"}, expect = ACCEPTABLE, desc = \"OK because requested before cancelled\")\n+\t@State\n+\tpublic static class InnerTryEmitNextCancelVersusRequestStressTest {\n+\n+\t\tfinal SinkManyBestEffort<Integer>             sink;\n+\t\tfinal StressSubscriber<Integer>               subscriber;\n+\t\tfinal SinkManyBestEffort.DirectInner<Integer> inner;\n+\n+\t\t{\n+\t\t\tsink = SinkManyBestEffort.createBestEffort();\n+\t\t\tsubscriber = new StressSubscriber<>(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29953f844bf3bbfadd9d3c08e92d830ab8f80cac"}, "originalPosition": 191}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3Mjg2MDQ1", "url": "https://github.com/reactor/reactor-core/pull/2392#pullrequestreview-497286045", "createdAt": "2020-09-28T08:20:21Z", "commit": {"oid": "29953f844bf3bbfadd9d3c08e92d830ab8f80cac"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwODoyMDoyMlrOHYzMVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwODoyMDoyMlrOHYzMVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc2NjYxMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t}\n          \n          \n            \n            \t}", "url": "https://github.com/reactor/reactor-core/pull/2392#discussion_r495766613", "createdAt": "2020-09-28T08:20:22Z", "author": {"login": "bsideup"}, "path": "reactor-core/src/jcstress/java/reactor/core/publisher/StressSubscriber.java", "diffHunk": "@@ -35,14 +40,36 @@\n \n \tpublic AtomicBoolean concurrentOnComplete = new AtomicBoolean(false);\n \n+\tpublic AtomicBoolean concurrentOnSubscribe = new AtomicBoolean(false);\n+\n \tpublic final AtomicInteger onNextCalls = new AtomicInteger();\n \n \tpublic final AtomicInteger onErrorCalls = new AtomicInteger();\n \n \tpublic final AtomicInteger onCompleteCalls = new AtomicInteger();\n \n+\tpublic final AtomicInteger onSubscribeCalls = new AtomicInteger();\n+\n+\tpublic StressSubscriber() {\n+\t\tthis(Long.MAX_VALUE);\n+\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29953f844bf3bbfadd9d3c08e92d830ab8f80cac"}, "originalPosition": 37}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3Mjg2Njg4", "url": "https://github.com/reactor/reactor-core/pull/2392#pullrequestreview-497286688", "createdAt": "2020-09-28T08:21:16Z", "commit": {"oid": "29953f844bf3bbfadd9d3c08e92d830ab8f80cac"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwODoyMToxN1rOHYzOQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwODoyMToxN1rOHYzOQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc2NzEwNQ==", "bodyText": "shouldn't the request be strictly positive? I see some new StressSubscriber(0) usages in the tests", "url": "https://github.com/reactor/reactor-core/pull/2392#discussion_r495767105", "createdAt": "2020-09-28T08:21:17Z", "author": {"login": "bsideup"}, "path": "reactor-core/src/jcstress/java/reactor/core/publisher/StressSubscriber.java", "diffHunk": "@@ -35,14 +40,36 @@\n \n \tpublic AtomicBoolean concurrentOnComplete = new AtomicBoolean(false);\n \n+\tpublic AtomicBoolean concurrentOnSubscribe = new AtomicBoolean(false);\n+\n \tpublic final AtomicInteger onNextCalls = new AtomicInteger();\n \n \tpublic final AtomicInteger onErrorCalls = new AtomicInteger();\n \n \tpublic final AtomicInteger onCompleteCalls = new AtomicInteger();\n \n+\tpublic final AtomicInteger onSubscribeCalls = new AtomicInteger();\n+\n+\tpublic StressSubscriber() {\n+\t\tthis(Long.MAX_VALUE);\n+\t}\n+\tpublic StressSubscriber(long initRequest) {\n+\t\tthis.initRequest = initRequest;\n+\t}\n+\n+\t@Override\n+\tprotected void hookOnSubscribe(Subscription subscription) {\n+\t\tif (!guard.compareAndSet(null, Operation.ON_SUBSCRIBE)) {\n+\t\t\tconcurrentOnSubscribe.set(true);\n+\t\t} else {\n+\t\t\tsubscription.request(initRequest);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29953f844bf3bbfadd9d3c08e92d830ab8f80cac"}, "originalPosition": 47}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "585343275bdad6bfec8cd3864f7f67ae83b8f12c", "author": {"user": {"login": "simonbasle", "name": "Simon Basl\u00e9"}}, "url": "https://github.com/reactor/reactor-core/commit/585343275bdad6bfec8cd3864f7f67ae83b8f12c", "committedDate": "2020-09-28T08:43:58Z", "message": "fix review comments on stress test + StressSubscriber"}, "afterCommit": {"oid": "2d200ffcec5b9dd950ad0e1a9e072398a23c0082", "author": {"user": {"login": "simonbasle", "name": "Simon Basl\u00e9"}}, "url": "https://github.com/reactor/reactor-core/commit/2d200ffcec5b9dd950ad0e1a9e072398a23c0082", "committedDate": "2020-09-28T14:11:53Z", "message": "fix review comments on stress test + StressSubscriber"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk5MzkzMTA1", "url": "https://github.com/reactor/reactor-core/pull/2392#pullrequestreview-499393105", "createdAt": "2020-09-30T12:50:07Z", "commit": {"oid": "e92e28766e1b76974f4883b4480166008943bcc0"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c39868beb644ec82ee93c9938dbd742bd3ff5529", "author": {"user": {"login": "simonbasle", "name": "Simon Basl\u00e9"}}, "url": "https://github.com/reactor/reactor-core/commit/c39868beb644ec82ee93c9938dbd742bd3ff5529", "committedDate": "2020-09-30T13:00:00Z", "message": "[polish] StressSubscriber generified, track onSubscribe, initRequest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "818ec001cd6e095c1ef63f36302292f1ba7491a2", "author": {"user": {"login": "simonbasle", "name": "Simon Basl\u00e9"}}, "url": "https://github.com/reactor/reactor-core/commit/818ec001cd6e095c1ef63f36302292f1ba7491a2", "committedDate": "2020-09-30T13:00:20Z", "message": "Add directAllOrNothing/directBestEffort multicast Sinks (#2392)\n\nThese new Sinks.Many are close to DirectProcessor, except they don't\nterminate on backpressure. Instead, they either drop for all subscribers\n(all or nothing) or for the slow subscribers only (best effort)."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e92e28766e1b76974f4883b4480166008943bcc0", "author": {"user": {"login": "simonbasle", "name": "Simon Basl\u00e9"}}, "url": "https://github.com/reactor/reactor-core/commit/e92e28766e1b76974f4883b4480166008943bcc0", "committedDate": "2020-09-30T12:41:15Z", "message": "[fixup] check initRequest > 0 in StressSubscriber"}, "afterCommit": {"oid": "818ec001cd6e095c1ef63f36302292f1ba7491a2", "author": {"user": {"login": "simonbasle", "name": "Simon Basl\u00e9"}}, "url": "https://github.com/reactor/reactor-core/commit/818ec001cd6e095c1ef63f36302292f1ba7491a2", "committedDate": "2020-09-30T13:00:20Z", "message": "Add directAllOrNothing/directBestEffort multicast Sinks (#2392)\n\nThese new Sinks.Many are close to DirectProcessor, except they don't\nterminate on backpressure. Instead, they either drop for all subscribers\n(all or nothing) or for the slow subscribers only (best effort)."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2871, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}