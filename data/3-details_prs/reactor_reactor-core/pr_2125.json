{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA2MTUxOTAz", "number": 2125, "title": "Provides tests suite to expose onDiscard leaks and fixes", "bodyText": "Signed-off-by: Oleh Dokuka shadowgun@i.ua", "createdAt": "2020-04-20T15:59:14Z", "url": "https://github.com/reactor/reactor-core/pull/2125", "merged": true, "mergeCommit": {"oid": "c0ef7398f6dff284d4138ccfff1dfef39e434071"}, "closed": true, "closedAt": "2020-04-22T15:22:26Z", "author": {"login": "OlegDokuka"}, "timelineItems": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcZhjRdgBqjMyNTI1MzIyNDU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcaJe96gFqTM5ODI3MzE1MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0624ec6da01e80ebcd1912753c89e65ce71821a6", "author": {"user": {"login": "OlegDokuka", "name": "Oleh Dokuka"}}, "url": "https://github.com/reactor/reactor-core/commit/0624ec6da01e80ebcd1912753c89e65ce71821a6", "committedDate": "2020-04-20T15:58:36Z", "message": "provides tests suite to expose onDiscard leaks and fixes\n\nSigned-off-by: Oleh Dokuka <shadowgun@i.ua>"}, "afterCommit": {"oid": "6660f9916877fe6eb2970a1682a5bf3ac58cb2ca", "author": {"user": {"login": "OlegDokuka", "name": "Oleh Dokuka"}}, "url": "https://github.com/reactor/reactor-core/commit/6660f9916877fe6eb2970a1682a5bf3ac58cb2ca", "committedDate": "2020-04-20T16:19:26Z", "message": "provides tests suite to expose onDiscard leaks and fixes\n\nSigned-off-by: Oleh Dokuka <shadowgun@i.ua>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NjE3NDYx", "url": "https://github.com/reactor/reactor-core/pull/2125#pullrequestreview-396617461", "createdAt": "2020-04-20T16:28:44Z", "commit": {"oid": "6660f9916877fe6eb2970a1682a5bf3ac58cb2ca"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NjU0MzU2", "url": "https://github.com/reactor/reactor-core/pull/2125#pullrequestreview-396654356", "createdAt": "2020-04-20T17:16:06Z", "commit": {"oid": "2f486cbf4dd08af2af6082292bd0e0fbd1defe38"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNzoxNjowN1rOGIfF6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNzoxNjowN1rOGIfF6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU1MTIwOA==", "bodyText": "if possible (depends on whether or not future test cases will absolutely need the whole array of publishers in a single array variable), I would suggest the following signature:\nprotected abstract Publisher<Tracked<?>> transform(TestPublisher<Tracked<?>> firstUpstream, TestPublisher<Tracked<?>>... otherUpstreams);", "url": "https://github.com/reactor/reactor-core/pull/2125#discussion_r411551208", "createdAt": "2020-04-20T17:16:07Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/test/java/reactor/core/publisher/AbstractOnDiscardShouldNotLeakTest.java", "diffHunk": "@@ -40,7 +42,7 @@ public AbstractOnDiscardShouldNotLeakTest(boolean conditional, boolean fused) {\n         this.fused = fused;\n     }\n \n-    abstract Flux<Tracked<?>> transform(Flux<Tracked<?>> upstream);\n+    protected abstract Publisher<Tracked<?>> transform(TestPublisher<Tracked<?>>... upstreams);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f486cbf4dd08af2af6082292bd0e0fbd1defe38"}, "originalPosition": 18}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2f486cbf4dd08af2af6082292bd0e0fbd1defe38", "author": {"user": {"login": "OlegDokuka", "name": "Oleh Dokuka"}}, "url": "https://github.com/reactor/reactor-core/commit/2f486cbf4dd08af2af6082292bd0e0fbd1defe38", "committedDate": "2020-04-20T17:01:07Z", "message": "migrates to TestPublisher\n\nSigned-off-by: Oleh Dokuka <shadowgun@i.ua>"}, "afterCommit": {"oid": "9e5fc611146ba3103fa21467b050fdf9a42a4c46", "author": {"user": {"login": "OlegDokuka", "name": "Oleh Dokuka"}}, "url": "https://github.com/reactor/reactor-core/commit/9e5fc611146ba3103fa21467b050fdf9a42a4c46", "committedDate": "2020-04-20T17:17:29Z", "message": "migrates to TestPublisher\n\nSigned-off-by: Oleh Dokuka <shadowgun@i.ua>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3MjEyODg3", "url": "https://github.com/reactor/reactor-core/pull/2125#pullrequestreview-397212887", "createdAt": "2020-04-21T10:50:04Z", "commit": {"oid": "e71d24ed008b177d3da03600fad3fa3e1a698e4b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMDo1MDowNFrOGI_UTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMDo1MDowNFrOGI_UTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjA3OTE4MQ==", "bodyText": "should be in try {} finally {} to avoid a leak", "url": "https://github.com/reactor/reactor-core/pull/2125#discussion_r412079181", "createdAt": "2020-04-21T10:50:04Z", "author": {"login": "bsideup"}, "path": "reactor-core/src/test/java/reactor/core/publisher/AbstractOnDiscardShouldNotLeakTest.java", "diffHunk": "@@ -0,0 +1,443 @@\n+package reactor.core.publisher;\n+\n+import org.assertj.core.api.Assertions;\n+import org.assertj.core.api.Assumptions;\n+import org.junit.After;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.reactivestreams.Publisher;\n+import reactor.core.Fuseable;\n+import reactor.core.Scannable;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+import reactor.test.publisher.TestPublisher;\n+import reactor.test.subscriber.AssertSubscriber;\n+import reactor.test.util.RaceTestUtils;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+@RunWith(Parameterized.class)\n+public abstract class AbstractOnDiscardShouldNotLeakTest {\n+\n+    @Parameterized.Parameters\n+    public static Collection<Boolean[]> data() {\n+        return Arrays.asList(new Boolean[][] {\n+            { false, false },\n+            { true, false },\n+            { false, true },\n+            { true, true }\n+        });\n+    }\n+\n+    private final boolean conditional;\n+    private final boolean fused;\n+\n+    public AbstractOnDiscardShouldNotLeakTest(boolean conditional, boolean fused) {\n+        this.conditional = conditional;\n+        this.fused = fused;\n+    }\n+\n+    protected abstract Publisher<Tracked<?>> transform(TestPublisher<Tracked<?>> main, TestPublisher<Tracked<?>>... additional);\n+\n+    int subscriptionsNumber() {\n+        return 1;\n+    }\n+\n+    @After\n+    public void tearDown() {\n+        Hooks.resetOnNextDropped();\n+        Hooks.resetOnErrorDropped();\n+        Hooks.resetOnNextError();\n+        Hooks.resetOnOperatorError();\n+    }\n+\n+    @Test\n+    public void ensureMultipleSubscribersSupportWithNoLeaksWhenRacingCancelAndOnNextAndRequest() {\n+        Hooks.onNextDropped(Tracked::safeRelease);\n+        Hooks.onErrorDropped(e -> {});\n+        Hooks.onOperatorError((e,v) -> null);\n+        int subscriptionsNumber = subscriptionsNumber();\n+        Scheduler scheduler = Schedulers.newParallel(\"testScheduler\", subscriptionsNumber + 1);\n+        scheduler.start();\n+        for (int i = 0; i < 10000; i++) {\n+            int[] index = new int[] {subscriptionsNumber};\n+            TestPublisher<Tracked<?>>[] testPublishers = new TestPublisher[subscriptionsNumber];\n+\n+            for (int i1 = 0; i1 < subscriptionsNumber; i1++) {\n+                testPublishers[i1] = TestPublisher.createNoncompliant(TestPublisher.Violation.DEFER_CANCELLATION, TestPublisher.Violation.REQUEST_OVERFLOW);\n+            }\n+\n+            Publisher<Tracked<?>> source = transform(testPublishers[0], Arrays.copyOfRange(testPublishers, 1, testPublishers.length));\n+\n+            if (conditional) {\n+                if (source instanceof Flux) {\n+                    source = ((Flux<Tracked<?>>)source).filter(t -> true);\n+                } else {\n+                    source = ((Mono<Tracked<?>>)source).filter(t -> true);\n+                }\n+            }\n+\n+            AssertSubscriber<Tracked<?>> assertSubscriber = new AssertSubscriber<>(Operators.enableOnDiscard(null, Tracked::safeRelease), 0);\n+            if (fused) {\n+                assertSubscriber.requestedFusionMode(Fuseable.ANY);\n+            }\n+            source.subscribe(assertSubscriber);\n+\n+            if (subscriptionsNumber == 1) {\n+                Tracked<Integer> value = new Tracked<>(1);\n+                RaceTestUtils.race(() -> RaceTestUtils.race(assertSubscriber::cancel, () -> assertSubscriber.request(Long.MAX_VALUE), scheduler), () -> testPublishers[0].next(value), scheduler);\n+            } else {\n+                int startIndex = --index[0];\n+                Tracked<Integer> value1 = new Tracked<>(startIndex);\n+                int secondIndex = --index[0];\n+                Tracked<Integer> value2 = new Tracked<>(secondIndex);\n+                Runnable action = () -> RaceTestUtils.race(() -> testPublishers[startIndex].next(value1), () -> testPublishers[secondIndex].next(value2), scheduler);\n+\n+                while (index[0] > 0) {\n+                    int nextIndex = --index[0];\n+                    Tracked<Integer> nextValue = new Tracked<>(nextIndex);\n+                    Runnable nextAction = action;\n+                    action = () -> RaceTestUtils.race(nextAction, () -> testPublishers[nextIndex].next(nextValue), scheduler);\n+                }\n+                RaceTestUtils.race(() -> RaceTestUtils.race(assertSubscriber::cancel, () -> assertSubscriber.request(Long.MAX_VALUE), scheduler), action, scheduler);\n+            }\n+\n+            List<Tracked<?>> values = assertSubscriber.values();\n+            values.forEach(Tracked::release);\n+\n+            Tracked.assertNoLeaks();\n+        }\n+        scheduler.dispose();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e71d24ed008b177d3da03600fad3fa3e1a698e4b"}, "originalPosition": 116}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3MjEzMzIy", "url": "https://github.com/reactor/reactor-core/pull/2125#pullrequestreview-397213322", "createdAt": "2020-04-21T10:50:42Z", "commit": {"oid": "e71d24ed008b177d3da03600fad3fa3e1a698e4b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMDo1MDo0M1rOGI_VwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMDo1MDo0M1rOGI_VwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjA3OTU1Mg==", "bodyText": "this block seems to be repeated in tests, perhaps it can be reused", "url": "https://github.com/reactor/reactor-core/pull/2125#discussion_r412079552", "createdAt": "2020-04-21T10:50:43Z", "author": {"login": "bsideup"}, "path": "reactor-core/src/test/java/reactor/core/publisher/AbstractOnDiscardShouldNotLeakTest.java", "diffHunk": "@@ -0,0 +1,443 @@\n+package reactor.core.publisher;\n+\n+import org.assertj.core.api.Assertions;\n+import org.assertj.core.api.Assumptions;\n+import org.junit.After;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.reactivestreams.Publisher;\n+import reactor.core.Fuseable;\n+import reactor.core.Scannable;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+import reactor.test.publisher.TestPublisher;\n+import reactor.test.subscriber.AssertSubscriber;\n+import reactor.test.util.RaceTestUtils;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+@RunWith(Parameterized.class)\n+public abstract class AbstractOnDiscardShouldNotLeakTest {\n+\n+    @Parameterized.Parameters\n+    public static Collection<Boolean[]> data() {\n+        return Arrays.asList(new Boolean[][] {\n+            { false, false },\n+            { true, false },\n+            { false, true },\n+            { true, true }\n+        });\n+    }\n+\n+    private final boolean conditional;\n+    private final boolean fused;\n+\n+    public AbstractOnDiscardShouldNotLeakTest(boolean conditional, boolean fused) {\n+        this.conditional = conditional;\n+        this.fused = fused;\n+    }\n+\n+    protected abstract Publisher<Tracked<?>> transform(TestPublisher<Tracked<?>> main, TestPublisher<Tracked<?>>... additional);\n+\n+    int subscriptionsNumber() {\n+        return 1;\n+    }\n+\n+    @After\n+    public void tearDown() {\n+        Hooks.resetOnNextDropped();\n+        Hooks.resetOnErrorDropped();\n+        Hooks.resetOnNextError();\n+        Hooks.resetOnOperatorError();\n+    }\n+\n+    @Test\n+    public void ensureMultipleSubscribersSupportWithNoLeaksWhenRacingCancelAndOnNextAndRequest() {\n+        Hooks.onNextDropped(Tracked::safeRelease);\n+        Hooks.onErrorDropped(e -> {});\n+        Hooks.onOperatorError((e,v) -> null);\n+        int subscriptionsNumber = subscriptionsNumber();\n+        Scheduler scheduler = Schedulers.newParallel(\"testScheduler\", subscriptionsNumber + 1);\n+        scheduler.start();\n+        for (int i = 0; i < 10000; i++) {\n+            int[] index = new int[] {subscriptionsNumber};\n+            TestPublisher<Tracked<?>>[] testPublishers = new TestPublisher[subscriptionsNumber];\n+\n+            for (int i1 = 0; i1 < subscriptionsNumber; i1++) {\n+                testPublishers[i1] = TestPublisher.createNoncompliant(TestPublisher.Violation.DEFER_CANCELLATION, TestPublisher.Violation.REQUEST_OVERFLOW);\n+            }\n+\n+            Publisher<Tracked<?>> source = transform(testPublishers[0], Arrays.copyOfRange(testPublishers, 1, testPublishers.length));\n+\n+            if (conditional) {\n+                if (source instanceof Flux) {\n+                    source = ((Flux<Tracked<?>>)source).filter(t -> true);\n+                } else {\n+                    source = ((Mono<Tracked<?>>)source).filter(t -> true);\n+                }\n+            }\n+\n+            AssertSubscriber<Tracked<?>> assertSubscriber = new AssertSubscriber<>(Operators.enableOnDiscard(null, Tracked::safeRelease), 0);\n+            if (fused) {\n+                assertSubscriber.requestedFusionMode(Fuseable.ANY);\n+            }\n+            source.subscribe(assertSubscriber);\n+\n+            if (subscriptionsNumber == 1) {\n+                Tracked<Integer> value = new Tracked<>(1);\n+                RaceTestUtils.race(() -> RaceTestUtils.race(assertSubscriber::cancel, () -> assertSubscriber.request(Long.MAX_VALUE), scheduler), () -> testPublishers[0].next(value), scheduler);\n+            } else {\n+                int startIndex = --index[0];\n+                Tracked<Integer> value1 = new Tracked<>(startIndex);\n+                int secondIndex = --index[0];\n+                Tracked<Integer> value2 = new Tracked<>(secondIndex);\n+                Runnable action = () -> RaceTestUtils.race(() -> testPublishers[startIndex].next(value1), () -> testPublishers[secondIndex].next(value2), scheduler);\n+\n+                while (index[0] > 0) {\n+                    int nextIndex = --index[0];\n+                    Tracked<Integer> nextValue = new Tracked<>(nextIndex);\n+                    Runnable nextAction = action;\n+                    action = () -> RaceTestUtils.race(nextAction, () -> testPublishers[nextIndex].next(nextValue), scheduler);\n+                }\n+                RaceTestUtils.race(() -> RaceTestUtils.race(assertSubscriber::cancel, () -> assertSubscriber.request(Long.MAX_VALUE), scheduler), action, scheduler);\n+            }\n+\n+            List<Tracked<?>> values = assertSubscriber.values();\n+            values.forEach(Tracked::release);\n+\n+            Tracked.assertNoLeaks();\n+        }\n+        scheduler.dispose();\n+    }\n+\n+    @Test\n+    public void ensureNoLeaksPopulatedQueueAndRacingCancelAndOnNext() {\n+        Assumptions.assumeThat(subscriptionsNumber())\n+                .isOne();\n+        Hooks.onNextDropped(Tracked::safeRelease);\n+        Hooks.onErrorDropped(e -> {});\n+        Hooks.onOperatorError((e,v) -> null);\n+        Scheduler scheduler = Schedulers.newParallel(\"testScheduler\", subscriptionsNumber() + 1);\n+        scheduler.start();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e71d24ed008b177d3da03600fad3fa3e1a698e4b"}, "originalPosition": 127}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3MjE0Mjgz", "url": "https://github.com/reactor/reactor-core/pull/2125#pullrequestreview-397214283", "createdAt": "2020-04-21T10:52:13Z", "commit": {"oid": "e71d24ed008b177d3da03600fad3fa3e1a698e4b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMDo1MjoxM1rOGI_Zaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMDo1MjoxM1rOGI_Zaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjA4MDQ5MQ==", "bodyText": "why not just changing the latch to new CountDownLatch(4) and output the current value if await fails?", "url": "https://github.com/reactor/reactor-core/pull/2125#discussion_r412080491", "createdAt": "2020-04-21T10:52:13Z", "author": {"login": "bsideup"}, "path": "reactor-core/src/test/java/reactor/core/publisher/SerializedSubscriberTest.java", "diffHunk": "@@ -90,6 +90,9 @@ public void testLeakWithRetryWhenImmediatelyCancelled() throws InterruptedExcept\n \t\tAtomicInteger seen = new AtomicInteger();\n \n \t\tfinal CountDownLatch latch = new CountDownLatch(1);\n+\t\tfinal CountDownLatch latch1 = new CountDownLatch(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e71d24ed008b177d3da03600fad3fa3e1a698e4b"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3MjE0OTYy", "url": "https://github.com/reactor/reactor-core/pull/2125#pullrequestreview-397214962", "createdAt": "2020-04-21T10:53:15Z", "commit": {"oid": "e71d24ed008b177d3da03600fad3fa3e1a698e4b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMDo1MzoxNVrOGI_b6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMDo1MzoxNVrOGI_b6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjA4MTEzMQ==", "bodyText": "nit: looking at other similar tests, we could introduce AbstractFluxOnDiscardShouldNotLeakTest that defines transform(Flux, Flux)", "url": "https://github.com/reactor/reactor-core/pull/2125#discussion_r412081131", "createdAt": "2020-04-21T10:53:15Z", "author": {"login": "bsideup"}, "path": "reactor-core/src/test/java/reactor/core/publisher/FluxFlatMapIterableOnDiscardShouldNotLeakTest.java", "diffHunk": "@@ -0,0 +1,20 @@\n+package reactor.core.publisher;\n+\n+import org.reactivestreams.Publisher;\n+import reactor.test.publisher.TestPublisher;\n+\n+import java.util.Arrays;\n+\n+public class FluxFlatMapIterableOnDiscardShouldNotLeakTest extends AbstractOnDiscardShouldNotLeakTest {\n+\n+    public FluxFlatMapIterableOnDiscardShouldNotLeakTest(boolean conditional, boolean fused) {\n+        super(conditional, fused);\n+    }\n+\n+    @Override\n+    protected Publisher<Tracked<?>> transform(TestPublisher<Tracked<?>> main, TestPublisher<Tracked<?>>... additional) {\n+        return main", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e71d24ed008b177d3da03600fad3fa3e1a698e4b"}, "originalPosition": 16}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3MjE1OTEz", "url": "https://github.com/reactor/reactor-core/pull/2125#pullrequestreview-397215913", "createdAt": "2020-04-21T10:54:41Z", "commit": {"oid": "e71d24ed008b177d3da03600fad3fa3e1a698e4b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMDo1NDo0MVrOGI_fYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMDo1NDo0MVrOGI_fYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjA4MjAxNw==", "bodyText": "Have you considered adding this to BaseOperatorTest instead?", "url": "https://github.com/reactor/reactor-core/pull/2125#discussion_r412082017", "createdAt": "2020-04-21T10:54:41Z", "author": {"login": "bsideup"}, "path": "reactor-core/src/test/java/reactor/core/publisher/AbstractOnDiscardShouldNotLeakTest.java", "diffHunk": "@@ -0,0 +1,443 @@\n+package reactor.core.publisher;\n+\n+import org.assertj.core.api.Assertions;\n+import org.assertj.core.api.Assumptions;\n+import org.junit.After;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.reactivestreams.Publisher;\n+import reactor.core.Fuseable;\n+import reactor.core.Scannable;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+import reactor.test.publisher.TestPublisher;\n+import reactor.test.subscriber.AssertSubscriber;\n+import reactor.test.util.RaceTestUtils;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+@RunWith(Parameterized.class)\n+public abstract class AbstractOnDiscardShouldNotLeakTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e71d24ed008b177d3da03600fad3fa3e1a698e4b"}, "originalPosition": 26}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "44f0011b01b2a52d4f14f990ac4bf04b11f9c204", "author": {"user": {"login": "OlegDokuka", "name": "Oleh Dokuka"}}, "url": "https://github.com/reactor/reactor-core/commit/44f0011b01b2a52d4f14f990ac4bf04b11f9c204", "committedDate": "2020-04-21T11:38:20Z", "message": "fixes AbstractFluxOnDiscardShouldNotLeakTest\n\nSigned-off-by: Oleh Dokuka <shadowgun@i.ua>"}, "afterCommit": {"oid": "5ec2f86c5e277fb9fe99427d54aa7c8030550b4b", "author": {"user": {"login": "OlegDokuka", "name": "Oleh Dokuka"}}, "url": "https://github.com/reactor/reactor-core/commit/5ec2f86c5e277fb9fe99427d54aa7c8030550b4b", "committedDate": "2020-04-21T12:12:10Z", "message": "fixes AbstractFluxOnDiscardShouldNotLeakTest\n\nSigned-off-by: Oleh Dokuka <shadowgun@i.ua>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "86b44b1df05d256cebf14b5bdef1334e1989b8c4", "author": {"user": {"login": "OlegDokuka", "name": "Oleh Dokuka"}}, "url": "https://github.com/reactor/reactor-core/commit/86b44b1df05d256cebf14b5bdef1334e1989b8c4", "committedDate": "2020-04-21T17:32:49Z", "message": "adds extra logging\n\nSigned-off-by: Oleh Dokuka <shadowgun@i.ua>"}, "afterCommit": {"oid": "f6d476c9d1796d54de64c2429e24ec9f8fd7cfad", "author": {"user": {"login": "OlegDokuka", "name": "Oleh Dokuka"}}, "url": "https://github.com/reactor/reactor-core/commit/f6d476c9d1796d54de64c2429e24ec9f8fd7cfad", "committedDate": "2020-04-21T19:15:58Z", "message": "fixes flakky test\n\nSigned-off-by: Oleh Dokuka <shadowgun@i.ua>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5c6c19b6c7aaa449736a5f037e53547c1725d362", "author": {"user": {"login": "OlegDokuka", "name": "Oleh Dokuka"}}, "url": "https://github.com/reactor/reactor-core/commit/5c6c19b6c7aaa449736a5f037e53547c1725d362", "committedDate": "2020-04-22T10:48:57Z", "message": "ensures merge has enough sources\n\nSigned-off-by: Oleh Dokuka <shadowgun@i.ua>"}, "afterCommit": {"oid": "f7d300f8ed3bbaf97399e090d100cba626d2a97e", "author": {"user": {"login": "OlegDokuka", "name": "Oleh Dokuka"}}, "url": "https://github.com/reactor/reactor-core/commit/f7d300f8ed3bbaf97399e090d100cba626d2a97e", "committedDate": "2020-04-22T11:51:40Z", "message": "ensures merge has enough sources\n\nSigned-off-by: Oleh Dokuka <shadowgun@i.ua>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f7d300f8ed3bbaf97399e090d100cba626d2a97e", "author": {"user": {"login": "OlegDokuka", "name": "Oleh Dokuka"}}, "url": "https://github.com/reactor/reactor-core/commit/f7d300f8ed3bbaf97399e090d100cba626d2a97e", "committedDate": "2020-04-22T11:51:40Z", "message": "ensures merge has enough sources\n\nSigned-off-by: Oleh Dokuka <shadowgun@i.ua>"}, "afterCommit": {"oid": "028fc8110b7063bb647fa9121b5ca3229173ff96", "author": {"user": {"login": "simonbasle", "name": "Simon Basl\u00e9"}}, "url": "https://github.com/reactor/reactor-core/commit/028fc8110b7063bb647fa9121b5ca3229173ff96", "committedDate": "2020-04-22T12:38:56Z", "message": "[test] Extract Tracked to MemoryUtils, add OffHeapDetector\n\nThe Tracked util introduced in #2125 has been moved into MemoryUtils and\nthe concern of tracking and asserting these objects has been split out\ninto the OffHeapDetector class, ensuring that even if a test fails,\nother tests that use Tracked won't be polluted due to an uncleaned\nshared queue."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6f261c53b99ef88180b08709ab3fe9429f60a814", "author": {"user": {"login": "OlegDokuka", "name": "Oleh Dokuka"}}, "url": "https://github.com/reactor/reactor-core/commit/6f261c53b99ef88180b08709ab3fe9429f60a814", "committedDate": "2020-04-22T14:47:26Z", "message": "Fix some discard cases, provide cross-cutting discard test (#2125)\n\nThis commit fixes several operators handling of discard hooks in the\ncase of racing onNext and cancel (flatMap, flatMapIterable, publishOn,\nonBackpressureBuffer).\n\nAdditionally, it introduces a reusable test base for testing this\ncategory of discard cases.\n\nSigned-off-by: Oleh Dokuka <shadowgun@i.ua>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c0c6f3b2df619b31ae48b8b4e033cd1e809123dd", "author": {"user": {"login": "OlegDokuka", "name": "Oleh Dokuka"}}, "url": "https://github.com/reactor/reactor-core/commit/c0c6f3b2df619b31ae48b8b4e033cd1e809123dd", "committedDate": "2020-04-22T14:49:29Z", "message": "[test] Polish some flakky tests\n\nReviewed-in: #2125\nSigned-off-by: Oleh Dokuka <shadowgun@i.ua>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dcdee8f76a6f95661277ff71cf41d5e97fbd06b5", "author": {"user": {"login": "simonbasle", "name": "Simon Basl\u00e9"}}, "url": "https://github.com/reactor/reactor-core/commit/dcdee8f76a6f95661277ff71cf41d5e97fbd06b5", "committedDate": "2020-04-22T14:49:29Z", "message": "[Polish] Rework #2125 test cases into a single class\n\nThe abstract test class is replaced by a cross-cutting test class that\ncovers all relevant operators, which are provided as a collection of\nDiscardLeakScenarios. This allows to also test multiple variants of an\noperator without the need for one class per variant.\n\nThe tests have also been improved, with all hooks and schedulers setup\nand teardown done in the test lifecycle methods."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3f44e262d26c70a33d05330849e406f132cc245e", "author": {"user": {"login": "simonbasle", "name": "Simon Basl\u00e9"}}, "url": "https://github.com/reactor/reactor-core/commit/3f44e262d26c70a33d05330849e406f132cc245e", "committedDate": "2020-04-22T14:49:29Z", "message": "[test] Extract Tracked to MemoryUtils, add OffHeapDetector\n\nThe Tracked util introduced in #2125 has been moved into MemoryUtils and\nthe concern of tracking and asserting these objects has been split out\ninto the OffHeapDetector class, ensuring that even if a test fails,\nother tests that use Tracked won't be polluted due to an uncleaned\nshared queue."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "028fc8110b7063bb647fa9121b5ca3229173ff96", "author": {"user": {"login": "simonbasle", "name": "Simon Basl\u00e9"}}, "url": "https://github.com/reactor/reactor-core/commit/028fc8110b7063bb647fa9121b5ca3229173ff96", "committedDate": "2020-04-22T12:38:56Z", "message": "[test] Extract Tracked to MemoryUtils, add OffHeapDetector\n\nThe Tracked util introduced in #2125 has been moved into MemoryUtils and\nthe concern of tracking and asserting these objects has been split out\ninto the OffHeapDetector class, ensuring that even if a test fails,\nother tests that use Tracked won't be polluted due to an uncleaned\nshared queue."}, "afterCommit": {"oid": "3f44e262d26c70a33d05330849e406f132cc245e", "author": {"user": {"login": "simonbasle", "name": "Simon Basl\u00e9"}}, "url": "https://github.com/reactor/reactor-core/commit/3f44e262d26c70a33d05330849e406f132cc245e", "committedDate": "2020-04-22T14:49:29Z", "message": "[test] Extract Tracked to MemoryUtils, add OffHeapDetector\n\nThe Tracked util introduced in #2125 has been moved into MemoryUtils and\nthe concern of tracking and asserting these objects has been split out\ninto the OffHeapDetector class, ensuring that even if a test fails,\nother tests that use Tracked won't be polluted due to an uncleaned\nshared queue."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4MjczMTUw", "url": "https://github.com/reactor/reactor-core/pull/2125#pullrequestreview-398273150", "createdAt": "2020-04-22T14:51:05Z", "commit": {"oid": "3f44e262d26c70a33d05330849e406f132cc245e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2952, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}