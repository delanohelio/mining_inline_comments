{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY2NDAzNjc2", "number": 2021, "title": "fix #2014 Cancel discards concatMapIterable/fromIterable's remainder \u2026", "bodyText": "\u2026from iterator\nIf both an Iterator and a Spliterator can be generated for each of the\nprocessed Iterables, then the Spliterator is used to ensure the Iterable\nis SIZED. This allows us to safely assume we can iterate over the\nremainder of the iterator when cancelling, in order to discard its\nelements that weren't emitted.\nNot doing this check would likely cause trouble with infinite discarding\nloops in the case of infinite Iterables (which is technically possible).\nFor Streams, since both the iterator() and spliterator() methods are\nterminating the Stream we only generate the Spliterator. We use it to\ncheck SIZED and then wrap it in an Iterator adapter for iteration (which\nis what BaseStream does by default).\nNote that using a Spliterator to drive the internal iteration doesn't\nwork that well, since the default Iterable#spliterator isn't SIZED and\nits estimatedSize() method doesn't behave like hasNext().\nIterator#hasNext is far better suited for looking ahead of the emitted\nelement to trigger onComplete immediately after the last onNext.", "createdAt": "2020-01-23T14:53:45Z", "url": "https://github.com/reactor/reactor-core/pull/2021", "merged": true, "mergeCommit": {"oid": "00a23332e02542ae4f753b24e765a926e5865da1"}, "closed": true, "closedAt": "2020-02-07T10:02:03Z", "author": {"login": "simonbasle"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb9MDH_gFqTM0NzM4NTUzOA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcB78gvABqjMwMTY5NTc0Mzg=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3Mzg1NTM4", "url": "https://github.com/reactor/reactor-core/pull/2021#pullrequestreview-347385538", "createdAt": "2020-01-23T15:26:35Z", "commit": {"oid": "ceac4252f343d2607a34fc66fef6e2e5d5a8baa8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxNToyNjozNVrOFhCULA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxNToyNjozNVrOFhCULA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDE4NTI2MA==", "bodyText": "magical constant used in a few places, let's extract :)", "url": "https://github.com/reactor/reactor-core/pull/2021#discussion_r370185260", "createdAt": "2020-01-23T15:26:35Z", "author": {"login": "bsideup"}, "path": "reactor-core/src/main/java/reactor/core/publisher/FluxFlattenIterable.java", "diffHunk": "@@ -89,11 +91,11 @@ public void subscribe(CoreSubscriber<? super R> actual) {\n \t\t\t}\n \n \t\t\tIterator<? extends R> it;\n-\n+\t\t\tboolean knownToBeFinite;\n \t\t\ttry {\n \t\t\t\tIterable<? extends R> iter = mapper.apply(v);\n-\n \t\t\t\tit = iter.iterator();\n+\t\t\t\tknownToBeFinite = iter.spliterator().getExactSizeIfKnown() != -1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ceac4252f343d2607a34fc66fef6e2e5d5a8baa8"}, "originalPosition": 26}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3Mzg2MzM0", "url": "https://github.com/reactor/reactor-core/pull/2021#pullrequestreview-347386334", "createdAt": "2020-01-23T15:27:30Z", "commit": {"oid": "ceac4252f343d2607a34fc66fef6e2e5d5a8baa8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxNToyNzozMFrOFhCWnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxNToyNzozMFrOFhCWnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDE4NTg4Nw==", "bodyText": "this block seems to be repeated 9 times, wdyt about extracting it into a method?", "url": "https://github.com/reactor/reactor-core/pull/2021#discussion_r370185887", "createdAt": "2020-01-23T15:27:30Z", "author": {"login": "bsideup"}, "path": "reactor-core/src/main/java/reactor/core/publisher/FluxFlattenIterable.java", "diffHunk": "@@ -367,15 +378,21 @@ void drainAsync() {\n \t\t\t\t\twhile (e != r) {\n \t\t\t\t\t\tif (cancelled) {\n \t\t\t\t\t\t\tcurrent = null;\n-\t\t\t\t\t\t\tOperators.onDiscardQueueWithClear(q, ctx, null);\n+\t\t\t\t\t\t\tcurrentKnownToBeFinite = false; //reset explicitly", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ceac4252f343d2607a34fc66fef6e2e5d5a8baa8"}, "originalPosition": 113}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4NTczOTU1", "url": "https://github.com/reactor/reactor-core/pull/2021#pullrequestreview-348573955", "createdAt": "2020-01-27T10:49:19Z", "commit": {"oid": "88992af734ddbee9b874dc1ed442216edb7e1cda"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxMDo0OToxOVrOFh-gjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxMDo0OToxOVrOFh-gjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE3MTQ2OA==", "bodyText": "FYI I was looking at the sources of java.util.Spliterator and trying to find the -1 constant there.\ngetExactSizeIfKnown() is defined as:\n    default long getExactSizeIfKnown() {\n        return (characteristics() & SIZED) == 0 ? -1L : estimateSize();\n    }\nwhich means that we could also do (iter.spliterator().characteristics() & Spliterator.SIZED) == 0 instead of calling getExactSizeIfKnown() which also matches what we're actually checking. WDYT?", "url": "https://github.com/reactor/reactor-core/pull/2021#discussion_r371171468", "createdAt": "2020-01-27T10:49:19Z", "author": {"login": "bsideup"}, "path": "reactor-core/src/main/java/reactor/core/publisher/FluxFlattenIterable.java", "diffHunk": "@@ -89,11 +90,11 @@ public void subscribe(CoreSubscriber<? super R> actual) {\n \t\t\t}\n \n \t\t\tIterator<? extends R> it;\n-\n+\t\t\tboolean knownToBeFinite;\n \t\t\ttry {\n \t\t\t\tIterable<? extends R> iter = mapper.apply(v);\n-\n \t\t\t\tit = iter.iterator();\n+\t\t\t\tknownToBeFinite = iter.spliterator().getExactSizeIfKnown() != FluxIterable.SPLITERATOR_UNSIZED;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88992af734ddbee9b874dc1ed442216edb7e1cda"}, "originalPosition": 18}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ5OTcwMTU4", "url": "https://github.com/reactor/reactor-core/pull/2021#pullrequestreview-349970158", "createdAt": "2020-01-29T09:38:21Z", "commit": {"oid": "1505277b88197bc1f4dfe23fb6dbc13273099086"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwNzY2ODU3", "url": "https://github.com/reactor/reactor-core/pull/2021#pullrequestreview-350766857", "createdAt": "2020-01-30T11:52:44Z", "commit": {"oid": "1505277b88197bc1f4dfe23fb6dbc13273099086"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQxMTo1Mjo0NFrOFjoYxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQxMzoxNjoxNFrOFjqdwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjkwNjE4Mw==", "bodyText": "Couldn't we check first if Iterable is a  Collection as an optimization to avoid the Spliterator instance creation? It could be encapsulated in an utility method since this is done quite a few times.", "url": "https://github.com/reactor/reactor-core/pull/2021#discussion_r372906183", "createdAt": "2020-01-30T11:52:44Z", "author": {"login": "rstoyanchev"}, "path": "reactor-core/src/main/java/reactor/core/publisher/FluxFlattenIterable.java", "diffHunk": "@@ -89,11 +91,11 @@ public void subscribe(CoreSubscriber<? super R> actual) {\n \t\t\t}\n \n \t\t\tIterator<? extends R> it;\n-\n+\t\t\tboolean knownToBeFinite;\n \t\t\ttry {\n \t\t\t\tIterable<? extends R> iter = mapper.apply(v);\n-\n \t\t\t\tit = iter.iterator();\n+\t\t\t\tknownToBeFinite = iter.spliterator().hasCharacteristics(Spliterator.SIZED);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1505277b88197bc1f4dfe23fb6dbc13273099086"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjkxMjgxNA==", "bodyText": "Maybe resetCurrent() reads better. Clear sounds a lot like clearing content, as in aCollection, which is also implemented here.", "url": "https://github.com/reactor/reactor-core/pull/2021#discussion_r372912814", "createdAt": "2020-01-30T12:08:23Z", "author": {"login": "rstoyanchev"}, "path": "reactor-core/src/main/java/reactor/core/publisher/FluxFlattenIterable.java", "diffHunk": "@@ -275,18 +279,27 @@ public void cancel() {\n \t\t\t\ts.cancel();\n \n \t\t\t\tif (WIP.getAndIncrement(this) == 0) {\n-\t\t\t\t\tOperators.onDiscardQueueWithClear(queue, actual.currentContext(), null);\n+\t\t\t\t\tContext context = actual.currentContext();\n+\t\t\t\t\tOperators.onDiscardQueueWithClear(queue, context, null);\n+\t\t\t\t\tOperators.onDiscardMultiple(current, currentKnownToBeFinite, context);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n+\t\t//should be kept small and final to favor inlining\n+\t\tfinal void clearIterator() {\n+\t\t\tcurrent = null;\n+\t\t\tcurrentKnownToBeFinite = false;\n+\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1505277b88197bc1f4dfe23fb6dbc13273099086"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjkzNzE2Mw==", "bodyText": "I noticed onCloseWithDropError in both subscriptions don't call onDiscardMultiple. Perhaps there is a reason, but it looks like the iterator may have more items (e.g. in poll() if an item is null).", "url": "https://github.com/reactor/reactor-core/pull/2021#discussion_r372937163", "createdAt": "2020-01-30T13:09:24Z", "author": {"login": "rstoyanchev"}, "path": "reactor-core/src/main/java/reactor/core/publisher/FluxIterable.java", "diffHunk": "@@ -19,16 +19,20 @@\n import java.util.Collection;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1505277b88197bc1f4dfe23fb6dbc13273099086"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjkzOTg2Nw==", "bodyText": "Isn't this initialization redundant? It will be updated before its used.", "url": "https://github.com/reactor/reactor-core/pull/2021#discussion_r372939867", "createdAt": "2020-01-30T13:15:31Z", "author": {"login": "rstoyanchev"}, "path": "reactor-core/src/main/java/reactor/core/publisher/FluxFlattenIterable.java", "diffHunk": "@@ -658,6 +697,7 @@ public boolean isEmpty() {\n \t\t@Nullable\n \t\tpublic R poll() {\n \t\t\tIterator<? extends R> it = current;\n+\t\t\tboolean itFinite = currentKnownToBeFinite;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1505277b88197bc1f4dfe23fb6dbc13273099086"}, "originalPosition": 360}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjk0MDIyNA==", "bodyText": "Likewise setting this here seems redundant since itFinite will be set again before its used.", "url": "https://github.com/reactor/reactor-core/pull/2021#discussion_r372940224", "createdAt": "2020-01-30T13:16:14Z", "author": {"login": "rstoyanchev"}, "path": "reactor-core/src/main/java/reactor/core/publisher/FluxFlattenIterable.java", "diffHunk": "@@ -679,16 +721,18 @@ public R poll() {\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \t\t\t\t\tcurrent = it;\n+\t\t\t\t\tcurrentKnownToBeFinite = itFinite;\n \t\t\t\t}\n \t\t\t\telse if (!it.hasNext()) {\n \t\t\t\t\tit = null;\n+\t\t\t\t\titFinite = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1505277b88197bc1f4dfe23fb6dbc13273099086"}, "originalPosition": 386}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0NjQ0MDI3", "url": "https://github.com/reactor/reactor-core/pull/2021#pullrequestreview-354644027", "createdAt": "2020-02-06T17:40:33Z", "commit": {"oid": "812d2657dabcf35d03e1a5e24fafa355ebdef320"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "db7d3cb26e209e39965e43600ad95a3e2088f499", "author": {"user": {"login": "simonbasle", "name": "Simon Basl\u00e9"}}, "url": "https://github.com/reactor/reactor-core/commit/db7d3cb26e209e39965e43600ad95a3e2088f499", "committedDate": "2020-02-07T09:24:05Z", "message": "fix #2014 Discard concatMapIterable/fromIterable's remainder on Cancel\n\nIn this change, the goal is to discard elements of the Iterable that\nhaven't been processed yet. The challenge is to avoid attempting doing\nso for _infinite_ Iterables (which would lead to infinite discarding\nloops).\n\nIf the Iterable is a Collection, it should be finite.\n\nIf both an Iterator and a Spliterator can be generated for each of the\nprocessed Iterables, then the Spliterator is used to ensure the Iterable\nis SIZED. This allows us to safely assume we can iterate over the\nremainder of the iterator when cancelling, in order to discard its\nelements that weren't emitted.\n\nFor Streams, since both the iterator() and spliterator() methods are\nterminating the Stream we only generate the Spliterator. We use it to\ncheck SIZED and then wrap it in an Iterator adapter for iteration (which\nis what BaseStream does by default).\n\nImplementation Notes\n----\nWe didn't fully switch to using a Spliterator to drive the internal\niteration. It doesn't work that well, since the Iterable#spliterator\ndefault implementation isn't SIZED and its estimatedSize() method does\nnot behave like hasNext().\nIterator#hasNext is far better suited for looking ahead of the emitted\nelement to trigger onComplete immediately after the last onNext."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f0dfc644388c353cd0ddf641210c2e7414ea042b", "author": {"user": {"login": "simonbasle", "name": "Simon Basl\u00e9"}}, "url": "https://github.com/reactor/reactor-core/commit/f0dfc644388c353cd0ddf641210c2e7414ea042b", "committedDate": "2020-02-07T09:29:45Z", "message": "[polish] Improve onDiscardMultiple/QueueWithClear resiliency (#2021)\n\nThis commit improves discard resiliency when dealing with queues,\nstreams, collections and iterators. By introducing finer grained\ntry/catch blocks, we ensure that failures around a single discarded\nelement doesn't prevent discarding of further elements of the container."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "812d2657dabcf35d03e1a5e24fafa355ebdef320", "author": {"user": {"login": "simonbasle", "name": "Simon Basl\u00e9"}}, "url": "https://github.com/reactor/reactor-core/commit/812d2657dabcf35d03e1a5e24fafa355ebdef320", "committedDate": "2020-02-03T15:09:17Z", "message": "[polish] Improve onDiscardMultiple/QueueWithClear resiliency\n\nThis commit improves discard resiliency when dealing with queues,\nstreams, collections and iterators. By introducing finer grained\ntry/catch blocks, we ensure that failures around a single discarded\nelement don't prevent discarding of further elements of the container."}, "afterCommit": {"oid": "f0dfc644388c353cd0ddf641210c2e7414ea042b", "author": {"user": {"login": "simonbasle", "name": "Simon Basl\u00e9"}}, "url": "https://github.com/reactor/reactor-core/commit/f0dfc644388c353cd0ddf641210c2e7414ea042b", "committedDate": "2020-02-07T09:29:45Z", "message": "[polish] Improve onDiscardMultiple/QueueWithClear resiliency (#2021)\n\nThis commit improves discard resiliency when dealing with queues,\nstreams, collections and iterators. By introducing finer grained\ntry/catch blocks, we ensure that failures around a single discarded\nelement doesn't prevent discarding of further elements of the container."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2892, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}