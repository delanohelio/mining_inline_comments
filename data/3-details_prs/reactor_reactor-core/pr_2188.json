{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMzMTQxODYy", "number": 2188, "title": "Introduce Sinks and deprecate concrete processors", "bodyText": "Last debated and designed in #2179 but also relates to #1169, #1296, #1172, #1170\nFixes #2179\nFixes #2203", "createdAt": "2020-06-11T15:04:28Z", "url": "https://github.com/reactor/reactor-core/pull/2188", "merged": true, "mergeCommit": {"oid": "ede41493b91a0cfc45b37f13dc2f6b7bba3712e7"}, "closed": true, "closedAt": "2020-06-19T17:51:54Z", "author": {"login": "simonbasle"}, "timelineItems": {"totalCount": 42, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcqPq9YABqjM0MzQ2MDUwNzc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcuLAZJgFqTQzNjEwODIyOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "df217fe2a654e2644155f76fbd8d62f9418e7d84", "author": {"user": {"login": "simonbasle", "name": "Simon Basl\u00e9"}}, "url": "https://github.com/reactor/reactor-core/commit/df217fe2a654e2644155f76fbd8d62f9418e7d84", "committedDate": "2020-06-11T15:01:25Z", "message": "wip first round of deprecation fixes for tests"}, "afterCommit": {"oid": "e26ada7999dd24f5a65a8a7781c5e835839b3e53", "author": {"user": {"login": "simonbasle", "name": "Simon Basl\u00e9"}}, "url": "https://github.com/reactor/reactor-core/commit/e26ada7999dd24f5a65a8a7781c5e835839b3e53", "committedDate": "2020-06-11T15:06:07Z", "message": "wip first round of deprecation fixes for tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI5MDMxMDI4", "url": "https://github.com/reactor/reactor-core/pull/2188#pullrequestreview-429031028", "createdAt": "2020-06-11T15:30:02Z", "commit": {"oid": "e26ada7999dd24f5a65a8a7781c5e835839b3e53"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNTozMDowMlrOGiipjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNTozMDowMlrOGiipjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg3MjQ2Mg==", "bodyText": "Can these wait until a major to be removed?", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r438872462", "createdAt": "2020-06-11T15:30:02Z", "author": {"login": "spencergibb"}, "path": "reactor-core/src/main/java/reactor/core/publisher/DirectProcessor.java", "diffHunk": "@@ -77,7 +78,9 @@\n  * </p>\n  *\n  * @param <T> the input and output value type\n+ * @deprecated Prefer clear cut usage of either {@link Processors} or {@link Sinks}, to be removed in 3.5", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e26ada7999dd24f5a65a8a7781c5e835839b3e53"}, "originalPosition": 12}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "52fa84bf2422d36200d0e14a79e104d16702766a", "author": {"user": {"login": "simonbasle", "name": "Simon Basl\u00e9"}}, "url": "https://github.com/reactor/reactor-core/commit/52fa84bf2422d36200d0e14a79e104d16702766a", "committedDate": "2020-06-18T17:43:10Z", "message": "Introduce FluxSink superinterface, Sinks vs Processors...\n\nAlso deprecate FluxProcessor concrete implementations."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ae1e25df970d6bbda1a3d9d6c35f3459bf474390", "author": {"user": {"login": "simonbasle", "name": "Simon Basl\u00e9"}}, "url": "https://github.com/reactor/reactor-core/commit/ae1e25df970d6bbda1a3d9d6c35f3459bf474390", "committedDate": "2020-06-18T17:43:10Z", "message": "Fix compilation of prod+test; fix warnings in prod"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8ac71c31731e111c05992ac8e95ecb4b42363d1f", "author": {"user": {"login": "simonbasle", "name": "Simon Basl\u00e9"}}, "url": "https://github.com/reactor/reactor-core/commit/8ac71c31731e111c05992ac8e95ecb4b42363d1f", "committedDate": "2020-06-18T17:43:10Z", "message": "Update guide to use Sinks.hotFlux instead of DirectProcessor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "85f274caafbd3a5967aecdef363722948581f4ca", "author": {"user": {"login": "simonbasle", "name": "Simon Basl\u00e9"}}, "url": "https://github.com/reactor/reactor-core/commit/85f274caafbd3a5967aecdef363722948581f4ca", "committedDate": "2020-06-18T17:43:10Z", "message": "wip first round of deprecation fixes for tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d70f60271ea604e385f11769d0d301610d9b5375", "author": {"user": {"login": "simonbasle", "name": "Simon Basl\u00e9"}}, "url": "https://github.com/reactor/reactor-core/commit/d70f60271ea604e385f11769d0d301610d9b5375", "committedDate": "2020-06-18T17:43:11Z", "message": "Fixup UnicastProcessor initial request"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4b3b42874e89d1aea553abbcb3ff26cbb4fd719f", "author": {"user": {"login": "simonbasle", "name": "Simon Basl\u00e9"}}, "url": "https://github.com/reactor/reactor-core/commit/4b3b42874e89d1aea553abbcb3ff26cbb4fd719f", "committedDate": "2020-06-18T17:43:11Z", "message": "Have UnicastProcessor expose ACTUAL attribute"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "83c9a9041d019d56b3570d4ffd72b169eedd4a2d", "author": {"user": {"login": "simonbasle", "name": "Simon Basl\u00e9"}}, "url": "https://github.com/reactor/reactor-core/commit/83c9a9041d019d56b3570d4ffd72b169eedd4a2d", "committedDate": "2020-06-18T17:43:11Z", "message": "Replace processor with standalone sink in FluxBufferTimeoutTest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a624c76af0d8b2dc907133357d756754529006a6", "author": {"user": {"login": "simonbasle", "name": "Simon Basl\u00e9"}}, "url": "https://github.com/reactor/reactor-core/commit/a624c76af0d8b2dc907133357d756754529006a6", "committedDate": "2020-06-18T17:43:11Z", "message": "Remove deprecated uses of concrete processors in flux tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "55805025a2f6cf5bee36ad901ef5397fee258876", "author": {"user": {"login": "simonbasle", "name": "Simon Basl\u00e9"}}, "url": "https://github.com/reactor/reactor-core/commit/55805025a2f6cf5bee36ad901ef5397fee258876", "committedDate": "2020-06-18T17:43:11Z", "message": "Remove deprecated uses of concrete processors in reactor-test tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "91e7bcbbae15a17031cefedc70e86e3f3bf758d1", "author": {"user": {"login": "simonbasle", "name": "Simon Basl\u00e9"}}, "url": "https://github.com/reactor/reactor-core/commit/91e7bcbbae15a17031cefedc70e86e3f3bf758d1", "committedDate": "2020-06-18T17:43:11Z", "message": "Remove deprecated uses of concrete processors in BaseOperatorTest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2570dc929e534ae8a2ce139dea375d8d2ec3e018", "author": {"user": {"login": "simonbasle", "name": "Simon Basl\u00e9"}}, "url": "https://github.com/reactor/reactor-core/commit/2570dc929e534ae8a2ce139dea375d8d2ec3e018", "committedDate": "2020-06-18T17:43:11Z", "message": "SinkFlux to SequenceSink, add ScalarSink, add more flavors\n\nTODO test latest() and trigger() mono-like sinks."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e5589ad86ba398592d83f2f1c33ab440755d3de5", "author": {"user": {"login": "simonbasle", "name": "Simon Basl\u00e9"}}, "url": "https://github.com/reactor/reactor-core/commit/e5589ad86ba398592d83f2f1c33ab440755d3de5", "committedDate": "2020-06-18T17:43:11Z", "message": "Align Processors size replay method naming with Sinks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "161b5106420ed8f920092edc4968464e944cd651", "author": {"user": {"login": "simonbasle", "name": "Simon Basl\u00e9"}}, "url": "https://github.com/reactor/reactor-core/commit/161b5106420ed8f920092edc4968464e944cd651", "committedDate": "2020-06-18T17:43:11Z", "message": "Remove SequenceToMonoSink, polish"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "45a7458528d1caee41db04c0f4ce3309cca55808", "author": {"user": {"login": "simonbasle", "name": "Simon Basl\u00e9"}}, "url": "https://github.com/reactor/reactor-core/commit/45a7458528d1caee41db04c0f4ce3309cca55808", "committedDate": "2020-06-18T17:43:11Z", "message": "polish unicast() sink and test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c52e32b4aea4885830ae7d89b397d6068b036107", "author": {"user": {"login": "simonbasle", "name": "Simon Basl\u00e9"}}, "url": "https://github.com/reactor/reactor-core/commit/c52e32b4aea4885830ae7d89b397d6068b036107", "committedDate": "2020-06-18T17:43:11Z", "message": "Add documentation around standalone sinks"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fa18e8aec89e31578ff4b3d34ea41a088417bb23", "author": {"user": {"login": "simonbasle", "name": "Simon Basl\u00e9"}}, "url": "https://github.com/reactor/reactor-core/commit/fa18e8aec89e31578ff4b3d34ea41a088417bb23", "committedDate": "2020-06-18T14:53:08Z", "message": "SinkFlux to SequenceSink, add ScalarSink, add more flavors\n\nTODO test latest() and trigger() mono-like sinks."}, "afterCommit": {"oid": "c52e32b4aea4885830ae7d89b397d6068b036107", "author": {"user": {"login": "simonbasle", "name": "Simon Basl\u00e9"}}, "url": "https://github.com/reactor/reactor-core/commit/c52e32b4aea4885830ae7d89b397d6068b036107", "committedDate": "2020-06-18T17:43:11Z", "message": "Add documentation around standalone sinks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ab76df0c1cd9fcaea8e53579a05789e6b5bbdd3f", "author": {"user": {"login": "simonbasle", "name": "Simon Basl\u00e9"}}, "url": "https://github.com/reactor/reactor-core/commit/ab76df0c1cd9fcaea8e53579a05789e6b5bbdd3f", "committedDate": "2020-06-18T18:18:14Z", "message": "polish asciidoc and fix issues"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d222ce1ac5a54f75a2212488c4ba340bdb6a3614", "author": {"user": {"login": "simonbasle", "name": "Simon Basl\u00e9"}}, "url": "https://github.com/reactor/reactor-core/commit/d222ce1ac5a54f75a2212488c4ba340bdb6a3614", "committedDate": "2020-06-18T18:25:11Z", "message": "Swap multicast() and multicastPreWarming, buffer by defaut"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "299a170088e47afaa060b550a7d9a4772169af30", "author": {"user": {"login": "simonbasle", "name": "Simon Basl\u00e9"}}, "url": "https://github.com/reactor/reactor-core/commit/299a170088e47afaa060b550a7d9a4772169af30", "committedDate": "2020-06-18T18:25:47Z", "message": "Align multicastReplay Sinks naming with replay Processors"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjU0MDE3", "url": "https://github.com/reactor/reactor-core/pull/2188#pullrequestreview-433654017", "createdAt": "2020-06-18T21:17:40Z", "commit": {"oid": "299a170088e47afaa060b550a7d9a4772169af30"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMToxNzo0MFrOGmAiVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMToxNzo0MFrOGmAiVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUwNzg2MQ==", "bodyText": "Since asFlux() exposes Flux<T> but not concrete Processor onEachOperator hook could be applied here.\nSince FluxProcessors are ASYNC Publishers it could help with Thread context propagations", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442507861", "createdAt": "2020-06-18T21:17:40Z", "author": {"login": "robotmrv"}, "path": "reactor-core/src/main/java/reactor/core/publisher/Sinks.java", "diffHunk": "@@ -0,0 +1,262 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import org.reactivestreams.Subscriber;\n+\n+import reactor.util.annotation.Nullable;\n+import reactor.util.concurrent.Queues;\n+import reactor.util.context.Context;\n+\n+/**\n+ * A collection of standalone sinks ({@link StandaloneFluxSink} and\n+ * {@link StandaloneMonoSink}).\n+ *\n+ * @author Simon Basl\u00e9\n+ */\n+public final class Sinks {\n+\n+\tprivate Sinks() { }\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand by conforming to the lowest demand in case\n+\t *     of multiple subscribers.</li>\n+\t *     <li>Replaying: No replay. Only forwards to a {@link Subscriber} the elements that have been\n+\t *     pushed to the sink AFTER this subscriber was subscribed. To the exception of the first\n+\t *     subscriber (see below).</li>\n+\t *     <li>Without {@link Subscriber}: warm up. Remembers up to {@link Queues#SMALL_BUFFER_SIZE}\n+\t *     elements pushed before the first {@link Subscriber} is registered.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> multicast() {\n+\t\treturn new FluxProcessorSink<>(EmitterProcessor.create(Queues.SMALL_BUFFER_SIZE));\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n+\t *     <li>Replaying: No replay. Only forwards to a {@link Subscriber} the elements that have been\n+\t *     pushed to the sink AFTER this subscriber was subscribed.</li>\n+\t *     <li>Without {@link Subscriber}: Discarding. Pushing elements while there are no {@link Subscriber}\n+\t *     registered will simply discard these elements instead of \"warming up\" the sink.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> multicastNoWarmup() {\n+\t\treturn new FluxProcessorSink<>(ReplayProcessor.create(0));\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n+\t *     <li>Replaying: by {@code historySize}. Keeps the last {@code historySize} elements and\n+\t *     replays them instantly to new subscribers before continuing with \"live\" elements.</li>\n+\t *     <li>Without {@link Subscriber}: buffers enough elements pushed without a subscriber to\n+\t *     honor the {@code historySize}.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> replay(int historySize) {\n+\t\treturn new FluxProcessorSink<>(ReplayProcessor.create(historySize));\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n+\t *     <li>Replaying: all elements pushed to this sink are replayed to new subscribers.</li>\n+\t *     <li>Without {@link Subscriber}: all elements pushed to this sink are remembered,\n+\t *     even when there is no subscriber.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> replayAll() {\n+\t\treturn new FluxProcessorSink<>(ReplayProcessor.create());\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li><strong>Unicast</strong>: contrary to most other {@link StandaloneFluxSink}, the\n+\t *     {@link Flux} view rejects {@link Subscriber subscribers} past the first one.</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of its single {@link Subscriber}.</li>\n+\t *     <li>Replaying: non-applicable, since only one {@link Subscriber} can register.</li>\n+\t *     <li>Without {@link Subscriber}: all elements pushed to this sink are remembered and will\n+\t *     be replayed once the {@link Subscriber} subscribes.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> unicast() {\n+\t\treturn new FluxProcessorSink<>(UnicastProcessor.create());\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneMonoSink} that can be triggered at any time by either of\n+\t * the three completions: {@link ScalarSink#success(Object) valued completion},\n+\t * {@link ScalarSink#success() empty completions} or {@link ScalarSink#error(Throwable) error}.\n+\t * This completion is replayed to late subscribers.\n+\t */\n+\tpublic static <T> StandaloneMonoSink<T> trigger() {\n+\t\treturn new MonoProcessorSink<>(MonoProcessor.create());\n+\t}\n+\n+\t// == interfaces ==\n+\n+\t/**\n+\t * A flavor of {@link SequenceSink} that is not attached to a single {@link Subscriber}\n+\t * but rather viewable {@link #asFlux() as a Flux}. Most likely, such a {@link SequenceSink}\n+\t * is capable of multicasting to several subscribers. However implementations can chose\n+\t * to be unicast instead, and only accept one {@link Subscriber} at a time (as allowed\n+\t * by the {@link org.reactivestreams.Publisher} specification).\n+\t *\n+\t * @param <T> the type of elements that can be emitted through this sink\n+\t */\n+\tpublic interface StandaloneFluxSink<T> extends SequenceSink<T> {\n+\n+\t\t@Override\n+\t\tStandaloneFluxSink<T> next(T t);\n+\n+\t\t/**\n+\t\t * Return the companion {@link Flux} instance that is backed by this sink.\n+\t\t * All calls to this method return the same instance.\n+\t\t *\n+\t\t * @return the {@link Flux} view associated to this {@link StandaloneFluxSink}\n+\t\t */\n+\t\tFlux<T> asFlux();\n+\n+\t}\n+\n+\t/**\n+\t * A flavor of {@link ScalarSink} that is not attached to a single {@link Subscriber}\n+\t * but rather viewable {@link #asMono() as a Mono}. Most likely, such a {@link ScalarSink}\n+\t * is capable of multicasting to several subscribers. However implementations can chose\n+\t * to be unicast instead, and only accept one {@link Subscriber} at a time (as allowed\n+\t * by the {@link org.reactivestreams.Publisher} specification).\n+\t *\n+\t * @param <T> the type of elements that can be emitted through this sink\n+\t */\n+\tpublic interface StandaloneMonoSink<T> extends ScalarSink<T> {\n+\n+\t\t/**\n+\t\t * Return the companion {@link Mono} instance that is backed by this sink.\n+\t\t * All calls to this method return the same instance.\n+\t\t *\n+\t\t * @return the {@link Mono} view associated to this {@link StandaloneMonoSink}\n+\t\t */\n+\t\tMono<T> asMono();\n+\t}\n+\n+\t// == concrete classes ==\n+\n+\tstatic final class FluxProcessorSink<T>\n+\t\t\timplements StandaloneFluxSink<T> {\n+\n+\t\tfinal FluxSink<T>         delegateSink;\n+\t\tfinal FluxProcessor<T, T> processor;\n+\n+\t\t@SuppressWarnings(\"deprecation\")\n+\t\tFluxProcessorSink(FluxProcessor<T, T> processor) {\n+\t\t\tthis.processor = processor;\n+\t\t\tthis.delegateSink = processor.sink();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Flux<T> asFlux() {\n+\t\t\treturn processor;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "299a170088e47afaa060b550a7d9a4772169af30"}, "originalPosition": 188}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzOTA1MzQx", "url": "https://github.com/reactor/reactor-core/pull/2188#pullrequestreview-433905341", "createdAt": "2020-06-19T08:41:34Z", "commit": {"oid": "299a170088e47afaa060b550a7d9a4772169af30"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwODo0MTozNFrOGmNEkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwODo0MTozNFrOGmNEkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcxMzIzMw==", "bodyText": "shouldn't it inherit the javadocs?", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442713233", "createdAt": "2020-06-19T08:41:34Z", "author": {"login": "bsideup"}, "path": "reactor-core/src/main/java/reactor/core/publisher/FluxSink.java", "diffHunk": "@@ -31,12 +31,10 @@\n  * <p>\n  * @param <T> the value type\n  */\n-public interface FluxSink<T> {\n+public interface FluxSink<T> extends SequenceSink<T> {\n \n-\t/**\n-     * @see Subscriber#onComplete()\n-     */\n-    void complete();\n+\t@Override", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "299a170088e47afaa060b550a7d9a4772169af30"}, "originalPosition": 21}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzOTA2MzU0", "url": "https://github.com/reactor/reactor-core/pull/2188#pullrequestreview-433906354", "createdAt": "2020-06-19T08:45:59Z", "commit": {"oid": "299a170088e47afaa060b550a7d9a4772169af30"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwODo0NjowMFrOGmNJhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwODo0NjowMFrOGmNJhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcxNDUwMg==", "bodyText": "FYI one of the reasons why I was choosing concrete type over FluxProcessor is because having to specify the type argument twice was a bit cumbersome.\nAs this is a new API, perhaps we can do something about it? especially given that now it is always <T, T>", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442714502", "createdAt": "2020-06-19T08:46:00Z", "author": {"login": "bsideup"}, "path": "reactor-core/src/main/java/reactor/core/publisher/Processors.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import java.time.Duration;\n+import java.util.Queue;\n+import java.util.function.Consumer;\n+\n+import reactor.core.Disposable;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.util.annotation.Nullable;\n+\n+/**\n+ * @author Simon Basl\u00e9\n+ */\n+public final class Processors {\n+\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static final <T> FluxProcessor<T, T> unicast() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "299a170088e47afaa060b550a7d9a4772169af30"}, "originalPosition": 34}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzOTA3MjQ4", "url": "https://github.com/reactor/reactor-core/pull/2188#pullrequestreview-433907248", "createdAt": "2020-06-19T08:50:12Z", "commit": {"oid": "299a170088e47afaa060b550a7d9a4772169af30"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwODo1MDoxMlrOGmNNIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwODo1MDoxMlrOGmNNIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcxNTQyNA==", "bodyText": "\"warmup\" sounds like a new term added. And, TBH, I struggle to understand it (even after reading the javadoc) \ud83d\ude05\nCould you please help me understanding the concept?", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442715424", "createdAt": "2020-06-19T08:50:12Z", "author": {"login": "bsideup"}, "path": "reactor-core/src/main/java/reactor/core/publisher/Sinks.java", "diffHunk": "@@ -0,0 +1,262 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import org.reactivestreams.Subscriber;\n+\n+import reactor.util.annotation.Nullable;\n+import reactor.util.concurrent.Queues;\n+import reactor.util.context.Context;\n+\n+/**\n+ * A collection of standalone sinks ({@link StandaloneFluxSink} and\n+ * {@link StandaloneMonoSink}).\n+ *\n+ * @author Simon Basl\u00e9\n+ */\n+public final class Sinks {\n+\n+\tprivate Sinks() { }\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand by conforming to the lowest demand in case\n+\t *     of multiple subscribers.</li>\n+\t *     <li>Replaying: No replay. Only forwards to a {@link Subscriber} the elements that have been\n+\t *     pushed to the sink AFTER this subscriber was subscribed. To the exception of the first\n+\t *     subscriber (see below).</li>\n+\t *     <li>Without {@link Subscriber}: warm up. Remembers up to {@link Queues#SMALL_BUFFER_SIZE}\n+\t *     elements pushed before the first {@link Subscriber} is registered.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> multicast() {\n+\t\treturn new FluxProcessorSink<>(EmitterProcessor.create(Queues.SMALL_BUFFER_SIZE));\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n+\t *     <li>Replaying: No replay. Only forwards to a {@link Subscriber} the elements that have been\n+\t *     pushed to the sink AFTER this subscriber was subscribed.</li>\n+\t *     <li>Without {@link Subscriber}: Discarding. Pushing elements while there are no {@link Subscriber}\n+\t *     registered will simply discard these elements instead of \"warming up\" the sink.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> multicastNoWarmup() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "299a170088e47afaa060b550a7d9a4772169af30"}, "originalPosition": 65}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzOTEzMjUx", "url": "https://github.com/reactor/reactor-core/pull/2188#pullrequestreview-433913251", "createdAt": "2020-06-19T09:00:39Z", "commit": {"oid": "299a170088e47afaa060b550a7d9a4772169af30"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwOTowMDozOVrOGmNc3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwOTowMDozOVrOGmNc3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcxOTQ1NQ==", "bodyText": "WDYT about promise or future? trigger is too verb-ish", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442719455", "createdAt": "2020-06-19T09:00:39Z", "author": {"login": "bsideup"}, "path": "reactor-core/src/main/java/reactor/core/publisher/Sinks.java", "diffHunk": "@@ -0,0 +1,262 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import org.reactivestreams.Subscriber;\n+\n+import reactor.util.annotation.Nullable;\n+import reactor.util.concurrent.Queues;\n+import reactor.util.context.Context;\n+\n+/**\n+ * A collection of standalone sinks ({@link StandaloneFluxSink} and\n+ * {@link StandaloneMonoSink}).\n+ *\n+ * @author Simon Basl\u00e9\n+ */\n+public final class Sinks {\n+\n+\tprivate Sinks() { }\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand by conforming to the lowest demand in case\n+\t *     of multiple subscribers.</li>\n+\t *     <li>Replaying: No replay. Only forwards to a {@link Subscriber} the elements that have been\n+\t *     pushed to the sink AFTER this subscriber was subscribed. To the exception of the first\n+\t *     subscriber (see below).</li>\n+\t *     <li>Without {@link Subscriber}: warm up. Remembers up to {@link Queues#SMALL_BUFFER_SIZE}\n+\t *     elements pushed before the first {@link Subscriber} is registered.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> multicast() {\n+\t\treturn new FluxProcessorSink<>(EmitterProcessor.create(Queues.SMALL_BUFFER_SIZE));\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n+\t *     <li>Replaying: No replay. Only forwards to a {@link Subscriber} the elements that have been\n+\t *     pushed to the sink AFTER this subscriber was subscribed.</li>\n+\t *     <li>Without {@link Subscriber}: Discarding. Pushing elements while there are no {@link Subscriber}\n+\t *     registered will simply discard these elements instead of \"warming up\" the sink.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> multicastNoWarmup() {\n+\t\treturn new FluxProcessorSink<>(ReplayProcessor.create(0));\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n+\t *     <li>Replaying: by {@code historySize}. Keeps the last {@code historySize} elements and\n+\t *     replays them instantly to new subscribers before continuing with \"live\" elements.</li>\n+\t *     <li>Without {@link Subscriber}: buffers enough elements pushed without a subscriber to\n+\t *     honor the {@code historySize}.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> replay(int historySize) {\n+\t\treturn new FluxProcessorSink<>(ReplayProcessor.create(historySize));\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n+\t *     <li>Replaying: all elements pushed to this sink are replayed to new subscribers.</li>\n+\t *     <li>Without {@link Subscriber}: all elements pushed to this sink are remembered,\n+\t *     even when there is no subscriber.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> replayAll() {\n+\t\treturn new FluxProcessorSink<>(ReplayProcessor.create());\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li><strong>Unicast</strong>: contrary to most other {@link StandaloneFluxSink}, the\n+\t *     {@link Flux} view rejects {@link Subscriber subscribers} past the first one.</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of its single {@link Subscriber}.</li>\n+\t *     <li>Replaying: non-applicable, since only one {@link Subscriber} can register.</li>\n+\t *     <li>Without {@link Subscriber}: all elements pushed to this sink are remembered and will\n+\t *     be replayed once the {@link Subscriber} subscribes.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> unicast() {\n+\t\treturn new FluxProcessorSink<>(UnicastProcessor.create());\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneMonoSink} that can be triggered at any time by either of\n+\t * the three completions: {@link ScalarSink#success(Object) valued completion},\n+\t * {@link ScalarSink#success() empty completions} or {@link ScalarSink#error(Throwable) error}.\n+\t * This completion is replayed to late subscribers.\n+\t */\n+\tpublic static <T> StandaloneMonoSink<T> trigger() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "299a170088e47afaa060b550a7d9a4772169af30"}, "originalPosition": 122}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzOTE2ODMw", "url": "https://github.com/reactor/reactor-core/pull/2188#pullrequestreview-433916830", "createdAt": "2020-06-19T09:06:10Z", "commit": {"oid": "299a170088e47afaa060b550a7d9a4772169af30"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwOTowNjoxMVrOGmNmVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwOTowNjoxMVrOGmNmVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyMTg3Nw==", "bodyText": "Just curious, why not using CAS?", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442721877", "createdAt": "2020-06-19T09:06:11Z", "author": {"login": "bsideup"}, "path": "reactor-core/src/main/java/reactor/core/publisher/Sinks.java", "diffHunk": "@@ -0,0 +1,262 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import org.reactivestreams.Subscriber;\n+\n+import reactor.util.annotation.Nullable;\n+import reactor.util.concurrent.Queues;\n+import reactor.util.context.Context;\n+\n+/**\n+ * A collection of standalone sinks ({@link StandaloneFluxSink} and\n+ * {@link StandaloneMonoSink}).\n+ *\n+ * @author Simon Basl\u00e9\n+ */\n+public final class Sinks {\n+\n+\tprivate Sinks() { }\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand by conforming to the lowest demand in case\n+\t *     of multiple subscribers.</li>\n+\t *     <li>Replaying: No replay. Only forwards to a {@link Subscriber} the elements that have been\n+\t *     pushed to the sink AFTER this subscriber was subscribed. To the exception of the first\n+\t *     subscriber (see below).</li>\n+\t *     <li>Without {@link Subscriber}: warm up. Remembers up to {@link Queues#SMALL_BUFFER_SIZE}\n+\t *     elements pushed before the first {@link Subscriber} is registered.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> multicast() {\n+\t\treturn new FluxProcessorSink<>(EmitterProcessor.create(Queues.SMALL_BUFFER_SIZE));\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n+\t *     <li>Replaying: No replay. Only forwards to a {@link Subscriber} the elements that have been\n+\t *     pushed to the sink AFTER this subscriber was subscribed.</li>\n+\t *     <li>Without {@link Subscriber}: Discarding. Pushing elements while there are no {@link Subscriber}\n+\t *     registered will simply discard these elements instead of \"warming up\" the sink.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> multicastNoWarmup() {\n+\t\treturn new FluxProcessorSink<>(ReplayProcessor.create(0));\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n+\t *     <li>Replaying: by {@code historySize}. Keeps the last {@code historySize} elements and\n+\t *     replays them instantly to new subscribers before continuing with \"live\" elements.</li>\n+\t *     <li>Without {@link Subscriber}: buffers enough elements pushed without a subscriber to\n+\t *     honor the {@code historySize}.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> replay(int historySize) {\n+\t\treturn new FluxProcessorSink<>(ReplayProcessor.create(historySize));\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n+\t *     <li>Replaying: all elements pushed to this sink are replayed to new subscribers.</li>\n+\t *     <li>Without {@link Subscriber}: all elements pushed to this sink are remembered,\n+\t *     even when there is no subscriber.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> replayAll() {\n+\t\treturn new FluxProcessorSink<>(ReplayProcessor.create());\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li><strong>Unicast</strong>: contrary to most other {@link StandaloneFluxSink}, the\n+\t *     {@link Flux} view rejects {@link Subscriber subscribers} past the first one.</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of its single {@link Subscriber}.</li>\n+\t *     <li>Replaying: non-applicable, since only one {@link Subscriber} can register.</li>\n+\t *     <li>Without {@link Subscriber}: all elements pushed to this sink are remembered and will\n+\t *     be replayed once the {@link Subscriber} subscribes.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> unicast() {\n+\t\treturn new FluxProcessorSink<>(UnicastProcessor.create());\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneMonoSink} that can be triggered at any time by either of\n+\t * the three completions: {@link ScalarSink#success(Object) valued completion},\n+\t * {@link ScalarSink#success() empty completions} or {@link ScalarSink#error(Throwable) error}.\n+\t * This completion is replayed to late subscribers.\n+\t */\n+\tpublic static <T> StandaloneMonoSink<T> trigger() {\n+\t\treturn new MonoProcessorSink<>(MonoProcessor.create());\n+\t}\n+\n+\t// == interfaces ==\n+\n+\t/**\n+\t * A flavor of {@link SequenceSink} that is not attached to a single {@link Subscriber}\n+\t * but rather viewable {@link #asFlux() as a Flux}. Most likely, such a {@link SequenceSink}\n+\t * is capable of multicasting to several subscribers. However implementations can chose\n+\t * to be unicast instead, and only accept one {@link Subscriber} at a time (as allowed\n+\t * by the {@link org.reactivestreams.Publisher} specification).\n+\t *\n+\t * @param <T> the type of elements that can be emitted through this sink\n+\t */\n+\tpublic interface StandaloneFluxSink<T> extends SequenceSink<T> {\n+\n+\t\t@Override\n+\t\tStandaloneFluxSink<T> next(T t);\n+\n+\t\t/**\n+\t\t * Return the companion {@link Flux} instance that is backed by this sink.\n+\t\t * All calls to this method return the same instance.\n+\t\t *\n+\t\t * @return the {@link Flux} view associated to this {@link StandaloneFluxSink}\n+\t\t */\n+\t\tFlux<T> asFlux();\n+\n+\t}\n+\n+\t/**\n+\t * A flavor of {@link ScalarSink} that is not attached to a single {@link Subscriber}\n+\t * but rather viewable {@link #asMono() as a Mono}. Most likely, such a {@link ScalarSink}\n+\t * is capable of multicasting to several subscribers. However implementations can chose\n+\t * to be unicast instead, and only accept one {@link Subscriber} at a time (as allowed\n+\t * by the {@link org.reactivestreams.Publisher} specification).\n+\t *\n+\t * @param <T> the type of elements that can be emitted through this sink\n+\t */\n+\tpublic interface StandaloneMonoSink<T> extends ScalarSink<T> {\n+\n+\t\t/**\n+\t\t * Return the companion {@link Mono} instance that is backed by this sink.\n+\t\t * All calls to this method return the same instance.\n+\t\t *\n+\t\t * @return the {@link Mono} view associated to this {@link StandaloneMonoSink}\n+\t\t */\n+\t\tMono<T> asMono();\n+\t}\n+\n+\t// == concrete classes ==\n+\n+\tstatic final class FluxProcessorSink<T>\n+\t\t\timplements StandaloneFluxSink<T> {\n+\n+\t\tfinal FluxSink<T>         delegateSink;\n+\t\tfinal FluxProcessor<T, T> processor;\n+\n+\t\t@SuppressWarnings(\"deprecation\")\n+\t\tFluxProcessorSink(FluxProcessor<T, T> processor) {\n+\t\t\tthis.processor = processor;\n+\t\t\tthis.delegateSink = processor.sink();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Flux<T> asFlux() {\n+\t\t\treturn processor;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void complete() {\n+\t\t\tdelegateSink.complete();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void error(Throwable e) {\n+\t\t\tdelegateSink.error(e);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic StandaloneFluxSink<T> next(T t) {\n+\t\t\tdelegateSink.next(t);\n+\t\t\treturn this;\n+\t\t}\n+\t}\n+\n+\tstatic final class MonoProcessorSink<T> implements StandaloneMonoSink<T> {\n+\n+\t\tfinal MonoProcessor<T> processor;\n+\t\tboolean done;\n+\n+\t\tMonoProcessorSink(MonoProcessor<T> processor) {\n+\t\t\tthis.processor = processor;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Mono<T> asMono() {\n+\t\t\treturn this.processor;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void success() {\n+\t\t\tsynchronized (processor) {\n+\t\t\t\tif (done) {\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t\tdone = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "299a170088e47afaa060b550a7d9a4772169af30"}, "originalPosition": 228}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzOTIwNDI1", "url": "https://github.com/reactor/reactor-core/pull/2188#pullrequestreview-433920425", "createdAt": "2020-06-19T09:11:37Z", "commit": {"oid": "299a170088e47afaa060b550a7d9a4772169af30"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwOToxMTozN1rOGmNwuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwOToxMTozN1rOGmNwuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyNDUzNw==", "bodyText": "Should be destroyed after the test to avoid dangling Threads", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442724537", "createdAt": "2020-06-19T09:11:37Z", "author": {"login": "bsideup"}, "path": "reactor-core/src/test/java/reactor/core/publisher/SinksTest.java", "diffHunk": "@@ -0,0 +1,721 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.awaitility.Awaitility;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+\n+import reactor.test.StepVerifier;\n+import reactor.test.subscriber.AssertSubscriber;\n+import reactor.util.concurrent.Queues;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatCode;\n+\n+/**\n+ * @author Simon Basl\u00e9\n+ */\n+class SinksTest {\n+\n+\t@Nested\n+\tclass MulticastNoWarmup {\n+\n+\t\tprivate Sinks.StandaloneFluxSink<Integer> sink;\n+\t\tprivate Flux<Integer> flux;\n+\n+\t\t@BeforeEach\n+\t\tvoid createInstance() {\n+\t\t\tsink = Sinks.multicastNoWarmup();\n+\t\t\tflux = sink.asFlux();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid fluxViewReturnsSameInstance() {\n+\t\t\tassertThat(flux).isSameAs(sink.asFlux());\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid isAcceptingMoreThatOneSubscriber() {\n+\t\t\tassertThatCode(() -> {\n+\t\t\t\tflux.subscribe();\n+\t\t\t\tflux.subscribe();\n+\t\t\t}).doesNotThrowAnyException();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid honorsMultipleSubscribersBackpressure()\n+\t\t\t\tthrows InterruptedException, ExecutionException {\n+\t\t\tExecutorService es = Executors.newFixedThreadPool(2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "299a170088e47afaa060b550a7d9a4772169af30"}, "originalPosition": 71}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzOTIxNDQ1", "url": "https://github.com/reactor/reactor-core/pull/2188#pullrequestreview-433921445", "createdAt": "2020-06-19T09:13:09Z", "commit": {"oid": "299a170088e47afaa060b550a7d9a4772169af30"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwOToxMzoxMFrOGmNzrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwOToxMzoxMFrOGmNzrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyNTI5Mw==", "bodyText": "cleanup is missing", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442725293", "createdAt": "2020-06-19T09:13:10Z", "author": {"login": "bsideup"}, "path": "reactor-core/src/test/java/reactor/core/publisher/SinksTest.java", "diffHunk": "@@ -0,0 +1,721 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.awaitility.Awaitility;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+\n+import reactor.test.StepVerifier;\n+import reactor.test.subscriber.AssertSubscriber;\n+import reactor.util.concurrent.Queues;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatCode;\n+\n+/**\n+ * @author Simon Basl\u00e9\n+ */\n+class SinksTest {\n+\n+\t@Nested\n+\tclass MulticastNoWarmup {\n+\n+\t\tprivate Sinks.StandaloneFluxSink<Integer> sink;\n+\t\tprivate Flux<Integer> flux;\n+\n+\t\t@BeforeEach\n+\t\tvoid createInstance() {\n+\t\t\tsink = Sinks.multicastNoWarmup();\n+\t\t\tflux = sink.asFlux();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid fluxViewReturnsSameInstance() {\n+\t\t\tassertThat(flux).isSameAs(sink.asFlux());\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid isAcceptingMoreThatOneSubscriber() {\n+\t\t\tassertThatCode(() -> {\n+\t\t\t\tflux.subscribe();\n+\t\t\t\tflux.subscribe();\n+\t\t\t}).doesNotThrowAnyException();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid honorsMultipleSubscribersBackpressure()\n+\t\t\t\tthrows InterruptedException, ExecutionException {\n+\t\t\tExecutorService es = Executors.newFixedThreadPool(2);\n+\t\t\tCountDownLatch requestLatch = new CountDownLatch(2);\n+\t\t\tfinal Future<?> f1 = es.submit(() -> {\n+\t\t\t\tAssertSubscriber<Integer> test1 = AssertSubscriber.create(2);\n+\t\t\t\tflux.subscribe(test1);\n+\t\t\t\ttest1.assertNoValues();\n+\t\t\t\trequestLatch.countDown();\n+\n+\t\t\t\ttest1.awaitAndAssertNextValues(1, 2);\n+\t\t\t\ttry {\n+\t\t\t\t\tAwaitility.await().atMost(2, TimeUnit.SECONDS)\n+\t\t\t\t\t          .with().pollDelay(1, TimeUnit.SECONDS)\n+\t\t\t\t\t          .untilAsserted(() -> test1.assertValueCount(2));\n+\t\t\t\t}\n+\t\t\t\tfinally {\n+\t\t\t\t\ttest1.cancel();\n+\t\t\t\t}\n+\t\t\t});\n+\t\t\tfinal Future<?> f2 = es.submit(() -> {\n+\t\t\t\tAssertSubscriber<Integer> test2 = AssertSubscriber.create(1);\n+\t\t\t\tflux.subscribe(test2);\n+\t\t\t\trequestLatch.countDown();\n+\n+\t\t\t\ttest2.awaitAndAssertNextValues(1);\n+\t\t\t\ttry {\n+\t\t\t\t\tAwaitility.await().atMost(2, TimeUnit.SECONDS)\n+\t\t\t\t\t          .with().pollDelay(1, TimeUnit.SECONDS)\n+\t\t\t\t\t          .untilAsserted(() -> test2.assertValueCount(1));\n+\t\t\t\t}\n+\t\t\t\tfinally {\n+\t\t\t\t\ttest2.cancel();\n+\t\t\t\t}\n+\t\t\t});\n+\n+\t\t\trequestLatch.await(1, TimeUnit.SECONDS);\n+\t\t\tsink.next(1)\n+\t\t\t    .next(2)\n+\t\t\t    .next(3)\n+\t\t\t    .next(4)\n+\t\t\t    .complete();\n+\n+\t\t\tf1.get();\n+\t\t\tf2.get();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid doesNotReplayToLateSubscribers() {\n+\t\t\tAssertSubscriber<Integer> s1 = AssertSubscriber.create();\n+\t\t\tAssertSubscriber<Integer> s2 = AssertSubscriber.create();\n+\n+\t\t\tflux.subscribe(s1);\n+\t\t\tsink.next(1).next(2).next(3);\n+\t\t\ts1.assertValues(1, 2, 3);\n+\n+\t\t\tflux.subscribe(s2);\n+\t\t\ts2.assertNoValues().assertNotComplete();\n+\n+\t\t\tsink.complete();\n+\t\t\ts1.assertValueCount(3).assertComplete();\n+\t\t\ts2.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void doesNotBufferBeforeFirstSubscriber() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).next(2).next(3);\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertNoValues().assertNotComplete();\n+\n+\t\t\tsink.complete();\n+\t\t\tfirst.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyCompleteFirstSubscriber() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).complete();\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyErrorFirstSubscriber() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).error(new IllegalStateException(\"boom\"));\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertNoValues().assertErrorMessage(\"boom\");\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyCompleteLateSubscriber() {\n+\t\t\tflux.subscribe(); //first subscriber\n+\t\t\tAssertSubscriber<Integer> late = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).complete();\n+\t\t\tflux.subscribe(late);\n+\n+\t\t\tlate.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyErrorLateSubscriber() {\n+\t\t\tflux.onErrorReturn(-1).subscribe(); //first subscriber, ignore errors\n+\t\t\tAssertSubscriber<Integer> late = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).error(new IllegalStateException(\"boom\"));\n+\t\t\tflux.subscribe(late);\n+\n+\t\t\tlate.assertNoValues().assertErrorMessage(\"boom\");\n+\t\t}\n+\t}\n+\n+\t@Nested\n+\tclass Multicast {\n+\n+\t\tprivate Sinks.StandaloneFluxSink<Integer> sink;\n+\t\tprivate Flux<Integer> flux;\n+\n+\t\t@BeforeEach\n+\t\tvoid createInstance() {\n+\t\t\tsink = Sinks.multicast();\n+\t\t\tflux = sink.asFlux();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid fluxViewReturnsSameInstance() {\n+\t\t\tassertThat(flux).isSameAs(sink.asFlux());\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid isAcceptingMoreThatOneSubscriber() {\n+\t\t\tassertThatCode(() -> {\n+\t\t\t\tflux.subscribe();\n+\t\t\t\tflux.subscribe();\n+\t\t\t}).doesNotThrowAnyException();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid honorsMultipleSubscribersBackpressure()\n+\t\t\t\tthrows InterruptedException, ExecutionException {\n+\t\t\tExecutorService es = Executors.newFixedThreadPool(2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "299a170088e47afaa060b550a7d9a4772169af30"}, "originalPosition": 217}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzOTIyMTE0", "url": "https://github.com/reactor/reactor-core/pull/2188#pullrequestreview-433922114", "createdAt": "2020-06-19T09:14:08Z", "commit": {"oid": "299a170088e47afaa060b550a7d9a4772169af30"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwOToxNDowOFrOGmN1Vg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwOToxNDowOFrOGmN1Vg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyNTcxOA==", "bodyText": "could use an abstract parent class that checks common behaviours like this one", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442725718", "createdAt": "2020-06-19T09:14:08Z", "author": {"login": "bsideup"}, "path": "reactor-core/src/test/java/reactor/core/publisher/SinksTest.java", "diffHunk": "@@ -0,0 +1,721 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.awaitility.Awaitility;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+\n+import reactor.test.StepVerifier;\n+import reactor.test.subscriber.AssertSubscriber;\n+import reactor.util.concurrent.Queues;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatCode;\n+\n+/**\n+ * @author Simon Basl\u00e9\n+ */\n+class SinksTest {\n+\n+\t@Nested\n+\tclass MulticastNoWarmup {\n+\n+\t\tprivate Sinks.StandaloneFluxSink<Integer> sink;\n+\t\tprivate Flux<Integer> flux;\n+\n+\t\t@BeforeEach\n+\t\tvoid createInstance() {\n+\t\t\tsink = Sinks.multicastNoWarmup();\n+\t\t\tflux = sink.asFlux();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid fluxViewReturnsSameInstance() {\n+\t\t\tassertThat(flux).isSameAs(sink.asFlux());\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid isAcceptingMoreThatOneSubscriber() {\n+\t\t\tassertThatCode(() -> {\n+\t\t\t\tflux.subscribe();\n+\t\t\t\tflux.subscribe();\n+\t\t\t}).doesNotThrowAnyException();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid honorsMultipleSubscribersBackpressure()\n+\t\t\t\tthrows InterruptedException, ExecutionException {\n+\t\t\tExecutorService es = Executors.newFixedThreadPool(2);\n+\t\t\tCountDownLatch requestLatch = new CountDownLatch(2);\n+\t\t\tfinal Future<?> f1 = es.submit(() -> {\n+\t\t\t\tAssertSubscriber<Integer> test1 = AssertSubscriber.create(2);\n+\t\t\t\tflux.subscribe(test1);\n+\t\t\t\ttest1.assertNoValues();\n+\t\t\t\trequestLatch.countDown();\n+\n+\t\t\t\ttest1.awaitAndAssertNextValues(1, 2);\n+\t\t\t\ttry {\n+\t\t\t\t\tAwaitility.await().atMost(2, TimeUnit.SECONDS)\n+\t\t\t\t\t          .with().pollDelay(1, TimeUnit.SECONDS)\n+\t\t\t\t\t          .untilAsserted(() -> test1.assertValueCount(2));\n+\t\t\t\t}\n+\t\t\t\tfinally {\n+\t\t\t\t\ttest1.cancel();\n+\t\t\t\t}\n+\t\t\t});\n+\t\t\tfinal Future<?> f2 = es.submit(() -> {\n+\t\t\t\tAssertSubscriber<Integer> test2 = AssertSubscriber.create(1);\n+\t\t\t\tflux.subscribe(test2);\n+\t\t\t\trequestLatch.countDown();\n+\n+\t\t\t\ttest2.awaitAndAssertNextValues(1);\n+\t\t\t\ttry {\n+\t\t\t\t\tAwaitility.await().atMost(2, TimeUnit.SECONDS)\n+\t\t\t\t\t          .with().pollDelay(1, TimeUnit.SECONDS)\n+\t\t\t\t\t          .untilAsserted(() -> test2.assertValueCount(1));\n+\t\t\t\t}\n+\t\t\t\tfinally {\n+\t\t\t\t\ttest2.cancel();\n+\t\t\t\t}\n+\t\t\t});\n+\n+\t\t\trequestLatch.await(1, TimeUnit.SECONDS);\n+\t\t\tsink.next(1)\n+\t\t\t    .next(2)\n+\t\t\t    .next(3)\n+\t\t\t    .next(4)\n+\t\t\t    .complete();\n+\n+\t\t\tf1.get();\n+\t\t\tf2.get();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid doesNotReplayToLateSubscribers() {\n+\t\t\tAssertSubscriber<Integer> s1 = AssertSubscriber.create();\n+\t\t\tAssertSubscriber<Integer> s2 = AssertSubscriber.create();\n+\n+\t\t\tflux.subscribe(s1);\n+\t\t\tsink.next(1).next(2).next(3);\n+\t\t\ts1.assertValues(1, 2, 3);\n+\n+\t\t\tflux.subscribe(s2);\n+\t\t\ts2.assertNoValues().assertNotComplete();\n+\n+\t\t\tsink.complete();\n+\t\t\ts1.assertValueCount(3).assertComplete();\n+\t\t\ts2.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void doesNotBufferBeforeFirstSubscriber() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).next(2).next(3);\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertNoValues().assertNotComplete();\n+\n+\t\t\tsink.complete();\n+\t\t\tfirst.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyCompleteFirstSubscriber() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).complete();\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyErrorFirstSubscriber() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).error(new IllegalStateException(\"boom\"));\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertNoValues().assertErrorMessage(\"boom\");\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyCompleteLateSubscriber() {\n+\t\t\tflux.subscribe(); //first subscriber\n+\t\t\tAssertSubscriber<Integer> late = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).complete();\n+\t\t\tflux.subscribe(late);\n+\n+\t\t\tlate.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyErrorLateSubscriber() {\n+\t\t\tflux.onErrorReturn(-1).subscribe(); //first subscriber, ignore errors\n+\t\t\tAssertSubscriber<Integer> late = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).error(new IllegalStateException(\"boom\"));\n+\t\t\tflux.subscribe(late);\n+\n+\t\t\tlate.assertNoValues().assertErrorMessage(\"boom\");\n+\t\t}\n+\t}\n+\n+\t@Nested\n+\tclass Multicast {\n+\n+\t\tprivate Sinks.StandaloneFluxSink<Integer> sink;\n+\t\tprivate Flux<Integer> flux;\n+\n+\t\t@BeforeEach\n+\t\tvoid createInstance() {\n+\t\t\tsink = Sinks.multicast();\n+\t\t\tflux = sink.asFlux();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid fluxViewReturnsSameInstance() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "299a170088e47afaa060b550a7d9a4772169af30"}, "originalPosition": 202}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzOTIyOTU2", "url": "https://github.com/reactor/reactor-core/pull/2188#pullrequestreview-433922956", "createdAt": "2020-06-19T09:15:22Z", "commit": {"oid": "299a170088e47afaa060b550a7d9a4772169af30"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwOToxNToyMlrOGmN3uQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwOToxNToyMlrOGmN3uQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyNjMyOQ==", "bodyText": "Probably not. Especially if onErrorResume is used on the returning Flux", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442726329", "createdAt": "2020-06-19T09:15:22Z", "author": {"login": "bsideup"}, "path": "reactor-core/src/test/java/reactor/core/publisher/SinksTest.java", "diffHunk": "@@ -0,0 +1,721 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.awaitility.Awaitility;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+\n+import reactor.test.StepVerifier;\n+import reactor.test.subscriber.AssertSubscriber;\n+import reactor.util.concurrent.Queues;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatCode;\n+\n+/**\n+ * @author Simon Basl\u00e9\n+ */\n+class SinksTest {\n+\n+\t@Nested\n+\tclass MulticastNoWarmup {\n+\n+\t\tprivate Sinks.StandaloneFluxSink<Integer> sink;\n+\t\tprivate Flux<Integer> flux;\n+\n+\t\t@BeforeEach\n+\t\tvoid createInstance() {\n+\t\t\tsink = Sinks.multicastNoWarmup();\n+\t\t\tflux = sink.asFlux();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid fluxViewReturnsSameInstance() {\n+\t\t\tassertThat(flux).isSameAs(sink.asFlux());\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid isAcceptingMoreThatOneSubscriber() {\n+\t\t\tassertThatCode(() -> {\n+\t\t\t\tflux.subscribe();\n+\t\t\t\tflux.subscribe();\n+\t\t\t}).doesNotThrowAnyException();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid honorsMultipleSubscribersBackpressure()\n+\t\t\t\tthrows InterruptedException, ExecutionException {\n+\t\t\tExecutorService es = Executors.newFixedThreadPool(2);\n+\t\t\tCountDownLatch requestLatch = new CountDownLatch(2);\n+\t\t\tfinal Future<?> f1 = es.submit(() -> {\n+\t\t\t\tAssertSubscriber<Integer> test1 = AssertSubscriber.create(2);\n+\t\t\t\tflux.subscribe(test1);\n+\t\t\t\ttest1.assertNoValues();\n+\t\t\t\trequestLatch.countDown();\n+\n+\t\t\t\ttest1.awaitAndAssertNextValues(1, 2);\n+\t\t\t\ttry {\n+\t\t\t\t\tAwaitility.await().atMost(2, TimeUnit.SECONDS)\n+\t\t\t\t\t          .with().pollDelay(1, TimeUnit.SECONDS)\n+\t\t\t\t\t          .untilAsserted(() -> test1.assertValueCount(2));\n+\t\t\t\t}\n+\t\t\t\tfinally {\n+\t\t\t\t\ttest1.cancel();\n+\t\t\t\t}\n+\t\t\t});\n+\t\t\tfinal Future<?> f2 = es.submit(() -> {\n+\t\t\t\tAssertSubscriber<Integer> test2 = AssertSubscriber.create(1);\n+\t\t\t\tflux.subscribe(test2);\n+\t\t\t\trequestLatch.countDown();\n+\n+\t\t\t\ttest2.awaitAndAssertNextValues(1);\n+\t\t\t\ttry {\n+\t\t\t\t\tAwaitility.await().atMost(2, TimeUnit.SECONDS)\n+\t\t\t\t\t          .with().pollDelay(1, TimeUnit.SECONDS)\n+\t\t\t\t\t          .untilAsserted(() -> test2.assertValueCount(1));\n+\t\t\t\t}\n+\t\t\t\tfinally {\n+\t\t\t\t\ttest2.cancel();\n+\t\t\t\t}\n+\t\t\t});\n+\n+\t\t\trequestLatch.await(1, TimeUnit.SECONDS);\n+\t\t\tsink.next(1)\n+\t\t\t    .next(2)\n+\t\t\t    .next(3)\n+\t\t\t    .next(4)\n+\t\t\t    .complete();\n+\n+\t\t\tf1.get();\n+\t\t\tf2.get();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid doesNotReplayToLateSubscribers() {\n+\t\t\tAssertSubscriber<Integer> s1 = AssertSubscriber.create();\n+\t\t\tAssertSubscriber<Integer> s2 = AssertSubscriber.create();\n+\n+\t\t\tflux.subscribe(s1);\n+\t\t\tsink.next(1).next(2).next(3);\n+\t\t\ts1.assertValues(1, 2, 3);\n+\n+\t\t\tflux.subscribe(s2);\n+\t\t\ts2.assertNoValues().assertNotComplete();\n+\n+\t\t\tsink.complete();\n+\t\t\ts1.assertValueCount(3).assertComplete();\n+\t\t\ts2.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void doesNotBufferBeforeFirstSubscriber() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).next(2).next(3);\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertNoValues().assertNotComplete();\n+\n+\t\t\tsink.complete();\n+\t\t\tfirst.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyCompleteFirstSubscriber() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).complete();\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyErrorFirstSubscriber() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).error(new IllegalStateException(\"boom\"));\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertNoValues().assertErrorMessage(\"boom\");\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyCompleteLateSubscriber() {\n+\t\t\tflux.subscribe(); //first subscriber\n+\t\t\tAssertSubscriber<Integer> late = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).complete();\n+\t\t\tflux.subscribe(late);\n+\n+\t\t\tlate.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyErrorLateSubscriber() {\n+\t\t\tflux.onErrorReturn(-1).subscribe(); //first subscriber, ignore errors\n+\t\t\tAssertSubscriber<Integer> late = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).error(new IllegalStateException(\"boom\"));\n+\t\t\tflux.subscribe(late);\n+\n+\t\t\tlate.assertNoValues().assertErrorMessage(\"boom\");\n+\t\t}\n+\t}\n+\n+\t@Nested\n+\tclass Multicast {\n+\n+\t\tprivate Sinks.StandaloneFluxSink<Integer> sink;\n+\t\tprivate Flux<Integer> flux;\n+\n+\t\t@BeforeEach\n+\t\tvoid createInstance() {\n+\t\t\tsink = Sinks.multicast();\n+\t\t\tflux = sink.asFlux();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid fluxViewReturnsSameInstance() {\n+\t\t\tassertThat(flux).isSameAs(sink.asFlux());\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid isAcceptingMoreThatOneSubscriber() {\n+\t\t\tassertThatCode(() -> {\n+\t\t\t\tflux.subscribe();\n+\t\t\t\tflux.subscribe();\n+\t\t\t}).doesNotThrowAnyException();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid honorsMultipleSubscribersBackpressure()\n+\t\t\t\tthrows InterruptedException, ExecutionException {\n+\t\t\tExecutorService es = Executors.newFixedThreadPool(2);\n+\t\t\tCountDownLatch requestLatch = new CountDownLatch(2);\n+\t\t\tfinal Future<?> f1 = es.submit(() -> {\n+\t\t\t\tAssertSubscriber<Integer> test1 = AssertSubscriber.create(2);\n+\t\t\t\tflux.subscribe(test1);\n+\t\t\t\ttest1.assertNoValues();\n+\t\t\t\trequestLatch.countDown();\n+\n+\t\t\t\ttest1.awaitAndAssertNextValues(1, 2);\n+\t\t\t\ttry {\n+\t\t\t\t\tAwaitility.await().atMost(2, TimeUnit.SECONDS)\n+\t\t\t\t\t          .with().pollDelay(1, TimeUnit.SECONDS)\n+\t\t\t\t\t          .untilAsserted(() -> test1.assertValueCount(2));\n+\t\t\t\t}\n+\t\t\t\tfinally {\n+\t\t\t\t\ttest1.cancel();\n+\t\t\t\t}\n+\t\t\t});\n+\t\t\tfinal Future<?> f2 = es.submit(() -> {\n+\t\t\t\tAssertSubscriber<Integer> test2 = AssertSubscriber.create(1);\n+\t\t\t\tflux.subscribe(test2);\n+\t\t\t\trequestLatch.countDown();\n+\n+\t\t\t\ttest2.awaitAndAssertNextValues(1);\n+\t\t\t\ttry {\n+\t\t\t\t\tAwaitility.await().atMost(2, TimeUnit.SECONDS)\n+\t\t\t\t\t          .with().pollDelay(1, TimeUnit.SECONDS)\n+\t\t\t\t\t          .untilAsserted(() -> test2.assertValueCount(1));\n+\t\t\t\t}\n+\t\t\t\tfinally {\n+\t\t\t\t\ttest2.cancel();\n+\t\t\t\t}\n+\t\t\t});\n+\n+\t\t\trequestLatch.await(1, TimeUnit.SECONDS);\n+\t\t\tsink.next(1)\n+\t\t\t    .next(2)\n+\t\t\t    .next(3)\n+\t\t\t    .next(4)\n+\t\t\t    .complete();\n+\n+\t\t\tf1.get();\n+\t\t\tf2.get();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid doesNotReplayToLateSubscribers() {\n+\t\t\tAssertSubscriber<Integer> s1 = AssertSubscriber.create();\n+\t\t\tAssertSubscriber<Integer> s2 = AssertSubscriber.create();\n+\n+\t\t\tflux.subscribe(s1);\n+\t\t\tsink.next(1).next(2).next(3);\n+\t\t\ts1.assertValues(1, 2, 3);\n+\n+\t\t\tflux.subscribe(s2);\n+\t\t\ts2.assertNoValues().assertNotComplete();\n+\n+\t\t\tsink.complete();\n+\t\t\ts1.assertValueCount(3).assertComplete();\n+\t\t\ts2.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void doesBufferBeforeFirstSubscriber() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).next(2).next(3);\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertValues(1, 2, 3).assertNotComplete();\n+\n+\t\t\tsink.complete();\n+\t\t\tfirst.assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void replayAndCompleteFirstSubscriber() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).complete();\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertValues(1).assertComplete();\n+\t\t}\n+\n+\t\t@Test //TODO is that acceptable that EmitterProcessor doesn't replay in case of errors?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "299a170088e47afaa060b550a7d9a4772169af30"}, "originalPosition": 302}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzOTI0NTc1", "url": "https://github.com/reactor/reactor-core/pull/2188#pullrequestreview-433924575", "createdAt": "2020-06-19T09:17:55Z", "commit": {"oid": "299a170088e47afaa060b550a7d9a4772169af30"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwOToxNzo1NlrOGmN8VA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwOToxNzo1NlrOGmN8VA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyNzUwOA==", "bodyText": "ditto (the cleanup)", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442727508", "createdAt": "2020-06-19T09:17:56Z", "author": {"login": "bsideup"}, "path": "reactor-core/src/test/java/reactor/core/publisher/SinksTest.java", "diffHunk": "@@ -0,0 +1,721 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.awaitility.Awaitility;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+\n+import reactor.test.StepVerifier;\n+import reactor.test.subscriber.AssertSubscriber;\n+import reactor.util.concurrent.Queues;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatCode;\n+\n+/**\n+ * @author Simon Basl\u00e9\n+ */\n+class SinksTest {\n+\n+\t@Nested\n+\tclass MulticastNoWarmup {\n+\n+\t\tprivate Sinks.StandaloneFluxSink<Integer> sink;\n+\t\tprivate Flux<Integer> flux;\n+\n+\t\t@BeforeEach\n+\t\tvoid createInstance() {\n+\t\t\tsink = Sinks.multicastNoWarmup();\n+\t\t\tflux = sink.asFlux();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid fluxViewReturnsSameInstance() {\n+\t\t\tassertThat(flux).isSameAs(sink.asFlux());\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid isAcceptingMoreThatOneSubscriber() {\n+\t\t\tassertThatCode(() -> {\n+\t\t\t\tflux.subscribe();\n+\t\t\t\tflux.subscribe();\n+\t\t\t}).doesNotThrowAnyException();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid honorsMultipleSubscribersBackpressure()\n+\t\t\t\tthrows InterruptedException, ExecutionException {\n+\t\t\tExecutorService es = Executors.newFixedThreadPool(2);\n+\t\t\tCountDownLatch requestLatch = new CountDownLatch(2);\n+\t\t\tfinal Future<?> f1 = es.submit(() -> {\n+\t\t\t\tAssertSubscriber<Integer> test1 = AssertSubscriber.create(2);\n+\t\t\t\tflux.subscribe(test1);\n+\t\t\t\ttest1.assertNoValues();\n+\t\t\t\trequestLatch.countDown();\n+\n+\t\t\t\ttest1.awaitAndAssertNextValues(1, 2);\n+\t\t\t\ttry {\n+\t\t\t\t\tAwaitility.await().atMost(2, TimeUnit.SECONDS)\n+\t\t\t\t\t          .with().pollDelay(1, TimeUnit.SECONDS)\n+\t\t\t\t\t          .untilAsserted(() -> test1.assertValueCount(2));\n+\t\t\t\t}\n+\t\t\t\tfinally {\n+\t\t\t\t\ttest1.cancel();\n+\t\t\t\t}\n+\t\t\t});\n+\t\t\tfinal Future<?> f2 = es.submit(() -> {\n+\t\t\t\tAssertSubscriber<Integer> test2 = AssertSubscriber.create(1);\n+\t\t\t\tflux.subscribe(test2);\n+\t\t\t\trequestLatch.countDown();\n+\n+\t\t\t\ttest2.awaitAndAssertNextValues(1);\n+\t\t\t\ttry {\n+\t\t\t\t\tAwaitility.await().atMost(2, TimeUnit.SECONDS)\n+\t\t\t\t\t          .with().pollDelay(1, TimeUnit.SECONDS)\n+\t\t\t\t\t          .untilAsserted(() -> test2.assertValueCount(1));\n+\t\t\t\t}\n+\t\t\t\tfinally {\n+\t\t\t\t\ttest2.cancel();\n+\t\t\t\t}\n+\t\t\t});\n+\n+\t\t\trequestLatch.await(1, TimeUnit.SECONDS);\n+\t\t\tsink.next(1)\n+\t\t\t    .next(2)\n+\t\t\t    .next(3)\n+\t\t\t    .next(4)\n+\t\t\t    .complete();\n+\n+\t\t\tf1.get();\n+\t\t\tf2.get();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid doesNotReplayToLateSubscribers() {\n+\t\t\tAssertSubscriber<Integer> s1 = AssertSubscriber.create();\n+\t\t\tAssertSubscriber<Integer> s2 = AssertSubscriber.create();\n+\n+\t\t\tflux.subscribe(s1);\n+\t\t\tsink.next(1).next(2).next(3);\n+\t\t\ts1.assertValues(1, 2, 3);\n+\n+\t\t\tflux.subscribe(s2);\n+\t\t\ts2.assertNoValues().assertNotComplete();\n+\n+\t\t\tsink.complete();\n+\t\t\ts1.assertValueCount(3).assertComplete();\n+\t\t\ts2.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void doesNotBufferBeforeFirstSubscriber() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).next(2).next(3);\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertNoValues().assertNotComplete();\n+\n+\t\t\tsink.complete();\n+\t\t\tfirst.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyCompleteFirstSubscriber() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).complete();\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyErrorFirstSubscriber() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).error(new IllegalStateException(\"boom\"));\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertNoValues().assertErrorMessage(\"boom\");\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyCompleteLateSubscriber() {\n+\t\t\tflux.subscribe(); //first subscriber\n+\t\t\tAssertSubscriber<Integer> late = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).complete();\n+\t\t\tflux.subscribe(late);\n+\n+\t\t\tlate.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyErrorLateSubscriber() {\n+\t\t\tflux.onErrorReturn(-1).subscribe(); //first subscriber, ignore errors\n+\t\t\tAssertSubscriber<Integer> late = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).error(new IllegalStateException(\"boom\"));\n+\t\t\tflux.subscribe(late);\n+\n+\t\t\tlate.assertNoValues().assertErrorMessage(\"boom\");\n+\t\t}\n+\t}\n+\n+\t@Nested\n+\tclass Multicast {\n+\n+\t\tprivate Sinks.StandaloneFluxSink<Integer> sink;\n+\t\tprivate Flux<Integer> flux;\n+\n+\t\t@BeforeEach\n+\t\tvoid createInstance() {\n+\t\t\tsink = Sinks.multicast();\n+\t\t\tflux = sink.asFlux();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid fluxViewReturnsSameInstance() {\n+\t\t\tassertThat(flux).isSameAs(sink.asFlux());\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid isAcceptingMoreThatOneSubscriber() {\n+\t\t\tassertThatCode(() -> {\n+\t\t\t\tflux.subscribe();\n+\t\t\t\tflux.subscribe();\n+\t\t\t}).doesNotThrowAnyException();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid honorsMultipleSubscribersBackpressure()\n+\t\t\t\tthrows InterruptedException, ExecutionException {\n+\t\t\tExecutorService es = Executors.newFixedThreadPool(2);\n+\t\t\tCountDownLatch requestLatch = new CountDownLatch(2);\n+\t\t\tfinal Future<?> f1 = es.submit(() -> {\n+\t\t\t\tAssertSubscriber<Integer> test1 = AssertSubscriber.create(2);\n+\t\t\t\tflux.subscribe(test1);\n+\t\t\t\ttest1.assertNoValues();\n+\t\t\t\trequestLatch.countDown();\n+\n+\t\t\t\ttest1.awaitAndAssertNextValues(1, 2);\n+\t\t\t\ttry {\n+\t\t\t\t\tAwaitility.await().atMost(2, TimeUnit.SECONDS)\n+\t\t\t\t\t          .with().pollDelay(1, TimeUnit.SECONDS)\n+\t\t\t\t\t          .untilAsserted(() -> test1.assertValueCount(2));\n+\t\t\t\t}\n+\t\t\t\tfinally {\n+\t\t\t\t\ttest1.cancel();\n+\t\t\t\t}\n+\t\t\t});\n+\t\t\tfinal Future<?> f2 = es.submit(() -> {\n+\t\t\t\tAssertSubscriber<Integer> test2 = AssertSubscriber.create(1);\n+\t\t\t\tflux.subscribe(test2);\n+\t\t\t\trequestLatch.countDown();\n+\n+\t\t\t\ttest2.awaitAndAssertNextValues(1);\n+\t\t\t\ttry {\n+\t\t\t\t\tAwaitility.await().atMost(2, TimeUnit.SECONDS)\n+\t\t\t\t\t          .with().pollDelay(1, TimeUnit.SECONDS)\n+\t\t\t\t\t          .untilAsserted(() -> test2.assertValueCount(1));\n+\t\t\t\t}\n+\t\t\t\tfinally {\n+\t\t\t\t\ttest2.cancel();\n+\t\t\t\t}\n+\t\t\t});\n+\n+\t\t\trequestLatch.await(1, TimeUnit.SECONDS);\n+\t\t\tsink.next(1)\n+\t\t\t    .next(2)\n+\t\t\t    .next(3)\n+\t\t\t    .next(4)\n+\t\t\t    .complete();\n+\n+\t\t\tf1.get();\n+\t\t\tf2.get();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid doesNotReplayToLateSubscribers() {\n+\t\t\tAssertSubscriber<Integer> s1 = AssertSubscriber.create();\n+\t\t\tAssertSubscriber<Integer> s2 = AssertSubscriber.create();\n+\n+\t\t\tflux.subscribe(s1);\n+\t\t\tsink.next(1).next(2).next(3);\n+\t\t\ts1.assertValues(1, 2, 3);\n+\n+\t\t\tflux.subscribe(s2);\n+\t\t\ts2.assertNoValues().assertNotComplete();\n+\n+\t\t\tsink.complete();\n+\t\t\ts1.assertValueCount(3).assertComplete();\n+\t\t\ts2.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void doesBufferBeforeFirstSubscriber() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).next(2).next(3);\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertValues(1, 2, 3).assertNotComplete();\n+\n+\t\t\tsink.complete();\n+\t\t\tfirst.assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void replayAndCompleteFirstSubscriber() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).complete();\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertValues(1).assertComplete();\n+\t\t}\n+\n+\t\t@Test //TODO is that acceptable that EmitterProcessor doesn't replay in case of errors?\n+\t\tpublic void noReplayBeforeFirstSubscriberIfEarlyError() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).next(2).next(3).error(new IllegalStateException(\"boom\"));\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertNoValues().assertErrorMessage(\"boom\");\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyCompleteLateSubscriber() {\n+\t\t\tflux.subscribe(); //first subscriber\n+\t\t\tAssertSubscriber<Integer> late = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).complete();\n+\t\t\tflux.subscribe(late);\n+\n+\t\t\tlate.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyErrorLateSubscriber() {\n+\t\t\tflux.onErrorReturn(-1).subscribe(); //first subscriber, ignore errors\n+\t\t\tAssertSubscriber<Integer> late = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).error(new IllegalStateException(\"boom\"));\n+\t\t\tflux.subscribe(late);\n+\n+\t\t\tlate.assertNoValues().assertErrorMessage(\"boom\");\n+\t\t}\n+\t}\n+\n+\t@Nested\n+\tclass MulticastReplayAll {\n+\n+\t\tprivate Sinks.StandaloneFluxSink<Integer> sink;\n+\t\tprivate Flux<Integer> flux;\n+\n+\t\t@BeforeEach\n+\t\tvoid createInstance() {\n+\t\t\tsink = Sinks.replayAll();\n+\t\t\tflux = sink.asFlux();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid fluxViewReturnsSameInstance() {\n+\t\t\tassertThat(flux).isSameAs(sink.asFlux());\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid isAcceptingMoreThatOneSubscriber() {\n+\t\t\tassertThatCode(() -> {\n+\t\t\t\tflux.subscribe();\n+\t\t\t\tflux.subscribe();\n+\t\t\t}).doesNotThrowAnyException();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid honorsMultipleSubscribersBackpressure()\n+\t\t\t\tthrows InterruptedException, ExecutionException {\n+\t\t\tExecutorService es = Executors.newFixedThreadPool(2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "299a170088e47afaa060b550a7d9a4772169af30"}, "originalPosition": 363}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzOTI1OTkw", "url": "https://github.com/reactor/reactor-core/pull/2188#pullrequestreview-433925990", "createdAt": "2020-06-19T09:20:14Z", "commit": {"oid": "299a170088e47afaa060b550a7d9a4772169af30"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f16014ad3bd48313adf0c90c33274a025719c321", "author": {"user": {"login": "simonbasle", "name": "Simon Basl\u00e9"}}, "url": "https://github.com/reactor/reactor-core/commit/f16014ad3bd48313adf0c90c33274a025719c321", "committedDate": "2020-06-19T13:03:03Z", "message": "Rework SinksTests to mutualize code as dynamic tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2fc8a2eed65ade94b587797134f5d5740c567503", "author": {"user": {"login": "simonbasle", "name": "Simon Basl\u00e9"}}, "url": "https://github.com/reactor/reactor-core/commit/2fc8a2eed65ade94b587797134f5d5740c567503", "committedDate": "2020-06-19T14:27:36Z", "message": "per review, improve javadocs and add svg for warmup concept"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a5fa482da96da34acdd980d9b28ab2fb696f3d4e", "author": {"user": {"login": "simonbasle", "name": "Simon Basl\u00e9"}}, "url": "https://github.com/reactor/reactor-core/commit/a5fa482da96da34acdd980d9b28ab2fb696f3d4e", "committedDate": "2020-06-19T15:03:04Z", "message": "per review, rename trigger to promise. add tests and fix error drop"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "60285c2e462b27804cea70009f168f23ae0014b4", "author": {"user": {"login": "simonbasle", "name": "Simon Basl\u00e9"}}, "url": "https://github.com/reactor/reactor-core/commit/60285c2e462b27804cea70009f168f23ae0014b4", "committedDate": "2020-06-19T15:22:05Z", "message": "Add FluxIdentityProcessor<T> specialization of FluxProcessor<T,T>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0MTc1NTc1", "url": "https://github.com/reactor/reactor-core/pull/2188#pullrequestreview-434175575", "createdAt": "2020-06-19T15:43:06Z", "commit": {"oid": "60285c2e462b27804cea70009f168f23ae0014b4"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6377bf3ad706354f9ad0dcc86db6398d9ba58ac6", "author": {"user": {"login": "simonbasle", "name": "Simon Basl\u00e9"}}, "url": "https://github.com/reactor/reactor-core/commit/6377bf3ad706354f9ad0dcc86db6398d9ba58ac6", "committedDate": "2020-06-19T16:36:05Z", "message": "fixup compilation and some additional deprecation warnings"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "77571d3d5460e357466716e1befe0edb0e2bc31a", "author": {"user": {"login": "simonbasle", "name": "Simon Basl\u00e9"}}, "url": "https://github.com/reactor/reactor-core/commit/77571d3d5460e357466716e1befe0edb0e2bc31a", "committedDate": "2020-06-19T17:34:30Z", "message": "fixup hanging test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a83b4deb91f552eb88973365a79edc95fa15e549", "author": {"user": {"login": "simonbasle", "name": "Simon Basl\u00e9"}}, "url": "https://github.com/reactor/reactor-core/commit/a83b4deb91f552eb88973365a79edc95fa15e549", "committedDate": "2020-06-19T17:50:32Z", "message": "Switch from FluxProcessor<T,T> to FluxIdentityProcessor<T> in operators"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2MTA4MjI4", "url": "https://github.com/reactor/reactor-core/pull/2188#pullrequestreview-436108228", "createdAt": "2020-06-23T19:55:59Z", "commit": {"oid": "a83b4deb91f552eb88973365a79edc95fa15e549"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2993, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}