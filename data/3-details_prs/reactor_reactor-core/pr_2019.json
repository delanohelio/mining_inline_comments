{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY1ODgzNjIw", "number": 2019, "title": "Fix early cancellation handling and improve switchOnFirst", "bodyText": "This PR provides a couple of non-breaking changes in the behavior of SwitchOnFirst operator:\n\nApplies Name changes in internal class naming\nProvides additional parameter which allows canceling the source Publisher or continuing it work regardless derived Publisher completion\nProvides the ability to cancel source if there are no elements but downstream has already been canceled (actually this was a bug, cuz in case of Flux.never or  Fluxes which require much time to produce an element it was impossible to cancel execution in a timely manner. Imagine the case -> Flux.just(1).delayElement(Durations.ofHour(1)).switchOnFirst(...).timeout(Duration.ofSeconds(1))).\n\nSigned-off-by: Oleh Dokuka shadowgun@i.ua", "createdAt": "2020-01-22T14:27:58Z", "url": "https://github.com/reactor/reactor-core/pull/2019", "merged": true, "mergeCommit": {"oid": "34df2b0946f88b3655101a191ff292b1e66d724a"}, "closed": true, "closedAt": "2020-03-06T16:30:43Z", "author": {"login": "OlegDokuka"}, "timelineItems": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb-ymAaAFqTM0OTQyNzEzNA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcLCohNgFqTM3MDQ1MTA5OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ5NDI3MTM0", "url": "https://github.com/reactor/reactor-core/pull/2019#pullrequestreview-349427134", "createdAt": "2020-01-28T14:42:33Z", "commit": {"oid": "877b27053c1efc5fd287d1617535114e32ccb1d1"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxNDo0MjozM1rOFingWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxNDo1MjozOVrOFin52A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg0MzE2MA==", "bodyText": "you should use the constant STATE_REQUESTED here too", "url": "https://github.com/reactor/reactor-core/pull/2019#discussion_r371843160", "createdAt": "2020-01-28T14:42:33Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/FluxSwitchOnFirst.java", "diffHunk": "@@ -523,58 +559,141 @@ public void onError(Throwable throwable) {\n                 parent.cancel();\n             }\n \n-            inner.onError(throwable);\n+            delegate.onError(throwable);\n         }\n \n         @Override\n         public void onComplete() {\n-            if (!parent.done) {\n+            if (!parent.done && cancelSourceOnComplete) {\n                 parent.cancel();\n             }\n \n-            inner.onComplete();\n+            delegate.onComplete();\n+        }\n+\n+        @Override\n+        public void request(long n) {\n+            long r = this.requested;\n+\n+            if (r > STATE_REQUESTED) {\n+                long u;\n+                for (;;) {\n+                    if (r == Long.MAX_VALUE) {\n+                        return;\n+                    }\n+                    u = Operators.addCap(r, n);\n+                    if (REQUESTED.compareAndSet(this, r, u)) {\n+                        return;\n+                    }\n+                    else {\n+                        r = requested;\n+\n+                        if (r < 0) {\n+                            break;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            if (r == STATE_CANCELLED) {\n+                return;\n+            }\n+\n+            s.request(n);\n+        }\n+\n+        void tryRequest() {\n+            final Subscription s = this.s;\n+            long r = REQUESTED.getAndSet(this, -1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "877b27053c1efc5fd287d1617535114e32ccb1d1"}, "originalPosition": 257}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg0NTQxMA==", "bodyText": "just for clarity's sake, use this.requested here", "url": "https://github.com/reactor/reactor-core/pull/2019#discussion_r371845410", "createdAt": "2020-01-28T14:46:00Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/FluxSwitchOnFirst.java", "diffHunk": "@@ -523,58 +559,141 @@ public void onError(Throwable throwable) {\n                 parent.cancel();\n             }\n \n-            inner.onError(throwable);\n+            delegate.onError(throwable);\n         }\n \n         @Override\n         public void onComplete() {\n-            if (!parent.done) {\n+            if (!parent.done && cancelSourceOnComplete) {\n                 parent.cancel();\n             }\n \n-            inner.onComplete();\n+            delegate.onComplete();\n+        }\n+\n+        @Override\n+        public void request(long n) {\n+            long r = this.requested;\n+\n+            if (r > STATE_REQUESTED) {\n+                long u;\n+                for (;;) {\n+                    if (r == Long.MAX_VALUE) {\n+                        return;\n+                    }\n+                    u = Operators.addCap(r, n);\n+                    if (REQUESTED.compareAndSet(this, r, u)) {\n+                        return;\n+                    }\n+                    else {\n+                        r = requested;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "877b27053c1efc5fd287d1617535114e32ccb1d1"}, "originalPosition": 239}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg0Njc1Nw==", "bodyText": "shouldn't it break from the for(;;) loop rather than completely exiting?\nI get the return in the case where we detect we're running in unbounded mode, but here we're aggregating requests and it is not clear to me how they will be propagated upstream...", "url": "https://github.com/reactor/reactor-core/pull/2019#discussion_r371846757", "createdAt": "2020-01-28T14:48:11Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/FluxSwitchOnFirst.java", "diffHunk": "@@ -523,58 +559,141 @@ public void onError(Throwable throwable) {\n                 parent.cancel();\n             }\n \n-            inner.onError(throwable);\n+            delegate.onError(throwable);\n         }\n \n         @Override\n         public void onComplete() {\n-            if (!parent.done) {\n+            if (!parent.done && cancelSourceOnComplete) {\n                 parent.cancel();\n             }\n \n-            inner.onComplete();\n+            delegate.onComplete();\n+        }\n+\n+        @Override\n+        public void request(long n) {\n+            long r = this.requested;\n+\n+            if (r > STATE_REQUESTED) {\n+                long u;\n+                for (;;) {\n+                    if (r == Long.MAX_VALUE) {\n+                        return;\n+                    }\n+                    u = Operators.addCap(r, n);\n+                    if (REQUESTED.compareAndSet(this, r, u)) {\n+                        return;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "877b27053c1efc5fd287d1617535114e32ccb1d1"}, "originalPosition": 236}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg0NzUwMQ==", "bodyText": "this is only done when this.requested == STATE_REQUESTED, ie in tryRequest, in turn only invoked in onSubscribe, correct?", "url": "https://github.com/reactor/reactor-core/pull/2019#discussion_r371847501", "createdAt": "2020-01-28T14:49:15Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/FluxSwitchOnFirst.java", "diffHunk": "@@ -523,58 +559,141 @@ public void onError(Throwable throwable) {\n                 parent.cancel();\n             }\n \n-            inner.onError(throwable);\n+            delegate.onError(throwable);\n         }\n \n         @Override\n         public void onComplete() {\n-            if (!parent.done) {\n+            if (!parent.done && cancelSourceOnComplete) {\n                 parent.cancel();\n             }\n \n-            inner.onComplete();\n+            delegate.onComplete();\n+        }\n+\n+        @Override\n+        public void request(long n) {\n+            long r = this.requested;\n+\n+            if (r > STATE_REQUESTED) {\n+                long u;\n+                for (;;) {\n+                    if (r == Long.MAX_VALUE) {\n+                        return;\n+                    }\n+                    u = Operators.addCap(r, n);\n+                    if (REQUESTED.compareAndSet(this, r, u)) {\n+                        return;\n+                    }\n+                    else {\n+                        r = requested;\n+\n+                        if (r < 0) {\n+                            break;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            if (r == STATE_CANCELLED) {\n+                return;\n+            }\n+\n+            s.request(n);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "877b27053c1efc5fd287d1617535114e32ccb1d1"}, "originalPosition": 252}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg0OTY4OA==", "bodyText": "comments above apply to this class as well", "url": "https://github.com/reactor/reactor-core/pull/2019#discussion_r371849688", "createdAt": "2020-01-28T14:52:39Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/FluxSwitchOnFirst.java", "diffHunk": "@@ -523,58 +559,141 @@ public void onError(Throwable throwable) {\n                 parent.cancel();\n             }\n \n-            inner.onError(throwable);\n+            delegate.onError(throwable);\n         }\n \n         @Override\n         public void onComplete() {\n-            if (!parent.done) {\n+            if (!parent.done && cancelSourceOnComplete) {\n                 parent.cancel();\n             }\n \n-            inner.onComplete();\n+            delegate.onComplete();\n+        }\n+\n+        @Override\n+        public void request(long n) {\n+            long r = this.requested;\n+\n+            if (r > STATE_REQUESTED) {\n+                long u;\n+                for (;;) {\n+                    if (r == Long.MAX_VALUE) {\n+                        return;\n+                    }\n+                    u = Operators.addCap(r, n);\n+                    if (REQUESTED.compareAndSet(this, r, u)) {\n+                        return;\n+                    }\n+                    else {\n+                        r = requested;\n+\n+                        if (r < 0) {\n+                            break;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            if (r == STATE_CANCELLED) {\n+                return;\n+            }\n+\n+            s.request(n);\n+        }\n+\n+        void tryRequest() {\n+            final Subscription s = this.s;\n+            long r = REQUESTED.getAndSet(this, -1);\n+\n+            if (r > 0) {\n+                s.request(r);\n+            }\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            final long state = REQUESTED.getAndSet(this, STATE_CANCELLED);\n+\n+            if (state == STATE_CANCELLED) {\n+                return;\n+            }\n+\n+            if (state == STATE_REQUESTED) {\n+                s.cancel();\n+                return;\n+            }\n+\n+            parent.cancel();\n         }\n \n         @Override\n         public Object scanUnsafe(Attr key) {\n             if (key == Attr.PARENT) return parent;\n-            if (key == Attr.ACTUAL) return inner;\n+            if (key == Attr.ACTUAL) return delegate;\n \n             return null;\n         }\n     }\n \n-    static final class SwitchOnFirstConditionalInnerSubscriber<T> implements InnerConsumer<T>,\n+    static final class SwitchOnFirstConditionalControlSubscriber<T> implements InnerOperator<T, T>, ControlSubscriber<T>,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "877b27053c1efc5fd287d1617535114e32ccb1d1"}, "originalPosition": 291}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzNzM5ODU4", "url": "https://github.com/reactor/reactor-core/pull/2019#pullrequestreview-353739858", "createdAt": "2020-02-05T14:07:10Z", "commit": {"oid": "877b27053c1efc5fd287d1617535114e32ccb1d1"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxNDowNzoxMVrOFl46vQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxNDoyMTo1OFrOFl5bzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTI3NDE3Mw==", "bodyText": "small nitpick: group these with other STATE_ and put the blank line above", "url": "https://github.com/reactor/reactor-core/pull/2019#discussion_r375274173", "createdAt": "2020-02-05T14:07:11Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/FluxSwitchOnFirst.java", "diffHunk": "@@ -34,17 +35,22 @@\n  * @param <R>\n  */\n final class FluxSwitchOnFirst<T, R> extends InternalFluxOperator<T, R> {\n+    static final int STATE_CANCELLED = -2;\n+    static final int STATE_REQUESTED = -1;\n ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "877b27053c1efc5fd287d1617535114e32ccb1d1"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTI4MTU5Mg==", "bodyText": "what guarantees that the n you just added to r in addCap are actually propagated upstream? since you're returning, and r > STATE_REQUESTED, there's no chance the tryRequest will swap the new r for -1 and perform s.request(r), so that amount n is lost. Am I missing something?", "url": "https://github.com/reactor/reactor-core/pull/2019#discussion_r375281592", "createdAt": "2020-02-05T14:20:26Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/FluxSwitchOnFirst.java", "diffHunk": "@@ -523,58 +559,141 @@ public void onError(Throwable throwable) {\n                 parent.cancel();\n             }\n \n-            inner.onError(throwable);\n+            delegate.onError(throwable);\n         }\n \n         @Override\n         public void onComplete() {\n-            if (!parent.done) {\n+            if (!parent.done && cancelSourceOnComplete) {\n                 parent.cancel();\n             }\n \n-            inner.onComplete();\n+            delegate.onComplete();\n+        }\n+\n+        @Override\n+        public void request(long n) {\n+            long r = this.requested;\n+\n+            if (r > STATE_REQUESTED) {\n+                long u;\n+                for (;;) {\n+                    if (r == Long.MAX_VALUE) {\n+                        return;\n+                    }\n+                    u = Operators.addCap(r, n);\n+                    if (REQUESTED.compareAndSet(this, r, u)) {\n+                        return;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg0Njc1Nw=="}, "originalCommit": {"oid": "877b27053c1efc5fd287d1617535114e32ccb1d1"}, "originalPosition": 236}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTI4MjYzNg==", "bodyText": "what I meant is \"what if the state was NOT requested, but a second batch of request (eg. this operator is called with request(3) then request(4)). wouldn't the second request call be \"lost\"?", "url": "https://github.com/reactor/reactor-core/pull/2019#discussion_r375282636", "createdAt": "2020-02-05T14:21:58Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/FluxSwitchOnFirst.java", "diffHunk": "@@ -523,58 +559,141 @@ public void onError(Throwable throwable) {\n                 parent.cancel();\n             }\n \n-            inner.onError(throwable);\n+            delegate.onError(throwable);\n         }\n \n         @Override\n         public void onComplete() {\n-            if (!parent.done) {\n+            if (!parent.done && cancelSourceOnComplete) {\n                 parent.cancel();\n             }\n \n-            inner.onComplete();\n+            delegate.onComplete();\n+        }\n+\n+        @Override\n+        public void request(long n) {\n+            long r = this.requested;\n+\n+            if (r > STATE_REQUESTED) {\n+                long u;\n+                for (;;) {\n+                    if (r == Long.MAX_VALUE) {\n+                        return;\n+                    }\n+                    u = Operators.addCap(r, n);\n+                    if (REQUESTED.compareAndSet(this, r, u)) {\n+                        return;\n+                    }\n+                    else {\n+                        r = requested;\n+\n+                        if (r < 0) {\n+                            break;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            if (r == STATE_CANCELLED) {\n+                return;\n+            }\n+\n+            s.request(n);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg0NzUwMQ=="}, "originalCommit": {"oid": "877b27053c1efc5fd287d1617535114e32ccb1d1"}, "originalPosition": 252}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8af77968e12abb7bfaccdd7c5417e23e6546985b", "author": {"user": {"login": "OlegDokuka", "name": "Oleh Dokuka"}}, "url": "https://github.com/reactor/reactor-core/commit/8af77968e12abb7bfaccdd7c5417e23e6546985b", "committedDate": "2020-03-06T12:02:30Z", "message": "provides refactoring\n\n1) Applies Name changes in internal class naming\n2) Provides Additional parameter which allows cancelling the source Publisher or continuing it work regardless derived Publisher completion\n3) Provides ability to cancel source if there is no elements but downstream has already been cancelled\n\nSigned-off-by: Oleh Dokuka <shadowgun@i.ua>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "97161681ee1d43e5b9d39cb1f71af31166990297", "author": {"user": {"login": "OlegDokuka", "name": "Oleh Dokuka"}}, "url": "https://github.com/reactor/reactor-core/commit/97161681ee1d43e5b9d39cb1f71af31166990297", "committedDate": "2020-03-06T12:02:30Z", "message": "provides source leaning and minor refactoring\n\nSigned-off-by: Oleh Dokuka <shadowgun@i.ua>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "877b27053c1efc5fd287d1617535114e32ccb1d1", "author": {"user": {"login": "OlegDokuka", "name": "Oleh Dokuka"}}, "url": "https://github.com/reactor/reactor-core/commit/877b27053c1efc5fd287d1617535114e32ccb1d1", "committedDate": "2020-01-22T14:21:46Z", "message": "provides refactoring\n\n1) Applies Name changes in internal class naming\n2) Provides Additional parameter which allows cancelling the source Publisher or continuing it work regardless derived Publisher completion\n3) Provides ability to cancel source if there is no elements but downstream has already been cancelled\n\nSigned-off-by: Oleh Dokuka <shadowgun@i.ua>"}, "afterCommit": {"oid": "97161681ee1d43e5b9d39cb1f71af31166990297", "author": {"user": {"login": "OlegDokuka", "name": "Oleh Dokuka"}}, "url": "https://github.com/reactor/reactor-core/commit/97161681ee1d43e5b9d39cb1f71af31166990297", "committedDate": "2020-03-06T12:02:30Z", "message": "provides source leaning and minor refactoring\n\nSigned-off-by: Oleh Dokuka <shadowgun@i.ua>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwMjc0NjE5", "url": "https://github.com/reactor/reactor-core/pull/2019#pullrequestreview-370274619", "createdAt": "2020-03-06T12:04:59Z", "commit": {"oid": "97161681ee1d43e5b9d39cb1f71af31166990297"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxMjowNDo1OVrOFy2iBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxMjowNDo1OVrOFy2iBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg2NjU2NQ==", "bodyText": "@simonbasle I ended up with the conclusion that context can not be mutable for upstream, thus removed that tricky part", "url": "https://github.com/reactor/reactor-core/pull/2019#discussion_r388866565", "createdAt": "2020-03-06T12:04:59Z", "author": {"login": "OlegDokuka"}, "path": "reactor-core/src/main/java/reactor/core/publisher/FluxSwitchOnFirst.java", "diffHunk": "@@ -56,87 +64,73 @@ public int getPrefetch() {\n     @SuppressWarnings(\"unchecked\")\n     public CoreSubscriber<? super T> subscribeOrReturn(CoreSubscriber<? super R> actual) {\n         if (actual instanceof Fuseable.ConditionalSubscriber) {\n-            source.subscribe(new SwitchOnFirstConditionalInner<>((Fuseable.ConditionalSubscriber<? super R>) actual, transformer));\n-            return null;\n+            return new SwitchOnFirstConditionalMain<>((Fuseable.ConditionalSubscriber<? super R>) actual, transformer, cancelSourceOnComplete);\n         }\n-        return new SwitchOnFirstInner<>(actual, transformer);\n+        return new SwitchOnFirstMain<>(actual, transformer, cancelSourceOnComplete);\n     }\n \n-    static abstract class AbstractSwitchOnFirstInner<T, R> extends Flux<T>\n+    static abstract class AbstractSwitchOnFirstMain<T, R> extends Flux<T>\n             implements InnerOperator<T, R> {\n \n-        final CoreSubscriber<? super R>                                        outer;\n+        final ControlSubscriber<? super R>                                     outer;\n         final BiFunction<Signal<? extends T>, Flux<T>, Publisher<? extends R>> transformer;\n \n         Subscription s;\n         Throwable    throwable;\n         T            first;\n         boolean      done;\n \n-        volatile boolean cancelled;\n-\n         volatile CoreSubscriber<? super T> inner;\n         @SuppressWarnings(\"rawtypes\")\n-        static final AtomicReferenceFieldUpdater<AbstractSwitchOnFirstInner, CoreSubscriber> INNER =\n-                AtomicReferenceFieldUpdater.newUpdater(AbstractSwitchOnFirstInner.class, CoreSubscriber.class, \"inner\");\n+        static final AtomicReferenceFieldUpdater<AbstractSwitchOnFirstMain, CoreSubscriber> INNER =\n+                AtomicReferenceFieldUpdater.newUpdater(AbstractSwitchOnFirstMain.class, CoreSubscriber.class, \"inner\");\n \n         volatile int wip;\n         @SuppressWarnings(\"rawtypes\")\n-        static final AtomicIntegerFieldUpdater<AbstractSwitchOnFirstInner> WIP =\n-                AtomicIntegerFieldUpdater.newUpdater(AbstractSwitchOnFirstInner.class, \"wip\");\n+        static final AtomicIntegerFieldUpdater<AbstractSwitchOnFirstMain> WIP =\n+                AtomicIntegerFieldUpdater.newUpdater(AbstractSwitchOnFirstMain.class, \"wip\");\n \n         volatile int state;\n         @SuppressWarnings(\"rawtypes\")\n-        static final AtomicIntegerFieldUpdater<AbstractSwitchOnFirstInner> STATE =\n-                AtomicIntegerFieldUpdater.newUpdater(AbstractSwitchOnFirstInner.class, \"state\");\n+        static final AtomicIntegerFieldUpdater<AbstractSwitchOnFirstMain> STATE =\n+                AtomicIntegerFieldUpdater.newUpdater(AbstractSwitchOnFirstMain.class, \"state\");\n \n         @SuppressWarnings(\"unchecked\")\n-        AbstractSwitchOnFirstInner(\n+        AbstractSwitchOnFirstMain(\n                 CoreSubscriber<? super R> outer,\n-                BiFunction<Signal<? extends T>, Flux<T>, Publisher<? extends R>> transformer) {\n+                BiFunction<Signal<? extends T>, Flux<T>, Publisher<? extends R>> transformer,\n+                boolean cancelSourceOnComplete) {\n             this.outer = outer instanceof Fuseable.ConditionalSubscriber\n-                ? new SwitchOnFirstConditionalInnerSubscriber<>(this, (Fuseable.ConditionalSubscriber<R>) outer)\n-                : new SwitchOnFirstInnerSubscriber<>(this, outer);\n+                ? new SwitchOnFirstConditionalControlSubscriber<>(this, (Fuseable.ConditionalSubscriber<R>) outer, cancelSourceOnComplete)\n+                : new SwitchOnFirstControlSubscriber<>(this, outer, cancelSourceOnComplete);\n             this.transformer = transformer;\n         }\n \n         @Override\n         @Nullable\n         public Object scanUnsafe(Attr key) {\n-            if (key == Attr.CANCELLED) return cancelled;\n-            if (key == Attr.TERMINATED) return done || cancelled;\n+            final boolean isCancelled = this.inner == Operators.emptySubscriber();\n+\n+            if (key == Attr.CANCELLED) return isCancelled && !this.done;\n+            if (key == Attr.TERMINATED) return this.done || isCancelled;\n \n             return InnerOperator.super.scanUnsafe(key);\n         }\n \n         @Override\n         public CoreSubscriber<? super R> actual() {\n-            return outer;\n-        }\n-\n-        @Override\n-        public Context currentContext() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97161681ee1d43e5b9d39cb1f71af31166990297"}, "originalPosition": 115}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwMjc1MDEw", "url": "https://github.com/reactor/reactor-core/pull/2019#pullrequestreview-370275010", "createdAt": "2020-03-06T12:05:49Z", "commit": {"oid": "97161681ee1d43e5b9d39cb1f71af31166990297"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxMjowNTo0OVrOFy2jJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxMjowNTo0OVrOFy2jJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg2Njg1Mg==", "bodyText": "Using empty subscriber instance (which I assume for internal usage only) in order to indicate canceled state and", "url": "https://github.com/reactor/reactor-core/pull/2019#discussion_r388866852", "createdAt": "2020-03-06T12:05:49Z", "author": {"login": "OlegDokuka"}, "path": "reactor-core/src/main/java/reactor/core/publisher/FluxSwitchOnFirst.java", "diffHunk": "@@ -56,87 +64,73 @@ public int getPrefetch() {\n     @SuppressWarnings(\"unchecked\")\n     public CoreSubscriber<? super T> subscribeOrReturn(CoreSubscriber<? super R> actual) {\n         if (actual instanceof Fuseable.ConditionalSubscriber) {\n-            source.subscribe(new SwitchOnFirstConditionalInner<>((Fuseable.ConditionalSubscriber<? super R>) actual, transformer));\n-            return null;\n+            return new SwitchOnFirstConditionalMain<>((Fuseable.ConditionalSubscriber<? super R>) actual, transformer, cancelSourceOnComplete);\n         }\n-        return new SwitchOnFirstInner<>(actual, transformer);\n+        return new SwitchOnFirstMain<>(actual, transformer, cancelSourceOnComplete);\n     }\n \n-    static abstract class AbstractSwitchOnFirstInner<T, R> extends Flux<T>\n+    static abstract class AbstractSwitchOnFirstMain<T, R> extends Flux<T>\n             implements InnerOperator<T, R> {\n \n-        final CoreSubscriber<? super R>                                        outer;\n+        final ControlSubscriber<? super R>                                     outer;\n         final BiFunction<Signal<? extends T>, Flux<T>, Publisher<? extends R>> transformer;\n \n         Subscription s;\n         Throwable    throwable;\n         T            first;\n         boolean      done;\n \n-        volatile boolean cancelled;\n-\n         volatile CoreSubscriber<? super T> inner;\n         @SuppressWarnings(\"rawtypes\")\n-        static final AtomicReferenceFieldUpdater<AbstractSwitchOnFirstInner, CoreSubscriber> INNER =\n-                AtomicReferenceFieldUpdater.newUpdater(AbstractSwitchOnFirstInner.class, CoreSubscriber.class, \"inner\");\n+        static final AtomicReferenceFieldUpdater<AbstractSwitchOnFirstMain, CoreSubscriber> INNER =\n+                AtomicReferenceFieldUpdater.newUpdater(AbstractSwitchOnFirstMain.class, CoreSubscriber.class, \"inner\");\n \n         volatile int wip;\n         @SuppressWarnings(\"rawtypes\")\n-        static final AtomicIntegerFieldUpdater<AbstractSwitchOnFirstInner> WIP =\n-                AtomicIntegerFieldUpdater.newUpdater(AbstractSwitchOnFirstInner.class, \"wip\");\n+        static final AtomicIntegerFieldUpdater<AbstractSwitchOnFirstMain> WIP =\n+                AtomicIntegerFieldUpdater.newUpdater(AbstractSwitchOnFirstMain.class, \"wip\");\n \n         volatile int state;\n         @SuppressWarnings(\"rawtypes\")\n-        static final AtomicIntegerFieldUpdater<AbstractSwitchOnFirstInner> STATE =\n-                AtomicIntegerFieldUpdater.newUpdater(AbstractSwitchOnFirstInner.class, \"state\");\n+        static final AtomicIntegerFieldUpdater<AbstractSwitchOnFirstMain> STATE =\n+                AtomicIntegerFieldUpdater.newUpdater(AbstractSwitchOnFirstMain.class, \"state\");\n \n         @SuppressWarnings(\"unchecked\")\n-        AbstractSwitchOnFirstInner(\n+        AbstractSwitchOnFirstMain(\n                 CoreSubscriber<? super R> outer,\n-                BiFunction<Signal<? extends T>, Flux<T>, Publisher<? extends R>> transformer) {\n+                BiFunction<Signal<? extends T>, Flux<T>, Publisher<? extends R>> transformer,\n+                boolean cancelSourceOnComplete) {\n             this.outer = outer instanceof Fuseable.ConditionalSubscriber\n-                ? new SwitchOnFirstConditionalInnerSubscriber<>(this, (Fuseable.ConditionalSubscriber<R>) outer)\n-                : new SwitchOnFirstInnerSubscriber<>(this, outer);\n+                ? new SwitchOnFirstConditionalControlSubscriber<>(this, (Fuseable.ConditionalSubscriber<R>) outer, cancelSourceOnComplete)\n+                : new SwitchOnFirstControlSubscriber<>(this, outer, cancelSourceOnComplete);\n             this.transformer = transformer;\n         }\n \n         @Override\n         @Nullable\n         public Object scanUnsafe(Attr key) {\n-            if (key == Attr.CANCELLED) return cancelled;\n-            if (key == Attr.TERMINATED) return done || cancelled;\n+            final boolean isCancelled = this.inner == Operators.emptySubscriber();\n+\n+            if (key == Attr.CANCELLED) return isCancelled && !this.done;\n+            if (key == Attr.TERMINATED) return this.done || isCancelled;\n \n             return InnerOperator.super.scanUnsafe(key);\n         }\n \n         @Override\n         public CoreSubscriber<? super R> actual() {\n-            return outer;\n-        }\n-\n-        @Override\n-        public Context currentContext() {\n-            CoreSubscriber<? super T> actual = inner;\n-\n-            if (actual != null) {\n-                return actual.currentContext();\n-            }\n-\n-            return outer.currentContext();\n+            return this.outer;\n         }\n \n         @Override\n         public void cancel() {\n-            if (!cancelled) {\n-                cancelled = true;\n-                s.cancel();\n+            if (INNER.getAndSet(this, Operators.emptySubscriber()) != Operators.emptySubscriber()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97161681ee1d43e5b9d39cb1f71af31166990297"}, "originalPosition": 131}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwMjc1NDcx", "url": "https://github.com/reactor/reactor-core/pull/2019#pullrequestreview-370275471", "createdAt": "2020-03-06T12:06:44Z", "commit": {"oid": "97161681ee1d43e5b9d39cb1f71af31166990297"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxMjowNjo0NVrOFy2kuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxMjowNjo0NVrOFy2kuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg2NzI1OQ==", "bodyText": "double-check here in order to ensure that we really need to request the first element. if the subscription has been canceled already then noops required", "url": "https://github.com/reactor/reactor-core/pull/2019#discussion_r388867259", "createdAt": "2020-03-06T12:06:45Z", "author": {"login": "OlegDokuka"}, "path": "reactor-core/src/main/java/reactor/core/publisher/FluxSwitchOnFirst.java", "diffHunk": "@@ -147,36 +141,38 @@ public void cancel() {\n         public void onSubscribe(Subscription s) {\n             if (Operators.validate(this.s, s)) {\n                 this.s = s;\n-                s.request(1);\n+                this.outer.sendSubscription();\n+                if (this.inner != Operators.emptySubscriber()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97161681ee1d43e5b9d39cb1f71af31166990297"}, "originalPosition": 151}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwMjc5MzAw", "url": "https://github.com/reactor/reactor-core/pull/2019#pullrequestreview-370279300", "createdAt": "2020-03-06T12:14:37Z", "commit": {"oid": "97161681ee1d43e5b9d39cb1f71af31166990297"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxMjoxNDozN1rOFy2wMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxMjoxNDozN1rOFy2wMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg3MDE5Mw==", "bodyText": "I made emptySubscriber an instance of ConditionalSubscriber specifically for that case", "url": "https://github.com/reactor/reactor-core/pull/2019#discussion_r388870193", "createdAt": "2020-03-06T12:14:37Z", "author": {"login": "OlegDokuka"}, "path": "reactor-core/src/main/java/reactor/core/publisher/FluxSwitchOnFirst.java", "diffHunk": "@@ -420,64 +419,45 @@ public boolean tryOnNext(T t) {\n         }\n \n         @Override\n-        public void request(long n) {\n-            if (Operators.validate(n)) {\n-                if (first != null) {\n-                    if (drainRegular() && n != Long.MAX_VALUE) {\n-                        if (--n > 0) {\n-                            s.request(n);\n-                            return;\n-                        }\n-\n-                        return;\n-                    }\n-                }\n-\n-                s.request(n);\n-            }\n-        }\n-\n-        @Override\n-        void drain() {\n-            drainRegular();\n-        }\n-\n-        boolean drainRegular() {\n+        @SuppressWarnings(\"unchecked\")\n+        boolean drain() {\n             if (WIP.getAndIncrement(this) != 0) {\n                 return false;\n             }\n \n-            T f = first;\n+            T f = this.first;\n             int m = 1;\n             boolean sent = false;\n-            @SuppressWarnings(\"unchecked\")\n             Fuseable.ConditionalSubscriber<? super T> a =\n-                    (Fuseable.ConditionalSubscriber<? super T>) inner;\n+                    (Fuseable.ConditionalSubscriber<? super T>) this.inner;\n \n             for (;;) {\n                 if (f != null) {\n-                    first = null;\n+                    this.first = null;\n \n-                    if (cancelled) {\n-                        Operators.onDiscard(f, a.currentContext());\n+                    if (a == Operators.emptySubscriber()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97161681ee1d43e5b9d39cb1f71af31166990297"}, "originalPosition": 550}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwMjc5Njc0", "url": "https://github.com/reactor/reactor-core/pull/2019#pullrequestreview-370279674", "createdAt": "2020-03-06T12:15:19Z", "commit": {"oid": "97161681ee1d43e5b9d39cb1f71af31166990297"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxMjoxNToxOVrOFy2xRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxMjoxNToxOVrOFy2xRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg3MDQ2OQ==", "bodyText": "Should not be a big deal to support ConditionalSubscriber interface which includes CoreSubscriber interface as well", "url": "https://github.com/reactor/reactor-core/pull/2019#discussion_r388870469", "createdAt": "2020-03-06T12:15:19Z", "author": {"login": "OlegDokuka"}, "path": "reactor-core/src/main/java/reactor/core/publisher/Operators.java", "diffHunk": "@@ -1413,7 +1413,7 @@ public void subscribe(Subscriber<? super T> s) {\n \t\t}\n \t}\n \n-\tstatic final CoreSubscriber<?> EMPTY_SUBSCRIBER = new CoreSubscriber<Object>() {\n+\tstatic final Fuseable.ConditionalSubscriber<?> EMPTY_SUBSCRIBER = new Fuseable.ConditionalSubscriber<Object>() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97161681ee1d43e5b9d39cb1f71af31166990297"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5fccf4c1acc81d85fed028f25ef2ab769de39d0a", "author": {"user": {"login": "OlegDokuka", "name": "Oleh Dokuka"}}, "url": "https://github.com/reactor/reactor-core/commit/5fccf4c1acc81d85fed028f25ef2ab769de39d0a", "committedDate": "2020-03-06T12:24:44Z", "message": "fixes tests. ensures cancellation is propagated\n\nSigned-off-by: Oleh Dokuka <shadowgun@i.ua>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwMzk1NDEw", "url": "https://github.com/reactor/reactor-core/pull/2019#pullrequestreview-370395410", "createdAt": "2020-03-06T15:13:36Z", "commit": {"oid": "5fccf4c1acc81d85fed028f25ef2ab769de39d0a"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxNToxMzozNlrOFy8NlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxNTo1MDoyMlrOFy9jdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODk1OTYzNw==", "bodyText": "this boils down to outer.currentContext(), so ok", "url": "https://github.com/reactor/reactor-core/pull/2019#discussion_r388959637", "createdAt": "2020-03-06T15:13:36Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/FluxSwitchOnFirst.java", "diffHunk": "@@ -56,87 +64,73 @@ public int getPrefetch() {\n     @SuppressWarnings(\"unchecked\")\n     public CoreSubscriber<? super T> subscribeOrReturn(CoreSubscriber<? super R> actual) {\n         if (actual instanceof Fuseable.ConditionalSubscriber) {\n-            source.subscribe(new SwitchOnFirstConditionalInner<>((Fuseable.ConditionalSubscriber<? super R>) actual, transformer));\n-            return null;\n+            return new SwitchOnFirstConditionalMain<>((Fuseable.ConditionalSubscriber<? super R>) actual, transformer, cancelSourceOnComplete);\n         }\n-        return new SwitchOnFirstInner<>(actual, transformer);\n+        return new SwitchOnFirstMain<>(actual, transformer, cancelSourceOnComplete);\n     }\n \n-    static abstract class AbstractSwitchOnFirstInner<T, R> extends Flux<T>\n+    static abstract class AbstractSwitchOnFirstMain<T, R> extends Flux<T>\n             implements InnerOperator<T, R> {\n \n-        final CoreSubscriber<? super R>                                        outer;\n+        final ControlSubscriber<? super R>                                     outer;\n         final BiFunction<Signal<? extends T>, Flux<T>, Publisher<? extends R>> transformer;\n \n         Subscription s;\n         Throwable    throwable;\n         T            first;\n         boolean      done;\n \n-        volatile boolean cancelled;\n-\n         volatile CoreSubscriber<? super T> inner;\n         @SuppressWarnings(\"rawtypes\")\n-        static final AtomicReferenceFieldUpdater<AbstractSwitchOnFirstInner, CoreSubscriber> INNER =\n-                AtomicReferenceFieldUpdater.newUpdater(AbstractSwitchOnFirstInner.class, CoreSubscriber.class, \"inner\");\n+        static final AtomicReferenceFieldUpdater<AbstractSwitchOnFirstMain, CoreSubscriber> INNER =\n+                AtomicReferenceFieldUpdater.newUpdater(AbstractSwitchOnFirstMain.class, CoreSubscriber.class, \"inner\");\n \n         volatile int wip;\n         @SuppressWarnings(\"rawtypes\")\n-        static final AtomicIntegerFieldUpdater<AbstractSwitchOnFirstInner> WIP =\n-                AtomicIntegerFieldUpdater.newUpdater(AbstractSwitchOnFirstInner.class, \"wip\");\n+        static final AtomicIntegerFieldUpdater<AbstractSwitchOnFirstMain> WIP =\n+                AtomicIntegerFieldUpdater.newUpdater(AbstractSwitchOnFirstMain.class, \"wip\");\n \n         volatile int state;\n         @SuppressWarnings(\"rawtypes\")\n-        static final AtomicIntegerFieldUpdater<AbstractSwitchOnFirstInner> STATE =\n-                AtomicIntegerFieldUpdater.newUpdater(AbstractSwitchOnFirstInner.class, \"state\");\n+        static final AtomicIntegerFieldUpdater<AbstractSwitchOnFirstMain> STATE =\n+                AtomicIntegerFieldUpdater.newUpdater(AbstractSwitchOnFirstMain.class, \"state\");\n \n         @SuppressWarnings(\"unchecked\")\n-        AbstractSwitchOnFirstInner(\n+        AbstractSwitchOnFirstMain(\n                 CoreSubscriber<? super R> outer,\n-                BiFunction<Signal<? extends T>, Flux<T>, Publisher<? extends R>> transformer) {\n+                BiFunction<Signal<? extends T>, Flux<T>, Publisher<? extends R>> transformer,\n+                boolean cancelSourceOnComplete) {\n             this.outer = outer instanceof Fuseable.ConditionalSubscriber\n-                ? new SwitchOnFirstConditionalInnerSubscriber<>(this, (Fuseable.ConditionalSubscriber<R>) outer)\n-                : new SwitchOnFirstInnerSubscriber<>(this, outer);\n+                ? new SwitchOnFirstConditionalControlSubscriber<>(this, (Fuseable.ConditionalSubscriber<R>) outer, cancelSourceOnComplete)\n+                : new SwitchOnFirstControlSubscriber<>(this, outer, cancelSourceOnComplete);\n             this.transformer = transformer;\n         }\n \n         @Override\n         @Nullable\n         public Object scanUnsafe(Attr key) {\n-            if (key == Attr.CANCELLED) return cancelled;\n-            if (key == Attr.TERMINATED) return done || cancelled;\n+            final boolean isCancelled = this.inner == Operators.emptySubscriber();\n+\n+            if (key == Attr.CANCELLED) return isCancelled && !this.done;\n+            if (key == Attr.TERMINATED) return this.done || isCancelled;\n \n             return InnerOperator.super.scanUnsafe(key);\n         }\n \n         @Override\n         public CoreSubscriber<? super R> actual() {\n-            return outer;\n-        }\n-\n-        @Override\n-        public Context currentContext() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg2NjU2NQ=="}, "originalCommit": {"oid": "97161681ee1d43e5b9d39cb1f71af31166990297"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODk2MDgyMg==", "bodyText": "I guess to be extra sure to be shielded from Operators.emptySubscriber() ever returning a new instance, you can directly use Operators.EMPTY_SUBSCRIBER ? (fine for usage internal to the publisher package)", "url": "https://github.com/reactor/reactor-core/pull/2019#discussion_r388960822", "createdAt": "2020-03-06T15:15:37Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/FluxSwitchOnFirst.java", "diffHunk": "@@ -56,87 +64,73 @@ public int getPrefetch() {\n     @SuppressWarnings(\"unchecked\")\n     public CoreSubscriber<? super T> subscribeOrReturn(CoreSubscriber<? super R> actual) {\n         if (actual instanceof Fuseable.ConditionalSubscriber) {\n-            source.subscribe(new SwitchOnFirstConditionalInner<>((Fuseable.ConditionalSubscriber<? super R>) actual, transformer));\n-            return null;\n+            return new SwitchOnFirstConditionalMain<>((Fuseable.ConditionalSubscriber<? super R>) actual, transformer, cancelSourceOnComplete);\n         }\n-        return new SwitchOnFirstInner<>(actual, transformer);\n+        return new SwitchOnFirstMain<>(actual, transformer, cancelSourceOnComplete);\n     }\n \n-    static abstract class AbstractSwitchOnFirstInner<T, R> extends Flux<T>\n+    static abstract class AbstractSwitchOnFirstMain<T, R> extends Flux<T>\n             implements InnerOperator<T, R> {\n \n-        final CoreSubscriber<? super R>                                        outer;\n+        final ControlSubscriber<? super R>                                     outer;\n         final BiFunction<Signal<? extends T>, Flux<T>, Publisher<? extends R>> transformer;\n \n         Subscription s;\n         Throwable    throwable;\n         T            first;\n         boolean      done;\n \n-        volatile boolean cancelled;\n-\n         volatile CoreSubscriber<? super T> inner;\n         @SuppressWarnings(\"rawtypes\")\n-        static final AtomicReferenceFieldUpdater<AbstractSwitchOnFirstInner, CoreSubscriber> INNER =\n-                AtomicReferenceFieldUpdater.newUpdater(AbstractSwitchOnFirstInner.class, CoreSubscriber.class, \"inner\");\n+        static final AtomicReferenceFieldUpdater<AbstractSwitchOnFirstMain, CoreSubscriber> INNER =\n+                AtomicReferenceFieldUpdater.newUpdater(AbstractSwitchOnFirstMain.class, CoreSubscriber.class, \"inner\");\n \n         volatile int wip;\n         @SuppressWarnings(\"rawtypes\")\n-        static final AtomicIntegerFieldUpdater<AbstractSwitchOnFirstInner> WIP =\n-                AtomicIntegerFieldUpdater.newUpdater(AbstractSwitchOnFirstInner.class, \"wip\");\n+        static final AtomicIntegerFieldUpdater<AbstractSwitchOnFirstMain> WIP =\n+                AtomicIntegerFieldUpdater.newUpdater(AbstractSwitchOnFirstMain.class, \"wip\");\n \n         volatile int state;\n         @SuppressWarnings(\"rawtypes\")\n-        static final AtomicIntegerFieldUpdater<AbstractSwitchOnFirstInner> STATE =\n-                AtomicIntegerFieldUpdater.newUpdater(AbstractSwitchOnFirstInner.class, \"state\");\n+        static final AtomicIntegerFieldUpdater<AbstractSwitchOnFirstMain> STATE =\n+                AtomicIntegerFieldUpdater.newUpdater(AbstractSwitchOnFirstMain.class, \"state\");\n \n         @SuppressWarnings(\"unchecked\")\n-        AbstractSwitchOnFirstInner(\n+        AbstractSwitchOnFirstMain(\n                 CoreSubscriber<? super R> outer,\n-                BiFunction<Signal<? extends T>, Flux<T>, Publisher<? extends R>> transformer) {\n+                BiFunction<Signal<? extends T>, Flux<T>, Publisher<? extends R>> transformer,\n+                boolean cancelSourceOnComplete) {\n             this.outer = outer instanceof Fuseable.ConditionalSubscriber\n-                ? new SwitchOnFirstConditionalInnerSubscriber<>(this, (Fuseable.ConditionalSubscriber<R>) outer)\n-                : new SwitchOnFirstInnerSubscriber<>(this, outer);\n+                ? new SwitchOnFirstConditionalControlSubscriber<>(this, (Fuseable.ConditionalSubscriber<R>) outer, cancelSourceOnComplete)\n+                : new SwitchOnFirstControlSubscriber<>(this, outer, cancelSourceOnComplete);\n             this.transformer = transformer;\n         }\n \n         @Override\n         @Nullable\n         public Object scanUnsafe(Attr key) {\n-            if (key == Attr.CANCELLED) return cancelled;\n-            if (key == Attr.TERMINATED) return done || cancelled;\n+            final boolean isCancelled = this.inner == Operators.emptySubscriber();\n+\n+            if (key == Attr.CANCELLED) return isCancelled && !this.done;\n+            if (key == Attr.TERMINATED) return this.done || isCancelled;\n \n             return InnerOperator.super.scanUnsafe(key);\n         }\n \n         @Override\n         public CoreSubscriber<? super R> actual() {\n-            return outer;\n-        }\n-\n-        @Override\n-        public Context currentContext() {\n-            CoreSubscriber<? super T> actual = inner;\n-\n-            if (actual != null) {\n-                return actual.currentContext();\n-            }\n-\n-            return outer.currentContext();\n+            return this.outer;\n         }\n \n         @Override\n         public void cancel() {\n-            if (!cancelled) {\n-                cancelled = true;\n-                s.cancel();\n+            if (INNER.getAndSet(this, Operators.emptySubscriber()) != Operators.emptySubscriber()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg2Njg1Mg=="}, "originalCommit": {"oid": "97161681ee1d43e5b9d39cb1f71af31166990297"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODk2MTQ4NQ==", "bodyText": "again, you can use Operators.EMPTY_SUBSCRIBER to be 100% shielded from API implementation details", "url": "https://github.com/reactor/reactor-core/pull/2019#discussion_r388961485", "createdAt": "2020-03-06T15:16:44Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/FluxSwitchOnFirst.java", "diffHunk": "@@ -147,36 +141,38 @@ public void cancel() {\n         public void onSubscribe(Subscription s) {\n             if (Operators.validate(this.s, s)) {\n                 this.s = s;\n-                s.request(1);\n+                this.outer.sendSubscription();\n+                if (this.inner != Operators.emptySubscriber()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg2NzI1OQ=="}, "originalCommit": {"oid": "97161681ee1d43e5b9d39cb1f71af31166990297"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODk2MTY2OA==", "bodyText": "same as above", "url": "https://github.com/reactor/reactor-core/pull/2019#discussion_r388961668", "createdAt": "2020-03-06T15:17:07Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/FluxSwitchOnFirst.java", "diffHunk": "@@ -186,29 +182,29 @@ public void onNext(T t) {\n \n         @Override\n         public void onError(Throwable t) {\n-            if (done) {\n+            final CoreSubscriber<? super T> i = this.inner;\n+            if (this.done || i == Operators.emptySubscriber()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5fccf4c1acc81d85fed028f25ef2ab769de39d0a"}, "originalPosition": 200}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODk2MTgwMQ==", "bodyText": "same as above", "url": "https://github.com/reactor/reactor-core/pull/2019#discussion_r388961801", "createdAt": "2020-03-06T15:17:20Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/FluxSwitchOnFirst.java", "diffHunk": "@@ -223,27 +219,27 @@ public void onError(Throwable t) {\n \n         @Override\n         public void onComplete() {\n-            if (done) {\n+            final CoreSubscriber<? super T> i = this.inner;\n+            if (this.done || i == Operators.emptySubscriber()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5fccf4c1acc81d85fed028f25ef2ab769de39d0a"}, "originalPosition": 241}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODk2MjE5Mg==", "bodyText": "can use EMPTY_SUBSCRIBER constant here too", "url": "https://github.com/reactor/reactor-core/pull/2019#discussion_r388962192", "createdAt": "2020-03-06T15:17:57Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/FluxSwitchOnFirst.java", "diffHunk": "@@ -289,94 +305,78 @@ public void subscribe(CoreSubscriber<? super T> actual) {\n         }\n \n         @Override\n-        public void request(long n) {\n-            if (Operators.validate(n)) {\n-                if (first != null) {\n-                    drain();\n-\n-                    if (n != Long.MAX_VALUE) {\n-                        if (--n > 0) {\n-                            s.request(n);\n-                            return;\n-                        }\n-\n-                        return;\n-                    }\n-                }\n-\n-                s.request(n);\n-            }\n-        }\n-\n-        @Override\n-        void drain() {\n+        boolean drain() {\n             if (WIP.getAndIncrement(this) != 0) {\n-                return;\n+                return false;\n             }\n \n-            T f = first;\n+            CoreSubscriber<? super T> a = this.inner;\n+            T f = this.first;\n             int m = 1;\n-            CoreSubscriber<? super T> a = inner;\n \n             for (;;) {\n                 if (f != null) {\n-                    first = null;\n+                    this.first = null;\n \n-                    if (cancelled) {\n-                        Operators.onDiscard(f, a.currentContext());\n-                        return;\n+                    if (a == Operators.emptySubscriber()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5fccf4c1acc81d85fed028f25ef2ab769de39d0a"}, "originalPosition": 380}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODk3OTM4OA==", "bodyText": "I'll evaluate that change separately in a comment below (the conditional one). ok for conditional \u2705  Otherwise, same as elsewhere, can use EMPTY_SUBSCRIBER constant.", "url": "https://github.com/reactor/reactor-core/pull/2019#discussion_r388979388", "createdAt": "2020-03-06T15:46:24Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/FluxSwitchOnFirst.java", "diffHunk": "@@ -420,64 +419,45 @@ public boolean tryOnNext(T t) {\n         }\n \n         @Override\n-        public void request(long n) {\n-            if (Operators.validate(n)) {\n-                if (first != null) {\n-                    if (drainRegular() && n != Long.MAX_VALUE) {\n-                        if (--n > 0) {\n-                            s.request(n);\n-                            return;\n-                        }\n-\n-                        return;\n-                    }\n-                }\n-\n-                s.request(n);\n-            }\n-        }\n-\n-        @Override\n-        void drain() {\n-            drainRegular();\n-        }\n-\n-        boolean drainRegular() {\n+        @SuppressWarnings(\"unchecked\")\n+        boolean drain() {\n             if (WIP.getAndIncrement(this) != 0) {\n                 return false;\n             }\n \n-            T f = first;\n+            T f = this.first;\n             int m = 1;\n             boolean sent = false;\n-            @SuppressWarnings(\"unchecked\")\n             Fuseable.ConditionalSubscriber<? super T> a =\n-                    (Fuseable.ConditionalSubscriber<? super T>) inner;\n+                    (Fuseable.ConditionalSubscriber<? super T>) this.inner;\n \n             for (;;) {\n                 if (f != null) {\n-                    first = null;\n+                    this.first = null;\n \n-                    if (cancelled) {\n-                        Operators.onDiscard(f, a.currentContext());\n+                    if (a == Operators.emptySubscriber()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg3MDE5Mw=="}, "originalCommit": {"oid": "97161681ee1d43e5b9d39cb1f71af31166990297"}, "originalPosition": 550}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODk4MDE1NQ==", "bodyText": "thanks for the explanations, comments and face-to-face review, this is clear to me now \ud83d\udc4d", "url": "https://github.com/reactor/reactor-core/pull/2019#discussion_r388980155", "createdAt": "2020-03-06T15:47:48Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/FluxSwitchOnFirst.java", "diffHunk": "@@ -523,58 +559,141 @@ public void onError(Throwable throwable) {\n                 parent.cancel();\n             }\n \n-            inner.onError(throwable);\n+            delegate.onError(throwable);\n         }\n \n         @Override\n         public void onComplete() {\n-            if (!parent.done) {\n+            if (!parent.done && cancelSourceOnComplete) {\n                 parent.cancel();\n             }\n \n-            inner.onComplete();\n+            delegate.onComplete();\n+        }\n+\n+        @Override\n+        public void request(long n) {\n+            long r = this.requested;\n+\n+            if (r > STATE_REQUESTED) {\n+                long u;\n+                for (;;) {\n+                    if (r == Long.MAX_VALUE) {\n+                        return;\n+                    }\n+                    u = Operators.addCap(r, n);\n+                    if (REQUESTED.compareAndSet(this, r, u)) {\n+                        return;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg0Njc1Nw=="}, "originalCommit": {"oid": "877b27053c1efc5fd287d1617535114e32ccb1d1"}, "originalPosition": 236}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODk4MTYyMw==", "bodyText": "looks good to me \ud83d\udc4d\nconceptually, instanceof ConditionalSubscriber should be done early on, during subscribe(), at which point the passed Subscriber is not supposed to be an EMPTY_SUBSCRIBER anyway so all good here \u2705", "url": "https://github.com/reactor/reactor-core/pull/2019#discussion_r388981623", "createdAt": "2020-03-06T15:50:22Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/Operators.java", "diffHunk": "@@ -1413,7 +1413,7 @@ public void subscribe(Subscriber<? super T> s) {\n \t\t}\n \t}\n \n-\tstatic final CoreSubscriber<?> EMPTY_SUBSCRIBER = new CoreSubscriber<Object>() {\n+\tstatic final Fuseable.ConditionalSubscriber<?> EMPTY_SUBSCRIBER = new Fuseable.ConditionalSubscriber<Object>() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg3MDQ2OQ=="}, "originalCommit": {"oid": "97161681ee1d43e5b9d39cb1f71af31166990297"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "422e5ceb4cdf4b5bdea4220e7d7ada606a846848", "author": {"user": {"login": "OlegDokuka", "name": "Oleh Dokuka"}}, "url": "https://github.com/reactor/reactor-core/commit/422e5ceb4cdf4b5bdea4220e7d7ada606a846848", "committedDate": "2020-03-06T16:20:57Z", "message": "uses directly the Operators.EMPTY_SUBSCRIBER constant\n\nSigned-off-by: Oleh Dokuka <shadowgun@i.ua>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwNDUxMDk5", "url": "https://github.com/reactor/reactor-core/pull/2019#pullrequestreview-370451099", "createdAt": "2020-03-06T16:23:19Z", "commit": {"oid": "422e5ceb4cdf4b5bdea4220e7d7ada606a846848"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2889, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}