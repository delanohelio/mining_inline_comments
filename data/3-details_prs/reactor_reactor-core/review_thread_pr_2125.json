{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA2MTUxOTAz", "number": 2125, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNzoxNjowN1rODz1cHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMDo1NDo0MVrOD0Lg5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1Njc5NTE4OnYy", "diffSide": "RIGHT", "path": "reactor-core/src/test/java/reactor/core/publisher/AbstractOnDiscardShouldNotLeakTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNzoxNjowN1rOGIfF6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNzoxNjowN1rOGIfF6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU1MTIwOA==", "bodyText": "if possible (depends on whether or not future test cases will absolutely need the whole array of publishers in a single array variable), I would suggest the following signature:\nprotected abstract Publisher<Tracked<?>> transform(TestPublisher<Tracked<?>> firstUpstream, TestPublisher<Tracked<?>>... otherUpstreams);", "url": "https://github.com/reactor/reactor-core/pull/2125#discussion_r411551208", "createdAt": "2020-04-20T17:16:07Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/test/java/reactor/core/publisher/AbstractOnDiscardShouldNotLeakTest.java", "diffHunk": "@@ -40,7 +42,7 @@ public AbstractOnDiscardShouldNotLeakTest(boolean conditional, boolean fused) {\n         this.fused = fused;\n     }\n \n-    abstract Flux<Tracked<?>> transform(Flux<Tracked<?>> upstream);\n+    protected abstract Publisher<Tracked<?>> transform(TestPublisher<Tracked<?>>... upstreams);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f486cbf4dd08af2af6082292bd0e0fbd1defe38"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MDM5Mjg2OnYy", "diffSide": "RIGHT", "path": "reactor-core/src/test/java/reactor/core/publisher/AbstractOnDiscardShouldNotLeakTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMDo1MDowNFrOGI_UTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMDo1ODo1OVrOGI_ptA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjA3OTE4MQ==", "bodyText": "should be in try {} finally {} to avoid a leak", "url": "https://github.com/reactor/reactor-core/pull/2125#discussion_r412079181", "createdAt": "2020-04-21T10:50:04Z", "author": {"login": "bsideup"}, "path": "reactor-core/src/test/java/reactor/core/publisher/AbstractOnDiscardShouldNotLeakTest.java", "diffHunk": "@@ -0,0 +1,443 @@\n+package reactor.core.publisher;\n+\n+import org.assertj.core.api.Assertions;\n+import org.assertj.core.api.Assumptions;\n+import org.junit.After;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.reactivestreams.Publisher;\n+import reactor.core.Fuseable;\n+import reactor.core.Scannable;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+import reactor.test.publisher.TestPublisher;\n+import reactor.test.subscriber.AssertSubscriber;\n+import reactor.test.util.RaceTestUtils;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+@RunWith(Parameterized.class)\n+public abstract class AbstractOnDiscardShouldNotLeakTest {\n+\n+    @Parameterized.Parameters\n+    public static Collection<Boolean[]> data() {\n+        return Arrays.asList(new Boolean[][] {\n+            { false, false },\n+            { true, false },\n+            { false, true },\n+            { true, true }\n+        });\n+    }\n+\n+    private final boolean conditional;\n+    private final boolean fused;\n+\n+    public AbstractOnDiscardShouldNotLeakTest(boolean conditional, boolean fused) {\n+        this.conditional = conditional;\n+        this.fused = fused;\n+    }\n+\n+    protected abstract Publisher<Tracked<?>> transform(TestPublisher<Tracked<?>> main, TestPublisher<Tracked<?>>... additional);\n+\n+    int subscriptionsNumber() {\n+        return 1;\n+    }\n+\n+    @After\n+    public void tearDown() {\n+        Hooks.resetOnNextDropped();\n+        Hooks.resetOnErrorDropped();\n+        Hooks.resetOnNextError();\n+        Hooks.resetOnOperatorError();\n+    }\n+\n+    @Test\n+    public void ensureMultipleSubscribersSupportWithNoLeaksWhenRacingCancelAndOnNextAndRequest() {\n+        Hooks.onNextDropped(Tracked::safeRelease);\n+        Hooks.onErrorDropped(e -> {});\n+        Hooks.onOperatorError((e,v) -> null);\n+        int subscriptionsNumber = subscriptionsNumber();\n+        Scheduler scheduler = Schedulers.newParallel(\"testScheduler\", subscriptionsNumber + 1);\n+        scheduler.start();\n+        for (int i = 0; i < 10000; i++) {\n+            int[] index = new int[] {subscriptionsNumber};\n+            TestPublisher<Tracked<?>>[] testPublishers = new TestPublisher[subscriptionsNumber];\n+\n+            for (int i1 = 0; i1 < subscriptionsNumber; i1++) {\n+                testPublishers[i1] = TestPublisher.createNoncompliant(TestPublisher.Violation.DEFER_CANCELLATION, TestPublisher.Violation.REQUEST_OVERFLOW);\n+            }\n+\n+            Publisher<Tracked<?>> source = transform(testPublishers[0], Arrays.copyOfRange(testPublishers, 1, testPublishers.length));\n+\n+            if (conditional) {\n+                if (source instanceof Flux) {\n+                    source = ((Flux<Tracked<?>>)source).filter(t -> true);\n+                } else {\n+                    source = ((Mono<Tracked<?>>)source).filter(t -> true);\n+                }\n+            }\n+\n+            AssertSubscriber<Tracked<?>> assertSubscriber = new AssertSubscriber<>(Operators.enableOnDiscard(null, Tracked::safeRelease), 0);\n+            if (fused) {\n+                assertSubscriber.requestedFusionMode(Fuseable.ANY);\n+            }\n+            source.subscribe(assertSubscriber);\n+\n+            if (subscriptionsNumber == 1) {\n+                Tracked<Integer> value = new Tracked<>(1);\n+                RaceTestUtils.race(() -> RaceTestUtils.race(assertSubscriber::cancel, () -> assertSubscriber.request(Long.MAX_VALUE), scheduler), () -> testPublishers[0].next(value), scheduler);\n+            } else {\n+                int startIndex = --index[0];\n+                Tracked<Integer> value1 = new Tracked<>(startIndex);\n+                int secondIndex = --index[0];\n+                Tracked<Integer> value2 = new Tracked<>(secondIndex);\n+                Runnable action = () -> RaceTestUtils.race(() -> testPublishers[startIndex].next(value1), () -> testPublishers[secondIndex].next(value2), scheduler);\n+\n+                while (index[0] > 0) {\n+                    int nextIndex = --index[0];\n+                    Tracked<Integer> nextValue = new Tracked<>(nextIndex);\n+                    Runnable nextAction = action;\n+                    action = () -> RaceTestUtils.race(nextAction, () -> testPublishers[nextIndex].next(nextValue), scheduler);\n+                }\n+                RaceTestUtils.race(() -> RaceTestUtils.race(assertSubscriber::cancel, () -> assertSubscriber.request(Long.MAX_VALUE), scheduler), action, scheduler);\n+            }\n+\n+            List<Tracked<?>> values = assertSubscriber.values();\n+            values.forEach(Tracked::release);\n+\n+            Tracked.assertNoLeaks();\n+        }\n+        scheduler.dispose();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e71d24ed008b177d3da03600fad3fa3e1a698e4b"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjA4NDY2MA==", "bodyText": "Moved to a common field which setups @before each test and dispose in the @after method", "url": "https://github.com/reactor/reactor-core/pull/2125#discussion_r412084660", "createdAt": "2020-04-21T10:58:59Z", "author": {"login": "OlegDokuka"}, "path": "reactor-core/src/test/java/reactor/core/publisher/AbstractOnDiscardShouldNotLeakTest.java", "diffHunk": "@@ -0,0 +1,443 @@\n+package reactor.core.publisher;\n+\n+import org.assertj.core.api.Assertions;\n+import org.assertj.core.api.Assumptions;\n+import org.junit.After;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.reactivestreams.Publisher;\n+import reactor.core.Fuseable;\n+import reactor.core.Scannable;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+import reactor.test.publisher.TestPublisher;\n+import reactor.test.subscriber.AssertSubscriber;\n+import reactor.test.util.RaceTestUtils;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+@RunWith(Parameterized.class)\n+public abstract class AbstractOnDiscardShouldNotLeakTest {\n+\n+    @Parameterized.Parameters\n+    public static Collection<Boolean[]> data() {\n+        return Arrays.asList(new Boolean[][] {\n+            { false, false },\n+            { true, false },\n+            { false, true },\n+            { true, true }\n+        });\n+    }\n+\n+    private final boolean conditional;\n+    private final boolean fused;\n+\n+    public AbstractOnDiscardShouldNotLeakTest(boolean conditional, boolean fused) {\n+        this.conditional = conditional;\n+        this.fused = fused;\n+    }\n+\n+    protected abstract Publisher<Tracked<?>> transform(TestPublisher<Tracked<?>> main, TestPublisher<Tracked<?>>... additional);\n+\n+    int subscriptionsNumber() {\n+        return 1;\n+    }\n+\n+    @After\n+    public void tearDown() {\n+        Hooks.resetOnNextDropped();\n+        Hooks.resetOnErrorDropped();\n+        Hooks.resetOnNextError();\n+        Hooks.resetOnOperatorError();\n+    }\n+\n+    @Test\n+    public void ensureMultipleSubscribersSupportWithNoLeaksWhenRacingCancelAndOnNextAndRequest() {\n+        Hooks.onNextDropped(Tracked::safeRelease);\n+        Hooks.onErrorDropped(e -> {});\n+        Hooks.onOperatorError((e,v) -> null);\n+        int subscriptionsNumber = subscriptionsNumber();\n+        Scheduler scheduler = Schedulers.newParallel(\"testScheduler\", subscriptionsNumber + 1);\n+        scheduler.start();\n+        for (int i = 0; i < 10000; i++) {\n+            int[] index = new int[] {subscriptionsNumber};\n+            TestPublisher<Tracked<?>>[] testPublishers = new TestPublisher[subscriptionsNumber];\n+\n+            for (int i1 = 0; i1 < subscriptionsNumber; i1++) {\n+                testPublishers[i1] = TestPublisher.createNoncompliant(TestPublisher.Violation.DEFER_CANCELLATION, TestPublisher.Violation.REQUEST_OVERFLOW);\n+            }\n+\n+            Publisher<Tracked<?>> source = transform(testPublishers[0], Arrays.copyOfRange(testPublishers, 1, testPublishers.length));\n+\n+            if (conditional) {\n+                if (source instanceof Flux) {\n+                    source = ((Flux<Tracked<?>>)source).filter(t -> true);\n+                } else {\n+                    source = ((Mono<Tracked<?>>)source).filter(t -> true);\n+                }\n+            }\n+\n+            AssertSubscriber<Tracked<?>> assertSubscriber = new AssertSubscriber<>(Operators.enableOnDiscard(null, Tracked::safeRelease), 0);\n+            if (fused) {\n+                assertSubscriber.requestedFusionMode(Fuseable.ANY);\n+            }\n+            source.subscribe(assertSubscriber);\n+\n+            if (subscriptionsNumber == 1) {\n+                Tracked<Integer> value = new Tracked<>(1);\n+                RaceTestUtils.race(() -> RaceTestUtils.race(assertSubscriber::cancel, () -> assertSubscriber.request(Long.MAX_VALUE), scheduler), () -> testPublishers[0].next(value), scheduler);\n+            } else {\n+                int startIndex = --index[0];\n+                Tracked<Integer> value1 = new Tracked<>(startIndex);\n+                int secondIndex = --index[0];\n+                Tracked<Integer> value2 = new Tracked<>(secondIndex);\n+                Runnable action = () -> RaceTestUtils.race(() -> testPublishers[startIndex].next(value1), () -> testPublishers[secondIndex].next(value2), scheduler);\n+\n+                while (index[0] > 0) {\n+                    int nextIndex = --index[0];\n+                    Tracked<Integer> nextValue = new Tracked<>(nextIndex);\n+                    Runnable nextAction = action;\n+                    action = () -> RaceTestUtils.race(nextAction, () -> testPublishers[nextIndex].next(nextValue), scheduler);\n+                }\n+                RaceTestUtils.race(() -> RaceTestUtils.race(assertSubscriber::cancel, () -> assertSubscriber.request(Long.MAX_VALUE), scheduler), action, scheduler);\n+            }\n+\n+            List<Tracked<?>> values = assertSubscriber.values();\n+            values.forEach(Tracked::release);\n+\n+            Tracked.assertNoLeaks();\n+        }\n+        scheduler.dispose();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjA3OTE4MQ=="}, "originalCommit": {"oid": "e71d24ed008b177d3da03600fad3fa3e1a698e4b"}, "originalPosition": 116}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MDM5NTI4OnYy", "diffSide": "RIGHT", "path": "reactor-core/src/test/java/reactor/core/publisher/AbstractOnDiscardShouldNotLeakTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMDo1MDo0M1rOGI_VwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMDo1ODo0MlrOGI_o_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjA3OTU1Mg==", "bodyText": "this block seems to be repeated in tests, perhaps it can be reused", "url": "https://github.com/reactor/reactor-core/pull/2125#discussion_r412079552", "createdAt": "2020-04-21T10:50:43Z", "author": {"login": "bsideup"}, "path": "reactor-core/src/test/java/reactor/core/publisher/AbstractOnDiscardShouldNotLeakTest.java", "diffHunk": "@@ -0,0 +1,443 @@\n+package reactor.core.publisher;\n+\n+import org.assertj.core.api.Assertions;\n+import org.assertj.core.api.Assumptions;\n+import org.junit.After;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.reactivestreams.Publisher;\n+import reactor.core.Fuseable;\n+import reactor.core.Scannable;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+import reactor.test.publisher.TestPublisher;\n+import reactor.test.subscriber.AssertSubscriber;\n+import reactor.test.util.RaceTestUtils;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+@RunWith(Parameterized.class)\n+public abstract class AbstractOnDiscardShouldNotLeakTest {\n+\n+    @Parameterized.Parameters\n+    public static Collection<Boolean[]> data() {\n+        return Arrays.asList(new Boolean[][] {\n+            { false, false },\n+            { true, false },\n+            { false, true },\n+            { true, true }\n+        });\n+    }\n+\n+    private final boolean conditional;\n+    private final boolean fused;\n+\n+    public AbstractOnDiscardShouldNotLeakTest(boolean conditional, boolean fused) {\n+        this.conditional = conditional;\n+        this.fused = fused;\n+    }\n+\n+    protected abstract Publisher<Tracked<?>> transform(TestPublisher<Tracked<?>> main, TestPublisher<Tracked<?>>... additional);\n+\n+    int subscriptionsNumber() {\n+        return 1;\n+    }\n+\n+    @After\n+    public void tearDown() {\n+        Hooks.resetOnNextDropped();\n+        Hooks.resetOnErrorDropped();\n+        Hooks.resetOnNextError();\n+        Hooks.resetOnOperatorError();\n+    }\n+\n+    @Test\n+    public void ensureMultipleSubscribersSupportWithNoLeaksWhenRacingCancelAndOnNextAndRequest() {\n+        Hooks.onNextDropped(Tracked::safeRelease);\n+        Hooks.onErrorDropped(e -> {});\n+        Hooks.onOperatorError((e,v) -> null);\n+        int subscriptionsNumber = subscriptionsNumber();\n+        Scheduler scheduler = Schedulers.newParallel(\"testScheduler\", subscriptionsNumber + 1);\n+        scheduler.start();\n+        for (int i = 0; i < 10000; i++) {\n+            int[] index = new int[] {subscriptionsNumber};\n+            TestPublisher<Tracked<?>>[] testPublishers = new TestPublisher[subscriptionsNumber];\n+\n+            for (int i1 = 0; i1 < subscriptionsNumber; i1++) {\n+                testPublishers[i1] = TestPublisher.createNoncompliant(TestPublisher.Violation.DEFER_CANCELLATION, TestPublisher.Violation.REQUEST_OVERFLOW);\n+            }\n+\n+            Publisher<Tracked<?>> source = transform(testPublishers[0], Arrays.copyOfRange(testPublishers, 1, testPublishers.length));\n+\n+            if (conditional) {\n+                if (source instanceof Flux) {\n+                    source = ((Flux<Tracked<?>>)source).filter(t -> true);\n+                } else {\n+                    source = ((Mono<Tracked<?>>)source).filter(t -> true);\n+                }\n+            }\n+\n+            AssertSubscriber<Tracked<?>> assertSubscriber = new AssertSubscriber<>(Operators.enableOnDiscard(null, Tracked::safeRelease), 0);\n+            if (fused) {\n+                assertSubscriber.requestedFusionMode(Fuseable.ANY);\n+            }\n+            source.subscribe(assertSubscriber);\n+\n+            if (subscriptionsNumber == 1) {\n+                Tracked<Integer> value = new Tracked<>(1);\n+                RaceTestUtils.race(() -> RaceTestUtils.race(assertSubscriber::cancel, () -> assertSubscriber.request(Long.MAX_VALUE), scheduler), () -> testPublishers[0].next(value), scheduler);\n+            } else {\n+                int startIndex = --index[0];\n+                Tracked<Integer> value1 = new Tracked<>(startIndex);\n+                int secondIndex = --index[0];\n+                Tracked<Integer> value2 = new Tracked<>(secondIndex);\n+                Runnable action = () -> RaceTestUtils.race(() -> testPublishers[startIndex].next(value1), () -> testPublishers[secondIndex].next(value2), scheduler);\n+\n+                while (index[0] > 0) {\n+                    int nextIndex = --index[0];\n+                    Tracked<Integer> nextValue = new Tracked<>(nextIndex);\n+                    Runnable nextAction = action;\n+                    action = () -> RaceTestUtils.race(nextAction, () -> testPublishers[nextIndex].next(nextValue), scheduler);\n+                }\n+                RaceTestUtils.race(() -> RaceTestUtils.race(assertSubscriber::cancel, () -> assertSubscriber.request(Long.MAX_VALUE), scheduler), action, scheduler);\n+            }\n+\n+            List<Tracked<?>> values = assertSubscriber.values();\n+            values.forEach(Tracked::release);\n+\n+            Tracked.assertNoLeaks();\n+        }\n+        scheduler.dispose();\n+    }\n+\n+    @Test\n+    public void ensureNoLeaksPopulatedQueueAndRacingCancelAndOnNext() {\n+        Assumptions.assumeThat(subscriptionsNumber())\n+                .isOne();\n+        Hooks.onNextDropped(Tracked::safeRelease);\n+        Hooks.onErrorDropped(e -> {});\n+        Hooks.onOperatorError((e,v) -> null);\n+        Scheduler scheduler = Schedulers.newParallel(\"testScheduler\", subscriptionsNumber() + 1);\n+        scheduler.start();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e71d24ed008b177d3da03600fad3fa3e1a698e4b"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjA4NDQ3OA==", "bodyText": "Moved to a common field which setups @Before each test and dispose in the @After method", "url": "https://github.com/reactor/reactor-core/pull/2125#discussion_r412084478", "createdAt": "2020-04-21T10:58:42Z", "author": {"login": "OlegDokuka"}, "path": "reactor-core/src/test/java/reactor/core/publisher/AbstractOnDiscardShouldNotLeakTest.java", "diffHunk": "@@ -0,0 +1,443 @@\n+package reactor.core.publisher;\n+\n+import org.assertj.core.api.Assertions;\n+import org.assertj.core.api.Assumptions;\n+import org.junit.After;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.reactivestreams.Publisher;\n+import reactor.core.Fuseable;\n+import reactor.core.Scannable;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+import reactor.test.publisher.TestPublisher;\n+import reactor.test.subscriber.AssertSubscriber;\n+import reactor.test.util.RaceTestUtils;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+@RunWith(Parameterized.class)\n+public abstract class AbstractOnDiscardShouldNotLeakTest {\n+\n+    @Parameterized.Parameters\n+    public static Collection<Boolean[]> data() {\n+        return Arrays.asList(new Boolean[][] {\n+            { false, false },\n+            { true, false },\n+            { false, true },\n+            { true, true }\n+        });\n+    }\n+\n+    private final boolean conditional;\n+    private final boolean fused;\n+\n+    public AbstractOnDiscardShouldNotLeakTest(boolean conditional, boolean fused) {\n+        this.conditional = conditional;\n+        this.fused = fused;\n+    }\n+\n+    protected abstract Publisher<Tracked<?>> transform(TestPublisher<Tracked<?>> main, TestPublisher<Tracked<?>>... additional);\n+\n+    int subscriptionsNumber() {\n+        return 1;\n+    }\n+\n+    @After\n+    public void tearDown() {\n+        Hooks.resetOnNextDropped();\n+        Hooks.resetOnErrorDropped();\n+        Hooks.resetOnNextError();\n+        Hooks.resetOnOperatorError();\n+    }\n+\n+    @Test\n+    public void ensureMultipleSubscribersSupportWithNoLeaksWhenRacingCancelAndOnNextAndRequest() {\n+        Hooks.onNextDropped(Tracked::safeRelease);\n+        Hooks.onErrorDropped(e -> {});\n+        Hooks.onOperatorError((e,v) -> null);\n+        int subscriptionsNumber = subscriptionsNumber();\n+        Scheduler scheduler = Schedulers.newParallel(\"testScheduler\", subscriptionsNumber + 1);\n+        scheduler.start();\n+        for (int i = 0; i < 10000; i++) {\n+            int[] index = new int[] {subscriptionsNumber};\n+            TestPublisher<Tracked<?>>[] testPublishers = new TestPublisher[subscriptionsNumber];\n+\n+            for (int i1 = 0; i1 < subscriptionsNumber; i1++) {\n+                testPublishers[i1] = TestPublisher.createNoncompliant(TestPublisher.Violation.DEFER_CANCELLATION, TestPublisher.Violation.REQUEST_OVERFLOW);\n+            }\n+\n+            Publisher<Tracked<?>> source = transform(testPublishers[0], Arrays.copyOfRange(testPublishers, 1, testPublishers.length));\n+\n+            if (conditional) {\n+                if (source instanceof Flux) {\n+                    source = ((Flux<Tracked<?>>)source).filter(t -> true);\n+                } else {\n+                    source = ((Mono<Tracked<?>>)source).filter(t -> true);\n+                }\n+            }\n+\n+            AssertSubscriber<Tracked<?>> assertSubscriber = new AssertSubscriber<>(Operators.enableOnDiscard(null, Tracked::safeRelease), 0);\n+            if (fused) {\n+                assertSubscriber.requestedFusionMode(Fuseable.ANY);\n+            }\n+            source.subscribe(assertSubscriber);\n+\n+            if (subscriptionsNumber == 1) {\n+                Tracked<Integer> value = new Tracked<>(1);\n+                RaceTestUtils.race(() -> RaceTestUtils.race(assertSubscriber::cancel, () -> assertSubscriber.request(Long.MAX_VALUE), scheduler), () -> testPublishers[0].next(value), scheduler);\n+            } else {\n+                int startIndex = --index[0];\n+                Tracked<Integer> value1 = new Tracked<>(startIndex);\n+                int secondIndex = --index[0];\n+                Tracked<Integer> value2 = new Tracked<>(secondIndex);\n+                Runnable action = () -> RaceTestUtils.race(() -> testPublishers[startIndex].next(value1), () -> testPublishers[secondIndex].next(value2), scheduler);\n+\n+                while (index[0] > 0) {\n+                    int nextIndex = --index[0];\n+                    Tracked<Integer> nextValue = new Tracked<>(nextIndex);\n+                    Runnable nextAction = action;\n+                    action = () -> RaceTestUtils.race(nextAction, () -> testPublishers[nextIndex].next(nextValue), scheduler);\n+                }\n+                RaceTestUtils.race(() -> RaceTestUtils.race(assertSubscriber::cancel, () -> assertSubscriber.request(Long.MAX_VALUE), scheduler), action, scheduler);\n+            }\n+\n+            List<Tracked<?>> values = assertSubscriber.values();\n+            values.forEach(Tracked::release);\n+\n+            Tracked.assertNoLeaks();\n+        }\n+        scheduler.dispose();\n+    }\n+\n+    @Test\n+    public void ensureNoLeaksPopulatedQueueAndRacingCancelAndOnNext() {\n+        Assumptions.assumeThat(subscriptionsNumber())\n+                .isOne();\n+        Hooks.onNextDropped(Tracked::safeRelease);\n+        Hooks.onErrorDropped(e -> {});\n+        Hooks.onOperatorError((e,v) -> null);\n+        Scheduler scheduler = Schedulers.newParallel(\"testScheduler\", subscriptionsNumber() + 1);\n+        scheduler.start();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjA3OTU1Mg=="}, "originalCommit": {"oid": "e71d24ed008b177d3da03600fad3fa3e1a698e4b"}, "originalPosition": 127}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MDQwMTc4OnYy", "diffSide": "RIGHT", "path": "reactor-core/src/test/java/reactor/core/publisher/SerializedSubscriberTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMDo1MjoxM1rOGI_Zaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMDo1ODowNlrOGI_nkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjA4MDQ5MQ==", "bodyText": "why not just changing the latch to new CountDownLatch(4) and output the current value if await fails?", "url": "https://github.com/reactor/reactor-core/pull/2125#discussion_r412080491", "createdAt": "2020-04-21T10:52:13Z", "author": {"login": "bsideup"}, "path": "reactor-core/src/test/java/reactor/core/publisher/SerializedSubscriberTest.java", "diffHunk": "@@ -90,6 +90,9 @@ public void testLeakWithRetryWhenImmediatelyCancelled() throws InterruptedExcept\n \t\tAtomicInteger seen = new AtomicInteger();\n \n \t\tfinal CountDownLatch latch = new CountDownLatch(1);\n+\t\tfinal CountDownLatch latch1 = new CountDownLatch(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e71d24ed008b177d3da03600fad3fa3e1a698e4b"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjA4NDExNQ==", "bodyText": "yeah. fixed", "url": "https://github.com/reactor/reactor-core/pull/2125#discussion_r412084115", "createdAt": "2020-04-21T10:58:06Z", "author": {"login": "OlegDokuka"}, "path": "reactor-core/src/test/java/reactor/core/publisher/SerializedSubscriberTest.java", "diffHunk": "@@ -90,6 +90,9 @@ public void testLeakWithRetryWhenImmediatelyCancelled() throws InterruptedExcept\n \t\tAtomicInteger seen = new AtomicInteger();\n \n \t\tfinal CountDownLatch latch = new CountDownLatch(1);\n+\t\tfinal CountDownLatch latch1 = new CountDownLatch(1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjA4MDQ5MQ=="}, "originalCommit": {"oid": "e71d24ed008b177d3da03600fad3fa3e1a698e4b"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MDQwNTkyOnYy", "diffSide": "RIGHT", "path": "reactor-core/src/test/java/reactor/core/publisher/FluxFlatMapIterableOnDiscardShouldNotLeakTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMDo1MzoxNVrOGI_b6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMTowNTo1OFrOGI_58A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjA4MTEzMQ==", "bodyText": "nit: looking at other similar tests, we could introduce AbstractFluxOnDiscardShouldNotLeakTest that defines transform(Flux, Flux)", "url": "https://github.com/reactor/reactor-core/pull/2125#discussion_r412081131", "createdAt": "2020-04-21T10:53:15Z", "author": {"login": "bsideup"}, "path": "reactor-core/src/test/java/reactor/core/publisher/FluxFlatMapIterableOnDiscardShouldNotLeakTest.java", "diffHunk": "@@ -0,0 +1,20 @@\n+package reactor.core.publisher;\n+\n+import org.reactivestreams.Publisher;\n+import reactor.test.publisher.TestPublisher;\n+\n+import java.util.Arrays;\n+\n+public class FluxFlatMapIterableOnDiscardShouldNotLeakTest extends AbstractOnDiscardShouldNotLeakTest {\n+\n+    public FluxFlatMapIterableOnDiscardShouldNotLeakTest(boolean conditional, boolean fused) {\n+        super(conditional, fused);\n+    }\n+\n+    @Override\n+    protected Publisher<Tracked<?>> transform(TestPublisher<Tracked<?>> main, TestPublisher<Tracked<?>>... additional) {\n+        return main", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e71d24ed008b177d3da03600fad3fa3e1a698e4b"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjA4NDg0NQ==", "bodyText": "Makes sense to do", "url": "https://github.com/reactor/reactor-core/pull/2125#discussion_r412084845", "createdAt": "2020-04-21T10:59:18Z", "author": {"login": "OlegDokuka"}, "path": "reactor-core/src/test/java/reactor/core/publisher/FluxFlatMapIterableOnDiscardShouldNotLeakTest.java", "diffHunk": "@@ -0,0 +1,20 @@\n+package reactor.core.publisher;\n+\n+import org.reactivestreams.Publisher;\n+import reactor.test.publisher.TestPublisher;\n+\n+import java.util.Arrays;\n+\n+public class FluxFlatMapIterableOnDiscardShouldNotLeakTest extends AbstractOnDiscardShouldNotLeakTest {\n+\n+    public FluxFlatMapIterableOnDiscardShouldNotLeakTest(boolean conditional, boolean fused) {\n+        super(conditional, fused);\n+    }\n+\n+    @Override\n+    protected Publisher<Tracked<?>> transform(TestPublisher<Tracked<?>> main, TestPublisher<Tracked<?>>... additional) {\n+        return main", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjA4MTEzMQ=="}, "originalCommit": {"oid": "e71d24ed008b177d3da03600fad3fa3e1a698e4b"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjA4ODgxNg==", "bodyText": "fixed", "url": "https://github.com/reactor/reactor-core/pull/2125#discussion_r412088816", "createdAt": "2020-04-21T11:05:58Z", "author": {"login": "OlegDokuka"}, "path": "reactor-core/src/test/java/reactor/core/publisher/FluxFlatMapIterableOnDiscardShouldNotLeakTest.java", "diffHunk": "@@ -0,0 +1,20 @@\n+package reactor.core.publisher;\n+\n+import org.reactivestreams.Publisher;\n+import reactor.test.publisher.TestPublisher;\n+\n+import java.util.Arrays;\n+\n+public class FluxFlatMapIterableOnDiscardShouldNotLeakTest extends AbstractOnDiscardShouldNotLeakTest {\n+\n+    public FluxFlatMapIterableOnDiscardShouldNotLeakTest(boolean conditional, boolean fused) {\n+        super(conditional, fused);\n+    }\n+\n+    @Override\n+    protected Publisher<Tracked<?>> transform(TestPublisher<Tracked<?>> main, TestPublisher<Tracked<?>>... additional) {\n+        return main", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjA4MTEzMQ=="}, "originalCommit": {"oid": "e71d24ed008b177d3da03600fad3fa3e1a698e4b"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MDQxMTkxOnYy", "diffSide": "RIGHT", "path": "reactor-core/src/test/java/reactor/core/publisher/AbstractOnDiscardShouldNotLeakTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMDo1NDo0MVrOGI_fYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMTowMDoxM1rOGI_spw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjA4MjAxNw==", "bodyText": "Have you considered adding this to BaseOperatorTest instead?", "url": "https://github.com/reactor/reactor-core/pull/2125#discussion_r412082017", "createdAt": "2020-04-21T10:54:41Z", "author": {"login": "bsideup"}, "path": "reactor-core/src/test/java/reactor/core/publisher/AbstractOnDiscardShouldNotLeakTest.java", "diffHunk": "@@ -0,0 +1,443 @@\n+package reactor.core.publisher;\n+\n+import org.assertj.core.api.Assertions;\n+import org.assertj.core.api.Assumptions;\n+import org.junit.After;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.reactivestreams.Publisher;\n+import reactor.core.Fuseable;\n+import reactor.core.Scannable;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+import reactor.test.publisher.TestPublisher;\n+import reactor.test.subscriber.AssertSubscriber;\n+import reactor.test.util.RaceTestUtils;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+@RunWith(Parameterized.class)\n+public abstract class AbstractOnDiscardShouldNotLeakTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e71d24ed008b177d3da03600fad3fa3e1a698e4b"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjA4NTQxNQ==", "bodyText": "Yeah. I don't know how to use it properly, thus created an abstract class for simplicity at the first stage, but ready to optimize and make it extending BaseOperatorTest", "url": "https://github.com/reactor/reactor-core/pull/2125#discussion_r412085415", "createdAt": "2020-04-21T11:00:13Z", "author": {"login": "OlegDokuka"}, "path": "reactor-core/src/test/java/reactor/core/publisher/AbstractOnDiscardShouldNotLeakTest.java", "diffHunk": "@@ -0,0 +1,443 @@\n+package reactor.core.publisher;\n+\n+import org.assertj.core.api.Assertions;\n+import org.assertj.core.api.Assumptions;\n+import org.junit.After;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.reactivestreams.Publisher;\n+import reactor.core.Fuseable;\n+import reactor.core.Scannable;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+import reactor.test.publisher.TestPublisher;\n+import reactor.test.subscriber.AssertSubscriber;\n+import reactor.test.util.RaceTestUtils;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+@RunWith(Parameterized.class)\n+public abstract class AbstractOnDiscardShouldNotLeakTest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjA4MjAxNw=="}, "originalCommit": {"oid": "e71d24ed008b177d3da03600fad3fa3e1a698e4b"}, "originalPosition": 26}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1035, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}