{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM4NTkyMDc4", "number": 2216, "title": "Fix #2196: don't hang on repeatWhenEmpty + discard handler", "bodyText": "", "createdAt": "2020-06-23T14:00:57Z", "url": "https://github.com/reactor/reactor-core/pull/2216", "merged": true, "mergeCommit": {"oid": "f6a5f5b920aec6a55b7887e252feb5aa112e4392"}, "closed": true, "closedAt": "2020-06-23T15:36:34Z", "author": {"login": "ericbottard"}, "timelineItems": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcuGAGIAFqTQzNTgxODQzOA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcuHzTLAFqTQzNTk0MDA4OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM1ODE4NDM4", "url": "https://github.com/reactor/reactor-core/pull/2216#pullrequestreview-435818438", "createdAt": "2020-06-23T14:06:08Z", "commit": {"oid": "5de0247ab0ed97bd32ac04f676a3b674cd484814"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f6a5f5b920aec6a55b7887e252feb5aa112e4392", "author": {"user": {"login": "ericbottard", "name": "Eric Bottard"}}, "url": "https://github.com/reactor/reactor-core/commit/f6a5f5b920aec6a55b7887e252feb5aa112e4392", "committedDate": "2020-06-23T15:35:12Z", "message": "Fix #2196: don't hang on repeatWhenEmpty + discard handler"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5de0247ab0ed97bd32ac04f676a3b674cd484814", "author": {"user": {"login": "ericbottard", "name": "Eric Bottard"}}, "url": "https://github.com/reactor/reactor-core/commit/5de0247ab0ed97bd32ac04f676a3b674cd484814", "committedDate": "2020-06-23T13:32:38Z", "message": "Fix #2196: don't hang on repeatWhenEmpty + discard handler"}, "afterCommit": {"oid": "f6a5f5b920aec6a55b7887e252feb5aa112e4392", "author": {"user": {"login": "ericbottard", "name": "Eric Bottard"}}, "url": "https://github.com/reactor/reactor-core/commit/f6a5f5b920aec6a55b7887e252feb5aa112e4392", "committedDate": "2020-06-23T15:35:12Z", "message": "Fix #2196: don't hang on repeatWhenEmpty + discard handler"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM1OTQwMDg4", "url": "https://github.com/reactor/reactor-core/pull/2216#pullrequestreview-435940088", "createdAt": "2020-06-23T16:11:57Z", "commit": {"oid": "f6a5f5b920aec6a55b7887e252feb5aa112e4392"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxNjoxMTo1N1rOGnwkGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxNjoxMTo1N1rOGnwkGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDM0MzMyMA==", "bodyText": "@ericbottard  @simonbasle\nisn't it better to use Flux.error(Supplier) version?\nas it always creates Exception which captures stacktrace ?", "url": "https://github.com/reactor/reactor-core/pull/2216#discussion_r444343320", "createdAt": "2020-06-23T16:11:57Z", "author": {"login": "robotmrv"}, "path": "reactor-core/src/main/java/reactor/core/publisher/Mono.java", "diffHunk": "@@ -3416,23 +3417,16 @@ public T block(Duration timeout) {\n \t * as long as the companion {@link Publisher} produces an onNext signal and the maximum number of repeats isn't exceeded.\n \t */\n \tpublic final Mono<T> repeatWhenEmpty(int maxRepeat, Function<Flux<Long>, ? extends Publisher<?>> repeatFactory) {\n-\t\treturn Mono.defer(() -> {\n-\t\t\tFlux<Long> iterations;\n-\n-\t\t\tif(maxRepeat == Integer.MAX_VALUE) {\n-\t\t\t\titerations = Flux.fromStream(LongStream.range(0, Long.MAX_VALUE).boxed());\n+\t\treturn Mono.defer(() -> this.repeatWhen(o -> {\n+\t\t\tif (maxRepeat == Integer.MAX_VALUE) {\n+\t\t\t\treturn repeatFactory.apply(o.index().map(Tuple2::getT1));\n \t\t\t}\n \t\t\telse {\n-\t\t\t\titerations = Flux\n-\t\t\t\t\t.range(0, maxRepeat)\n-\t\t\t\t\t.map(Integer::longValue)\n-\t\t\t\t\t.concatWith(Flux.error(new IllegalStateException(\"Exceeded maximum number of repeats\"), true));\n+\t\t\t\treturn repeatFactory.apply(o.index().map(Tuple2::getT1)\n+\t\t\t\t\t\t.take(maxRepeat)\n+\t\t\t\t\t\t.concatWith(Flux.error(new IllegalStateException(\"Exceeded maximum number of repeats\"), true)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f6a5f5b920aec6a55b7887e252feb5aa112e4392"}, "originalPosition": 58}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2745, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}