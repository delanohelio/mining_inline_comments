{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE0OTIxNjQ0", "number": 2475, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwODozODo0OVrOE1HxVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwODo0ODo1MVrOE1H_fw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MTM3MzAwOnYy", "diffSide": "RIGHT", "path": "reactor-core/src/main/java/reactor/core/publisher/Flux.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwODozODo0OVrOHtN5Fw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwODozODo0OVrOHtN5Fw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE3NTU3NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * The {@link Timed} object instances are safe to store and used later, as they are created as an\n          \n          \n            \n            \t * immutable wrapper around the {@code <T>} value and immediately passed to the downstream.\n          \n          \n            \n            \t * The {@link Timed} object instances are safe to store and use later, as they are created as an\n          \n          \n            \n            \t * immutable wrapper around the {@code <T>} value and immediately passed downstream.", "url": "https://github.com/reactor/reactor-core/pull/2475#discussion_r517175575", "createdAt": "2020-11-04T08:38:49Z", "author": {"login": "ericbottard"}, "path": "reactor-core/src/main/java/reactor/core/publisher/Flux.java", "diffHunk": "@@ -8676,6 +8680,60 @@ public final void subscribe(Subscriber<? super T> actual) {\n \t\treturn concat;\n \t}\n \n+\t/**\n+\t * Times {@link Subscriber#onNext(Object)} events, encapsulated into a {@link Timed} object\n+\t * that lets downstream consumer look at various time information gathered with nanosecond\n+\t * resolution using the default clock ({@link Schedulers#parallel()}):\n+\t * <ul>\n+\t *     <li>{@link Timed#elapsed()}: the time in nanoseconds since last event, as a {@link Duration}.\n+\t *     For the first onNext, \"last event\" is the subscription. Otherwise it is the previous onNext.\n+\t *     This is functionally equivalent to {@link #elapsed()}, with a more expressive representation\n+\t *     than a {@link Tuple2} with a long.</li>\n+\t *     <li>{@link Timed#timestamp()}: the timestamp of this onNext, as an {@link java.time.Instant}\n+\t *     (with nanoseconds part). This is functionally equivalent to {@link #timestamp()}, with a more\n+\t *     expressive representation than a {@link Tuple2} with a long.</li>\n+\t *     <li>{@link Timed#elapsedSinceSubscription()}: the time in nanoseconds since subscription,\n+\t *     as a {@link Duration}.</li>\n+\t * </ul>\n+\t * <p>\n+\t * The {@link Timed} object instances are safe to store and used later, as they are created as an\n+\t * immutable wrapper around the {@code <T>} value and immediately passed to the downstream.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76a5be567c24fa60d1ab7bdb5780c4c47db04ecf"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MTM3NDE1OnYy", "diffSide": "RIGHT", "path": "reactor-core/src/main/java/reactor/core/publisher/Flux.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwODozOToxNFrOHtN50w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwODozOToxNFrOHtN50w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE3NTc2Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * The {@link Timed} object instances are safe to store and used later, as they are created as an\n          \n          \n            \n            \t * immutable wrapper around the {@code <T>} value and immediately passed to the downstream.\n          \n          \n            \n            \t * The {@link Timed} object instances are safe to store and use later, as they are created as an\n          \n          \n            \n            \t * immutable wrapper around the {@code <T>} value and immediately passed downstream.", "url": "https://github.com/reactor/reactor-core/pull/2475#discussion_r517175763", "createdAt": "2020-11-04T08:39:14Z", "author": {"login": "ericbottard"}, "path": "reactor-core/src/main/java/reactor/core/publisher/Flux.java", "diffHunk": "@@ -8676,6 +8680,60 @@ public final void subscribe(Subscriber<? super T> actual) {\n \t\treturn concat;\n \t}\n \n+\t/**\n+\t * Times {@link Subscriber#onNext(Object)} events, encapsulated into a {@link Timed} object\n+\t * that lets downstream consumer look at various time information gathered with nanosecond\n+\t * resolution using the default clock ({@link Schedulers#parallel()}):\n+\t * <ul>\n+\t *     <li>{@link Timed#elapsed()}: the time in nanoseconds since last event, as a {@link Duration}.\n+\t *     For the first onNext, \"last event\" is the subscription. Otherwise it is the previous onNext.\n+\t *     This is functionally equivalent to {@link #elapsed()}, with a more expressive representation\n+\t *     than a {@link Tuple2} with a long.</li>\n+\t *     <li>{@link Timed#timestamp()}: the timestamp of this onNext, as an {@link java.time.Instant}\n+\t *     (with nanoseconds part). This is functionally equivalent to {@link #timestamp()}, with a more\n+\t *     expressive representation than a {@link Tuple2} with a long.</li>\n+\t *     <li>{@link Timed#elapsedSinceSubscription()}: the time in nanoseconds since subscription,\n+\t *     as a {@link Duration}.</li>\n+\t * </ul>\n+\t * <p>\n+\t * The {@link Timed} object instances are safe to store and used later, as they are created as an\n+\t * immutable wrapper around the {@code <T>} value and immediately passed to the downstream.\n+\t *\n+\t * @return a timed {@link Flux}\n+\t * @see #elapsed()\n+\t * @see #timestamp()\n+\t */\n+\tpublic final Flux<Timed<T>> timed() {\n+\t\treturn this.timed(Schedulers.parallel());\n+\t}\n+\n+\t/**\n+\t * Times {@link Subscriber#onNext(Object)} events, encapsulated into a {@link Timed} object\n+\t * that lets downstream consumer look at various time information gathered with nanosecond\n+\t * resolution using the provided {@link Scheduler} as a clock:\n+\t * <ul>\n+\t *     <li>{@link Timed#elapsed()}: the time in nanoseconds since last event, as a {@link Duration}.\n+\t *     For the first onNext, \"last event\" is the subscription. Otherwise it is the previous onNext.\n+\t *     This is functionally equivalent to {@link #elapsed()}, with a more expressive representation\n+\t *     than a {@link Tuple2} with a long.</li>\n+\t *     <li>{@link Timed#timestamp()}: the timestamp of this onNext, as an {@link java.time.Instant}\n+\t *     (with nanoseconds part). This is functionally equivalent to {@link #timestamp()}, with a more\n+\t *     expressive representation than a {@link Tuple2} with a long.</li>\n+\t *     <li>{@link Timed#elapsedSinceSubscription()}: the time in nanoseconds since subscription,\n+\t *     as a {@link Duration}.</li>\n+\t * </ul>\n+\t * <p>\n+\t * The {@link Timed} object instances are safe to store and used later, as they are created as an\n+\t * immutable wrapper around the {@code <T>} value and immediately passed to the downstream.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76a5be567c24fa60d1ab7bdb5780c4c47db04ecf"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MTM3OTAwOnYy", "diffSide": "RIGHT", "path": "reactor-core/src/main/java/reactor/core/publisher/FluxTimed.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwODo0MDoyMlrOHtN8qA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNDozMTozM1rOHtas7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE3NjQ4OA==", "bodyText": "Don't forget this", "url": "https://github.com/reactor/reactor-core/pull/2475#discussion_r517176488", "createdAt": "2020-11-04T08:40:22Z", "author": {"login": "ericbottard"}, "path": "reactor-core/src/main/java/reactor/core/publisher/FluxTimed.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.reactivestreams.Subscription;\n+\n+import reactor.core.CoreSubscriber;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.util.annotation.Nullable;\n+\n+/**\n+ * @author Simon Basl\u00e9\n+ */\n+final class FluxTimed<T> extends InternalFluxOperator<T, Timed<T>> {\n+\n+\tfinal Scheduler clock;\n+\n+\tFluxTimed(Flux<? extends T> source, Scheduler clock) {\n+\t\tsuper(source);\n+\t\tthis.clock = clock;\n+\t}\n+\n+\t@Override\n+\tpublic CoreSubscriber<? super T> subscribeOrReturn(CoreSubscriber<? super Timed<T>> actual) {\n+\t\treturn new TimedSubscriber<>(actual, this.clock);\n+\t}\n+\n+\t@Nullable\n+\t@Override\n+\tpublic Object scanUnsafe(Attr key) {\n+\t\t//FIXME", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76a5be567c24fa60d1ab7bdb5780c4c47db04ecf"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzI4NTI0NQ==", "bodyText": "yes, this is a draft", "url": "https://github.com/reactor/reactor-core/pull/2475#discussion_r517285245", "createdAt": "2020-11-04T11:43:18Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/FluxTimed.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.reactivestreams.Subscription;\n+\n+import reactor.core.CoreSubscriber;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.util.annotation.Nullable;\n+\n+/**\n+ * @author Simon Basl\u00e9\n+ */\n+final class FluxTimed<T> extends InternalFluxOperator<T, Timed<T>> {\n+\n+\tfinal Scheduler clock;\n+\n+\tFluxTimed(Flux<? extends T> source, Scheduler clock) {\n+\t\tsuper(source);\n+\t\tthis.clock = clock;\n+\t}\n+\n+\t@Override\n+\tpublic CoreSubscriber<? super T> subscribeOrReturn(CoreSubscriber<? super Timed<T>> actual) {\n+\t\treturn new TimedSubscriber<>(actual, this.clock);\n+\t}\n+\n+\t@Nullable\n+\t@Override\n+\tpublic Object scanUnsafe(Attr key) {\n+\t\t//FIXME", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE3NjQ4OA=="}, "originalCommit": {"oid": "76a5be567c24fa60d1ab7bdb5780c4c47db04ecf"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM4NTQ1NQ==", "bodyText": "done", "url": "https://github.com/reactor/reactor-core/pull/2475#discussion_r517385455", "createdAt": "2020-11-04T14:31:33Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/FluxTimed.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.reactivestreams.Subscription;\n+\n+import reactor.core.CoreSubscriber;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.util.annotation.Nullable;\n+\n+/**\n+ * @author Simon Basl\u00e9\n+ */\n+final class FluxTimed<T> extends InternalFluxOperator<T, Timed<T>> {\n+\n+\tfinal Scheduler clock;\n+\n+\tFluxTimed(Flux<? extends T> source, Scheduler clock) {\n+\t\tsuper(source);\n+\t\tthis.clock = clock;\n+\t}\n+\n+\t@Override\n+\tpublic CoreSubscriber<? super T> subscribeOrReturn(CoreSubscriber<? super Timed<T>> actual) {\n+\t\treturn new TimedSubscriber<>(actual, this.clock);\n+\t}\n+\n+\t@Nullable\n+\t@Override\n+\tpublic Object scanUnsafe(Attr key) {\n+\t\t//FIXME", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE3NjQ4OA=="}, "originalCommit": {"oid": "76a5be567c24fa60d1ab7bdb5780c4c47db04ecf"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MTM4OTkxOnYy", "diffSide": "RIGHT", "path": "reactor-core/src/main/java/reactor/core/publisher/FluxTimed.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwODo0MzozMVrOHtODYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNDozMDo1NFrOHtarBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE3ODIxMA==", "bodyText": "Don't forget this TODO either", "url": "https://github.com/reactor/reactor-core/pull/2475#discussion_r517178210", "createdAt": "2020-11-04T08:43:31Z", "author": {"login": "ericbottard"}, "path": "reactor-core/src/main/java/reactor/core/publisher/FluxTimed.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.reactivestreams.Subscription;\n+\n+import reactor.core.CoreSubscriber;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.util.annotation.Nullable;\n+\n+/**\n+ * @author Simon Basl\u00e9\n+ */\n+final class FluxTimed<T> extends InternalFluxOperator<T, Timed<T>> {\n+\n+\tfinal Scheduler clock;\n+\n+\tFluxTimed(Flux<? extends T> source, Scheduler clock) {\n+\t\tsuper(source);\n+\t\tthis.clock = clock;\n+\t}\n+\n+\t@Override\n+\tpublic CoreSubscriber<? super T> subscribeOrReturn(CoreSubscriber<? super Timed<T>> actual) {\n+\t\treturn new TimedSubscriber<>(actual, this.clock);\n+\t}\n+\n+\t@Nullable\n+\t@Override\n+\tpublic Object scanUnsafe(Attr key) {\n+\t\t//FIXME\n+\t\treturn super.scanUnsafe(key);\n+\t}\n+\n+\t/**\n+\t * Immutable version of {@link Timed}. This is preferable to the subscriber implementing\n+\t * Timed interface, as timestamps are likely to be collected for later use (so flyweight\n+\t * would get in the way).\n+\t *\n+\t * @param <T>\n+\t */\n+\tstatic final class ImmutableTimed<T> implements Timed<T> {\n+\n+\t\tfinal long eventElapsedSinceSubscriptionNanos;\n+\t\tfinal long eventElapsedNanos;\n+\t\tfinal long eventTimestampEpochMillis;\n+\t\tfinal T    event;\n+\n+\t\tImmutableTimed(long eventElapsedSinceSubscriptionNanos,\n+\t\t\t\tlong eventElapsedNanos,\n+\t\t\t\tlong eventTimestampEpochMillis,\n+\t\t\t\tT event) {\n+\t\t\tthis.eventElapsedSinceSubscriptionNanos = eventElapsedSinceSubscriptionNanos;\n+\t\t\tthis.eventElapsedNanos = eventElapsedNanos;\n+\t\t\tthis.eventTimestampEpochMillis = eventTimestampEpochMillis;\n+\t\t\tthis.event = event;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic T get() {\n+\t\t\treturn this.event;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Duration elapsed() {\n+\t\t\treturn Duration.ofNanos(eventElapsedNanos);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Duration elapsedSinceSubscription() {\n+\t\t\treturn Duration.ofNanos(eventElapsedSinceSubscriptionNanos);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Instant timestamp() {\n+\t\t\treturn Instant.ofEpochMilli(eventTimestampEpochMillis);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String toString() {\n+\t\t\treturn \"Timed(\" + event + \"){eventElapsedNanos=\" + eventElapsedNanos + \", eventElapsedSinceSubscriptionNanos=\" + eventElapsedSinceSubscriptionNanos + \",  eventTimestampEpochMillis=\" + eventTimestampEpochMillis + '}';\n+\t\t}\n+\t}\n+\n+\tstatic final class TimedSubscriber<T> implements InnerOperator<T, Timed<T>> {\n+\n+\t\tfinal CoreSubscriber<? super Timed<T>> actual;\n+\t\tfinal Scheduler clock;\n+\n+\t\tlong subscriptionNanos;\n+\t\tlong lastEventNanos;\n+\n+\t\tSubscription s;\n+\n+\t\tTimedSubscriber(CoreSubscriber<? super Timed<T>> actual, Scheduler clock) {\n+\t\t\tthis.actual = actual;\n+\t\t\tthis.clock = clock;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic CoreSubscriber<? super Timed<T>> actual() {\n+\t\t\treturn this.actual;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void onSubscribe(Subscription s) {\n+\t\t\tif (Operators.validate(this.s, s)) {\n+\t\t\t\tthis.s = s;\n+\n+\t\t\t\tthis.subscriptionNanos = clock.now(TimeUnit.NANOSECONDS);\n+\t\t\t\tthis.lastEventNanos = subscriptionNanos;\n+\n+\t\t\t\tactual.onSubscribe(this);\n+\t\t\t}\n+\t\t}\n+\n+\t\t//TODO protect against malformed publishers", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76a5be567c24fa60d1ab7bdb5780c4c47db04ecf"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM4NDk2Ng==", "bodyText": "done", "url": "https://github.com/reactor/reactor-core/pull/2475#discussion_r517384966", "createdAt": "2020-11-04T14:30:54Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/FluxTimed.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.reactivestreams.Subscription;\n+\n+import reactor.core.CoreSubscriber;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.util.annotation.Nullable;\n+\n+/**\n+ * @author Simon Basl\u00e9\n+ */\n+final class FluxTimed<T> extends InternalFluxOperator<T, Timed<T>> {\n+\n+\tfinal Scheduler clock;\n+\n+\tFluxTimed(Flux<? extends T> source, Scheduler clock) {\n+\t\tsuper(source);\n+\t\tthis.clock = clock;\n+\t}\n+\n+\t@Override\n+\tpublic CoreSubscriber<? super T> subscribeOrReturn(CoreSubscriber<? super Timed<T>> actual) {\n+\t\treturn new TimedSubscriber<>(actual, this.clock);\n+\t}\n+\n+\t@Nullable\n+\t@Override\n+\tpublic Object scanUnsafe(Attr key) {\n+\t\t//FIXME\n+\t\treturn super.scanUnsafe(key);\n+\t}\n+\n+\t/**\n+\t * Immutable version of {@link Timed}. This is preferable to the subscriber implementing\n+\t * Timed interface, as timestamps are likely to be collected for later use (so flyweight\n+\t * would get in the way).\n+\t *\n+\t * @param <T>\n+\t */\n+\tstatic final class ImmutableTimed<T> implements Timed<T> {\n+\n+\t\tfinal long eventElapsedSinceSubscriptionNanos;\n+\t\tfinal long eventElapsedNanos;\n+\t\tfinal long eventTimestampEpochMillis;\n+\t\tfinal T    event;\n+\n+\t\tImmutableTimed(long eventElapsedSinceSubscriptionNanos,\n+\t\t\t\tlong eventElapsedNanos,\n+\t\t\t\tlong eventTimestampEpochMillis,\n+\t\t\t\tT event) {\n+\t\t\tthis.eventElapsedSinceSubscriptionNanos = eventElapsedSinceSubscriptionNanos;\n+\t\t\tthis.eventElapsedNanos = eventElapsedNanos;\n+\t\t\tthis.eventTimestampEpochMillis = eventTimestampEpochMillis;\n+\t\t\tthis.event = event;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic T get() {\n+\t\t\treturn this.event;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Duration elapsed() {\n+\t\t\treturn Duration.ofNanos(eventElapsedNanos);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Duration elapsedSinceSubscription() {\n+\t\t\treturn Duration.ofNanos(eventElapsedSinceSubscriptionNanos);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Instant timestamp() {\n+\t\t\treturn Instant.ofEpochMilli(eventTimestampEpochMillis);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String toString() {\n+\t\t\treturn \"Timed(\" + event + \"){eventElapsedNanos=\" + eventElapsedNanos + \", eventElapsedSinceSubscriptionNanos=\" + eventElapsedSinceSubscriptionNanos + \",  eventTimestampEpochMillis=\" + eventTimestampEpochMillis + '}';\n+\t\t}\n+\t}\n+\n+\tstatic final class TimedSubscriber<T> implements InnerOperator<T, Timed<T>> {\n+\n+\t\tfinal CoreSubscriber<? super Timed<T>> actual;\n+\t\tfinal Scheduler clock;\n+\n+\t\tlong subscriptionNanos;\n+\t\tlong lastEventNanos;\n+\n+\t\tSubscription s;\n+\n+\t\tTimedSubscriber(CoreSubscriber<? super Timed<T>> actual, Scheduler clock) {\n+\t\t\tthis.actual = actual;\n+\t\t\tthis.clock = clock;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic CoreSubscriber<? super Timed<T>> actual() {\n+\t\t\treturn this.actual;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void onSubscribe(Subscription s) {\n+\t\t\tif (Operators.validate(this.s, s)) {\n+\t\t\t\tthis.s = s;\n+\n+\t\t\t\tthis.subscriptionNanos = clock.now(TimeUnit.NANOSECONDS);\n+\t\t\t\tthis.lastEventNanos = subscriptionNanos;\n+\n+\t\t\t\tactual.onSubscribe(this);\n+\t\t\t}\n+\t\t}\n+\n+\t\t//TODO protect against malformed publishers", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE3ODIxMA=="}, "originalCommit": {"oid": "76a5be567c24fa60d1ab7bdb5780c4c47db04ecf"}, "originalPosition": 135}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MTQwODUzOnYy", "diffSide": "RIGHT", "path": "reactor-core/src/test/java/reactor/core/publisher/FluxTimedTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwODo0ODozOFrOHtOOvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNDozMToyM1rOHtashA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE4MTExNg==", "bodyText": "Could this use virtual time to avoid losing ~1s each?", "url": "https://github.com/reactor/reactor-core/pull/2475#discussion_r517181116", "createdAt": "2020-11-04T08:48:38Z", "author": {"login": "ericbottard"}, "path": "reactor-core/src/test/java/reactor/core/publisher/FluxTimedTest.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import java.time.Duration;\n+import java.util.function.Consumer;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import reactor.test.StepVerifier;\n+import reactor.util.function.Tuple2;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+class FluxTimedTest {\n+\n+\t@Test\n+\tvoid compareTimedElapsedNanosToElapsedT1() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76a5be567c24fa60d1ab7bdb5780c4c47db04ecf"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM4NTM0OA==", "bodyText": "reworked the test to use virtual time (through explicit use of a VirtualTimeScheduler)", "url": "https://github.com/reactor/reactor-core/pull/2475#discussion_r517385348", "createdAt": "2020-11-04T14:31:23Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/test/java/reactor/core/publisher/FluxTimedTest.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import java.time.Duration;\n+import java.util.function.Consumer;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import reactor.test.StepVerifier;\n+import reactor.util.function.Tuple2;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+class FluxTimedTest {\n+\n+\t@Test\n+\tvoid compareTimedElapsedNanosToElapsedT1() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE4MTExNg=="}, "originalCommit": {"oid": "76a5be567c24fa60d1ab7bdb5780c4c47db04ecf"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MTQwOTI3OnYy", "diffSide": "RIGHT", "path": "reactor-core/src/test/java/reactor/core/publisher/FluxTimedTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwODo0ODo1MVrOHtOPNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwODo0ODo1MVrOHtOPNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE4MTIzOQ==", "bodyText": "CR missing", "url": "https://github.com/reactor/reactor-core/pull/2475#discussion_r517181239", "createdAt": "2020-11-04T08:48:51Z", "author": {"login": "ericbottard"}, "path": "reactor-core/src/test/java/reactor/core/publisher/FluxTimedTest.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import java.time.Duration;\n+import java.util.function.Consumer;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import reactor.test.StepVerifier;\n+import reactor.util.function.Tuple2;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+class FluxTimedTest {\n+\n+\t@Test\n+\tvoid compareTimedElapsedNanosToElapsedT1() {\n+\t\tConsumer<? super Timed<Tuple2<Long, Integer>>> timedSimilarToElapsed = v -> {\n+\t\t\tassertThat(v.elapsed().toMillis())\n+\t\t\t\t\t.as(v.toString())\n+\t\t\t\t\t//Duration.toMillis() drops the nanosecond part entirely\n+\t\t\t\t\t.isBetween(v.get().getT1() - 1L, v.get().getT1());\n+\t\t};\n+\n+\t\tFlux.range(1, 5)\n+\t\t    .delayElements(Duration.ofMillis(123))\n+\t\t    .elapsed()\n+\t\t    .timed()\n+\t\t    .as(StepVerifier::create)\n+\t\t    .assertNext(timedSimilarToElapsed)\n+\t\t    .assertNext(timedSimilarToElapsed)\n+\t\t    .assertNext(timedSimilarToElapsed)\n+\t\t    .assertNext(timedSimilarToElapsed)\n+\t\t    .assertNext(timedSimilarToElapsed)\n+\t\t    .verifyComplete();\n+\t}\n+\n+\t@Test\n+\tvoid compareTimedTimetampNanosToTimestampT1() {\n+\t\tConsumer<? super Timed<Tuple2<Long, Integer>>> timedSimilarToTimestamp = v -> {\n+\t\t\tassertThat(v.timestamp().toEpochMilli())\n+\t\t\t\t\t.as(v.toString())\n+\t\t\t\t\t//Instant.toEpochMilli() drops the nanosecond part entirely\n+\t\t\t\t\t.isBetween(v.get().getT1() -1L, v.get().getT1());\n+\t\t};\n+\n+\t\tFlux.range(1, 5)\n+\t\t    .delayElements(Duration.ofMillis(123))\n+\t\t    .timestamp()\n+\t\t    .timed()\n+\t\t    .as(StepVerifier::create)\n+\t\t    .assertNext(timedSimilarToTimestamp)\n+\t\t    .assertNext(timedSimilarToTimestamp)\n+\t\t    .assertNext(timedSimilarToTimestamp)\n+\t\t    .assertNext(timedSimilarToTimestamp)\n+\t\t    .assertNext(timedSimilarToTimestamp)\n+\t\t    .verifyComplete();\n+\t}\n+\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76a5be567c24fa60d1ab7bdb5780c4c47db04ecf"}, "originalPosition": 75}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 833, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}