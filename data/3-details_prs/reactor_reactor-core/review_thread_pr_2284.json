{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU1MTI2NTU5", "number": 2284, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNjoxNjoyMlrOERhVOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxNjoyMzoyOVrOER4vFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2ODA3MzUyOnYy", "diffSide": "RIGHT", "path": "reactor-core/src/main/java/reactor/core/publisher/ContextTrackingUtils.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNjoxNjoyMlrOG2R2sA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNjoyNToxN1rOG2SMcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU2ODgxNg==", "bodyText": "I just noticed that, contrary to what I thought, the Function uses the hash of the Publisher and not the Subscriber (ie hash is not specific to each subscriber). So I guess we could use originalSource here.", "url": "https://github.com/reactor/reactor-core/pull/2284#discussion_r459568816", "createdAt": "2020-07-23T16:16:22Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/ContextTrackingUtils.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+\n+import reactor.core.CorePublisher;\n+import reactor.core.CoreSubscriber;\n+import reactor.util.context.Context;\n+import reactor.util.context.ContextView;\n+\n+/**\n+ * @author Simon Basl\u00e9\n+ * @author Sergei Egorov\n+ */\n+final class ContextTrackingUtils {\n+\n+\tstatic final String CONTEXT_MARKER_PREFIX = \"reactor.core.context.marker.\";\n+\n+\tstatic final String generateKey(Object o) {\n+\t\treturn CONTEXT_MARKER_PREFIX + System.identityHashCode(o);\n+\t}\n+\n+\t/**\n+\t * This {@link Function} wrapper is used to implement the context loss detection.\n+\t *\n+\t */\n+\tstatic class FunctionWrapper<T, V> implements Function<CorePublisher<T>, CorePublisher<V>>  {\n+\n+\t\tfinal Function<? super Publisher<T>, ? extends Publisher<V>> transformer;\n+\n+\t\tFunctionWrapper(Function<? super Publisher<T>, ? extends Publisher<V>> transformer) {\n+\t\t\tthis.transformer = transformer;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic CorePublisher<V> apply(CorePublisher<T> self) {\n+\t\t\tString key = generateKey(self);\n+\n+\t\t\tPublisher<V> newSource = Operators.<T, T>liftPublisher((p, actual) -> {\n+\t\t\t\tContext ctx = actual.currentContext();\n+\n+\t\t\t\tif (!ctx.hasKey(key)) {\n+\t\t\t\t\tthrow new IllegalStateException(\"Context loss after applying \" + transformer);\n+\t\t\t\t}\n+\n+\t\t\t\tContext newContext = ctx.delete(key);\n+\t\t\t\treturn new FluxContextStart.ContextStartSubscriber<>(actual, newContext);\n+\t\t\t}).andThen(transformer).apply(self);\n+\n+\t\t\t// It is okay to return `CorePublisher` here since `transform` will use `from()` anyways\n+\t\t\treturn new CorePublisher<V>() {\n+\t\t\t\t@Override\n+\t\t\t\tpublic void subscribe(CoreSubscriber<? super V> actual) {\n+\t\t\t\t\tContext ctx = actual.currentContext().put(key, true);\n+\t\t\t\t\tCoreSubscriber<V> subscriber = new FluxContextStart.ContextStartSubscriber<>(actual, ctx);\n+\n+\t\t\t\t\tif (newSource instanceof CorePublisher) {\n+\t\t\t\t\t\t((CorePublisher<V>) newSource).subscribe(subscriber);\n+\t\t\t\t\t}\n+\t\t\t\t\telse {\n+\t\t\t\t\t\tnewSource.subscribe(subscriber);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\t@Override\n+\t\t\t\tpublic void subscribe(Subscriber<? super V> subscriber) {\n+\t\t\t\t\tsubscribe(Operators.toCoreSubscriber(subscriber));\n+\t\t\t\t}\n+\t\t\t};\n+\t\t}\n+\t}\n+\n+\tstatic final <V, T> CorePublisher<V> trackContextLossForFlux(Flux<T> originalSource,\n+\t\t\tContextView ctxView,\n+\t\t\tBiFunction<? super ContextView,? super Flux<T>,? extends Publisher<V>> transformer) {\n+\t\tString key = generateKey(ctxView);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5449f86002b2a4577e8b2b7bb11b80c437527ef1"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU3MjU0NA==", "bodyText": "well, it does not really matter much, just need to be some random value, but yeah, can also be per-subscriber", "url": "https://github.com/reactor/reactor-core/pull/2284#discussion_r459572544", "createdAt": "2020-07-23T16:22:22Z", "author": {"login": "bsideup"}, "path": "reactor-core/src/main/java/reactor/core/publisher/ContextTrackingUtils.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+\n+import reactor.core.CorePublisher;\n+import reactor.core.CoreSubscriber;\n+import reactor.util.context.Context;\n+import reactor.util.context.ContextView;\n+\n+/**\n+ * @author Simon Basl\u00e9\n+ * @author Sergei Egorov\n+ */\n+final class ContextTrackingUtils {\n+\n+\tstatic final String CONTEXT_MARKER_PREFIX = \"reactor.core.context.marker.\";\n+\n+\tstatic final String generateKey(Object o) {\n+\t\treturn CONTEXT_MARKER_PREFIX + System.identityHashCode(o);\n+\t}\n+\n+\t/**\n+\t * This {@link Function} wrapper is used to implement the context loss detection.\n+\t *\n+\t */\n+\tstatic class FunctionWrapper<T, V> implements Function<CorePublisher<T>, CorePublisher<V>>  {\n+\n+\t\tfinal Function<? super Publisher<T>, ? extends Publisher<V>> transformer;\n+\n+\t\tFunctionWrapper(Function<? super Publisher<T>, ? extends Publisher<V>> transformer) {\n+\t\t\tthis.transformer = transformer;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic CorePublisher<V> apply(CorePublisher<T> self) {\n+\t\t\tString key = generateKey(self);\n+\n+\t\t\tPublisher<V> newSource = Operators.<T, T>liftPublisher((p, actual) -> {\n+\t\t\t\tContext ctx = actual.currentContext();\n+\n+\t\t\t\tif (!ctx.hasKey(key)) {\n+\t\t\t\t\tthrow new IllegalStateException(\"Context loss after applying \" + transformer);\n+\t\t\t\t}\n+\n+\t\t\t\tContext newContext = ctx.delete(key);\n+\t\t\t\treturn new FluxContextStart.ContextStartSubscriber<>(actual, newContext);\n+\t\t\t}).andThen(transformer).apply(self);\n+\n+\t\t\t// It is okay to return `CorePublisher` here since `transform` will use `from()` anyways\n+\t\t\treturn new CorePublisher<V>() {\n+\t\t\t\t@Override\n+\t\t\t\tpublic void subscribe(CoreSubscriber<? super V> actual) {\n+\t\t\t\t\tContext ctx = actual.currentContext().put(key, true);\n+\t\t\t\t\tCoreSubscriber<V> subscriber = new FluxContextStart.ContextStartSubscriber<>(actual, ctx);\n+\n+\t\t\t\t\tif (newSource instanceof CorePublisher) {\n+\t\t\t\t\t\t((CorePublisher<V>) newSource).subscribe(subscriber);\n+\t\t\t\t\t}\n+\t\t\t\t\telse {\n+\t\t\t\t\t\tnewSource.subscribe(subscriber);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\t@Override\n+\t\t\t\tpublic void subscribe(Subscriber<? super V> subscriber) {\n+\t\t\t\t\tsubscribe(Operators.toCoreSubscriber(subscriber));\n+\t\t\t\t}\n+\t\t\t};\n+\t\t}\n+\t}\n+\n+\tstatic final <V, T> CorePublisher<V> trackContextLossForFlux(Flux<T> originalSource,\n+\t\t\tContextView ctxView,\n+\t\t\tBiFunction<? super ContextView,? super Flux<T>,? extends Publisher<V>> transformer) {\n+\t\tString key = generateKey(ctxView);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU2ODgxNg=="}, "originalCommit": {"oid": "5449f86002b2a4577e8b2b7bb11b80c437527ef1"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU3NDM4Ng==", "bodyText": "ok, I'll leave it as is then", "url": "https://github.com/reactor/reactor-core/pull/2284#discussion_r459574386", "createdAt": "2020-07-23T16:25:17Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/ContextTrackingUtils.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+\n+import reactor.core.CorePublisher;\n+import reactor.core.CoreSubscriber;\n+import reactor.util.context.Context;\n+import reactor.util.context.ContextView;\n+\n+/**\n+ * @author Simon Basl\u00e9\n+ * @author Sergei Egorov\n+ */\n+final class ContextTrackingUtils {\n+\n+\tstatic final String CONTEXT_MARKER_PREFIX = \"reactor.core.context.marker.\";\n+\n+\tstatic final String generateKey(Object o) {\n+\t\treturn CONTEXT_MARKER_PREFIX + System.identityHashCode(o);\n+\t}\n+\n+\t/**\n+\t * This {@link Function} wrapper is used to implement the context loss detection.\n+\t *\n+\t */\n+\tstatic class FunctionWrapper<T, V> implements Function<CorePublisher<T>, CorePublisher<V>>  {\n+\n+\t\tfinal Function<? super Publisher<T>, ? extends Publisher<V>> transformer;\n+\n+\t\tFunctionWrapper(Function<? super Publisher<T>, ? extends Publisher<V>> transformer) {\n+\t\t\tthis.transformer = transformer;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic CorePublisher<V> apply(CorePublisher<T> self) {\n+\t\t\tString key = generateKey(self);\n+\n+\t\t\tPublisher<V> newSource = Operators.<T, T>liftPublisher((p, actual) -> {\n+\t\t\t\tContext ctx = actual.currentContext();\n+\n+\t\t\t\tif (!ctx.hasKey(key)) {\n+\t\t\t\t\tthrow new IllegalStateException(\"Context loss after applying \" + transformer);\n+\t\t\t\t}\n+\n+\t\t\t\tContext newContext = ctx.delete(key);\n+\t\t\t\treturn new FluxContextStart.ContextStartSubscriber<>(actual, newContext);\n+\t\t\t}).andThen(transformer).apply(self);\n+\n+\t\t\t// It is okay to return `CorePublisher` here since `transform` will use `from()` anyways\n+\t\t\treturn new CorePublisher<V>() {\n+\t\t\t\t@Override\n+\t\t\t\tpublic void subscribe(CoreSubscriber<? super V> actual) {\n+\t\t\t\t\tContext ctx = actual.currentContext().put(key, true);\n+\t\t\t\t\tCoreSubscriber<V> subscriber = new FluxContextStart.ContextStartSubscriber<>(actual, ctx);\n+\n+\t\t\t\t\tif (newSource instanceof CorePublisher) {\n+\t\t\t\t\t\t((CorePublisher<V>) newSource).subscribe(subscriber);\n+\t\t\t\t\t}\n+\t\t\t\t\telse {\n+\t\t\t\t\t\tnewSource.subscribe(subscriber);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\t@Override\n+\t\t\t\tpublic void subscribe(Subscriber<? super V> subscriber) {\n+\t\t\t\t\tsubscribe(Operators.toCoreSubscriber(subscriber));\n+\t\t\t\t}\n+\t\t\t};\n+\t\t}\n+\t}\n+\n+\tstatic final <V, T> CorePublisher<V> trackContextLossForFlux(Flux<T> originalSource,\n+\t\t\tContextView ctxView,\n+\t\t\tBiFunction<? super ContextView,? super Flux<T>,? extends Publisher<V>> transformer) {\n+\t\tString key = generateKey(ctxView);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU2ODgxNg=="}, "originalCommit": {"oid": "5449f86002b2a4577e8b2b7bb11b80c437527ef1"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2ODA3NTczOnYy", "diffSide": "RIGHT", "path": "reactor-core/src/main/java/reactor/core/publisher/ContextTrackingUtils.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNjoxNjo1N1rOG2R4HQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNjoxNjo1N1rOG2R4HQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU2OTE4MQ==", "bodyText": "should it be ctxView? or should we expose the context including the key?", "url": "https://github.com/reactor/reactor-core/pull/2284#discussion_r459569181", "createdAt": "2020-07-23T16:16:57Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/ContextTrackingUtils.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+\n+import reactor.core.CorePublisher;\n+import reactor.core.CoreSubscriber;\n+import reactor.util.context.Context;\n+import reactor.util.context.ContextView;\n+\n+/**\n+ * @author Simon Basl\u00e9\n+ * @author Sergei Egorov\n+ */\n+final class ContextTrackingUtils {\n+\n+\tstatic final String CONTEXT_MARKER_PREFIX = \"reactor.core.context.marker.\";\n+\n+\tstatic final String generateKey(Object o) {\n+\t\treturn CONTEXT_MARKER_PREFIX + System.identityHashCode(o);\n+\t}\n+\n+\t/**\n+\t * This {@link Function} wrapper is used to implement the context loss detection.\n+\t *\n+\t */\n+\tstatic class FunctionWrapper<T, V> implements Function<CorePublisher<T>, CorePublisher<V>>  {\n+\n+\t\tfinal Function<? super Publisher<T>, ? extends Publisher<V>> transformer;\n+\n+\t\tFunctionWrapper(Function<? super Publisher<T>, ? extends Publisher<V>> transformer) {\n+\t\t\tthis.transformer = transformer;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic CorePublisher<V> apply(CorePublisher<T> self) {\n+\t\t\tString key = generateKey(self);\n+\n+\t\t\tPublisher<V> newSource = Operators.<T, T>liftPublisher((p, actual) -> {\n+\t\t\t\tContext ctx = actual.currentContext();\n+\n+\t\t\t\tif (!ctx.hasKey(key)) {\n+\t\t\t\t\tthrow new IllegalStateException(\"Context loss after applying \" + transformer);\n+\t\t\t\t}\n+\n+\t\t\t\tContext newContext = ctx.delete(key);\n+\t\t\t\treturn new FluxContextStart.ContextStartSubscriber<>(actual, newContext);\n+\t\t\t}).andThen(transformer).apply(self);\n+\n+\t\t\t// It is okay to return `CorePublisher` here since `transform` will use `from()` anyways\n+\t\t\treturn new CorePublisher<V>() {\n+\t\t\t\t@Override\n+\t\t\t\tpublic void subscribe(CoreSubscriber<? super V> actual) {\n+\t\t\t\t\tContext ctx = actual.currentContext().put(key, true);\n+\t\t\t\t\tCoreSubscriber<V> subscriber = new FluxContextStart.ContextStartSubscriber<>(actual, ctx);\n+\n+\t\t\t\t\tif (newSource instanceof CorePublisher) {\n+\t\t\t\t\t\t((CorePublisher<V>) newSource).subscribe(subscriber);\n+\t\t\t\t\t}\n+\t\t\t\t\telse {\n+\t\t\t\t\t\tnewSource.subscribe(subscriber);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\t@Override\n+\t\t\t\tpublic void subscribe(Subscriber<? super V> subscriber) {\n+\t\t\t\t\tsubscribe(Operators.toCoreSubscriber(subscriber));\n+\t\t\t\t}\n+\t\t\t};\n+\t\t}\n+\t}\n+\n+\tstatic final <V, T> CorePublisher<V> trackContextLossForFlux(Flux<T> originalSource,\n+\t\t\tContextView ctxView,\n+\t\t\tBiFunction<? super ContextView,? super Flux<T>,? extends Publisher<V>> transformer) {\n+\t\tString key = generateKey(ctxView);\n+\n+\t\tPublisher<T> sourceWithLossDetection = Operators.<T, T>liftPublisher((p, actual) -> {\n+\t\t\tContext ctx = actual.currentContext();\n+\n+\t\t\tif (!ctx.hasKey(key)) {\n+\t\t\t\tthrow new IllegalStateException(\"Context loss after applying \" + transformer);\n+\t\t\t}\n+\n+\t\t\tContext newContext = ctx.delete(key);\n+\t\t\treturn new FluxContextStart.ContextStartSubscriber<>(actual, newContext);\n+\t\t}).apply(originalSource);\n+\n+\t\tfinal Publisher<V> transformedByUser = transformer.apply(ctxView, Flux.from(sourceWithLossDetection));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5449f86002b2a4577e8b2b7bb11b80c437527ef1"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3MTI3NDE3OnYy", "diffSide": "RIGHT", "path": "reactor-core/src/main/java/reactor/core/publisher/Flux.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxMzozODo0NlrOG2vrpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxMzozODo0NlrOG2vrpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDA1NzUwOA==", "bodyText": "TODO\n(actionable comment)", "url": "https://github.com/reactor/reactor-core/pull/2284#discussion_r460057508", "createdAt": "2020-07-24T13:38:46Z", "author": {"login": "bsideup"}, "path": "reactor-core/src/main/java/reactor/core/publisher/Flux.java", "diffHunk": "@@ -8778,19 +8778,35 @@ public final void subscribe(Subscriber<? super T> actual) {\n \t *\n \t * @return a new {@link Flux}\n \t * @see #transform(Function) transform() for immmediate transformation of Flux\n+\t * @see #transformDeferred(BiFunction) transformDeferred(BiFunction) for a similarly deferred transformation of Flux reading the ContextView\n \t * @see #as as() for a loose conversion to an arbitrary type\n \t */\n \tpublic final <V> Flux<V> transformDeferred(Function<? super Flux<T>, ? extends Publisher<V>> transformer) {\n \t\treturn defer(() -> {\n \t\t\tif (Hooks.DETECT_CONTEXT_LOSS) {\n \t\t\t\t@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n-\t\t\t\tCorePublisher<V> result = new ContextTrackingFunctionWrapper<T, V>((Function) transformer).apply(this);\n-\t\t\t\treturn result;\n+\t\t\t\tContextTrackingFunctionWrapper<T, V> wrapper = new ContextTrackingFunctionWrapper<T, V>((Function) transformer);\n+\t\t\t\treturn wrapper.apply(this);\n \t\t\t}\n \t\t\treturn transformer.apply(this);\n \t\t});\n \t}\n \n+\t//TODO javadoc", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a76bc518057ac1201b4d7f515fa1a24b3e84d68"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3MTkwODA3OnYy", "diffSide": "RIGHT", "path": "reactor-core/src/main/java/reactor/core/publisher/Flux.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxNjoyMzoyOVrOG21wpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxNjo0OTowNVrOG22mEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE1NzA5Mw==", "bodyText": "can we please swap ContextView and ? super Flux<T>, so that the publisher comes first and Context is a secondary concept.", "url": "https://github.com/reactor/reactor-core/pull/2284#discussion_r460157093", "createdAt": "2020-07-24T16:23:29Z", "author": {"login": "bsideup"}, "path": "reactor-core/src/main/java/reactor/core/publisher/Flux.java", "diffHunk": "@@ -8778,19 +8778,57 @@ public final void subscribe(Subscriber<? super T> actual) {\n \t *\n \t * @return a new {@link Flux}\n \t * @see #transform(Function) transform() for immmediate transformation of Flux\n+\t * @see #transformDeferred(BiFunction) transformDeferred(BiFunction) for a similarly deferred transformation of Flux reading the ContextView\n \t * @see #as as() for a loose conversion to an arbitrary type\n \t */\n \tpublic final <V> Flux<V> transformDeferred(Function<? super Flux<T>, ? extends Publisher<V>> transformer) {\n \t\treturn defer(() -> {\n \t\t\tif (Hooks.DETECT_CONTEXT_LOSS) {\n \t\t\t\t@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n-\t\t\t\tCorePublisher<V> result = new ContextTrackingFunctionWrapper<T, V>((Function) transformer).apply(this);\n-\t\t\t\treturn result;\n+\t\t\t\tContextTrackingFunctionWrapper<T, V> wrapper = new ContextTrackingFunctionWrapper<T, V>((Function) transformer);\n+\t\t\t\treturn wrapper.apply(this);\n \t\t\t}\n \t\t\treturn transformer.apply(this);\n \t\t});\n \t}\n \n+\t/**\n+\t * Defer the given transformation to this {@link Flux} in order to generate a\n+\t * target {@link Flux} type. A transformation will occur for each\n+\t * {@link Subscriber}. In addition, the transfoming {@link BiFunction} exposes\n+\t * the {@link ContextView} of each {@link Subscriber}. For instance:\n+\t *\n+\t * <blockquote><pre>\n+\t * Flux&lt;T> fluxLogged = flux.transformDeferred((ctx, original) -> original.log(\"for RequestID\" + ctx.get(\"RequestID\"))\n+\t * //...later subscribe. Each subscriber has its Context with a RequestID entry\n+\t * fluxLogged.subscriberContext(Context.of(\"RequestID\", \"requestA\").subscribe();\n+\t * fluxLogged.subscriberContext(Context.of(\"RequestID\", \"requestB\").subscribe();\n+\t * </pre></blockquote>\n+\t * <p>\n+\t * <img class=\"marble\" src=\"doc-files/marbles/transformDeferredForFlux.svg\" alt=\"\">\n+\t *\n+\t * @param transformer the {@link BiFunction} to lazily map this {@link Flux} into a target {@link Flux}\n+\t * instance upon subscription, with access to {@link ContextView}\n+\t * @param <V> the item type in the returned {@link Publisher}\n+\t * @return a new {@link Flux}\n+\t * @see #as as() for a loose conversion to an arbitrary type\n+\t * @see #transform(Function)\n+\t * @see #transformDeferred(Function)\n+\t */\n+\tpublic final <V> Flux<V> transformDeferred(BiFunction<? super ContextView, ? super Flux<T>, ? extends Publisher<V>> transformer) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac8e7cd13af417e9bd9a457d817602f19d2996fb"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE3MDc3MQ==", "bodyText": "done", "url": "https://github.com/reactor/reactor-core/pull/2284#discussion_r460170771", "createdAt": "2020-07-24T16:49:05Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/Flux.java", "diffHunk": "@@ -8778,19 +8778,57 @@ public final void subscribe(Subscriber<? super T> actual) {\n \t *\n \t * @return a new {@link Flux}\n \t * @see #transform(Function) transform() for immmediate transformation of Flux\n+\t * @see #transformDeferred(BiFunction) transformDeferred(BiFunction) for a similarly deferred transformation of Flux reading the ContextView\n \t * @see #as as() for a loose conversion to an arbitrary type\n \t */\n \tpublic final <V> Flux<V> transformDeferred(Function<? super Flux<T>, ? extends Publisher<V>> transformer) {\n \t\treturn defer(() -> {\n \t\t\tif (Hooks.DETECT_CONTEXT_LOSS) {\n \t\t\t\t@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n-\t\t\t\tCorePublisher<V> result = new ContextTrackingFunctionWrapper<T, V>((Function) transformer).apply(this);\n-\t\t\t\treturn result;\n+\t\t\t\tContextTrackingFunctionWrapper<T, V> wrapper = new ContextTrackingFunctionWrapper<T, V>((Function) transformer);\n+\t\t\t\treturn wrapper.apply(this);\n \t\t\t}\n \t\t\treturn transformer.apply(this);\n \t\t});\n \t}\n \n+\t/**\n+\t * Defer the given transformation to this {@link Flux} in order to generate a\n+\t * target {@link Flux} type. A transformation will occur for each\n+\t * {@link Subscriber}. In addition, the transfoming {@link BiFunction} exposes\n+\t * the {@link ContextView} of each {@link Subscriber}. For instance:\n+\t *\n+\t * <blockquote><pre>\n+\t * Flux&lt;T> fluxLogged = flux.transformDeferred((ctx, original) -> original.log(\"for RequestID\" + ctx.get(\"RequestID\"))\n+\t * //...later subscribe. Each subscriber has its Context with a RequestID entry\n+\t * fluxLogged.subscriberContext(Context.of(\"RequestID\", \"requestA\").subscribe();\n+\t * fluxLogged.subscriberContext(Context.of(\"RequestID\", \"requestB\").subscribe();\n+\t * </pre></blockquote>\n+\t * <p>\n+\t * <img class=\"marble\" src=\"doc-files/marbles/transformDeferredForFlux.svg\" alt=\"\">\n+\t *\n+\t * @param transformer the {@link BiFunction} to lazily map this {@link Flux} into a target {@link Flux}\n+\t * instance upon subscription, with access to {@link ContextView}\n+\t * @param <V> the item type in the returned {@link Publisher}\n+\t * @return a new {@link Flux}\n+\t * @see #as as() for a loose conversion to an arbitrary type\n+\t * @see #transform(Function)\n+\t * @see #transformDeferred(Function)\n+\t */\n+\tpublic final <V> Flux<V> transformDeferred(BiFunction<? super ContextView, ? super Flux<T>, ? extends Publisher<V>> transformer) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE1NzA5Mw=="}, "originalCommit": {"oid": "ac8e7cd13af417e9bd9a457d817602f19d2996fb"}, "originalPosition": 43}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 902, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}