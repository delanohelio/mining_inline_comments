{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM4ODMzOTc0", "number": 2218, "title": "Suggesting some changes on the Processor API update", "bodyText": "Giving a go at my latest comment on #2188", "createdAt": "2020-06-23T21:33:51Z", "url": "https://github.com/reactor/reactor-core/pull/2218", "merged": true, "mergeCommit": {"oid": "a29a4d0165cff2ec8eeaada021040c8e4ddf9387"}, "closed": true, "closedAt": "2020-08-05T10:18:57Z", "author": {"login": "smaldini"}, "timelineItems": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcuWzZdgFqTQzNjQ1OTc2Mw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABc74F7DAFqTQ2MTUwODUzNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2NDU5NzYz", "url": "https://github.com/reactor/reactor-core/pull/2218#pullrequestreview-436459763", "createdAt": "2020-06-24T09:03:46Z", "commit": {"oid": "e152ff38435ecb251deefea7fdfbde45ba9516c7"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwOTowMzo0N1rOGoJc4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwOToxNTo1OFrOGoJ5Hw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc1MTA3Mw==", "bodyText": "if sinks are advertised as thread safe objects, doesn't this require external synchronization of the processor's calls ? especially if we later introduce several flavors of MonoProcessor ?", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r444751073", "createdAt": "2020-06-24T09:03:47Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/Sinks.java", "diffHunk": "@@ -203,64 +159,43 @@ public void error(Throwable e) {\n \t\t}\n \n \t\t@Override\n-\t\tpublic StandaloneFluxSink<T> next(T t) {\n+\t\tpublic Sink<T> next(T t) {\n \t\t\tdelegateSink.next(t);\n \t\t\treturn this;\n \t\t}\n \t}\n \n-\t//TODO improve synchronization, prefer CAS ?\n-\tstatic final class MonoProcessorSink<T> implements StandaloneMonoSink<T> {\n+\tstatic final class MonoProcessorSink<T> implements Sink<T> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e152ff38435ecb251deefea7fdfbde45ba9516c7"}, "originalPosition": 207}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc1MjYzOQ==", "bodyText": "IF the mono flavor is removed, this and 'Sink' can be removed. but I'm not a huge fan of removing the mono flavor...", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r444752639", "createdAt": "2020-06-24T09:06:29Z", "author": {"login": "simonbasle"}, "path": "docs/asciidoc/processors.adoc", "diffHunk": "@@ -45,7 +45,7 @@ If, after exploring the above alternatives, you still think you need a `Processo\n the <<processor-overview>> section to learn about the different implementations.\n \n [[sinks]]\n-= Safely Produce from Multiple Threads by Using `StandaloneFluxSink` and `StandaloneMonoSink`\n+= Safely Produce from Multiple Threads by Using `Sink` and `Sink`", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e152ff38435ecb251deefea7fdfbde45ba9516c7"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc1MzQ2NQ==", "bodyText": "could you maybe revert the FluxIdentityProcessor removal for now, and offer it in a separate PR ? this distracts from the rest of the PR IMHO, as maybe 90% of these files are only changed due to this removal.", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r444753465", "createdAt": "2020-06-24T09:07:48Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/DirectProcessor.java", "diffHunk": "@@ -81,7 +81,7 @@\n  * @deprecated Prefer clear cut usage of either {@link Processors} or {@link Sinks}, to be removed in 3.5\n  */\n @Deprecated\n-public final class DirectProcessor<T> extends FluxIdentityProcessor<T> {\n+public final class DirectProcessor<T> extends FluxProcessor<T, T> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e152ff38435ecb251deefea7fdfbde45ba9516c7"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc1NTA3Mw==", "bodyText": "the rationale for adding this was that FluxProcessor<String, String> feels clunky, and was such a pain to migrate when removing deprecation warnings in the test code. Maybe that pain will be a good motivator for people to move to Sink? But maybe on the contrary it will just make them angry \ud83d\ude1d", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r444755073", "createdAt": "2020-06-24T09:10:33Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/FluxIdentityProcessor.java", "diffHunk": "@@ -1,26 +0,0 @@\n-/*\n- * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *        https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package reactor.core.publisher;\n-\n-/**\n- * A {@link FluxProcessor} that has the same input and output types.\n- * \n- * @author Simon Basl\u00e9\n- */\n-public abstract class FluxIdentityProcessor<T> extends FluxProcessor<T, T> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e152ff38435ecb251deefea7fdfbde45ba9516c7"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc1NTg4NQ==", "bodyText": "honestly, I'm not a huge fan of offering an API and then having it error in half the cases. this feels like a step backward towards the same kind of inconsistencies that we had in processors.", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r444755885", "createdAt": "2020-06-24T09:11:55Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/FluxSink.java", "diffHunk": "@@ -113,6 +113,16 @@\n \t */\n \tFluxSink<T> onDispose(Disposable d);\n \n+\t@Override\n+\tdefault Flux<T> toFlux() {\n+\t\treturn Flux.error(new IllegalStateException(\"A FluxSink does not support back referencing the outer Flux\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e152ff38435ecb251deefea7fdfbde45ba9516c7"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc1ODMwMw==", "bodyText": "I think this is very problematic. Offering a flux-like API on the MonoSink, even if we introduce a specialized API, is bound to be confusing.\nie this API seemingly allows next(t).next(t).complete() or even more confusing, next(t1).next(t2).success(t3) type of calls.", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r444758303", "createdAt": "2020-06-24T09:15:58Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/MonoSink.java", "diffHunk": "@@ -31,7 +33,45 @@\n  *\n  * @param <T> the value type emitted\n  */\n-public interface MonoSink<T> extends ScalarSink<T> {\n+public interface MonoSink<T> extends Sink<T> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e152ff38435ecb251deefea7fdfbde45ba9516c7"}, "originalPosition": 21}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3MzA2Mzk5", "url": "https://github.com/reactor/reactor-core/pull/2218#pullrequestreview-437306399", "createdAt": "2020-06-25T09:06:09Z", "commit": {"oid": "3d171d8870cd3d3ee46d5fc06aac05b98ff3046d"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQwOTowNjoxMFrOGox_vg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxMDoxODoyM1rOGo0fVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQxNTM1OA==", "bodyText": "while you're here \ud83d\ude01\ncould you help getting rid of the parkNanos ? (I think I remember you said you thought it was possible)", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r445415358", "createdAt": "2020-06-25T09:06:10Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/EmitterProcessor.java", "diffHunk": "@@ -192,6 +192,85 @@ public void subscribe(CoreSubscriber<? super T> actual) {\n \t\t}\n \t}\n \n+\t@Override\n+\tpublic boolean emitComplete() {\n+\t\tif (done) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tdone = true;\n+\t\tdrain();\n+\t\treturn true;\n+\t}\n+\n+\t@Override\n+\tpublic boolean emitError(Throwable t) {\n+\t\tObjects.requireNonNull(t, \"onError\");\n+\t\tif (done) {\n+\t\t\tOperators.onErrorDroppedMulticast(t);\n+\t\t\treturn false;\n+\t\t}\n+\t\tif (Exceptions.addThrowable(ERROR, this, t)) {\n+\t\t\tdone = true;\n+\t\t\tdrain();\n+\t\t\treturn true;\n+\t\t}\n+\t\telse {\n+\t\t\tOperators.onErrorDroppedMulticast(t);\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic boolean emitNext(T t) {\n+\t\tif (done) {\n+\t\t\tOperators.onNextDropped(t, currentContext());\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tif (sourceMode == Fuseable.ASYNC) {\n+\t\t\tdrain();\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tObjects.requireNonNull(t, \"onNext\");\n+\n+\t\tQueue<T> q = queue;\n+\n+\t\tif (q == null) {\n+\t\t\tif (Operators.setOnce(S, this, Operators.emptySubscription())) {\n+\t\t\t\tq = Queues.<T>get(prefetch).get();\n+\t\t\t\tqueue = q;\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tfor (; ; ) {\n+\t\t\t\t\tif (isDisposed()) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\tq = queue;\n+\t\t\t\t\tif (q != null) {\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\twhile (!q.offer(t)) {\n+\t\t\tLockSupport.parkNanos(10);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d171d8870cd3d3ee46d5fc06aac05b98ff3046d"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQxNjc1Ng==", "bodyText": "potential for regression around leaks", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r445416756", "createdAt": "2020-06-25T09:08:39Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/FluxCreate.java", "diffHunk": "@@ -131,102 +130,102 @@ public Object scanUnsafe(Attr key) {\n \n \t\tvolatile boolean done;\n \n-\t\tSerializedSink(BaseSink<T> sink) {\n+\t\tSerializedSink(SINK sink) {\n \t\t\tthis.sink = sink;\n \t\t\tthis.mpscQueue = Queues.<T>unboundedMultiproducer().get();\n \t\t}\n \n \t\t@Override\n-\t\tpublic Context currentContext() {\n-\t\t\treturn sink.currentContext();\n+\t\tpublic final Flux<T> toFlux() {\n+\t\t\treturn sink.toFlux();\n \t\t}\n \n \t\t@Override\n-\t\tpublic FluxSink<T> next(T t) {\n+\t\tpublic final Mono<T> toMono() {\n+\t\t\treturn sink.toMono();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic final boolean emitComplete() {\n+\t\t\tif (done) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tdone = true;\n+\t\t\tdrain();\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tabstract Context currentContext();\n+\n+\t\t@Override\n+\t\tpublic final boolean emitError(Throwable t) {\n+\t\t\tObjects.requireNonNull(t, \"t is null in sink.error(t)\");\n+\t\t\tif (done) {\n+\t\t\t\tOperators.onOperatorError(t, currentContext());\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (Exceptions.addThrowable(ERROR, this, t)) {\n+\t\t\t\tdone = true;\n+\t\t\t\tdrain();\n+\t\t\t\treturn true;\n+\t\t\t}\n+\n+\t\t\tContext ctx = currentContext();\n+\t\t\tOperators.onDiscardQueueWithClear(mpscQueue, ctx, null);\n+\t\t\tOperators.onOperatorError(t, ctx);\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic final boolean emitNext(T t) {\n \t\t\tObjects.requireNonNull(t, \"t is null in sink.next(t)\");\n-\t\t\tif (sink.isTerminated() || done) {\n-\t\t\t\tOperators.onNextDropped(t, sink.currentContext());\n-\t\t\t\treturn this;\n+\t\t\tif (done) {\n+\t\t\t\tOperators.onNextDropped(t, currentContext());\n+\t\t\t\treturn false;\n \t\t\t}\n \t\t\tif (WIP.get(this) == 0 && WIP.compareAndSet(this, 0, 1)) {\n \t\t\t\ttry {\n-\t\t\t\t\tsink.next(t);\n+\t\t\t\t\tsink.emitNext(t);\n \t\t\t\t}\n \t\t\t\tcatch (Throwable ex) {\n-\t\t\t\t\tOperators.onOperatorError(sink, ex, t, sink.currentContext());\n+\t\t\t\t\tOperators.onOperatorError(null, ex, t, currentContext());\n+\t\t\t\t\temitError(ex);\n+\t\t\t\t\treturn false;\n \t\t\t\t}\n \t\t\t\tif (WIP.decrementAndGet(this) == 0) {\n-\t\t\t\t\treturn this;\n+\t\t\t\t\treturn true;\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthis.mpscQueue.offer(t);\n \t\t\t\tif (WIP.getAndIncrement(this) != 0) {\n-\t\t\t\t\treturn this;\n+\t\t\t\t\treturn true;\n \t\t\t\t}\n \t\t\t}\n \t\t\tdrainLoop();\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void error(Throwable t) {\n-\t\t\tObjects.requireNonNull(t, \"t is null in sink.error(t)\");\n-\t\t\tif (sink.isTerminated() || done) {\n-\t\t\t\tOperators.onOperatorError(t, sink.currentContext());\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t\tif (Exceptions.addThrowable(ERROR, this, t)) {\n-\t\t\t\tdone = true;\n-\t\t\t\tdrain();\n-\t\t\t}\n-\t\t\telse {\n-\t\t\t\tContext ctx = sink.currentContext();\n-\t\t\t\tOperators.onDiscardQueueWithClear(mpscQueue, ctx, null);\n-\t\t\t\tOperators.onOperatorError(t, ctx);\n-\t\t\t}\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void complete() {\n-\t\t\tif (sink.isTerminated() || done) {\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t\tdone = true;\n-\t\t\tdrain();\n+\t\t\treturn true;\n \t\t}\n \n \t\t//impl note: don't use sink.isTerminated() in the drain loop,\n \t\t//it needs to separately check its own `done` status before calling the base sink\n \t\t//complete()/error() methods (which do flip the isTerminated), otherwise it could\n \t\t//bypass the terminate handler (in buffer and latest variants notably).\n-\t\tvoid drain() {\n+\t\tfinal void drain() {\n \t\t\tif (WIP.getAndIncrement(this) == 0) {\n \t\t\t\tdrainLoop();\n \t\t\t}\n \t\t}\n \n-\t\tvoid drainLoop() {\n-\t\t\tContext ctx = sink.currentContext();\n-\t\t\tBaseSink<T> e = sink;\n+\t\tfinal void drainLoop() {\n+\t\t\tSink<T> e = sink;\n \t\t\tQueue<T> q = mpscQueue;\n \t\t\tfor (; ; ) {\n \n \t\t\t\tfor (; ; ) {\n-\t\t\t\t\tif (e.isCancelled()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d171d8870cd3d3ee46d5fc06aac05b98ff3046d"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQxODY3Ng==", "bodyText": "I think we can directly make Sink implement Scannable", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r445418676", "createdAt": "2020-06-25T09:12:11Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/FluxGroupJoin.java", "diffHunk": "@@ -207,7 +207,7 @@\n \t\t@Override\n \t\tpublic Stream<? extends Scannable> inners() {\n \t\t\treturn Stream.concat(\n-\t\t\t\t\tlefts.values().stream(),\n+\t\t\t\t\tlefts.values().stream().map(Scannable.class::cast),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d171d8870cd3d3ee46d5fc06aac05b98ff3046d"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQyMDU3OQ==", "bodyText": "no need for the from if Sink becomes Scannable (this comment is relevant to several other files, I haven't commented on all of them)", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r445420579", "createdAt": "2020-06-25T09:15:34Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/FluxWindow.java", "diffHunk": "@@ -445,18 +443,18 @@ public Object scanUnsafe(Attr key) {\n \n \t\t@Override\n \t\tpublic Stream<? extends Scannable> inners() {\n-\t\t\treturn Stream.of(window);\n+\t\t\treturn Stream.of(Scannable.from(window));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d171d8870cd3d3ee46d5fc06aac05b98ff3046d"}, "originalPosition": 199}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQyMzI0NA==", "bodyText": "Note for last pass: the doc will need a reflow. We're talking about processor flavors and then give Sinks builders. We'll probably need to explain multiple flavors of sinks and then how to turn them into FluxProcessor?", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r445423244", "createdAt": "2020-06-25T09:20:04Z", "author": {"login": "simonbasle"}, "path": "docs/asciidoc/processors.adoc", "diffHunk": "@@ -50,7 +50,7 @@ the <<processor-overview>> section to learn about the different implementations.\n Rather than directly using Reactor `Processors`, it is a good practice to use `Sinks` to\n manually produce signals, with thread safety.\n \n-Most `Processors` flavors have an equivalent in `Sinks`. For example, `Processors.replayAll()`:\n+Most `Processors` flavors have an equivalent in `Sinks`. For example, `Sinks.replayAll()`:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d171d8870cd3d3ee46d5fc06aac05b98ff3046d"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQyNDg2Nw==", "bodyText": "remove either in both overloads javadocs", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r445424867", "createdAt": "2020-06-25T09:22:41Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/FluxProcessor.java", "diffHunk": "@@ -203,7 +203,7 @@ public Context currentContext() {\n \t * </ul>\n \t *\n \t * @return a serializing {@link FluxSink}\n-\t * @deprecated Prefer clear cut usage of either {@link Processors} or {@link Sinks}, to be removed in 3.5\n+\t * @deprecated Prefer clear cut usage of either {@link Sinks}, to be removed in 3.5", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d171d8870cd3d3ee46d5fc06aac05b98ff3046d"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQyNzE4Mw==", "bodyText": "should we deprecate the next/complete/error methods in favor of the emit ones? contrary to MonoSink, these don't seem to provide more value / guidance to the user. (on MonoSink the methods help you respect the mono contract). cc @reactor/core-team", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r445427183", "createdAt": "2020-06-25T09:26:44Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/FluxSink.java", "diffHunk": "@@ -33,9 +34,29 @@\n  */\n public interface FluxSink<T> extends Sink<T> {\n \n-\t@Override\n+\t/**\n+\t * Emit a non-null element, generating an {@link Subscriber#onNext(Object) onNext} signal.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d171d8870cd3d3ee46d5fc06aac05b98ff3046d"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQyOTAzOQ==", "bodyText": "note : will need to document the dropping behavior (in case of return false)", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r445429039", "createdAt": "2020-06-25T09:29:50Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/MonoSink.java", "diffHunk": "@@ -55,11 +55,18 @@\n \tvoid success(@Nullable T value);\n \n \t/**\n-\t * Terminate with the given value without requiring {@link #complete()} to be explicitly called.\n+\t * @see #emitError(Throwable)\n+\t */\n+\tvoid error(Throwable e);\n+\n+\t/**\n+\t * Terminate with the given value without requiring {@link #emitComplete()} to be explicitly called.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d171d8870cd3d3ee46d5fc06aac05b98ff3046d"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQzMDAxNA==", "bodyText": "let's use completion rather than emission which is a bit too tied to the notion of emitting an element for the docs IMO.", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r445430014", "createdAt": "2020-06-25T09:31:30Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/Sink.java", "diffHunk": "@@ -36,17 +37,19 @@\n \t * signal.\n \t *\n \t * @see Subscriber#onComplete()\n+\t * @return true if emission succeeded (the sink was not previously terminated)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d171d8870cd3d3ee46d5fc06aac05b98ff3046d"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQzMTEwNg==", "bodyText": "let's use sequence could be failed rather than emission succeeded which is a bit too tied to the notion of emitting an element for the docs IMO. Plus the word succeeded on an error method is a bit confusing.", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r445431106", "createdAt": "2020-06-25T09:33:18Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/Sink.java", "diffHunk": "@@ -36,17 +37,19 @@\n \t * signal.\n \t *\n \t * @see Subscriber#onComplete()\n+\t * @return true if emission succeeded (the sink was not previously terminated)\n \t */\n-\tvoid complete();\n+\tboolean emitComplete();\n \n \t/**\n \t * Fail the sequence, generating an {@link Subscriber#onError(Throwable) onError}\n \t * signal.\n \t *\n \t * @see Subscriber#onError(Throwable)\n \t * @param e the exception to signal, not null\n+\t * @return true if emission succeeded (the sink was not previously terminated)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d171d8870cd3d3ee46d5fc06aac05b98ff3046d"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQzNDc5OA==", "bodyText": "I still think this inconsistency in behavior between what happens before the FIRST subscriber and what happens to ADDITIONAL subscribers can be surprising, and so it should be made a little bit more explicit. Maybe re-introduce the <li> but put it first in the list? Like \"What happens before the first subscription\" vs \"What happens when more subscribers subscribe\" rather than \"Without subscriber\"vs\"Replaying\" ?", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r445434798", "createdAt": "2020-06-25T09:39:36Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/Sinks.java", "diffHunk": "@@ -47,25 +53,37 @@ private Sinks() { }\n \t */\n \t@SuppressWarnings(\"deprecation\")\n \tpublic static <T> Sink<T> multicast() {\n-\t\treturn new ProcessorSink<>(EmitterProcessor.create(Queues.SMALL_BUFFER_SIZE));\n+\t\tEmitterProcessor<T> processor = EmitterProcessor.create(Queues.SMALL_BUFFER_SIZE);\n+\t\treturn SinksHelper.toSink(processor, processor);\n \t}\n \n \t/**\n \t * A {@link Sink} with the following characteristics:\n \t * <ul>\n \t *     <li>Multicast</li>\n-\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n+\t *     <li>Backpressure : this sink is not able to honor downstream demand and will emit `onError` if there is a mismatch.</li>\n \t *     <li>Replaying: No replay. Only forwards to a {@link Subscriber} the elements that have been\n-\t *     pushed to the sink AFTER this subscriber was subscribed.</li>\n-\t *     <li>Without {@link Subscriber}: Discarding. Pushing elements while there are no {@link Subscriber}\n-\t *     registered will simply discard these elements instead of \"warming up\" the sink.</li>\n+\t *     pushed to the sink AFTER this subscriber was subscribed. To the exception of the first", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d171d8870cd3d3ee46d5fc06aac05b98ff3046d"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQzNzI3Mw==", "bodyText": "add a private ctor", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r445437273", "createdAt": "2020-06-25T09:43:52Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/SinksHelper.java", "diffHunk": "@@ -0,0 +1,130 @@\n+package reactor.core.publisher;\n+\n+import reactor.core.CoreSubscriber;\n+import reactor.core.Disposable;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.util.annotation.Nullable;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.util.Queue;\n+import java.util.function.Consumer;\n+\n+final class SinksHelper implements Sinks.UnsafeSinks {\n+\tstatic final SinksHelper INSTANCE = new SinksHelper();\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d171d8870cd3d3ee46d5fc06aac05b98ff3046d"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ0MjA4OA==", "bodyText": "rename to serialize? (like in Operators.serialize(subscriber))", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r445442088", "createdAt": "2020-06-25T09:52:16Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/SinksHelper.java", "diffHunk": "@@ -0,0 +1,130 @@\n+package reactor.core.publisher;\n+\n+import reactor.core.CoreSubscriber;\n+import reactor.core.Disposable;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.util.annotation.Nullable;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.util.Queue;\n+import java.util.function.Consumer;\n+\n+final class SinksHelper implements Sinks.UnsafeSinks {\n+\tstatic final SinksHelper INSTANCE = new SinksHelper();\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> unicast() {\n+\t\treturn UnicastProcessor.create();\n+\t}\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> multicast() {\n+\t\treturn EmitterProcessor.create();\n+\t}\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> replayAll() {\n+\t\treturn ReplayProcessor.create();\n+\t}\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> replay(int historySize) {\n+\t\treturn ReplayProcessor.create(historySize);\n+\t}\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic  <T> Sink<T> replayTimeout(Duration maxAge) {\n+\t\treturn ReplayProcessor.createTimeout(maxAge);\n+\t}\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> replaySizeAndTimeout(int historySize, Duration maxAge) {\n+\t\treturn ReplayProcessor.createSizeAndTimeout(historySize, maxAge);\n+\t}\n+\n+\t// == unicast ==\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> unicast(Queue<T> queue) {\n+\t\treturn UnicastProcessor.create(queue);\n+\t}\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> unicast(Queue<T> queue, Disposable endCallback) {\n+\t\treturn UnicastProcessor.create(queue, endCallback);\n+\t}\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> unicast(Queue<T> queue, Consumer<? super T> onOverflow, Disposable endCallback) {\n+\t\treturn UnicastProcessor.create(queue, onOverflow, endCallback);\n+\t}\n+\n+\t// == direct (less used) ==\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> multicastNoBackpressure() {\n+\t\treturn DirectProcessor.create();\n+\t}\n+\n+\t// == emitter ==\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> multicast(boolean autoCancel) {\n+\t\treturn EmitterProcessor.create(autoCancel);\n+\t}\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> multicast(int bufferSize) {\n+\t\treturn EmitterProcessor.create(bufferSize);\n+\t}\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> multicast(int bufferSize, boolean autoCancel) {\n+\t\treturn EmitterProcessor.create(bufferSize, autoCancel);\n+\t}\n+\n+\t// == replay ==\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> replayLatest() {\n+\t\treturn ReplayProcessor.cacheLast();\n+\t}\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> replayLatestOrDefault(@Nullable T value) {\n+\t\treturn ReplayProcessor.cacheLastOrDefault(value);\n+\t}\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> replay(int historySize, boolean unbounded) {\n+\t\treturn ReplayProcessor.create(historySize, unbounded);\n+\t}\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> replayTimeout(Duration maxAge, Scheduler scheduler) {\n+\t\treturn ReplayProcessor.createTimeout(maxAge, scheduler);\n+\t}\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> replaySizeAndTimeout(int historySize, Duration maxAge, Scheduler scheduler) {\n+\t\treturn ReplayProcessor.createSizeAndTimeout(historySize, maxAge, scheduler);\n+\t}\n+\n+\tstatic <T> Sink<T> toSink(Sink<T> sink, CoreSubscriber<T> contextHolder) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d171d8870cd3d3ee46d5fc06aac05b98ff3046d"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ0MjQ3Ng==", "bodyText": "rename to SerializedSinkWithContext ?", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r445442476", "createdAt": "2020-06-25T09:52:55Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/SinksHelper.java", "diffHunk": "@@ -0,0 +1,130 @@\n+package reactor.core.publisher;\n+\n+import reactor.core.CoreSubscriber;\n+import reactor.core.Disposable;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.util.annotation.Nullable;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.util.Queue;\n+import java.util.function.Consumer;\n+\n+final class SinksHelper implements Sinks.UnsafeSinks {\n+\tstatic final SinksHelper INSTANCE = new SinksHelper();\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> unicast() {\n+\t\treturn UnicastProcessor.create();\n+\t}\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> multicast() {\n+\t\treturn EmitterProcessor.create();\n+\t}\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> replayAll() {\n+\t\treturn ReplayProcessor.create();\n+\t}\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> replay(int historySize) {\n+\t\treturn ReplayProcessor.create(historySize);\n+\t}\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic  <T> Sink<T> replayTimeout(Duration maxAge) {\n+\t\treturn ReplayProcessor.createTimeout(maxAge);\n+\t}\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> replaySizeAndTimeout(int historySize, Duration maxAge) {\n+\t\treturn ReplayProcessor.createSizeAndTimeout(historySize, maxAge);\n+\t}\n+\n+\t// == unicast ==\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> unicast(Queue<T> queue) {\n+\t\treturn UnicastProcessor.create(queue);\n+\t}\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> unicast(Queue<T> queue, Disposable endCallback) {\n+\t\treturn UnicastProcessor.create(queue, endCallback);\n+\t}\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> unicast(Queue<T> queue, Consumer<? super T> onOverflow, Disposable endCallback) {\n+\t\treturn UnicastProcessor.create(queue, onOverflow, endCallback);\n+\t}\n+\n+\t// == direct (less used) ==\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> multicastNoBackpressure() {\n+\t\treturn DirectProcessor.create();\n+\t}\n+\n+\t// == emitter ==\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> multicast(boolean autoCancel) {\n+\t\treturn EmitterProcessor.create(autoCancel);\n+\t}\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> multicast(int bufferSize) {\n+\t\treturn EmitterProcessor.create(bufferSize);\n+\t}\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> multicast(int bufferSize, boolean autoCancel) {\n+\t\treturn EmitterProcessor.create(bufferSize, autoCancel);\n+\t}\n+\n+\t// == replay ==\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> replayLatest() {\n+\t\treturn ReplayProcessor.cacheLast();\n+\t}\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> replayLatestOrDefault(@Nullable T value) {\n+\t\treturn ReplayProcessor.cacheLastOrDefault(value);\n+\t}\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> replay(int historySize, boolean unbounded) {\n+\t\treturn ReplayProcessor.create(historySize, unbounded);\n+\t}\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> replayTimeout(Duration maxAge, Scheduler scheduler) {\n+\t\treturn ReplayProcessor.createTimeout(maxAge, scheduler);\n+\t}\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> replaySizeAndTimeout(int historySize, Duration maxAge, Scheduler scheduler) {\n+\t\treturn ReplayProcessor.createSizeAndTimeout(historySize, maxAge, scheduler);\n+\t}\n+\n+\tstatic <T> Sink<T> toSink(Sink<T> sink, CoreSubscriber<T> contextHolder) {\n+\t\treturn new FluxProcessorSink<>(sink, contextHolder);\n+\t}\n+\n+\tstatic final class FluxProcessorSink<T> extends FluxCreate.SerializedSink<T, Sink<T>> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d171d8870cd3d3ee46d5fc06aac05b98ff3046d"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ0ODYyNQ==", "bodyText": "since the sink isn't really used, can also be replaced with TestPublisher which makes it easier to assert subscribers:\n\t\tTestPublisher<Integer> testPublisher = TestPublisher.create();\n\n\t\ttestPublisher.flux().publish().autoConnect(0, cancel::set);\n\t\ttestPublisher.assertSubscribers();\n\t\t\n\t\tcancel.get().dispose();\n\t\ttestPublisher.assertNoSubscribers();", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r445448625", "createdAt": "2020-06-25T10:03:58Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/test/java/reactor/core/publisher/FluxAutoConnectTest.java", "diffHunk": "@@ -43,42 +43,42 @@ public void constructors() {\n \t\n \t@Test\n \tpublic void connectImmediately() {\n-\t\tFluxProcessor<Integer, Integer> e = Processors.multicast();\n+\t\tSink<Integer> e = Sinks.multicast();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d171d8870cd3d3ee46d5fc06aac05b98ff3046d"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ1MTg3MQ==", "bodyText": "let's use Sinks.multicast(), replay(0) being kind of a corner case.\nAlso change the corresponding snippet in the asciidoc!", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r445451871", "createdAt": "2020-06-25T10:10:02Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/test/java/reactor/guide/GuideTests.java", "diffHunk": "@@ -201,21 +201,20 @@ public void advancedCold() {\n \n \t@Test\n \tpublic void advancedHot() {\n-\t\tSink<String> hotSource = Sinks.multicastNoWarmup();\n+\t\tSink<String> hotSource = Sinks.replay(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d171d8870cd3d3ee46d5fc06aac05b98ff3046d"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ1MjQ0Ng==", "bodyText": "see comment on GuideTest.java", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r445452446", "createdAt": "2020-06-25T10:11:07Z", "author": {"login": "simonbasle"}, "path": "docs/asciidoc/advancedFeatures.adoc", "diffHunk": "@@ -193,7 +193,7 @@ Compare the first example to the second example, shown in the following code:\n ====\n [source,java]\n ----\n-Sink<String> hotSource = Sinks.multicastNoWarmup();\n+Sink<String> hotSource = Sinks.replay(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d171d8870cd3d3ee46d5fc06aac05b98ff3046d"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ1NDA3MA==", "bodyText": "Add a note that it is better suited to be viewed as a toMono() ?", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r445454070", "createdAt": "2020-06-25T10:14:14Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/Sinks.java", "diffHunk": "@@ -47,25 +53,37 @@ private Sinks() { }\n \t */\n \t@SuppressWarnings(\"deprecation\")\n \tpublic static <T> Sink<T> multicast() {\n-\t\treturn new ProcessorSink<>(EmitterProcessor.create(Queues.SMALL_BUFFER_SIZE));\n+\t\tEmitterProcessor<T> processor = EmitterProcessor.create(Queues.SMALL_BUFFER_SIZE);\n+\t\treturn SinksHelper.toSink(processor, processor);\n \t}\n \n \t/**\n \t * A {@link Sink} with the following characteristics:\n \t * <ul>\n \t *     <li>Multicast</li>\n-\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n+\t *     <li>Backpressure : this sink is not able to honor downstream demand and will emit `onError` if there is a mismatch.</li>\n \t *     <li>Replaying: No replay. Only forwards to a {@link Subscriber} the elements that have been\n-\t *     pushed to the sink AFTER this subscriber was subscribed.</li>\n-\t *     <li>Without {@link Subscriber}: Discarding. Pushing elements while there are no {@link Subscriber}\n-\t *     registered will simply discard these elements instead of \"warming up\" the sink.</li>\n+\t *     pushed to the sink AFTER this subscriber was subscribed. To the exception of the first\n+\t *     subscribe.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> Sink<T> multicastNoBackpressure() {\n+\t\tDirectProcessor<T> processor = DirectProcessor.create();\n+\t\treturn SinksHelper.toSink(processor, processor);\n+\t}\n+\n+\t/**\n+\t * A {@link Sink} with the following characteristics:\n+\t * <ul>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d171d8870cd3d3ee46d5fc06aac05b98ff3046d"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ1NTAwOQ==", "bodyText": "put it next to promise, as both behave closer to Mono. That makes me wonder if it would be better backed by a MonoProcessor? likely to be used as toMono() more often and thus benefit from the 0-overhead conversion? or maybe add a constructor parameter to DirectProcessor that allows its toMono() method to do Mono.fromDirect(this) rather than next()?", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r445455009", "createdAt": "2020-06-25T10:16:03Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/Sinks.java", "diffHunk": "@@ -47,25 +53,37 @@ private Sinks() { }\n \t */\n \t@SuppressWarnings(\"deprecation\")\n \tpublic static <T> Sink<T> multicast() {\n-\t\treturn new ProcessorSink<>(EmitterProcessor.create(Queues.SMALL_BUFFER_SIZE));\n+\t\tEmitterProcessor<T> processor = EmitterProcessor.create(Queues.SMALL_BUFFER_SIZE);\n+\t\treturn SinksHelper.toSink(processor, processor);\n \t}\n \n \t/**\n \t * A {@link Sink} with the following characteristics:\n \t * <ul>\n \t *     <li>Multicast</li>\n-\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n+\t *     <li>Backpressure : this sink is not able to honor downstream demand and will emit `onError` if there is a mismatch.</li>\n \t *     <li>Replaying: No replay. Only forwards to a {@link Subscriber} the elements that have been\n-\t *     pushed to the sink AFTER this subscriber was subscribed.</li>\n-\t *     <li>Without {@link Subscriber}: Discarding. Pushing elements while there are no {@link Subscriber}\n-\t *     registered will simply discard these elements instead of \"warming up\" the sink.</li>\n+\t *     pushed to the sink AFTER this subscriber was subscribed. To the exception of the first\n+\t *     subscribe.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> Sink<T> multicastNoBackpressure() {\n+\t\tDirectProcessor<T> processor = DirectProcessor.create();\n+\t\treturn SinksHelper.toSink(processor, processor);\n+\t}\n+\n+\t/**\n+\t * A {@link Sink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink does not need any demand since it can only signal error or completion</li>\n+\t *     <li>Replaying: Replay the terminal signal (error or complete).</li>\n \t * </ul>\n-\t * <p>\n-\t * <img class=\"marble\" src=\"doc-files/marbles/sinkNoWarmup.svg\" alt=\"\">\n \t */\n \t@SuppressWarnings(\"deprecation\")\n-\tpublic static <T> Sink<T> multicastNoWarmup() {\n-\t\treturn new ProcessorSink<>(ReplayProcessor.create(0));\n+\tpublic static Sink<Void> coordinator() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d171d8870cd3d3ee46d5fc06aac05b98ff3046d"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ1NTI1MQ==", "bodyText": "add  (which is implicit). at the end", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r445455251", "createdAt": "2020-06-25T10:16:29Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/Sinks.java", "diffHunk": "@@ -112,92 +132,73 @@ private Sinks() { }\n \t */\n \t@SuppressWarnings(\"deprecation\")\n \tpublic static <T> Sink<T> unicast() {\n-\t\treturn new ProcessorSink<>(UnicastProcessor.create());\n+\t\tUnicastProcessor<T> processor = UnicastProcessor.create();\n+\t\treturn SinksHelper.toSink(processor, processor);\n \t}\n \n \t/**\n \t * A {@link Sink} that works like a conceptual Promise: it can be completed\n \t * with or without a value at any time, but only once. This completion is replayed to late subscribers.\n-\t * Calling {@link Sink#next(Object)} is enough and does not require a following {@link Sink#complete()}.\n+\t * Calling {@link Sink#emitNext(Object)} is enough and does not require a following {@link Sink#emitComplete()}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d171d8870cd3d3ee46d5fc06aac05b98ff3046d"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ1NTc4NQ==", "bodyText": "also add that as a result the Sinks closely follows the Mono contract and is better suited to be viewed as toMono() (hinting at 0-overhead conversion to mono vs overhead conversion to flux)", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r445455785", "createdAt": "2020-06-25T10:17:29Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/Sinks.java", "diffHunk": "@@ -112,92 +132,73 @@ private Sinks() { }\n \t */\n \t@SuppressWarnings(\"deprecation\")\n \tpublic static <T> Sink<T> unicast() {\n-\t\treturn new ProcessorSink<>(UnicastProcessor.create());\n+\t\tUnicastProcessor<T> processor = UnicastProcessor.create();\n+\t\treturn SinksHelper.toSink(processor, processor);\n \t}\n \n \t/**\n \t * A {@link Sink} that works like a conceptual Promise: it can be completed\n \t * with or without a value at any time, but only once. This completion is replayed to late subscribers.\n-\t * Calling {@link Sink#next(Object)} is enough and does not require a following {@link Sink#complete()}.\n+\t * Calling {@link Sink#emitNext(Object)} is enough and does not require a following {@link Sink#emitComplete()}.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ1NTI1MQ=="}, "originalCommit": {"oid": "3d171d8870cd3d3ee46d5fc06aac05b98ff3046d"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ1NjIxMw==", "bodyText": "change to \"and expect usage to be externally synchronized so as to respect\"", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r445456213", "createdAt": "2020-06-25T10:18:23Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/Sinks.java", "diffHunk": "@@ -112,92 +132,73 @@ private Sinks() { }\n \t */\n \t@SuppressWarnings(\"deprecation\")\n \tpublic static <T> Sink<T> unicast() {\n-\t\treturn new ProcessorSink<>(UnicastProcessor.create());\n+\t\tUnicastProcessor<T> processor = UnicastProcessor.create();\n+\t\treturn SinksHelper.toSink(processor, processor);\n \t}\n \n \t/**\n \t * A {@link Sink} that works like a conceptual Promise: it can be completed\n \t * with or without a value at any time, but only once. This completion is replayed to late subscribers.\n-\t * Calling {@link Sink#next(Object)} is enough and does not require a following {@link Sink#complete()}.\n+\t * Calling {@link Sink#emitNext(Object)} is enough and does not require a following {@link Sink#emitComplete()}.\n \t */\n \tpublic static <T> Sink<T> promise() {\n-\t\treturn new MonoProcessorSink<>(MonoProcessor.create());\n+\t\treturn MonoProcessor.create();\n \t}\n \n-\t// == concrete classes ==\n-\n-\tstatic final class ProcessorSink<T>\n-\t\t\timplements Sink<T> {\n-\n-\t\tfinal FluxSink<T>         delegateSink;\n-\t\tfinal FluxProcessor<T, T> processor;\n-\n-\t\t@SuppressWarnings(\"deprecation\")\n-\t\tProcessorSink(FluxProcessor<T, T> processor) {\n-\t\t\tthis.processor = processor;\n-\t\t\tthis.delegateSink = processor.sink();\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic Flux<T> toFlux() {\n-\t\t\treturn Flux.from(processor);\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic Mono<T> toMono() {\n-\t\t\treturn Mono.from(processor);\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void complete() {\n-\t\t\tdelegateSink.complete();\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void error(Throwable e) {\n-\t\t\tdelegateSink.error(e);\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic Sink<T> next(T t) {\n-\t\t\tdelegateSink.next(t);\n-\t\t\treturn this;\n-\t\t}\n+\t/**\n+\t * Return unsafe {@link Sink} that are not serialized and expect the signal producer to respect", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d171d8870cd3d3ee46d5fc06aac05b98ff3046d"}, "originalPosition": 143}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "cce9eda630e0fe43179e5f2c15ac37fb119f792b", "author": {"user": {"login": "smaldini", "name": "Stephane Maldini"}}, "url": "https://github.com/reactor/reactor-core/commit/cce9eda630e0fe43179e5f2c15ac37fb119f792b", "committedDate": "2020-07-01T00:01:57Z", "message": "Add Sinks builders and address some PR feedback\n- Reuse onBackpressureXxx naming conventions\n- deprecate FluxProcessor#switchOnNext\n- add FluxProcessor#isIdentityProcessor\n- add FluxProcessor#fromSink"}, "afterCommit": {"oid": "5981100d27d02470de0b807433e63042353be2d0", "author": {"user": {"login": "smaldini", "name": "Stephane Maldini"}}, "url": "https://github.com/reactor/reactor-core/commit/5981100d27d02470de0b807433e63042353be2d0", "committedDate": "2020-07-01T01:36:05Z", "message": "Add Sinks builders and address some PR feedback\n- Reuse onBackpressureXxx naming conventions\n- deprecate FluxProcessor#switchOnNext\n- add FluxProcessor#isIdentityProcessor\n- add FluxProcessor#fromSink"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxNjk0MTI3", "url": "https://github.com/reactor/reactor-core/pull/2218#pullrequestreview-441694127", "createdAt": "2020-07-02T13:46:35Z", "commit": {"oid": "5981100d27d02470de0b807433e63042353be2d0"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMzo0NjozNVrOGsNnnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNDo1NDo0MFrOGsQg-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAxMzY2MQ==", "bodyText": "shouldn't it be downstream?", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r449013661", "createdAt": "2020-07-02T13:46:35Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/DelegateSinkFluxProcessor.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Copyright (c) 2011-2017 Pivotal Software Inc, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package reactor.core.publisher;\n+\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.Scannable;\n+import reactor.util.annotation.Nullable;\n+import reactor.util.context.Context;\n+\n+import java.util.Objects;\n+import java.util.stream.Stream;\n+\n+/**\n+ * @author Stephane Maldini\n+ */\n+final class DelegateSinkFluxProcessor<IN> extends FluxProcessor<IN, IN> {\n+\n+\tfinal Flux<IN> downstream;\n+\tfinal Sink<IN> upstream;\n+\n+\tDelegateSinkFluxProcessor(Flux<IN> downstream,\n+\t\t\t\t\t\t\t  Sink<IN> upstream) {\n+\t\tthis.downstream = Objects.requireNonNull(downstream, \"Downstream must not be null\");\n+\t\tthis.upstream = Objects.requireNonNull(upstream, \"Upstream must not be null\");\n+\t}\n+\n+\t@Override\n+\tpublic Context currentContext() {\n+\t\tif(upstream instanceof CoreSubscriber){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5981100d27d02470de0b807433e63042353be2d0"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAxNTI4OQ==", "bodyText": "there seem to be a reversion of downstream and upstream terms compared to their usual meaning, maybe different terms would be better. ie do we expect the downstream to basically be the same as Sink.toFlux() ?", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r449015289", "createdAt": "2020-07-02T13:48:49Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/DelegateSinkFluxProcessor.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Copyright (c) 2011-2017 Pivotal Software Inc, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package reactor.core.publisher;\n+\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.Scannable;\n+import reactor.util.annotation.Nullable;\n+import reactor.util.context.Context;\n+\n+import java.util.Objects;\n+import java.util.stream.Stream;\n+\n+/**\n+ * @author Stephane Maldini\n+ */\n+final class DelegateSinkFluxProcessor<IN> extends FluxProcessor<IN, IN> {\n+\n+\tfinal Flux<IN> downstream;\n+\tfinal Sink<IN> upstream;\n+\n+\tDelegateSinkFluxProcessor(Flux<IN> downstream,\n+\t\t\t\t\t\t\t  Sink<IN> upstream) {\n+\t\tthis.downstream = Objects.requireNonNull(downstream, \"Downstream must not be null\");\n+\t\tthis.upstream = Objects.requireNonNull(upstream, \"Upstream must not be null\");\n+\t}\n+\n+\t@Override\n+\tpublic Context currentContext() {\n+\t\tif(upstream instanceof CoreSubscriber){", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAxMzY2MQ=="}, "originalCommit": {"oid": "5981100d27d02470de0b807433e63042353be2d0"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAyMTI3NA==", "bodyText": "nitpick: this looks like - 1 (a subtraction): replace with\nProvide unicast sinks: at most one `Subscriber` per `Sink`", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r449021274", "createdAt": "2020-07-02T13:57:20Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/Sinks.java", "diffHunk": "@@ -87,118 +78,315 @@ private Sinks() { }\n \t}\n \n \t/**\n-\t * A {@link Sink} with the following characteristics:\n-\t * <ul>\n-\t *     <li>Multicast</li>\n-\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n-\t *     <li>Replaying: by {@code historySize}. Keeps the last {@code historySize} elements and\n-\t *     replays them instantly to new subscribers before continuing with \"live\" elements.</li>\n-\t *     <li>Without {@link Subscriber}: buffers enough elements pushed without a subscriber to\n-\t *     honor the {@code historySize}.</li>\n-\t * </ul>\n+\t * A {@link Sink} that works like a conceptual Promise: it can be completed\n+\t * with or without a value at any time, but only once. This completion is replayed to late subscribers.\n+\t * Calling {@link Sink#emitNext(Object)} is enough and will implicitly produce a follow-up {@link Sink#emitComplete()}.\n+\t * As a result the Sink closely follows the {@link Mono} contract and is better suited to be consumed via {@link Sink#toMono}\n \t */\n-\t@SuppressWarnings(\"deprecation\")\n-\tpublic static <T> Sink<T> replay(int historySize) {\n-\t\tReplayProcessor<T> processor = ReplayProcessor.create(historySize);\n-\t\treturn SinksHelper.toSink(processor, processor);\n+\tpublic static <T> Sink<T> promise() {\n+\t\treturn MonoProcessor.create();\n \t}\n \n \t/**\n-\t * A {@link Sink} with the following characteristics:\n-\t * <ul>\n-\t *     <li>Multicast</li>\n-\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n-\t *     <li>Replaying: all elements pushed to this sink are replayed to new subscribers.</li>\n-\t *     <li>Without {@link Subscriber}: all elements pushed to this sink are remembered,\n-\t *     even when there is no subscriber.</li>\n-\t * </ul>\n+\t * Return a builder for more advanced use cases such as building operators.\n+\t * Unsafe {@link Sink} are not serialized and expect usage to be externally synchronized to respect\n+\t * the Reactive Streams specification. The builder also allows to create {@link FluxProcessor} and {@link MonoProcessor}.\n+\t *\n+\t * @return {@link UnsafeSpec}\n \t */\n-\t@SuppressWarnings(\"deprecation\")\n-\tpublic static <T> Sink<T> replayAll() {\n-\t\tReplayProcessor<T> processor = ReplayProcessor.create();\n-\t\treturn SinksHelper.toSink(processor, processor);\n+\tpublic static UnsafeSpec unsafe() {\n+\t\treturn SinksSpecs.UNSAFE_SPEC;\n \t}\n \n \t/**\n-\t * A {@link Sink} with the following characteristics:\n-\t * <ul>\n-\t *     <li><strong>Unicast</strong>: contrary to most other {@link Sink}, the\n-\t *     {@link Flux} view rejects {@link Subscriber subscribers} past the first one.</li>\n-\t *     <li>Backpressure : this sink honors downstream demand of its single {@link Subscriber}.</li>\n-\t *     <li>Replaying: non-applicable, since only one {@link Subscriber} can register.</li>\n-\t *     <li>Without {@link Subscriber}: all elements pushed to this sink are remembered and will\n-\t *     be replayed once the {@link Subscriber} subscribes.</li>\n-\t * </ul>\n+\t * A builder for more advanced use cases such as building operators.\n+\t * Unsafe {@link Sink} are not serialized and expect usage to be externally synchronized to respect\n+\t * the Reactive Streams specification. The builder also allows to create {@link FluxProcessor} and {@link MonoProcessor}.\n \t */\n-\t@SuppressWarnings(\"deprecation\")\n-\tpublic static <T> Sink<T> unicast() {\n-\t\tUnicastProcessor<T> processor = UnicastProcessor.create();\n-\t\treturn SinksHelper.toSink(processor, processor);\n+\tpublic interface UnsafeSpec {\n+\t\t/**\n+\t\t * Help building {@link Sink} that will broadcast signals to a single {@link Subscriber}\n+\t\t *\n+\t\t * @return {@link UnicastSpec}\n+\t\t */\n+\t\tUnicastSpec unicast();\n+\n+\t\t/**\n+\t\t * Help building {@link Sink} that will broadcast signals to multiple {@link Subscriber}\n+\t\t *\n+\t\t * @return {@link MulticastSpec}\n+\t\t */\n+\t\tMulticastSpec multicast();\n+\n+\t\t/**\n+\t\t * Help building {@link Sink} that will broadcast signals to multiple {@link Subscriber} with the ability to retain\n+\t\t * and replay all or an arbitrary number of elements.\n+\t\t *\n+\t\t * @return {@link MulticastReplaySpec}\n+\t\t */\n+\t\tMulticastReplaySpec replay();\n \t}\n \n \t/**\n-\t * A {@link Sink} that works like a conceptual Promise: it can be completed\n-\t * with or without a value at any time, but only once. This completion is replayed to late subscribers.\n-\t * Calling {@link Sink#emitNext(Object)} is enough and does not require a following {@link Sink#emitComplete()}.\n+\t * Provide unicast - 1 sink, 1 {@link Subscriber}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5981100d27d02470de0b807433e63042353be2d0"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAyMTc1NQ==", "bodyText": "same phrasing remark as above", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r449021755", "createdAt": "2020-07-02T13:58:00Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/Sinks.java", "diffHunk": "@@ -87,118 +78,315 @@ private Sinks() { }\n \t}\n \n \t/**\n-\t * A {@link Sink} with the following characteristics:\n-\t * <ul>\n-\t *     <li>Multicast</li>\n-\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n-\t *     <li>Replaying: by {@code historySize}. Keeps the last {@code historySize} elements and\n-\t *     replays them instantly to new subscribers before continuing with \"live\" elements.</li>\n-\t *     <li>Without {@link Subscriber}: buffers enough elements pushed without a subscriber to\n-\t *     honor the {@code historySize}.</li>\n-\t * </ul>\n+\t * A {@link Sink} that works like a conceptual Promise: it can be completed\n+\t * with or without a value at any time, but only once. This completion is replayed to late subscribers.\n+\t * Calling {@link Sink#emitNext(Object)} is enough and will implicitly produce a follow-up {@link Sink#emitComplete()}.\n+\t * As a result the Sink closely follows the {@link Mono} contract and is better suited to be consumed via {@link Sink#toMono}\n \t */\n-\t@SuppressWarnings(\"deprecation\")\n-\tpublic static <T> Sink<T> replay(int historySize) {\n-\t\tReplayProcessor<T> processor = ReplayProcessor.create(historySize);\n-\t\treturn SinksHelper.toSink(processor, processor);\n+\tpublic static <T> Sink<T> promise() {\n+\t\treturn MonoProcessor.create();\n \t}\n \n \t/**\n-\t * A {@link Sink} with the following characteristics:\n-\t * <ul>\n-\t *     <li>Multicast</li>\n-\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n-\t *     <li>Replaying: all elements pushed to this sink are replayed to new subscribers.</li>\n-\t *     <li>Without {@link Subscriber}: all elements pushed to this sink are remembered,\n-\t *     even when there is no subscriber.</li>\n-\t * </ul>\n+\t * Return a builder for more advanced use cases such as building operators.\n+\t * Unsafe {@link Sink} are not serialized and expect usage to be externally synchronized to respect\n+\t * the Reactive Streams specification. The builder also allows to create {@link FluxProcessor} and {@link MonoProcessor}.\n+\t *\n+\t * @return {@link UnsafeSpec}\n \t */\n-\t@SuppressWarnings(\"deprecation\")\n-\tpublic static <T> Sink<T> replayAll() {\n-\t\tReplayProcessor<T> processor = ReplayProcessor.create();\n-\t\treturn SinksHelper.toSink(processor, processor);\n+\tpublic static UnsafeSpec unsafe() {\n+\t\treturn SinksSpecs.UNSAFE_SPEC;\n \t}\n \n \t/**\n-\t * A {@link Sink} with the following characteristics:\n-\t * <ul>\n-\t *     <li><strong>Unicast</strong>: contrary to most other {@link Sink}, the\n-\t *     {@link Flux} view rejects {@link Subscriber subscribers} past the first one.</li>\n-\t *     <li>Backpressure : this sink honors downstream demand of its single {@link Subscriber}.</li>\n-\t *     <li>Replaying: non-applicable, since only one {@link Subscriber} can register.</li>\n-\t *     <li>Without {@link Subscriber}: all elements pushed to this sink are remembered and will\n-\t *     be replayed once the {@link Subscriber} subscribes.</li>\n-\t * </ul>\n+\t * A builder for more advanced use cases such as building operators.\n+\t * Unsafe {@link Sink} are not serialized and expect usage to be externally synchronized to respect\n+\t * the Reactive Streams specification. The builder also allows to create {@link FluxProcessor} and {@link MonoProcessor}.\n \t */\n-\t@SuppressWarnings(\"deprecation\")\n-\tpublic static <T> Sink<T> unicast() {\n-\t\tUnicastProcessor<T> processor = UnicastProcessor.create();\n-\t\treturn SinksHelper.toSink(processor, processor);\n+\tpublic interface UnsafeSpec {\n+\t\t/**\n+\t\t * Help building {@link Sink} that will broadcast signals to a single {@link Subscriber}\n+\t\t *\n+\t\t * @return {@link UnicastSpec}\n+\t\t */\n+\t\tUnicastSpec unicast();\n+\n+\t\t/**\n+\t\t * Help building {@link Sink} that will broadcast signals to multiple {@link Subscriber}\n+\t\t *\n+\t\t * @return {@link MulticastSpec}\n+\t\t */\n+\t\tMulticastSpec multicast();\n+\n+\t\t/**\n+\t\t * Help building {@link Sink} that will broadcast signals to multiple {@link Subscriber} with the ability to retain\n+\t\t * and replay all or an arbitrary number of elements.\n+\t\t *\n+\t\t * @return {@link MulticastReplaySpec}\n+\t\t */\n+\t\tMulticastReplaySpec replay();\n \t}\n \n \t/**\n-\t * A {@link Sink} that works like a conceptual Promise: it can be completed\n-\t * with or without a value at any time, but only once. This completion is replayed to late subscribers.\n-\t * Calling {@link Sink#emitNext(Object)} is enough and does not require a following {@link Sink#emitComplete()}.\n+\t * Provide unicast - 1 sink, 1 {@link Subscriber}\n \t */\n-\tpublic static <T> Sink<T> promise() {\n-\t\treturn MonoProcessor.create();\n+\tpublic interface UnicastSpec {\n+\t\t/**\n+\t\t * A {@link Sink} with the following characteristics:\n+\t\t * <ul>\n+\t\t *     <li><strong>Unicast</strong>: contrary to most other {@link Sink}, the\n+\t\t *     {@link Flux} view rejects {@link Subscriber subscribers} past the first one.</li>\n+\t\t *     <li>Backpressure : this sink honors downstream demand of its single {@link Subscriber}.</li>\n+\t\t *     <li>Replaying: non-applicable, since only one {@link Subscriber} can register.</li>\n+\t\t *     <li>Without {@link Subscriber}: all elements pushed to this sink are remembered and will\n+\t\t *     be replayed once the {@link Subscriber} subscribes.</li>\n+\t\t * </ul>\n+\t\t */\n+\t\t<T> Sink<T> onBackpressureBuffer();\n+\n+\t\t/**\n+\t\t * A {@link Sink} with the following characteristics:\n+\t\t * <ul>\n+\t\t *     <li><strong>Unicast</strong>: contrary to most other {@link Sink}, the\n+\t\t *     {@link Flux} view rejects {@link Subscriber subscribers} past the first one.</li>\n+\t\t *     <li>Backpressure : this sink honors downstream demand of its single {@link Subscriber}.</li>\n+\t\t *     <li>Replaying: non-applicable, since only one {@link Subscriber} can register.</li>\n+\t\t *    <li>Without {@link Subscriber}: depending on the queue, all elements pushed to this sink are remembered and will\n+\t\t * \t\t  be replayed once the {@link Subscriber} subscribes.</li>\n+\t\t * </ul>\n+\t\t *\n+\t\t * @param queue an arbitrary queue to use that must at least support Single Producer / Single Consumer semantics\n+\t\t */\n+\t\t<T> Sink<T> onBackpressureBuffer(Queue<T> queue);\n+\n+\t\t/**\n+\t\t * A {@link Sink} with the following characteristics:\n+\t\t * <ul>\n+\t\t *     <li><strong>Unicast</strong>: contrary to most other {@link Sink}, the\n+\t\t *     {@link Flux} view rejects {@link Subscriber subscribers} past the first one.</li>\n+\t\t *     <li>Backpressure : this sink honors downstream demand of its single {@link Subscriber}.</li>\n+\t\t *     <li>Replaying: non-applicable, since only one {@link Subscriber} can register.</li>\n+\t\t *     <li>Without {@link Subscriber}: depending on the queue, all elements pushed to this sink are remembered and will\n+\t\t *     be replayed once the {@link Subscriber} subscribes.</li>\n+\t\t * </ul>\n+\t\t *\n+\t\t * @param queue an arbitrary queue to use that must at least support Single Producer / Single Consumer semantics\n+\t\t * @param endCallback when a terminal signal is observed: error, complete or cancel\n+\t\t */\n+\t\t<T> Sink<T> onBackpressureBuffer(Queue<T> queue, Disposable endCallback);\n \t}\n \n \t/**\n-\t * Return unsafe {@link Sink} that are not serialized and expect the signal producer to respect\n-\t * the Reactive Streams specification.\n-\t *\n-\t * @return {@link UnsafeSinks}\n+\t * Provide multicast - 1 sink, N {@link Subscriber}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5981100d27d02470de0b807433e63042353be2d0"}, "originalPosition": 224}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAyMjgyNA==", "bodyText": "According to the javadoc above, there is no exception for the first subscribe (elements are discarded if pushed before any Subscriber) => the last sentence should be removed", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r449022824", "createdAt": "2020-07-02T13:59:35Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/Sinks.java", "diffHunk": "@@ -87,118 +78,315 @@ private Sinks() { }\n \t}\n \n \t/**\n-\t * A {@link Sink} with the following characteristics:\n-\t * <ul>\n-\t *     <li>Multicast</li>\n-\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n-\t *     <li>Replaying: by {@code historySize}. Keeps the last {@code historySize} elements and\n-\t *     replays them instantly to new subscribers before continuing with \"live\" elements.</li>\n-\t *     <li>Without {@link Subscriber}: buffers enough elements pushed without a subscriber to\n-\t *     honor the {@code historySize}.</li>\n-\t * </ul>\n+\t * A {@link Sink} that works like a conceptual Promise: it can be completed\n+\t * with or without a value at any time, but only once. This completion is replayed to late subscribers.\n+\t * Calling {@link Sink#emitNext(Object)} is enough and will implicitly produce a follow-up {@link Sink#emitComplete()}.\n+\t * As a result the Sink closely follows the {@link Mono} contract and is better suited to be consumed via {@link Sink#toMono}\n \t */\n-\t@SuppressWarnings(\"deprecation\")\n-\tpublic static <T> Sink<T> replay(int historySize) {\n-\t\tReplayProcessor<T> processor = ReplayProcessor.create(historySize);\n-\t\treturn SinksHelper.toSink(processor, processor);\n+\tpublic static <T> Sink<T> promise() {\n+\t\treturn MonoProcessor.create();\n \t}\n \n \t/**\n-\t * A {@link Sink} with the following characteristics:\n-\t * <ul>\n-\t *     <li>Multicast</li>\n-\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n-\t *     <li>Replaying: all elements pushed to this sink are replayed to new subscribers.</li>\n-\t *     <li>Without {@link Subscriber}: all elements pushed to this sink are remembered,\n-\t *     even when there is no subscriber.</li>\n-\t * </ul>\n+\t * Return a builder for more advanced use cases such as building operators.\n+\t * Unsafe {@link Sink} are not serialized and expect usage to be externally synchronized to respect\n+\t * the Reactive Streams specification. The builder also allows to create {@link FluxProcessor} and {@link MonoProcessor}.\n+\t *\n+\t * @return {@link UnsafeSpec}\n \t */\n-\t@SuppressWarnings(\"deprecation\")\n-\tpublic static <T> Sink<T> replayAll() {\n-\t\tReplayProcessor<T> processor = ReplayProcessor.create();\n-\t\treturn SinksHelper.toSink(processor, processor);\n+\tpublic static UnsafeSpec unsafe() {\n+\t\treturn SinksSpecs.UNSAFE_SPEC;\n \t}\n \n \t/**\n-\t * A {@link Sink} with the following characteristics:\n-\t * <ul>\n-\t *     <li><strong>Unicast</strong>: contrary to most other {@link Sink}, the\n-\t *     {@link Flux} view rejects {@link Subscriber subscribers} past the first one.</li>\n-\t *     <li>Backpressure : this sink honors downstream demand of its single {@link Subscriber}.</li>\n-\t *     <li>Replaying: non-applicable, since only one {@link Subscriber} can register.</li>\n-\t *     <li>Without {@link Subscriber}: all elements pushed to this sink are remembered and will\n-\t *     be replayed once the {@link Subscriber} subscribes.</li>\n-\t * </ul>\n+\t * A builder for more advanced use cases such as building operators.\n+\t * Unsafe {@link Sink} are not serialized and expect usage to be externally synchronized to respect\n+\t * the Reactive Streams specification. The builder also allows to create {@link FluxProcessor} and {@link MonoProcessor}.\n \t */\n-\t@SuppressWarnings(\"deprecation\")\n-\tpublic static <T> Sink<T> unicast() {\n-\t\tUnicastProcessor<T> processor = UnicastProcessor.create();\n-\t\treturn SinksHelper.toSink(processor, processor);\n+\tpublic interface UnsafeSpec {\n+\t\t/**\n+\t\t * Help building {@link Sink} that will broadcast signals to a single {@link Subscriber}\n+\t\t *\n+\t\t * @return {@link UnicastSpec}\n+\t\t */\n+\t\tUnicastSpec unicast();\n+\n+\t\t/**\n+\t\t * Help building {@link Sink} that will broadcast signals to multiple {@link Subscriber}\n+\t\t *\n+\t\t * @return {@link MulticastSpec}\n+\t\t */\n+\t\tMulticastSpec multicast();\n+\n+\t\t/**\n+\t\t * Help building {@link Sink} that will broadcast signals to multiple {@link Subscriber} with the ability to retain\n+\t\t * and replay all or an arbitrary number of elements.\n+\t\t *\n+\t\t * @return {@link MulticastReplaySpec}\n+\t\t */\n+\t\tMulticastReplaySpec replay();\n \t}\n \n \t/**\n-\t * A {@link Sink} that works like a conceptual Promise: it can be completed\n-\t * with or without a value at any time, but only once. This completion is replayed to late subscribers.\n-\t * Calling {@link Sink#emitNext(Object)} is enough and does not require a following {@link Sink#emitComplete()}.\n+\t * Provide unicast - 1 sink, 1 {@link Subscriber}\n \t */\n-\tpublic static <T> Sink<T> promise() {\n-\t\treturn MonoProcessor.create();\n+\tpublic interface UnicastSpec {\n+\t\t/**\n+\t\t * A {@link Sink} with the following characteristics:\n+\t\t * <ul>\n+\t\t *     <li><strong>Unicast</strong>: contrary to most other {@link Sink}, the\n+\t\t *     {@link Flux} view rejects {@link Subscriber subscribers} past the first one.</li>\n+\t\t *     <li>Backpressure : this sink honors downstream demand of its single {@link Subscriber}.</li>\n+\t\t *     <li>Replaying: non-applicable, since only one {@link Subscriber} can register.</li>\n+\t\t *     <li>Without {@link Subscriber}: all elements pushed to this sink are remembered and will\n+\t\t *     be replayed once the {@link Subscriber} subscribes.</li>\n+\t\t * </ul>\n+\t\t */\n+\t\t<T> Sink<T> onBackpressureBuffer();\n+\n+\t\t/**\n+\t\t * A {@link Sink} with the following characteristics:\n+\t\t * <ul>\n+\t\t *     <li><strong>Unicast</strong>: contrary to most other {@link Sink}, the\n+\t\t *     {@link Flux} view rejects {@link Subscriber subscribers} past the first one.</li>\n+\t\t *     <li>Backpressure : this sink honors downstream demand of its single {@link Subscriber}.</li>\n+\t\t *     <li>Replaying: non-applicable, since only one {@link Subscriber} can register.</li>\n+\t\t *    <li>Without {@link Subscriber}: depending on the queue, all elements pushed to this sink are remembered and will\n+\t\t * \t\t  be replayed once the {@link Subscriber} subscribes.</li>\n+\t\t * </ul>\n+\t\t *\n+\t\t * @param queue an arbitrary queue to use that must at least support Single Producer / Single Consumer semantics\n+\t\t */\n+\t\t<T> Sink<T> onBackpressureBuffer(Queue<T> queue);\n+\n+\t\t/**\n+\t\t * A {@link Sink} with the following characteristics:\n+\t\t * <ul>\n+\t\t *     <li><strong>Unicast</strong>: contrary to most other {@link Sink}, the\n+\t\t *     {@link Flux} view rejects {@link Subscriber subscribers} past the first one.</li>\n+\t\t *     <li>Backpressure : this sink honors downstream demand of its single {@link Subscriber}.</li>\n+\t\t *     <li>Replaying: non-applicable, since only one {@link Subscriber} can register.</li>\n+\t\t *     <li>Without {@link Subscriber}: depending on the queue, all elements pushed to this sink are remembered and will\n+\t\t *     be replayed once the {@link Subscriber} subscribes.</li>\n+\t\t * </ul>\n+\t\t *\n+\t\t * @param queue an arbitrary queue to use that must at least support Single Producer / Single Consumer semantics\n+\t\t * @param endCallback when a terminal signal is observed: error, complete or cancel\n+\t\t */\n+\t\t<T> Sink<T> onBackpressureBuffer(Queue<T> queue, Disposable endCallback);\n \t}\n \n \t/**\n-\t * Return unsafe {@link Sink} that are not serialized and expect the signal producer to respect\n-\t * the Reactive Streams specification.\n-\t *\n-\t * @return {@link UnsafeSinks}\n+\t * Provide multicast - 1 sink, N {@link Subscriber}\n \t */\n-\tpublic static UnsafeSinks unsafe() {\n-\t\treturn SinksHelper.INSTANCE;\n+\tpublic interface MulticastSpec {\n+\n+\t\t/**\n+\t\t * A {@link Sink} with the following characteristics:\n+\t\t * <ul>\n+\t\t *     <li>Multicast</li>\n+\t\t *     <li>Without {@link Subscriber}: warm up. Remembers up to {@link Queues#SMALL_BUFFER_SIZE}\n+\t\t *     elements pushed via {@link Sink#emitNext(Object)} before the first {@link Subscriber} is registered.</li>\n+\t\t *     <li>Backpressure : this sink honors downstream demand by conforming to the lowest demand in case\n+\t\t *     of multiple subscribers.</li>\n+\t\t *     <li>Replaying: No replay. Only forwards to a {@link Subscriber} the elements that have been\n+\t\t *     pushed to the sink AFTER this subscriber was subscribed. To the exception of the first\n+\t\t *     subscriber (see below).</li>\n+\t\t * </ul>\n+\t\t * <p>\n+\t\t * <img class=\"marble\" src=\"doc-files/marbles/sinkWarmup.svg\" alt=\"\">\n+\t\t */\n+\t\t<T> Sink<T> onBackpressureBuffer();\n+\n+\t\t/**\n+\t\t * A {@link Sink} with the following characteristics:\n+\t\t * <ul>\n+\t\t *     <li>Multicast</li>\n+\t\t *     <li>Without {@link Subscriber}: warm up. Remembers up to {@param bufferSize}\n+\t\t *     elements pushed via {@link Sink#emitNext(Object)} before the first {@link Subscriber} is registered.</li>\n+\t\t *     <li>Backpressure : this sink honors downstream demand by conforming to the lowest demand in case\n+\t\t *     of multiple subscribers.</li>\n+\t\t *     <li>Replaying: No replay. Only forwards to a {@link Subscriber} the elements that have been\n+\t\t *     pushed to the sink AFTER this subscriber was subscribed. To the exception of the first\n+\t\t *     subscriber (see below).</li>\n+\t\t * </ul>\n+\t\t * <p>\n+\t\t * <img class=\"marble\" src=\"doc-files/marbles/sinkWarmup.svg\" alt=\"\">\n+\t\t *\n+\t\t * @param bufferSize the maximum queue size\n+\t\t */\n+\t\t<T> Sink<T> onBackpressureBuffer(int bufferSize);\n+\n+\t\t/**\n+\t\t * A {@link Sink} with the following characteristics:\n+\t\t * <ul>\n+\t\t *     <li>Multicast</li>\n+\t\t *     <li>Without {@link Subscriber}: warm up. Remembers up to {@param bufferSize}\n+\t\t *     elements pushed via {@link Sink#emitNext(Object)} before the first {@link Subscriber} is registered.</li>\n+\t\t *     <li>Backpressure : this sink honors downstream demand by conforming to the lowest demand in case\n+\t\t *     of multiple subscribers.</li>\n+\t\t *     <li>Replaying: No replay. Only forwards to a {@link Subscriber} the elements that have been\n+\t\t *     pushed to the sink AFTER this subscriber was subscribed. To the exception of the first\n+\t\t *     subscriber (see below).</li>\n+\t\t * </ul>\n+\t\t * <p>\n+\t\t * <img class=\"marble\" src=\"doc-files/marbles/sinkWarmup.svg\" alt=\"\">\n+\t\t *\n+\t\t * @param bufferSize the maximum queue size\n+\t\t * @param autoCancel should the sink fully shutdowns (not publishing anymore) when the last subscriber cancels\n+\t\t */\n+\t\t<T> Sink<T> onBackpressureBuffer(int bufferSize, boolean autoCancel);\n+\n+\t\t/**\n+\t\t * A {@link Sink} with the following characteristics:\n+\t\t * <ul>\n+\t\t *     <li>Multicast</li>\n+\t\t *     <li>Without {@link Subscriber}: elements pushed via {@link Sink#emitNext(Object)} are discarded</li>\n+\t\t *     <li>Backpressure : this sink is not able to honor downstream demand and will emit `onError` if there is a mismatch.</li>\n+\t\t *     <li>Replaying: No replay. Only forwards to a {@link Subscriber} the elements that have been\n+\t\t *     pushed to the sink AFTER this subscriber was subscribed. To the exception of the first", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5981100d27d02470de0b807433e63042353be2d0"}, "originalPosition": 293}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA1MzQwMQ==", "bodyText": "I like the *Spec idea, but at the same time it reintroduces potential for overwhelming users, between all the available overloads.", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r449053401", "createdAt": "2020-07-02T14:43:18Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/SinksSpecs.java", "diffHunk": "@@ -0,0 +1,174 @@\n+package reactor.core.publisher;\n+\n+import reactor.core.CoreSubscriber;\n+import reactor.core.Disposable;\n+import reactor.core.Scannable;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.util.Queue;\n+\n+final class SinksSpecs {\n+\tstatic final UnicastSpecImpl         UNICAST_SPEC                 = new UnicastSpecImpl(true);\n+\tstatic final MulticastSpecImpl       MULTICAST_SPEC               = new MulticastSpecImpl(true);\n+\tstatic final MulticastReplaySpecImpl MULTICAST_REPLAY_SPEC        = new MulticastReplaySpecImpl(true);\n+\tstatic final UnsafeSpecImpl          UNSAFE_SPEC                  = new UnsafeSpecImpl();\n+\tstatic final UnicastSpecImpl         UNSAFE_UNICAST_SPEC          = new UnicastSpecImpl(false);\n+\tstatic final MulticastSpecImpl       UNSAFE_MULTICAST_SPEC        = new MulticastSpecImpl(false);\n+\tstatic final MulticastReplaySpecImpl UNSAFE_MULTICAST_REPLAY_SPEC = new MulticastReplaySpecImpl(false);\n+\n+}\n+\n+final class FluxProcessorSink<T> extends FluxCreate.SerializedSink<T, Sink<T>> {\n+\tfinal CoreSubscriber<T> contextHolder;\n+\n+\tFluxProcessorSink(Sink<T> sink, CoreSubscriber<T> contextHolder) {\n+\t\tsuper(sink);\n+\t\tthis.contextHolder = contextHolder;\n+\t}\n+\n+\t@Override\n+\tContext currentContext() {\n+\t\treturn contextHolder.currentContext();\n+\t}\n+\n+\t@Override\n+\tpublic boolean isCancelled() {\n+\t\treturn Scannable.from(sink).scanOrDefault(Attr.CANCELLED, false);\n+\t}\n+}\n+\n+abstract class SinkSpecImpl {\n+\tfinal boolean serialized;\n+\n+\tSinkSpecImpl(boolean serialized) {\n+\t\tthis.serialized = serialized;\n+\t}\n+\n+\tfinal <T> Sink<T> toSerializedSink(FluxProcessor<T, T> sink) {\n+\t\tif (serialized) {\n+\t\t\treturn new FluxProcessorSink<>(sink, sink);\n+\t\t}\n+\t\treturn sink;\n+\t}\n+}\n+\n+final class UnsafeSpecImpl implements Sinks.UnsafeSpec {\n+\n+\t@Override\n+\tpublic Sinks.UnicastSpec unicast() {\n+\t\treturn SinksSpecs.UNSAFE_UNICAST_SPEC;\n+\t}\n+\n+\t@Override\n+\tpublic Sinks.MulticastSpec multicast() {\n+\t\treturn SinksSpecs.UNSAFE_MULTICAST_SPEC;\n+\t}\n+\n+\t@Override\n+\tpublic Sinks.MulticastReplaySpec replay() {\n+\t\treturn SinksSpecs.UNSAFE_MULTICAST_REPLAY_SPEC;\n+\t}\n+}\n+\n+@SuppressWarnings(\"deprecated\")\n+final class UnicastSpecImpl extends SinkSpecImpl implements Sinks.UnicastSpec {\n+\tUnicastSpecImpl(boolean serialized) {\n+\t\tsuper(serialized);\n+\t}\n+\n+\t@Override\n+\tpublic <T> Sink<T> onBackpressureBuffer() {\n+\t\treturn toSerializedSink(UnicastProcessor.create());\n+\t}\n+\n+\t@Override\n+\tpublic <T> Sink<T> onBackpressureBuffer(Queue<T> queue) {\n+\t\treturn toSerializedSink(UnicastProcessor.create(queue));\n+\t}\n+\n+\t@Override\n+\tpublic <T> Sink<T> onBackpressureBuffer(Queue<T> queue, Disposable endCallback) {\n+\t\treturn toSerializedSink(UnicastProcessor.create(queue, endCallback));\n+\t}\n+}\n+\n+@SuppressWarnings(\"deprecated\")\n+final class MulticastSpecImpl extends SinkSpecImpl implements Sinks.MulticastSpec {\n+\tMulticastSpecImpl(boolean serialized) {\n+\t\tsuper(serialized);\n+\t}\n+\n+\t@Override\n+\tpublic <T> Sink<T> onBackpressureBuffer() {\n+\t\treturn toSerializedSink(EmitterProcessor.create());\n+\t}\n+\n+\t@Override\n+\tpublic <T> Sink<T> onBackpressureBuffer(int bufferSize) {\n+\t\treturn toSerializedSink(EmitterProcessor.create(bufferSize));\n+\t}\n+\n+\t@Override\n+\tpublic <T> Sink<T> onBackpressureBuffer(int bufferSize, boolean autoCancel) {\n+\t\treturn toSerializedSink(EmitterProcessor.create(bufferSize, autoCancel));\n+\t}\n+\n+\t@Override\n+\tpublic <T> Sink<T> onBackpressureError() {\n+\t\treturn toSerializedSink(DirectProcessor.create());\n+\t}\n+}\n+\n+@SuppressWarnings(\"deprecated\")\n+final class MulticastReplaySpecImpl extends SinkSpecImpl implements Sinks.MulticastReplaySpec {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5981100d27d02470de0b807433e63042353be2d0"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA1NjcyNQ==", "bodyText": "please don't change the indentation of unchanged lines. these were indented with intentional newlines", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r449056725", "createdAt": "2020-07-02T14:48:16Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/test/java/reactor/core/publisher/SinksTest.java", "diffHunk": "@@ -51,15 +51,11 @@\n \t@Nested\n \tclass MulticastNoWarmup {\n \n-\t\tfinal Supplier<Sink<Integer>> supplier = () -> Sinks.replay(0);\n+\t\tfinal Supplier<Sink<Integer>> supplier = () -> Sinks.replay().limit(0);\n \n \t\t@TestFactory\n \t\tStream<DynamicContainer> checkSemantics() {\n-\t\t\treturn Stream.of(\n-\t\t\t\t\texpectMulticast(supplier),\n-\t\t\t\t\texpectReplay(supplier, NONE),\n-\t\t\t\t\texpectBufferingBeforeFirstSubscriber(supplier, NONE)\n-\t\t\t);\n+\t\t\treturn Stream.of(expectMulticast(supplier), expectReplay(supplier, NONE), expectBufferingBeforeFirstSubscriber(supplier, NONE));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5981100d27d02470de0b807433e63042353be2d0"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA1Njg3Mg==", "bodyText": "same as above, these were indented with intentional newlines", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r449056872", "createdAt": "2020-07-02T14:48:29Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/test/java/reactor/core/publisher/SinksTest.java", "diffHunk": "@@ -69,17 +65,13 @@\n \t\t//TODO Multicast has slightly different behavior with early onNext + onError : doesn't buffer elements for benefit of 1st subscriber\n \t\t//(this is a behavioral difference in EmitterProcessor)\n \n-\t\tfinal Supplier<Sink<Integer>> supplier = Sinks::multicast;\n+\t\tfinal Supplier<Sink<Integer>> supplier = () -> Sinks.multicast().onBackpressureBuffer();\n \n \t\t@TestFactory\n \t\tStream<DynamicContainer> checkSemantics() {\n-\t\t\treturn Stream.of(\n-\t\t\t\t\texpectMulticast(supplier),\n-\t\t\t\t\texpectReplay(supplier, NONE),\n-\t\t\t\t\tdynamicContainer(\"buffers all before 1st subscriber, except for errors\",\n-\t\t\t\t\t\t\texpectBufferingBeforeFirstSubscriber(supplier, ALL)\n-\t\t\t\t\t\t\t\t\t.getChildren().filter(dn -> !dn.getDisplayName().equals(\"replayAndErrorFirstSubscriber\")))\n-\t\t\t);\n+\t\t\treturn Stream.of(expectMulticast(supplier), expectReplay(supplier, NONE), dynamicContainer(\"buffers all before 1st subscriber, except for errors\", expectBufferingBeforeFirstSubscriber(supplier, ALL).getChildren()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5981100d27d02470de0b807433e63042353be2d0"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA1NzIzNA==", "bodyText": "same as above, these were indented with intentional newlines", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r449057234", "createdAt": "2020-07-02T14:49:03Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/test/java/reactor/core/publisher/SinksTest.java", "diffHunk": "@@ -94,22 +86,19 @@ void noReplayBeforeFirstSubscriberIfEarlyError() {\n \t\t\tsink.emitError(new IllegalStateException(\"boom\"));\n \t\t\tflux.subscribe(first);\n \n-\t\t\tfirst.assertNoValues().assertErrorMessage(\"boom\");\n+\t\t\tfirst.assertNoValues()\n+\t\t\t\t .assertErrorMessage(\"boom\");\n \t\t}\n \t}\n \n \t@Nested\n \tclass MulticastReplayAll {\n \n-\t\tfinal Supplier<Sink<Integer>> supplier = Sinks::replayAll;\n+\t\tfinal Supplier<Sink<Integer>> supplier = () -> Sinks.replay().all();\n \n \t\t@TestFactory\n \t\tStream<DynamicContainer> checkSemantics() {\n-\t\t\treturn Stream.of(\n-\t\t\t\t\texpectMulticast(supplier),\n-\t\t\t\t\texpectReplay(supplier, ALL),\n-\t\t\t\t\texpectBufferingBeforeFirstSubscriber(supplier, ALL)\n-\t\t\t);\n+\t\t\treturn Stream.of(expectMulticast(supplier), expectReplay(supplier, ALL), expectBufferingBeforeFirstSubscriber(supplier, ALL));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5981100d27d02470de0b807433e63042353be2d0"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA1NzM3Ng==", "bodyText": "same as above, these were indented with intentional newlines", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r449057376", "createdAt": "2020-07-02T14:49:15Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/test/java/reactor/core/publisher/SinksTest.java", "diffHunk": "@@ -119,51 +108,36 @@ void noReplayBeforeFirstSubscriberIfEarlyError() {\n \t\t@TestFactory\n \t\tStream<DynamicContainer> checkSemanticsSize5() {\n \t\t\tfinal int historySize = 5;\n-\t\t\tfinal Supplier<Sink<Integer>> supplier = () -> Sinks.replay(historySize);\n+\t\t\tfinal Supplier<Sink<Integer>> supplier = () -> Sinks.replay().limit(historySize);\n \n-\t\t\treturn Stream.of(\n-\t\t\t\t\texpectMulticast(supplier),\n-\t\t\t\t\texpectReplay(supplier, historySize),\n-\t\t\t\t\texpectBufferingBeforeFirstSubscriber(supplier, historySize)\n-\t\t\t);\n+\t\t\treturn Stream.of(expectMulticast(supplier), expectReplay(supplier, historySize), expectBufferingBeforeFirstSubscriber(supplier, historySize));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5981100d27d02470de0b807433e63042353be2d0"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA1NzQ5NA==", "bodyText": "same as above, these were indented with intentional newlines", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r449057494", "createdAt": "2020-07-02T14:49:25Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/test/java/reactor/core/publisher/SinksTest.java", "diffHunk": "@@ -119,51 +108,36 @@ void noReplayBeforeFirstSubscriberIfEarlyError() {\n \t\t@TestFactory\n \t\tStream<DynamicContainer> checkSemanticsSize5() {\n \t\t\tfinal int historySize = 5;\n-\t\t\tfinal Supplier<Sink<Integer>> supplier = () -> Sinks.replay(historySize);\n+\t\t\tfinal Supplier<Sink<Integer>> supplier = () -> Sinks.replay().limit(historySize);\n \n-\t\t\treturn Stream.of(\n-\t\t\t\t\texpectMulticast(supplier),\n-\t\t\t\t\texpectReplay(supplier, historySize),\n-\t\t\t\t\texpectBufferingBeforeFirstSubscriber(supplier, historySize)\n-\t\t\t);\n+\t\t\treturn Stream.of(expectMulticast(supplier), expectReplay(supplier, historySize), expectBufferingBeforeFirstSubscriber(supplier, historySize));\n \t\t}\n \n \t\t@TestFactory\n \t\tStream<DynamicContainer> checkSemanticsSize0() {\n \t\t\tfinal int historySize = 0;\n-\t\t\tfinal Supplier<Sink<Integer>> supplier = () -> Sinks.replay(historySize);\n+\t\t\tfinal Supplier<Sink<Integer>> supplier = () -> Sinks.replay().limit(historySize);\n \n-\t\t\treturn Stream.of(\n-\t\t\t\t\texpectMulticast(supplier),\n-\t\t\t\t\texpectReplay(supplier, historySize),\n-\t\t\t\t\texpectBufferingBeforeFirstSubscriber(supplier, historySize)\n-\t\t\t);\n+\t\t\treturn Stream.of(expectMulticast(supplier), expectReplay(supplier, historySize), expectBufferingBeforeFirstSubscriber(supplier, historySize));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5981100d27d02470de0b807433e63042353be2d0"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA1NzU5OA==", "bodyText": "same as above, these were indented with intentional newlines", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r449057598", "createdAt": "2020-07-02T14:49:35Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/test/java/reactor/core/publisher/SinksTest.java", "diffHunk": "@@ -119,51 +108,36 @@ void noReplayBeforeFirstSubscriberIfEarlyError() {\n \t\t@TestFactory\n \t\tStream<DynamicContainer> checkSemanticsSize5() {\n \t\t\tfinal int historySize = 5;\n-\t\t\tfinal Supplier<Sink<Integer>> supplier = () -> Sinks.replay(historySize);\n+\t\t\tfinal Supplier<Sink<Integer>> supplier = () -> Sinks.replay().limit(historySize);\n \n-\t\t\treturn Stream.of(\n-\t\t\t\t\texpectMulticast(supplier),\n-\t\t\t\t\texpectReplay(supplier, historySize),\n-\t\t\t\t\texpectBufferingBeforeFirstSubscriber(supplier, historySize)\n-\t\t\t);\n+\t\t\treturn Stream.of(expectMulticast(supplier), expectReplay(supplier, historySize), expectBufferingBeforeFirstSubscriber(supplier, historySize));\n \t\t}\n \n \t\t@TestFactory\n \t\tStream<DynamicContainer> checkSemanticsSize0() {\n \t\t\tfinal int historySize = 0;\n-\t\t\tfinal Supplier<Sink<Integer>> supplier = () -> Sinks.replay(historySize);\n+\t\t\tfinal Supplier<Sink<Integer>> supplier = () -> Sinks.replay().limit(historySize);\n \n-\t\t\treturn Stream.of(\n-\t\t\t\t\texpectMulticast(supplier),\n-\t\t\t\t\texpectReplay(supplier, historySize),\n-\t\t\t\t\texpectBufferingBeforeFirstSubscriber(supplier, historySize)\n-\t\t\t);\n+\t\t\treturn Stream.of(expectMulticast(supplier), expectReplay(supplier, historySize), expectBufferingBeforeFirstSubscriber(supplier, historySize));\n \t\t}\n \n \t\t@TestFactory\n \t\tStream<DynamicContainer> checkSemanticsSize100() {\n \t\t\tfinal int historySize = 100;\n-\t\t\tfinal Supplier<Sink<Integer>> supplier = () -> Sinks.replay(historySize);\n+\t\t\tfinal Supplier<Sink<Integer>> supplier = () -> Sinks.replay().limit(historySize);\n \n-\t\t\treturn Stream.of(\n-\t\t\t\t\texpectMulticast(supplier),\n-\t\t\t\t\texpectReplay(supplier, historySize),\n-\t\t\t\t\texpectBufferingBeforeFirstSubscriber(supplier, historySize)\n-\t\t\t);\n+\t\t\treturn Stream.of(expectMulticast(supplier), expectReplay(supplier, historySize), expectBufferingBeforeFirstSubscriber(supplier, historySize));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5981100d27d02470de0b807433e63042353be2d0"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA1Nzc2Ng==", "bodyText": "same as above, these were indented with intentional newlines", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r449057766", "createdAt": "2020-07-02T14:49:49Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/test/java/reactor/core/publisher/SinksTest.java", "diffHunk": "@@ -119,51 +108,36 @@ void noReplayBeforeFirstSubscriberIfEarlyError() {\n \t\t@TestFactory\n \t\tStream<DynamicContainer> checkSemanticsSize5() {\n \t\t\tfinal int historySize = 5;\n-\t\t\tfinal Supplier<Sink<Integer>> supplier = () -> Sinks.replay(historySize);\n+\t\t\tfinal Supplier<Sink<Integer>> supplier = () -> Sinks.replay().limit(historySize);\n \n-\t\t\treturn Stream.of(\n-\t\t\t\t\texpectMulticast(supplier),\n-\t\t\t\t\texpectReplay(supplier, historySize),\n-\t\t\t\t\texpectBufferingBeforeFirstSubscriber(supplier, historySize)\n-\t\t\t);\n+\t\t\treturn Stream.of(expectMulticast(supplier), expectReplay(supplier, historySize), expectBufferingBeforeFirstSubscriber(supplier, historySize));\n \t\t}\n \n \t\t@TestFactory\n \t\tStream<DynamicContainer> checkSemanticsSize0() {\n \t\t\tfinal int historySize = 0;\n-\t\t\tfinal Supplier<Sink<Integer>> supplier = () -> Sinks.replay(historySize);\n+\t\t\tfinal Supplier<Sink<Integer>> supplier = () -> Sinks.replay().limit(historySize);\n \n-\t\t\treturn Stream.of(\n-\t\t\t\t\texpectMulticast(supplier),\n-\t\t\t\t\texpectReplay(supplier, historySize),\n-\t\t\t\t\texpectBufferingBeforeFirstSubscriber(supplier, historySize)\n-\t\t\t);\n+\t\t\treturn Stream.of(expectMulticast(supplier), expectReplay(supplier, historySize), expectBufferingBeforeFirstSubscriber(supplier, historySize));\n \t\t}\n \n \t\t@TestFactory\n \t\tStream<DynamicContainer> checkSemanticsSize100() {\n \t\t\tfinal int historySize = 100;\n-\t\t\tfinal Supplier<Sink<Integer>> supplier = () -> Sinks.replay(historySize);\n+\t\t\tfinal Supplier<Sink<Integer>> supplier = () -> Sinks.replay().limit(historySize);\n \n-\t\t\treturn Stream.of(\n-\t\t\t\t\texpectMulticast(supplier),\n-\t\t\t\t\texpectReplay(supplier, historySize),\n-\t\t\t\t\texpectBufferingBeforeFirstSubscriber(supplier, historySize)\n-\t\t\t);\n+\t\t\treturn Stream.of(expectMulticast(supplier), expectReplay(supplier, historySize), expectBufferingBeforeFirstSubscriber(supplier, historySize));\n \t\t}\n \t}\n \n \t@Nested\n \tclass Unicast {\n \n-\t\tfinal Supplier<Sink<Integer>> supplier = Sinks::unicast;\n+\t\tfinal Supplier<Sink<Integer>> supplier = () -> Sinks.unicast().onBackpressureBuffer();\n \n \t\t@TestFactory\n \t\tStream<DynamicContainer> checkSemantics() {\n-\t\t\treturn Stream.of(\n-\t\t\t\t\texpectUnicast(supplier),\n-\t\t\t\t\texpectBufferingBeforeFirstSubscriber(supplier, ALL)\n-\t\t\t);\n+\t\t\treturn Stream.of(expectUnicast(supplier), expectBufferingBeforeFirstSubscriber(supplier, ALL));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5981100d27d02470de0b807433e63042353be2d0"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA2MTExNA==", "bodyText": "past this point the indentation was tuned a bit to avoid code creeping towards the right. this looks like good old callback hell \ud83d\ude48 \ud83d\ude06", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r449061114", "createdAt": "2020-07-02T14:54:40Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/test/java/reactor/core/publisher/SinksTest.java", "diffHunk": "@@ -494,300 +477,327 @@ DynamicContainer expectUnicast(Supplier<Sink<Integer>> sinkSupplier) {\n \t\t\t\t\tfinally {\n \t\t\t\t\t\tes.shutdownNow();\n \t\t\t\t\t}\n-\t\t\t\t})\n-\t\t));\n+\t\t\t\t})));\n \t}\n \n \tDynamicContainer expectReplay(Supplier<Sink<Integer>> sinkSupplier, int expectedReplay) {\n \t\tif (expectedReplay == NONE) {\n-\t\t\treturn dynamicContainer(\"no replay\", Stream.of(\n-\t\t\t\t\tdynamicTest(\"doesNotReplayToLateSubscribers\", () -> {\n-\t\t\t\t\t\tSink<Integer> sink = sinkSupplier.get();\n-\t\t\t\t\t\tFlux<Integer> flux = sink.toFlux();\n-\t\t\t\t\t\tAssertSubscriber<Integer> s1 = AssertSubscriber.create();\n-\t\t\t\t\t\tAssertSubscriber<Integer> s2 = AssertSubscriber.create();\n-\n-\t\t\t\t\t\tflux.subscribe(s1);\n-\t\t\t\t\t\tsink.emitNext(1);\n-\t\t\t\t\t\tsink.emitNext(2);\n-\t\t\t\t\t\tsink.emitNext(3);\n-\t\t\t\t\t\ts1.assertValues(1, 2, 3);\n-\n-\t\t\t\t\t\tflux.subscribe(s2);\n-\t\t\t\t\t\ts2.assertNoValues().assertNotComplete();\n-\n-\t\t\t\t\t\tsink.emitComplete();\n-\t\t\t\t\t\ts1.assertValueCount(3).assertComplete();\n-\t\t\t\t\t\ts2.assertNoValues().assertComplete();\n-\t\t\t\t\t}),\n-\n-\t\t\t\t\tdynamicTest(\"immediatelyCompleteLateSubscriber\", () -> {\n-\t\t\t\t\t\tSink<Integer> sink = sinkSupplier.get();\n-\t\t\t\t\t\tFlux<Integer> flux = sink.toFlux();\n-\n-\t\t\t\t\t\tflux.subscribe(); //first subscriber\n-\t\t\t\t\t\tAssertSubscriber<Integer> late = AssertSubscriber.create();\n-\n-\t\t\t\t\t\tsink.emitNext(1);\n-\t\t\t\t\t\tsink.emitComplete();\n-\t\t\t\t\t\tflux.subscribe(late);\n-\n-\t\t\t\t\t\tlate.assertNoValues().assertComplete();\n-\t\t\t\t\t}),\n-\n-\t\t\t\t\tdynamicTest(\"immediatelyErrorLateSubscriber\", () -> {\n-\t\t\t\t\t\tSink<Integer> sink = sinkSupplier.get();\n-\t\t\t\t\t\tFlux<Integer> flux = sink.toFlux();\n-\n-\t\t\t\t\t\tflux.onErrorReturn(-1).subscribe(); //first subscriber, ignore errors\n-\t\t\t\t\t\tAssertSubscriber<Integer> late = AssertSubscriber.create();\n-\n-\t\t\t\t\t\tsink.emitNext(1);\n-\t\t\t\t\t\tsink.emitError(new IllegalStateException(\"boom\"));\n-\t\t\t\t\t\tflux.subscribe(late);\n-\n-\t\t\t\t\t\tlate.assertNoValues().assertErrorMessage(\"boom\");\n-\t\t\t\t\t})\n-\t\t\t));\n+\t\t\treturn dynamicContainer(\"no replay\", Stream.of(dynamicTest(\"doesNotReplayToLateSubscribers\", () -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5981100d27d02470de0b807433e63042353be2d0"}, "originalPosition": 529}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxNzc3MzAy", "url": "https://github.com/reactor/reactor-core/pull/2218#pullrequestreview-441777302", "createdAt": "2020-07-02T15:12:39Z", "commit": {"oid": "5981100d27d02470de0b807433e63042353be2d0"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNToxMjozOVrOGsRQXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNjowOTo0OVrOGsUW5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA3MzI0Nw==", "bodyText": "this should definitely NOT be Scannable.class::cast then, but from. otherwise we'll be sure to get ClassCastException at some point in the future.", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r449073247", "createdAt": "2020-07-02T15:12:39Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/FluxGroupJoin.java", "diffHunk": "@@ -207,7 +207,7 @@\n \t\t@Override\n \t\tpublic Stream<? extends Scannable> inners() {\n \t\t\treturn Stream.concat(\n-\t\t\t\t\tlefts.values().stream(),\n+\t\t\t\t\tlefts.values().stream().map(Scannable.class::cast),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQxODY3Ng=="}, "originalCommit": {"oid": "3d171d8870cd3d3ee46d5fc06aac05b98ff3046d"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA3NjE0OA==", "bodyText": "After re-considering it I think I can live with the FluxSink rejecting use of toFlux at runtime, maybe. I have more trouble with FluxSink having a toMono() and MonoSink a toFlux, to be honest", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r449076148", "createdAt": "2020-07-02T15:17:05Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/FluxSink.java", "diffHunk": "@@ -113,6 +113,16 @@\n \t */\n \tFluxSink<T> onDispose(Disposable d);\n \n+\t@Override\n+\tdefault Flux<T> toFlux() {\n+\t\treturn Flux.error(new IllegalStateException(\"A FluxSink does not support back referencing the outer Flux\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc1NTg4NQ=="}, "originalCommit": {"oid": "e152ff38435ecb251deefea7fdfbde45ba9516c7"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA4MTA2Mw==", "bodyText": "that would be an option, yeah. as I'm not sure I will be able to implement the tryNext feature within the 3.4.0 timeframe, I'd prefer to pave the way for it and thus introduce a subset of the enum. Maybe SinkResult with values EMITTED, REJECTED_TERMINATED and REJECTED_CANCELLED for now ? (or even just EMITTED vs REJECTED_TERMINATED). The important point is that trynext is only one new enum value from being added (and we can later do finer grained distinction between rejections due to termination, cancellation and disposal of the sink)\nIn a word I would make a MVP of this idea part of this PR", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r449081063", "createdAt": "2020-07-02T15:24:23Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/MonoSink.java", "diffHunk": "@@ -31,7 +33,45 @@\n  *\n  * @param <T> the value type emitted\n  */\n-public interface MonoSink<T> extends ScalarSink<T> {\n+public interface MonoSink<T> extends Sink<T> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc1ODMwMw=="}, "originalCommit": {"oid": "e152ff38435ecb251deefea7fdfbde45ba9516c7"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA4NDE0NQ==", "bodyText": "wdyt about the suggestion of changing from DirectProcessor (which can always be created via multicast().onBackpressureError() anyways) to MonoProcessor @smaldini ?", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r449084145", "createdAt": "2020-07-02T15:27:34Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/Sinks.java", "diffHunk": "@@ -47,25 +53,37 @@ private Sinks() { }\n \t */\n \t@SuppressWarnings(\"deprecation\")\n \tpublic static <T> Sink<T> multicast() {\n-\t\treturn new ProcessorSink<>(EmitterProcessor.create(Queues.SMALL_BUFFER_SIZE));\n+\t\tEmitterProcessor<T> processor = EmitterProcessor.create(Queues.SMALL_BUFFER_SIZE);\n+\t\treturn SinksHelper.toSink(processor, processor);\n \t}\n \n \t/**\n \t * A {@link Sink} with the following characteristics:\n \t * <ul>\n \t *     <li>Multicast</li>\n-\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n+\t *     <li>Backpressure : this sink is not able to honor downstream demand and will emit `onError` if there is a mismatch.</li>\n \t *     <li>Replaying: No replay. Only forwards to a {@link Subscriber} the elements that have been\n-\t *     pushed to the sink AFTER this subscriber was subscribed.</li>\n-\t *     <li>Without {@link Subscriber}: Discarding. Pushing elements while there are no {@link Subscriber}\n-\t *     registered will simply discard these elements instead of \"warming up\" the sink.</li>\n+\t *     pushed to the sink AFTER this subscriber was subscribed. To the exception of the first\n+\t *     subscribe.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> Sink<T> multicastNoBackpressure() {\n+\t\tDirectProcessor<T> processor = DirectProcessor.create();\n+\t\treturn SinksHelper.toSink(processor, processor);\n+\t}\n+\n+\t/**\n+\t * A {@link Sink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink does not need any demand since it can only signal error or completion</li>\n+\t *     <li>Replaying: Replay the terminal signal (error or complete).</li>\n \t * </ul>\n-\t * <p>\n-\t * <img class=\"marble\" src=\"doc-files/marbles/sinkNoWarmup.svg\" alt=\"\">\n \t */\n \t@SuppressWarnings(\"deprecation\")\n-\tpublic static <T> Sink<T> multicastNoWarmup() {\n-\t\treturn new ProcessorSink<>(ReplayProcessor.create(0));\n+\tpublic static Sink<Void> coordinator() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ1NTAwOQ=="}, "originalCommit": {"oid": "3d171d8870cd3d3ee46d5fc06aac05b98ff3046d"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA4Njk4OA==", "bodyText": "I do like the split and the choice of basic vs unsafe, though... And the fact that these two flavors otherwise align perfectly in terms of choice in the number of factory methods \ud83d\udc4d", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r449086988", "createdAt": "2020-07-02T15:29:58Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/SinksSpecs.java", "diffHunk": "@@ -0,0 +1,174 @@\n+package reactor.core.publisher;\n+\n+import reactor.core.CoreSubscriber;\n+import reactor.core.Disposable;\n+import reactor.core.Scannable;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.util.Queue;\n+\n+final class SinksSpecs {\n+\tstatic final UnicastSpecImpl         UNICAST_SPEC                 = new UnicastSpecImpl(true);\n+\tstatic final MulticastSpecImpl       MULTICAST_SPEC               = new MulticastSpecImpl(true);\n+\tstatic final MulticastReplaySpecImpl MULTICAST_REPLAY_SPEC        = new MulticastReplaySpecImpl(true);\n+\tstatic final UnsafeSpecImpl          UNSAFE_SPEC                  = new UnsafeSpecImpl();\n+\tstatic final UnicastSpecImpl         UNSAFE_UNICAST_SPEC          = new UnicastSpecImpl(false);\n+\tstatic final MulticastSpecImpl       UNSAFE_MULTICAST_SPEC        = new MulticastSpecImpl(false);\n+\tstatic final MulticastReplaySpecImpl UNSAFE_MULTICAST_REPLAY_SPEC = new MulticastReplaySpecImpl(false);\n+\n+}\n+\n+final class FluxProcessorSink<T> extends FluxCreate.SerializedSink<T, Sink<T>> {\n+\tfinal CoreSubscriber<T> contextHolder;\n+\n+\tFluxProcessorSink(Sink<T> sink, CoreSubscriber<T> contextHolder) {\n+\t\tsuper(sink);\n+\t\tthis.contextHolder = contextHolder;\n+\t}\n+\n+\t@Override\n+\tContext currentContext() {\n+\t\treturn contextHolder.currentContext();\n+\t}\n+\n+\t@Override\n+\tpublic boolean isCancelled() {\n+\t\treturn Scannable.from(sink).scanOrDefault(Attr.CANCELLED, false);\n+\t}\n+}\n+\n+abstract class SinkSpecImpl {\n+\tfinal boolean serialized;\n+\n+\tSinkSpecImpl(boolean serialized) {\n+\t\tthis.serialized = serialized;\n+\t}\n+\n+\tfinal <T> Sink<T> toSerializedSink(FluxProcessor<T, T> sink) {\n+\t\tif (serialized) {\n+\t\t\treturn new FluxProcessorSink<>(sink, sink);\n+\t\t}\n+\t\treturn sink;\n+\t}\n+}\n+\n+final class UnsafeSpecImpl implements Sinks.UnsafeSpec {\n+\n+\t@Override\n+\tpublic Sinks.UnicastSpec unicast() {\n+\t\treturn SinksSpecs.UNSAFE_UNICAST_SPEC;\n+\t}\n+\n+\t@Override\n+\tpublic Sinks.MulticastSpec multicast() {\n+\t\treturn SinksSpecs.UNSAFE_MULTICAST_SPEC;\n+\t}\n+\n+\t@Override\n+\tpublic Sinks.MulticastReplaySpec replay() {\n+\t\treturn SinksSpecs.UNSAFE_MULTICAST_REPLAY_SPEC;\n+\t}\n+}\n+\n+@SuppressWarnings(\"deprecated\")\n+final class UnicastSpecImpl extends SinkSpecImpl implements Sinks.UnicastSpec {\n+\tUnicastSpecImpl(boolean serialized) {\n+\t\tsuper(serialized);\n+\t}\n+\n+\t@Override\n+\tpublic <T> Sink<T> onBackpressureBuffer() {\n+\t\treturn toSerializedSink(UnicastProcessor.create());\n+\t}\n+\n+\t@Override\n+\tpublic <T> Sink<T> onBackpressureBuffer(Queue<T> queue) {\n+\t\treturn toSerializedSink(UnicastProcessor.create(queue));\n+\t}\n+\n+\t@Override\n+\tpublic <T> Sink<T> onBackpressureBuffer(Queue<T> queue, Disposable endCallback) {\n+\t\treturn toSerializedSink(UnicastProcessor.create(queue, endCallback));\n+\t}\n+}\n+\n+@SuppressWarnings(\"deprecated\")\n+final class MulticastSpecImpl extends SinkSpecImpl implements Sinks.MulticastSpec {\n+\tMulticastSpecImpl(boolean serialized) {\n+\t\tsuper(serialized);\n+\t}\n+\n+\t@Override\n+\tpublic <T> Sink<T> onBackpressureBuffer() {\n+\t\treturn toSerializedSink(EmitterProcessor.create());\n+\t}\n+\n+\t@Override\n+\tpublic <T> Sink<T> onBackpressureBuffer(int bufferSize) {\n+\t\treturn toSerializedSink(EmitterProcessor.create(bufferSize));\n+\t}\n+\n+\t@Override\n+\tpublic <T> Sink<T> onBackpressureBuffer(int bufferSize, boolean autoCancel) {\n+\t\treturn toSerializedSink(EmitterProcessor.create(bufferSize, autoCancel));\n+\t}\n+\n+\t@Override\n+\tpublic <T> Sink<T> onBackpressureError() {\n+\t\treturn toSerializedSink(DirectProcessor.create());\n+\t}\n+}\n+\n+@SuppressWarnings(\"deprecated\")\n+final class MulticastReplaySpecImpl extends SinkSpecImpl implements Sinks.MulticastReplaySpec {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA1MzQwMQ=="}, "originalCommit": {"oid": "5981100d27d02470de0b807433e63042353be2d0"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA5NTkyNw==", "bodyText": "remaining extraneous either", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r449095927", "createdAt": "2020-07-02T15:37:30Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/FluxProcessor.java", "diffHunk": "@@ -229,7 +239,7 @@ public Context currentContext() {\n \t * for the\n \t * available strategies\n \t * @return a serializing {@link FluxSink}\n-\t * @deprecated Prefer clear cut usage of either {@link Processors} or {@link Sinks}, to be removed in 3.5\n+\t * @deprecated Prefer clear cut usage of either {@link Sinks}, to be removed in 3.5", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5981100d27d02470de0b807433e63042353be2d0"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTExMDIxMA==", "bodyText": "tracking in #2243", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r449110210", "createdAt": "2020-07-02T15:49:10Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/FluxSink.java", "diffHunk": "@@ -33,9 +34,29 @@\n  */\n public interface FluxSink<T> extends Sink<T> {\n \n-\t@Override\n+\t/**\n+\t * Emit a non-null element, generating an {@link Subscriber#onNext(Object) onNext} signal.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQyNzE4Mw=="}, "originalCommit": {"oid": "3d171d8870cd3d3ee46d5fc06aac05b98ff3046d"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTExNTg5NQ==", "bodyText": "rename to SerializedSinkWithContext", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r449115895", "createdAt": "2020-07-02T15:56:52Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/SinksSpecs.java", "diffHunk": "@@ -0,0 +1,174 @@\n+package reactor.core.publisher;\n+\n+import reactor.core.CoreSubscriber;\n+import reactor.core.Disposable;\n+import reactor.core.Scannable;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.util.Queue;\n+\n+final class SinksSpecs {\n+\tstatic final UnicastSpecImpl         UNICAST_SPEC                 = new UnicastSpecImpl(true);\n+\tstatic final MulticastSpecImpl       MULTICAST_SPEC               = new MulticastSpecImpl(true);\n+\tstatic final MulticastReplaySpecImpl MULTICAST_REPLAY_SPEC        = new MulticastReplaySpecImpl(true);\n+\tstatic final UnsafeSpecImpl          UNSAFE_SPEC                  = new UnsafeSpecImpl();\n+\tstatic final UnicastSpecImpl         UNSAFE_UNICAST_SPEC          = new UnicastSpecImpl(false);\n+\tstatic final MulticastSpecImpl       UNSAFE_MULTICAST_SPEC        = new MulticastSpecImpl(false);\n+\tstatic final MulticastReplaySpecImpl UNSAFE_MULTICAST_REPLAY_SPEC = new MulticastReplaySpecImpl(false);\n+\n+}\n+\n+final class FluxProcessorSink<T> extends FluxCreate.SerializedSink<T, Sink<T>> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5981100d27d02470de0b807433e63042353be2d0"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEyMTUyNg==", "bodyText": "I'm not sure xxxProcessor tests should use the Sinks path. After all, these classes are there to explicitly test a specific concrete implementation and would likely survive the switch of said concrete implementation to package-private. On the other hand, if the implementation of Sinks.unicast() somehow changes then coverage would drop for UnicastProcessor.\nThis comment applies to other xxxProcessorTest cases.", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r449121526", "createdAt": "2020-07-02T16:05:28Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/test/java/reactor/core/publisher/UnicastProcessorTest.java", "diffHunk": "@@ -65,20 +65,19 @@ public void secondSubscriberRejectedProperly() {\n \n \t@Test\n \tpublic void multiThreadedProducer() {\n-\t\tUnicastProcessor<Integer> processor = UnicastProcessor.create();\n-\t\tFluxSink<Integer> sink = processor.sink();\n+\t\tSink<Integer> sink = Sinks.unicast().onBackpressureBuffer();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5981100d27d02470de0b807433e63042353be2d0"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEyMzcyNA==", "bodyText": "see comment in GuideTest.java", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r449123724", "createdAt": "2020-07-02T16:09:13Z", "author": {"login": "simonbasle"}, "path": "docs/asciidoc/advancedFeatures.adoc", "diffHunk": "@@ -193,7 +193,7 @@ Compare the first example to the second example, shown in the following code:\n ====\n [source,java]\n ----\n-Sinks.StandaloneFluxSink<String> hotSource = Sinks.multicastNoWarmup();\n+Sink<String> hotSource = Sinks.replay().limit(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5981100d27d02470de0b807433e63042353be2d0"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEyNDA3MA==", "bodyText": "reiterating that replay().limit(0) is probably a bit too confusing. multicast().onBackpressureError() sounds like the best example to give, showcasing only live data makes it past the sink.\nAlso change in advancedFeatures.adoc.", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r449124070", "createdAt": "2020-07-02T16:09:49Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/test/java/reactor/guide/GuideTests.java", "diffHunk": "@@ -201,21 +201,20 @@ public void advancedCold() {\n \n \t@Test\n \tpublic void advancedHot() {\n-\t\tSinks.StandaloneFluxSink<String> hotSource = Sinks.multicastNoWarmup();\n-\n-\t\tFlux<String> hotFlux = hotSource.asFlux().map(String::toUpperCase);\n+\t\tSink<String> hotSource = Sinks.replay().limit(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5981100d27d02470de0b807433e63042353be2d0"}, "originalPosition": 77}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5981100d27d02470de0b807433e63042353be2d0", "author": {"user": {"login": "smaldini", "name": "Stephane Maldini"}}, "url": "https://github.com/reactor/reactor-core/commit/5981100d27d02470de0b807433e63042353be2d0", "committedDate": "2020-07-01T01:36:05Z", "message": "Add Sinks builders and address some PR feedback\n- Reuse onBackpressureXxx naming conventions\n- deprecate FluxProcessor#switchOnNext\n- add FluxProcessor#isIdentityProcessor\n- add FluxProcessor#fromSink"}, "afterCommit": {"oid": "adf69c237b92ae3328b33e58f40c88b9784411b0", "author": {"user": {"login": "smaldini", "name": "Stephane Maldini"}}, "url": "https://github.com/reactor/reactor-core/commit/adf69c237b92ae3328b33e58f40c88b9784411b0", "committedDate": "2020-07-31T23:19:04Z", "message": "Tweak redundant imports"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwMTU1ODg1", "url": "https://github.com/reactor/reactor-core/pull/2218#pullrequestreview-460155885", "createdAt": "2020-08-03T16:10:56Z", "commit": {"oid": "8b1fef2f844ae02c53c5603de3300de1bd86445d"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1f2d496be031339098cdfa2c2aaffa0760deefed", "author": {"user": {"login": "simonbasle", "name": "Simon Basl\u00e9"}}, "url": "https://github.com/reactor/reactor-core/commit/1f2d496be031339098cdfa2c2aaffa0760deefed", "committedDate": "2020-08-03T16:18:33Z", "message": "fix refguide use of Sinks.many().replay().limit(0)"}, "afterCommit": {"oid": "7b6b655f0ca41a4ea96c54f3819a48d8e99c80eb", "author": {"user": {"login": "simonbasle", "name": "Simon Basl\u00e9"}}, "url": "https://github.com/reactor/reactor-core/commit/7b6b655f0ca41a4ea96c54f3819a48d8e99c80eb", "committedDate": "2020-08-03T16:18:56Z", "message": "fix refguide use of Sinks.many().replay().limit(0)"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwNzI3MDYw", "url": "https://github.com/reactor/reactor-core/pull/2218#pullrequestreview-460727060", "createdAt": "2020-08-04T11:30:14Z", "commit": {"oid": "8cb64857c3c6a6ce5ae2e8e6d9f4fa54bf09c366"}, "state": "APPROVED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxMTozMDoxNFrOG7cVZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNjowNToxMVrOG7nPLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDk4MzM5Nw==", "bodyText": "Shouldn't it be asFlux() instead of toFlux()?", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r464983397", "createdAt": "2020-08-04T11:30:14Z", "author": {"login": "aneveu"}, "path": "docs/asciidoc/processors.adoc", "diffHunk": "@@ -64,17 +41,24 @@ Multiple producer threads may concurrently generate data on the sink by doing th\n ====\n [source,java]\n ----\n-sink.next(1).next(2).next(3);\n+//thread1\n+sink.emitNext(1);\n+\n+//thread2\n+sink.emitNext(2);\n+\n+//thread3\n+sink.emitNext(3);\n ----\n ====\n \n-Parallel to that, the sink can be presented to downstream consumers as a `Publisher` (a `Flux`\n+The sink can be presented to downstream consumers as a `Publisher` (a `Flux`\n or a `Mono`), like in the below example:\n \n ====\n [source,java]\n ----\n-Flux<Integer> fluxView = replaySink.asFlux();\n+Flux<Integer> fluxView = replaySink.toFlux();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8cb64857c3c6a6ce5ae2e8e6d9f4fa54bf09c366"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDk4NTQ3MQ==", "bodyText": "I'm not sure that sentence could be kept this way as we're not talking about processor anymore on this part.", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r464985471", "createdAt": "2020-08-04T11:34:39Z", "author": {"login": "aneveu"}, "path": "docs/asciidoc/processors.adoc", "diffHunk": "@@ -83,81 +67,80 @@ fluxView\n ====\n \n \n-The `Sinks` flavors that can be viewed as `Flux` are:\n-\n-. `multicast()`: a sink that will transmit only newly pushed data to its subscribers, honoring their backpressure (newly pushed as in \"after the subscriber's subscription\").\n-. `multicastPreWarming()`: same as above, with the twist that data pushed before the first subscriber registers is buffered.\n-. `multicastReplayAll()`: a sink that will replay all the history of pushed data to new subscribers then continue pushing new data live.\n-. `multicastReplay(int)`: same as above, except the history of replayed data is limited in size.\n-. `unicast()`: the only sink that won't accept more than one `Subscriber`, but honors their backpressure\n-(and replays elements pushed to it before the Subscriber arrives)\n+The `Sinks` categories are:\n \n-There is currently only one `Sinks` flavor that can be viewed as `Mono`:\n-\n-. `trigger()`: a sink that will wait for a `Mono`-like interaction, propagate it to current `Subscribers` and additionally cache it for replaying to any late `Subscriber`.\n+. `many().multicast()`: a sink that will transmit only newly pushed data to its subscribers, honoring their backpressure (newly pushed as in \"after the subscriber's subscription\").\n+. `many().unicast()`: same as above, with the twist that data pushed before the first subscriber registers is buffered.\n+. `many().replay()`: a sink that will replay a specified history size of pushed data to new subscribers then continue pushing new data live.\n+. `singleOrEmpty()`: a sink that will play a single element to its subscribers\n+. `empty()`: a sink that will play a terminal signal only to its subscribers (error or complete)\n \n [[processor-overview]]\n-= Overview of Available Processors\n-\n-== Direct Processor\n+= Overview of Available Sinks\n \n-A direct `Processor` is a very simple processor that can dispatch signals to zero or more\n-`Subscribers`. On the other hand, *it has the limitation of not handling backpressure*.\n-As a consequence, a `DirectProcessor` signals an `IllegalStateException` to its\n-subscribers if you push N elements through it but at least one of its subscribers has\n-requested less than N.\n+== Sinks.many().unicast().onBackpressureBuffer(args?)\n \n-This aspect makes it a bit niche, and so the (only) factory method to create a direct processor\n-is hidden a bit: it is created via `Processors.more().multicastNoBackpressure()`.\n-\n-Once the `Processor` has terminated (usually through its sink's `error(Throwable)` or\n-`complete()` methods being called), it lets more subscribers subscribe but replays the\n-termination signal to them immediately.\n-\n-== Unicast Processor\n-\n-A unicast `Processor` can deal with backpressure by using an internal buffer. The trade-off\n+A unicast `sink` can deal with backpressure by using an internal buffer. The trade-off\n is that it can have _at most one_ `Subscriber`.\n \n-The basic unicast processor is created via `Processors.unicast()`.\n+The basic unicast sink is created via `Sinks.many().unicast().onBackpressureBuffer()`.\n But since it has a few more options than a direct processor, there are a few additional", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8cb64857c3c6a6ce5ae2e8e6d9f4fa54bf09c366"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDk4NjAxNg==", "bodyText": "sink instead of processor", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r464986016", "createdAt": "2020-08-04T11:35:46Z", "author": {"login": "aneveu"}, "path": "docs/asciidoc/processors.adoc", "diffHunk": "@@ -83,81 +67,80 @@ fluxView\n ====\n \n \n-The `Sinks` flavors that can be viewed as `Flux` are:\n-\n-. `multicast()`: a sink that will transmit only newly pushed data to its subscribers, honoring their backpressure (newly pushed as in \"after the subscriber's subscription\").\n-. `multicastPreWarming()`: same as above, with the twist that data pushed before the first subscriber registers is buffered.\n-. `multicastReplayAll()`: a sink that will replay all the history of pushed data to new subscribers then continue pushing new data live.\n-. `multicastReplay(int)`: same as above, except the history of replayed data is limited in size.\n-. `unicast()`: the only sink that won't accept more than one `Subscriber`, but honors their backpressure\n-(and replays elements pushed to it before the Subscriber arrives)\n+The `Sinks` categories are:\n \n-There is currently only one `Sinks` flavor that can be viewed as `Mono`:\n-\n-. `trigger()`: a sink that will wait for a `Mono`-like interaction, propagate it to current `Subscribers` and additionally cache it for replaying to any late `Subscriber`.\n+. `many().multicast()`: a sink that will transmit only newly pushed data to its subscribers, honoring their backpressure (newly pushed as in \"after the subscriber's subscription\").\n+. `many().unicast()`: same as above, with the twist that data pushed before the first subscriber registers is buffered.\n+. `many().replay()`: a sink that will replay a specified history size of pushed data to new subscribers then continue pushing new data live.\n+. `singleOrEmpty()`: a sink that will play a single element to its subscribers\n+. `empty()`: a sink that will play a terminal signal only to its subscribers (error or complete)\n \n [[processor-overview]]\n-= Overview of Available Processors\n-\n-== Direct Processor\n+= Overview of Available Sinks\n \n-A direct `Processor` is a very simple processor that can dispatch signals to zero or more\n-`Subscribers`. On the other hand, *it has the limitation of not handling backpressure*.\n-As a consequence, a `DirectProcessor` signals an `IllegalStateException` to its\n-subscribers if you push N elements through it but at least one of its subscribers has\n-requested less than N.\n+== Sinks.many().unicast().onBackpressureBuffer(args?)\n \n-This aspect makes it a bit niche, and so the (only) factory method to create a direct processor\n-is hidden a bit: it is created via `Processors.more().multicastNoBackpressure()`.\n-\n-Once the `Processor` has terminated (usually through its sink's `error(Throwable)` or\n-`complete()` methods being called), it lets more subscribers subscribe but replays the\n-termination signal to them immediately.\n-\n-== Unicast Processor\n-\n-A unicast `Processor` can deal with backpressure by using an internal buffer. The trade-off\n+A unicast `sink` can deal with backpressure by using an internal buffer. The trade-off\n is that it can have _at most one_ `Subscriber`.\n \n-The basic unicast processor is created via `Processors.unicast()`.\n+The basic unicast sink is created via `Sinks.many().unicast().onBackpressureBuffer()`.\n But since it has a few more options than a direct processor, there are a few additional\n-`unicast` static factory methods in `Processors#more()`.\n+`unicast` static factory methods in `Sinks.many().unicast()`.\n \n For instance, by default, it is unbounded: If you push any amount of data through it while\n its `Subscriber` has not yet requested data, it buffers all of the data.\n You can change this by providing a custom `Queue` implementation for the internal\n-buffering in the `Processors.more().unicast(Queue)` factory method.\n+buffering in the `Sinks.many().unicast().onBackpressureBuffer(Queue)` factory method.\n If that queue is bounded, the processor could reject the push of a value when the buffer", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8cb64857c3c6a6ce5ae2e8e6d9f4fa54bf09c366"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDk4NjM5MQ==", "bodyText": "same here", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r464986391", "createdAt": "2020-08-04T11:36:35Z", "author": {"login": "aneveu"}, "path": "docs/asciidoc/processors.adoc", "diffHunk": "@@ -83,81 +67,80 @@ fluxView\n ====\n \n \n-The `Sinks` flavors that can be viewed as `Flux` are:\n-\n-. `multicast()`: a sink that will transmit only newly pushed data to its subscribers, honoring their backpressure (newly pushed as in \"after the subscriber's subscription\").\n-. `multicastPreWarming()`: same as above, with the twist that data pushed before the first subscriber registers is buffered.\n-. `multicastReplayAll()`: a sink that will replay all the history of pushed data to new subscribers then continue pushing new data live.\n-. `multicastReplay(int)`: same as above, except the history of replayed data is limited in size.\n-. `unicast()`: the only sink that won't accept more than one `Subscriber`, but honors their backpressure\n-(and replays elements pushed to it before the Subscriber arrives)\n+The `Sinks` categories are:\n \n-There is currently only one `Sinks` flavor that can be viewed as `Mono`:\n-\n-. `trigger()`: a sink that will wait for a `Mono`-like interaction, propagate it to current `Subscribers` and additionally cache it for replaying to any late `Subscriber`.\n+. `many().multicast()`: a sink that will transmit only newly pushed data to its subscribers, honoring their backpressure (newly pushed as in \"after the subscriber's subscription\").\n+. `many().unicast()`: same as above, with the twist that data pushed before the first subscriber registers is buffered.\n+. `many().replay()`: a sink that will replay a specified history size of pushed data to new subscribers then continue pushing new data live.\n+. `singleOrEmpty()`: a sink that will play a single element to its subscribers\n+. `empty()`: a sink that will play a terminal signal only to its subscribers (error or complete)\n \n [[processor-overview]]\n-= Overview of Available Processors\n-\n-== Direct Processor\n+= Overview of Available Sinks\n \n-A direct `Processor` is a very simple processor that can dispatch signals to zero or more\n-`Subscribers`. On the other hand, *it has the limitation of not handling backpressure*.\n-As a consequence, a `DirectProcessor` signals an `IllegalStateException` to its\n-subscribers if you push N elements through it but at least one of its subscribers has\n-requested less than N.\n+== Sinks.many().unicast().onBackpressureBuffer(args?)\n \n-This aspect makes it a bit niche, and so the (only) factory method to create a direct processor\n-is hidden a bit: it is created via `Processors.more().multicastNoBackpressure()`.\n-\n-Once the `Processor` has terminated (usually through its sink's `error(Throwable)` or\n-`complete()` methods being called), it lets more subscribers subscribe but replays the\n-termination signal to them immediately.\n-\n-== Unicast Processor\n-\n-A unicast `Processor` can deal with backpressure by using an internal buffer. The trade-off\n+A unicast `sink` can deal with backpressure by using an internal buffer. The trade-off\n is that it can have _at most one_ `Subscriber`.\n \n-The basic unicast processor is created via `Processors.unicast()`.\n+The basic unicast sink is created via `Sinks.many().unicast().onBackpressureBuffer()`.\n But since it has a few more options than a direct processor, there are a few additional\n-`unicast` static factory methods in `Processors#more()`.\n+`unicast` static factory methods in `Sinks.many().unicast()`.\n \n For instance, by default, it is unbounded: If you push any amount of data through it while\n its `Subscriber` has not yet requested data, it buffers all of the data.\n You can change this by providing a custom `Queue` implementation for the internal\n-buffering in the `Processors.more().unicast(Queue)` factory method.\n+buffering in the `Sinks.many().unicast().onBackpressureBuffer(Queue)` factory method.\n If that queue is bounded, the processor could reject the push of a value when the buffer\n is full and not enough requests from downstream have been received.\n \n-In that _bounded_ case, you can also build the processor with a callback that is invoked\n-on each rejected element, allowing for cleanup of these rejected elements.\n+== Sinks.many().multicast().onBackpressureBuffer(args?)\n \n-== Multicast Processor\n-\n-An multicast `Processor` (sometimes referred to as an \"emitter\" processor) can emit to several\n+An multicast `Sink` can emit to several\n subscribers while honoring backpressure for each of its subscribers.\n Subscribers receive only the signals pushed through the processor after they have subscribed.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8cb64857c3c6a6ce5ae2e8e6d9f4fa54bf09c366"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDk4NjkxNA==", "bodyText": "A not An", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r464986914", "createdAt": "2020-08-04T11:37:39Z", "author": {"login": "aneveu"}, "path": "docs/asciidoc/processors.adoc", "diffHunk": "@@ -83,81 +67,80 @@ fluxView\n ====\n \n \n-The `Sinks` flavors that can be viewed as `Flux` are:\n-\n-. `multicast()`: a sink that will transmit only newly pushed data to its subscribers, honoring their backpressure (newly pushed as in \"after the subscriber's subscription\").\n-. `multicastPreWarming()`: same as above, with the twist that data pushed before the first subscriber registers is buffered.\n-. `multicastReplayAll()`: a sink that will replay all the history of pushed data to new subscribers then continue pushing new data live.\n-. `multicastReplay(int)`: same as above, except the history of replayed data is limited in size.\n-. `unicast()`: the only sink that won't accept more than one `Subscriber`, but honors their backpressure\n-(and replays elements pushed to it before the Subscriber arrives)\n+The `Sinks` categories are:\n \n-There is currently only one `Sinks` flavor that can be viewed as `Mono`:\n-\n-. `trigger()`: a sink that will wait for a `Mono`-like interaction, propagate it to current `Subscribers` and additionally cache it for replaying to any late `Subscriber`.\n+. `many().multicast()`: a sink that will transmit only newly pushed data to its subscribers, honoring their backpressure (newly pushed as in \"after the subscriber's subscription\").\n+. `many().unicast()`: same as above, with the twist that data pushed before the first subscriber registers is buffered.\n+. `many().replay()`: a sink that will replay a specified history size of pushed data to new subscribers then continue pushing new data live.\n+. `singleOrEmpty()`: a sink that will play a single element to its subscribers\n+. `empty()`: a sink that will play a terminal signal only to its subscribers (error or complete)\n \n [[processor-overview]]\n-= Overview of Available Processors\n-\n-== Direct Processor\n+= Overview of Available Sinks\n \n-A direct `Processor` is a very simple processor that can dispatch signals to zero or more\n-`Subscribers`. On the other hand, *it has the limitation of not handling backpressure*.\n-As a consequence, a `DirectProcessor` signals an `IllegalStateException` to its\n-subscribers if you push N elements through it but at least one of its subscribers has\n-requested less than N.\n+== Sinks.many().unicast().onBackpressureBuffer(args?)\n \n-This aspect makes it a bit niche, and so the (only) factory method to create a direct processor\n-is hidden a bit: it is created via `Processors.more().multicastNoBackpressure()`.\n-\n-Once the `Processor` has terminated (usually through its sink's `error(Throwable)` or\n-`complete()` methods being called), it lets more subscribers subscribe but replays the\n-termination signal to them immediately.\n-\n-== Unicast Processor\n-\n-A unicast `Processor` can deal with backpressure by using an internal buffer. The trade-off\n+A unicast `sink` can deal with backpressure by using an internal buffer. The trade-off\n is that it can have _at most one_ `Subscriber`.\n \n-The basic unicast processor is created via `Processors.unicast()`.\n+The basic unicast sink is created via `Sinks.many().unicast().onBackpressureBuffer()`.\n But since it has a few more options than a direct processor, there are a few additional\n-`unicast` static factory methods in `Processors#more()`.\n+`unicast` static factory methods in `Sinks.many().unicast()`.\n \n For instance, by default, it is unbounded: If you push any amount of data through it while\n its `Subscriber` has not yet requested data, it buffers all of the data.\n You can change this by providing a custom `Queue` implementation for the internal\n-buffering in the `Processors.more().unicast(Queue)` factory method.\n+buffering in the `Sinks.many().unicast().onBackpressureBuffer(Queue)` factory method.\n If that queue is bounded, the processor could reject the push of a value when the buffer\n is full and not enough requests from downstream have been received.\n \n-In that _bounded_ case, you can also build the processor with a callback that is invoked\n-on each rejected element, allowing for cleanup of these rejected elements.\n+== Sinks.many().multicast().onBackpressureBuffer(args?)\n \n-== Multicast Processor\n-\n-An multicast `Processor` (sometimes referred to as an \"emitter\" processor) can emit to several\n+An multicast `Sink` can emit to several", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8cb64857c3c6a6ce5ae2e8e6d9f4fa54bf09c366"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDk4ODUzMA==", "bodyText": "either not needed anymore", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r464988530", "createdAt": "2020-08-04T11:40:52Z", "author": {"login": "aneveu"}, "path": "reactor-core/src/main/java/reactor/core/publisher/DirectProcessor.java", "diffHunk": "@@ -78,10 +79,10 @@\n  * </p>\n  *\n  * @param <T> the input and output value type\n- * @deprecated Prefer clear cut usage of either {@link Processors} or {@link Sinks}, to be removed in 3.5\n+ * @deprecated Prefer clear cut usage of either {@link Sinks}, to be removed in 3.5", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8cb64857c3c6a6ce5ae2e8e6d9f4fa54bf09c366"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDk4OTQ3OQ==", "bodyText": "either not needed anymore", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r464989479", "createdAt": "2020-08-04T11:43:00Z", "author": {"login": "aneveu"}, "path": "reactor-core/src/main/java/reactor/core/publisher/EmitterProcessor.java", "diffHunk": "@@ -51,10 +51,10 @@\n  * @param <T> the input and output value type\n  *\n  * @author Stephane Maldini\n- * @deprecated Prefer clear cut usage of either {@link Processors} or {@link Sinks}, to be removed in 3.5\n+ * @deprecated Prefer clear cut usage of either {@link Sinks}, to be removed in 3.5", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8cb64857c3c6a6ce5ae2e8e6d9f4fa54bf09c366"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE1MDQ4MQ==", "bodyText": "either not needed anymore", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r465150481", "createdAt": "2020-08-04T15:47:54Z", "author": {"login": "aneveu"}, "path": "reactor-core/src/main/java/reactor/core/publisher/ReplayProcessor.java", "diffHunk": "@@ -46,11 +47,11 @@\n  * <p>\n  *\n  * @param <T> the value type\n- * @deprecated Prefer clear cut usage of either {@link Processors} or {@link Sinks}, to be removed in 3.5\n+ * @deprecated Prefer clear cut usage of either {@link Sinks}, to be removed in 3.5", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f9026ae5240238fd353b119d1c89bff9fa10676b"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE1MjM0NQ==", "bodyText": "Should we keep the Standalone prefix in this class name?", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r465152345", "createdAt": "2020-08-04T15:50:39Z", "author": {"login": "aneveu"}, "path": "reactor-core/src/main/java/reactor/core/publisher/SinksSpecs.java", "diffHunk": "@@ -0,0 +1,385 @@\n+package reactor.core.publisher;\n+\n+import java.time.Duration;\n+import java.util.Objects;\n+import java.util.Queue;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.stream.Stream;\n+\n+import org.reactivestreams.Subscription;\n+\n+import reactor.core.CoreSubscriber;\n+import reactor.core.Disposable;\n+import reactor.core.Exceptions;\n+import reactor.core.Scannable;\n+import reactor.core.publisher.Sinks.Emission;\n+import reactor.core.publisher.Sinks.Many;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.util.annotation.Nullable;\n+import reactor.util.concurrent.Queues;\n+import reactor.util.context.Context;\n+\n+final class SinksSpecs {\n+\tstatic final ManySpecImpl            MANY_SPEC                    = new ManySpecImpl();\n+\tstatic final UnicastSpecImpl         UNICAST_SPEC                 = new UnicastSpecImpl(true);\n+\tstatic final MulticastSpecImpl       MULTICAST_SPEC               = new MulticastSpecImpl(true);\n+\tstatic final MulticastReplaySpecImpl MULTICAST_REPLAY_SPEC        = new MulticastReplaySpecImpl(true);\n+\tstatic final UnsafeManySpecImpl      UNSAFE_MANY_SPEC             = new UnsafeManySpecImpl();\n+\tstatic final UnicastSpecImpl         UNSAFE_UNICAST_SPEC          = new UnicastSpecImpl(false);\n+\tstatic final MulticastSpecImpl       UNSAFE_MULTICAST_SPEC        = new MulticastSpecImpl(false);\n+\tstatic final MulticastReplaySpecImpl UNSAFE_MULTICAST_REPLAY_SPEC = new MulticastReplaySpecImpl(false);\n+\n+}\n+\n+final class SerializedStandaloneSink<T> implements Many<T>, Scannable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f9026ae5240238fd353b119d1c89bff9fa10676b"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE1NTc0NA==", "bodyText": "either not needed anymore", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r465155744", "createdAt": "2020-08-04T15:55:43Z", "author": {"login": "aneveu"}, "path": "reactor-core/src/main/java/reactor/core/publisher/UnicastProcessor.java", "diffHunk": "@@ -83,11 +84,12 @@\n  * </p>\n  *\n  * @param <T> the input and output type\n- * @deprecated Prefer clear cut usage of either {@link Processors} or {@link Sinks}, to be removed in 3.5\n+ * @deprecated Prefer clear cut usage of either {@link Sinks}, to be removed in 3.5", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f9026ae5240238fd353b119d1c89bff9fa10676b"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE2MjAzMQ==", "bodyText": "not really important but the name of the variable was already quite unclear before and it becomes completely impossible to link to anything now \ud83d\ude05", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r465162031", "createdAt": "2020-08-04T16:05:11Z", "author": {"login": "aneveu"}, "path": "reactor-core/src/test/java/reactor/core/publisher/FluxFilterWhenTest.java", "diffHunk": "@@ -254,13 +254,13 @@ protected void hookFinally(SignalType type) {\n \n \t@Test\n \tpublic void cancel() {\n-\t\tfinal FluxIdentityProcessor<Boolean> pp = Processors.multicast();\n+\t\tfinal Sinks.Many<Boolean> pp = Sinks.many().multicast().onBackpressureBuffer();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f9026ae5240238fd353b119d1c89bff9fa10676b"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMTQ5ODU1", "url": "https://github.com/reactor/reactor-core/pull/2218#pullrequestreview-461149855", "createdAt": "2020-08-04T20:29:26Z", "commit": {"oid": "f9026ae5240238fd353b119d1c89bff9fa10676b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "406003bcd7b10283c040f7b409e475ab16ae9c36", "author": {"user": {"login": "smaldini", "name": "Stephane Maldini"}}, "url": "https://github.com/reactor/reactor-core/commit/406003bcd7b10283c040f7b409e475ab16ae9c36", "committedDate": "2020-08-05T09:42:41Z", "message": "Rework of M1 Sinks, further separate standalone Sinks API (#1037, #2218)\n\nThis commit is a rework of the `Sinks` approach introduced in 3.4.0-M1\n(see #2179 and #2188).\n\nSince the original goal is the ultimate hiding of most processors\nimplementations, the `Processors` factory has been removed. In a similar\neffort NOT to give traction to processor use, `FluxIdentityProcessor`\nhas also been removed and replaced by the pre-existing equivalent of\n`FluxProcessor<T, T>`.\n\nThe `StandaloneFluxSink` and `StandaloneMonoSink` have been reworked:\nthere is no `SequenceSink` and `ScalarSink` common superinterface, so\nthese new sinks don't share API with pre-existing `FluxSink` and\n`MonoSink` anymore. The later are both reserved for in-operator sink\nusage, with an API that reflects their association with a single\nsubscription.\n\nInstead, this commit introduces flavors of sinks that are meant to be\nused as publishers, regrouped under the `Sinks` class to clearly mark\nthey're 3 sides of a similar concept: `Sinks.Empty`, `Sinks.One` and\n`Sinks.Many`. The intent is to always keep the `Sinks` prefix to clarify\nthe nature of the objects.\n\nThese sinks don't expose a fluent API, but rather expose `emitXxx`\nmethods that trigger relevant signals in their `Subscriber`s. They also\neach expose a \"view method\", either `asMono()` or `asFlux`, which allows\ndownstream code to see the sink as a `Publisher` and subscribe to it.\nThese emit methods return a `Sinks.Emission` enum indicating success or\nfailure to emit, further distinguishing between cases for failure.\nThis later point fixes #1037.\n\nThis different API allows efficient instance creation since the\nconcrete implementations are processors which also directly implement\nthe sinks and their view.\n\nReviewed-in: #2218\nCo-authored-by: Stephane Maldini <smaldini@netflix.com>\nCo-authored-by: Simon Basl\u00e9 <sbasle@vmware.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a3bccb838e931355febf3538ea593cead2575e3b", "author": {"user": {"login": "simonbasle", "name": "Simon Basl\u00e9"}}, "url": "https://github.com/reactor/reactor-core/commit/a3bccb838e931355febf3538ea593cead2575e3b", "committedDate": "2020-08-05T09:46:41Z", "message": "fix #2049 Fail fast if EmitterProcessor queue is full\n\nThis commit replaces the wait-loop in 10ns increments with a fail-fast\nwhich returns Emission.FAIL_OVERFLOW if the backpressure queue is full.\n\nReviewed-in: #2218\nCo-authored-by: Stephane Maldini <smaldini@netflix.com>\nCo-authored-by: Simon Basl\u00e9 <sbasle@vmware.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4a172f2212a3876dec1167013901b04d2cb9d9cb", "author": {"user": {"login": "simonbasle", "name": "Simon Basl\u00e9"}}, "url": "https://github.com/reactor/reactor-core/commit/4a172f2212a3876dec1167013901b04d2cb9d9cb", "committedDate": "2020-08-05T08:47:51Z", "message": "Document Sinks.one and Sinks.empty"}, "afterCommit": {"oid": "a3bccb838e931355febf3538ea593cead2575e3b", "author": {"user": {"login": "simonbasle", "name": "Simon Basl\u00e9"}}, "url": "https://github.com/reactor/reactor-core/commit/a3bccb838e931355febf3538ea593cead2575e3b", "committedDate": "2020-08-05T09:46:41Z", "message": "fix #2049 Fail fast if EmitterProcessor queue is full\n\nThis commit replaces the wait-loop in 10ns increments with a fail-fast\nwhich returns Emission.FAIL_OVERFLOW if the backpressure queue is full.\n\nReviewed-in: #2218\nCo-authored-by: Stephane Maldini <smaldini@netflix.com>\nCo-authored-by: Simon Basl\u00e9 <sbasle@vmware.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxNTA4NTM1", "url": "https://github.com/reactor/reactor-core/pull/2218#pullrequestreview-461508535", "createdAt": "2020-08-05T09:48:46Z", "commit": {"oid": "a3bccb838e931355febf3538ea593cead2575e3b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2750, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}