{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA4MjI0MTIx", "number": 2134, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQwNzo1NToxMVrOD1pP5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxMjo0ODo0OVrOD1wg_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3NTc2OTMzOnYy", "diffSide": "RIGHT", "path": "reactor-core/src/test/java/reactor/core/publisher/OnDiscardShouldNotLeakTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQwNzo1NToxMVrOGLLTAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQwNzo1NjoyMFrOGLLVvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDM3MjYxMA==", "bodyText": "formatting: there shouldn't be spaces in this file if you use the official Reactor intellij format", "url": "https://github.com/reactor/reactor-core/pull/2134#discussion_r414372610", "createdAt": "2020-04-24T07:55:11Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/test/java/reactor/core/publisher/OnDiscardShouldNotLeakTest.java", "diffHunk": "@@ -45,24 +45,50 @@\n @RunWith(Parameterized.class)\n public class OnDiscardShouldNotLeakTest {\n \n-\t//add DiscardScenarios here to test more operators\n-\tprivate static DiscardScenario[] SCENARIOS = new DiscardScenario[] {\n-\t\t\tDiscardScenario.allFluxSourceArray(\"merge\", 4, Flux::merge),\n-\t\t\tDiscardScenario.fluxSource(\"onBackpressureBuffer\", 1, Flux::onBackpressureBuffer),\n-\t\t\tDiscardScenario.rawSource(\"flatMapInner\", 1, raw -> Flux.just(1).flatMap(f -> raw)),\n-\t\t\tDiscardScenario.fluxSource(\"flatMap\", 1, main -> main.flatMap(f -> Mono.just(f).hide().flux())),\n-\t\t\tDiscardScenario.fluxSource(\"flatMapIterable\", 1, f -> f.flatMapIterable(Arrays::asList)),\n-\t\t\tDiscardScenario.fluxSource(\"publishOnDelayErrors\", 1, f -> f.publishOn(Schedulers.immediate())),\n-\t\t\tDiscardScenario.fluxSource(\"publishOnImmediateErrors\", 1, f -> f.publishOn(Schedulers.immediate(), false, Queues.SMALL_BUFFER_SIZE)),\n-\t\t\tDiscardScenario.fluxSource(\"unicastProcessor\", 1, f -> f.subscribeWith(UnicastProcessor.create()))\n-\t};\n-\n-\tprivate static boolean[][] CONDITIONAL_AND_FUSED = new boolean[][] {\n-\t\t\t{ false, false },\n-\t\t\t{ true, false },\n-\t\t\t{ false, true },\n-\t\t\t{ true, true }\n-\t};\n+    //add DiscardScenarios here to test more operators", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e99c33fc9e6e6c663ec57b9edc8ceb63f9361f43"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDM3MzMwOA==", "bodyText": "\ud83d\ude43fixed", "url": "https://github.com/reactor/reactor-core/pull/2134#discussion_r414373308", "createdAt": "2020-04-24T07:56:20Z", "author": {"login": "OlegDokuka"}, "path": "reactor-core/src/test/java/reactor/core/publisher/OnDiscardShouldNotLeakTest.java", "diffHunk": "@@ -45,24 +45,50 @@\n @RunWith(Parameterized.class)\n public class OnDiscardShouldNotLeakTest {\n \n-\t//add DiscardScenarios here to test more operators\n-\tprivate static DiscardScenario[] SCENARIOS = new DiscardScenario[] {\n-\t\t\tDiscardScenario.allFluxSourceArray(\"merge\", 4, Flux::merge),\n-\t\t\tDiscardScenario.fluxSource(\"onBackpressureBuffer\", 1, Flux::onBackpressureBuffer),\n-\t\t\tDiscardScenario.rawSource(\"flatMapInner\", 1, raw -> Flux.just(1).flatMap(f -> raw)),\n-\t\t\tDiscardScenario.fluxSource(\"flatMap\", 1, main -> main.flatMap(f -> Mono.just(f).hide().flux())),\n-\t\t\tDiscardScenario.fluxSource(\"flatMapIterable\", 1, f -> f.flatMapIterable(Arrays::asList)),\n-\t\t\tDiscardScenario.fluxSource(\"publishOnDelayErrors\", 1, f -> f.publishOn(Schedulers.immediate())),\n-\t\t\tDiscardScenario.fluxSource(\"publishOnImmediateErrors\", 1, f -> f.publishOn(Schedulers.immediate(), false, Queues.SMALL_BUFFER_SIZE)),\n-\t\t\tDiscardScenario.fluxSource(\"unicastProcessor\", 1, f -> f.subscribeWith(UnicastProcessor.create()))\n-\t};\n-\n-\tprivate static boolean[][] CONDITIONAL_AND_FUSED = new boolean[][] {\n-\t\t\t{ false, false },\n-\t\t\t{ true, false },\n-\t\t\t{ false, true },\n-\t\t\t{ true, true }\n-\t};\n+    //add DiscardScenarios here to test more operators", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDM3MjYxMA=="}, "originalCommit": {"oid": "e99c33fc9e6e6c663ec57b9edc8ceb63f9361f43"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3NjgyMDgxOnYy", "diffSide": "RIGHT", "path": "reactor-core/src/main/java/reactor/core/publisher/FluxOnBackpressureBuffer.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxMjoxNDoxN1rOGLU09w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxMjoyOToxMFrOGLVYLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDUyODc1OQ==", "bodyText": "nitpick: can you rename the variable to at least stick to the convention that local copies in drain loops are named after the initial of their corresponding field? it. w becomes dg", "url": "https://github.com/reactor/reactor-core/pull/2134#discussion_r414528759", "createdAt": "2020-04-24T12:14:17Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/FluxOnBackpressureBuffer.java", "diffHunk": "@@ -349,7 +364,29 @@ public boolean isEmpty() {\n \n \t\t@Override\n \t\tpublic void clear() {\n-\t\t\tOperators.onDiscardQueueWithClear(queue, ctx, null);\n+\t\t\t// use guard on the queue instance as the best way to ensure there is no racing on draining\n+\t\t\t// the call to this method must be done only during the ASYNC fusion so all the callers will be waiting\n+\t\t\t// this should not ber performance costly with the assumption the cancel is rare operation\n+\t\t\tif (DISCARD_GUARD.getAndIncrement(this) != 0) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\n+\t\t\tint missed = 1;\n+\n+\t\t\tfor (;;) {\n+\t\t\t\tOperators.onDiscardQueueWithClear(queue, ctx, null);\n+\n+\t\t\t\tint w = discardGuard;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21ea73e22f70520f2b03da0176ae38aac419321c"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDUzMDg2MQ==", "bodyText": "applies to all occurrences below as well", "url": "https://github.com/reactor/reactor-core/pull/2134#discussion_r414530861", "createdAt": "2020-04-24T12:17:46Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/FluxOnBackpressureBuffer.java", "diffHunk": "@@ -349,7 +364,29 @@ public boolean isEmpty() {\n \n \t\t@Override\n \t\tpublic void clear() {\n-\t\t\tOperators.onDiscardQueueWithClear(queue, ctx, null);\n+\t\t\t// use guard on the queue instance as the best way to ensure there is no racing on draining\n+\t\t\t// the call to this method must be done only during the ASYNC fusion so all the callers will be waiting\n+\t\t\t// this should not ber performance costly with the assumption the cancel is rare operation\n+\t\t\tif (DISCARD_GUARD.getAndIncrement(this) != 0) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\n+\t\t\tint missed = 1;\n+\n+\t\t\tfor (;;) {\n+\t\t\t\tOperators.onDiscardQueueWithClear(queue, ctx, null);\n+\n+\t\t\t\tint w = discardGuard;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDUyODc1OQ=="}, "originalCommit": {"oid": "21ea73e22f70520f2b03da0176ae38aac419321c"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDUzNzc3NA==", "bodyText": "fixed", "url": "https://github.com/reactor/reactor-core/pull/2134#discussion_r414537774", "createdAt": "2020-04-24T12:29:10Z", "author": {"login": "OlegDokuka"}, "path": "reactor-core/src/main/java/reactor/core/publisher/FluxOnBackpressureBuffer.java", "diffHunk": "@@ -349,7 +364,29 @@ public boolean isEmpty() {\n \n \t\t@Override\n \t\tpublic void clear() {\n-\t\t\tOperators.onDiscardQueueWithClear(queue, ctx, null);\n+\t\t\t// use guard on the queue instance as the best way to ensure there is no racing on draining\n+\t\t\t// the call to this method must be done only during the ASYNC fusion so all the callers will be waiting\n+\t\t\t// this should not ber performance costly with the assumption the cancel is rare operation\n+\t\t\tif (DISCARD_GUARD.getAndIncrement(this) != 0) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\n+\t\t\tint missed = 1;\n+\n+\t\t\tfor (;;) {\n+\t\t\t\tOperators.onDiscardQueueWithClear(queue, ctx, null);\n+\n+\t\t\t\tint w = discardGuard;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDUyODc1OQ=="}, "originalCommit": {"oid": "21ea73e22f70520f2b03da0176ae38aac419321c"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3NjgyODI1OnYy", "diffSide": "RIGHT", "path": "reactor-core/src/main/java/reactor/core/publisher/FluxOnBackpressureBuffer.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxMjoxNjowNVrOGLU5Ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxMjoyOTowNlrOGLVYEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDUyOTg0Ng==", "bodyText": "typo not ber -> not be", "url": "https://github.com/reactor/reactor-core/pull/2134#discussion_r414529846", "createdAt": "2020-04-24T12:16:05Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/FluxOnBackpressureBuffer.java", "diffHunk": "@@ -349,7 +364,29 @@ public boolean isEmpty() {\n \n \t\t@Override\n \t\tpublic void clear() {\n-\t\t\tOperators.onDiscardQueueWithClear(queue, ctx, null);\n+\t\t\t// use guard on the queue instance as the best way to ensure there is no racing on draining\n+\t\t\t// the call to this method must be done only during the ASYNC fusion so all the callers will be waiting\n+\t\t\t// this should not ber performance costly with the assumption the cancel is rare operation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21ea73e22f70520f2b03da0176ae38aac419321c"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDUzMDc5OQ==", "bodyText": "applies to all occurrences below as well", "url": "https://github.com/reactor/reactor-core/pull/2134#discussion_r414530799", "createdAt": "2020-04-24T12:17:40Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/main/java/reactor/core/publisher/FluxOnBackpressureBuffer.java", "diffHunk": "@@ -349,7 +364,29 @@ public boolean isEmpty() {\n \n \t\t@Override\n \t\tpublic void clear() {\n-\t\t\tOperators.onDiscardQueueWithClear(queue, ctx, null);\n+\t\t\t// use guard on the queue instance as the best way to ensure there is no racing on draining\n+\t\t\t// the call to this method must be done only during the ASYNC fusion so all the callers will be waiting\n+\t\t\t// this should not ber performance costly with the assumption the cancel is rare operation", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDUyOTg0Ng=="}, "originalCommit": {"oid": "21ea73e22f70520f2b03da0176ae38aac419321c"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDUzNzc0Nw==", "bodyText": "fixed", "url": "https://github.com/reactor/reactor-core/pull/2134#discussion_r414537747", "createdAt": "2020-04-24T12:29:06Z", "author": {"login": "OlegDokuka"}, "path": "reactor-core/src/main/java/reactor/core/publisher/FluxOnBackpressureBuffer.java", "diffHunk": "@@ -349,7 +364,29 @@ public boolean isEmpty() {\n \n \t\t@Override\n \t\tpublic void clear() {\n-\t\t\tOperators.onDiscardQueueWithClear(queue, ctx, null);\n+\t\t\t// use guard on the queue instance as the best way to ensure there is no racing on draining\n+\t\t\t// the call to this method must be done only during the ASYNC fusion so all the callers will be waiting\n+\t\t\t// this should not ber performance costly with the assumption the cancel is rare operation", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDUyOTg0Ng=="}, "originalCommit": {"oid": "21ea73e22f70520f2b03da0176ae38aac419321c"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3NjgzMzU5OnYy", "diffSide": "RIGHT", "path": "reactor-core/src/test/java/reactor/core/publisher/OnDiscardShouldNotLeakTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxMjoxNzoyM1rOGLU8RQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxMjoyOTowM1rOGLVX8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDUzMDYyOQ==", "bodyText": "still whitespace formatting issue", "url": "https://github.com/reactor/reactor-core/pull/2134#discussion_r414530629", "createdAt": "2020-04-24T12:17:23Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/test/java/reactor/core/publisher/OnDiscardShouldNotLeakTest.java", "diffHunk": "@@ -45,24 +45,50 @@\n @RunWith(Parameterized.class)\n public class OnDiscardShouldNotLeakTest {\n \n-\t//add DiscardScenarios here to test more operators\n-\tprivate static DiscardScenario[] SCENARIOS = new DiscardScenario[] {\n-\t\t\tDiscardScenario.allFluxSourceArray(\"merge\", 4, Flux::merge),\n-\t\t\tDiscardScenario.fluxSource(\"onBackpressureBuffer\", 1, Flux::onBackpressureBuffer),\n-\t\t\tDiscardScenario.rawSource(\"flatMapInner\", 1, raw -> Flux.just(1).flatMap(f -> raw)),\n-\t\t\tDiscardScenario.fluxSource(\"flatMap\", 1, main -> main.flatMap(f -> Mono.just(f).hide().flux())),\n-\t\t\tDiscardScenario.fluxSource(\"flatMapIterable\", 1, f -> f.flatMapIterable(Arrays::asList)),\n-\t\t\tDiscardScenario.fluxSource(\"publishOnDelayErrors\", 1, f -> f.publishOn(Schedulers.immediate())),\n-\t\t\tDiscardScenario.fluxSource(\"publishOnImmediateErrors\", 1, f -> f.publishOn(Schedulers.immediate(), false, Queues.SMALL_BUFFER_SIZE)),\n-\t\t\tDiscardScenario.fluxSource(\"unicastProcessor\", 1, f -> f.subscribeWith(UnicastProcessor.create()))\n-\t};\n-\n-\tprivate static boolean[][] CONDITIONAL_AND_FUSED = new boolean[][] {\n-\t\t\t{ false, false },\n-\t\t\t{ true, false },\n-\t\t\t{ false, true },\n-\t\t\t{ true, true }\n-\t};\n+    // add DiscardScenarios here to test more operators", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21ea73e22f70520f2b03da0176ae38aac419321c"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDUzNzcxMg==", "bodyText": "fixed", "url": "https://github.com/reactor/reactor-core/pull/2134#discussion_r414537712", "createdAt": "2020-04-24T12:29:03Z", "author": {"login": "OlegDokuka"}, "path": "reactor-core/src/test/java/reactor/core/publisher/OnDiscardShouldNotLeakTest.java", "diffHunk": "@@ -45,24 +45,50 @@\n @RunWith(Parameterized.class)\n public class OnDiscardShouldNotLeakTest {\n \n-\t//add DiscardScenarios here to test more operators\n-\tprivate static DiscardScenario[] SCENARIOS = new DiscardScenario[] {\n-\t\t\tDiscardScenario.allFluxSourceArray(\"merge\", 4, Flux::merge),\n-\t\t\tDiscardScenario.fluxSource(\"onBackpressureBuffer\", 1, Flux::onBackpressureBuffer),\n-\t\t\tDiscardScenario.rawSource(\"flatMapInner\", 1, raw -> Flux.just(1).flatMap(f -> raw)),\n-\t\t\tDiscardScenario.fluxSource(\"flatMap\", 1, main -> main.flatMap(f -> Mono.just(f).hide().flux())),\n-\t\t\tDiscardScenario.fluxSource(\"flatMapIterable\", 1, f -> f.flatMapIterable(Arrays::asList)),\n-\t\t\tDiscardScenario.fluxSource(\"publishOnDelayErrors\", 1, f -> f.publishOn(Schedulers.immediate())),\n-\t\t\tDiscardScenario.fluxSource(\"publishOnImmediateErrors\", 1, f -> f.publishOn(Schedulers.immediate(), false, Queues.SMALL_BUFFER_SIZE)),\n-\t\t\tDiscardScenario.fluxSource(\"unicastProcessor\", 1, f -> f.subscribeWith(UnicastProcessor.create()))\n-\t};\n-\n-\tprivate static boolean[][] CONDITIONAL_AND_FUSED = new boolean[][] {\n-\t\t\t{ false, false },\n-\t\t\t{ true, false },\n-\t\t\t{ false, true },\n-\t\t\t{ true, true }\n-\t};\n+    // add DiscardScenarios here to test more operators", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDUzMDYyOQ=="}, "originalCommit": {"oid": "21ea73e22f70520f2b03da0176ae38aac419321c"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3Njk1OTk4OnYy", "diffSide": "RIGHT", "path": "reactor-core/src/test/java/reactor/core/publisher/OnDiscardShouldNotLeakTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxMjo0ODo0OVrOGLWGeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxMzowNzoyNFrOGLWz-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDU0OTYyNQ==", "bodyText": "haha nice try, I meant on the whole file \ud83d\ude1b", "url": "https://github.com/reactor/reactor-core/pull/2134#discussion_r414549625", "createdAt": "2020-04-24T12:48:49Z", "author": {"login": "simonbasle"}, "path": "reactor-core/src/test/java/reactor/core/publisher/OnDiscardShouldNotLeakTest.java", "diffHunk": "@@ -45,7 +45,7 @@\n @RunWith(Parameterized.class)\n public class OnDiscardShouldNotLeakTest {\n \n-    // add DiscardScenarios here to test more operators\n+\t// add DiscardScenarios here to test more operators", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20bf3e64415848d3ebe07039449693e58052d302"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDU2MTI3Mw==", "bodyText": "formated the whole file :D", "url": "https://github.com/reactor/reactor-core/pull/2134#discussion_r414561273", "createdAt": "2020-04-24T13:07:24Z", "author": {"login": "OlegDokuka"}, "path": "reactor-core/src/test/java/reactor/core/publisher/OnDiscardShouldNotLeakTest.java", "diffHunk": "@@ -45,7 +45,7 @@\n @RunWith(Parameterized.class)\n public class OnDiscardShouldNotLeakTest {\n \n-    // add DiscardScenarios here to test more operators\n+\t// add DiscardScenarios here to test more operators", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDU0OTYyNQ=="}, "originalCommit": {"oid": "20bf3e64415848d3ebe07039449693e58052d302"}, "originalPosition": 5}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1037, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}