{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ2NDAxNTk5", "number": 1501, "title": "Semantic highlighting improvements", "bodyText": "Implements redhat-developer/vscode-java#1488\nFixes redhat-developer/vscode-java#1514\nChanges\n\nAdded some javadoc comments to the semantic highlighting classes\nFixed indentation of the semantic highlighting classes, as per the .editorconfig\n\nToken types and modifiers\n\n\nBoth token types and modifiers can now be found in their respective enum.\n\n\nMade the naming scheme more consistent\n\nThe enum members now have \"Java-names\", such as TokenType.METHOD instead of TokenType.FUNCTION\nThe toString() method on the enum members return the more generic name used in the legend.\n\n\n\nRemoved unused token types\n\n\nAdded new token types:\n\nClass\nInterface\nEnum\nEnum member\nType parameter\nParameter\nAnnotation member (Example: value in @SuppressWarnings(value = \"all\"))\n\n\n\nAdded new token modifiers:\n\nDeclaration\n\n\n\nSemantic tokens visitor\n\nMoved all the logic that figures out applicable token types and modifiers into TokenType and TokenModifier enums.\nNo longer merges the entire qualified name of a package into one token\n\nThis is to avoid inconsistencies with the \"dots\", for example:\n\nThe dot between java and lang in java.lang.Math is part of a namespace token\nThe dot between lang and Math is not part of a namespace token\nIt does not make sense for any of the dots to be part of a namespace token\n\n\nI am aware that this change was implemented to fix redhat-developer/vscode-java#1434\n\nBut in my testing this issue seems to no longer appear even with my revert\nIf someone finds that this change introduces the issue again, we can revert it\n\n\n\n\nNow tries to more precisely highlight the invocation of a constructor, fixes redhat-developer/vscode-java#1514\nNow applies token modifiers in cases where it previously did not. (Types and annotations, for example.)\n\nTesting\nI did not manage to run the tests, since they failed halfway through even before I made any changes to the code (I will try to debug this soon). At least one test will fail because of the change I made to the merging of package names, so that test will have to be rewritten. Also, I haven't written any tests for the above changes, since I could not set up testing to work on my machine. It would be very kind of someone to help me write these tests, maybe @Eskibear since you wrote the other semantic highlighting tests? I will try to get testing to work for me in the meantime.", "createdAt": "2020-07-08T18:05:03Z", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1501", "merged": true, "mergeCommit": {"oid": "2eb3c193815fbb4d13ed55e8fb0f3e86e8bcf294"}, "closed": true, "closedAt": "2020-07-21T10:10:19Z", "author": {"login": "0dinD"}, "timelineItems": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABczcA39gFqTQ0NjExMzc0OQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABc3BrUKABqjM1Njk4NTM2NTQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2MTEzNzQ5", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1501#pullrequestreview-446113749", "createdAt": "2020-07-10T04:26:14Z", "commit": {"oid": "a8c033511caaeb3dc3346b795caa0533b00884e2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwNDoyNjoxNFrOGvpcjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwNDoyNjoxNFrOGvpcjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYxNTMwOA==", "bodyText": "redhat-developer/vscode-java#1434 is introduced again. And by the way it's not only for java.", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1501#discussion_r452615308", "createdAt": "2020-07-10T04:26:14Z", "author": {"login": "Eskibear"}, "path": "org.eclipse.jdt.ls.core/src/org/eclipse/jdt/ls/core/internal/semantictokens/SemanticTokensVisitor.java", "diffHunk": "@@ -18,204 +18,212 @@\n \n import org.eclipse.jdt.core.dom.ASTNode;\n import org.eclipse.jdt.core.dom.ASTVisitor;\n-import org.eclipse.jdt.core.dom.Annotation;\n import org.eclipse.jdt.core.dom.ClassInstanceCreation;\n-import org.eclipse.jdt.core.dom.IBinding;\n-import org.eclipse.jdt.core.dom.IVariableBinding;\n-import org.eclipse.jdt.core.dom.MethodInvocation;\n+import org.eclipse.jdt.core.dom.NameQualifiedType;\n+import org.eclipse.jdt.core.dom.ParameterizedType;\n import org.eclipse.jdt.core.dom.QualifiedName;\n+import org.eclipse.jdt.core.dom.QualifiedType;\n import org.eclipse.jdt.core.dom.SimpleName;\n import org.eclipse.jdt.core.dom.SimpleType;\n+import org.eclipse.jdt.core.dom.Type;\n import org.eclipse.jdt.ls.core.internal.handlers.JsonRpcHelpers;\n import org.eclipse.jface.text.IDocument;\n \n public class SemanticTokensVisitor extends ASTVisitor {\n-    private IDocument document;\n-    private SemanticTokenManager manager;\n-    private List<SemanticToken> tokens;\n-\n-    public final static ITokenModifier[] NO_MODIFIERS = {};\n-\n-    public SemanticTokensVisitor(IDocument document, SemanticTokenManager manager) {\n-        this.manager = manager;\n-        this.document = document;\n-        this.tokens = new ArrayList<>();\n-    }\n-\n-    private class SemanticToken {\n-        private final TokenType tokenType;\n-        private final ITokenModifier[] tokenModifiers;\n-        private final int offset;\n-        private final int length;\n-\n-        public SemanticToken(int offset, int length, TokenType tokenType, ITokenModifier[] tokenModifiers) {\n-            this.offset = offset;\n-            this.length = length;\n-            this.tokenType = tokenType;\n-            this.tokenModifiers = tokenModifiers;\n-        }\n-\n-        public TokenType getTokenType() {\n-            return tokenType;\n-        }\n-\n-        public ITokenModifier[] getTokenModifiers() {\n-            return tokenModifiers;\n-        }\n-\n-        public int getOffset() {\n-            return offset;\n-        }\n-\n-        public int getLength() {\n-            return length;\n-        }\n-    }\n-\n-    public SemanticTokens getSemanticTokens() {\n-        List<Integer> data = encoded();\n-        return new SemanticTokens(data);\n-    }\n-\n-    private List<Integer> encoded() {\n-        List<Integer> data = new ArrayList<>();\n-        int currentLine = 0;\n-        int currentColumn = 0;\n-        for (SemanticToken token : this.tokens) {\n-            int[] lineAndColumn = JsonRpcHelpers.toLine(this.document, token.getOffset());\n-            int line = lineAndColumn[0];\n-            int column = lineAndColumn[1];\n-            int deltaLine = line - currentLine;\n-            if (deltaLine != 0) {\n-                currentLine = line;\n-                currentColumn = 0;\n-            }\n-            int deltaColumn = column - currentColumn;\n-            currentColumn = column;\n-            // Disallow duplicate/conflict token (if exists)\n-            if (deltaLine != 0 || deltaColumn != 0) {\n-                int tokenTypeIndex = manager.getTokenTypes().indexOf(token.getTokenType());\n-                ITokenModifier[] modifiers = token.getTokenModifiers();\n-                int encodedModifiers = 0;\n-                for (ITokenModifier modifier : modifiers) {\n-                    int bit = manager.getTokenModifiers().indexOf(modifier);\n-                    if (bit >= 0) {\n-                        encodedModifiers = encodedModifiers | (0b00000001 << bit);\n-                    }\n-                }\n-                data.add(deltaLine);\n-                data.add(deltaColumn);\n-                data.add(token.getLength());\n-                data.add(tokenTypeIndex);\n-                data.add(encodedModifiers);\n-            }\n-        }\n-        return data;\n-    }\n-\n-    private void addToken(ASTNode node, TokenType tokenType) {\n-        addToken(node, tokenType, NO_MODIFIERS);\n-    }\n-\n-    private void addToken(ASTNode node, TokenType tokenType, ITokenModifier[] modifiers) {\n-        int offset = node.getStartPosition();\n-        int length = node.getLength();\n-        SemanticToken token = new SemanticToken(offset, length, tokenType, modifiers);\n-        tokens.add(token);\n-    }\n-\n-    @Override\n-    public boolean visit(QualifiedName node) {\n-        IBinding binding = node.resolveBinding();\n-        if (binding != null && binding.getKind() == IBinding.PACKAGE) {\n-            addToken(node, TokenType.NAMESPACE, NO_MODIFIERS);\n-            return false;\n-        }\n-        return super.visit(node);\n-    }\n-\n-    @Override\n-    public boolean visit(SimpleName node) {\n-        ASTNode parent = node.getParent();\n-        if (parent instanceof Annotation) {\n-            addToken(node, TokenType.ANNOTATION);\n-            return false;\n-        }\n-\n-        IBinding binding = node.resolveBinding();\n-        if (binding == null) {\n-            return super.visit(node);\n-        }\n-\n-        TokenType tokenType = null;\n-        switch (binding.getKind()) {\n-            case IBinding.VARIABLE: {\n-                if (((IVariableBinding) binding).isField()) {\n-                    tokenType = TokenType.PROPERTY;\n-                } else {\n-                    tokenType = TokenType.VARIABLE;\n-                }\n-                break;\n-            }\n-            case IBinding.METHOD: {\n-                tokenType = TokenType.FUNCTION;\n-                break;\n-            }\n-            case IBinding.TYPE: {\n-                tokenType = TokenType.TYPE;\n-                break;\n-            }\n-            case IBinding.PACKAGE: {\n-                tokenType = TokenType.NAMESPACE;\n-                break;\n-            }\n-            default:\n-                break;\n-        }\n-\n-        if (tokenType == null) {\n-            return super.visit(node);\n-        }\n-\n-        switch (tokenType) {\n-            case FUNCTION:\n-            case VARIABLE:\n-            case PROPERTY:\n-            case MEMBER: {\n-                ITokenModifier[] modifiers = getModifiers(binding);\n-                addToken(node, tokenType, modifiers);\n-                break;\n-            }\n-            case TYPE:\n-            case NAMESPACE:\n-                addToken(node, tokenType, NO_MODIFIERS);\n-                break;\n-            default:\n-                break;\n-        }\n-\n-        return super.visit(node);\n-    }\n-\n-    @Override\n-    public boolean visit(MethodInvocation node) {\n-        return super.visit(node);\n-    }\n-\n-    private ITokenModifier[] getModifiers(IBinding binding) {\n-        return manager.getTokenModifiers().values().stream()\n-                      .filter(tm -> tm.applies(binding))\n-                      .toArray(size -> new ITokenModifier[size]);\n-    }\n-\n-    @Override\n-    public boolean visit(SimpleType node) {\n-        ASTNode parent = node.getParent();\n-        if (parent instanceof ClassInstanceCreation) { // For ClassInstanceCreation \"new E()\", \"E\" should be highlighted as 'function' instead of 'type'\n-            addToken(node, TokenType.FUNCTION, NO_MODIFIERS);\n-            return false;\n-        }\n-        return super.visit(node);\n-    }\n-\n+\tprivate IDocument document;\n+\tprivate SemanticTokenManager manager;\n+\tprivate List<SemanticToken> tokens;\n+\n+\tpublic SemanticTokensVisitor(IDocument document, SemanticTokenManager manager) {\n+\t\tthis.manager = manager;\n+\t\tthis.document = document;\n+\t\tthis.tokens = new ArrayList<>();\n+\t}\n+\n+\tprivate class SemanticToken {\n+\t\tprivate final TokenType tokenType;\n+\t\tprivate final TokenModifier[] tokenModifiers;\n+\t\tprivate final int offset;\n+\t\tprivate final int length;\n+\n+\t\tpublic SemanticToken(int offset, int length, TokenType tokenType, TokenModifier[] tokenModifiers) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.length = length;\n+\t\t\tthis.tokenType = tokenType;\n+\t\t\tthis.tokenModifiers = tokenModifiers;\n+\t\t}\n+\n+\t\tpublic TokenType getTokenType() {\n+\t\t\treturn tokenType;\n+\t\t}\n+\n+\t\tpublic TokenModifier[] getTokenModifiers() {\n+\t\t\treturn tokenModifiers;\n+\t\t}\n+\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\tpublic int getLength() {\n+\t\t\treturn length;\n+\t\t}\n+\t}\n+\n+\tpublic SemanticTokens getSemanticTokens() {\n+\t\tList<Integer> data = encodeTokens();\n+\t\treturn new SemanticTokens(data);\n+\t}\n+\n+\tprivate List<Integer> encodeTokens() {\n+\t\tList<Integer> data = new ArrayList<>();\n+\t\tint currentLine = 0;\n+\t\tint currentColumn = 0;\n+\t\tfor (SemanticToken token : this.tokens) {\n+\t\t\tint[] lineAndColumn = JsonRpcHelpers.toLine(this.document, token.getOffset());\n+\t\t\tint line = lineAndColumn[0];\n+\t\t\tint column = lineAndColumn[1];\n+\t\t\tint deltaLine = line - currentLine;\n+\t\t\tif (deltaLine != 0) {\n+\t\t\t\tcurrentLine = line;\n+\t\t\t\tcurrentColumn = 0;\n+\t\t\t}\n+\t\t\tint deltaColumn = column - currentColumn;\n+\t\t\tcurrentColumn = column;\n+\t\t\t// Disallow duplicate/conflict token (if exists)\n+\t\t\tif (deltaLine != 0 || deltaColumn != 0) {\n+\t\t\t\tint tokenTypeIndex = manager.getTokenTypes().indexOf(token.getTokenType());\n+\t\t\t\tTokenModifier[] modifiers = token.getTokenModifiers();\n+\t\t\t\tint encodedModifiers = 0;\n+\t\t\t\tfor (TokenModifier modifier : modifiers) {\n+\t\t\t\t\tint bit = manager.getTokenModifiers().indexOf(modifier);\n+\t\t\t\t\tencodedModifiers = encodedModifiers | (0b00000001 << bit);\n+\t\t\t\t}\n+\t\t\t\tdata.add(deltaLine);\n+\t\t\t\tdata.add(deltaColumn);\n+\t\t\t\tdata.add(token.getLength());\n+\t\t\t\tdata.add(tokenTypeIndex);\n+\t\t\t\tdata.add(encodedModifiers);\n+\t\t\t}\n+\t\t}\n+\t\treturn data;\n+\t}\n+\n+\t/**\n+\t* Adds a semantic token to the list of tokens being collected by this\n+\t* semantic token visitor.\n+\t*\n+\t* @param node The AST node representing the location of the semantic token.\n+\t* @param tokenType The type of the semantic token.\n+\t* @param modifiers The modifiers of the semantic token.\n+\t*\n+\t* @apiNote This method is order-dependent because of {@link #encodeTokens()}.\n+\t* If semantic tokens are not added in the order they appear in the document,\n+\t* the encoding algorithm might discard them.\n+\t*/\n+\tprivate void addToken(ASTNode node, TokenType tokenType, TokenModifier[] modifiers) {\n+\t\tint offset = node.getStartPosition();\n+\t\tint length = node.getLength();\n+\t\tSemanticToken token = new SemanticToken(offset, length, tokenType, modifiers);\n+\t\ttokens.add(token);\n+\t}\n+\n+\t@Override\n+\tpublic boolean visit(SimpleName node) {\n+\t\tTokenType tokenType = TokenType.getApplicableToken(node.resolveBinding());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8c033511caaeb3dc3346b795caa0533b00884e2"}, "originalPosition": 335}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5NDgzMTIw", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1501#pullrequestreview-449483120", "createdAt": "2020-07-16T03:31:31Z", "commit": {"oid": "7b53dcee3dd5e121f3d3b41a9779653e5cc81345"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwMzozMTozMVrOGyY0gw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwMzozMTozMVrOGyY0gw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ4ODY0Mw==", "bodyText": "Can add || node.resolveBinding() instanceof ITypeBinding to cover more cases. E.g.\nimport org.jcp.*;\nimport org.ietf.Eskibear;", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1501#discussion_r455488643", "createdAt": "2020-07-16T03:31:31Z", "author": {"login": "Eskibear"}, "path": "org.eclipse.jdt.ls.core/src/org/eclipse/jdt/ls/core/internal/semantictokens/SemanticTokensVisitor.java", "diffHunk": "@@ -127,6 +129,52 @@ private void addToken(ASTNode node, TokenType tokenType, TokenModifier[] modifie\n \t\ttokens.add(token);\n \t}\n \n+\t/**\n+\t* Adds a semantic token to the list of tokens being collected by this\n+\t* semantic token provider. Overload for {@link #addToken(ASTNode, TokenType, TokenModifier[])}\n+\t* that adds no modifiers to the semantic token.\n+\t*\n+\t* @param node The AST node representing the location of the semantic token.\n+\t* @param tokenType The type of the semantic token.\n+\t*\n+\t* @apiNote This method is order-dependent because of {@link #encodeTokens()}.\n+\t* If semantic tokens are not added in the order they appear in the document,\n+\t* the encoding algorithm might discard them.\n+\t*/\n+\tprivate void addToken(ASTNode node, TokenType tokenType) {\n+\t\taddToken(node, tokenType, new TokenModifier[0]);\n+\t}\n+\n+\t@Override\n+\tpublic boolean visit(QualifiedName node) {\n+\t\tif (node.resolveBinding() instanceof IPackageBinding) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b53dcee3dd5e121f3d3b41a9779653e5cc81345"}, "originalPosition": 31}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "483c0add625450a69c756e2d30dbd1fdb1309255", "author": {"user": {"login": "0dinD", "name": null}}, "url": "https://github.com/eclipse/eclipse.jdt.ls/commit/483c0add625450a69c756e2d30dbd1fdb1309255", "committedDate": "2020-07-20T19:45:16Z", "message": "Add new test cases"}, "afterCommit": {"oid": "97fe211b91a8a4acba34b7dec737bfa524fd309e", "author": {"user": {"login": "0dinD", "name": null}}, "url": "https://github.com/eclipse/eclipse.jdt.ls/commit/97fe211b91a8a4acba34b7dec737bfa524fd309e", "committedDate": "2020-07-20T20:38:51Z", "message": "Improve semantic highlighting\n\nSigned-off-by: 0dinD <zerodind@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUyMDI2MTE3", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1501#pullrequestreview-452026117", "createdAt": "2020-07-20T23:27:33Z", "commit": {"oid": "97fe211b91a8a4acba34b7dec737bfa524fd309e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQyMzoyNzozM1rOG0isjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQyMzoyNzozM1rOG0isjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc0NzU5Nw==", "bodyText": "encodedTokens", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1501#discussion_r457747597", "createdAt": "2020-07-20T23:27:33Z", "author": {"login": "fbricon"}, "path": "org.eclipse.jdt.ls.core/src/org/eclipse/jdt/ls/core/internal/semantictokens/SemanticTokensVisitor.java", "diffHunk": "@@ -9,213 +9,322 @@\n  *\n  * Contributors:\n  *     Microsoft Corporation - initial API and implementation\n+ *     0dinD - Semantic highlighting improvements - https://github.com/eclipse/eclipse.jdt.ls/pull/1501\n  *******************************************************************************/\n-\n package org.eclipse.jdt.ls.core.internal.semantictokens;\n \n import java.util.ArrayList;\n import java.util.List;\n \n import org.eclipse.jdt.core.dom.ASTNode;\n import org.eclipse.jdt.core.dom.ASTVisitor;\n-import org.eclipse.jdt.core.dom.Annotation;\n import org.eclipse.jdt.core.dom.ClassInstanceCreation;\n import org.eclipse.jdt.core.dom.IBinding;\n-import org.eclipse.jdt.core.dom.IVariableBinding;\n-import org.eclipse.jdt.core.dom.MethodInvocation;\n+import org.eclipse.jdt.core.dom.IPackageBinding;\n+import org.eclipse.jdt.core.dom.ITypeBinding;\n+import org.eclipse.jdt.core.dom.ImportDeclaration;\n+import org.eclipse.jdt.core.dom.Name;\n+import org.eclipse.jdt.core.dom.NameQualifiedType;\n+import org.eclipse.jdt.core.dom.ParameterizedType;\n import org.eclipse.jdt.core.dom.QualifiedName;\n+import org.eclipse.jdt.core.dom.QualifiedType;\n import org.eclipse.jdt.core.dom.SimpleName;\n import org.eclipse.jdt.core.dom.SimpleType;\n+import org.eclipse.jdt.core.dom.Type;\n import org.eclipse.jdt.ls.core.internal.handlers.JsonRpcHelpers;\n import org.eclipse.jface.text.IDocument;\n \n public class SemanticTokensVisitor extends ASTVisitor {\n-    private IDocument document;\n-    private SemanticTokenManager manager;\n-    private List<SemanticToken> tokens;\n-\n-    public final static ITokenModifier[] NO_MODIFIERS = {};\n-\n-    public SemanticTokensVisitor(IDocument document, SemanticTokenManager manager) {\n-        this.manager = manager;\n-        this.document = document;\n-        this.tokens = new ArrayList<>();\n-    }\n-\n-    private class SemanticToken {\n-        private final TokenType tokenType;\n-        private final ITokenModifier[] tokenModifiers;\n-        private final int offset;\n-        private final int length;\n-\n-        public SemanticToken(int offset, int length, TokenType tokenType, ITokenModifier[] tokenModifiers) {\n-            this.offset = offset;\n-            this.length = length;\n-            this.tokenType = tokenType;\n-            this.tokenModifiers = tokenModifiers;\n-        }\n-\n-        public TokenType getTokenType() {\n-            return tokenType;\n-        }\n-\n-        public ITokenModifier[] getTokenModifiers() {\n-            return tokenModifiers;\n-        }\n-\n-        public int getOffset() {\n-            return offset;\n-        }\n-\n-        public int getLength() {\n-            return length;\n-        }\n-    }\n-\n-    public SemanticTokens getSemanticTokens() {\n-        List<Integer> data = encoded();\n-        return new SemanticTokens(data);\n-    }\n-\n-    private List<Integer> encoded() {\n-        List<Integer> data = new ArrayList<>();\n-        int currentLine = 0;\n-        int currentColumn = 0;\n-        for (SemanticToken token : this.tokens) {\n-            int[] lineAndColumn = JsonRpcHelpers.toLine(this.document, token.getOffset());\n-            int line = lineAndColumn[0];\n-            int column = lineAndColumn[1];\n-            int deltaLine = line - currentLine;\n-            if (deltaLine != 0) {\n-                currentLine = line;\n-                currentColumn = 0;\n-            }\n-            int deltaColumn = column - currentColumn;\n-            currentColumn = column;\n-            // Disallow duplicate/conflict token (if exists)\n-            if (deltaLine != 0 || deltaColumn != 0) {\n-                int tokenTypeIndex = manager.getTokenTypes().indexOf(token.getTokenType());\n-                ITokenModifier[] modifiers = token.getTokenModifiers();\n-                int encodedModifiers = 0;\n-                for (ITokenModifier modifier : modifiers) {\n-                    int bit = manager.getTokenModifiers().indexOf(modifier);\n-                    if (bit >= 0) {\n-                        encodedModifiers = encodedModifiers | (0b00000001 << bit);\n-                    }\n-                }\n-                data.add(deltaLine);\n-                data.add(deltaColumn);\n-                data.add(token.getLength());\n-                data.add(tokenTypeIndex);\n-                data.add(encodedModifiers);\n-            }\n-        }\n-        return data;\n-    }\n-\n-    private void addToken(ASTNode node, TokenType tokenType) {\n-        addToken(node, tokenType, NO_MODIFIERS);\n-    }\n-\n-    private void addToken(ASTNode node, TokenType tokenType, ITokenModifier[] modifiers) {\n-        int offset = node.getStartPosition();\n-        int length = node.getLength();\n-        SemanticToken token = new SemanticToken(offset, length, tokenType, modifiers);\n-        tokens.add(token);\n-    }\n-\n-    @Override\n-    public boolean visit(QualifiedName node) {\n-        IBinding binding = node.resolveBinding();\n-        if (binding != null && binding.getKind() == IBinding.PACKAGE) {\n-            addToken(node, TokenType.NAMESPACE, NO_MODIFIERS);\n-            return false;\n-        }\n-        return super.visit(node);\n-    }\n-\n-    @Override\n-    public boolean visit(SimpleName node) {\n-        ASTNode parent = node.getParent();\n-        if (parent instanceof Annotation) {\n-            addToken(node, TokenType.ANNOTATION);\n-            return false;\n-        }\n-\n-        IBinding binding = node.resolveBinding();\n-        if (binding == null) {\n-            return super.visit(node);\n-        }\n-\n-        TokenType tokenType = null;\n-        switch (binding.getKind()) {\n-            case IBinding.VARIABLE: {\n-                if (((IVariableBinding) binding).isField()) {\n-                    tokenType = TokenType.PROPERTY;\n-                } else {\n-                    tokenType = TokenType.VARIABLE;\n-                }\n-                break;\n-            }\n-            case IBinding.METHOD: {\n-                tokenType = TokenType.FUNCTION;\n-                break;\n-            }\n-            case IBinding.TYPE: {\n-                tokenType = TokenType.TYPE;\n-                break;\n-            }\n-            case IBinding.PACKAGE: {\n-                tokenType = TokenType.NAMESPACE;\n-                break;\n-            }\n-            default:\n-                break;\n-        }\n-\n-        if (tokenType == null) {\n-            return super.visit(node);\n-        }\n-\n-        switch (tokenType) {\n-            case FUNCTION:\n-            case VARIABLE:\n-            case PROPERTY:\n-            case MEMBER: {\n-                ITokenModifier[] modifiers = getModifiers(binding);\n-                addToken(node, tokenType, modifiers);\n-                break;\n-            }\n-            case TYPE:\n-            case NAMESPACE:\n-                addToken(node, tokenType, NO_MODIFIERS);\n-                break;\n-            default:\n-                break;\n-        }\n-\n-        return super.visit(node);\n-    }\n-\n-    @Override\n-    public boolean visit(MethodInvocation node) {\n-        return super.visit(node);\n-    }\n-\n-    private ITokenModifier[] getModifiers(IBinding binding) {\n-        return manager.getTokenModifiers().values().stream()\n-                      .filter(tm -> tm.applies(binding))\n-                      .toArray(size -> new ITokenModifier[size]);\n-    }\n-\n-    @Override\n-    public boolean visit(SimpleType node) {\n-        ASTNode parent = node.getParent();\n-        if (parent instanceof ClassInstanceCreation) { // For ClassInstanceCreation \"new E()\", \"E\" should be highlighted as 'function' instead of 'type'\n-            addToken(node, TokenType.FUNCTION, NO_MODIFIERS);\n-            return false;\n-        }\n-        return super.visit(node);\n-    }\n+\tprivate IDocument document;\n+\tprivate SemanticTokenManager manager;\n+\tprivate List<SemanticToken> tokens;\n+\n+\tpublic SemanticTokensVisitor(IDocument document, SemanticTokenManager manager) {\n+\t\tthis.manager = manager;\n+\t\tthis.document = document;\n+\t\tthis.tokens = new ArrayList<>();\n+\t}\n+\n+\tprivate class SemanticToken {\n+\t\tprivate final TokenType tokenType;\n+\t\tprivate final TokenModifier[] tokenModifiers;\n+\t\tprivate final int offset;\n+\t\tprivate final int length;\n+\n+\t\tpublic SemanticToken(int offset, int length, TokenType tokenType, TokenModifier[] tokenModifiers) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.length = length;\n+\t\t\tthis.tokenType = tokenType;\n+\t\t\tthis.tokenModifiers = tokenModifiers;\n+\t\t}\n+\n+\t\tpublic TokenType getTokenType() {\n+\t\t\treturn tokenType;\n+\t\t}\n+\n+\t\tpublic TokenModifier[] getTokenModifiers() {\n+\t\t\treturn tokenModifiers;\n+\t\t}\n+\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\tpublic int getLength() {\n+\t\t\treturn length;\n+\t\t}\n+\t}\n+\n+\tpublic SemanticTokens getSemanticTokens() {\n+\t\tList<Integer> data = encodeTokens();\n+\t\treturn new SemanticTokens(data);\n+\t}\n+\n+\tprivate List<Integer> encodeTokens() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97fe211b91a8a4acba34b7dec737bfa524fd309e"}, "originalPosition": 266}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "785a6f175ea7823dee6f177517dda4160325bb67", "author": {"user": {"login": "0dinD", "name": null}}, "url": "https://github.com/eclipse/eclipse.jdt.ls/commit/785a6f175ea7823dee6f177517dda4160325bb67", "committedDate": "2020-07-21T08:08:14Z", "message": "Improve semantic highlighting\n\nSigned-off-by: 0dinD <zerodind@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "97fe211b91a8a4acba34b7dec737bfa524fd309e", "author": {"user": {"login": "0dinD", "name": null}}, "url": "https://github.com/eclipse/eclipse.jdt.ls/commit/97fe211b91a8a4acba34b7dec737bfa524fd309e", "committedDate": "2020-07-20T20:38:51Z", "message": "Improve semantic highlighting\n\nSigned-off-by: 0dinD <zerodind@gmail.com>"}, "afterCommit": {"oid": "785a6f175ea7823dee6f177517dda4160325bb67", "author": {"user": {"login": "0dinD", "name": null}}, "url": "https://github.com/eclipse/eclipse.jdt.ls/commit/785a6f175ea7823dee6f177517dda4160325bb67", "committedDate": "2020-07-21T08:08:14Z", "message": "Improve semantic highlighting\n\nSigned-off-by: 0dinD <zerodind@gmail.com>"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1166, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}