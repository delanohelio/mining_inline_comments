{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ2NDAxNTk5", "number": 1501, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwNDoyNjoxNFrOENIo_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQyMzoyNzozM1rOEQaB1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMjA4NTExOnYy", "diffSide": "RIGHT", "path": "org.eclipse.jdt.ls.core/src/org/eclipse/jdt/ls/core/internal/semantictokens/SemanticTokensVisitor.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwNDoyNjoxNFrOGvpcjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwNDoyNjoxNFrOGvpcjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYxNTMwOA==", "bodyText": "redhat-developer/vscode-java#1434 is introduced again. And by the way it's not only for java.", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1501#discussion_r452615308", "createdAt": "2020-07-10T04:26:14Z", "author": {"login": "Eskibear"}, "path": "org.eclipse.jdt.ls.core/src/org/eclipse/jdt/ls/core/internal/semantictokens/SemanticTokensVisitor.java", "diffHunk": "@@ -18,204 +18,212 @@\n \n import org.eclipse.jdt.core.dom.ASTNode;\n import org.eclipse.jdt.core.dom.ASTVisitor;\n-import org.eclipse.jdt.core.dom.Annotation;\n import org.eclipse.jdt.core.dom.ClassInstanceCreation;\n-import org.eclipse.jdt.core.dom.IBinding;\n-import org.eclipse.jdt.core.dom.IVariableBinding;\n-import org.eclipse.jdt.core.dom.MethodInvocation;\n+import org.eclipse.jdt.core.dom.NameQualifiedType;\n+import org.eclipse.jdt.core.dom.ParameterizedType;\n import org.eclipse.jdt.core.dom.QualifiedName;\n+import org.eclipse.jdt.core.dom.QualifiedType;\n import org.eclipse.jdt.core.dom.SimpleName;\n import org.eclipse.jdt.core.dom.SimpleType;\n+import org.eclipse.jdt.core.dom.Type;\n import org.eclipse.jdt.ls.core.internal.handlers.JsonRpcHelpers;\n import org.eclipse.jface.text.IDocument;\n \n public class SemanticTokensVisitor extends ASTVisitor {\n-    private IDocument document;\n-    private SemanticTokenManager manager;\n-    private List<SemanticToken> tokens;\n-\n-    public final static ITokenModifier[] NO_MODIFIERS = {};\n-\n-    public SemanticTokensVisitor(IDocument document, SemanticTokenManager manager) {\n-        this.manager = manager;\n-        this.document = document;\n-        this.tokens = new ArrayList<>();\n-    }\n-\n-    private class SemanticToken {\n-        private final TokenType tokenType;\n-        private final ITokenModifier[] tokenModifiers;\n-        private final int offset;\n-        private final int length;\n-\n-        public SemanticToken(int offset, int length, TokenType tokenType, ITokenModifier[] tokenModifiers) {\n-            this.offset = offset;\n-            this.length = length;\n-            this.tokenType = tokenType;\n-            this.tokenModifiers = tokenModifiers;\n-        }\n-\n-        public TokenType getTokenType() {\n-            return tokenType;\n-        }\n-\n-        public ITokenModifier[] getTokenModifiers() {\n-            return tokenModifiers;\n-        }\n-\n-        public int getOffset() {\n-            return offset;\n-        }\n-\n-        public int getLength() {\n-            return length;\n-        }\n-    }\n-\n-    public SemanticTokens getSemanticTokens() {\n-        List<Integer> data = encoded();\n-        return new SemanticTokens(data);\n-    }\n-\n-    private List<Integer> encoded() {\n-        List<Integer> data = new ArrayList<>();\n-        int currentLine = 0;\n-        int currentColumn = 0;\n-        for (SemanticToken token : this.tokens) {\n-            int[] lineAndColumn = JsonRpcHelpers.toLine(this.document, token.getOffset());\n-            int line = lineAndColumn[0];\n-            int column = lineAndColumn[1];\n-            int deltaLine = line - currentLine;\n-            if (deltaLine != 0) {\n-                currentLine = line;\n-                currentColumn = 0;\n-            }\n-            int deltaColumn = column - currentColumn;\n-            currentColumn = column;\n-            // Disallow duplicate/conflict token (if exists)\n-            if (deltaLine != 0 || deltaColumn != 0) {\n-                int tokenTypeIndex = manager.getTokenTypes().indexOf(token.getTokenType());\n-                ITokenModifier[] modifiers = token.getTokenModifiers();\n-                int encodedModifiers = 0;\n-                for (ITokenModifier modifier : modifiers) {\n-                    int bit = manager.getTokenModifiers().indexOf(modifier);\n-                    if (bit >= 0) {\n-                        encodedModifiers = encodedModifiers | (0b00000001 << bit);\n-                    }\n-                }\n-                data.add(deltaLine);\n-                data.add(deltaColumn);\n-                data.add(token.getLength());\n-                data.add(tokenTypeIndex);\n-                data.add(encodedModifiers);\n-            }\n-        }\n-        return data;\n-    }\n-\n-    private void addToken(ASTNode node, TokenType tokenType) {\n-        addToken(node, tokenType, NO_MODIFIERS);\n-    }\n-\n-    private void addToken(ASTNode node, TokenType tokenType, ITokenModifier[] modifiers) {\n-        int offset = node.getStartPosition();\n-        int length = node.getLength();\n-        SemanticToken token = new SemanticToken(offset, length, tokenType, modifiers);\n-        tokens.add(token);\n-    }\n-\n-    @Override\n-    public boolean visit(QualifiedName node) {\n-        IBinding binding = node.resolveBinding();\n-        if (binding != null && binding.getKind() == IBinding.PACKAGE) {\n-            addToken(node, TokenType.NAMESPACE, NO_MODIFIERS);\n-            return false;\n-        }\n-        return super.visit(node);\n-    }\n-\n-    @Override\n-    public boolean visit(SimpleName node) {\n-        ASTNode parent = node.getParent();\n-        if (parent instanceof Annotation) {\n-            addToken(node, TokenType.ANNOTATION);\n-            return false;\n-        }\n-\n-        IBinding binding = node.resolveBinding();\n-        if (binding == null) {\n-            return super.visit(node);\n-        }\n-\n-        TokenType tokenType = null;\n-        switch (binding.getKind()) {\n-            case IBinding.VARIABLE: {\n-                if (((IVariableBinding) binding).isField()) {\n-                    tokenType = TokenType.PROPERTY;\n-                } else {\n-                    tokenType = TokenType.VARIABLE;\n-                }\n-                break;\n-            }\n-            case IBinding.METHOD: {\n-                tokenType = TokenType.FUNCTION;\n-                break;\n-            }\n-            case IBinding.TYPE: {\n-                tokenType = TokenType.TYPE;\n-                break;\n-            }\n-            case IBinding.PACKAGE: {\n-                tokenType = TokenType.NAMESPACE;\n-                break;\n-            }\n-            default:\n-                break;\n-        }\n-\n-        if (tokenType == null) {\n-            return super.visit(node);\n-        }\n-\n-        switch (tokenType) {\n-            case FUNCTION:\n-            case VARIABLE:\n-            case PROPERTY:\n-            case MEMBER: {\n-                ITokenModifier[] modifiers = getModifiers(binding);\n-                addToken(node, tokenType, modifiers);\n-                break;\n-            }\n-            case TYPE:\n-            case NAMESPACE:\n-                addToken(node, tokenType, NO_MODIFIERS);\n-                break;\n-            default:\n-                break;\n-        }\n-\n-        return super.visit(node);\n-    }\n-\n-    @Override\n-    public boolean visit(MethodInvocation node) {\n-        return super.visit(node);\n-    }\n-\n-    private ITokenModifier[] getModifiers(IBinding binding) {\n-        return manager.getTokenModifiers().values().stream()\n-                      .filter(tm -> tm.applies(binding))\n-                      .toArray(size -> new ITokenModifier[size]);\n-    }\n-\n-    @Override\n-    public boolean visit(SimpleType node) {\n-        ASTNode parent = node.getParent();\n-        if (parent instanceof ClassInstanceCreation) { // For ClassInstanceCreation \"new E()\", \"E\" should be highlighted as 'function' instead of 'type'\n-            addToken(node, TokenType.FUNCTION, NO_MODIFIERS);\n-            return false;\n-        }\n-        return super.visit(node);\n-    }\n-\n+\tprivate IDocument document;\n+\tprivate SemanticTokenManager manager;\n+\tprivate List<SemanticToken> tokens;\n+\n+\tpublic SemanticTokensVisitor(IDocument document, SemanticTokenManager manager) {\n+\t\tthis.manager = manager;\n+\t\tthis.document = document;\n+\t\tthis.tokens = new ArrayList<>();\n+\t}\n+\n+\tprivate class SemanticToken {\n+\t\tprivate final TokenType tokenType;\n+\t\tprivate final TokenModifier[] tokenModifiers;\n+\t\tprivate final int offset;\n+\t\tprivate final int length;\n+\n+\t\tpublic SemanticToken(int offset, int length, TokenType tokenType, TokenModifier[] tokenModifiers) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.length = length;\n+\t\t\tthis.tokenType = tokenType;\n+\t\t\tthis.tokenModifiers = tokenModifiers;\n+\t\t}\n+\n+\t\tpublic TokenType getTokenType() {\n+\t\t\treturn tokenType;\n+\t\t}\n+\n+\t\tpublic TokenModifier[] getTokenModifiers() {\n+\t\t\treturn tokenModifiers;\n+\t\t}\n+\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\tpublic int getLength() {\n+\t\t\treturn length;\n+\t\t}\n+\t}\n+\n+\tpublic SemanticTokens getSemanticTokens() {\n+\t\tList<Integer> data = encodeTokens();\n+\t\treturn new SemanticTokens(data);\n+\t}\n+\n+\tprivate List<Integer> encodeTokens() {\n+\t\tList<Integer> data = new ArrayList<>();\n+\t\tint currentLine = 0;\n+\t\tint currentColumn = 0;\n+\t\tfor (SemanticToken token : this.tokens) {\n+\t\t\tint[] lineAndColumn = JsonRpcHelpers.toLine(this.document, token.getOffset());\n+\t\t\tint line = lineAndColumn[0];\n+\t\t\tint column = lineAndColumn[1];\n+\t\t\tint deltaLine = line - currentLine;\n+\t\t\tif (deltaLine != 0) {\n+\t\t\t\tcurrentLine = line;\n+\t\t\t\tcurrentColumn = 0;\n+\t\t\t}\n+\t\t\tint deltaColumn = column - currentColumn;\n+\t\t\tcurrentColumn = column;\n+\t\t\t// Disallow duplicate/conflict token (if exists)\n+\t\t\tif (deltaLine != 0 || deltaColumn != 0) {\n+\t\t\t\tint tokenTypeIndex = manager.getTokenTypes().indexOf(token.getTokenType());\n+\t\t\t\tTokenModifier[] modifiers = token.getTokenModifiers();\n+\t\t\t\tint encodedModifiers = 0;\n+\t\t\t\tfor (TokenModifier modifier : modifiers) {\n+\t\t\t\t\tint bit = manager.getTokenModifiers().indexOf(modifier);\n+\t\t\t\t\tencodedModifiers = encodedModifiers | (0b00000001 << bit);\n+\t\t\t\t}\n+\t\t\t\tdata.add(deltaLine);\n+\t\t\t\tdata.add(deltaColumn);\n+\t\t\t\tdata.add(token.getLength());\n+\t\t\t\tdata.add(tokenTypeIndex);\n+\t\t\t\tdata.add(encodedModifiers);\n+\t\t\t}\n+\t\t}\n+\t\treturn data;\n+\t}\n+\n+\t/**\n+\t* Adds a semantic token to the list of tokens being collected by this\n+\t* semantic token visitor.\n+\t*\n+\t* @param node The AST node representing the location of the semantic token.\n+\t* @param tokenType The type of the semantic token.\n+\t* @param modifiers The modifiers of the semantic token.\n+\t*\n+\t* @apiNote This method is order-dependent because of {@link #encodeTokens()}.\n+\t* If semantic tokens are not added in the order they appear in the document,\n+\t* the encoding algorithm might discard them.\n+\t*/\n+\tprivate void addToken(ASTNode node, TokenType tokenType, TokenModifier[] modifiers) {\n+\t\tint offset = node.getStartPosition();\n+\t\tint length = node.getLength();\n+\t\tSemanticToken token = new SemanticToken(offset, length, tokenType, modifiers);\n+\t\ttokens.add(token);\n+\t}\n+\n+\t@Override\n+\tpublic boolean visit(SimpleName node) {\n+\t\tTokenType tokenType = TokenType.getApplicableToken(node.resolveBinding());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8c033511caaeb3dc3346b795caa0533b00884e2"}, "originalPosition": 335}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MTEwNDE2OnYy", "diffSide": "RIGHT", "path": "org.eclipse.jdt.ls.core/src/org/eclipse/jdt/ls/core/internal/semantictokens/SemanticTokensVisitor.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwMzozMTozMVrOGyY0gw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwMzozMTozMVrOGyY0gw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ4ODY0Mw==", "bodyText": "Can add || node.resolveBinding() instanceof ITypeBinding to cover more cases. E.g.\nimport org.jcp.*;\nimport org.ietf.Eskibear;", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1501#discussion_r455488643", "createdAt": "2020-07-16T03:31:31Z", "author": {"login": "Eskibear"}, "path": "org.eclipse.jdt.ls.core/src/org/eclipse/jdt/ls/core/internal/semantictokens/SemanticTokensVisitor.java", "diffHunk": "@@ -127,6 +129,52 @@ private void addToken(ASTNode node, TokenType tokenType, TokenModifier[] modifie\n \t\ttokens.add(token);\n \t}\n \n+\t/**\n+\t* Adds a semantic token to the list of tokens being collected by this\n+\t* semantic token provider. Overload for {@link #addToken(ASTNode, TokenType, TokenModifier[])}\n+\t* that adds no modifiers to the semantic token.\n+\t*\n+\t* @param node The AST node representing the location of the semantic token.\n+\t* @param tokenType The type of the semantic token.\n+\t*\n+\t* @apiNote This method is order-dependent because of {@link #encodeTokens()}.\n+\t* If semantic tokens are not added in the order they appear in the document,\n+\t* the encoding algorithm might discard them.\n+\t*/\n+\tprivate void addToken(ASTNode node, TokenType tokenType) {\n+\t\taddToken(node, tokenType, new TokenModifier[0]);\n+\t}\n+\n+\t@Override\n+\tpublic boolean visit(QualifiedName node) {\n+\t\tif (node.resolveBinding() instanceof IPackageBinding) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b53dcee3dd5e121f3d3b41a9779653e5cc81345"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NjM5MTI2OnYy", "diffSide": "RIGHT", "path": "org.eclipse.jdt.ls.core/src/org/eclipse/jdt/ls/core/internal/semantictokens/SemanticTokensVisitor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQyMzoyNzozM1rOG0isjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwODoxMTo0NlrOG0s_wg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc0NzU5Nw==", "bodyText": "encodedTokens", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1501#discussion_r457747597", "createdAt": "2020-07-20T23:27:33Z", "author": {"login": "fbricon"}, "path": "org.eclipse.jdt.ls.core/src/org/eclipse/jdt/ls/core/internal/semantictokens/SemanticTokensVisitor.java", "diffHunk": "@@ -9,213 +9,322 @@\n  *\n  * Contributors:\n  *     Microsoft Corporation - initial API and implementation\n+ *     0dinD - Semantic highlighting improvements - https://github.com/eclipse/eclipse.jdt.ls/pull/1501\n  *******************************************************************************/\n-\n package org.eclipse.jdt.ls.core.internal.semantictokens;\n \n import java.util.ArrayList;\n import java.util.List;\n \n import org.eclipse.jdt.core.dom.ASTNode;\n import org.eclipse.jdt.core.dom.ASTVisitor;\n-import org.eclipse.jdt.core.dom.Annotation;\n import org.eclipse.jdt.core.dom.ClassInstanceCreation;\n import org.eclipse.jdt.core.dom.IBinding;\n-import org.eclipse.jdt.core.dom.IVariableBinding;\n-import org.eclipse.jdt.core.dom.MethodInvocation;\n+import org.eclipse.jdt.core.dom.IPackageBinding;\n+import org.eclipse.jdt.core.dom.ITypeBinding;\n+import org.eclipse.jdt.core.dom.ImportDeclaration;\n+import org.eclipse.jdt.core.dom.Name;\n+import org.eclipse.jdt.core.dom.NameQualifiedType;\n+import org.eclipse.jdt.core.dom.ParameterizedType;\n import org.eclipse.jdt.core.dom.QualifiedName;\n+import org.eclipse.jdt.core.dom.QualifiedType;\n import org.eclipse.jdt.core.dom.SimpleName;\n import org.eclipse.jdt.core.dom.SimpleType;\n+import org.eclipse.jdt.core.dom.Type;\n import org.eclipse.jdt.ls.core.internal.handlers.JsonRpcHelpers;\n import org.eclipse.jface.text.IDocument;\n \n public class SemanticTokensVisitor extends ASTVisitor {\n-    private IDocument document;\n-    private SemanticTokenManager manager;\n-    private List<SemanticToken> tokens;\n-\n-    public final static ITokenModifier[] NO_MODIFIERS = {};\n-\n-    public SemanticTokensVisitor(IDocument document, SemanticTokenManager manager) {\n-        this.manager = manager;\n-        this.document = document;\n-        this.tokens = new ArrayList<>();\n-    }\n-\n-    private class SemanticToken {\n-        private final TokenType tokenType;\n-        private final ITokenModifier[] tokenModifiers;\n-        private final int offset;\n-        private final int length;\n-\n-        public SemanticToken(int offset, int length, TokenType tokenType, ITokenModifier[] tokenModifiers) {\n-            this.offset = offset;\n-            this.length = length;\n-            this.tokenType = tokenType;\n-            this.tokenModifiers = tokenModifiers;\n-        }\n-\n-        public TokenType getTokenType() {\n-            return tokenType;\n-        }\n-\n-        public ITokenModifier[] getTokenModifiers() {\n-            return tokenModifiers;\n-        }\n-\n-        public int getOffset() {\n-            return offset;\n-        }\n-\n-        public int getLength() {\n-            return length;\n-        }\n-    }\n-\n-    public SemanticTokens getSemanticTokens() {\n-        List<Integer> data = encoded();\n-        return new SemanticTokens(data);\n-    }\n-\n-    private List<Integer> encoded() {\n-        List<Integer> data = new ArrayList<>();\n-        int currentLine = 0;\n-        int currentColumn = 0;\n-        for (SemanticToken token : this.tokens) {\n-            int[] lineAndColumn = JsonRpcHelpers.toLine(this.document, token.getOffset());\n-            int line = lineAndColumn[0];\n-            int column = lineAndColumn[1];\n-            int deltaLine = line - currentLine;\n-            if (deltaLine != 0) {\n-                currentLine = line;\n-                currentColumn = 0;\n-            }\n-            int deltaColumn = column - currentColumn;\n-            currentColumn = column;\n-            // Disallow duplicate/conflict token (if exists)\n-            if (deltaLine != 0 || deltaColumn != 0) {\n-                int tokenTypeIndex = manager.getTokenTypes().indexOf(token.getTokenType());\n-                ITokenModifier[] modifiers = token.getTokenModifiers();\n-                int encodedModifiers = 0;\n-                for (ITokenModifier modifier : modifiers) {\n-                    int bit = manager.getTokenModifiers().indexOf(modifier);\n-                    if (bit >= 0) {\n-                        encodedModifiers = encodedModifiers | (0b00000001 << bit);\n-                    }\n-                }\n-                data.add(deltaLine);\n-                data.add(deltaColumn);\n-                data.add(token.getLength());\n-                data.add(tokenTypeIndex);\n-                data.add(encodedModifiers);\n-            }\n-        }\n-        return data;\n-    }\n-\n-    private void addToken(ASTNode node, TokenType tokenType) {\n-        addToken(node, tokenType, NO_MODIFIERS);\n-    }\n-\n-    private void addToken(ASTNode node, TokenType tokenType, ITokenModifier[] modifiers) {\n-        int offset = node.getStartPosition();\n-        int length = node.getLength();\n-        SemanticToken token = new SemanticToken(offset, length, tokenType, modifiers);\n-        tokens.add(token);\n-    }\n-\n-    @Override\n-    public boolean visit(QualifiedName node) {\n-        IBinding binding = node.resolveBinding();\n-        if (binding != null && binding.getKind() == IBinding.PACKAGE) {\n-            addToken(node, TokenType.NAMESPACE, NO_MODIFIERS);\n-            return false;\n-        }\n-        return super.visit(node);\n-    }\n-\n-    @Override\n-    public boolean visit(SimpleName node) {\n-        ASTNode parent = node.getParent();\n-        if (parent instanceof Annotation) {\n-            addToken(node, TokenType.ANNOTATION);\n-            return false;\n-        }\n-\n-        IBinding binding = node.resolveBinding();\n-        if (binding == null) {\n-            return super.visit(node);\n-        }\n-\n-        TokenType tokenType = null;\n-        switch (binding.getKind()) {\n-            case IBinding.VARIABLE: {\n-                if (((IVariableBinding) binding).isField()) {\n-                    tokenType = TokenType.PROPERTY;\n-                } else {\n-                    tokenType = TokenType.VARIABLE;\n-                }\n-                break;\n-            }\n-            case IBinding.METHOD: {\n-                tokenType = TokenType.FUNCTION;\n-                break;\n-            }\n-            case IBinding.TYPE: {\n-                tokenType = TokenType.TYPE;\n-                break;\n-            }\n-            case IBinding.PACKAGE: {\n-                tokenType = TokenType.NAMESPACE;\n-                break;\n-            }\n-            default:\n-                break;\n-        }\n-\n-        if (tokenType == null) {\n-            return super.visit(node);\n-        }\n-\n-        switch (tokenType) {\n-            case FUNCTION:\n-            case VARIABLE:\n-            case PROPERTY:\n-            case MEMBER: {\n-                ITokenModifier[] modifiers = getModifiers(binding);\n-                addToken(node, tokenType, modifiers);\n-                break;\n-            }\n-            case TYPE:\n-            case NAMESPACE:\n-                addToken(node, tokenType, NO_MODIFIERS);\n-                break;\n-            default:\n-                break;\n-        }\n-\n-        return super.visit(node);\n-    }\n-\n-    @Override\n-    public boolean visit(MethodInvocation node) {\n-        return super.visit(node);\n-    }\n-\n-    private ITokenModifier[] getModifiers(IBinding binding) {\n-        return manager.getTokenModifiers().values().stream()\n-                      .filter(tm -> tm.applies(binding))\n-                      .toArray(size -> new ITokenModifier[size]);\n-    }\n-\n-    @Override\n-    public boolean visit(SimpleType node) {\n-        ASTNode parent = node.getParent();\n-        if (parent instanceof ClassInstanceCreation) { // For ClassInstanceCreation \"new E()\", \"E\" should be highlighted as 'function' instead of 'type'\n-            addToken(node, TokenType.FUNCTION, NO_MODIFIERS);\n-            return false;\n-        }\n-        return super.visit(node);\n-    }\n+\tprivate IDocument document;\n+\tprivate SemanticTokenManager manager;\n+\tprivate List<SemanticToken> tokens;\n+\n+\tpublic SemanticTokensVisitor(IDocument document, SemanticTokenManager manager) {\n+\t\tthis.manager = manager;\n+\t\tthis.document = document;\n+\t\tthis.tokens = new ArrayList<>();\n+\t}\n+\n+\tprivate class SemanticToken {\n+\t\tprivate final TokenType tokenType;\n+\t\tprivate final TokenModifier[] tokenModifiers;\n+\t\tprivate final int offset;\n+\t\tprivate final int length;\n+\n+\t\tpublic SemanticToken(int offset, int length, TokenType tokenType, TokenModifier[] tokenModifiers) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.length = length;\n+\t\t\tthis.tokenType = tokenType;\n+\t\t\tthis.tokenModifiers = tokenModifiers;\n+\t\t}\n+\n+\t\tpublic TokenType getTokenType() {\n+\t\t\treturn tokenType;\n+\t\t}\n+\n+\t\tpublic TokenModifier[] getTokenModifiers() {\n+\t\t\treturn tokenModifiers;\n+\t\t}\n+\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\tpublic int getLength() {\n+\t\t\treturn length;\n+\t\t}\n+\t}\n+\n+\tpublic SemanticTokens getSemanticTokens() {\n+\t\tList<Integer> data = encodeTokens();\n+\t\treturn new SemanticTokens(data);\n+\t}\n+\n+\tprivate List<Integer> encodeTokens() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97fe211b91a8a4acba34b7dec737bfa524fd309e"}, "originalPosition": 266}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzkxNjM1NA==", "bodyText": "Fixed and amended to previous commit", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1501#discussion_r457916354", "createdAt": "2020-07-21T08:11:46Z", "author": {"login": "0dinD"}, "path": "org.eclipse.jdt.ls.core/src/org/eclipse/jdt/ls/core/internal/semantictokens/SemanticTokensVisitor.java", "diffHunk": "@@ -9,213 +9,322 @@\n  *\n  * Contributors:\n  *     Microsoft Corporation - initial API and implementation\n+ *     0dinD - Semantic highlighting improvements - https://github.com/eclipse/eclipse.jdt.ls/pull/1501\n  *******************************************************************************/\n-\n package org.eclipse.jdt.ls.core.internal.semantictokens;\n \n import java.util.ArrayList;\n import java.util.List;\n \n import org.eclipse.jdt.core.dom.ASTNode;\n import org.eclipse.jdt.core.dom.ASTVisitor;\n-import org.eclipse.jdt.core.dom.Annotation;\n import org.eclipse.jdt.core.dom.ClassInstanceCreation;\n import org.eclipse.jdt.core.dom.IBinding;\n-import org.eclipse.jdt.core.dom.IVariableBinding;\n-import org.eclipse.jdt.core.dom.MethodInvocation;\n+import org.eclipse.jdt.core.dom.IPackageBinding;\n+import org.eclipse.jdt.core.dom.ITypeBinding;\n+import org.eclipse.jdt.core.dom.ImportDeclaration;\n+import org.eclipse.jdt.core.dom.Name;\n+import org.eclipse.jdt.core.dom.NameQualifiedType;\n+import org.eclipse.jdt.core.dom.ParameterizedType;\n import org.eclipse.jdt.core.dom.QualifiedName;\n+import org.eclipse.jdt.core.dom.QualifiedType;\n import org.eclipse.jdt.core.dom.SimpleName;\n import org.eclipse.jdt.core.dom.SimpleType;\n+import org.eclipse.jdt.core.dom.Type;\n import org.eclipse.jdt.ls.core.internal.handlers.JsonRpcHelpers;\n import org.eclipse.jface.text.IDocument;\n \n public class SemanticTokensVisitor extends ASTVisitor {\n-    private IDocument document;\n-    private SemanticTokenManager manager;\n-    private List<SemanticToken> tokens;\n-\n-    public final static ITokenModifier[] NO_MODIFIERS = {};\n-\n-    public SemanticTokensVisitor(IDocument document, SemanticTokenManager manager) {\n-        this.manager = manager;\n-        this.document = document;\n-        this.tokens = new ArrayList<>();\n-    }\n-\n-    private class SemanticToken {\n-        private final TokenType tokenType;\n-        private final ITokenModifier[] tokenModifiers;\n-        private final int offset;\n-        private final int length;\n-\n-        public SemanticToken(int offset, int length, TokenType tokenType, ITokenModifier[] tokenModifiers) {\n-            this.offset = offset;\n-            this.length = length;\n-            this.tokenType = tokenType;\n-            this.tokenModifiers = tokenModifiers;\n-        }\n-\n-        public TokenType getTokenType() {\n-            return tokenType;\n-        }\n-\n-        public ITokenModifier[] getTokenModifiers() {\n-            return tokenModifiers;\n-        }\n-\n-        public int getOffset() {\n-            return offset;\n-        }\n-\n-        public int getLength() {\n-            return length;\n-        }\n-    }\n-\n-    public SemanticTokens getSemanticTokens() {\n-        List<Integer> data = encoded();\n-        return new SemanticTokens(data);\n-    }\n-\n-    private List<Integer> encoded() {\n-        List<Integer> data = new ArrayList<>();\n-        int currentLine = 0;\n-        int currentColumn = 0;\n-        for (SemanticToken token : this.tokens) {\n-            int[] lineAndColumn = JsonRpcHelpers.toLine(this.document, token.getOffset());\n-            int line = lineAndColumn[0];\n-            int column = lineAndColumn[1];\n-            int deltaLine = line - currentLine;\n-            if (deltaLine != 0) {\n-                currentLine = line;\n-                currentColumn = 0;\n-            }\n-            int deltaColumn = column - currentColumn;\n-            currentColumn = column;\n-            // Disallow duplicate/conflict token (if exists)\n-            if (deltaLine != 0 || deltaColumn != 0) {\n-                int tokenTypeIndex = manager.getTokenTypes().indexOf(token.getTokenType());\n-                ITokenModifier[] modifiers = token.getTokenModifiers();\n-                int encodedModifiers = 0;\n-                for (ITokenModifier modifier : modifiers) {\n-                    int bit = manager.getTokenModifiers().indexOf(modifier);\n-                    if (bit >= 0) {\n-                        encodedModifiers = encodedModifiers | (0b00000001 << bit);\n-                    }\n-                }\n-                data.add(deltaLine);\n-                data.add(deltaColumn);\n-                data.add(token.getLength());\n-                data.add(tokenTypeIndex);\n-                data.add(encodedModifiers);\n-            }\n-        }\n-        return data;\n-    }\n-\n-    private void addToken(ASTNode node, TokenType tokenType) {\n-        addToken(node, tokenType, NO_MODIFIERS);\n-    }\n-\n-    private void addToken(ASTNode node, TokenType tokenType, ITokenModifier[] modifiers) {\n-        int offset = node.getStartPosition();\n-        int length = node.getLength();\n-        SemanticToken token = new SemanticToken(offset, length, tokenType, modifiers);\n-        tokens.add(token);\n-    }\n-\n-    @Override\n-    public boolean visit(QualifiedName node) {\n-        IBinding binding = node.resolveBinding();\n-        if (binding != null && binding.getKind() == IBinding.PACKAGE) {\n-            addToken(node, TokenType.NAMESPACE, NO_MODIFIERS);\n-            return false;\n-        }\n-        return super.visit(node);\n-    }\n-\n-    @Override\n-    public boolean visit(SimpleName node) {\n-        ASTNode parent = node.getParent();\n-        if (parent instanceof Annotation) {\n-            addToken(node, TokenType.ANNOTATION);\n-            return false;\n-        }\n-\n-        IBinding binding = node.resolveBinding();\n-        if (binding == null) {\n-            return super.visit(node);\n-        }\n-\n-        TokenType tokenType = null;\n-        switch (binding.getKind()) {\n-            case IBinding.VARIABLE: {\n-                if (((IVariableBinding) binding).isField()) {\n-                    tokenType = TokenType.PROPERTY;\n-                } else {\n-                    tokenType = TokenType.VARIABLE;\n-                }\n-                break;\n-            }\n-            case IBinding.METHOD: {\n-                tokenType = TokenType.FUNCTION;\n-                break;\n-            }\n-            case IBinding.TYPE: {\n-                tokenType = TokenType.TYPE;\n-                break;\n-            }\n-            case IBinding.PACKAGE: {\n-                tokenType = TokenType.NAMESPACE;\n-                break;\n-            }\n-            default:\n-                break;\n-        }\n-\n-        if (tokenType == null) {\n-            return super.visit(node);\n-        }\n-\n-        switch (tokenType) {\n-            case FUNCTION:\n-            case VARIABLE:\n-            case PROPERTY:\n-            case MEMBER: {\n-                ITokenModifier[] modifiers = getModifiers(binding);\n-                addToken(node, tokenType, modifiers);\n-                break;\n-            }\n-            case TYPE:\n-            case NAMESPACE:\n-                addToken(node, tokenType, NO_MODIFIERS);\n-                break;\n-            default:\n-                break;\n-        }\n-\n-        return super.visit(node);\n-    }\n-\n-    @Override\n-    public boolean visit(MethodInvocation node) {\n-        return super.visit(node);\n-    }\n-\n-    private ITokenModifier[] getModifiers(IBinding binding) {\n-        return manager.getTokenModifiers().values().stream()\n-                      .filter(tm -> tm.applies(binding))\n-                      .toArray(size -> new ITokenModifier[size]);\n-    }\n-\n-    @Override\n-    public boolean visit(SimpleType node) {\n-        ASTNode parent = node.getParent();\n-        if (parent instanceof ClassInstanceCreation) { // For ClassInstanceCreation \"new E()\", \"E\" should be highlighted as 'function' instead of 'type'\n-            addToken(node, TokenType.FUNCTION, NO_MODIFIERS);\n-            return false;\n-        }\n-        return super.visit(node);\n-    }\n+\tprivate IDocument document;\n+\tprivate SemanticTokenManager manager;\n+\tprivate List<SemanticToken> tokens;\n+\n+\tpublic SemanticTokensVisitor(IDocument document, SemanticTokenManager manager) {\n+\t\tthis.manager = manager;\n+\t\tthis.document = document;\n+\t\tthis.tokens = new ArrayList<>();\n+\t}\n+\n+\tprivate class SemanticToken {\n+\t\tprivate final TokenType tokenType;\n+\t\tprivate final TokenModifier[] tokenModifiers;\n+\t\tprivate final int offset;\n+\t\tprivate final int length;\n+\n+\t\tpublic SemanticToken(int offset, int length, TokenType tokenType, TokenModifier[] tokenModifiers) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.length = length;\n+\t\t\tthis.tokenType = tokenType;\n+\t\t\tthis.tokenModifiers = tokenModifiers;\n+\t\t}\n+\n+\t\tpublic TokenType getTokenType() {\n+\t\t\treturn tokenType;\n+\t\t}\n+\n+\t\tpublic TokenModifier[] getTokenModifiers() {\n+\t\t\treturn tokenModifiers;\n+\t\t}\n+\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\tpublic int getLength() {\n+\t\t\treturn length;\n+\t\t}\n+\t}\n+\n+\tpublic SemanticTokens getSemanticTokens() {\n+\t\tList<Integer> data = encodeTokens();\n+\t\treturn new SemanticTokens(data);\n+\t}\n+\n+\tprivate List<Integer> encodeTokens() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc0NzU5Nw=="}, "originalCommit": {"oid": "97fe211b91a8a4acba34b7dec737bfa524fd309e"}, "originalPosition": 266}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3598, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}