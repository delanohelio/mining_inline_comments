{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDgwNTA4MTc0", "number": 1539, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwMzozODoxNFrOEiXoNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwNDoyMjozMlrOEiYEig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NDc0MTY1OnYy", "diffSide": "RIGHT", "path": "org.eclipse.jdt.ls.core/src/org/eclipse/jdt/ls/core/internal/semantictokens/SemanticTokensLegend.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwMzozODoxNFrOHQNICQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxMzoyOTozM1rOHQe5DA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc1NDMxMw==", "bodyText": "I'm ok to simplify it by removing SemanticTokenManager. But here it's no longer lazy-loaded. Suggest to keep the original Initialization-on-demand_holder_idiom", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1539#discussion_r486754313", "createdAt": "2020-09-11T03:38:14Z", "author": {"login": "Eskibear"}, "path": "org.eclipse.jdt.ls.core/src/org/eclipse/jdt/ls/core/internal/semantictokens/SemanticTokensLegend.java", "diffHunk": "@@ -13,22 +13,28 @@\n  *******************************************************************************/\n package org.eclipse.jdt.ls.core.internal.semantictokens;\n \n-import java.util.List;\n+import java.util.Arrays;\n \n public class SemanticTokensLegend {\n-\tprivate final List<String> tokenTypes;\n-\tprivate final List<String> tokenModifiers;\n+\tpublic static final SemanticTokensLegend INSTANCE = new SemanticTokensLegend();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "964cba6e58027764cba709b1476e8998eadd28f2"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc5ODUxMg==", "bodyText": "Oh, I see the original purpose of SemanticTokenManager now. But I just thought it was a bit unnecessary after the changes I made, since it was only used to get the SemanticTokensLegend instance. I can re-implement the lazy-loading in SemanticTokensLegend instead.\nBut now that I think about it, is there any reason to keep the legend in-memory at all in Java-land? Couldn't we just create a new instance when requested by the client? Because the server never uses the legend, and the client only needs to request it once and then keep it in it's own memory. Does the server have any reason to keep holding a static instance of the legend then?", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1539#discussion_r486798512", "createdAt": "2020-09-11T06:21:38Z", "author": {"login": "0dinD"}, "path": "org.eclipse.jdt.ls.core/src/org/eclipse/jdt/ls/core/internal/semantictokens/SemanticTokensLegend.java", "diffHunk": "@@ -13,22 +13,28 @@\n  *******************************************************************************/\n package org.eclipse.jdt.ls.core.internal.semantictokens;\n \n-import java.util.List;\n+import java.util.Arrays;\n \n public class SemanticTokensLegend {\n-\tprivate final List<String> tokenTypes;\n-\tprivate final List<String> tokenModifiers;\n+\tpublic static final SemanticTokensLegend INSTANCE = new SemanticTokensLegend();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc1NDMxMw=="}, "originalCommit": {"oid": "964cba6e58027764cba709b1476e8998eadd28f2"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA0NTM4OA==", "bodyText": "is there any reason to keep the legend in-memory at all in Java-land?\n\nIt's a good finding. Indeed, we don't have to have the Legend, as it simply holds all possible values of TokenType and TokenModifier.\n\nDoes the server have any reason to keep holding a static instance of the legend then?\n\nWhen client talks to the server, Legend is their contract, and it was used to encode tokens. With consistency in mind, I just implemented in that way.", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1539#discussion_r487045388", "createdAt": "2020-09-11T13:29:33Z", "author": {"login": "Eskibear"}, "path": "org.eclipse.jdt.ls.core/src/org/eclipse/jdt/ls/core/internal/semantictokens/SemanticTokensLegend.java", "diffHunk": "@@ -13,22 +13,28 @@\n  *******************************************************************************/\n package org.eclipse.jdt.ls.core.internal.semantictokens;\n \n-import java.util.List;\n+import java.util.Arrays;\n \n public class SemanticTokensLegend {\n-\tprivate final List<String> tokenTypes;\n-\tprivate final List<String> tokenModifiers;\n+\tpublic static final SemanticTokensLegend INSTANCE = new SemanticTokensLegend();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc1NDMxMw=="}, "originalCommit": {"oid": "964cba6e58027764cba709b1476e8998eadd28f2"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NDgxNDE4OnYy", "diffSide": "RIGHT", "path": "org.eclipse.jdt.ls.core/src/org/eclipse/jdt/ls/core/internal/semantictokens/TokenModifier.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwNDoyMjozMlrOHQNxrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxOTo1ODowOFrOHRkd8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc2NDk3NQ==", "bodyText": "I'm wondering whether we have to add all \"standard Java modifiers\", because ultimately we'll align modifiers with LSP3.16 as much as possible, via LSP4J.\nAnd massive modifiers would be potentially anonying (we did receive such feedback). I'm thinking, do people actually want to know below information from highlighting?\ntransient, volatile, default, synchronized, native, strictfp\n\nMy suggestion is to only keep important modifiers you are actually consuming now, also to avoid future breaking changes (when aligning to LSP) as best as we can.", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1539#discussion_r486764975", "createdAt": "2020-09-11T04:22:32Z", "author": {"login": "Eskibear"}, "path": "org.eclipse.jdt.ls.core/src/org/eclipse/jdt/ls/core/internal/semantictokens/TokenModifier.java", "diffHunk": "@@ -31,54 +31,26 @@\n import org.eclipse.jdt.core.dom.VariableDeclarationFragment;\n \n public enum TokenModifier {\n-\tSTATIC(\"static\") {\n-\t\t@Override\n-\t\tprotected boolean applies(IBinding binding) {\n-\t\t\treturn Modifier.isStatic(binding.getModifiers());\n-\t\t}\n-\t},\n-\tFINAL(\"readonly\") {\n-\t\t@Override\n-\t\tprotected boolean applies(IBinding binding) {\n-\t\t\treturn Modifier.isFinal(binding.getModifiers());\n-\t\t}\n-\t},\n-\tDEPRECATED(\"deprecated\") {\n-\t\t@Override\n-\t\tprotected boolean applies(IBinding binding) {\n-\t\t\treturn binding.isDeprecated();\n-\t\t}\n-\t},\n-\tPUBLIC(\"public\") {\n-\t\t@Override\n-\t\tprotected boolean applies(IBinding binding) {\n-\t\t\treturn Modifier.isPublic(binding.getModifiers());\n-\t\t}\n-\t},\n-\tPRIVATE(\"private\") {\n-\t\t@Override\n-\t\tprotected boolean applies(IBinding binding) {\n-\t\t\treturn Modifier.isPrivate(binding.getModifiers());\n-\t\t}\n-\t},\n-\tPROTECTED(\"protected\") {\n-\t\t@Override\n-\t\tprotected boolean applies(IBinding binding) {\n-\t\t\treturn Modifier.isProtected(binding.getModifiers());\n-\t\t}\n-\t},\n-\tABSTRACT(\"abstract\") {\n-\t\t@Override\n-\t\tprotected boolean applies(IBinding binding) {\n-\t\t\treturn Modifier.isAbstract(binding.getModifiers());\n-\t\t}\n-\t},\n-\tDECLARATION(\"declaration\") {\n-\t\t@Override\n-\t\tprotected boolean applies(SimpleName simpleName) {\n-\t\t\treturn isDeclaration(simpleName);\n-\t\t}\n-\t};\n+\t// Standard Java modifiers\n+\tPUBLIC(\"public\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "964cba6e58027764cba709b1476e8998eadd28f2"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjgwNDA3MA==", "bodyText": "Well, I do see your point here. The main purpose of this PR was to add the generic, typeArgument and importDeclaration modifiers. But I realised that adding the rest of the standard Java modifiers was easy and computationally cheap, so I thought \"why not?\".\nI'm not sure I understand what you mean by \"align modifiers with LSP3.16\"? We still need to have some custom modifiers that are not part of LSP3.16, and I don't see why these would be any different. Regarding the \"massive modifiers\", I think it would be rare to actually see all of those modifiers used together in a token, since many of them are mutually exclusive, or at least rarely used together.\nTo be clear, I also think some of the standard Java modifiers are rarely going to be used, like strictfp for example. But I just didn't see any particular reason not to add the information, since it's trivial to check them in the same way as public, static, readonly etc. If you want me to remove the new \"standard Java modifiers\", I am also fine with that.", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1539#discussion_r486804070", "createdAt": "2020-09-11T06:36:50Z", "author": {"login": "0dinD"}, "path": "org.eclipse.jdt.ls.core/src/org/eclipse/jdt/ls/core/internal/semantictokens/TokenModifier.java", "diffHunk": "@@ -31,54 +31,26 @@\n import org.eclipse.jdt.core.dom.VariableDeclarationFragment;\n \n public enum TokenModifier {\n-\tSTATIC(\"static\") {\n-\t\t@Override\n-\t\tprotected boolean applies(IBinding binding) {\n-\t\t\treturn Modifier.isStatic(binding.getModifiers());\n-\t\t}\n-\t},\n-\tFINAL(\"readonly\") {\n-\t\t@Override\n-\t\tprotected boolean applies(IBinding binding) {\n-\t\t\treturn Modifier.isFinal(binding.getModifiers());\n-\t\t}\n-\t},\n-\tDEPRECATED(\"deprecated\") {\n-\t\t@Override\n-\t\tprotected boolean applies(IBinding binding) {\n-\t\t\treturn binding.isDeprecated();\n-\t\t}\n-\t},\n-\tPUBLIC(\"public\") {\n-\t\t@Override\n-\t\tprotected boolean applies(IBinding binding) {\n-\t\t\treturn Modifier.isPublic(binding.getModifiers());\n-\t\t}\n-\t},\n-\tPRIVATE(\"private\") {\n-\t\t@Override\n-\t\tprotected boolean applies(IBinding binding) {\n-\t\t\treturn Modifier.isPrivate(binding.getModifiers());\n-\t\t}\n-\t},\n-\tPROTECTED(\"protected\") {\n-\t\t@Override\n-\t\tprotected boolean applies(IBinding binding) {\n-\t\t\treturn Modifier.isProtected(binding.getModifiers());\n-\t\t}\n-\t},\n-\tABSTRACT(\"abstract\") {\n-\t\t@Override\n-\t\tprotected boolean applies(IBinding binding) {\n-\t\t\treturn Modifier.isAbstract(binding.getModifiers());\n-\t\t}\n-\t},\n-\tDECLARATION(\"declaration\") {\n-\t\t@Override\n-\t\tprotected boolean applies(SimpleName simpleName) {\n-\t\t\treturn isDeclaration(simpleName);\n-\t\t}\n-\t};\n+\t// Standard Java modifiers\n+\tPUBLIC(\"public\"),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc2NDk3NQ=="}, "originalCommit": {"oid": "964cba6e58027764cba709b1476e8998eadd28f2"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA1MTY1OQ==", "bodyText": "I'm not that strongly opposed to that (as you mentioned you don't see any slow-down), my point is just \"why to add them if they are rarely going to be used\". It's indeed trivial to check them, it may cost tiny but still some time to check...\nI still prefer not to add them here. One day if we do consume those modifiers, it's also trivial to add them back.", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1539#discussion_r487051659", "createdAt": "2020-09-11T13:40:09Z", "author": {"login": "Eskibear"}, "path": "org.eclipse.jdt.ls.core/src/org/eclipse/jdt/ls/core/internal/semantictokens/TokenModifier.java", "diffHunk": "@@ -31,54 +31,26 @@\n import org.eclipse.jdt.core.dom.VariableDeclarationFragment;\n \n public enum TokenModifier {\n-\tSTATIC(\"static\") {\n-\t\t@Override\n-\t\tprotected boolean applies(IBinding binding) {\n-\t\t\treturn Modifier.isStatic(binding.getModifiers());\n-\t\t}\n-\t},\n-\tFINAL(\"readonly\") {\n-\t\t@Override\n-\t\tprotected boolean applies(IBinding binding) {\n-\t\t\treturn Modifier.isFinal(binding.getModifiers());\n-\t\t}\n-\t},\n-\tDEPRECATED(\"deprecated\") {\n-\t\t@Override\n-\t\tprotected boolean applies(IBinding binding) {\n-\t\t\treturn binding.isDeprecated();\n-\t\t}\n-\t},\n-\tPUBLIC(\"public\") {\n-\t\t@Override\n-\t\tprotected boolean applies(IBinding binding) {\n-\t\t\treturn Modifier.isPublic(binding.getModifiers());\n-\t\t}\n-\t},\n-\tPRIVATE(\"private\") {\n-\t\t@Override\n-\t\tprotected boolean applies(IBinding binding) {\n-\t\t\treturn Modifier.isPrivate(binding.getModifiers());\n-\t\t}\n-\t},\n-\tPROTECTED(\"protected\") {\n-\t\t@Override\n-\t\tprotected boolean applies(IBinding binding) {\n-\t\t\treturn Modifier.isProtected(binding.getModifiers());\n-\t\t}\n-\t},\n-\tABSTRACT(\"abstract\") {\n-\t\t@Override\n-\t\tprotected boolean applies(IBinding binding) {\n-\t\t\treturn Modifier.isAbstract(binding.getModifiers());\n-\t\t}\n-\t},\n-\tDECLARATION(\"declaration\") {\n-\t\t@Override\n-\t\tprotected boolean applies(SimpleName simpleName) {\n-\t\t\treturn isDeclaration(simpleName);\n-\t\t}\n-\t};\n+\t// Standard Java modifiers\n+\tPUBLIC(\"public\"),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc2NDk3NQ=="}, "originalCommit": {"oid": "964cba6e58027764cba709b1476e8998eadd28f2"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE4NTMzMA==", "bodyText": "Yeah, I do see your point. I'll remove those modifiers from this PR in my next iteration, which I'll probably commit later this week. But can we keep the native modifier? I don't see much use for the other modifiers (transient, volatile, default, synchronized and strictfp), but native is something that I might actually use myself, as it's quite common to see when using native libraries.", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1539#discussion_r488185330", "createdAt": "2020-09-14T19:58:08Z", "author": {"login": "0dinD"}, "path": "org.eclipse.jdt.ls.core/src/org/eclipse/jdt/ls/core/internal/semantictokens/TokenModifier.java", "diffHunk": "@@ -31,54 +31,26 @@\n import org.eclipse.jdt.core.dom.VariableDeclarationFragment;\n \n public enum TokenModifier {\n-\tSTATIC(\"static\") {\n-\t\t@Override\n-\t\tprotected boolean applies(IBinding binding) {\n-\t\t\treturn Modifier.isStatic(binding.getModifiers());\n-\t\t}\n-\t},\n-\tFINAL(\"readonly\") {\n-\t\t@Override\n-\t\tprotected boolean applies(IBinding binding) {\n-\t\t\treturn Modifier.isFinal(binding.getModifiers());\n-\t\t}\n-\t},\n-\tDEPRECATED(\"deprecated\") {\n-\t\t@Override\n-\t\tprotected boolean applies(IBinding binding) {\n-\t\t\treturn binding.isDeprecated();\n-\t\t}\n-\t},\n-\tPUBLIC(\"public\") {\n-\t\t@Override\n-\t\tprotected boolean applies(IBinding binding) {\n-\t\t\treturn Modifier.isPublic(binding.getModifiers());\n-\t\t}\n-\t},\n-\tPRIVATE(\"private\") {\n-\t\t@Override\n-\t\tprotected boolean applies(IBinding binding) {\n-\t\t\treturn Modifier.isPrivate(binding.getModifiers());\n-\t\t}\n-\t},\n-\tPROTECTED(\"protected\") {\n-\t\t@Override\n-\t\tprotected boolean applies(IBinding binding) {\n-\t\t\treturn Modifier.isProtected(binding.getModifiers());\n-\t\t}\n-\t},\n-\tABSTRACT(\"abstract\") {\n-\t\t@Override\n-\t\tprotected boolean applies(IBinding binding) {\n-\t\t\treturn Modifier.isAbstract(binding.getModifiers());\n-\t\t}\n-\t},\n-\tDECLARATION(\"declaration\") {\n-\t\t@Override\n-\t\tprotected boolean applies(SimpleName simpleName) {\n-\t\t\treturn isDeclaration(simpleName);\n-\t\t}\n-\t};\n+\t// Standard Java modifiers\n+\tPUBLIC(\"public\"),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc2NDk3NQ=="}, "originalCommit": {"oid": "964cba6e58027764cba709b1476e8998eadd28f2"}, "originalPosition": 70}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3622, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}