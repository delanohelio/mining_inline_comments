{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI3MjM0Njgw", "number": 1823, "title": "AWS: Glue catalog lock interface", "bodyText": "Allow Glue catalog to use an external DynamoDB table to enforce serializable isolation during commit.", "createdAt": "2020-11-25T07:13:41Z", "url": "https://github.com/apache/iceberg/pull/1823", "merged": true, "mergeCommit": {"oid": "4eb2010b3d51f63a6bfdafa9173f00ca354e66aa"}, "closed": true, "closedAt": "2021-01-05T21:08:29Z", "author": {"login": "jackye1995"}, "timelineItems": {"totalCount": 88, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdgCC_GgFqTUzODcyOTgxMg==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdtRdd8AFqTU2MjEzMDg5NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM4NzI5ODEy", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-538729812", "createdAt": "2020-11-25T17:45:53Z", "commit": {"oid": "4afaa87d34fef77570de66c93844837fa8c74ee4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNzo0NTo1M1rOH5-IXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNzo0NTo1M1rOH5-IXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU0ODgyOA==", "bodyText": "I think this should default to true because it is needed for correct operations.", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r530548828", "createdAt": "2020-11-25T17:45:53Z", "author": {"login": "rdblue"}, "path": "aws/src/main/java/org/apache/iceberg/aws/AwsProperties.java", "diffHunk": "@@ -114,6 +115,33 @@\n    */\n   public static final String S3FILEIO_ACL = \"s3fileio.acl\";\n \n+  /**\n+   * If {@link org.apache.iceberg.aws.glue.GlueCatalog} should use external lock or not, default to false.\n+   * If set to true, it will use DynamoDB to enforce locking during commits.\n+   */\n+  public static final String GLUE_CATALOG_LOCK_ENABLED = \"gluecatalog.lock.enabled\";\n+  public static final boolean GLUE_CATALOG_LOCK_ENABLED_DEFAULT = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4afaa87d34fef77570de66c93844837fa8c74ee4"}, "originalPosition": 17}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM4NzMwNzE5", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-538730719", "createdAt": "2020-11-25T17:47:05Z", "commit": {"oid": "4afaa87d34fef77570de66c93844837fa8c74ee4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNzo0NzowNlrOH5-K_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNzo0NzowNlrOH5-K_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU0OTUwMQ==", "bodyText": "Can we base this on a prefix + catalog name instead of a constant? That way we don't do something unsafe by default.", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r530549501", "createdAt": "2020-11-25T17:47:06Z", "author": {"login": "rdblue"}, "path": "aws/src/main/java/org/apache/iceberg/aws/AwsProperties.java", "diffHunk": "@@ -114,6 +115,33 @@\n    */\n   public static final String S3FILEIO_ACL = \"s3fileio.acl\";\n \n+  /**\n+   * If {@link org.apache.iceberg.aws.glue.GlueCatalog} should use external lock or not, default to false.\n+   * If set to true, it will use DynamoDB to enforce locking during commits.\n+   */\n+  public static final String GLUE_CATALOG_LOCK_ENABLED = \"gluecatalog.lock.enabled\";\n+  public static final boolean GLUE_CATALOG_LOCK_ENABLED_DEFAULT = false;\n+\n+  /**\n+   * The DynamoDB table used for locking.\n+   * One lock table is designed to be used for only one catalog.\n+   * It is recommended to use a different table name for each Glue catalog.\n+   * If the table does not exist, it will be created at runtime.\n+   */\n+  public static final String GLUE_CATALOG_LOCK_TABLE = \"gluecatalog.lock.table\";\n+  public static final String GLUE_CATALOG_LOCK_TABLE_DEFAULT = \"IcebergGlueCatalogLockTable\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4afaa87d34fef77570de66c93844837fa8c74ee4"}, "originalPosition": 26}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM4NzMxMTg5", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-538731189", "createdAt": "2020-11-25T17:47:47Z", "commit": {"oid": "4afaa87d34fef77570de66c93844837fa8c74ee4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNzo0Nzo0N1rOH5-MYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNzo0Nzo0N1rOH5-MYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU0OTg1Ng==", "bodyText": "Commits can take longer than this. What about using the max retry time for commits?", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r530549856", "createdAt": "2020-11-25T17:47:47Z", "author": {"login": "rdblue"}, "path": "aws/src/main/java/org/apache/iceberg/aws/AwsProperties.java", "diffHunk": "@@ -114,6 +115,33 @@\n    */\n   public static final String S3FILEIO_ACL = \"s3fileio.acl\";\n \n+  /**\n+   * If {@link org.apache.iceberg.aws.glue.GlueCatalog} should use external lock or not, default to false.\n+   * If set to true, it will use DynamoDB to enforce locking during commits.\n+   */\n+  public static final String GLUE_CATALOG_LOCK_ENABLED = \"gluecatalog.lock.enabled\";\n+  public static final boolean GLUE_CATALOG_LOCK_ENABLED_DEFAULT = false;\n+\n+  /**\n+   * The DynamoDB table used for locking.\n+   * One lock table is designed to be used for only one catalog.\n+   * It is recommended to use a different table name for each Glue catalog.\n+   * If the table does not exist, it will be created at runtime.\n+   */\n+  public static final String GLUE_CATALOG_LOCK_TABLE = \"gluecatalog.lock.table\";\n+  public static final String GLUE_CATALOG_LOCK_TABLE_DEFAULT = \"IcebergGlueCatalogLockTable\";\n+\n+  /**\n+   * After the given time in milliseconds, the process will give up the attempt to acquire a lock.\n+   */\n+  public static final String GLUE_CATALOG_LOCK_WAIT = \"gluecatalog.lock.wait\";\n+  public static final long GLUE_CATALOG_LOCK_WAIT_DEFAULT = TimeUnit.MINUTES.toMillis(3);\n+\n+  /**\n+   * After the given time in milliseconds, the lock is automatically expired.\n+   */\n+  public static final String GLUE_CATALOG_LOCK_EXPIRE = \"gluecatalog.lock.expire\";\n+  public static final long GLUE_CATALOG_LOCK_EXPIRE_DEFAULT = TimeUnit.MINUTES.toMillis(2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4afaa87d34fef77570de66c93844837fa8c74ee4"}, "originalPosition": 38}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM4NzMxOTU0", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-538731954", "createdAt": "2020-11-25T17:48:59Z", "commit": {"oid": "4afaa87d34fef77570de66c93844837fa8c74ee4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNzo0ODo1OVrOH5-Osw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNzo0ODo1OVrOH5-Osw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU1MDQ1MQ==", "bodyText": "Typo: try -> trying. The current message makes it sound like its telling the reader to try to create the table.", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r530550451", "createdAt": "2020-11-25T17:48:59Z", "author": {"login": "rdblue"}, "path": "aws/src/main/java/org/apache/iceberg/aws/glue/DynamoLockManager.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.aws.AwsClientUtil;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeDefinition;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.BillingMode;\n+import software.amazon.awssdk.services.dynamodb.model.CreateTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableResponse;\n+import software.amazon.awssdk.services.dynamodb.model.KeySchemaElement;\n+import software.amazon.awssdk.services.dynamodb.model.KeyType;\n+import software.amazon.awssdk.services.dynamodb.model.PutItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+import software.amazon.awssdk.services.dynamodb.model.ScalarAttributeType;\n+import software.amazon.awssdk.services.dynamodb.model.TableStatus;\n+\n+class DynamoLockManager implements LockManager {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManager.class);\n+\n+  private static final String LOCK_TABLE_COL_TABLE_ID = \"tableId\";\n+  private static final String LOCK_TABLE_COL_EXPIRE_TS_MILLIS = \"expireTimestampMillis\";\n+\n+  private static final List<KeySchemaElement> LOCK_TABLE_SCHEMA = Lists.newArrayList(\n+      KeySchemaElement.builder()\n+          .attributeName(LOCK_TABLE_COL_TABLE_ID)\n+          .keyType(KeyType.HASH)\n+          .build()\n+  );\n+\n+  private static final List<AttributeDefinition> LOCK_TABLE_COL_DEFINITIONS = Lists.newArrayList(\n+      AttributeDefinition.builder()\n+          .attributeName(LOCK_TABLE_COL_TABLE_ID)\n+          .attributeType(ScalarAttributeType.S)\n+          .build()\n+  );\n+\n+  private final DynamoDbClient dynamo;\n+  private final AwsProperties awsProperties;\n+\n+  DynamoLockManager(AwsProperties awsProperties) {\n+    this(AwsClientUtil.defaultDynamoClient(), awsProperties);\n+  }\n+\n+  DynamoLockManager(DynamoDbClient dynamo, AwsProperties awsProperties) {\n+    this.dynamo = dynamo;\n+    this.awsProperties = awsProperties;\n+    ensureLockTableExists();\n+  }\n+\n+  private void ensureLockTableExists() {\n+    ensureTableExists(awsProperties.glueCatalogLockTable(), LOCK_TABLE_SCHEMA, LOCK_TABLE_COL_DEFINITIONS);\n+  }\n+\n+  private void ensureTableExists(String tableName, List<KeySchemaElement> schema,\n+                                 List<AttributeDefinition> definitions) {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(tableName)\n+          .build());\n+    } catch (ResourceNotFoundException e) {\n+      LOG.info(\"Glue lock DynamoDB table <{}> not found, try to create\", tableName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4afaa87d34fef77570de66c93844837fa8c74ee4"}, "originalPosition": 90}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM4Nzg4MDA5", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-538788009", "createdAt": "2020-11-25T19:19:28Z", "commit": {"oid": "8cb01808eff4d3fe8dee19467f3cd69aa85e165a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxOToxOToyOVrOH6A81w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxOToxOToyOVrOH6A81w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU5NTAzMQ==", "bodyText": "Can the lock have a configurable type? eg DYNAMODB by default? We were hoping to leverage the work here to make nessie an option for the 'locking' mechanism here and bring nessie support to Glue. I hope to have a patch up soon to follow on from this.", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r530595031", "createdAt": "2020-11-25T19:19:29Z", "author": {"login": "rymurr"}, "path": "aws/src/main/java/org/apache/iceberg/aws/AwsProperties.java", "diffHunk": "@@ -114,6 +115,33 @@\n    */\n   public static final String S3FILEIO_ACL = \"s3fileio.acl\";\n \n+  /**\n+   * If {@link org.apache.iceberg.aws.glue.GlueCatalog} should use external lock or not, default to false.\n+   * If set to true, it will use DynamoDB to enforce locking during commits.\n+   */\n+  public static final String GLUE_CATALOG_LOCK_ENABLED = \"gluecatalog.lock.enabled\";\n+  public static final boolean GLUE_CATALOG_LOCK_ENABLED_DEFAULT = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8cb01808eff4d3fe8dee19467f3cd69aa85e165a"}, "originalPosition": 17}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM4NzkwMDIw", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-538790020", "createdAt": "2020-11-25T19:23:01Z", "commit": {"oid": "8cb01808eff4d3fe8dee19467f3cd69aa85e165a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxOToyMzowMVrOH6BDYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxOToyMzowMVrOH6BDYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU5NjcwNQ==", "bodyText": "Can we extend this interface a little bit? Again to help us w/ Nessie. Being able to pass at the very least the new metadata location would broaden the types of actions the implementer of this class can do.\nSimilar: Could we call this ConcurrencyManager or something similar? To hihglight that this is helping negotiate commit-ability rather than a pure lock mechanism?", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r530596705", "createdAt": "2020-11-25T19:23:01Z", "author": {"login": "rymurr"}, "path": "aws/src/main/java/org/apache/iceberg/aws/glue/LockManager.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+interface LockManager {\n+\n+  /**\n+   * Try to lock a table once\n+   * @param database Glue database name\n+   * @param table Glue table name\n+   * @param expireMillis max duration to hold the lock in milliseconds\n+   * @return if lock acquisition succeeded or not\n+   */\n+  boolean tryLock(String database, String table, long expireMillis);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8cb01808eff4d3fe8dee19467f3cd69aa85e165a"}, "originalPosition": 31}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM4Nzk4MzI4", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-538798328", "createdAt": "2020-11-25T19:37:10Z", "commit": {"oid": "8cb01808eff4d3fe8dee19467f3cd69aa85e165a"}, "state": "COMMENTED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxOTozNzoxMFrOH6Bdhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQyMDowMjozMVrOH6CLww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYwMzM5OA==", "bodyText": "This code only locks at the table level. I think in future we can add additional methods here, e.g. based on the implementation we can have lock at the row level, folder level, etc.", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r530603398", "createdAt": "2020-11-25T19:37:10Z", "author": {"login": "giovannifumarola"}, "path": "aws/src/main/java/org/apache/iceberg/aws/glue/LockManager.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+interface LockManager {\n+\n+  /**\n+   * Try to lock a table once\n+   * @param database Glue database name\n+   * @param table Glue table name\n+   * @param expireMillis max duration to hold the lock in milliseconds\n+   * @return if lock acquisition succeeded or not\n+   */\n+  boolean tryLock(String database, String table, long expireMillis);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU5NjcwNQ=="}, "originalCommit": {"oid": "8cb01808eff4d3fe8dee19467f3cd69aa85e165a"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYwNTgxNA==", "bodyText": "NIT:\nthis should be\npublic static final String AWS_GLUE_CATALOG_LOCK_ENABLED = AWS_GLUE_CATALOG + \"lock.enabled\";\npublic static final String AWS_GLUE_CATALOG = \"aws.gluecatalog.\";\nYou can reuse AWS_GLUE_CATALOG for the other properties.\nI would also add aws for readability.", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r530605814", "createdAt": "2020-11-25T19:42:30Z", "author": {"login": "giovannifumarola"}, "path": "aws/src/main/java/org/apache/iceberg/aws/AwsProperties.java", "diffHunk": "@@ -114,6 +115,33 @@\n    */\n   public static final String S3FILEIO_ACL = \"s3fileio.acl\";\n \n+  /**\n+   * If {@link org.apache.iceberg.aws.glue.GlueCatalog} should use external lock or not, default to false.\n+   * If set to true, it will use DynamoDB to enforce locking during commits.\n+   */\n+  public static final String GLUE_CATALOG_LOCK_ENABLED = \"gluecatalog.lock.enabled\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4afaa87d34fef77570de66c93844837fa8c74ee4"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYwNzMyOQ==", "bodyText": "This is not clear. We are using a single table for a single customer?", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r530607329", "createdAt": "2020-11-25T19:45:42Z", "author": {"login": "giovannifumarola"}, "path": "aws/src/main/java/org/apache/iceberg/aws/AwsProperties.java", "diffHunk": "@@ -114,6 +115,33 @@\n    */\n   public static final String S3FILEIO_ACL = \"s3fileio.acl\";\n \n+  /**\n+   * If {@link org.apache.iceberg.aws.glue.GlueCatalog} should use external lock or not, default to false.\n+   * If set to true, it will use DynamoDB to enforce locking during commits.\n+   */\n+  public static final String GLUE_CATALOG_LOCK_ENABLED = \"gluecatalog.lock.enabled\";\n+  public static final boolean GLUE_CATALOG_LOCK_ENABLED_DEFAULT = false;\n+\n+  /**\n+   * The DynamoDB table used for locking.\n+   * One lock table is designed to be used for only one catalog.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4afaa87d34fef77570de66c93844837fa8c74ee4"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYwNzcyNA==", "bodyText": "NIT: Timeout", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r530607724", "createdAt": "2020-11-25T19:46:32Z", "author": {"login": "giovannifumarola"}, "path": "aws/src/main/java/org/apache/iceberg/aws/AwsProperties.java", "diffHunk": "@@ -114,6 +115,33 @@\n    */\n   public static final String S3FILEIO_ACL = \"s3fileio.acl\";\n \n+  /**\n+   * If {@link org.apache.iceberg.aws.glue.GlueCatalog} should use external lock or not, default to false.\n+   * If set to true, it will use DynamoDB to enforce locking during commits.\n+   */\n+  public static final String GLUE_CATALOG_LOCK_ENABLED = \"gluecatalog.lock.enabled\";\n+  public static final boolean GLUE_CATALOG_LOCK_ENABLED_DEFAULT = false;\n+\n+  /**\n+   * The DynamoDB table used for locking.\n+   * One lock table is designed to be used for only one catalog.\n+   * It is recommended to use a different table name for each Glue catalog.\n+   * If the table does not exist, it will be created at runtime.\n+   */\n+  public static final String GLUE_CATALOG_LOCK_TABLE = \"gluecatalog.lock.table\";\n+  public static final String GLUE_CATALOG_LOCK_TABLE_DEFAULT = \"IcebergGlueCatalogLockTable\";\n+\n+  /**\n+   * After the given time in milliseconds, the process will give up the attempt to acquire a lock.\n+   */\n+  public static final String GLUE_CATALOG_LOCK_WAIT = \"gluecatalog.lock.wait\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4afaa87d34fef77570de66c93844837fa8c74ee4"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYwODMyOA==", "bodyText": "NIT: You can use PropertyUtil.propertyAs", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r530608328", "createdAt": "2020-11-25T19:47:49Z", "author": {"login": "giovannifumarola"}, "path": "aws/src/main/java/org/apache/iceberg/aws/AwsProperties.java", "diffHunk": "@@ -182,6 +218,14 @@ public AwsProperties(Map<String, String> properties) {\n     this.s3FileIoAcl = ObjectCannedACL.fromValue(aclType);\n     Preconditions.checkArgument(s3FileIoAcl == null || !s3FileIoAcl.equals(ObjectCannedACL.UNKNOWN_TO_SDK_VERSION),\n         \"Cannot support S3 CannedACL \" + aclType);\n+\n+    this.glueCatalogLockEnabled = PropertyUtil.propertyAsBoolean(properties,\n+        GLUE_CATALOG_LOCK_ENABLED, GLUE_CATALOG_LOCK_ENABLED_DEFAULT);\n+    this.glueCatalogLockTable = properties.getOrDefault(GLUE_CATALOG_LOCK_TABLE, GLUE_CATALOG_LOCK_TABLE_DEFAULT);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4afaa87d34fef77570de66c93844837fa8c74ee4"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYwOTM3Mw==", "bodyText": "NIT: Javadoc.\ne.g.\n/** default implementation of lock manager... it returns always true etc.. mainly using for testing purposes or when no external locking systems are needed.\n*/", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r530609373", "createdAt": "2020-11-25T19:50:10Z", "author": {"login": "giovannifumarola"}, "path": "aws/src/main/java/org/apache/iceberg/aws/glue/DefaultLockManager.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+public class DefaultLockManager implements LockManager {\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4afaa87d34fef77570de66c93844837fa8c74ee4"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxMDY4NQ==", "bodyText": "NIT: Javadoc.", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r530610685", "createdAt": "2020-11-25T19:53:05Z", "author": {"login": "giovannifumarola"}, "path": "aws/src/main/java/org/apache/iceberg/aws/glue/DynamoLockManager.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.aws.AwsClientUtil;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeDefinition;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.BillingMode;\n+import software.amazon.awssdk.services.dynamodb.model.CreateTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableResponse;\n+import software.amazon.awssdk.services.dynamodb.model.KeySchemaElement;\n+import software.amazon.awssdk.services.dynamodb.model.KeyType;\n+import software.amazon.awssdk.services.dynamodb.model.PutItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+import software.amazon.awssdk.services.dynamodb.model.ScalarAttributeType;\n+import software.amazon.awssdk.services.dynamodb.model.TableStatus;\n+\n+class DynamoLockManager implements LockManager {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4afaa87d34fef77570de66c93844837fa8c74ee4"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxMTMyNw==", "bodyText": "NIT: dynamoDbClient", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r530611327", "createdAt": "2020-11-25T19:54:26Z", "author": {"login": "giovannifumarola"}, "path": "aws/src/main/java/org/apache/iceberg/aws/glue/DynamoLockManager.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.aws.AwsClientUtil;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeDefinition;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.BillingMode;\n+import software.amazon.awssdk.services.dynamodb.model.CreateTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableResponse;\n+import software.amazon.awssdk.services.dynamodb.model.KeySchemaElement;\n+import software.amazon.awssdk.services.dynamodb.model.KeyType;\n+import software.amazon.awssdk.services.dynamodb.model.PutItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+import software.amazon.awssdk.services.dynamodb.model.ScalarAttributeType;\n+import software.amazon.awssdk.services.dynamodb.model.TableStatus;\n+\n+class DynamoLockManager implements LockManager {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManager.class);\n+\n+  private static final String LOCK_TABLE_COL_TABLE_ID = \"tableId\";\n+  private static final String LOCK_TABLE_COL_EXPIRE_TS_MILLIS = \"expireTimestampMillis\";\n+\n+  private static final List<KeySchemaElement> LOCK_TABLE_SCHEMA = Lists.newArrayList(\n+      KeySchemaElement.builder()\n+          .attributeName(LOCK_TABLE_COL_TABLE_ID)\n+          .keyType(KeyType.HASH)\n+          .build()\n+  );\n+\n+  private static final List<AttributeDefinition> LOCK_TABLE_COL_DEFINITIONS = Lists.newArrayList(\n+      AttributeDefinition.builder()\n+          .attributeName(LOCK_TABLE_COL_TABLE_ID)\n+          .attributeType(ScalarAttributeType.S)\n+          .build()\n+  );\n+\n+  private final DynamoDbClient dynamo;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4afaa87d34fef77570de66c93844837fa8c74ee4"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxMjg1Mw==", "bodyText": "why pay per request instead of provisioned?", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r530612853", "createdAt": "2020-11-25T19:57:29Z", "author": {"login": "giovannifumarola"}, "path": "aws/src/main/java/org/apache/iceberg/aws/glue/DynamoLockManager.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.aws.AwsClientUtil;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeDefinition;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.BillingMode;\n+import software.amazon.awssdk.services.dynamodb.model.CreateTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableResponse;\n+import software.amazon.awssdk.services.dynamodb.model.KeySchemaElement;\n+import software.amazon.awssdk.services.dynamodb.model.KeyType;\n+import software.amazon.awssdk.services.dynamodb.model.PutItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+import software.amazon.awssdk.services.dynamodb.model.ScalarAttributeType;\n+import software.amazon.awssdk.services.dynamodb.model.TableStatus;\n+\n+class DynamoLockManager implements LockManager {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManager.class);\n+\n+  private static final String LOCK_TABLE_COL_TABLE_ID = \"tableId\";\n+  private static final String LOCK_TABLE_COL_EXPIRE_TS_MILLIS = \"expireTimestampMillis\";\n+\n+  private static final List<KeySchemaElement> LOCK_TABLE_SCHEMA = Lists.newArrayList(\n+      KeySchemaElement.builder()\n+          .attributeName(LOCK_TABLE_COL_TABLE_ID)\n+          .keyType(KeyType.HASH)\n+          .build()\n+  );\n+\n+  private static final List<AttributeDefinition> LOCK_TABLE_COL_DEFINITIONS = Lists.newArrayList(\n+      AttributeDefinition.builder()\n+          .attributeName(LOCK_TABLE_COL_TABLE_ID)\n+          .attributeType(ScalarAttributeType.S)\n+          .build()\n+  );\n+\n+  private final DynamoDbClient dynamo;\n+  private final AwsProperties awsProperties;\n+\n+  DynamoLockManager(AwsProperties awsProperties) {\n+    this(AwsClientUtil.defaultDynamoClient(), awsProperties);\n+  }\n+\n+  DynamoLockManager(DynamoDbClient dynamo, AwsProperties awsProperties) {\n+    this.dynamo = dynamo;\n+    this.awsProperties = awsProperties;\n+    ensureLockTableExists();\n+  }\n+\n+  private void ensureLockTableExists() {\n+    ensureTableExists(awsProperties.glueCatalogLockTable(), LOCK_TABLE_SCHEMA, LOCK_TABLE_COL_DEFINITIONS);\n+  }\n+\n+  private void ensureTableExists(String tableName, List<KeySchemaElement> schema,\n+                                 List<AttributeDefinition> definitions) {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(tableName)\n+          .build());\n+    } catch (ResourceNotFoundException e) {\n+      LOG.info(\"Glue lock DynamoDB table <{}> not found, try to create\", tableName);\n+      dynamo.createTable(CreateTableRequest.builder()\n+          .tableName(tableName)\n+          .keySchema(schema)\n+          .attributeDefinitions(definitions)\n+          .billingMode(BillingMode.PAY_PER_REQUEST)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4afaa87d34fef77570de66c93844837fa8c74ee4"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxMzE2Nw==", "bodyText": "add as config? or is it a standard aws timeout?", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r530613167", "createdAt": "2020-11-25T19:58:13Z", "author": {"login": "giovannifumarola"}, "path": "aws/src/main/java/org/apache/iceberg/aws/glue/DynamoLockManager.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.aws.AwsClientUtil;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeDefinition;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.BillingMode;\n+import software.amazon.awssdk.services.dynamodb.model.CreateTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableResponse;\n+import software.amazon.awssdk.services.dynamodb.model.KeySchemaElement;\n+import software.amazon.awssdk.services.dynamodb.model.KeyType;\n+import software.amazon.awssdk.services.dynamodb.model.PutItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+import software.amazon.awssdk.services.dynamodb.model.ScalarAttributeType;\n+import software.amazon.awssdk.services.dynamodb.model.TableStatus;\n+\n+class DynamoLockManager implements LockManager {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManager.class);\n+\n+  private static final String LOCK_TABLE_COL_TABLE_ID = \"tableId\";\n+  private static final String LOCK_TABLE_COL_EXPIRE_TS_MILLIS = \"expireTimestampMillis\";\n+\n+  private static final List<KeySchemaElement> LOCK_TABLE_SCHEMA = Lists.newArrayList(\n+      KeySchemaElement.builder()\n+          .attributeName(LOCK_TABLE_COL_TABLE_ID)\n+          .keyType(KeyType.HASH)\n+          .build()\n+  );\n+\n+  private static final List<AttributeDefinition> LOCK_TABLE_COL_DEFINITIONS = Lists.newArrayList(\n+      AttributeDefinition.builder()\n+          .attributeName(LOCK_TABLE_COL_TABLE_ID)\n+          .attributeType(ScalarAttributeType.S)\n+          .build()\n+  );\n+\n+  private final DynamoDbClient dynamo;\n+  private final AwsProperties awsProperties;\n+\n+  DynamoLockManager(AwsProperties awsProperties) {\n+    this(AwsClientUtil.defaultDynamoClient(), awsProperties);\n+  }\n+\n+  DynamoLockManager(DynamoDbClient dynamo, AwsProperties awsProperties) {\n+    this.dynamo = dynamo;\n+    this.awsProperties = awsProperties;\n+    ensureLockTableExists();\n+  }\n+\n+  private void ensureLockTableExists() {\n+    ensureTableExists(awsProperties.glueCatalogLockTable(), LOCK_TABLE_SCHEMA, LOCK_TABLE_COL_DEFINITIONS);\n+  }\n+\n+  private void ensureTableExists(String tableName, List<KeySchemaElement> schema,\n+                                 List<AttributeDefinition> definitions) {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(tableName)\n+          .build());\n+    } catch (ResourceNotFoundException e) {\n+      LOG.info(\"Glue lock DynamoDB table <{}> not found, try to create\", tableName);\n+      dynamo.createTable(CreateTableRequest.builder()\n+          .tableName(tableName)\n+          .keySchema(schema)\n+          .attributeDefinitions(definitions)\n+          .billingMode(BillingMode.PAY_PER_REQUEST)\n+          .build());\n+\n+      boolean isTableActive = false;\n+      while (!isTableActive) {\n+        LOG.info(\"waiting for DynamoDB table <{}> to be active\", tableName);\n+        try {\n+          Thread.sleep(5000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4afaa87d34fef77570de66c93844837fa8c74ee4"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxMzg3Nw==", "bodyText": "NIT: ensureTableExistsOrCreate\nbecause the function creates a table if does not exists.\n\"Ensure\" gives the impressions of a boolean check.", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r530613877", "createdAt": "2020-11-25T19:59:52Z", "author": {"login": "giovannifumarola"}, "path": "aws/src/main/java/org/apache/iceberg/aws/glue/DynamoLockManager.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.aws.AwsClientUtil;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeDefinition;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.BillingMode;\n+import software.amazon.awssdk.services.dynamodb.model.CreateTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableResponse;\n+import software.amazon.awssdk.services.dynamodb.model.KeySchemaElement;\n+import software.amazon.awssdk.services.dynamodb.model.KeyType;\n+import software.amazon.awssdk.services.dynamodb.model.PutItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+import software.amazon.awssdk.services.dynamodb.model.ScalarAttributeType;\n+import software.amazon.awssdk.services.dynamodb.model.TableStatus;\n+\n+class DynamoLockManager implements LockManager {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManager.class);\n+\n+  private static final String LOCK_TABLE_COL_TABLE_ID = \"tableId\";\n+  private static final String LOCK_TABLE_COL_EXPIRE_TS_MILLIS = \"expireTimestampMillis\";\n+\n+  private static final List<KeySchemaElement> LOCK_TABLE_SCHEMA = Lists.newArrayList(\n+      KeySchemaElement.builder()\n+          .attributeName(LOCK_TABLE_COL_TABLE_ID)\n+          .keyType(KeyType.HASH)\n+          .build()\n+  );\n+\n+  private static final List<AttributeDefinition> LOCK_TABLE_COL_DEFINITIONS = Lists.newArrayList(\n+      AttributeDefinition.builder()\n+          .attributeName(LOCK_TABLE_COL_TABLE_ID)\n+          .attributeType(ScalarAttributeType.S)\n+          .build()\n+  );\n+\n+  private final DynamoDbClient dynamo;\n+  private final AwsProperties awsProperties;\n+\n+  DynamoLockManager(AwsProperties awsProperties) {\n+    this(AwsClientUtil.defaultDynamoClient(), awsProperties);\n+  }\n+\n+  DynamoLockManager(DynamoDbClient dynamo, AwsProperties awsProperties) {\n+    this.dynamo = dynamo;\n+    this.awsProperties = awsProperties;\n+    ensureLockTableExists();\n+  }\n+\n+  private void ensureLockTableExists() {\n+    ensureTableExists(awsProperties.glueCatalogLockTable(), LOCK_TABLE_SCHEMA, LOCK_TABLE_COL_DEFINITIONS);\n+  }\n+\n+  private void ensureTableExists(String tableName, List<KeySchemaElement> schema,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4afaa87d34fef77570de66c93844837fa8c74ee4"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxNDkwNQ==", "bodyText": "add log line.\nWe should inform if the item does not exist in the table.", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r530614905", "createdAt": "2020-11-25T20:01:47Z", "author": {"login": "giovannifumarola"}, "path": "aws/src/main/java/org/apache/iceberg/aws/glue/DynamoLockManager.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.aws.AwsClientUtil;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeDefinition;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.BillingMode;\n+import software.amazon.awssdk.services.dynamodb.model.CreateTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableResponse;\n+import software.amazon.awssdk.services.dynamodb.model.KeySchemaElement;\n+import software.amazon.awssdk.services.dynamodb.model.KeyType;\n+import software.amazon.awssdk.services.dynamodb.model.PutItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+import software.amazon.awssdk.services.dynamodb.model.ScalarAttributeType;\n+import software.amazon.awssdk.services.dynamodb.model.TableStatus;\n+\n+class DynamoLockManager implements LockManager {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManager.class);\n+\n+  private static final String LOCK_TABLE_COL_TABLE_ID = \"tableId\";\n+  private static final String LOCK_TABLE_COL_EXPIRE_TS_MILLIS = \"expireTimestampMillis\";\n+\n+  private static final List<KeySchemaElement> LOCK_TABLE_SCHEMA = Lists.newArrayList(\n+      KeySchemaElement.builder()\n+          .attributeName(LOCK_TABLE_COL_TABLE_ID)\n+          .keyType(KeyType.HASH)\n+          .build()\n+  );\n+\n+  private static final List<AttributeDefinition> LOCK_TABLE_COL_DEFINITIONS = Lists.newArrayList(\n+      AttributeDefinition.builder()\n+          .attributeName(LOCK_TABLE_COL_TABLE_ID)\n+          .attributeType(ScalarAttributeType.S)\n+          .build()\n+  );\n+\n+  private final DynamoDbClient dynamo;\n+  private final AwsProperties awsProperties;\n+\n+  DynamoLockManager(AwsProperties awsProperties) {\n+    this(AwsClientUtil.defaultDynamoClient(), awsProperties);\n+  }\n+\n+  DynamoLockManager(DynamoDbClient dynamo, AwsProperties awsProperties) {\n+    this.dynamo = dynamo;\n+    this.awsProperties = awsProperties;\n+    ensureLockTableExists();\n+  }\n+\n+  private void ensureLockTableExists() {\n+    ensureTableExists(awsProperties.glueCatalogLockTable(), LOCK_TABLE_SCHEMA, LOCK_TABLE_COL_DEFINITIONS);\n+  }\n+\n+  private void ensureTableExists(String tableName, List<KeySchemaElement> schema,\n+                                 List<AttributeDefinition> definitions) {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(tableName)\n+          .build());\n+    } catch (ResourceNotFoundException e) {\n+      LOG.info(\"Glue lock DynamoDB table <{}> not found, try to create\", tableName);\n+      dynamo.createTable(CreateTableRequest.builder()\n+          .tableName(tableName)\n+          .keySchema(schema)\n+          .attributeDefinitions(definitions)\n+          .billingMode(BillingMode.PAY_PER_REQUEST)\n+          .build());\n+\n+      boolean isTableActive = false;\n+      while (!isTableActive) {\n+        LOG.info(\"waiting for DynamoDB table <{}> to be active\", tableName);\n+        try {\n+          Thread.sleep(5000);\n+        } catch (InterruptedException ie) {\n+          LOG.warn(\"Glue lock DynamoDB table creation sleep interrupted\", e);\n+        }\n+        DescribeTableResponse describeTableResponse = dynamo.describeTable(DescribeTableRequest.builder()\n+            .tableName(tableName)\n+            .build());\n+        isTableActive = describeTableResponse.table().tableStatus().equals(TableStatus.ACTIVE);\n+      }\n+    }\n+  }\n+\n+\n+  @Override\n+  public boolean tryLock(String database, String table, long expireMillis) {\n+    String tableId = tableId(database, table);\n+\n+    Map<String, AttributeValue> key = Maps.newHashMap();\n+    key.put(LOCK_TABLE_COL_TABLE_ID, AttributeValue.builder().s(tableId).build());\n+    key.put(LOCK_TABLE_COL_EXPIRE_TS_MILLIS, AttributeValue.builder().n(\n+        Long.toString(System.currentTimeMillis() + expireMillis)\n+    ).build());\n+\n+    Map<String, AttributeValue> expressionValues = Maps.newHashMap();\n+    expressionValues.put(\":tid\", AttributeValue.builder().s(tableId).build());\n+    expressionValues.put(\":ts\", AttributeValue.builder().n(Long.toString(System.currentTimeMillis())).build());\n+\n+    try {\n+\n+      dynamo.putItem(PutItemRequest.builder()\n+          .tableName(awsProperties.glueCatalogLockTable())\n+          .item(key)\n+          // succeed only if there is no lock, or the lock is there but already expired\n+          .conditionExpression(\"attribute_not_exists(\" +\n+              LOCK_TABLE_COL_TABLE_ID + \") OR (\" +\n+              LOCK_TABLE_COL_TABLE_ID + \" = :tid AND \" +\n+              LOCK_TABLE_COL_EXPIRE_TS_MILLIS + \" < :ts)\")\n+          .expressionAttributeValues(expressionValues)\n+          .build());\n+      return true;\n+    } catch (Exception e) {\n+      // most likely it's ConditionalCheckFailedException, but we will catch any exception\n+      LOG.debug(\"Acquiring lock {}.{} failed\", database, table, e);\n+      return false;\n+    }\n+  }\n+\n+  @Override\n+  public void unlock(String database, String table) {\n+    String tableId = tableId(database, table);\n+    Map<String, AttributeValue> key = Maps.newHashMap();\n+    key.put(LOCK_TABLE_COL_TABLE_ID, AttributeValue.builder().s(tableId).build());\n+\n+    dynamo.deleteItem(DeleteItemRequest.builder()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4afaa87d34fef77570de66c93844837fa8c74ee4"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxNTIzNQ==", "bodyText": "this should be warn.", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r530615235", "createdAt": "2020-11-25T20:02:31Z", "author": {"login": "giovannifumarola"}, "path": "aws/src/main/java/org/apache/iceberg/aws/glue/DynamoLockManager.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.aws.AwsClientUtil;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeDefinition;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.BillingMode;\n+import software.amazon.awssdk.services.dynamodb.model.CreateTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableResponse;\n+import software.amazon.awssdk.services.dynamodb.model.KeySchemaElement;\n+import software.amazon.awssdk.services.dynamodb.model.KeyType;\n+import software.amazon.awssdk.services.dynamodb.model.PutItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+import software.amazon.awssdk.services.dynamodb.model.ScalarAttributeType;\n+import software.amazon.awssdk.services.dynamodb.model.TableStatus;\n+\n+class DynamoLockManager implements LockManager {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManager.class);\n+\n+  private static final String LOCK_TABLE_COL_TABLE_ID = \"tableId\";\n+  private static final String LOCK_TABLE_COL_EXPIRE_TS_MILLIS = \"expireTimestampMillis\";\n+\n+  private static final List<KeySchemaElement> LOCK_TABLE_SCHEMA = Lists.newArrayList(\n+      KeySchemaElement.builder()\n+          .attributeName(LOCK_TABLE_COL_TABLE_ID)\n+          .keyType(KeyType.HASH)\n+          .build()\n+  );\n+\n+  private static final List<AttributeDefinition> LOCK_TABLE_COL_DEFINITIONS = Lists.newArrayList(\n+      AttributeDefinition.builder()\n+          .attributeName(LOCK_TABLE_COL_TABLE_ID)\n+          .attributeType(ScalarAttributeType.S)\n+          .build()\n+  );\n+\n+  private final DynamoDbClient dynamo;\n+  private final AwsProperties awsProperties;\n+\n+  DynamoLockManager(AwsProperties awsProperties) {\n+    this(AwsClientUtil.defaultDynamoClient(), awsProperties);\n+  }\n+\n+  DynamoLockManager(DynamoDbClient dynamo, AwsProperties awsProperties) {\n+    this.dynamo = dynamo;\n+    this.awsProperties = awsProperties;\n+    ensureLockTableExists();\n+  }\n+\n+  private void ensureLockTableExists() {\n+    ensureTableExists(awsProperties.glueCatalogLockTable(), LOCK_TABLE_SCHEMA, LOCK_TABLE_COL_DEFINITIONS);\n+  }\n+\n+  private void ensureTableExists(String tableName, List<KeySchemaElement> schema,\n+                                 List<AttributeDefinition> definitions) {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(tableName)\n+          .build());\n+    } catch (ResourceNotFoundException e) {\n+      LOG.info(\"Glue lock DynamoDB table <{}> not found, try to create\", tableName);\n+      dynamo.createTable(CreateTableRequest.builder()\n+          .tableName(tableName)\n+          .keySchema(schema)\n+          .attributeDefinitions(definitions)\n+          .billingMode(BillingMode.PAY_PER_REQUEST)\n+          .build());\n+\n+      boolean isTableActive = false;\n+      while (!isTableActive) {\n+        LOG.info(\"waiting for DynamoDB table <{}> to be active\", tableName);\n+        try {\n+          Thread.sleep(5000);\n+        } catch (InterruptedException ie) {\n+          LOG.warn(\"Glue lock DynamoDB table creation sleep interrupted\", e);\n+        }\n+        DescribeTableResponse describeTableResponse = dynamo.describeTable(DescribeTableRequest.builder()\n+            .tableName(tableName)\n+            .build());\n+        isTableActive = describeTableResponse.table().tableStatus().equals(TableStatus.ACTIVE);\n+      }\n+    }\n+  }\n+\n+\n+  @Override\n+  public boolean tryLock(String database, String table, long expireMillis) {\n+    String tableId = tableId(database, table);\n+\n+    Map<String, AttributeValue> key = Maps.newHashMap();\n+    key.put(LOCK_TABLE_COL_TABLE_ID, AttributeValue.builder().s(tableId).build());\n+    key.put(LOCK_TABLE_COL_EXPIRE_TS_MILLIS, AttributeValue.builder().n(\n+        Long.toString(System.currentTimeMillis() + expireMillis)\n+    ).build());\n+\n+    Map<String, AttributeValue> expressionValues = Maps.newHashMap();\n+    expressionValues.put(\":tid\", AttributeValue.builder().s(tableId).build());\n+    expressionValues.put(\":ts\", AttributeValue.builder().n(Long.toString(System.currentTimeMillis())).build());\n+\n+    try {\n+\n+      dynamo.putItem(PutItemRequest.builder()\n+          .tableName(awsProperties.glueCatalogLockTable())\n+          .item(key)\n+          // succeed only if there is no lock, or the lock is there but already expired\n+          .conditionExpression(\"attribute_not_exists(\" +\n+              LOCK_TABLE_COL_TABLE_ID + \") OR (\" +\n+              LOCK_TABLE_COL_TABLE_ID + \" = :tid AND \" +\n+              LOCK_TABLE_COL_EXPIRE_TS_MILLIS + \" < :ts)\")\n+          .expressionAttributeValues(expressionValues)\n+          .build());\n+      return true;\n+    } catch (Exception e) {\n+      // most likely it's ConditionalCheckFailedException, but we will catch any exception\n+      LOG.debug(\"Acquiring lock {}.{} failed\", database, table, e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4afaa87d34fef77570de66c93844837fa8c74ee4"}, "originalPosition": 144}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM4ODk1MTM3", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-538895137", "createdAt": "2020-11-25T23:01:42Z", "commit": {"oid": "02b6ddababbedd4864acbd5d808b7d5950b2d8a4"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQyMzowMTo0M1rOH6GcHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQyMzoxOTozMVrOH6GvCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY4NDk1Ng==", "bodyText": "Is \"One lock table is designed to be used for only one catalog\" still accurate? It seems to me that we are able to have one lock table controlling multiple catalogs? And I think if we do want to recommend one table per catalog, we probably want to update the default to be prefix + catalog name to follow our own recommendation just as Ryan commented above. Although I'm not super clear on what exactly is the benefit of having one ddb table per catalog...", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r530684956", "createdAt": "2020-11-25T23:01:43Z", "author": {"login": "yyanyy"}, "path": "aws/src/main/java/org/apache/iceberg/aws/AwsProperties.java", "diffHunk": "@@ -114,6 +115,33 @@\n    */\n   public static final String S3FILEIO_ACL = \"s3fileio.acl\";\n \n+  /**\n+   * If {@link org.apache.iceberg.aws.glue.GlueCatalog} should use external lock or not, default to false.\n+   * If set to true, it will use DynamoDB to enforce locking during commits.\n+   */\n+  public static final String GLUE_CATALOG_LOCK_ENABLED = \"gluecatalog.lock.enabled\";\n+  public static final boolean GLUE_CATALOG_LOCK_ENABLED_DEFAULT = false;\n+\n+  /**\n+   * The DynamoDB table used for locking.\n+   * One lock table is designed to be used for only one catalog.\n+   * It is recommended to use a different table name for each Glue catalog.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02b6ddababbedd4864acbd5d808b7d5950b2d8a4"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY4NTU2NQ==", "bodyText": "I think System.currentTimeMillis may lead to clock skew problem. DDBLockClient's implementation to workaround this problem is interesting, probably worth borrowing: https://github.com/awslabs/amazon-dynamodb-lock-client#how-we-handle-clock-skew", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r530685565", "createdAt": "2020-11-25T23:04:05Z", "author": {"login": "yyanyy"}, "path": "aws/src/main/java/org/apache/iceberg/aws/glue/DynamoLockManager.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.aws.AwsClientUtil;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeDefinition;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.BillingMode;\n+import software.amazon.awssdk.services.dynamodb.model.CreateTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableResponse;\n+import software.amazon.awssdk.services.dynamodb.model.KeySchemaElement;\n+import software.amazon.awssdk.services.dynamodb.model.KeyType;\n+import software.amazon.awssdk.services.dynamodb.model.PutItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+import software.amazon.awssdk.services.dynamodb.model.ScalarAttributeType;\n+import software.amazon.awssdk.services.dynamodb.model.TableStatus;\n+\n+class DynamoLockManager implements LockManager {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManager.class);\n+\n+  private static final String LOCK_TABLE_COL_TABLE_ID = \"tableId\";\n+  private static final String LOCK_TABLE_COL_EXPIRE_TS_MILLIS = \"expireTimestampMillis\";\n+\n+  private static final List<KeySchemaElement> LOCK_TABLE_SCHEMA = Lists.newArrayList(\n+      KeySchemaElement.builder()\n+          .attributeName(LOCK_TABLE_COL_TABLE_ID)\n+          .keyType(KeyType.HASH)\n+          .build()\n+  );\n+\n+  private static final List<AttributeDefinition> LOCK_TABLE_COL_DEFINITIONS = Lists.newArrayList(\n+      AttributeDefinition.builder()\n+          .attributeName(LOCK_TABLE_COL_TABLE_ID)\n+          .attributeType(ScalarAttributeType.S)\n+          .build()\n+  );\n+\n+  private final DynamoDbClient dynamo;\n+  private final AwsProperties awsProperties;\n+\n+  DynamoLockManager(AwsProperties awsProperties) {\n+    this(AwsClientUtil.defaultDynamoClient(), awsProperties);\n+  }\n+\n+  DynamoLockManager(DynamoDbClient dynamo, AwsProperties awsProperties) {\n+    this.dynamo = dynamo;\n+    this.awsProperties = awsProperties;\n+    ensureLockTableExists();\n+  }\n+\n+  private void ensureLockTableExists() {\n+    ensureTableExists(awsProperties.glueCatalogLockTable(), LOCK_TABLE_SCHEMA, LOCK_TABLE_COL_DEFINITIONS);\n+  }\n+\n+  private void ensureTableExists(String tableName, List<KeySchemaElement> schema,\n+                                 List<AttributeDefinition> definitions) {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(tableName)\n+          .build());\n+    } catch (ResourceNotFoundException e) {\n+      LOG.info(\"Glue lock DynamoDB table <{}> not found, trying to create\", tableName);\n+      dynamo.createTable(CreateTableRequest.builder()\n+          .tableName(tableName)\n+          .keySchema(schema)\n+          .attributeDefinitions(definitions)\n+          .billingMode(BillingMode.PAY_PER_REQUEST)\n+          .build());\n+\n+      boolean isTableActive = false;\n+      while (!isTableActive) {\n+        LOG.info(\"waiting for DynamoDB table <{}> to be active\", tableName);\n+        try {\n+          Thread.sleep(5000);\n+        } catch (InterruptedException ie) {\n+          LOG.warn(\"Glue lock DynamoDB table creation sleep interrupted\", e);\n+        }\n+        DescribeTableResponse describeTableResponse = dynamo.describeTable(DescribeTableRequest.builder()\n+            .tableName(tableName)\n+            .build());\n+        isTableActive = describeTableResponse.table().tableStatus().equals(TableStatus.ACTIVE);\n+      }\n+    }\n+  }\n+\n+\n+  @Override\n+  public boolean tryLock(String database, String table, long expireMillis) {\n+    String tableId = tableId(database, table);\n+\n+    Map<String, AttributeValue> key = Maps.newHashMap();\n+    key.put(LOCK_TABLE_COL_TABLE_ID, AttributeValue.builder().s(tableId).build());\n+    key.put(LOCK_TABLE_COL_EXPIRE_TS_MILLIS, AttributeValue.builder().n(\n+        Long.toString(System.currentTimeMillis() + expireMillis)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02b6ddababbedd4864acbd5d808b7d5950b2d8a4"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY4NTgwNQ==", "bodyText": "I think we may still need to catch ResourceNotFoundException  here: https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_DescribeTable.html", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r530685805", "createdAt": "2020-11-25T23:05:03Z", "author": {"login": "yyanyy"}, "path": "aws/src/main/java/org/apache/iceberg/aws/glue/DynamoLockManager.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.aws.AwsClientUtil;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeDefinition;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.BillingMode;\n+import software.amazon.awssdk.services.dynamodb.model.CreateTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableResponse;\n+import software.amazon.awssdk.services.dynamodb.model.KeySchemaElement;\n+import software.amazon.awssdk.services.dynamodb.model.KeyType;\n+import software.amazon.awssdk.services.dynamodb.model.PutItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+import software.amazon.awssdk.services.dynamodb.model.ScalarAttributeType;\n+import software.amazon.awssdk.services.dynamodb.model.TableStatus;\n+\n+class DynamoLockManager implements LockManager {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManager.class);\n+\n+  private static final String LOCK_TABLE_COL_TABLE_ID = \"tableId\";\n+  private static final String LOCK_TABLE_COL_EXPIRE_TS_MILLIS = \"expireTimestampMillis\";\n+\n+  private static final List<KeySchemaElement> LOCK_TABLE_SCHEMA = Lists.newArrayList(\n+      KeySchemaElement.builder()\n+          .attributeName(LOCK_TABLE_COL_TABLE_ID)\n+          .keyType(KeyType.HASH)\n+          .build()\n+  );\n+\n+  private static final List<AttributeDefinition> LOCK_TABLE_COL_DEFINITIONS = Lists.newArrayList(\n+      AttributeDefinition.builder()\n+          .attributeName(LOCK_TABLE_COL_TABLE_ID)\n+          .attributeType(ScalarAttributeType.S)\n+          .build()\n+  );\n+\n+  private final DynamoDbClient dynamo;\n+  private final AwsProperties awsProperties;\n+\n+  DynamoLockManager(AwsProperties awsProperties) {\n+    this(AwsClientUtil.defaultDynamoClient(), awsProperties);\n+  }\n+\n+  DynamoLockManager(DynamoDbClient dynamo, AwsProperties awsProperties) {\n+    this.dynamo = dynamo;\n+    this.awsProperties = awsProperties;\n+    ensureLockTableExists();\n+  }\n+\n+  private void ensureLockTableExists() {\n+    ensureTableExists(awsProperties.glueCatalogLockTable(), LOCK_TABLE_SCHEMA, LOCK_TABLE_COL_DEFINITIONS);\n+  }\n+\n+  private void ensureTableExists(String tableName, List<KeySchemaElement> schema,\n+                                 List<AttributeDefinition> definitions) {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(tableName)\n+          .build());\n+    } catch (ResourceNotFoundException e) {\n+      LOG.info(\"Glue lock DynamoDB table <{}> not found, trying to create\", tableName);\n+      dynamo.createTable(CreateTableRequest.builder()\n+          .tableName(tableName)\n+          .keySchema(schema)\n+          .attributeDefinitions(definitions)\n+          .billingMode(BillingMode.PAY_PER_REQUEST)\n+          .build());\n+\n+      boolean isTableActive = false;\n+      while (!isTableActive) {\n+        LOG.info(\"waiting for DynamoDB table <{}> to be active\", tableName);\n+        try {\n+          Thread.sleep(5000);\n+        } catch (InterruptedException ie) {\n+          LOG.warn(\"Glue lock DynamoDB table creation sleep interrupted\", e);\n+        }\n+        DescribeTableResponse describeTableResponse = dynamo.describeTable(DescribeTableRequest.builder()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02b6ddababbedd4864acbd5d808b7d5950b2d8a4"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY4NjEyMQ==", "bodyText": "I think we might want some timeout (hard coded probably could be fine) to avoid staying in the loop forever", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r530686121", "createdAt": "2020-11-25T23:06:04Z", "author": {"login": "yyanyy"}, "path": "aws/src/main/java/org/apache/iceberg/aws/glue/DynamoLockManager.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.aws.AwsClientUtil;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeDefinition;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.BillingMode;\n+import software.amazon.awssdk.services.dynamodb.model.CreateTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableResponse;\n+import software.amazon.awssdk.services.dynamodb.model.KeySchemaElement;\n+import software.amazon.awssdk.services.dynamodb.model.KeyType;\n+import software.amazon.awssdk.services.dynamodb.model.PutItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+import software.amazon.awssdk.services.dynamodb.model.ScalarAttributeType;\n+import software.amazon.awssdk.services.dynamodb.model.TableStatus;\n+\n+class DynamoLockManager implements LockManager {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManager.class);\n+\n+  private static final String LOCK_TABLE_COL_TABLE_ID = \"tableId\";\n+  private static final String LOCK_TABLE_COL_EXPIRE_TS_MILLIS = \"expireTimestampMillis\";\n+\n+  private static final List<KeySchemaElement> LOCK_TABLE_SCHEMA = Lists.newArrayList(\n+      KeySchemaElement.builder()\n+          .attributeName(LOCK_TABLE_COL_TABLE_ID)\n+          .keyType(KeyType.HASH)\n+          .build()\n+  );\n+\n+  private static final List<AttributeDefinition> LOCK_TABLE_COL_DEFINITIONS = Lists.newArrayList(\n+      AttributeDefinition.builder()\n+          .attributeName(LOCK_TABLE_COL_TABLE_ID)\n+          .attributeType(ScalarAttributeType.S)\n+          .build()\n+  );\n+\n+  private final DynamoDbClient dynamo;\n+  private final AwsProperties awsProperties;\n+\n+  DynamoLockManager(AwsProperties awsProperties) {\n+    this(AwsClientUtil.defaultDynamoClient(), awsProperties);\n+  }\n+\n+  DynamoLockManager(DynamoDbClient dynamo, AwsProperties awsProperties) {\n+    this.dynamo = dynamo;\n+    this.awsProperties = awsProperties;\n+    ensureLockTableExists();\n+  }\n+\n+  private void ensureLockTableExists() {\n+    ensureTableExists(awsProperties.glueCatalogLockTable(), LOCK_TABLE_SCHEMA, LOCK_TABLE_COL_DEFINITIONS);\n+  }\n+\n+  private void ensureTableExists(String tableName, List<KeySchemaElement> schema,\n+                                 List<AttributeDefinition> definitions) {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(tableName)\n+          .build());\n+    } catch (ResourceNotFoundException e) {\n+      LOG.info(\"Glue lock DynamoDB table <{}> not found, trying to create\", tableName);\n+      dynamo.createTable(CreateTableRequest.builder()\n+          .tableName(tableName)\n+          .keySchema(schema)\n+          .attributeDefinitions(definitions)\n+          .billingMode(BillingMode.PAY_PER_REQUEST)\n+          .build());\n+\n+      boolean isTableActive = false;\n+      while (!isTableActive) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02b6ddababbedd4864acbd5d808b7d5950b2d8a4"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY4NzMxNA==", "bodyText": "Do we want Thread.currentThread().interrupt here?", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r530687314", "createdAt": "2020-11-25T23:10:24Z", "author": {"login": "yyanyy"}, "path": "aws/src/main/java/org/apache/iceberg/aws/glue/DynamoLockManager.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.aws.AwsClientUtil;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeDefinition;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.BillingMode;\n+import software.amazon.awssdk.services.dynamodb.model.CreateTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableResponse;\n+import software.amazon.awssdk.services.dynamodb.model.KeySchemaElement;\n+import software.amazon.awssdk.services.dynamodb.model.KeyType;\n+import software.amazon.awssdk.services.dynamodb.model.PutItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+import software.amazon.awssdk.services.dynamodb.model.ScalarAttributeType;\n+import software.amazon.awssdk.services.dynamodb.model.TableStatus;\n+\n+class DynamoLockManager implements LockManager {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManager.class);\n+\n+  private static final String LOCK_TABLE_COL_TABLE_ID = \"tableId\";\n+  private static final String LOCK_TABLE_COL_EXPIRE_TS_MILLIS = \"expireTimestampMillis\";\n+\n+  private static final List<KeySchemaElement> LOCK_TABLE_SCHEMA = Lists.newArrayList(\n+      KeySchemaElement.builder()\n+          .attributeName(LOCK_TABLE_COL_TABLE_ID)\n+          .keyType(KeyType.HASH)\n+          .build()\n+  );\n+\n+  private static final List<AttributeDefinition> LOCK_TABLE_COL_DEFINITIONS = Lists.newArrayList(\n+      AttributeDefinition.builder()\n+          .attributeName(LOCK_TABLE_COL_TABLE_ID)\n+          .attributeType(ScalarAttributeType.S)\n+          .build()\n+  );\n+\n+  private final DynamoDbClient dynamo;\n+  private final AwsProperties awsProperties;\n+\n+  DynamoLockManager(AwsProperties awsProperties) {\n+    this(AwsClientUtil.defaultDynamoClient(), awsProperties);\n+  }\n+\n+  DynamoLockManager(DynamoDbClient dynamo, AwsProperties awsProperties) {\n+    this.dynamo = dynamo;\n+    this.awsProperties = awsProperties;\n+    ensureLockTableExists();\n+  }\n+\n+  private void ensureLockTableExists() {\n+    ensureTableExists(awsProperties.glueCatalogLockTable(), LOCK_TABLE_SCHEMA, LOCK_TABLE_COL_DEFINITIONS);\n+  }\n+\n+  private void ensureTableExists(String tableName, List<KeySchemaElement> schema,\n+                                 List<AttributeDefinition> definitions) {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(tableName)\n+          .build());\n+    } catch (ResourceNotFoundException e) {\n+      LOG.info(\"Glue lock DynamoDB table <{}> not found, trying to create\", tableName);\n+      dynamo.createTable(CreateTableRequest.builder()\n+          .tableName(tableName)\n+          .keySchema(schema)\n+          .attributeDefinitions(definitions)\n+          .billingMode(BillingMode.PAY_PER_REQUEST)\n+          .build());\n+\n+      boolean isTableActive = false;\n+      while (!isTableActive) {\n+        LOG.info(\"waiting for DynamoDB table <{}> to be active\", tableName);\n+        try {\n+          Thread.sleep(5000);\n+        } catch (InterruptedException ie) {\n+          LOG.warn(\"Glue lock DynamoDB table creation sleep interrupted\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02b6ddababbedd4864acbd5d808b7d5950b2d8a4"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY4Nzc4Nw==", "bodyText": "+1, personally speaking non-ConditionalCheckFailedException may even worth a log.error", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r530687787", "createdAt": "2020-11-25T23:12:08Z", "author": {"login": "yyanyy"}, "path": "aws/src/main/java/org/apache/iceberg/aws/glue/DynamoLockManager.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.aws.AwsClientUtil;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeDefinition;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.BillingMode;\n+import software.amazon.awssdk.services.dynamodb.model.CreateTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableResponse;\n+import software.amazon.awssdk.services.dynamodb.model.KeySchemaElement;\n+import software.amazon.awssdk.services.dynamodb.model.KeyType;\n+import software.amazon.awssdk.services.dynamodb.model.PutItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+import software.amazon.awssdk.services.dynamodb.model.ScalarAttributeType;\n+import software.amazon.awssdk.services.dynamodb.model.TableStatus;\n+\n+class DynamoLockManager implements LockManager {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManager.class);\n+\n+  private static final String LOCK_TABLE_COL_TABLE_ID = \"tableId\";\n+  private static final String LOCK_TABLE_COL_EXPIRE_TS_MILLIS = \"expireTimestampMillis\";\n+\n+  private static final List<KeySchemaElement> LOCK_TABLE_SCHEMA = Lists.newArrayList(\n+      KeySchemaElement.builder()\n+          .attributeName(LOCK_TABLE_COL_TABLE_ID)\n+          .keyType(KeyType.HASH)\n+          .build()\n+  );\n+\n+  private static final List<AttributeDefinition> LOCK_TABLE_COL_DEFINITIONS = Lists.newArrayList(\n+      AttributeDefinition.builder()\n+          .attributeName(LOCK_TABLE_COL_TABLE_ID)\n+          .attributeType(ScalarAttributeType.S)\n+          .build()\n+  );\n+\n+  private final DynamoDbClient dynamo;\n+  private final AwsProperties awsProperties;\n+\n+  DynamoLockManager(AwsProperties awsProperties) {\n+    this(AwsClientUtil.defaultDynamoClient(), awsProperties);\n+  }\n+\n+  DynamoLockManager(DynamoDbClient dynamo, AwsProperties awsProperties) {\n+    this.dynamo = dynamo;\n+    this.awsProperties = awsProperties;\n+    ensureLockTableExists();\n+  }\n+\n+  private void ensureLockTableExists() {\n+    ensureTableExists(awsProperties.glueCatalogLockTable(), LOCK_TABLE_SCHEMA, LOCK_TABLE_COL_DEFINITIONS);\n+  }\n+\n+  private void ensureTableExists(String tableName, List<KeySchemaElement> schema,\n+                                 List<AttributeDefinition> definitions) {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(tableName)\n+          .build());\n+    } catch (ResourceNotFoundException e) {\n+      LOG.info(\"Glue lock DynamoDB table <{}> not found, try to create\", tableName);\n+      dynamo.createTable(CreateTableRequest.builder()\n+          .tableName(tableName)\n+          .keySchema(schema)\n+          .attributeDefinitions(definitions)\n+          .billingMode(BillingMode.PAY_PER_REQUEST)\n+          .build());\n+\n+      boolean isTableActive = false;\n+      while (!isTableActive) {\n+        LOG.info(\"waiting for DynamoDB table <{}> to be active\", tableName);\n+        try {\n+          Thread.sleep(5000);\n+        } catch (InterruptedException ie) {\n+          LOG.warn(\"Glue lock DynamoDB table creation sleep interrupted\", e);\n+        }\n+        DescribeTableResponse describeTableResponse = dynamo.describeTable(DescribeTableRequest.builder()\n+            .tableName(tableName)\n+            .build());\n+        isTableActive = describeTableResponse.table().tableStatus().equals(TableStatus.ACTIVE);\n+      }\n+    }\n+  }\n+\n+\n+  @Override\n+  public boolean tryLock(String database, String table, long expireMillis) {\n+    String tableId = tableId(database, table);\n+\n+    Map<String, AttributeValue> key = Maps.newHashMap();\n+    key.put(LOCK_TABLE_COL_TABLE_ID, AttributeValue.builder().s(tableId).build());\n+    key.put(LOCK_TABLE_COL_EXPIRE_TS_MILLIS, AttributeValue.builder().n(\n+        Long.toString(System.currentTimeMillis() + expireMillis)\n+    ).build());\n+\n+    Map<String, AttributeValue> expressionValues = Maps.newHashMap();\n+    expressionValues.put(\":tid\", AttributeValue.builder().s(tableId).build());\n+    expressionValues.put(\":ts\", AttributeValue.builder().n(Long.toString(System.currentTimeMillis())).build());\n+\n+    try {\n+\n+      dynamo.putItem(PutItemRequest.builder()\n+          .tableName(awsProperties.glueCatalogLockTable())\n+          .item(key)\n+          // succeed only if there is no lock, or the lock is there but already expired\n+          .conditionExpression(\"attribute_not_exists(\" +\n+              LOCK_TABLE_COL_TABLE_ID + \") OR (\" +\n+              LOCK_TABLE_COL_TABLE_ID + \" = :tid AND \" +\n+              LOCK_TABLE_COL_EXPIRE_TS_MILLIS + \" < :ts)\")\n+          .expressionAttributeValues(expressionValues)\n+          .build());\n+      return true;\n+    } catch (Exception e) {\n+      // most likely it's ConditionalCheckFailedException, but we will catch any exception\n+      LOG.debug(\"Acquiring lock {}.{} failed\", database, table, e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxNTIzNQ=="}, "originalCommit": {"oid": "4afaa87d34fef77570de66c93844837fa8c74ee4"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY4OTgwMw==", "bodyText": "+1, also I'm not an expert in AWS free tier but according to this it seems like low provisioned capacity counts towards free tier, so charging might not be a big problem in normal use cases. If this is the case, I guess this also applies to how table gets set up (billingMode).", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r530689803", "createdAt": "2020-11-25T23:19:31Z", "author": {"login": "yyanyy"}, "path": "aws/src/main/java/org/apache/iceberg/aws/AwsProperties.java", "diffHunk": "@@ -114,6 +115,33 @@\n    */\n   public static final String S3FILEIO_ACL = \"s3fileio.acl\";\n \n+  /**\n+   * If {@link org.apache.iceberg.aws.glue.GlueCatalog} should use external lock or not, default to false.\n+   * If set to true, it will use DynamoDB to enforce locking during commits.\n+   */\n+  public static final String GLUE_CATALOG_LOCK_ENABLED = \"gluecatalog.lock.enabled\";\n+  public static final boolean GLUE_CATALOG_LOCK_ENABLED_DEFAULT = false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU0ODgyOA=="}, "originalCommit": {"oid": "4afaa87d34fef77570de66c93844837fa8c74ee4"}, "originalPosition": 17}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "02b6ddababbedd4864acbd5d808b7d5950b2d8a4", "author": {"user": {"login": "jackye1995", "name": "Jack Ye"}}, "url": "https://github.com/apache/iceberg/commit/02b6ddababbedd4864acbd5d808b7d5950b2d8a4", "committedDate": "2020-11-25T20:37:25Z", "message": "temporarily put enabled to false for a discussion"}, "afterCommit": {"oid": "eedd4f17cb9bea8e555e2f974132730d96087386", "author": {"user": {"login": "jackye1995", "name": "Jack Ye"}}, "url": "https://github.com/apache/iceberg/commit/eedd4f17cb9bea8e555e2f974132730d96087386", "committedDate": "2020-12-02T04:23:57Z", "message": "AWS: Glue catalog locking through DynamoDB"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5eaf783766364a921f4c724180fa86a198a94a5b", "author": {"user": {"login": "jackye1995", "name": "Jack Ye"}}, "url": "https://github.com/apache/iceberg/commit/5eaf783766364a921f4c724180fa86a198a94a5b", "committedDate": "2020-12-08T21:43:46Z", "message": "fix initialize bug in glue"}, "afterCommit": {"oid": "af78fd4b37d2b8f8a174239f0bf9383a7615f630", "author": {"user": {"login": "jackye1995", "name": "Jack Ye"}}, "url": "https://github.com/apache/iceberg/commit/af78fd4b37d2b8f8a174239f0bf9383a7615f630", "committedDate": "2020-12-21T22:14:57Z", "message": "AWS: Glue catalog locking through DynamoDB"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2a82a1e3286ea9edf44e7be7242d0fd686abc5b2", "author": {"user": {"login": "jackye1995", "name": "Jack Ye"}}, "url": "https://github.com/apache/iceberg/commit/2a82a1e3286ea9edf44e7be7242d0fd686abc5b2", "committedDate": "2020-12-21T22:25:59Z", "message": "fix checkstyle"}, "afterCommit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee", "author": {"user": {"login": "jackye1995", "name": "Jack Ye"}}, "url": "https://github.com/apache/iceberg/commit/17874b628e12aedb347b1e9303b6a7928d4b9bee", "committedDate": "2020-12-21T22:36:45Z", "message": "AWS: Glue catalog locking through DynamoDB"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3MzIyNDg3", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-557322487", "createdAt": "2020-12-22T19:38:16Z", "commit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxOTozODoxNlrOIKHBoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxOTozODoxNlrOIKHBoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzQ3MTc3Nw==", "bodyText": "Does this change need to be in this PR?", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547471777", "createdAt": "2020-12-22T19:38:16Z", "author": {"login": "rdblue"}, "path": "aws/src/integration/java/org/apache/iceberg/aws/s3/S3FileIOTest.java", "diffHunk": "@@ -202,8 +201,7 @@ public void testACL() throws Exception {\n \n   @Test\n   public void testClientFactorySerialization() throws Exception {\n-    S3FileIO fileIO = new S3FileIO();\n-    fileIO.initialize(Maps.newHashMap());\n+    S3FileIO fileIO = new S3FileIO(clientFactory::s3);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "originalPosition": 14}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3MzYxNDg0", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-557361484", "createdAt": "2020-12-22T20:54:55Z", "commit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMDo1NDo1NVrOIKI8DQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMDo1NDo1NVrOIKI8DQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUwMzExNw==", "bodyText": "If this is used for testing, then why not implement it as an in-memory lock manager using synchronized methods? It seems strange to have a default lock manager that doesn't perform locking.", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547503117", "createdAt": "2020-12-22T20:54:55Z", "author": {"login": "rdblue"}, "path": "aws/src/main/java/org/apache/iceberg/aws/glue/DefaultLockManager.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+/**\n+ * Default implementation of {@link LockManager} that always returns true.\n+ * It is mainly used for testing purposes or when no external locking systems are needed.\n+ */\n+public class DefaultLockManager implements LockManager {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "originalPosition": 26}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3MzYzMzQ4", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-557363348", "createdAt": "2020-12-22T20:58:37Z", "commit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMDo1ODozN1rOIKJCOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMDo1ODozN1rOIKJCOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUwNDY5OA==", "bodyText": "Nit: there should be no need to add <>. If the table name is empty or null, that should be a separate exception.", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547504698", "createdAt": "2020-12-22T20:58:37Z", "author": {"login": "rdblue"}, "path": "aws/src/main/java/org/apache/iceberg/aws/glue/DynamoLockManager.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeDefinition;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.BillingMode;\n+import software.amazon.awssdk.services.dynamodb.model.ConditionalCheckFailedException;\n+import software.amazon.awssdk.services.dynamodb.model.CreateTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableResponse;\n+import software.amazon.awssdk.services.dynamodb.model.KeySchemaElement;\n+import software.amazon.awssdk.services.dynamodb.model.KeyType;\n+import software.amazon.awssdk.services.dynamodb.model.PutItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+import software.amazon.awssdk.services.dynamodb.model.ScalarAttributeType;\n+import software.amazon.awssdk.services.dynamodb.model.TableStatus;\n+\n+/**\n+ * DynamoDB implementation for the lock manager.\n+ */\n+class DynamoLockManager implements LockManager {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManager.class);\n+\n+  private static final String LOCK_TABLE_COL_LOCK_ID = \"lockId\";\n+  private static final String LOCK_TABLE_COL_EXPIRE_TS_MILLIS = \"expireTimestampMillis\";\n+  private static final long LOCK_TABLE_CREATION_WAIT_MS = 5000;\n+  private static final int LOCK_TABLE_CREATION_WAIT_ROUNDS = 10;\n+\n+  private static final List<KeySchemaElement> LOCK_TABLE_SCHEMA = Lists.newArrayList(\n+      KeySchemaElement.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .keyType(KeyType.HASH)\n+          .build()\n+  );\n+\n+  private static final List<AttributeDefinition> LOCK_TABLE_COL_DEFINITIONS = Lists.newArrayList(\n+      AttributeDefinition.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .attributeType(ScalarAttributeType.S)\n+          .build()\n+  );\n+\n+  private final DynamoDbClient dynamo;\n+  private final AwsProperties awsProperties;\n+\n+  DynamoLockManager(DynamoDbClient dynamo, AwsProperties awsProperties) {\n+    this.dynamo = dynamo;\n+    this.awsProperties = awsProperties;\n+    ensureLockTableExistsOrCreate();\n+  }\n+\n+  private void ensureLockTableExistsOrCreate() {\n+    ensureTableExistsOrCreate(awsProperties.glueCatalogLockTable(), LOCK_TABLE_SCHEMA, LOCK_TABLE_COL_DEFINITIONS);\n+  }\n+\n+  private void ensureTableExistsOrCreate(String tableName, List<KeySchemaElement> schema,\n+                                         List<AttributeDefinition> definitions) {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(tableName)\n+          .build());\n+    } catch (ResourceNotFoundException e) {\n+      LOG.info(\"Glue lock DynamoDB table <{}> not found, trying to create\", tableName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "originalPosition": 91}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3MzY5NTk5", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-557369599", "createdAt": "2020-12-22T21:12:06Z", "commit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMToxMjowNlrOIKJVKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMToxMjowNlrOIKJVKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUwOTU0NQ==", "bodyText": "The return value of ++ should not be used in Iceberg because it is hard to reason about. Can you move the increment to a separate line?", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547509545", "createdAt": "2020-12-22T21:12:06Z", "author": {"login": "rdblue"}, "path": "aws/src/main/java/org/apache/iceberg/aws/glue/DynamoLockManager.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeDefinition;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.BillingMode;\n+import software.amazon.awssdk.services.dynamodb.model.ConditionalCheckFailedException;\n+import software.amazon.awssdk.services.dynamodb.model.CreateTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableResponse;\n+import software.amazon.awssdk.services.dynamodb.model.KeySchemaElement;\n+import software.amazon.awssdk.services.dynamodb.model.KeyType;\n+import software.amazon.awssdk.services.dynamodb.model.PutItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+import software.amazon.awssdk.services.dynamodb.model.ScalarAttributeType;\n+import software.amazon.awssdk.services.dynamodb.model.TableStatus;\n+\n+/**\n+ * DynamoDB implementation for the lock manager.\n+ */\n+class DynamoLockManager implements LockManager {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManager.class);\n+\n+  private static final String LOCK_TABLE_COL_LOCK_ID = \"lockId\";\n+  private static final String LOCK_TABLE_COL_EXPIRE_TS_MILLIS = \"expireTimestampMillis\";\n+  private static final long LOCK_TABLE_CREATION_WAIT_MS = 5000;\n+  private static final int LOCK_TABLE_CREATION_WAIT_ROUNDS = 10;\n+\n+  private static final List<KeySchemaElement> LOCK_TABLE_SCHEMA = Lists.newArrayList(\n+      KeySchemaElement.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .keyType(KeyType.HASH)\n+          .build()\n+  );\n+\n+  private static final List<AttributeDefinition> LOCK_TABLE_COL_DEFINITIONS = Lists.newArrayList(\n+      AttributeDefinition.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .attributeType(ScalarAttributeType.S)\n+          .build()\n+  );\n+\n+  private final DynamoDbClient dynamo;\n+  private final AwsProperties awsProperties;\n+\n+  DynamoLockManager(DynamoDbClient dynamo, AwsProperties awsProperties) {\n+    this.dynamo = dynamo;\n+    this.awsProperties = awsProperties;\n+    ensureLockTableExistsOrCreate();\n+  }\n+\n+  private void ensureLockTableExistsOrCreate() {\n+    ensureTableExistsOrCreate(awsProperties.glueCatalogLockTable(), LOCK_TABLE_SCHEMA, LOCK_TABLE_COL_DEFINITIONS);\n+  }\n+\n+  private void ensureTableExistsOrCreate(String tableName, List<KeySchemaElement> schema,\n+                                         List<AttributeDefinition> definitions) {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(tableName)\n+          .build());\n+    } catch (ResourceNotFoundException e) {\n+      LOG.info(\"Glue lock DynamoDB table <{}> not found, trying to create\", tableName);\n+      dynamo.createTable(CreateTableRequest.builder()\n+          .tableName(tableName)\n+          .keySchema(schema)\n+          .attributeDefinitions(definitions)\n+          .billingMode(BillingMode.PAY_PER_REQUEST)\n+          .build());\n+\n+      boolean isTableActive = false;\n+      int round = 0;\n+      while (!isTableActive && round < LOCK_TABLE_CREATION_WAIT_ROUNDS) {\n+        LOG.info(\"waiting for DynamoDB table <{}> to be active, round {}\", tableName, round++);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "originalPosition": 102}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3MzY5NzEz", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-557369713", "createdAt": "2020-12-22T21:12:21Z", "commit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMToxMjoyMVrOIKJVeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMToxMjoyMVrOIKJVeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUwOTYyNA==", "bodyText": "Nit: needs a newline between control flow statements.", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547509624", "createdAt": "2020-12-22T21:12:21Z", "author": {"login": "rdblue"}, "path": "aws/src/main/java/org/apache/iceberg/aws/glue/DynamoLockManager.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeDefinition;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.BillingMode;\n+import software.amazon.awssdk.services.dynamodb.model.ConditionalCheckFailedException;\n+import software.amazon.awssdk.services.dynamodb.model.CreateTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableResponse;\n+import software.amazon.awssdk.services.dynamodb.model.KeySchemaElement;\n+import software.amazon.awssdk.services.dynamodb.model.KeyType;\n+import software.amazon.awssdk.services.dynamodb.model.PutItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+import software.amazon.awssdk.services.dynamodb.model.ScalarAttributeType;\n+import software.amazon.awssdk.services.dynamodb.model.TableStatus;\n+\n+/**\n+ * DynamoDB implementation for the lock manager.\n+ */\n+class DynamoLockManager implements LockManager {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManager.class);\n+\n+  private static final String LOCK_TABLE_COL_LOCK_ID = \"lockId\";\n+  private static final String LOCK_TABLE_COL_EXPIRE_TS_MILLIS = \"expireTimestampMillis\";\n+  private static final long LOCK_TABLE_CREATION_WAIT_MS = 5000;\n+  private static final int LOCK_TABLE_CREATION_WAIT_ROUNDS = 10;\n+\n+  private static final List<KeySchemaElement> LOCK_TABLE_SCHEMA = Lists.newArrayList(\n+      KeySchemaElement.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .keyType(KeyType.HASH)\n+          .build()\n+  );\n+\n+  private static final List<AttributeDefinition> LOCK_TABLE_COL_DEFINITIONS = Lists.newArrayList(\n+      AttributeDefinition.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .attributeType(ScalarAttributeType.S)\n+          .build()\n+  );\n+\n+  private final DynamoDbClient dynamo;\n+  private final AwsProperties awsProperties;\n+\n+  DynamoLockManager(DynamoDbClient dynamo, AwsProperties awsProperties) {\n+    this.dynamo = dynamo;\n+    this.awsProperties = awsProperties;\n+    ensureLockTableExistsOrCreate();\n+  }\n+\n+  private void ensureLockTableExistsOrCreate() {\n+    ensureTableExistsOrCreate(awsProperties.glueCatalogLockTable(), LOCK_TABLE_SCHEMA, LOCK_TABLE_COL_DEFINITIONS);\n+  }\n+\n+  private void ensureTableExistsOrCreate(String tableName, List<KeySchemaElement> schema,\n+                                         List<AttributeDefinition> definitions) {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(tableName)\n+          .build());\n+    } catch (ResourceNotFoundException e) {\n+      LOG.info(\"Glue lock DynamoDB table <{}> not found, trying to create\", tableName);\n+      dynamo.createTable(CreateTableRequest.builder()\n+          .tableName(tableName)\n+          .keySchema(schema)\n+          .attributeDefinitions(definitions)\n+          .billingMode(BillingMode.PAY_PER_REQUEST)\n+          .build());\n+\n+      boolean isTableActive = false;\n+      int round = 0;\n+      while (!isTableActive && round < LOCK_TABLE_CREATION_WAIT_ROUNDS) {\n+        LOG.info(\"waiting for DynamoDB table <{}> to be active, round {}\", tableName, round++);\n+        try {\n+          Thread.sleep(LOCK_TABLE_CREATION_WAIT_MS);\n+        } catch (InterruptedException ie) {\n+          Thread.currentThread().interrupt();\n+          LOG.warn(\"Glue lock DynamoDB table creation sleep interrupted\", ie);\n+        }\n+        try {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "originalPosition": 109}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3MzY5ODk4", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-557369898", "createdAt": "2020-12-22T21:12:47Z", "commit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMToxMjo0OFrOIKJWAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMToxMjo0OFrOIKJWAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUwOTc2MA==", "bodyText": "Nit: error messages should use sentence case: \"Describe table ...\"", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547509760", "createdAt": "2020-12-22T21:12:48Z", "author": {"login": "rdblue"}, "path": "aws/src/main/java/org/apache/iceberg/aws/glue/DynamoLockManager.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeDefinition;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.BillingMode;\n+import software.amazon.awssdk.services.dynamodb.model.ConditionalCheckFailedException;\n+import software.amazon.awssdk.services.dynamodb.model.CreateTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableResponse;\n+import software.amazon.awssdk.services.dynamodb.model.KeySchemaElement;\n+import software.amazon.awssdk.services.dynamodb.model.KeyType;\n+import software.amazon.awssdk.services.dynamodb.model.PutItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+import software.amazon.awssdk.services.dynamodb.model.ScalarAttributeType;\n+import software.amazon.awssdk.services.dynamodb.model.TableStatus;\n+\n+/**\n+ * DynamoDB implementation for the lock manager.\n+ */\n+class DynamoLockManager implements LockManager {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManager.class);\n+\n+  private static final String LOCK_TABLE_COL_LOCK_ID = \"lockId\";\n+  private static final String LOCK_TABLE_COL_EXPIRE_TS_MILLIS = \"expireTimestampMillis\";\n+  private static final long LOCK_TABLE_CREATION_WAIT_MS = 5000;\n+  private static final int LOCK_TABLE_CREATION_WAIT_ROUNDS = 10;\n+\n+  private static final List<KeySchemaElement> LOCK_TABLE_SCHEMA = Lists.newArrayList(\n+      KeySchemaElement.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .keyType(KeyType.HASH)\n+          .build()\n+  );\n+\n+  private static final List<AttributeDefinition> LOCK_TABLE_COL_DEFINITIONS = Lists.newArrayList(\n+      AttributeDefinition.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .attributeType(ScalarAttributeType.S)\n+          .build()\n+  );\n+\n+  private final DynamoDbClient dynamo;\n+  private final AwsProperties awsProperties;\n+\n+  DynamoLockManager(DynamoDbClient dynamo, AwsProperties awsProperties) {\n+    this.dynamo = dynamo;\n+    this.awsProperties = awsProperties;\n+    ensureLockTableExistsOrCreate();\n+  }\n+\n+  private void ensureLockTableExistsOrCreate() {\n+    ensureTableExistsOrCreate(awsProperties.glueCatalogLockTable(), LOCK_TABLE_SCHEMA, LOCK_TABLE_COL_DEFINITIONS);\n+  }\n+\n+  private void ensureTableExistsOrCreate(String tableName, List<KeySchemaElement> schema,\n+                                         List<AttributeDefinition> definitions) {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(tableName)\n+          .build());\n+    } catch (ResourceNotFoundException e) {\n+      LOG.info(\"Glue lock DynamoDB table <{}> not found, trying to create\", tableName);\n+      dynamo.createTable(CreateTableRequest.builder()\n+          .tableName(tableName)\n+          .keySchema(schema)\n+          .attributeDefinitions(definitions)\n+          .billingMode(BillingMode.PAY_PER_REQUEST)\n+          .build());\n+\n+      boolean isTableActive = false;\n+      int round = 0;\n+      while (!isTableActive && round < LOCK_TABLE_CREATION_WAIT_ROUNDS) {\n+        LOG.info(\"waiting for DynamoDB table <{}> to be active, round {}\", tableName, round++);\n+        try {\n+          Thread.sleep(LOCK_TABLE_CREATION_WAIT_MS);\n+        } catch (InterruptedException ie) {\n+          Thread.currentThread().interrupt();\n+          LOG.warn(\"Glue lock DynamoDB table creation sleep interrupted\", ie);\n+        }\n+        try {\n+          DescribeTableResponse describeTableResponse = dynamo.describeTable(DescribeTableRequest.builder()\n+              .tableName(tableName)\n+              .build());\n+          isTableActive = describeTableResponse.table().tableStatus().equals(TableStatus.ACTIVE);\n+        } catch (ResourceNotFoundException e2) {\n+          LOG.error(\"describe table failed after table creation\", e2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "originalPosition": 115}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3MzcwNDI0", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-557370424", "createdAt": "2020-12-22T21:14:00Z", "commit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMToxNDowMFrOIKJXtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMToxNDowMFrOIKJXtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUxMDE5OA==", "bodyText": "This should break out of the loop when interrupted.", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547510198", "createdAt": "2020-12-22T21:14:00Z", "author": {"login": "rdblue"}, "path": "aws/src/main/java/org/apache/iceberg/aws/glue/DynamoLockManager.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeDefinition;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.BillingMode;\n+import software.amazon.awssdk.services.dynamodb.model.ConditionalCheckFailedException;\n+import software.amazon.awssdk.services.dynamodb.model.CreateTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableResponse;\n+import software.amazon.awssdk.services.dynamodb.model.KeySchemaElement;\n+import software.amazon.awssdk.services.dynamodb.model.KeyType;\n+import software.amazon.awssdk.services.dynamodb.model.PutItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+import software.amazon.awssdk.services.dynamodb.model.ScalarAttributeType;\n+import software.amazon.awssdk.services.dynamodb.model.TableStatus;\n+\n+/**\n+ * DynamoDB implementation for the lock manager.\n+ */\n+class DynamoLockManager implements LockManager {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManager.class);\n+\n+  private static final String LOCK_TABLE_COL_LOCK_ID = \"lockId\";\n+  private static final String LOCK_TABLE_COL_EXPIRE_TS_MILLIS = \"expireTimestampMillis\";\n+  private static final long LOCK_TABLE_CREATION_WAIT_MS = 5000;\n+  private static final int LOCK_TABLE_CREATION_WAIT_ROUNDS = 10;\n+\n+  private static final List<KeySchemaElement> LOCK_TABLE_SCHEMA = Lists.newArrayList(\n+      KeySchemaElement.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .keyType(KeyType.HASH)\n+          .build()\n+  );\n+\n+  private static final List<AttributeDefinition> LOCK_TABLE_COL_DEFINITIONS = Lists.newArrayList(\n+      AttributeDefinition.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .attributeType(ScalarAttributeType.S)\n+          .build()\n+  );\n+\n+  private final DynamoDbClient dynamo;\n+  private final AwsProperties awsProperties;\n+\n+  DynamoLockManager(DynamoDbClient dynamo, AwsProperties awsProperties) {\n+    this.dynamo = dynamo;\n+    this.awsProperties = awsProperties;\n+    ensureLockTableExistsOrCreate();\n+  }\n+\n+  private void ensureLockTableExistsOrCreate() {\n+    ensureTableExistsOrCreate(awsProperties.glueCatalogLockTable(), LOCK_TABLE_SCHEMA, LOCK_TABLE_COL_DEFINITIONS);\n+  }\n+\n+  private void ensureTableExistsOrCreate(String tableName, List<KeySchemaElement> schema,\n+                                         List<AttributeDefinition> definitions) {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(tableName)\n+          .build());\n+    } catch (ResourceNotFoundException e) {\n+      LOG.info(\"Glue lock DynamoDB table <{}> not found, trying to create\", tableName);\n+      dynamo.createTable(CreateTableRequest.builder()\n+          .tableName(tableName)\n+          .keySchema(schema)\n+          .attributeDefinitions(definitions)\n+          .billingMode(BillingMode.PAY_PER_REQUEST)\n+          .build());\n+\n+      boolean isTableActive = false;\n+      int round = 0;\n+      while (!isTableActive && round < LOCK_TABLE_CREATION_WAIT_ROUNDS) {\n+        LOG.info(\"waiting for DynamoDB table <{}> to be active, round {}\", tableName, round++);\n+        try {\n+          Thread.sleep(LOCK_TABLE_CREATION_WAIT_MS);\n+        } catch (InterruptedException ie) {\n+          Thread.currentThread().interrupt();\n+          LOG.warn(\"Glue lock DynamoDB table creation sleep interrupted\", ie);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "originalPosition": 107}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3MzcwNjcw", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-557370670", "createdAt": "2020-12-22T21:14:35Z", "commit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMToxNDozNVrOIKJYfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMToxNDozNVrOIKJYfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUxMDM5Ng==", "bodyText": "How about \"Timed out after %s ms waiting for table %s to become active\"?", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547510396", "createdAt": "2020-12-22T21:14:35Z", "author": {"login": "rdblue"}, "path": "aws/src/main/java/org/apache/iceberg/aws/glue/DynamoLockManager.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeDefinition;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.BillingMode;\n+import software.amazon.awssdk.services.dynamodb.model.ConditionalCheckFailedException;\n+import software.amazon.awssdk.services.dynamodb.model.CreateTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableResponse;\n+import software.amazon.awssdk.services.dynamodb.model.KeySchemaElement;\n+import software.amazon.awssdk.services.dynamodb.model.KeyType;\n+import software.amazon.awssdk.services.dynamodb.model.PutItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+import software.amazon.awssdk.services.dynamodb.model.ScalarAttributeType;\n+import software.amazon.awssdk.services.dynamodb.model.TableStatus;\n+\n+/**\n+ * DynamoDB implementation for the lock manager.\n+ */\n+class DynamoLockManager implements LockManager {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManager.class);\n+\n+  private static final String LOCK_TABLE_COL_LOCK_ID = \"lockId\";\n+  private static final String LOCK_TABLE_COL_EXPIRE_TS_MILLIS = \"expireTimestampMillis\";\n+  private static final long LOCK_TABLE_CREATION_WAIT_MS = 5000;\n+  private static final int LOCK_TABLE_CREATION_WAIT_ROUNDS = 10;\n+\n+  private static final List<KeySchemaElement> LOCK_TABLE_SCHEMA = Lists.newArrayList(\n+      KeySchemaElement.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .keyType(KeyType.HASH)\n+          .build()\n+  );\n+\n+  private static final List<AttributeDefinition> LOCK_TABLE_COL_DEFINITIONS = Lists.newArrayList(\n+      AttributeDefinition.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .attributeType(ScalarAttributeType.S)\n+          .build()\n+  );\n+\n+  private final DynamoDbClient dynamo;\n+  private final AwsProperties awsProperties;\n+\n+  DynamoLockManager(DynamoDbClient dynamo, AwsProperties awsProperties) {\n+    this.dynamo = dynamo;\n+    this.awsProperties = awsProperties;\n+    ensureLockTableExistsOrCreate();\n+  }\n+\n+  private void ensureLockTableExistsOrCreate() {\n+    ensureTableExistsOrCreate(awsProperties.glueCatalogLockTable(), LOCK_TABLE_SCHEMA, LOCK_TABLE_COL_DEFINITIONS);\n+  }\n+\n+  private void ensureTableExistsOrCreate(String tableName, List<KeySchemaElement> schema,\n+                                         List<AttributeDefinition> definitions) {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(tableName)\n+          .build());\n+    } catch (ResourceNotFoundException e) {\n+      LOG.info(\"Glue lock DynamoDB table <{}> not found, trying to create\", tableName);\n+      dynamo.createTable(CreateTableRequest.builder()\n+          .tableName(tableName)\n+          .keySchema(schema)\n+          .attributeDefinitions(definitions)\n+          .billingMode(BillingMode.PAY_PER_REQUEST)\n+          .build());\n+\n+      boolean isTableActive = false;\n+      int round = 0;\n+      while (!isTableActive && round < LOCK_TABLE_CREATION_WAIT_ROUNDS) {\n+        LOG.info(\"waiting for DynamoDB table <{}> to be active, round {}\", tableName, round++);\n+        try {\n+          Thread.sleep(LOCK_TABLE_CREATION_WAIT_MS);\n+        } catch (InterruptedException ie) {\n+          Thread.currentThread().interrupt();\n+          LOG.warn(\"Glue lock DynamoDB table creation sleep interrupted\", ie);\n+        }\n+        try {\n+          DescribeTableResponse describeTableResponse = dynamo.describeTable(DescribeTableRequest.builder()\n+              .tableName(tableName)\n+              .build());\n+          isTableActive = describeTableResponse.table().tableStatus().equals(TableStatus.ACTIVE);\n+        } catch (ResourceNotFoundException e2) {\n+          LOG.error(\"describe table failed after table creation\", e2);\n+        }\n+      }\n+\n+      if (!isTableActive) {\n+        throw new IllegalStateException(String.format(\"DynamoDB table <%s> failed to become active after %d ms\",\n+            tableName, LOCK_TABLE_CREATION_WAIT_MS * LOCK_TABLE_CREATION_WAIT_ROUNDS));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "originalPosition": 121}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3MzcxNDUx", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-557371451", "createdAt": "2020-12-22T21:16:18Z", "commit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMToxNjoxOVrOIKJbHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMToxNjoxOVrOIKJbHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUxMTA3MQ==", "bodyText": "I don't think that \"round\" is very clear. In most places we refer to this as an \"attempt\" or \"try\". What do you think about using \"attempt\" here?", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547511071", "createdAt": "2020-12-22T21:16:19Z", "author": {"login": "rdblue"}, "path": "aws/src/main/java/org/apache/iceberg/aws/glue/DynamoLockManager.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeDefinition;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.BillingMode;\n+import software.amazon.awssdk.services.dynamodb.model.ConditionalCheckFailedException;\n+import software.amazon.awssdk.services.dynamodb.model.CreateTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableResponse;\n+import software.amazon.awssdk.services.dynamodb.model.KeySchemaElement;\n+import software.amazon.awssdk.services.dynamodb.model.KeyType;\n+import software.amazon.awssdk.services.dynamodb.model.PutItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+import software.amazon.awssdk.services.dynamodb.model.ScalarAttributeType;\n+import software.amazon.awssdk.services.dynamodb.model.TableStatus;\n+\n+/**\n+ * DynamoDB implementation for the lock manager.\n+ */\n+class DynamoLockManager implements LockManager {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManager.class);\n+\n+  private static final String LOCK_TABLE_COL_LOCK_ID = \"lockId\";\n+  private static final String LOCK_TABLE_COL_EXPIRE_TS_MILLIS = \"expireTimestampMillis\";\n+  private static final long LOCK_TABLE_CREATION_WAIT_MS = 5000;\n+  private static final int LOCK_TABLE_CREATION_WAIT_ROUNDS = 10;\n+\n+  private static final List<KeySchemaElement> LOCK_TABLE_SCHEMA = Lists.newArrayList(\n+      KeySchemaElement.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .keyType(KeyType.HASH)\n+          .build()\n+  );\n+\n+  private static final List<AttributeDefinition> LOCK_TABLE_COL_DEFINITIONS = Lists.newArrayList(\n+      AttributeDefinition.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .attributeType(ScalarAttributeType.S)\n+          .build()\n+  );\n+\n+  private final DynamoDbClient dynamo;\n+  private final AwsProperties awsProperties;\n+\n+  DynamoLockManager(DynamoDbClient dynamo, AwsProperties awsProperties) {\n+    this.dynamo = dynamo;\n+    this.awsProperties = awsProperties;\n+    ensureLockTableExistsOrCreate();\n+  }\n+\n+  private void ensureLockTableExistsOrCreate() {\n+    ensureTableExistsOrCreate(awsProperties.glueCatalogLockTable(), LOCK_TABLE_SCHEMA, LOCK_TABLE_COL_DEFINITIONS);\n+  }\n+\n+  private void ensureTableExistsOrCreate(String tableName, List<KeySchemaElement> schema,\n+                                         List<AttributeDefinition> definitions) {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(tableName)\n+          .build());\n+    } catch (ResourceNotFoundException e) {\n+      LOG.info(\"Glue lock DynamoDB table <{}> not found, trying to create\", tableName);\n+      dynamo.createTable(CreateTableRequest.builder()\n+          .tableName(tableName)\n+          .keySchema(schema)\n+          .attributeDefinitions(definitions)\n+          .billingMode(BillingMode.PAY_PER_REQUEST)\n+          .build());\n+\n+      boolean isTableActive = false;\n+      int round = 0;\n+      while (!isTableActive && round < LOCK_TABLE_CREATION_WAIT_ROUNDS) {\n+        LOG.info(\"waiting for DynamoDB table <{}> to be active, round {}\", tableName, round++);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "originalPosition": 102}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3MzcxNjA1", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-557371605", "createdAt": "2020-12-22T21:16:42Z", "commit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMToxNjo0MlrOIKJbrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMToxNjo0MlrOIKJbrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUxMTIxNQ==", "bodyText": "Could this use Tasks instead of custom logic? That supports retries with a configurable backoff policy.", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547511215", "createdAt": "2020-12-22T21:16:42Z", "author": {"login": "rdblue"}, "path": "aws/src/main/java/org/apache/iceberg/aws/glue/DynamoLockManager.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeDefinition;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.BillingMode;\n+import software.amazon.awssdk.services.dynamodb.model.ConditionalCheckFailedException;\n+import software.amazon.awssdk.services.dynamodb.model.CreateTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableResponse;\n+import software.amazon.awssdk.services.dynamodb.model.KeySchemaElement;\n+import software.amazon.awssdk.services.dynamodb.model.KeyType;\n+import software.amazon.awssdk.services.dynamodb.model.PutItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+import software.amazon.awssdk.services.dynamodb.model.ScalarAttributeType;\n+import software.amazon.awssdk.services.dynamodb.model.TableStatus;\n+\n+/**\n+ * DynamoDB implementation for the lock manager.\n+ */\n+class DynamoLockManager implements LockManager {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManager.class);\n+\n+  private static final String LOCK_TABLE_COL_LOCK_ID = \"lockId\";\n+  private static final String LOCK_TABLE_COL_EXPIRE_TS_MILLIS = \"expireTimestampMillis\";\n+  private static final long LOCK_TABLE_CREATION_WAIT_MS = 5000;\n+  private static final int LOCK_TABLE_CREATION_WAIT_ROUNDS = 10;\n+\n+  private static final List<KeySchemaElement> LOCK_TABLE_SCHEMA = Lists.newArrayList(\n+      KeySchemaElement.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .keyType(KeyType.HASH)\n+          .build()\n+  );\n+\n+  private static final List<AttributeDefinition> LOCK_TABLE_COL_DEFINITIONS = Lists.newArrayList(\n+      AttributeDefinition.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .attributeType(ScalarAttributeType.S)\n+          .build()\n+  );\n+\n+  private final DynamoDbClient dynamo;\n+  private final AwsProperties awsProperties;\n+\n+  DynamoLockManager(DynamoDbClient dynamo, AwsProperties awsProperties) {\n+    this.dynamo = dynamo;\n+    this.awsProperties = awsProperties;\n+    ensureLockTableExistsOrCreate();\n+  }\n+\n+  private void ensureLockTableExistsOrCreate() {\n+    ensureTableExistsOrCreate(awsProperties.glueCatalogLockTable(), LOCK_TABLE_SCHEMA, LOCK_TABLE_COL_DEFINITIONS);\n+  }\n+\n+  private void ensureTableExistsOrCreate(String tableName, List<KeySchemaElement> schema,\n+                                         List<AttributeDefinition> definitions) {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(tableName)\n+          .build());\n+    } catch (ResourceNotFoundException e) {\n+      LOG.info(\"Glue lock DynamoDB table <{}> not found, trying to create\", tableName);\n+      dynamo.createTable(CreateTableRequest.builder()\n+          .tableName(tableName)\n+          .keySchema(schema)\n+          .attributeDefinitions(definitions)\n+          .billingMode(BillingMode.PAY_PER_REQUEST)\n+          .build());\n+\n+      boolean isTableActive = false;\n+      int round = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "originalPosition": 100}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3MzcyMDg3", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-557372087", "createdAt": "2020-12-22T21:17:51Z", "commit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMToxNzo1MVrOIKJdWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMToxNzo1MVrOIKJdWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUxMTY0Mg==", "bodyText": "Nit: No need for a newline at the start of a method.", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547511642", "createdAt": "2020-12-22T21:17:51Z", "author": {"login": "rdblue"}, "path": "aws/src/main/java/org/apache/iceberg/aws/glue/DynamoLockManager.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeDefinition;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.BillingMode;\n+import software.amazon.awssdk.services.dynamodb.model.ConditionalCheckFailedException;\n+import software.amazon.awssdk.services.dynamodb.model.CreateTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableResponse;\n+import software.amazon.awssdk.services.dynamodb.model.KeySchemaElement;\n+import software.amazon.awssdk.services.dynamodb.model.KeyType;\n+import software.amazon.awssdk.services.dynamodb.model.PutItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+import software.amazon.awssdk.services.dynamodb.model.ScalarAttributeType;\n+import software.amazon.awssdk.services.dynamodb.model.TableStatus;\n+\n+/**\n+ * DynamoDB implementation for the lock manager.\n+ */\n+class DynamoLockManager implements LockManager {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManager.class);\n+\n+  private static final String LOCK_TABLE_COL_LOCK_ID = \"lockId\";\n+  private static final String LOCK_TABLE_COL_EXPIRE_TS_MILLIS = \"expireTimestampMillis\";\n+  private static final long LOCK_TABLE_CREATION_WAIT_MS = 5000;\n+  private static final int LOCK_TABLE_CREATION_WAIT_ROUNDS = 10;\n+\n+  private static final List<KeySchemaElement> LOCK_TABLE_SCHEMA = Lists.newArrayList(\n+      KeySchemaElement.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .keyType(KeyType.HASH)\n+          .build()\n+  );\n+\n+  private static final List<AttributeDefinition> LOCK_TABLE_COL_DEFINITIONS = Lists.newArrayList(\n+      AttributeDefinition.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .attributeType(ScalarAttributeType.S)\n+          .build()\n+  );\n+\n+  private final DynamoDbClient dynamo;\n+  private final AwsProperties awsProperties;\n+\n+  DynamoLockManager(DynamoDbClient dynamo, AwsProperties awsProperties) {\n+    this.dynamo = dynamo;\n+    this.awsProperties = awsProperties;\n+    ensureLockTableExistsOrCreate();\n+  }\n+\n+  private void ensureLockTableExistsOrCreate() {\n+    ensureTableExistsOrCreate(awsProperties.glueCatalogLockTable(), LOCK_TABLE_SCHEMA, LOCK_TABLE_COL_DEFINITIONS);\n+  }\n+\n+  private void ensureTableExistsOrCreate(String tableName, List<KeySchemaElement> schema,\n+                                         List<AttributeDefinition> definitions) {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(tableName)\n+          .build());\n+    } catch (ResourceNotFoundException e) {\n+      LOG.info(\"Glue lock DynamoDB table <{}> not found, trying to create\", tableName);\n+      dynamo.createTable(CreateTableRequest.builder()\n+          .tableName(tableName)\n+          .keySchema(schema)\n+          .attributeDefinitions(definitions)\n+          .billingMode(BillingMode.PAY_PER_REQUEST)\n+          .build());\n+\n+      boolean isTableActive = false;\n+      int round = 0;\n+      while (!isTableActive && round < LOCK_TABLE_CREATION_WAIT_ROUNDS) {\n+        LOG.info(\"waiting for DynamoDB table <{}> to be active, round {}\", tableName, round++);\n+        try {\n+          Thread.sleep(LOCK_TABLE_CREATION_WAIT_MS);\n+        } catch (InterruptedException ie) {\n+          Thread.currentThread().interrupt();\n+          LOG.warn(\"Glue lock DynamoDB table creation sleep interrupted\", ie);\n+        }\n+        try {\n+          DescribeTableResponse describeTableResponse = dynamo.describeTable(DescribeTableRequest.builder()\n+              .tableName(tableName)\n+              .build());\n+          isTableActive = describeTableResponse.table().tableStatus().equals(TableStatus.ACTIVE);\n+        } catch (ResourceNotFoundException e2) {\n+          LOG.error(\"describe table failed after table creation\", e2);\n+        }\n+      }\n+\n+      if (!isTableActive) {\n+        throw new IllegalStateException(String.format(\"DynamoDB table <%s> failed to become active after %d ms\",\n+            tableName, LOCK_TABLE_CREATION_WAIT_MS * LOCK_TABLE_CREATION_WAIT_ROUNDS));\n+      }\n+    }\n+  }\n+\n+\n+  @Override\n+  public boolean tryLock(String lockId, long expireMillis) {\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "originalPosition": 129}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3MzcyMTY3", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-557372167", "createdAt": "2020-12-22T21:17:59Z", "commit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMToxNzo1OVrOIKJdmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMToxNzo1OVrOIKJdmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUxMTcwNw==", "bodyText": "Nit: double newline.", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547511707", "createdAt": "2020-12-22T21:17:59Z", "author": {"login": "rdblue"}, "path": "aws/src/main/java/org/apache/iceberg/aws/glue/DynamoLockManager.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeDefinition;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.BillingMode;\n+import software.amazon.awssdk.services.dynamodb.model.ConditionalCheckFailedException;\n+import software.amazon.awssdk.services.dynamodb.model.CreateTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableResponse;\n+import software.amazon.awssdk.services.dynamodb.model.KeySchemaElement;\n+import software.amazon.awssdk.services.dynamodb.model.KeyType;\n+import software.amazon.awssdk.services.dynamodb.model.PutItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+import software.amazon.awssdk.services.dynamodb.model.ScalarAttributeType;\n+import software.amazon.awssdk.services.dynamodb.model.TableStatus;\n+\n+/**\n+ * DynamoDB implementation for the lock manager.\n+ */\n+class DynamoLockManager implements LockManager {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManager.class);\n+\n+  private static final String LOCK_TABLE_COL_LOCK_ID = \"lockId\";\n+  private static final String LOCK_TABLE_COL_EXPIRE_TS_MILLIS = \"expireTimestampMillis\";\n+  private static final long LOCK_TABLE_CREATION_WAIT_MS = 5000;\n+  private static final int LOCK_TABLE_CREATION_WAIT_ROUNDS = 10;\n+\n+  private static final List<KeySchemaElement> LOCK_TABLE_SCHEMA = Lists.newArrayList(\n+      KeySchemaElement.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .keyType(KeyType.HASH)\n+          .build()\n+  );\n+\n+  private static final List<AttributeDefinition> LOCK_TABLE_COL_DEFINITIONS = Lists.newArrayList(\n+      AttributeDefinition.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .attributeType(ScalarAttributeType.S)\n+          .build()\n+  );\n+\n+  private final DynamoDbClient dynamo;\n+  private final AwsProperties awsProperties;\n+\n+  DynamoLockManager(DynamoDbClient dynamo, AwsProperties awsProperties) {\n+    this.dynamo = dynamo;\n+    this.awsProperties = awsProperties;\n+    ensureLockTableExistsOrCreate();\n+  }\n+\n+  private void ensureLockTableExistsOrCreate() {\n+    ensureTableExistsOrCreate(awsProperties.glueCatalogLockTable(), LOCK_TABLE_SCHEMA, LOCK_TABLE_COL_DEFINITIONS);\n+  }\n+\n+  private void ensureTableExistsOrCreate(String tableName, List<KeySchemaElement> schema,\n+                                         List<AttributeDefinition> definitions) {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(tableName)\n+          .build());\n+    } catch (ResourceNotFoundException e) {\n+      LOG.info(\"Glue lock DynamoDB table <{}> not found, trying to create\", tableName);\n+      dynamo.createTable(CreateTableRequest.builder()\n+          .tableName(tableName)\n+          .keySchema(schema)\n+          .attributeDefinitions(definitions)\n+          .billingMode(BillingMode.PAY_PER_REQUEST)\n+          .build());\n+\n+      boolean isTableActive = false;\n+      int round = 0;\n+      while (!isTableActive && round < LOCK_TABLE_CREATION_WAIT_ROUNDS) {\n+        LOG.info(\"waiting for DynamoDB table <{}> to be active, round {}\", tableName, round++);\n+        try {\n+          Thread.sleep(LOCK_TABLE_CREATION_WAIT_MS);\n+        } catch (InterruptedException ie) {\n+          Thread.currentThread().interrupt();\n+          LOG.warn(\"Glue lock DynamoDB table creation sleep interrupted\", ie);\n+        }\n+        try {\n+          DescribeTableResponse describeTableResponse = dynamo.describeTable(DescribeTableRequest.builder()\n+              .tableName(tableName)\n+              .build());\n+          isTableActive = describeTableResponse.table().tableStatus().equals(TableStatus.ACTIVE);\n+        } catch (ResourceNotFoundException e2) {\n+          LOG.error(\"describe table failed after table creation\", e2);\n+        }\n+      }\n+\n+      if (!isTableActive) {\n+        throw new IllegalStateException(String.format(\"DynamoDB table <%s> failed to become active after %d ms\",\n+            tableName, LOCK_TABLE_CREATION_WAIT_MS * LOCK_TABLE_CREATION_WAIT_ROUNDS));\n+      }\n+    }\n+  }\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "originalPosition": 126}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3MzczNDIy", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-557373422", "createdAt": "2020-12-22T21:20:44Z", "commit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMToyMDo0NFrOIKJhug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMToyMDo0NFrOIKJhug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUxMjc2Mg==", "bodyText": "This is duplicated below when waiting for the table to become active. I think it would be cleaner to have a tableExists method:\n  private boolean tableExists(String tableName) {\n    try {\n      dynamo.describeTable(...);\n      return true;\n    } catch (ResourceNotFoundException e) {\n      return false;\n    }\n  }\nThen you could call that method here as well as in waitUntilActive. That would avoid having so much logic in a catch block.", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547512762", "createdAt": "2020-12-22T21:20:44Z", "author": {"login": "rdblue"}, "path": "aws/src/main/java/org/apache/iceberg/aws/glue/DynamoLockManager.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeDefinition;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.BillingMode;\n+import software.amazon.awssdk.services.dynamodb.model.ConditionalCheckFailedException;\n+import software.amazon.awssdk.services.dynamodb.model.CreateTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableResponse;\n+import software.amazon.awssdk.services.dynamodb.model.KeySchemaElement;\n+import software.amazon.awssdk.services.dynamodb.model.KeyType;\n+import software.amazon.awssdk.services.dynamodb.model.PutItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+import software.amazon.awssdk.services.dynamodb.model.ScalarAttributeType;\n+import software.amazon.awssdk.services.dynamodb.model.TableStatus;\n+\n+/**\n+ * DynamoDB implementation for the lock manager.\n+ */\n+class DynamoLockManager implements LockManager {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManager.class);\n+\n+  private static final String LOCK_TABLE_COL_LOCK_ID = \"lockId\";\n+  private static final String LOCK_TABLE_COL_EXPIRE_TS_MILLIS = \"expireTimestampMillis\";\n+  private static final long LOCK_TABLE_CREATION_WAIT_MS = 5000;\n+  private static final int LOCK_TABLE_CREATION_WAIT_ROUNDS = 10;\n+\n+  private static final List<KeySchemaElement> LOCK_TABLE_SCHEMA = Lists.newArrayList(\n+      KeySchemaElement.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .keyType(KeyType.HASH)\n+          .build()\n+  );\n+\n+  private static final List<AttributeDefinition> LOCK_TABLE_COL_DEFINITIONS = Lists.newArrayList(\n+      AttributeDefinition.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .attributeType(ScalarAttributeType.S)\n+          .build()\n+  );\n+\n+  private final DynamoDbClient dynamo;\n+  private final AwsProperties awsProperties;\n+\n+  DynamoLockManager(DynamoDbClient dynamo, AwsProperties awsProperties) {\n+    this.dynamo = dynamo;\n+    this.awsProperties = awsProperties;\n+    ensureLockTableExistsOrCreate();\n+  }\n+\n+  private void ensureLockTableExistsOrCreate() {\n+    ensureTableExistsOrCreate(awsProperties.glueCatalogLockTable(), LOCK_TABLE_SCHEMA, LOCK_TABLE_COL_DEFINITIONS);\n+  }\n+\n+  private void ensureTableExistsOrCreate(String tableName, List<KeySchemaElement> schema,\n+                                         List<AttributeDefinition> definitions) {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(tableName)\n+          .build());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "originalPosition": 89}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3Mzc5MTMw", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-557379130", "createdAt": "2020-12-22T21:33:13Z", "commit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMTozMzoxM1rOIKJzMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMTozMzoxM1rOIKJzMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUxNzIzMw==", "bodyText": "Iceberg generally avoids using \"get\" in names unless it is making the API more clear and understandable. Here, it is sufficient to use lockTableSchema() and lockTableColumnDefinitions()", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547517233", "createdAt": "2020-12-22T21:33:13Z", "author": {"login": "rdblue"}, "path": "aws/src/main/java/org/apache/iceberg/aws/glue/DynamoLockManager.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeDefinition;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.BillingMode;\n+import software.amazon.awssdk.services.dynamodb.model.ConditionalCheckFailedException;\n+import software.amazon.awssdk.services.dynamodb.model.CreateTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableResponse;\n+import software.amazon.awssdk.services.dynamodb.model.KeySchemaElement;\n+import software.amazon.awssdk.services.dynamodb.model.KeyType;\n+import software.amazon.awssdk.services.dynamodb.model.PutItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+import software.amazon.awssdk.services.dynamodb.model.ScalarAttributeType;\n+import software.amazon.awssdk.services.dynamodb.model.TableStatus;\n+\n+/**\n+ * DynamoDB implementation for the lock manager.\n+ */\n+class DynamoLockManager implements LockManager {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManager.class);\n+\n+  private static final String LOCK_TABLE_COL_LOCK_ID = \"lockId\";\n+  private static final String LOCK_TABLE_COL_EXPIRE_TS_MILLIS = \"expireTimestampMillis\";\n+  private static final long LOCK_TABLE_CREATION_WAIT_MS = 5000;\n+  private static final int LOCK_TABLE_CREATION_WAIT_ROUNDS = 10;\n+\n+  private static final List<KeySchemaElement> LOCK_TABLE_SCHEMA = Lists.newArrayList(\n+      KeySchemaElement.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .keyType(KeyType.HASH)\n+          .build()\n+  );\n+\n+  private static final List<AttributeDefinition> LOCK_TABLE_COL_DEFINITIONS = Lists.newArrayList(\n+      AttributeDefinition.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .attributeType(ScalarAttributeType.S)\n+          .build()\n+  );\n+\n+  private final DynamoDbClient dynamo;\n+  private final AwsProperties awsProperties;\n+\n+  DynamoLockManager(DynamoDbClient dynamo, AwsProperties awsProperties) {\n+    this.dynamo = dynamo;\n+    this.awsProperties = awsProperties;\n+    ensureLockTableExistsOrCreate();\n+  }\n+\n+  private void ensureLockTableExistsOrCreate() {\n+    ensureTableExistsOrCreate(awsProperties.glueCatalogLockTable(), LOCK_TABLE_SCHEMA, LOCK_TABLE_COL_DEFINITIONS);\n+  }\n+\n+  private void ensureTableExistsOrCreate(String tableName, List<KeySchemaElement> schema,\n+                                         List<AttributeDefinition> definitions) {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(tableName)\n+          .build());\n+    } catch (ResourceNotFoundException e) {\n+      LOG.info(\"Glue lock DynamoDB table <{}> not found, trying to create\", tableName);\n+      dynamo.createTable(CreateTableRequest.builder()\n+          .tableName(tableName)\n+          .keySchema(schema)\n+          .attributeDefinitions(definitions)\n+          .billingMode(BillingMode.PAY_PER_REQUEST)\n+          .build());\n+\n+      boolean isTableActive = false;\n+      int round = 0;\n+      while (!isTableActive && round < LOCK_TABLE_CREATION_WAIT_ROUNDS) {\n+        LOG.info(\"waiting for DynamoDB table <{}> to be active, round {}\", tableName, round++);\n+        try {\n+          Thread.sleep(LOCK_TABLE_CREATION_WAIT_MS);\n+        } catch (InterruptedException ie) {\n+          Thread.currentThread().interrupt();\n+          LOG.warn(\"Glue lock DynamoDB table creation sleep interrupted\", ie);\n+        }\n+        try {\n+          DescribeTableResponse describeTableResponse = dynamo.describeTable(DescribeTableRequest.builder()\n+              .tableName(tableName)\n+              .build());\n+          isTableActive = describeTableResponse.table().tableStatus().equals(TableStatus.ACTIVE);\n+        } catch (ResourceNotFoundException e2) {\n+          LOG.error(\"describe table failed after table creation\", e2);\n+        }\n+      }\n+\n+      if (!isTableActive) {\n+        throw new IllegalStateException(String.format(\"DynamoDB table <%s> failed to become active after %d ms\",\n+            tableName, LOCK_TABLE_CREATION_WAIT_MS * LOCK_TABLE_CREATION_WAIT_ROUNDS));\n+      }\n+    }\n+  }\n+\n+\n+  @Override\n+  public boolean tryLock(String lockId, long expireMillis) {\n+\n+    Map<String, AttributeValue> key = Maps.newHashMap();\n+    key.put(LOCK_TABLE_COL_LOCK_ID, AttributeValue.builder().s(lockId).build());\n+    // TODO: fix potential clock skew issue\n+    //   more details: https://github.com/awslabs/amazon-dynamodb-lock-client#how-we-handle-clock-skew\n+    key.put(LOCK_TABLE_COL_EXPIRE_TS_MILLIS, AttributeValue.builder().n(\n+        Long.toString(System.currentTimeMillis() + expireMillis)\n+    ).build());\n+\n+    Map<String, AttributeValue> expressionValues = Maps.newHashMap();\n+    expressionValues.put(\":lid\", AttributeValue.builder().s(lockId).build());\n+    expressionValues.put(\":ts\", AttributeValue.builder().n(Long.toString(System.currentTimeMillis())).build());\n+\n+    try {\n+\n+      dynamo.putItem(PutItemRequest.builder()\n+          .tableName(awsProperties.glueCatalogLockTable())\n+          .item(key)\n+          // succeed only if there is no lock, or the lock is there but already expired\n+          .conditionExpression(\"attribute_not_exists(\" +\n+              LOCK_TABLE_COL_LOCK_ID + \") OR (\" +\n+              LOCK_TABLE_COL_LOCK_ID + \" = :lid AND \" +\n+              LOCK_TABLE_COL_EXPIRE_TS_MILLIS + \" < :ts)\")\n+          .expressionAttributeValues(expressionValues)\n+          .build());\n+      return true;\n+    } catch (ConditionalCheckFailedException e) {\n+      LOG.debug(\"Acquiring lock {} failed\", lockId, e);\n+      return false;\n+    } catch (Exception e) {\n+      LOG.error(\"Encountered unexpected exception when acquiring lock {}\", lockId, e);\n+      return false;\n+    }\n+  }\n+\n+  @Override\n+  public void unlock(String lockId) {\n+    Map<String, AttributeValue> key = Maps.newHashMap();\n+    key.put(LOCK_TABLE_COL_LOCK_ID, AttributeValue.builder().s(lockId).build());\n+\n+    dynamo.deleteItem(DeleteItemRequest.builder()\n+        .tableName(awsProperties.glueCatalogLockTable())\n+        .key(key)\n+        .build());\n+  }\n+\n+  /**\n+   * The lock table schema, for users who would like to create the table separately\n+   * @return lock table schema\n+   */\n+  public static List<KeySchemaElement> getLockTableSchema() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "originalPosition": 179}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3MzgzNzk5", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-557383799", "createdAt": "2020-12-22T21:43:57Z", "commit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMTo0Mzo1N1rOIKKCjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMTo0Mzo1N1rOIKKCjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUyMTE2Nw==", "bodyText": "The condition expression used in tryLock allows another process to claim the lock if it appears to be expired. If that happens before the unlock runs in the process that originally held the lock, then unlocking will make the problem worse by deleting the lock held by the new process.\nI think this should be fixed by adding a UUID for the lock manager. A lock manager should only release a lock if it is still held. That is, if the UUID of the current holder matches the lock manager's UUID.", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547521167", "createdAt": "2020-12-22T21:43:57Z", "author": {"login": "rdblue"}, "path": "aws/src/main/java/org/apache/iceberg/aws/glue/DynamoLockManager.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeDefinition;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.BillingMode;\n+import software.amazon.awssdk.services.dynamodb.model.ConditionalCheckFailedException;\n+import software.amazon.awssdk.services.dynamodb.model.CreateTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableResponse;\n+import software.amazon.awssdk.services.dynamodb.model.KeySchemaElement;\n+import software.amazon.awssdk.services.dynamodb.model.KeyType;\n+import software.amazon.awssdk.services.dynamodb.model.PutItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+import software.amazon.awssdk.services.dynamodb.model.ScalarAttributeType;\n+import software.amazon.awssdk.services.dynamodb.model.TableStatus;\n+\n+/**\n+ * DynamoDB implementation for the lock manager.\n+ */\n+class DynamoLockManager implements LockManager {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManager.class);\n+\n+  private static final String LOCK_TABLE_COL_LOCK_ID = \"lockId\";\n+  private static final String LOCK_TABLE_COL_EXPIRE_TS_MILLIS = \"expireTimestampMillis\";\n+  private static final long LOCK_TABLE_CREATION_WAIT_MS = 5000;\n+  private static final int LOCK_TABLE_CREATION_WAIT_ROUNDS = 10;\n+\n+  private static final List<KeySchemaElement> LOCK_TABLE_SCHEMA = Lists.newArrayList(\n+      KeySchemaElement.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .keyType(KeyType.HASH)\n+          .build()\n+  );\n+\n+  private static final List<AttributeDefinition> LOCK_TABLE_COL_DEFINITIONS = Lists.newArrayList(\n+      AttributeDefinition.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .attributeType(ScalarAttributeType.S)\n+          .build()\n+  );\n+\n+  private final DynamoDbClient dynamo;\n+  private final AwsProperties awsProperties;\n+\n+  DynamoLockManager(DynamoDbClient dynamo, AwsProperties awsProperties) {\n+    this.dynamo = dynamo;\n+    this.awsProperties = awsProperties;\n+    ensureLockTableExistsOrCreate();\n+  }\n+\n+  private void ensureLockTableExistsOrCreate() {\n+    ensureTableExistsOrCreate(awsProperties.glueCatalogLockTable(), LOCK_TABLE_SCHEMA, LOCK_TABLE_COL_DEFINITIONS);\n+  }\n+\n+  private void ensureTableExistsOrCreate(String tableName, List<KeySchemaElement> schema,\n+                                         List<AttributeDefinition> definitions) {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(tableName)\n+          .build());\n+    } catch (ResourceNotFoundException e) {\n+      LOG.info(\"Glue lock DynamoDB table <{}> not found, trying to create\", tableName);\n+      dynamo.createTable(CreateTableRequest.builder()\n+          .tableName(tableName)\n+          .keySchema(schema)\n+          .attributeDefinitions(definitions)\n+          .billingMode(BillingMode.PAY_PER_REQUEST)\n+          .build());\n+\n+      boolean isTableActive = false;\n+      int round = 0;\n+      while (!isTableActive && round < LOCK_TABLE_CREATION_WAIT_ROUNDS) {\n+        LOG.info(\"waiting for DynamoDB table <{}> to be active, round {}\", tableName, round++);\n+        try {\n+          Thread.sleep(LOCK_TABLE_CREATION_WAIT_MS);\n+        } catch (InterruptedException ie) {\n+          Thread.currentThread().interrupt();\n+          LOG.warn(\"Glue lock DynamoDB table creation sleep interrupted\", ie);\n+        }\n+        try {\n+          DescribeTableResponse describeTableResponse = dynamo.describeTable(DescribeTableRequest.builder()\n+              .tableName(tableName)\n+              .build());\n+          isTableActive = describeTableResponse.table().tableStatus().equals(TableStatus.ACTIVE);\n+        } catch (ResourceNotFoundException e2) {\n+          LOG.error(\"describe table failed after table creation\", e2);\n+        }\n+      }\n+\n+      if (!isTableActive) {\n+        throw new IllegalStateException(String.format(\"DynamoDB table <%s> failed to become active after %d ms\",\n+            tableName, LOCK_TABLE_CREATION_WAIT_MS * LOCK_TABLE_CREATION_WAIT_ROUNDS));\n+      }\n+    }\n+  }\n+\n+\n+  @Override\n+  public boolean tryLock(String lockId, long expireMillis) {\n+\n+    Map<String, AttributeValue> key = Maps.newHashMap();\n+    key.put(LOCK_TABLE_COL_LOCK_ID, AttributeValue.builder().s(lockId).build());\n+    // TODO: fix potential clock skew issue\n+    //   more details: https://github.com/awslabs/amazon-dynamodb-lock-client#how-we-handle-clock-skew\n+    key.put(LOCK_TABLE_COL_EXPIRE_TS_MILLIS, AttributeValue.builder().n(\n+        Long.toString(System.currentTimeMillis() + expireMillis)\n+    ).build());\n+\n+    Map<String, AttributeValue> expressionValues = Maps.newHashMap();\n+    expressionValues.put(\":lid\", AttributeValue.builder().s(lockId).build());\n+    expressionValues.put(\":ts\", AttributeValue.builder().n(Long.toString(System.currentTimeMillis())).build());\n+\n+    try {\n+\n+      dynamo.putItem(PutItemRequest.builder()\n+          .tableName(awsProperties.glueCatalogLockTable())\n+          .item(key)\n+          // succeed only if there is no lock, or the lock is there but already expired\n+          .conditionExpression(\"attribute_not_exists(\" +\n+              LOCK_TABLE_COL_LOCK_ID + \") OR (\" +\n+              LOCK_TABLE_COL_LOCK_ID + \" = :lid AND \" +\n+              LOCK_TABLE_COL_EXPIRE_TS_MILLIS + \" < :ts)\")\n+          .expressionAttributeValues(expressionValues)\n+          .build());\n+      return true;\n+    } catch (ConditionalCheckFailedException e) {\n+      LOG.debug(\"Acquiring lock {} failed\", lockId, e);\n+      return false;\n+    } catch (Exception e) {\n+      LOG.error(\"Encountered unexpected exception when acquiring lock {}\", lockId, e);\n+      return false;\n+    }\n+  }\n+\n+  @Override\n+  public void unlock(String lockId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "originalPosition": 165}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3MzkwNDU3", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-557390457", "createdAt": "2020-12-22T21:58:40Z", "commit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMTo1ODo0MFrOIKKZAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMTo1ODo0MFrOIKKZAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUyNjkxMg==", "bodyText": "Nit: Rather than creating a new string each time, could you do this once in the constructor?", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547526912", "createdAt": "2020-12-22T21:58:40Z", "author": {"login": "rdblue"}, "path": "aws/src/main/java/org/apache/iceberg/aws/glue/GlueTableOperations.java", "diffHunk": "@@ -117,9 +120,39 @@ protected void doCommit(TableMetadata base, TableMetadata metadata) {\n       if (exceptionThrown) {\n         io().deleteFile(newMetadataLocation);\n       }\n+\n+      unlock();\n+    }\n+  }\n+\n+  private void acquireLock() {\n+    try {\n+      boolean lockAcquired = lockManager.tryLock(lockId(databaseName, tableName),\n+          awsProperties.glueCatalogLockExpireMs(), awsProperties.glueCatalogLockWaitMs());\n+      if (!lockAcquired) {\n+        throw new CommitFailedException(\"Timed out after %s ms waiting for lock on %s.%s\",\n+            awsProperties.glueCatalogLockWaitMs(), databaseName, tableName);\n+      }\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new CommitFailedException(e, \"Thread interrupted during commit\");\n+    } catch (Exception e) {\n+      throw new CommitFailedException(e, \"Unexpected exception when locking %s.%s\", databaseName, tableName);\n     }\n   }\n \n+  private void unlock() {\n+    try {\n+      lockManager.unlock(lockId(databaseName, tableName));\n+    } catch (Exception e) {\n+      LOG.error(\"Unexpected exception when unlocking {}.{}, manual unlock might be needed\", databaseName, tableName, e);\n+    }\n+  }\n+\n+  private String lockId(String database, String table) {\n+    return String.format(\"%s.%s\", database, table);\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "originalPosition": 62}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3MzkwOTA3", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-557390907", "createdAt": "2020-12-22T21:59:38Z", "commit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMTo1OTozOFrOIKKahg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMTo1OTozOFrOIKKahg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUyNzMwMg==", "bodyText": "This should throw something other than CommitFailedException because that exception will cause a retry. When the commit is interrupted, I don't think that it should retry.", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547527302", "createdAt": "2020-12-22T21:59:38Z", "author": {"login": "rdblue"}, "path": "aws/src/main/java/org/apache/iceberg/aws/glue/GlueTableOperations.java", "diffHunk": "@@ -117,9 +120,39 @@ protected void doCommit(TableMetadata base, TableMetadata metadata) {\n       if (exceptionThrown) {\n         io().deleteFile(newMetadataLocation);\n       }\n+\n+      unlock();\n+    }\n+  }\n+\n+  private void acquireLock() {\n+    try {\n+      boolean lockAcquired = lockManager.tryLock(lockId(databaseName, tableName),\n+          awsProperties.glueCatalogLockExpireMs(), awsProperties.glueCatalogLockWaitMs());\n+      if (!lockAcquired) {\n+        throw new CommitFailedException(\"Timed out after %s ms waiting for lock on %s.%s\",\n+            awsProperties.glueCatalogLockWaitMs(), databaseName, tableName);\n+      }\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new CommitFailedException(e, \"Thread interrupted during commit\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "originalPosition": 46}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3MzkyMzIw", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-557392320", "createdAt": "2020-12-22T22:02:44Z", "commit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMjowMjo0NFrOIKKe0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMjowMjo0NFrOIKKe0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUyODQwMA==", "bodyText": "Why does this throw CommitFailedException when the lock timeout expires and on any exception thrown by the lock manager?\nThat will cause a retry, which will try to acquire the lock again. I don't think that's the right behavior because failure to get the lock has already exceeded the lock retry timeout. To wait longer, just extend the lock timeout.", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547528400", "createdAt": "2020-12-22T22:02:44Z", "author": {"login": "rdblue"}, "path": "aws/src/main/java/org/apache/iceberg/aws/glue/GlueTableOperations.java", "diffHunk": "@@ -117,9 +120,39 @@ protected void doCommit(TableMetadata base, TableMetadata metadata) {\n       if (exceptionThrown) {\n         io().deleteFile(newMetadataLocation);\n       }\n+\n+      unlock();\n+    }\n+  }\n+\n+  private void acquireLock() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "originalPosition": 36}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3MzkzNzM5", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-557393739", "createdAt": "2020-12-22T22:06:06Z", "commit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMjowNjowNlrOIKKjnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMjowNjowNlrOIKKjnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUyOTYyOQ==", "bodyText": "Can you put this in a separate try/finally block?\nIf any of the exceptions above is thrown, then this needs to delete the metadata location. But if that for some reason fails, this also needs to attempt to unlock. Since both unlock and deleteFile must be done even if the other fails, we need to separate them into different finally blocks that are independent.", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547529629", "createdAt": "2020-12-22T22:06:06Z", "author": {"login": "rdblue"}, "path": "aws/src/main/java/org/apache/iceberg/aws/glue/GlueTableOperations.java", "diffHunk": "@@ -117,9 +120,39 @@ protected void doCommit(TableMetadata base, TableMetadata metadata) {\n       if (exceptionThrown) {\n         io().deleteFile(newMetadataLocation);\n       }\n+\n+      unlock();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "originalPosition": 32}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3Mzk0MTYy", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-557394162", "createdAt": "2020-12-22T22:07:09Z", "commit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMjowNzowOVrOIKKlLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMjowNzowOVrOIKKlLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUzMDAyOA==", "bodyText": "This should not swallow the exception, it should re-throw it.\nI also think that there is no need to catch Exception here because there are no checked exceptions thrown by unlock. RuntimeException should be fine.", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547530028", "createdAt": "2020-12-22T22:07:09Z", "author": {"login": "rdblue"}, "path": "aws/src/main/java/org/apache/iceberg/aws/glue/GlueTableOperations.java", "diffHunk": "@@ -117,9 +120,39 @@ protected void doCommit(TableMetadata base, TableMetadata metadata) {\n       if (exceptionThrown) {\n         io().deleteFile(newMetadataLocation);\n       }\n+\n+      unlock();\n+    }\n+  }\n+\n+  private void acquireLock() {\n+    try {\n+      boolean lockAcquired = lockManager.tryLock(lockId(databaseName, tableName),\n+          awsProperties.glueCatalogLockExpireMs(), awsProperties.glueCatalogLockWaitMs());\n+      if (!lockAcquired) {\n+        throw new CommitFailedException(\"Timed out after %s ms waiting for lock on %s.%s\",\n+            awsProperties.glueCatalogLockWaitMs(), databaseName, tableName);\n+      }\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new CommitFailedException(e, \"Thread interrupted during commit\");\n+    } catch (Exception e) {\n+      throw new CommitFailedException(e, \"Unexpected exception when locking %s.%s\", databaseName, tableName);\n     }\n   }\n \n+  private void unlock() {\n+    try {\n+      lockManager.unlock(lockId(databaseName, tableName));\n+    } catch (Exception e) {\n+      LOG.error(\"Unexpected exception when unlocking {}.{}, manual unlock might be needed\", databaseName, tableName, e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "originalPosition": 56}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3Mzk0MjU4", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-557394258", "createdAt": "2020-12-22T22:07:24Z", "commit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMjowNzoyNVrOIKKldg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMjowNzoyNVrOIKKldg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUzMDEwMg==", "bodyText": "Similar to unlock, this doesn't need to catch Exception.", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547530102", "createdAt": "2020-12-22T22:07:25Z", "author": {"login": "rdblue"}, "path": "aws/src/main/java/org/apache/iceberg/aws/glue/GlueTableOperations.java", "diffHunk": "@@ -117,9 +120,39 @@ protected void doCommit(TableMetadata base, TableMetadata metadata) {\n       if (exceptionThrown) {\n         io().deleteFile(newMetadataLocation);\n       }\n+\n+      unlock();\n+    }\n+  }\n+\n+  private void acquireLock() {\n+    try {\n+      boolean lockAcquired = lockManager.tryLock(lockId(databaseName, tableName),\n+          awsProperties.glueCatalogLockExpireMs(), awsProperties.glueCatalogLockWaitMs());\n+      if (!lockAcquired) {\n+        throw new CommitFailedException(\"Timed out after %s ms waiting for lock on %s.%s\",\n+            awsProperties.glueCatalogLockWaitMs(), databaseName, tableName);\n+      }\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new CommitFailedException(e, \"Thread interrupted during commit\");\n+    } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "originalPosition": 47}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3Mzk2NDcw", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-557396470", "createdAt": "2020-12-22T22:11:43Z", "commit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMjoxMTo0M1rOIKKrzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMjoxMTo0M1rOIKKrzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUzMTcyNg==", "bodyText": "Can this use Tasks instead of custom retry logic?", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547531726", "createdAt": "2020-12-22T22:11:43Z", "author": {"login": "rdblue"}, "path": "aws/src/main/java/org/apache/iceberg/aws/glue/LockManager.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+/**\n+ * An interface for locking, used to ensure Glue catalog commit isolation.\n+ */\n+interface LockManager {\n+\n+  /**\n+   * Try to acquire lock\n+   * @param lockId a unique id for the lock\n+   * @param expireMillis max duration to hold the lock in milliseconds\n+   * @return if lock acquisition succeeded or not\n+   */\n+  boolean tryLock(String lockId, long expireMillis);\n+\n+  /**\n+   * Try to acquire a lock in a given period of time\n+   * @param lockId a unique id for the lock\n+   * @param expireMillis max duration to hold the lock in milliseconds\n+   * @param waitMillis max time to try acquire the lock in milliseconds\n+   * @return if lock acquisition succeeded or not\n+   * @throws InterruptedException if sleep is interrupted between two tries to acquire the lock\n+   */\n+  default boolean tryLock(String lockId, long expireMillis, long waitMillis)\n+      throws InterruptedException {\n+    long limit = System.currentTimeMillis() + waitMillis;\n+    boolean succeeded = false;\n+    while (!succeeded && System.currentTimeMillis() < limit) {\n+      succeeded = tryLock(lockId, expireMillis);\n+      if (!succeeded) {\n+        Thread.sleep(50);\n+      }\n+    }\n+    return succeeded;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "originalPosition": 53}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3Mzk3MDA0", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-557397004", "createdAt": "2020-12-22T22:12:59Z", "commit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMjoxMjo1OVrOIKKthg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMjoxMjo1OVrOIKKthg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUzMjE2Ng==", "bodyText": "Is there no way to programmatically run tests?", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547532166", "createdAt": "2020-12-22T22:12:59Z", "author": {"login": "rdblue"}, "path": "aws/src/test/java/org/apache/iceberg/aws/glue/DynamoLockManagerTest.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.net.URI;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.auth.credentials.AwsBasicCredentials;\n+import software.amazon.awssdk.auth.credentials.StaticCredentialsProvider;\n+import software.amazon.awssdk.http.urlconnection.UrlConnectionHttpClient;\n+import software.amazon.awssdk.regions.Region;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.GetItemRequest;\n+\n+public class DynamoLockManagerTest {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManagerTest.class);\n+\n+  private static final String DYNAMO_LOCAL_DOWNLOAD_URL =\n+      \"https://s3.us-west-2.amazonaws.com/dynamodb-local/dynamodb_local_latest.tar.gz\";\n+  private static final String DYNAMO_LOCAL_DIR_NAME = \"/tmp/dynamo-local\";\n+  private static final int DYNAMO_LOCAL_SERVER_PORT = 2333;\n+  private static final String TABLE_NAME = \"dynamoLockTable\";\n+\n+  private Process dynamoLocalProcess;\n+  private DynamoDbClient dynamo;\n+  private AwsProperties properties;\n+  private LockManager lockManager;\n+\n+  @BeforeClass\n+  public static void beforeClass() throws Exception {\n+    Runtime rt = Runtime.getRuntime();\n+    Process pr = rt.exec(String.format(\"curl %s -o %s.tar.gz\", DYNAMO_LOCAL_DOWNLOAD_URL, DYNAMO_LOCAL_DIR_NAME));\n+    pr.waitFor();\n+    pr = rt.exec(String.format(\"mkdir %s\", DYNAMO_LOCAL_DIR_NAME));\n+    pr.waitFor();\n+    pr = rt.exec(String.format(\"tar xvzf %s.tar.gz -C %s\", DYNAMO_LOCAL_DIR_NAME, DYNAMO_LOCAL_DIR_NAME));\n+    pr.waitFor();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "originalPosition": 71}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3Mzk4MDky", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-557398092", "createdAt": "2020-12-22T22:15:44Z", "commit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMjoxNTo0NFrOIKKxrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMjoxNTo0NFrOIKKxrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUzMzIzMA==", "bodyText": "Tests already fail if an unexpected exception is thrown. I would remove the try/catch here.", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547533230", "createdAt": "2020-12-22T22:15:44Z", "author": {"login": "rdblue"}, "path": "aws/src/test/java/org/apache/iceberg/aws/glue/DynamoLockManagerTest.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.net.URI;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.auth.credentials.AwsBasicCredentials;\n+import software.amazon.awssdk.auth.credentials.StaticCredentialsProvider;\n+import software.amazon.awssdk.http.urlconnection.UrlConnectionHttpClient;\n+import software.amazon.awssdk.regions.Region;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.GetItemRequest;\n+\n+public class DynamoLockManagerTest {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManagerTest.class);\n+\n+  private static final String DYNAMO_LOCAL_DOWNLOAD_URL =\n+      \"https://s3.us-west-2.amazonaws.com/dynamodb-local/dynamodb_local_latest.tar.gz\";\n+  private static final String DYNAMO_LOCAL_DIR_NAME = \"/tmp/dynamo-local\";\n+  private static final int DYNAMO_LOCAL_SERVER_PORT = 2333;\n+  private static final String TABLE_NAME = \"dynamoLockTable\";\n+\n+  private Process dynamoLocalProcess;\n+  private DynamoDbClient dynamo;\n+  private AwsProperties properties;\n+  private LockManager lockManager;\n+\n+  @BeforeClass\n+  public static void beforeClass() throws Exception {\n+    Runtime rt = Runtime.getRuntime();\n+    Process pr = rt.exec(String.format(\"curl %s -o %s.tar.gz\", DYNAMO_LOCAL_DOWNLOAD_URL, DYNAMO_LOCAL_DIR_NAME));\n+    pr.waitFor();\n+    pr = rt.exec(String.format(\"mkdir %s\", DYNAMO_LOCAL_DIR_NAME));\n+    pr.waitFor();\n+    pr = rt.exec(String.format(\"tar xvzf %s.tar.gz -C %s\", DYNAMO_LOCAL_DIR_NAME, DYNAMO_LOCAL_DIR_NAME));\n+    pr.waitFor();\n+  }\n+\n+  @Before\n+  public void before() throws Exception {\n+    Runtime rt = Runtime.getRuntime();\n+    dynamoLocalProcess = rt.exec(String.format(\"java -Djava.library.path=%s/DynamoDBLocal_lib -jar \" +\n+            \"%s/DynamoDBLocal.jar -inMemory -port %s\",\n+        DYNAMO_LOCAL_DIR_NAME, DYNAMO_LOCAL_DIR_NAME, DYNAMO_LOCAL_SERVER_PORT));\n+    Thread.sleep(1000); // wait for start\n+    dynamo = DynamoDbClient.builder()\n+        .endpointOverride(URI.create(String.format(\"http://0.0.0.0:%d/\", DYNAMO_LOCAL_SERVER_PORT)))\n+        .region(Region.US_EAST_1) // dummy region\n+        .credentialsProvider(StaticCredentialsProvider.create(\n+            AwsBasicCredentials.create(\"key\", \"secret\"))) // dummy credential\n+        .httpClient(UrlConnectionHttpClient.create())\n+        .build();\n+    properties = new AwsProperties();\n+    properties.setGlueCatalogLockEnabled(true);\n+    properties.setGlueCatalogLockTable(TABLE_NAME);\n+    lockManager = new DynamoLockManager(dynamo, properties);\n+  }\n+\n+  @After\n+  public void after() throws Exception {\n+    dynamo.deleteTable(DeleteTableRequest.builder()\n+        .tableName(TABLE_NAME)\n+        .build());\n+    dynamoLocalProcess.destroy();\n+    dynamoLocalProcess.waitFor();\n+  }\n+\n+  @AfterClass\n+  public static void afterClass() throws Exception {\n+    Runtime.getRuntime().exec(String.format(\"rm %s.tar.gz\", DYNAMO_LOCAL_DIR_NAME)).waitFor();\n+    Runtime.getRuntime().exec(String.format(\"rm -rf %s\", DYNAMO_LOCAL_DIR_NAME)).waitFor();\n+  }\n+\n+  @Test\n+  public void testTableCreation() {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(TABLE_NAME)\n+          .build());\n+    } catch (Exception e) {\n+      LOG.error(\"encountered failure\", e);\n+      Assert.fail(\"Should not throw exception when describing DynamoDB lock table\");\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "originalPosition": 118}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3Mzk4ODg1", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-557398885", "createdAt": "2020-12-22T22:17:49Z", "commit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMjoxNzo0OVrOIKK0Sg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMjoxNzo0OVrOIKK0Sg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUzMzg5OA==", "bodyText": "If DynamoLockManager.tableExists is package-private, then you'd be able to call that here.", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547533898", "createdAt": "2020-12-22T22:17:49Z", "author": {"login": "rdblue"}, "path": "aws/src/test/java/org/apache/iceberg/aws/glue/DynamoLockManagerTest.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.net.URI;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.auth.credentials.AwsBasicCredentials;\n+import software.amazon.awssdk.auth.credentials.StaticCredentialsProvider;\n+import software.amazon.awssdk.http.urlconnection.UrlConnectionHttpClient;\n+import software.amazon.awssdk.regions.Region;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.GetItemRequest;\n+\n+public class DynamoLockManagerTest {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManagerTest.class);\n+\n+  private static final String DYNAMO_LOCAL_DOWNLOAD_URL =\n+      \"https://s3.us-west-2.amazonaws.com/dynamodb-local/dynamodb_local_latest.tar.gz\";\n+  private static final String DYNAMO_LOCAL_DIR_NAME = \"/tmp/dynamo-local\";\n+  private static final int DYNAMO_LOCAL_SERVER_PORT = 2333;\n+  private static final String TABLE_NAME = \"dynamoLockTable\";\n+\n+  private Process dynamoLocalProcess;\n+  private DynamoDbClient dynamo;\n+  private AwsProperties properties;\n+  private LockManager lockManager;\n+\n+  @BeforeClass\n+  public static void beforeClass() throws Exception {\n+    Runtime rt = Runtime.getRuntime();\n+    Process pr = rt.exec(String.format(\"curl %s -o %s.tar.gz\", DYNAMO_LOCAL_DOWNLOAD_URL, DYNAMO_LOCAL_DIR_NAME));\n+    pr.waitFor();\n+    pr = rt.exec(String.format(\"mkdir %s\", DYNAMO_LOCAL_DIR_NAME));\n+    pr.waitFor();\n+    pr = rt.exec(String.format(\"tar xvzf %s.tar.gz -C %s\", DYNAMO_LOCAL_DIR_NAME, DYNAMO_LOCAL_DIR_NAME));\n+    pr.waitFor();\n+  }\n+\n+  @Before\n+  public void before() throws Exception {\n+    Runtime rt = Runtime.getRuntime();\n+    dynamoLocalProcess = rt.exec(String.format(\"java -Djava.library.path=%s/DynamoDBLocal_lib -jar \" +\n+            \"%s/DynamoDBLocal.jar -inMemory -port %s\",\n+        DYNAMO_LOCAL_DIR_NAME, DYNAMO_LOCAL_DIR_NAME, DYNAMO_LOCAL_SERVER_PORT));\n+    Thread.sleep(1000); // wait for start\n+    dynamo = DynamoDbClient.builder()\n+        .endpointOverride(URI.create(String.format(\"http://0.0.0.0:%d/\", DYNAMO_LOCAL_SERVER_PORT)))\n+        .region(Region.US_EAST_1) // dummy region\n+        .credentialsProvider(StaticCredentialsProvider.create(\n+            AwsBasicCredentials.create(\"key\", \"secret\"))) // dummy credential\n+        .httpClient(UrlConnectionHttpClient.create())\n+        .build();\n+    properties = new AwsProperties();\n+    properties.setGlueCatalogLockEnabled(true);\n+    properties.setGlueCatalogLockTable(TABLE_NAME);\n+    lockManager = new DynamoLockManager(dynamo, properties);\n+  }\n+\n+  @After\n+  public void after() throws Exception {\n+    dynamo.deleteTable(DeleteTableRequest.builder()\n+        .tableName(TABLE_NAME)\n+        .build());\n+    dynamoLocalProcess.destroy();\n+    dynamoLocalProcess.waitFor();\n+  }\n+\n+  @AfterClass\n+  public static void afterClass() throws Exception {\n+    Runtime.getRuntime().exec(String.format(\"rm %s.tar.gz\", DYNAMO_LOCAL_DIR_NAME)).waitFor();\n+    Runtime.getRuntime().exec(String.format(\"rm -rf %s\", DYNAMO_LOCAL_DIR_NAME)).waitFor();\n+  }\n+\n+  @Test\n+  public void testTableCreation() {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(TABLE_NAME)\n+          .build());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "originalPosition": 114}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3NDAyODgw", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-557402880", "createdAt": "2020-12-22T22:28:03Z", "commit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMjoyODowM1rOIKLCFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMjoyODowM1rOIKLCFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUzNzQyOA==", "bodyText": "Assertions like this should have context because if this fails, it just produces a generic error message like \"expected true\". It is better to explain what true means:\nAssert.assertTrue(\"Should successfully acquire the lock\", succeed);", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547537428", "createdAt": "2020-12-22T22:28:03Z", "author": {"login": "rdblue"}, "path": "aws/src/test/java/org/apache/iceberg/aws/glue/DynamoLockManagerTest.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.net.URI;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.auth.credentials.AwsBasicCredentials;\n+import software.amazon.awssdk.auth.credentials.StaticCredentialsProvider;\n+import software.amazon.awssdk.http.urlconnection.UrlConnectionHttpClient;\n+import software.amazon.awssdk.regions.Region;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.GetItemRequest;\n+\n+public class DynamoLockManagerTest {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManagerTest.class);\n+\n+  private static final String DYNAMO_LOCAL_DOWNLOAD_URL =\n+      \"https://s3.us-west-2.amazonaws.com/dynamodb-local/dynamodb_local_latest.tar.gz\";\n+  private static final String DYNAMO_LOCAL_DIR_NAME = \"/tmp/dynamo-local\";\n+  private static final int DYNAMO_LOCAL_SERVER_PORT = 2333;\n+  private static final String TABLE_NAME = \"dynamoLockTable\";\n+\n+  private Process dynamoLocalProcess;\n+  private DynamoDbClient dynamo;\n+  private AwsProperties properties;\n+  private LockManager lockManager;\n+\n+  @BeforeClass\n+  public static void beforeClass() throws Exception {\n+    Runtime rt = Runtime.getRuntime();\n+    Process pr = rt.exec(String.format(\"curl %s -o %s.tar.gz\", DYNAMO_LOCAL_DOWNLOAD_URL, DYNAMO_LOCAL_DIR_NAME));\n+    pr.waitFor();\n+    pr = rt.exec(String.format(\"mkdir %s\", DYNAMO_LOCAL_DIR_NAME));\n+    pr.waitFor();\n+    pr = rt.exec(String.format(\"tar xvzf %s.tar.gz -C %s\", DYNAMO_LOCAL_DIR_NAME, DYNAMO_LOCAL_DIR_NAME));\n+    pr.waitFor();\n+  }\n+\n+  @Before\n+  public void before() throws Exception {\n+    Runtime rt = Runtime.getRuntime();\n+    dynamoLocalProcess = rt.exec(String.format(\"java -Djava.library.path=%s/DynamoDBLocal_lib -jar \" +\n+            \"%s/DynamoDBLocal.jar -inMemory -port %s\",\n+        DYNAMO_LOCAL_DIR_NAME, DYNAMO_LOCAL_DIR_NAME, DYNAMO_LOCAL_SERVER_PORT));\n+    Thread.sleep(1000); // wait for start\n+    dynamo = DynamoDbClient.builder()\n+        .endpointOverride(URI.create(String.format(\"http://0.0.0.0:%d/\", DYNAMO_LOCAL_SERVER_PORT)))\n+        .region(Region.US_EAST_1) // dummy region\n+        .credentialsProvider(StaticCredentialsProvider.create(\n+            AwsBasicCredentials.create(\"key\", \"secret\"))) // dummy credential\n+        .httpClient(UrlConnectionHttpClient.create())\n+        .build();\n+    properties = new AwsProperties();\n+    properties.setGlueCatalogLockEnabled(true);\n+    properties.setGlueCatalogLockTable(TABLE_NAME);\n+    lockManager = new DynamoLockManager(dynamo, properties);\n+  }\n+\n+  @After\n+  public void after() throws Exception {\n+    dynamo.deleteTable(DeleteTableRequest.builder()\n+        .tableName(TABLE_NAME)\n+        .build());\n+    dynamoLocalProcess.destroy();\n+    dynamoLocalProcess.waitFor();\n+  }\n+\n+  @AfterClass\n+  public static void afterClass() throws Exception {\n+    Runtime.getRuntime().exec(String.format(\"rm %s.tar.gz\", DYNAMO_LOCAL_DIR_NAME)).waitFor();\n+    Runtime.getRuntime().exec(String.format(\"rm -rf %s\", DYNAMO_LOCAL_DIR_NAME)).waitFor();\n+  }\n+\n+  @Test\n+  public void testTableCreation() {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(TABLE_NAME)\n+          .build());\n+    } catch (Exception e) {\n+      LOG.error(\"encountered failure\", e);\n+      Assert.fail(\"Should not throw exception when describing DynamoDB lock table\");\n+    }\n+\n+  }\n+\n+  @Test\n+  public void testLock_singleProcess() {\n+    boolean succeed = lockManager.tryLock(\"database.table\", AwsProperties.GLUE_CATALOG_LOCK_EXPIRE_MS_DEFAULT);\n+    Assert.assertTrue(succeed);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "originalPosition": 125}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3NDAzMjQz", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-557403243", "createdAt": "2020-12-22T22:29:02Z", "commit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMjoyOTowMlrOIKLDdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMjoyOTowMlrOIKLDdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUzNzc4Mw==", "bodyText": "If the lock stored the expiration interval, then this could assert that a result was received and that the interval is the one expected.", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547537783", "createdAt": "2020-12-22T22:29:02Z", "author": {"login": "rdblue"}, "path": "aws/src/test/java/org/apache/iceberg/aws/glue/DynamoLockManagerTest.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.net.URI;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.auth.credentials.AwsBasicCredentials;\n+import software.amazon.awssdk.auth.credentials.StaticCredentialsProvider;\n+import software.amazon.awssdk.http.urlconnection.UrlConnectionHttpClient;\n+import software.amazon.awssdk.regions.Region;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.GetItemRequest;\n+\n+public class DynamoLockManagerTest {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManagerTest.class);\n+\n+  private static final String DYNAMO_LOCAL_DOWNLOAD_URL =\n+      \"https://s3.us-west-2.amazonaws.com/dynamodb-local/dynamodb_local_latest.tar.gz\";\n+  private static final String DYNAMO_LOCAL_DIR_NAME = \"/tmp/dynamo-local\";\n+  private static final int DYNAMO_LOCAL_SERVER_PORT = 2333;\n+  private static final String TABLE_NAME = \"dynamoLockTable\";\n+\n+  private Process dynamoLocalProcess;\n+  private DynamoDbClient dynamo;\n+  private AwsProperties properties;\n+  private LockManager lockManager;\n+\n+  @BeforeClass\n+  public static void beforeClass() throws Exception {\n+    Runtime rt = Runtime.getRuntime();\n+    Process pr = rt.exec(String.format(\"curl %s -o %s.tar.gz\", DYNAMO_LOCAL_DOWNLOAD_URL, DYNAMO_LOCAL_DIR_NAME));\n+    pr.waitFor();\n+    pr = rt.exec(String.format(\"mkdir %s\", DYNAMO_LOCAL_DIR_NAME));\n+    pr.waitFor();\n+    pr = rt.exec(String.format(\"tar xvzf %s.tar.gz -C %s\", DYNAMO_LOCAL_DIR_NAME, DYNAMO_LOCAL_DIR_NAME));\n+    pr.waitFor();\n+  }\n+\n+  @Before\n+  public void before() throws Exception {\n+    Runtime rt = Runtime.getRuntime();\n+    dynamoLocalProcess = rt.exec(String.format(\"java -Djava.library.path=%s/DynamoDBLocal_lib -jar \" +\n+            \"%s/DynamoDBLocal.jar -inMemory -port %s\",\n+        DYNAMO_LOCAL_DIR_NAME, DYNAMO_LOCAL_DIR_NAME, DYNAMO_LOCAL_SERVER_PORT));\n+    Thread.sleep(1000); // wait for start\n+    dynamo = DynamoDbClient.builder()\n+        .endpointOverride(URI.create(String.format(\"http://0.0.0.0:%d/\", DYNAMO_LOCAL_SERVER_PORT)))\n+        .region(Region.US_EAST_1) // dummy region\n+        .credentialsProvider(StaticCredentialsProvider.create(\n+            AwsBasicCredentials.create(\"key\", \"secret\"))) // dummy credential\n+        .httpClient(UrlConnectionHttpClient.create())\n+        .build();\n+    properties = new AwsProperties();\n+    properties.setGlueCatalogLockEnabled(true);\n+    properties.setGlueCatalogLockTable(TABLE_NAME);\n+    lockManager = new DynamoLockManager(dynamo, properties);\n+  }\n+\n+  @After\n+  public void after() throws Exception {\n+    dynamo.deleteTable(DeleteTableRequest.builder()\n+        .tableName(TABLE_NAME)\n+        .build());\n+    dynamoLocalProcess.destroy();\n+    dynamoLocalProcess.waitFor();\n+  }\n+\n+  @AfterClass\n+  public static void afterClass() throws Exception {\n+    Runtime.getRuntime().exec(String.format(\"rm %s.tar.gz\", DYNAMO_LOCAL_DIR_NAME)).waitFor();\n+    Runtime.getRuntime().exec(String.format(\"rm -rf %s\", DYNAMO_LOCAL_DIR_NAME)).waitFor();\n+  }\n+\n+  @Test\n+  public void testTableCreation() {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(TABLE_NAME)\n+          .build());\n+    } catch (Exception e) {\n+      LOG.error(\"encountered failure\", e);\n+      Assert.fail(\"Should not throw exception when describing DynamoDB lock table\");\n+    }\n+\n+  }\n+\n+  @Test\n+  public void testLock_singleProcess() {\n+    boolean succeed = lockManager.tryLock(\"database.table\", AwsProperties.GLUE_CATALOG_LOCK_EXPIRE_MS_DEFAULT);\n+    Assert.assertTrue(succeed);\n+    Map<String, AttributeValue> key = Maps.newHashMap();\n+    key.put(\"lockId\", AttributeValue.builder().s(\"database.table\").build());\n+    try {\n+      dynamo.getItem(GetItemRequest.builder()\n+          .tableName(TABLE_NAME)\n+          .key(key)\n+          .build());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "originalPosition": 132}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3NDAzOTc0", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-557403974", "createdAt": "2020-12-22T22:31:00Z", "commit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMjozMTowMFrOIKLF5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMjozMTowMFrOIKLF5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUzODQwNg==", "bodyText": "I think what's happening here is that the attempts are deciding that others are expired. A comment would be helpful here.", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547538406", "createdAt": "2020-12-22T22:31:00Z", "author": {"login": "rdblue"}, "path": "aws/src/test/java/org/apache/iceberg/aws/glue/DynamoLockManagerTest.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.net.URI;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.auth.credentials.AwsBasicCredentials;\n+import software.amazon.awssdk.auth.credentials.StaticCredentialsProvider;\n+import software.amazon.awssdk.http.urlconnection.UrlConnectionHttpClient;\n+import software.amazon.awssdk.regions.Region;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.GetItemRequest;\n+\n+public class DynamoLockManagerTest {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManagerTest.class);\n+\n+  private static final String DYNAMO_LOCAL_DOWNLOAD_URL =\n+      \"https://s3.us-west-2.amazonaws.com/dynamodb-local/dynamodb_local_latest.tar.gz\";\n+  private static final String DYNAMO_LOCAL_DIR_NAME = \"/tmp/dynamo-local\";\n+  private static final int DYNAMO_LOCAL_SERVER_PORT = 2333;\n+  private static final String TABLE_NAME = \"dynamoLockTable\";\n+\n+  private Process dynamoLocalProcess;\n+  private DynamoDbClient dynamo;\n+  private AwsProperties properties;\n+  private LockManager lockManager;\n+\n+  @BeforeClass\n+  public static void beforeClass() throws Exception {\n+    Runtime rt = Runtime.getRuntime();\n+    Process pr = rt.exec(String.format(\"curl %s -o %s.tar.gz\", DYNAMO_LOCAL_DOWNLOAD_URL, DYNAMO_LOCAL_DIR_NAME));\n+    pr.waitFor();\n+    pr = rt.exec(String.format(\"mkdir %s\", DYNAMO_LOCAL_DIR_NAME));\n+    pr.waitFor();\n+    pr = rt.exec(String.format(\"tar xvzf %s.tar.gz -C %s\", DYNAMO_LOCAL_DIR_NAME, DYNAMO_LOCAL_DIR_NAME));\n+    pr.waitFor();\n+  }\n+\n+  @Before\n+  public void before() throws Exception {\n+    Runtime rt = Runtime.getRuntime();\n+    dynamoLocalProcess = rt.exec(String.format(\"java -Djava.library.path=%s/DynamoDBLocal_lib -jar \" +\n+            \"%s/DynamoDBLocal.jar -inMemory -port %s\",\n+        DYNAMO_LOCAL_DIR_NAME, DYNAMO_LOCAL_DIR_NAME, DYNAMO_LOCAL_SERVER_PORT));\n+    Thread.sleep(1000); // wait for start\n+    dynamo = DynamoDbClient.builder()\n+        .endpointOverride(URI.create(String.format(\"http://0.0.0.0:%d/\", DYNAMO_LOCAL_SERVER_PORT)))\n+        .region(Region.US_EAST_1) // dummy region\n+        .credentialsProvider(StaticCredentialsProvider.create(\n+            AwsBasicCredentials.create(\"key\", \"secret\"))) // dummy credential\n+        .httpClient(UrlConnectionHttpClient.create())\n+        .build();\n+    properties = new AwsProperties();\n+    properties.setGlueCatalogLockEnabled(true);\n+    properties.setGlueCatalogLockTable(TABLE_NAME);\n+    lockManager = new DynamoLockManager(dynamo, properties);\n+  }\n+\n+  @After\n+  public void after() throws Exception {\n+    dynamo.deleteTable(DeleteTableRequest.builder()\n+        .tableName(TABLE_NAME)\n+        .build());\n+    dynamoLocalProcess.destroy();\n+    dynamoLocalProcess.waitFor();\n+  }\n+\n+  @AfterClass\n+  public static void afterClass() throws Exception {\n+    Runtime.getRuntime().exec(String.format(\"rm %s.tar.gz\", DYNAMO_LOCAL_DIR_NAME)).waitFor();\n+    Runtime.getRuntime().exec(String.format(\"rm -rf %s\", DYNAMO_LOCAL_DIR_NAME)).waitFor();\n+  }\n+\n+  @Test\n+  public void testTableCreation() {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(TABLE_NAME)\n+          .build());\n+    } catch (Exception e) {\n+      LOG.error(\"encountered failure\", e);\n+      Assert.fail(\"Should not throw exception when describing DynamoDB lock table\");\n+    }\n+\n+  }\n+\n+  @Test\n+  public void testLock_singleProcess() {\n+    boolean succeed = lockManager.tryLock(\"database.table\", AwsProperties.GLUE_CATALOG_LOCK_EXPIRE_MS_DEFAULT);\n+    Assert.assertTrue(succeed);\n+    Map<String, AttributeValue> key = Maps.newHashMap();\n+    key.put(\"lockId\", AttributeValue.builder().s(\"database.table\").build());\n+    try {\n+      dynamo.getItem(GetItemRequest.builder()\n+          .tableName(TABLE_NAME)\n+          .key(key)\n+          .build());\n+    } catch (Exception e) {\n+      LOG.error(\"encountered failure\", e);\n+      Assert.fail(\"Should not throw exception when getting lock after insert\");\n+    }\n+  }\n+\n+  @Test\n+  public void testLock_multiProcess() {\n+    List<Boolean> results = IntStream.range(0, 100).parallel()\n+        .mapToObj(i -> lockManager.tryLock(\"database.table\", AwsProperties.GLUE_CATALOG_LOCK_EXPIRE_MS_DEFAULT))\n+        .collect(Collectors.toList());\n+    Assert.assertEquals(1, results.stream().filter(s -> s).count());\n+  }\n+\n+  @Test\n+  public void testWaitLock_singleProcess() throws Exception {\n+    boolean succeed = lockManager.tryLock(\"database.table\",\n+        AwsProperties.GLUE_CATALOG_LOCK_EXPIRE_MS_DEFAULT,\n+        AwsProperties.GLUE_CATALOG_LOCK_WAIT_MS_DEFAULT);\n+    Assert.assertTrue(succeed);\n+    Map<String, AttributeValue> key = Maps.newHashMap();\n+    key.put(\"lockId\", AttributeValue.builder().s(\"database.table\").build());\n+    try {\n+      dynamo.getItem(GetItemRequest.builder()\n+          .tableName(TABLE_NAME)\n+          .key(key)\n+          .build());\n+    } catch (Exception e) {\n+      LOG.error(\"encountered failure\", e);\n+      Assert.fail(\"Should not throw exception when getting lock after insert\");\n+    }\n+  }\n+\n+  @Test\n+  public void testWaitLock_multiProcess_allSucceed() {\n+    List<Boolean> results = IntStream.range(0, 100).parallel()\n+        .mapToObj(i -> {\n+          try {\n+            return lockManager.tryLock(\"database.table\", 10, 100000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "originalPosition": 171}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3NDA0MzA4", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-557404308", "createdAt": "2020-12-22T22:31:55Z", "commit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMjozMTo1NVrOIKLHAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMjozMTo1NVrOIKLHAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUzODY4OA==", "bodyText": "It seems to me that this should succeed because the lock manager holds the lock. I guess it doesn't need to be re-entrant.", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547538688", "createdAt": "2020-12-22T22:31:55Z", "author": {"login": "rdblue"}, "path": "aws/src/test/java/org/apache/iceberg/aws/glue/DynamoLockManagerTest.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.net.URI;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.auth.credentials.AwsBasicCredentials;\n+import software.amazon.awssdk.auth.credentials.StaticCredentialsProvider;\n+import software.amazon.awssdk.http.urlconnection.UrlConnectionHttpClient;\n+import software.amazon.awssdk.regions.Region;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.GetItemRequest;\n+\n+public class DynamoLockManagerTest {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManagerTest.class);\n+\n+  private static final String DYNAMO_LOCAL_DOWNLOAD_URL =\n+      \"https://s3.us-west-2.amazonaws.com/dynamodb-local/dynamodb_local_latest.tar.gz\";\n+  private static final String DYNAMO_LOCAL_DIR_NAME = \"/tmp/dynamo-local\";\n+  private static final int DYNAMO_LOCAL_SERVER_PORT = 2333;\n+  private static final String TABLE_NAME = \"dynamoLockTable\";\n+\n+  private Process dynamoLocalProcess;\n+  private DynamoDbClient dynamo;\n+  private AwsProperties properties;\n+  private LockManager lockManager;\n+\n+  @BeforeClass\n+  public static void beforeClass() throws Exception {\n+    Runtime rt = Runtime.getRuntime();\n+    Process pr = rt.exec(String.format(\"curl %s -o %s.tar.gz\", DYNAMO_LOCAL_DOWNLOAD_URL, DYNAMO_LOCAL_DIR_NAME));\n+    pr.waitFor();\n+    pr = rt.exec(String.format(\"mkdir %s\", DYNAMO_LOCAL_DIR_NAME));\n+    pr.waitFor();\n+    pr = rt.exec(String.format(\"tar xvzf %s.tar.gz -C %s\", DYNAMO_LOCAL_DIR_NAME, DYNAMO_LOCAL_DIR_NAME));\n+    pr.waitFor();\n+  }\n+\n+  @Before\n+  public void before() throws Exception {\n+    Runtime rt = Runtime.getRuntime();\n+    dynamoLocalProcess = rt.exec(String.format(\"java -Djava.library.path=%s/DynamoDBLocal_lib -jar \" +\n+            \"%s/DynamoDBLocal.jar -inMemory -port %s\",\n+        DYNAMO_LOCAL_DIR_NAME, DYNAMO_LOCAL_DIR_NAME, DYNAMO_LOCAL_SERVER_PORT));\n+    Thread.sleep(1000); // wait for start\n+    dynamo = DynamoDbClient.builder()\n+        .endpointOverride(URI.create(String.format(\"http://0.0.0.0:%d/\", DYNAMO_LOCAL_SERVER_PORT)))\n+        .region(Region.US_EAST_1) // dummy region\n+        .credentialsProvider(StaticCredentialsProvider.create(\n+            AwsBasicCredentials.create(\"key\", \"secret\"))) // dummy credential\n+        .httpClient(UrlConnectionHttpClient.create())\n+        .build();\n+    properties = new AwsProperties();\n+    properties.setGlueCatalogLockEnabled(true);\n+    properties.setGlueCatalogLockTable(TABLE_NAME);\n+    lockManager = new DynamoLockManager(dynamo, properties);\n+  }\n+\n+  @After\n+  public void after() throws Exception {\n+    dynamo.deleteTable(DeleteTableRequest.builder()\n+        .tableName(TABLE_NAME)\n+        .build());\n+    dynamoLocalProcess.destroy();\n+    dynamoLocalProcess.waitFor();\n+  }\n+\n+  @AfterClass\n+  public static void afterClass() throws Exception {\n+    Runtime.getRuntime().exec(String.format(\"rm %s.tar.gz\", DYNAMO_LOCAL_DIR_NAME)).waitFor();\n+    Runtime.getRuntime().exec(String.format(\"rm -rf %s\", DYNAMO_LOCAL_DIR_NAME)).waitFor();\n+  }\n+\n+  @Test\n+  public void testTableCreation() {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(TABLE_NAME)\n+          .build());\n+    } catch (Exception e) {\n+      LOG.error(\"encountered failure\", e);\n+      Assert.fail(\"Should not throw exception when describing DynamoDB lock table\");\n+    }\n+\n+  }\n+\n+  @Test\n+  public void testLock_singleProcess() {\n+    boolean succeed = lockManager.tryLock(\"database.table\", AwsProperties.GLUE_CATALOG_LOCK_EXPIRE_MS_DEFAULT);\n+    Assert.assertTrue(succeed);\n+    Map<String, AttributeValue> key = Maps.newHashMap();\n+    key.put(\"lockId\", AttributeValue.builder().s(\"database.table\").build());\n+    try {\n+      dynamo.getItem(GetItemRequest.builder()\n+          .tableName(TABLE_NAME)\n+          .key(key)\n+          .build());\n+    } catch (Exception e) {\n+      LOG.error(\"encountered failure\", e);\n+      Assert.fail(\"Should not throw exception when getting lock after insert\");\n+    }\n+  }\n+\n+  @Test\n+  public void testLock_multiProcess() {\n+    List<Boolean> results = IntStream.range(0, 100).parallel()\n+        .mapToObj(i -> lockManager.tryLock(\"database.table\", AwsProperties.GLUE_CATALOG_LOCK_EXPIRE_MS_DEFAULT))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "originalPosition": 142}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3NDA0NTYz", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-557404563", "createdAt": "2020-12-22T22:32:37Z", "commit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMjozMjozN1rOIKLH0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMjozMjozN1rOIKLH0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUzODg5OA==", "bodyText": "I think a better test would be to create two lock managers and use tryLock / unlock to show that the other will time out waiting to acquire the lock.\nThat's what we do in other cases, like when we are simulating two concurrent writes. We create two writers, start one and then commit the other, and finally verify that the original had to retry.", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547538898", "createdAt": "2020-12-22T22:32:37Z", "author": {"login": "rdblue"}, "path": "aws/src/test/java/org/apache/iceberg/aws/glue/DynamoLockManagerTest.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.net.URI;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.auth.credentials.AwsBasicCredentials;\n+import software.amazon.awssdk.auth.credentials.StaticCredentialsProvider;\n+import software.amazon.awssdk.http.urlconnection.UrlConnectionHttpClient;\n+import software.amazon.awssdk.regions.Region;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.GetItemRequest;\n+\n+public class DynamoLockManagerTest {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManagerTest.class);\n+\n+  private static final String DYNAMO_LOCAL_DOWNLOAD_URL =\n+      \"https://s3.us-west-2.amazonaws.com/dynamodb-local/dynamodb_local_latest.tar.gz\";\n+  private static final String DYNAMO_LOCAL_DIR_NAME = \"/tmp/dynamo-local\";\n+  private static final int DYNAMO_LOCAL_SERVER_PORT = 2333;\n+  private static final String TABLE_NAME = \"dynamoLockTable\";\n+\n+  private Process dynamoLocalProcess;\n+  private DynamoDbClient dynamo;\n+  private AwsProperties properties;\n+  private LockManager lockManager;\n+\n+  @BeforeClass\n+  public static void beforeClass() throws Exception {\n+    Runtime rt = Runtime.getRuntime();\n+    Process pr = rt.exec(String.format(\"curl %s -o %s.tar.gz\", DYNAMO_LOCAL_DOWNLOAD_URL, DYNAMO_LOCAL_DIR_NAME));\n+    pr.waitFor();\n+    pr = rt.exec(String.format(\"mkdir %s\", DYNAMO_LOCAL_DIR_NAME));\n+    pr.waitFor();\n+    pr = rt.exec(String.format(\"tar xvzf %s.tar.gz -C %s\", DYNAMO_LOCAL_DIR_NAME, DYNAMO_LOCAL_DIR_NAME));\n+    pr.waitFor();\n+  }\n+\n+  @Before\n+  public void before() throws Exception {\n+    Runtime rt = Runtime.getRuntime();\n+    dynamoLocalProcess = rt.exec(String.format(\"java -Djava.library.path=%s/DynamoDBLocal_lib -jar \" +\n+            \"%s/DynamoDBLocal.jar -inMemory -port %s\",\n+        DYNAMO_LOCAL_DIR_NAME, DYNAMO_LOCAL_DIR_NAME, DYNAMO_LOCAL_SERVER_PORT));\n+    Thread.sleep(1000); // wait for start\n+    dynamo = DynamoDbClient.builder()\n+        .endpointOverride(URI.create(String.format(\"http://0.0.0.0:%d/\", DYNAMO_LOCAL_SERVER_PORT)))\n+        .region(Region.US_EAST_1) // dummy region\n+        .credentialsProvider(StaticCredentialsProvider.create(\n+            AwsBasicCredentials.create(\"key\", \"secret\"))) // dummy credential\n+        .httpClient(UrlConnectionHttpClient.create())\n+        .build();\n+    properties = new AwsProperties();\n+    properties.setGlueCatalogLockEnabled(true);\n+    properties.setGlueCatalogLockTable(TABLE_NAME);\n+    lockManager = new DynamoLockManager(dynamo, properties);\n+  }\n+\n+  @After\n+  public void after() throws Exception {\n+    dynamo.deleteTable(DeleteTableRequest.builder()\n+        .tableName(TABLE_NAME)\n+        .build());\n+    dynamoLocalProcess.destroy();\n+    dynamoLocalProcess.waitFor();\n+  }\n+\n+  @AfterClass\n+  public static void afterClass() throws Exception {\n+    Runtime.getRuntime().exec(String.format(\"rm %s.tar.gz\", DYNAMO_LOCAL_DIR_NAME)).waitFor();\n+    Runtime.getRuntime().exec(String.format(\"rm -rf %s\", DYNAMO_LOCAL_DIR_NAME)).waitFor();\n+  }\n+\n+  @Test\n+  public void testTableCreation() {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(TABLE_NAME)\n+          .build());\n+    } catch (Exception e) {\n+      LOG.error(\"encountered failure\", e);\n+      Assert.fail(\"Should not throw exception when describing DynamoDB lock table\");\n+    }\n+\n+  }\n+\n+  @Test\n+  public void testLock_singleProcess() {\n+    boolean succeed = lockManager.tryLock(\"database.table\", AwsProperties.GLUE_CATALOG_LOCK_EXPIRE_MS_DEFAULT);\n+    Assert.assertTrue(succeed);\n+    Map<String, AttributeValue> key = Maps.newHashMap();\n+    key.put(\"lockId\", AttributeValue.builder().s(\"database.table\").build());\n+    try {\n+      dynamo.getItem(GetItemRequest.builder()\n+          .tableName(TABLE_NAME)\n+          .key(key)\n+          .build());\n+    } catch (Exception e) {\n+      LOG.error(\"encountered failure\", e);\n+      Assert.fail(\"Should not throw exception when getting lock after insert\");\n+    }\n+  }\n+\n+  @Test\n+  public void testLock_multiProcess() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "originalPosition": 140}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3NDA1MzMy", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-557405332", "createdAt": "2020-12-22T22:34:33Z", "commit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMjozNDozNFrOIKLKfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMjozNDozNFrOIKLKfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUzOTU4Mg==", "bodyText": "Nit: unnecessary whitespace change.", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547539582", "createdAt": "2020-12-22T22:34:34Z", "author": {"login": "rdblue"}, "path": "aws/src/test/java/org/apache/iceberg/aws/glue/GlueCatalogTest.java", "diffHunk": "@@ -80,14 +80,16 @@ public void constructor_emptyWarehousePath() {\n         \"Cannot initialize GlueCatalog because warehousePath must not be null\",\n         () -> {\n             GlueCatalog catalog = new GlueCatalog();\n-            catalog.initialize(CATALOG_NAME, null, new AwsProperties(), glue, null);\n+            catalog.initialize(CATALOG_NAME, null, new AwsProperties(), glue, new DefaultLockManager(), null);\n         });\n   }\n \n   @Test\n   public void constructor_warehousePathWithEndSlash() {\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "originalPosition": 20}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3NDA2MDA1", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-557406005", "createdAt": "2020-12-22T22:36:12Z", "commit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMjozNjoxMlrOIKLMzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMjozNjoxMlrOIKLMzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU0MDE3NQ==", "bodyText": "You might want to just copy testConcurrentFastAppends. We know that does a good job of catching collisions. https://github.com/apache/iceberg/blob/master/hive-metastore/src/test/java/org/apache/iceberg/hive/TestHiveTableConcurrency.java#L45-L79", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547540175", "createdAt": "2020-12-22T22:36:12Z", "author": {"login": "rdblue"}, "path": "aws/src/integration/java/org/apache/iceberg/aws/glue/GlueCatalogLockTest.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.iceberg.AppendFiles;\n+import org.apache.iceberg.DataFile;\n+import org.apache.iceberg.DataFiles;\n+import org.apache.iceberg.PendingUpdate;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.aws.s3.S3FileIO;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteTableRequest;\n+\n+public class GlueCatalogLockTest extends GlueTestBase {\n+\n+  private static String lockTableName;\n+  private static DynamoDbClient dynamo;\n+\n+  @BeforeClass\n+  public static void beforeClass() {\n+    GlueTestBase.beforeClass();\n+    String testBucketPath = \"s3://\" + testBucketName + \"/\" + testPathPrefix;\n+    lockTableName = getRandomName();\n+    S3FileIO fileIO = new S3FileIO(clientFactory::s3);\n+    glueCatalog = new GlueCatalog();\n+    AwsProperties awsProperties = new AwsProperties();\n+    awsProperties.setGlueCatalogLockTable(lockTableName);\n+    awsProperties.setGlueCatalogLockEnabled(true);\n+    dynamo = clientFactory.dynamo();\n+    glueCatalog.initialize(catalogName, testBucketPath, awsProperties, glue,\n+        new DynamoLockManager(dynamo, awsProperties), fileIO);\n+  }\n+\n+  @AfterClass\n+  public static void afterClass() {\n+    GlueTestBase.afterClass();\n+    dynamo.deleteTable(DeleteTableRequest.builder().tableName(lockTableName).build());\n+  }\n+\n+  @Test\n+  public void testParallelCommit() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "originalPosition": 67}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3NDIzODcz", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-557423873", "createdAt": "2020-12-22T23:26:57Z", "commit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMzoyNjo1N1rOIKMImQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMzoyNjo1N1rOIKMImQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU1NTQ4MQ==", "bodyText": "Shouldn't this use GLUE_CATALOG_LOCK_ENABLED_DEFAULT?", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547555481", "createdAt": "2020-12-22T23:26:57Z", "author": {"login": "rdblue"}, "path": "aws/src/main/java/org/apache/iceberg/aws/AwsProperties.java", "diffHunk": "@@ -155,6 +196,10 @@ public AwsProperties() {\n \n     this.glueCatalogId = null;\n     this.glueCatalogSkipArchive = GLUE_CATALOG_SKIP_ARCHIVE_DEFAULT;\n+    this.glueCatalogLockEnabled = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "originalPosition": 66}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3NDI0MDgy", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-557424082", "createdAt": "2020-12-22T23:27:36Z", "commit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMzoyNzozNlrOIKMJOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMzoyNzozNlrOIKMJOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU1NTY0Mw==", "bodyText": "Typo: \"GLue\" -> \"Glue\"", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547555643", "createdAt": "2020-12-22T23:27:36Z", "author": {"login": "rdblue"}, "path": "aws/src/main/java/org/apache/iceberg/aws/AwsProperties.java", "diffHunk": "@@ -198,6 +243,19 @@ public AwsProperties(Map<String, String> properties) {\n     this.s3FileIoAcl = ObjectCannedACL.fromValue(aclType);\n     Preconditions.checkArgument(s3FileIoAcl == null || !s3FileIoAcl.equals(ObjectCannedACL.UNKNOWN_TO_SDK_VERSION),\n         \"Cannot support S3 CannedACL \" + aclType);\n+\n+    this.glueCatalogLockEnabled = PropertyUtil.propertyAsBoolean(properties,\n+        GLUE_CATALOG_LOCK_ENABLED, GLUE_CATALOG_LOCK_ENABLED_DEFAULT);\n+    this.glueCatalogLockTable = properties.get(GLUE_CATALOG_LOCK_TABLE);\n+    this.glueCatalogLockWaitMs = PropertyUtil.propertyAsLong(properties,\n+        GLUE_CATALOG_LOCK_WAIT_MS, GLUE_CATALOG_LOCK_WAIT_MS_DEFAULT);\n+    this.glueCatalogLockExpireMs = PropertyUtil.propertyAsLong(properties,\n+        GLUE_CATALOG_LOCK_MS_EXPIRE, GLUE_CATALOG_LOCK_EXPIRE_MS_DEFAULT);\n+\n+    if (glueCatalogLockEnabled) {\n+      Preconditions.checkNotNull(glueCatalogLockTable,\n+          GLUE_CATALOG_LOCK_TABLE + \" must not be null with GLue catalog lock is enabled\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee"}, "originalPosition": 88}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee", "author": {"user": {"login": "jackye1995", "name": "Jack Ye"}}, "url": "https://github.com/apache/iceberg/commit/17874b628e12aedb347b1e9303b6a7928d4b9bee", "committedDate": "2020-12-21T22:36:45Z", "message": "AWS: Glue catalog locking through DynamoDB"}, "afterCommit": {"oid": "2c565d5b408a80115935899450b54a96dcf0405e", "author": {"user": {"login": "jackye1995", "name": "Jack Ye"}}, "url": "https://github.com/apache/iceberg/commit/2c565d5b408a80115935899450b54a96dcf0405e", "committedDate": "2020-12-23T17:58:38Z", "message": "AWS: Glue catalog locking through DynamoDB"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2c565d5b408a80115935899450b54a96dcf0405e", "author": {"user": {"login": "jackye1995", "name": "Jack Ye"}}, "url": "https://github.com/apache/iceberg/commit/2c565d5b408a80115935899450b54a96dcf0405e", "committedDate": "2020-12-23T17:58:38Z", "message": "AWS: Glue catalog locking through DynamoDB"}, "afterCommit": {"oid": "4f94b13edc7e6a10e85385e1493e9fee02853346", "author": {"user": {"login": "jackye1995", "name": "Jack Ye"}}, "url": "https://github.com/apache/iceberg/commit/4f94b13edc7e6a10e85385e1493e9fee02853346", "committedDate": "2020-12-23T21:46:00Z", "message": "AWS: Glue catalog locking through DynamoDB"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5MzMzMjA5", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-559333209", "createdAt": "2020-12-28T23:31:40Z", "commit": {"oid": "951291449040a6127da99fcb40ec65faf46564c0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOFQyMzozMTo0MFrOIMD50g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOFQyMzozMTo0MFrOIMD50g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxNzc3OA==", "bodyText": "The test will already fail if an unexpected exception is thrown. Is there value in adding extra code here to do the same thing?", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r549517778", "createdAt": "2020-12-28T23:31:40Z", "author": {"login": "rdblue"}, "path": "aws/src/integration/java/org/apache/iceberg/aws/glue/DynamoLockManagerTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.aws.AwsClientFactories;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.GetItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+\n+public class DynamoLockManagerTest {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(LockManagerTest.class);\n+\n+  private static final String DATABASE = \"database\";\n+\n+  private static String lockTableName;\n+  private static DynamoDbClient dynamo;\n+\n+  private LockManager lockManager;\n+  private String tableName;\n+\n+  @BeforeClass\n+  public static void beforeClass() {\n+    lockTableName = genTableName();\n+    dynamo = AwsClientFactories.defaultFactory().dynamo();\n+  }\n+\n+  @Before\n+  public void before() {\n+    lockManager = new DynamoLockManager(dynamo, lockTableName);\n+    tableName = genTableName();\n+  }\n+\n+  @AfterClass\n+  public static void afterClass() {\n+    dynamo.deleteTable(DeleteTableRequest.builder().tableName(lockTableName).build());\n+  }\n+\n+  @Test\n+  public void testTableCreation() {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(lockTableName)\n+          .build());\n+    } catch (Exception e) {\n+      LOG.error(\"encountered failure\", e);\n+      Assert.fail(\"Should not throw exception when describing DynamoDB lock table\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "951291449040a6127da99fcb40ec65faf46564c0"}, "originalPosition": 84}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5MzM0MTc0", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-559334174", "createdAt": "2020-12-28T23:37:58Z", "commit": {"oid": "951291449040a6127da99fcb40ec65faf46564c0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOFQyMzozNzo1OFrOIMD-Jw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOFQyMzozNzo1OFrOIMD-Jw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxODg4Nw==", "bodyText": "What about using lock.table? I'm not sure that \"dynamo\" needs to be in the property name because it doesn't provide much value.", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r549518887", "createdAt": "2020-12-28T23:37:58Z", "author": {"login": "rdblue"}, "path": "aws/src/main/java/org/apache/iceberg/aws/AwsProperties.java", "diffHunk": "@@ -130,6 +131,37 @@\n    */\n   public static final String S3FILEIO_ACL = \"s3fileio.acl\";\n \n+  /**\n+   * The implementation of LockManager to use for concurrent commits.\n+   */\n+  public static final String LOCK_IMPL = \"lock.impl\";\n+\n+  /**\n+   * After the given time in milliseconds, the process will give up the attempt to acquire a lock.\n+   * Default to 3 minutes.\n+   */\n+  public static final String LOCK_WAIT_MS = \"lock.wait-ms\";\n+  public static final long LOCK_WAIT_MS_DEFAULT = TimeUnit.MINUTES.toMillis(3);\n+\n+  /**\n+   * After the given time in milliseconds, the lock is automatically expired.\n+   * Default to 20 minutes.\n+   */\n+  public static final String LOCK_EXPIRE_MS = \"lock.expire-ms\";\n+  public static final long LOCK_EXPIRE_MS_DEFAULT = TimeUnit.MINUTES.toMillis(20);\n+\n+  /**\n+   * The DynamoDB table used for locking.\n+   * <p>\n+   * The table name must be explicitly provided as an input when lock is enabled.\n+   * This ensures the user is aware of the use of a DynamoDB table that might incur cost.\n+   * Each glue catalog should use a different DynamoDB table for locking,\n+   * otherwise tables with the same name from different catalog will block each other's commit.\n+   * If the table with the given name does not exist,\n+   * the table will be created at runtime with billing mode set to PAY_PER_REQUEST.\n+   */\n+  public static final String LOCK_DYNAMO_TABLE = \"lock.dynamo.table\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "951291449040a6127da99fcb40ec65faf46564c0"}, "originalPosition": 41}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5MzM0NTg1", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-559334585", "createdAt": "2020-12-28T23:40:40Z", "commit": {"oid": "951291449040a6127da99fcb40ec65faf46564c0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOFQyMzo0MDo0MVrOIMD_8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOFQyMzo0MDo0MVrOIMD_8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxOTM0Nw==", "bodyText": "Minor: seems odd to have a separate method when the schema and definitions are always the same and this isn't called from elsewhere.", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r549519347", "createdAt": "2020-12-28T23:40:41Z", "author": {"login": "rdblue"}, "path": "aws/src/main/java/org/apache/iceberg/aws/glue/DynamoLockManager.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.aws.AwsClientFactories;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.util.Tasks;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeDefinition;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.BillingMode;\n+import software.amazon.awssdk.services.dynamodb.model.ConditionalCheckFailedException;\n+import software.amazon.awssdk.services.dynamodb.model.CreateTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableResponse;\n+import software.amazon.awssdk.services.dynamodb.model.KeySchemaElement;\n+import software.amazon.awssdk.services.dynamodb.model.KeyType;\n+import software.amazon.awssdk.services.dynamodb.model.PutItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+import software.amazon.awssdk.services.dynamodb.model.ScalarAttributeType;\n+import software.amazon.awssdk.services.dynamodb.model.TableStatus;\n+\n+/**\n+ * DynamoDB implementation for the lock manager.\n+ */\n+class DynamoLockManager implements LockManager {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManager.class);\n+\n+  private static final String LOCK_TABLE_COL_LOCK_ID = \"lockId\";\n+  private static final String LOCK_TABLE_COL_EXPIRE_TS_MILLIS = \"expireTimestampMillis\";\n+  private static final int LOCK_TABLE_CREATION_WAIT_ATTEMPTS_MAX = 5;\n+\n+  private static final List<KeySchemaElement> LOCK_TABLE_SCHEMA = Lists.newArrayList(\n+      KeySchemaElement.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .keyType(KeyType.HASH)\n+          .build()\n+  );\n+\n+  private static final List<AttributeDefinition> LOCK_TABLE_COL_DEFINITIONS = Lists.newArrayList(\n+      AttributeDefinition.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .attributeType(ScalarAttributeType.S)\n+          .build()\n+  );\n+\n+  private DynamoDbClient dynamo;\n+  private String lockTableName;\n+\n+  /**\n+   * constructor for dynamic initialization, {@link #initialize(Map)} must be called later.\n+   */\n+  DynamoLockManager() {\n+  }\n+\n+  /**\n+   * All arg constructor, used for testing purpose\n+   * @param dynamo dynamo client\n+   * @param lockTableName lock table name\n+   */\n+  DynamoLockManager(DynamoDbClient dynamo, String lockTableName) {\n+    this.dynamo = dynamo;\n+    this.lockTableName = lockTableName;\n+    ensureLockTableExistsOrCreate();\n+  }\n+\n+  private void ensureLockTableExistsOrCreate() {\n+    ensureTableExistsOrCreate(lockTableName, LOCK_TABLE_SCHEMA, LOCK_TABLE_COL_DEFINITIONS);\n+  }\n+\n+  private void ensureTableExistsOrCreate(String tableName, List<KeySchemaElement> schema,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "951291449040a6127da99fcb40ec65faf46564c0"}, "originalPosition": 97}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5MzM0OTQx", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-559334941", "createdAt": "2020-12-28T23:43:11Z", "commit": {"oid": "951291449040a6127da99fcb40ec65faf46564c0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOFQyMzo0MzoxMVrOIMEBfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOFQyMzo0MzoxMVrOIMEBfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxOTc0MQ==", "bodyText": "Since this should only retry on IllegalStateException, I think you should use onlyRetryOn(IllegalStateException.class). That way, other exceptions thrown from the Dynamo client won't cause retries that just take longer to fail.", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r549519741", "createdAt": "2020-12-28T23:43:11Z", "author": {"login": "rdblue"}, "path": "aws/src/main/java/org/apache/iceberg/aws/glue/DynamoLockManager.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.aws.AwsClientFactories;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.util.Tasks;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeDefinition;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.BillingMode;\n+import software.amazon.awssdk.services.dynamodb.model.ConditionalCheckFailedException;\n+import software.amazon.awssdk.services.dynamodb.model.CreateTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableResponse;\n+import software.amazon.awssdk.services.dynamodb.model.KeySchemaElement;\n+import software.amazon.awssdk.services.dynamodb.model.KeyType;\n+import software.amazon.awssdk.services.dynamodb.model.PutItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+import software.amazon.awssdk.services.dynamodb.model.ScalarAttributeType;\n+import software.amazon.awssdk.services.dynamodb.model.TableStatus;\n+\n+/**\n+ * DynamoDB implementation for the lock manager.\n+ */\n+class DynamoLockManager implements LockManager {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManager.class);\n+\n+  private static final String LOCK_TABLE_COL_LOCK_ID = \"lockId\";\n+  private static final String LOCK_TABLE_COL_EXPIRE_TS_MILLIS = \"expireTimestampMillis\";\n+  private static final int LOCK_TABLE_CREATION_WAIT_ATTEMPTS_MAX = 5;\n+\n+  private static final List<KeySchemaElement> LOCK_TABLE_SCHEMA = Lists.newArrayList(\n+      KeySchemaElement.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .keyType(KeyType.HASH)\n+          .build()\n+  );\n+\n+  private static final List<AttributeDefinition> LOCK_TABLE_COL_DEFINITIONS = Lists.newArrayList(\n+      AttributeDefinition.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .attributeType(ScalarAttributeType.S)\n+          .build()\n+  );\n+\n+  private DynamoDbClient dynamo;\n+  private String lockTableName;\n+\n+  /**\n+   * constructor for dynamic initialization, {@link #initialize(Map)} must be called later.\n+   */\n+  DynamoLockManager() {\n+  }\n+\n+  /**\n+   * All arg constructor, used for testing purpose\n+   * @param dynamo dynamo client\n+   * @param lockTableName lock table name\n+   */\n+  DynamoLockManager(DynamoDbClient dynamo, String lockTableName) {\n+    this.dynamo = dynamo;\n+    this.lockTableName = lockTableName;\n+    ensureLockTableExistsOrCreate();\n+  }\n+\n+  private void ensureLockTableExistsOrCreate() {\n+    ensureTableExistsOrCreate(lockTableName, LOCK_TABLE_SCHEMA, LOCK_TABLE_COL_DEFINITIONS);\n+  }\n+\n+  private void ensureTableExistsOrCreate(String tableName, List<KeySchemaElement> schema,\n+                                         List<AttributeDefinition> definitions) {\n+    if (tableExists(tableName)) {\n+      return;\n+    }\n+\n+    LOG.info(\"Dynamo lock table {} not found, trying to create\", tableName);\n+    dynamo.createTable(CreateTableRequest.builder()\n+        .tableName(tableName)\n+        .keySchema(schema)\n+        .attributeDefinitions(definitions)\n+        .billingMode(BillingMode.PAY_PER_REQUEST)\n+        .build());\n+\n+    Tasks.foreach(tableName)\n+        .retry(LOCK_TABLE_CREATION_WAIT_ATTEMPTS_MAX)\n+        .throwFailureWhenFinished()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "951291449040a6127da99fcb40ec65faf46564c0"}, "originalPosition": 113}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5MzM1MDk4", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-559335098", "createdAt": "2020-12-28T23:44:29Z", "commit": {"oid": "951291449040a6127da99fcb40ec65faf46564c0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOFQyMzo0NDoyOVrOIMECPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOFQyMzo0NDoyOVrOIMECPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxOTkzNA==", "bodyText": "It is better to avoid including class, method, or variable names in messages because the user often won't be familiar with this code's variable names. Instead, use \"Table name\" or \"Lock table name\" because that's what the user sets.", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r549519934", "createdAt": "2020-12-28T23:44:29Z", "author": {"login": "rdblue"}, "path": "aws/src/main/java/org/apache/iceberg/aws/glue/DynamoLockManager.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.aws.AwsClientFactories;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.util.Tasks;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeDefinition;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.BillingMode;\n+import software.amazon.awssdk.services.dynamodb.model.ConditionalCheckFailedException;\n+import software.amazon.awssdk.services.dynamodb.model.CreateTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableResponse;\n+import software.amazon.awssdk.services.dynamodb.model.KeySchemaElement;\n+import software.amazon.awssdk.services.dynamodb.model.KeyType;\n+import software.amazon.awssdk.services.dynamodb.model.PutItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+import software.amazon.awssdk.services.dynamodb.model.ScalarAttributeType;\n+import software.amazon.awssdk.services.dynamodb.model.TableStatus;\n+\n+/**\n+ * DynamoDB implementation for the lock manager.\n+ */\n+class DynamoLockManager implements LockManager {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManager.class);\n+\n+  private static final String LOCK_TABLE_COL_LOCK_ID = \"lockId\";\n+  private static final String LOCK_TABLE_COL_EXPIRE_TS_MILLIS = \"expireTimestampMillis\";\n+  private static final int LOCK_TABLE_CREATION_WAIT_ATTEMPTS_MAX = 5;\n+\n+  private static final List<KeySchemaElement> LOCK_TABLE_SCHEMA = Lists.newArrayList(\n+      KeySchemaElement.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .keyType(KeyType.HASH)\n+          .build()\n+  );\n+\n+  private static final List<AttributeDefinition> LOCK_TABLE_COL_DEFINITIONS = Lists.newArrayList(\n+      AttributeDefinition.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .attributeType(ScalarAttributeType.S)\n+          .build()\n+  );\n+\n+  private DynamoDbClient dynamo;\n+  private String lockTableName;\n+\n+  /**\n+   * constructor for dynamic initialization, {@link #initialize(Map)} must be called later.\n+   */\n+  DynamoLockManager() {\n+  }\n+\n+  /**\n+   * All arg constructor, used for testing purpose\n+   * @param dynamo dynamo client\n+   * @param lockTableName lock table name\n+   */\n+  DynamoLockManager(DynamoDbClient dynamo, String lockTableName) {\n+    this.dynamo = dynamo;\n+    this.lockTableName = lockTableName;\n+    ensureLockTableExistsOrCreate();\n+  }\n+\n+  private void ensureLockTableExistsOrCreate() {\n+    ensureTableExistsOrCreate(lockTableName, LOCK_TABLE_SCHEMA, LOCK_TABLE_COL_DEFINITIONS);\n+  }\n+\n+  private void ensureTableExistsOrCreate(String tableName, List<KeySchemaElement> schema,\n+                                         List<AttributeDefinition> definitions) {\n+    if (tableExists(tableName)) {\n+      return;\n+    }\n+\n+    LOG.info(\"Dynamo lock table {} not found, trying to create\", tableName);\n+    dynamo.createTable(CreateTableRequest.builder()\n+        .tableName(tableName)\n+        .keySchema(schema)\n+        .attributeDefinitions(definitions)\n+        .billingMode(BillingMode.PAY_PER_REQUEST)\n+        .build());\n+\n+    Tasks.foreach(tableName)\n+        .retry(LOCK_TABLE_CREATION_WAIT_ATTEMPTS_MAX)\n+        .throwFailureWhenFinished()\n+        .run(this::checkTableActive);\n+  }\n+\n+  private boolean tableExists(String tableName) {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(tableName)\n+          .build());\n+      return true;\n+    } catch (ResourceNotFoundException e) {\n+      return false;\n+    }\n+  }\n+\n+  private void checkTableActive(String tableName) {\n+    try {\n+      DescribeTableResponse response = dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(tableName)\n+          .build());\n+      TableStatus currentStatus = response.table().tableStatus();\n+      if (!currentStatus.equals(TableStatus.ACTIVE)) {\n+        throw new IllegalStateException(String.format(\"Dynamo table %s is not active, current status: %s\",\n+            tableName, currentStatus));\n+      }\n+    } catch (ResourceNotFoundException e) {\n+      throw new IllegalStateException(String.format(\"Cannot find Dynamo table %s\", tableName));\n+    }\n+  }\n+\n+  @Override\n+  public void initialize(Map<String, String> properties) {\n+    this.dynamo = AwsClientFactories.from(properties).dynamo();\n+    this.lockTableName = properties.get(AwsProperties.LOCK_DYNAMO_TABLE);\n+    Preconditions.checkNotNull(lockTableName, \"tableName must not be null\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "951291449040a6127da99fcb40ec65faf46564c0"}, "originalPosition": 147}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5MzM1MzM1", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-559335335", "createdAt": "2020-12-28T23:46:07Z", "commit": {"oid": "951291449040a6127da99fcb40ec65faf46564c0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOFQyMzo0NjowN1rOIMEDaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOFQyMzo0NjowN1rOIMEDaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUyMDIzMw==", "bodyText": "Nit: unnecessary newline.", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r549520233", "createdAt": "2020-12-28T23:46:07Z", "author": {"login": "rdblue"}, "path": "aws/src/main/java/org/apache/iceberg/aws/glue/DynamoLockManager.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.aws.AwsClientFactories;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.util.Tasks;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeDefinition;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.BillingMode;\n+import software.amazon.awssdk.services.dynamodb.model.ConditionalCheckFailedException;\n+import software.amazon.awssdk.services.dynamodb.model.CreateTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableResponse;\n+import software.amazon.awssdk.services.dynamodb.model.KeySchemaElement;\n+import software.amazon.awssdk.services.dynamodb.model.KeyType;\n+import software.amazon.awssdk.services.dynamodb.model.PutItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+import software.amazon.awssdk.services.dynamodb.model.ScalarAttributeType;\n+import software.amazon.awssdk.services.dynamodb.model.TableStatus;\n+\n+/**\n+ * DynamoDB implementation for the lock manager.\n+ */\n+class DynamoLockManager implements LockManager {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManager.class);\n+\n+  private static final String LOCK_TABLE_COL_LOCK_ID = \"lockId\";\n+  private static final String LOCK_TABLE_COL_EXPIRE_TS_MILLIS = \"expireTimestampMillis\";\n+  private static final int LOCK_TABLE_CREATION_WAIT_ATTEMPTS_MAX = 5;\n+\n+  private static final List<KeySchemaElement> LOCK_TABLE_SCHEMA = Lists.newArrayList(\n+      KeySchemaElement.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .keyType(KeyType.HASH)\n+          .build()\n+  );\n+\n+  private static final List<AttributeDefinition> LOCK_TABLE_COL_DEFINITIONS = Lists.newArrayList(\n+      AttributeDefinition.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .attributeType(ScalarAttributeType.S)\n+          .build()\n+  );\n+\n+  private DynamoDbClient dynamo;\n+  private String lockTableName;\n+\n+  /**\n+   * constructor for dynamic initialization, {@link #initialize(Map)} must be called later.\n+   */\n+  DynamoLockManager() {\n+  }\n+\n+  /**\n+   * All arg constructor, used for testing purpose\n+   * @param dynamo dynamo client\n+   * @param lockTableName lock table name\n+   */\n+  DynamoLockManager(DynamoDbClient dynamo, String lockTableName) {\n+    this.dynamo = dynamo;\n+    this.lockTableName = lockTableName;\n+    ensureLockTableExistsOrCreate();\n+  }\n+\n+  private void ensureLockTableExistsOrCreate() {\n+    ensureTableExistsOrCreate(lockTableName, LOCK_TABLE_SCHEMA, LOCK_TABLE_COL_DEFINITIONS);\n+  }\n+\n+  private void ensureTableExistsOrCreate(String tableName, List<KeySchemaElement> schema,\n+                                         List<AttributeDefinition> definitions) {\n+    if (tableExists(tableName)) {\n+      return;\n+    }\n+\n+    LOG.info(\"Dynamo lock table {} not found, trying to create\", tableName);\n+    dynamo.createTable(CreateTableRequest.builder()\n+        .tableName(tableName)\n+        .keySchema(schema)\n+        .attributeDefinitions(definitions)\n+        .billingMode(BillingMode.PAY_PER_REQUEST)\n+        .build());\n+\n+    Tasks.foreach(tableName)\n+        .retry(LOCK_TABLE_CREATION_WAIT_ATTEMPTS_MAX)\n+        .throwFailureWhenFinished()\n+        .run(this::checkTableActive);\n+  }\n+\n+  private boolean tableExists(String tableName) {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(tableName)\n+          .build());\n+      return true;\n+    } catch (ResourceNotFoundException e) {\n+      return false;\n+    }\n+  }\n+\n+  private void checkTableActive(String tableName) {\n+    try {\n+      DescribeTableResponse response = dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(tableName)\n+          .build());\n+      TableStatus currentStatus = response.table().tableStatus();\n+      if (!currentStatus.equals(TableStatus.ACTIVE)) {\n+        throw new IllegalStateException(String.format(\"Dynamo table %s is not active, current status: %s\",\n+            tableName, currentStatus));\n+      }\n+    } catch (ResourceNotFoundException e) {\n+      throw new IllegalStateException(String.format(\"Cannot find Dynamo table %s\", tableName));\n+    }\n+  }\n+\n+  @Override\n+  public void initialize(Map<String, String> properties) {\n+    this.dynamo = AwsClientFactories.from(properties).dynamo();\n+    this.lockTableName = properties.get(AwsProperties.LOCK_DYNAMO_TABLE);\n+    Preconditions.checkNotNull(lockTableName, \"tableName must not be null\");\n+    ensureLockTableExistsOrCreate();\n+  }\n+\n+  @Override\n+  public boolean tryLock(String lockId, long expireMillis) {\n+    Map<String, AttributeValue> key = Maps.newHashMap();\n+    key.put(LOCK_TABLE_COL_LOCK_ID, AttributeValue.builder().s(lockId).build());\n+    // TODO: fix potential clock skew issue\n+    //   more details: https://github.com/awslabs/amazon-dynamodb-lock-client#how-we-handle-clock-skew\n+    key.put(LOCK_TABLE_COL_EXPIRE_TS_MILLIS, AttributeValue.builder().n(\n+        Long.toString(System.currentTimeMillis() + expireMillis)\n+    ).build());\n+\n+    Map<String, AttributeValue> expressionValues = Maps.newHashMap();\n+    expressionValues.put(\":lid\", AttributeValue.builder().s(lockId).build());\n+    expressionValues.put(\":ts\", AttributeValue.builder().n(Long.toString(System.currentTimeMillis())).build());\n+\n+    try {\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "951291449040a6127da99fcb40ec65faf46564c0"}, "originalPosition": 166}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5MzM2MzY2", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-559336366", "createdAt": "2020-12-28T23:53:43Z", "commit": {"oid": "951291449040a6127da99fcb40ec65faf46564c0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOFQyMzo1Mzo0M1rOIMEIFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOFQyMzo1Mzo0M1rOIMEIFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUyMTQyOA==", "bodyText": "I think that this should validate that the lock is correctly held by the expected lock manager. Since there isn't an ID for the lock manager yet, it should at least validate that there is a valid timestamp in the table.", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r549521428", "createdAt": "2020-12-28T23:53:43Z", "author": {"login": "rdblue"}, "path": "aws/src/integration/java/org/apache/iceberg/aws/glue/DynamoLockManagerTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.aws.AwsClientFactories;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.GetItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+\n+public class DynamoLockManagerTest {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(LockManagerTest.class);\n+\n+  private static final String DATABASE = \"database\";\n+\n+  private static String lockTableName;\n+  private static DynamoDbClient dynamo;\n+\n+  private LockManager lockManager;\n+  private String tableName;\n+\n+  @BeforeClass\n+  public static void beforeClass() {\n+    lockTableName = genTableName();\n+    dynamo = AwsClientFactories.defaultFactory().dynamo();\n+  }\n+\n+  @Before\n+  public void before() {\n+    lockManager = new DynamoLockManager(dynamo, lockTableName);\n+    tableName = genTableName();\n+  }\n+\n+  @AfterClass\n+  public static void afterClass() {\n+    dynamo.deleteTable(DeleteTableRequest.builder().tableName(lockTableName).build());\n+  }\n+\n+  @Test\n+  public void testTableCreation() {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(lockTableName)\n+          .build());\n+    } catch (Exception e) {\n+      LOG.error(\"encountered failure\", e);\n+      Assert.fail(\"Should not throw exception when describing DynamoDB lock table\");\n+    }\n+  }\n+\n+  @Test\n+  public void testLock_singleProcess() {\n+    boolean succeed = lockManager.tryLock(tableId(tableName),\n+        AwsProperties.LOCK_EXPIRE_MS_DEFAULT);\n+    Assert.assertTrue(succeed);\n+    Map<String, AttributeValue> key = Maps.newHashMap();\n+    key.put(\"lockId\", AttributeValue.builder().s(tableId(tableName)).build());\n+    try {\n+      dynamo.getItem(GetItemRequest.builder()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "951291449040a6127da99fcb40ec65faf46564c0"}, "originalPosition": 96}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5MzM2NDY2", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-559336466", "createdAt": "2020-12-28T23:54:30Z", "commit": {"oid": "951291449040a6127da99fcb40ec65faf46564c0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOFQyMzo1NDozMFrOIMEIng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOFQyMzo1NDozMFrOIMEIng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUyMTU2Ng==", "bodyText": "I think this should create different lock managers to simulate multiple processes, not use the same one.", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r549521566", "createdAt": "2020-12-28T23:54:30Z", "author": {"login": "rdblue"}, "path": "aws/src/integration/java/org/apache/iceberg/aws/glue/DynamoLockManagerTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.aws.AwsClientFactories;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.GetItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+\n+public class DynamoLockManagerTest {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(LockManagerTest.class);\n+\n+  private static final String DATABASE = \"database\";\n+\n+  private static String lockTableName;\n+  private static DynamoDbClient dynamo;\n+\n+  private LockManager lockManager;\n+  private String tableName;\n+\n+  @BeforeClass\n+  public static void beforeClass() {\n+    lockTableName = genTableName();\n+    dynamo = AwsClientFactories.defaultFactory().dynamo();\n+  }\n+\n+  @Before\n+  public void before() {\n+    lockManager = new DynamoLockManager(dynamo, lockTableName);\n+    tableName = genTableName();\n+  }\n+\n+  @AfterClass\n+  public static void afterClass() {\n+    dynamo.deleteTable(DeleteTableRequest.builder().tableName(lockTableName).build());\n+  }\n+\n+  @Test\n+  public void testTableCreation() {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(lockTableName)\n+          .build());\n+    } catch (Exception e) {\n+      LOG.error(\"encountered failure\", e);\n+      Assert.fail(\"Should not throw exception when describing DynamoDB lock table\");\n+    }\n+  }\n+\n+  @Test\n+  public void testLock_singleProcess() {\n+    boolean succeed = lockManager.tryLock(tableId(tableName),\n+        AwsProperties.LOCK_EXPIRE_MS_DEFAULT);\n+    Assert.assertTrue(succeed);\n+    Map<String, AttributeValue> key = Maps.newHashMap();\n+    key.put(\"lockId\", AttributeValue.builder().s(tableId(tableName)).build());\n+    try {\n+      dynamo.getItem(GetItemRequest.builder()\n+          .tableName(lockTableName)\n+          .key(key)\n+          .build());\n+    } catch (Exception e) {\n+      LOG.error(\"encountered failure\", e);\n+      Assert.fail(\"Should not throw exception when getting lock after insert\");\n+    }\n+  }\n+\n+  @Test\n+  public void testLock_multiProcess() {\n+    List<Boolean> results = IntStream.range(0, 100).parallel()\n+        .mapToObj(i -> lockManager.tryLock(tableId(tableName),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "951291449040a6127da99fcb40ec65faf46564c0"}, "originalPosition": 109}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5MzM2Njcx", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-559336671", "createdAt": "2020-12-28T23:55:57Z", "commit": {"oid": "951291449040a6127da99fcb40ec65faf46564c0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOFQyMzo1NTo1N1rOIMEJkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOFQyMzo1NTo1N1rOIMEJkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUyMTgxMQ==", "bodyText": "This doesn't test unlock, it tests that lock succeeds after dropping the lock item in the table.", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r549521811", "createdAt": "2020-12-28T23:55:57Z", "author": {"login": "rdblue"}, "path": "aws/src/integration/java/org/apache/iceberg/aws/glue/DynamoLockManagerTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.aws.AwsClientFactories;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.GetItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+\n+public class DynamoLockManagerTest {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(LockManagerTest.class);\n+\n+  private static final String DATABASE = \"database\";\n+\n+  private static String lockTableName;\n+  private static DynamoDbClient dynamo;\n+\n+  private LockManager lockManager;\n+  private String tableName;\n+\n+  @BeforeClass\n+  public static void beforeClass() {\n+    lockTableName = genTableName();\n+    dynamo = AwsClientFactories.defaultFactory().dynamo();\n+  }\n+\n+  @Before\n+  public void before() {\n+    lockManager = new DynamoLockManager(dynamo, lockTableName);\n+    tableName = genTableName();\n+  }\n+\n+  @AfterClass\n+  public static void afterClass() {\n+    dynamo.deleteTable(DeleteTableRequest.builder().tableName(lockTableName).build());\n+  }\n+\n+  @Test\n+  public void testTableCreation() {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(lockTableName)\n+          .build());\n+    } catch (Exception e) {\n+      LOG.error(\"encountered failure\", e);\n+      Assert.fail(\"Should not throw exception when describing DynamoDB lock table\");\n+    }\n+  }\n+\n+  @Test\n+  public void testLock_singleProcess() {\n+    boolean succeed = lockManager.tryLock(tableId(tableName),\n+        AwsProperties.LOCK_EXPIRE_MS_DEFAULT);\n+    Assert.assertTrue(succeed);\n+    Map<String, AttributeValue> key = Maps.newHashMap();\n+    key.put(\"lockId\", AttributeValue.builder().s(tableId(tableName)).build());\n+    try {\n+      dynamo.getItem(GetItemRequest.builder()\n+          .tableName(lockTableName)\n+          .key(key)\n+          .build());\n+    } catch (Exception e) {\n+      LOG.error(\"encountered failure\", e);\n+      Assert.fail(\"Should not throw exception when getting lock after insert\");\n+    }\n+  }\n+\n+  @Test\n+  public void testLock_multiProcess() {\n+    List<Boolean> results = IntStream.range(0, 100).parallel()\n+        .mapToObj(i -> lockManager.tryLock(tableId(tableName),\n+            AwsProperties.LOCK_EXPIRE_MS_DEFAULT))\n+        .collect(Collectors.toList());\n+    Assert.assertEquals(1, results.stream().filter(s -> s).count());\n+  }\n+\n+  @Test\n+  public void testWaitLock_singleProcess() throws Exception {\n+    boolean succeed = lockManager.tryLock(tableId(tableName),\n+        AwsProperties.LOCK_EXPIRE_MS_DEFAULT,\n+        AwsProperties.LOCK_WAIT_MS_DEFAULT);\n+    Assert.assertTrue(succeed);\n+    Map<String, AttributeValue> key = Maps.newHashMap();\n+    key.put(\"lockId\", AttributeValue.builder().s(tableId(tableName)).build());\n+    try {\n+      dynamo.getItem(GetItemRequest.builder()\n+          .tableName(lockTableName)\n+          .key(key)\n+          .build());\n+    } catch (Exception e) {\n+      LOG.error(\"encountered failure\", e);\n+      Assert.fail(\"Should not throw exception when getting lock after insert\");\n+    }\n+  }\n+\n+  @Test\n+  public void testWaitLock_multiProcess_allSucceed() {\n+    List<Boolean> results = IntStream.range(0, 100).parallel()\n+        .mapToObj(i -> {\n+          try {\n+            return lockManager.tryLock(tableId(tableName), 10, 100000);\n+          } catch (InterruptedException e) {\n+            LOG.error(\"lock acquire interrupted\", e);\n+            return false;\n+          }\n+        })\n+        .collect(Collectors.toList());\n+    Assert.assertEquals(100, results.stream().filter(s -> s).count());\n+  }\n+\n+  @Test\n+  public void testWaitLock_multiProcess_allFail() {\n+    List<Boolean> results = IntStream.range(0, 100).parallel()\n+        .mapToObj(i -> {\n+          try {\n+            return lockManager.tryLock(tableId(tableName), 1000000, 10);\n+          } catch (InterruptedException e) {\n+            LOG.error(\"lock acquire interrupted\", e);\n+            return false;\n+          }\n+        })\n+        .collect(Collectors.toList());\n+    Assert.assertEquals(1, results.stream().filter(s -> s).count());\n+  }\n+\n+\n+  @Test\n+  public void testUnlock() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "951291449040a6127da99fcb40ec65faf46564c0"}, "originalPosition": 166}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5MzM2ODk4", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-559336898", "createdAt": "2020-12-28T23:57:08Z", "commit": {"oid": "951291449040a6127da99fcb40ec65faf46564c0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOFQyMzo1NzowOFrOIMEKnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOFQyMzo1NzowOFrOIMEKnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUyMjA3OQ==", "bodyText": "Considering the lock only uses an ID string, I don't think that this method is needed. You could just use a static ID string.", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r549522079", "createdAt": "2020-12-28T23:57:08Z", "author": {"login": "rdblue"}, "path": "aws/src/integration/java/org/apache/iceberg/aws/glue/DynamoLockManagerTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.aws.AwsClientFactories;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.GetItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+\n+public class DynamoLockManagerTest {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(LockManagerTest.class);\n+\n+  private static final String DATABASE = \"database\";\n+\n+  private static String lockTableName;\n+  private static DynamoDbClient dynamo;\n+\n+  private LockManager lockManager;\n+  private String tableName;\n+\n+  @BeforeClass\n+  public static void beforeClass() {\n+    lockTableName = genTableName();\n+    dynamo = AwsClientFactories.defaultFactory().dynamo();\n+  }\n+\n+  @Before\n+  public void before() {\n+    lockManager = new DynamoLockManager(dynamo, lockTableName);\n+    tableName = genTableName();\n+  }\n+\n+  @AfterClass\n+  public static void afterClass() {\n+    dynamo.deleteTable(DeleteTableRequest.builder().tableName(lockTableName).build());\n+  }\n+\n+  @Test\n+  public void testTableCreation() {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(lockTableName)\n+          .build());\n+    } catch (Exception e) {\n+      LOG.error(\"encountered failure\", e);\n+      Assert.fail(\"Should not throw exception when describing DynamoDB lock table\");\n+    }\n+  }\n+\n+  @Test\n+  public void testLock_singleProcess() {\n+    boolean succeed = lockManager.tryLock(tableId(tableName),\n+        AwsProperties.LOCK_EXPIRE_MS_DEFAULT);\n+    Assert.assertTrue(succeed);\n+    Map<String, AttributeValue> key = Maps.newHashMap();\n+    key.put(\"lockId\", AttributeValue.builder().s(tableId(tableName)).build());\n+    try {\n+      dynamo.getItem(GetItemRequest.builder()\n+          .tableName(lockTableName)\n+          .key(key)\n+          .build());\n+    } catch (Exception e) {\n+      LOG.error(\"encountered failure\", e);\n+      Assert.fail(\"Should not throw exception when getting lock after insert\");\n+    }\n+  }\n+\n+  @Test\n+  public void testLock_multiProcess() {\n+    List<Boolean> results = IntStream.range(0, 100).parallel()\n+        .mapToObj(i -> lockManager.tryLock(tableId(tableName),\n+            AwsProperties.LOCK_EXPIRE_MS_DEFAULT))\n+        .collect(Collectors.toList());\n+    Assert.assertEquals(1, results.stream().filter(s -> s).count());\n+  }\n+\n+  @Test\n+  public void testWaitLock_singleProcess() throws Exception {\n+    boolean succeed = lockManager.tryLock(tableId(tableName),\n+        AwsProperties.LOCK_EXPIRE_MS_DEFAULT,\n+        AwsProperties.LOCK_WAIT_MS_DEFAULT);\n+    Assert.assertTrue(succeed);\n+    Map<String, AttributeValue> key = Maps.newHashMap();\n+    key.put(\"lockId\", AttributeValue.builder().s(tableId(tableName)).build());\n+    try {\n+      dynamo.getItem(GetItemRequest.builder()\n+          .tableName(lockTableName)\n+          .key(key)\n+          .build());\n+    } catch (Exception e) {\n+      LOG.error(\"encountered failure\", e);\n+      Assert.fail(\"Should not throw exception when getting lock after insert\");\n+    }\n+  }\n+\n+  @Test\n+  public void testWaitLock_multiProcess_allSucceed() {\n+    List<Boolean> results = IntStream.range(0, 100).parallel()\n+        .mapToObj(i -> {\n+          try {\n+            return lockManager.tryLock(tableId(tableName), 10, 100000);\n+          } catch (InterruptedException e) {\n+            LOG.error(\"lock acquire interrupted\", e);\n+            return false;\n+          }\n+        })\n+        .collect(Collectors.toList());\n+    Assert.assertEquals(100, results.stream().filter(s -> s).count());\n+  }\n+\n+  @Test\n+  public void testWaitLock_multiProcess_allFail() {\n+    List<Boolean> results = IntStream.range(0, 100).parallel()\n+        .mapToObj(i -> {\n+          try {\n+            return lockManager.tryLock(tableId(tableName), 1000000, 10);\n+          } catch (InterruptedException e) {\n+            LOG.error(\"lock acquire interrupted\", e);\n+            return false;\n+          }\n+        })\n+        .collect(Collectors.toList());\n+    Assert.assertEquals(1, results.stream().filter(s -> s).count());\n+  }\n+\n+\n+  @Test\n+  public void testUnlock() {\n+    boolean succeed = lockManager.tryLock(tableId(tableName),\n+        AwsProperties.LOCK_EXPIRE_MS_DEFAULT);\n+    Assert.assertTrue(succeed);\n+    Map<String, AttributeValue> key = Maps.newHashMap();\n+    key.put(\"lockId\", AttributeValue.builder().s(tableId(tableName)).build());\n+    dynamo.deleteItem(DeleteItemRequest.builder()\n+        .tableName(lockTableName)\n+        .key(key)\n+        .build());\n+    succeed = lockManager.tryLock(tableId(tableName),\n+        AwsProperties.LOCK_EXPIRE_MS_DEFAULT);\n+    Assert.assertTrue(succeed);\n+  }\n+\n+  @Test\n+  public void testTableCreationFailure() {\n+    DynamoDbClient dynamo2 = Mockito.mock(DynamoDbClient.class);\n+    Mockito.doThrow(ResourceNotFoundException.class).when(dynamo2)\n+        .describeTable(Mockito.any(DescribeTableRequest.class));\n+    AssertHelpers.assertThrows(\"should fail to initialize the lock manager\",\n+        IllegalStateException.class,\n+        \"Cannot find Dynamo table\",\n+        () -> new DynamoLockManager(dynamo2, lockTableName));\n+  }\n+\n+  private static String tableId(String tableName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "951291449040a6127da99fcb40ec65faf46564c0"}, "originalPosition": 192}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "951291449040a6127da99fcb40ec65faf46564c0", "author": {"user": {"login": "jackye1995", "name": "Jack Ye"}}, "url": "https://github.com/apache/iceberg/commit/951291449040a6127da99fcb40ec65faf46564c0", "committedDate": "2020-12-23T22:07:50Z", "message": "fix checkstyle"}, "afterCommit": {"oid": "1855b4ea40d020c178d5a454b99d1639dfedfce1", "author": {"user": {"login": "jackye1995", "name": "Jack Ye"}}, "url": "https://github.com/apache/iceberg/commit/1855b4ea40d020c178d5a454b99d1639dfedfce1", "committedDate": "2020-12-30T00:57:34Z", "message": "AWS: Glue catalog locking through DynamoDB"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "17da34459a6cb2b4ddb067aed6de3c5c2b22e725", "author": {"user": {"login": "jackye1995", "name": "Jack Ye"}}, "url": "https://github.com/apache/iceberg/commit/17da34459a6cb2b4ddb067aed6de3c5c2b22e725", "committedDate": "2020-12-30T01:45:55Z", "message": "use one manager per thread in test"}, "afterCommit": {"oid": "5794af1414902a7a4d464dc947f34a89f60e7e10", "author": {"user": {"login": "jackye1995", "name": "Jack Ye"}}, "url": "https://github.com/apache/iceberg/commit/5794af1414902a7a4d464dc947f34a89f60e7e10", "committedDate": "2020-12-30T01:54:15Z", "message": "AWS: Glue catalog locking through DynamoDB"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7c005c1fcc7b3869ebb28639e0975b22f9b06d11", "author": {"user": {"login": "jackye1995", "name": "Jack Ye"}}, "url": "https://github.com/apache/iceberg/commit/7c005c1fcc7b3869ebb28639e0975b22f9b06d11", "committedDate": "2020-12-30T02:07:11Z", "message": "fix checkstyle"}, "afterCommit": {"oid": "4d9b78176102d7cfa1234b04af780725554a74f8", "author": {"user": {"login": "jackye1995", "name": "Jack Ye"}}, "url": "https://github.com/apache/iceberg/commit/4d9b78176102d7cfa1234b04af780725554a74f8", "committedDate": "2020-12-30T04:04:54Z", "message": "AWS: Glue catalog locking through DynamoDB"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYwNTUxODM3", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-560551837", "createdAt": "2020-12-31T21:35:38Z", "commit": {"oid": "4d9b78176102d7cfa1234b04af780725554a74f8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMVQyMTozNTozOVrOINLt2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMVQyMTozNTozOVrOINLt2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDY5NDM2Mg==", "bodyText": "Why does this include owner ID? If it identifies a lock, that shouldn't depend on owner. And if this identifies a lock, what is the entity ID?\nIt seems like you want the lock manager to have an ID (owner ID) and a lock to have an ID (entity ID), but this mixes them together.", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r550694362", "createdAt": "2020-12-31T21:35:39Z", "author": {"login": "rdblue"}, "path": "aws/src/main/java/org/apache/iceberg/aws/glue/LockManager.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.Map;\n+import java.util.Objects;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+\n+/**\n+ * An interface for locking, used to ensure Glue catalog commit isolation.\n+ */\n+interface LockManager extends AutoCloseable {\n+\n+  /**\n+   * Try to acquire a lock\n+   * @param lockId lock ID\n+   * @throws LockNotAcquiredException if lock is not acquired\n+   */\n+  void acquire(LockId lockId);\n+\n+  /**\n+   * Release a lock\n+   * @param lockId lock ID\n+   * @throws IllegalArgumentException if lock entity not found or trying to unlock with a wrong owner ID\n+   */\n+  void release(LockId lockId);\n+\n+  /**\n+   * Initialize lock manager from catalog properties.\n+   * @param properties catalog properties\n+   */\n+  void initialize(Map<String, String> properties);\n+\n+  class LockId {\n+\n+    private final String entityId;\n+    private final String ownerId;\n+\n+    LockId(String entityId, String ownerId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d9b78176102d7cfa1234b04af780725554a74f8"}, "originalPosition": 56}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYwNTUxODY1", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-560551865", "createdAt": "2020-12-31T21:36:03Z", "commit": {"oid": "4d9b78176102d7cfa1234b04af780725554a74f8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMVQyMTozNjowM1rOINLuEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMVQyMTozNjowM1rOINLuEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDY5NDQxNw==", "bodyText": "Why not use lock and unlock?", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r550694417", "createdAt": "2020-12-31T21:36:03Z", "author": {"login": "rdblue"}, "path": "aws/src/main/java/org/apache/iceberg/aws/glue/LockManager.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.Map;\n+import java.util.Objects;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+\n+/**\n+ * An interface for locking, used to ensure Glue catalog commit isolation.\n+ */\n+interface LockManager extends AutoCloseable {\n+\n+  /**\n+   * Try to acquire a lock\n+   * @param lockId lock ID\n+   * @throws LockNotAcquiredException if lock is not acquired\n+   */\n+  void acquire(LockId lockId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d9b78176102d7cfa1234b04af780725554a74f8"}, "originalPosition": 36}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYwNTUxOTc1", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-560551975", "createdAt": "2020-12-31T21:37:14Z", "commit": {"oid": "4d9b78176102d7cfa1234b04af780725554a74f8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMVQyMTozNzoxNFrOINLuwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMVQyMTozNzoxNFrOINLuwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDY5NDU5Mg==", "bodyText": "Why would a lock need more than one heartbeat thread?", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r550694592", "createdAt": "2020-12-31T21:37:14Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/CatalogProperties.java", "diffHunk": "@@ -31,4 +33,24 @@ private CatalogProperties() {\n   public static final String HIVE_URI = \"uri\";\n   public static final String HIVE_CLIENT_POOL_SIZE = \"clients\";\n   public static final int HIVE_CLIENT_POOL_SIZE_DEFAULT = 2;\n+\n+  public static final String LOCK_IMPL = \"lock.impl\";\n+\n+  public static final String LOCK_HEARTBEAT_INTERVAL_MS = \"lock.heartbeat-interval-ms\";\n+  public static final long LOCK_HEARTBEAT_INTERVAL_MS_DEFAULT = TimeUnit.SECONDS.toMillis(3);\n+\n+  public static final String LOCK_HEARTBEAT_TIMEOUT_MS = \"lock.heartbeat-timeout-ms\";\n+  public static final long LOCK_HEARTBEAT_TIMEOUT_MS_DEFAULT = TimeUnit.SECONDS.toMillis(15);\n+\n+  public static final String LOCK_HEARTBEAT_THREADS = \"lock.heartbeat-threads\";\n+  public static final int LOCK_HEARTBEAT_THREADS_DEFAULT = 4;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d9b78176102d7cfa1234b04af780725554a74f8"}, "originalPosition": 23}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYwNTUyMDM0", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-560552034", "createdAt": "2020-12-31T21:37:48Z", "commit": {"oid": "4d9b78176102d7cfa1234b04af780725554a74f8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMVQyMTozNzo0OFrOINLu_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMVQyMTozNzo0OFrOINLu_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDY5NDY1Mw==", "bodyText": "Nit: unnecessary whitespace change.", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r550694653", "createdAt": "2020-12-31T21:37:48Z", "author": {"login": "rdblue"}, "path": "build.gradle", "diffHunk": "@@ -269,10 +269,12 @@ project(':iceberg-aws') {\n     compile project(':iceberg-api')\n     compile project(':iceberg-core')\n \n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d9b78176102d7cfa1234b04af780725554a74f8"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYwNTUyMDg5", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-560552089", "createdAt": "2020-12-31T21:38:30Z", "commit": {"oid": "4d9b78176102d7cfa1234b04af780725554a74f8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMVQyMTozODozMFrOINLvUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMVQyMTozODozMFrOINLvUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDY5NDczOA==", "bodyText": "Since this is getting large, we may want to separate it into the lock manager PR that Glue uses, and a new PR for the dynamo lock manager.", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r550694738", "createdAt": "2020-12-31T21:38:30Z", "author": {"login": "rdblue"}, "path": "aws/src/test/java/org/apache/iceberg/aws/glue/GlueCatalogTest.java", "diffHunk": "@@ -70,7 +70,8 @@\n   public void before() {\n     glue = Mockito.mock(GlueClient.class);\n     glueCatalog = new GlueCatalog();\n-    glueCatalog.initialize(CATALOG_NAME, WAREHOUSE_PATH, new AwsProperties(), glue, null);\n+    glueCatalog.initialize(CATALOG_NAME, WAREHOUSE_PATH, new AwsProperties(), glue,\n+        LockManagers.defaultLockManager(), null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d9b78176102d7cfa1234b04af780725554a74f8"}, "originalPosition": 6}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYwNTUyMjI2", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-560552226", "createdAt": "2020-12-31T21:39:56Z", "commit": {"oid": "4d9b78176102d7cfa1234b04af780725554a74f8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMVQyMTozOTo1NlrOINLwAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMVQyMTozOTo1NlrOINLwAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDY5NDkxMw==", "bodyText": "Could you rename this to InMemoryLockManager? I think we should make it clear that this is not suitable for real world use.", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r550694913", "createdAt": "2020-12-31T21:39:56Z", "author": {"login": "rdblue"}, "path": "aws/src/main/java/org/apache/iceberg/aws/glue/LockManagers.java", "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.Map;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.common.DynConstructors;\n+import org.apache.iceberg.relocated.com.google.common.annotations.VisibleForTesting;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.util.PropertyUtil;\n+import org.apache.iceberg.util.Tasks;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+class LockManagers {\n+\n+  private static final LockManager LOCK_MANAGER_DEFAULT = new DefaultLockManager(Maps.newHashMap());\n+\n+  private LockManagers() {\n+  }\n+\n+  public static LockManager defaultLockManager() {\n+    return LOCK_MANAGER_DEFAULT;\n+  }\n+\n+  public static LockManager from(Map<String, String> properties) {\n+    if (properties.containsKey(CatalogProperties.LOCK_IMPL)) {\n+      return loadLockManager(properties.get(CatalogProperties.LOCK_IMPL), properties);\n+    } else {\n+      return defaultLockManager();\n+    }\n+  }\n+\n+  private static LockManager loadLockManager(String impl, Map<String, String> properties) {\n+    DynConstructors.Ctor<LockManager> ctor;\n+    try {\n+      ctor = DynConstructors.builder(LockManager.class).hiddenImpl(impl).buildChecked();\n+    } catch (NoSuchMethodException e) {\n+      throw new IllegalArgumentException(String.format(\n+          \"Cannot initialize LockManager, missing no-arg constructor: %s\", impl), e);\n+    }\n+\n+    LockManager lockManager;\n+    try {\n+      lockManager = ctor.newInstance();\n+    } catch (ClassCastException e) {\n+      throw new IllegalArgumentException(\n+          String.format(\"Cannot initialize LockManager, %s does not implement LockManager.\", impl), e);\n+    }\n+\n+    lockManager.initialize(properties);\n+    return lockManager;\n+  }\n+\n+  abstract static class LockManagerBase implements LockManager {\n+\n+    private static volatile ScheduledExecutorService scheduler;\n+\n+    private long acquireTimeoutMs;\n+    private long acquireIntervalMs;\n+    private long heartbeatIntervalMs;\n+    private long heartbeatTimeoutMs;\n+    private int heartbeatThreads;\n+\n+    public long heartbeatTimeoutMs() {\n+      return heartbeatTimeoutMs;\n+    }\n+\n+    public long heartbeatIntervalMs() {\n+      return heartbeatIntervalMs;\n+    }\n+\n+    public long acquireIntervalMs() {\n+      return acquireIntervalMs;\n+    }\n+\n+    public long acquireTimeoutMs() {\n+      return acquireTimeoutMs;\n+    }\n+\n+    public int heartbeatThreads() {\n+      return heartbeatThreads;\n+    }\n+\n+    @SuppressWarnings(\"StaticGuardedByInstance\")\n+    public ScheduledExecutorService scheduler() {\n+      if (scheduler == null) {\n+        synchronized (this) {\n+          if (scheduler == null) {\n+            scheduler = Executors.newScheduledThreadPool(heartbeatThreads);\n+          }\n+        }\n+      }\n+      return scheduler;\n+    }\n+\n+    @Override\n+    public void initialize(Map<String, String> properties) {\n+      this.acquireTimeoutMs = PropertyUtil.propertyAsLong(properties,\n+          CatalogProperties.LOCK_ACQUIRE_TIMEOUT_MS, CatalogProperties.LOCK_ACQUIRE_TIMEOUT_MS_DEFAULT);\n+      this.acquireIntervalMs = PropertyUtil.propertyAsLong(properties,\n+          CatalogProperties.LOCK_ACQUIRE_INTERVAL_MS, CatalogProperties.LOCK_ACQUIRE_INTERVAL_MS_DEFAULT);\n+      this.heartbeatIntervalMs = PropertyUtil.propertyAsLong(properties,\n+          CatalogProperties.LOCK_HEARTBEAT_INTERVAL_MS, CatalogProperties.LOCK_HEARTBEAT_INTERVAL_MS_DEFAULT);\n+      this.heartbeatTimeoutMs = PropertyUtil.propertyAsLong(properties,\n+          CatalogProperties.LOCK_HEARTBEAT_TIMEOUT_MS, CatalogProperties.LOCK_HEARTBEAT_TIMEOUT_MS_DEFAULT);\n+      this.heartbeatThreads = PropertyUtil.propertyAsInt(properties,\n+          CatalogProperties.LOCK_HEARTBEAT_THREADS, CatalogProperties.LOCK_HEARTBEAT_THREADS_DEFAULT);\n+    }\n+  }\n+\n+  /**\n+   * Default implementation of {@link LockManager} that uses an in-memory concurrent map for locking.\n+   * This implementation should only be used for testing,\n+   * or if the caller only needs locking within the same JVM during table commits.\n+   */\n+  static class DefaultLockManager extends LockManagerBase {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d9b78176102d7cfa1234b04af780725554a74f8"}, "originalPosition": 138}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYwNTUyNDE1", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-560552415", "createdAt": "2020-12-31T21:41:59Z", "commit": {"oid": "4d9b78176102d7cfa1234b04af780725554a74f8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMVQyMTo0MjowMFrOINLwxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMVQyMTo0MjowMFrOINLwxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDY5NTExMQ==", "bodyText": "This looks good to me.", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r550695111", "createdAt": "2020-12-31T21:42:00Z", "author": {"login": "rdblue"}, "path": "aws/src/main/java/org/apache/iceberg/aws/glue/LockManagers.java", "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.Map;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.common.DynConstructors;\n+import org.apache.iceberg.relocated.com.google.common.annotations.VisibleForTesting;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.util.PropertyUtil;\n+import org.apache.iceberg.util.Tasks;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+class LockManagers {\n+\n+  private static final LockManager LOCK_MANAGER_DEFAULT = new DefaultLockManager(Maps.newHashMap());\n+\n+  private LockManagers() {\n+  }\n+\n+  public static LockManager defaultLockManager() {\n+    return LOCK_MANAGER_DEFAULT;\n+  }\n+\n+  public static LockManager from(Map<String, String> properties) {\n+    if (properties.containsKey(CatalogProperties.LOCK_IMPL)) {\n+      return loadLockManager(properties.get(CatalogProperties.LOCK_IMPL), properties);\n+    } else {\n+      return defaultLockManager();\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d9b78176102d7cfa1234b04af780725554a74f8"}, "originalPosition": 52}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYwNTU0NDA5", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-560554409", "createdAt": "2020-12-31T22:06:37Z", "commit": {"oid": "4d9b78176102d7cfa1234b04af780725554a74f8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMVQyMjowNjozN1rOINL7UQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMVQyMjowNjozN1rOINL7UQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDY5NzgwOQ==", "bodyText": "Can you also store the interval in the row? That way, the process that holds the lock shares its expectation with other processes. If you don't do that, then another process could use a wait interval shorter than the lock holder's heartbeat interval and incorrectly unlock. So the expected wait interval should come from the process that currently holds the lock, not the process attempting to get it.", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r550697809", "createdAt": "2020-12-31T22:06:37Z", "author": {"login": "rdblue"}, "path": "aws/src/main/java/org/apache/iceberg/aws/glue/DynamoLockManager.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.aws.AwsClientFactories;\n+import org.apache.iceberg.relocated.com.google.common.annotations.VisibleForTesting;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.util.Tasks;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeDefinition;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.BillingMode;\n+import software.amazon.awssdk.services.dynamodb.model.ConditionalCheckFailedException;\n+import software.amazon.awssdk.services.dynamodb.model.CreateTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableResponse;\n+import software.amazon.awssdk.services.dynamodb.model.GetItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.GetItemResponse;\n+import software.amazon.awssdk.services.dynamodb.model.InternalServerErrorException;\n+import software.amazon.awssdk.services.dynamodb.model.KeySchemaElement;\n+import software.amazon.awssdk.services.dynamodb.model.KeyType;\n+import software.amazon.awssdk.services.dynamodb.model.ProvisionedThroughputExceededException;\n+import software.amazon.awssdk.services.dynamodb.model.PutItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.RequestLimitExceededException;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+import software.amazon.awssdk.services.dynamodb.model.ScalarAttributeType;\n+import software.amazon.awssdk.services.dynamodb.model.TableStatus;\n+import software.amazon.awssdk.services.dynamodb.model.TransactionConflictException;\n+\n+/**\n+ * DynamoDB implementation for the lock manager.\n+ */\n+class DynamoLockManager extends LockManagers.LockManagerBase {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManager.class);\n+\n+  private static final String COL_LOCK_ENTITY_ID = \"entityId\";\n+  private static final String COL_LEASE_DURATION_MS = \"leaseDurationMs\";\n+  private static final String COL_VERSION = \"version\";\n+  private static final String COL_LOCK_OWNER_ID = \"ownerId\";\n+\n+  private static final String CONDITION_LOCK_ID_MATCH =\n+          COL_LOCK_ENTITY_ID + \"= :eid AND \" +\n+          COL_LOCK_OWNER_ID + \" = :oid\";\n+  private static final String CONDITION_LOCK_ENTITY_NOT_EXIST = \"attribute_not_exists(\" + COL_LOCK_ENTITY_ID + \")\";\n+  private static final String CONDITION_LOCK_ENTITY_NOT_EXIST_OR_VERSION_MATCH =\n+          \"attribute_not_exists(\" + COL_LOCK_ENTITY_ID + \") OR (\" +\n+          COL_LOCK_ENTITY_ID + \"= :eid AND \" +\n+          COL_VERSION + \"= :vid)\";\n+\n+  private static final int LOCK_TABLE_CREATION_WAIT_ATTEMPTS_MAX = 5;\n+\n+  private static final List<KeySchemaElement> LOCK_TABLE_SCHEMA = Lists.newArrayList(\n+      KeySchemaElement.builder()\n+          .attributeName(COL_LOCK_ENTITY_ID)\n+          .keyType(KeyType.HASH)\n+          .build()\n+  );\n+\n+  private static final List<AttributeDefinition> LOCK_TABLE_COL_DEFINITIONS = Lists.newArrayList(\n+      AttributeDefinition.builder()\n+          .attributeName(COL_LOCK_ENTITY_ID)\n+          .attributeType(ScalarAttributeType.S)\n+          .build()\n+  );\n+\n+  private final Map<String, ScheduledFuture<?>> heartbeats = Maps.newHashMap();\n+\n+  private DynamoDbClient dynamo;\n+  private String lockTableName;\n+\n+  /**\n+   * constructor for dynamic initialization, {@link #initialize(Map)} must be called later.\n+   */\n+  DynamoLockManager() {\n+  }\n+\n+  /**\n+   * constructor used for testing purpose\n+   * @param dynamo dynamo client\n+   * @param lockTableName lock table name\n+   */\n+  DynamoLockManager(DynamoDbClient dynamo, String lockTableName) {\n+    super.initialize(Maps.newHashMap());\n+    this.dynamo = dynamo;\n+    this.lockTableName = lockTableName;\n+    ensureLockTableExistsOrCreate();\n+  }\n+\n+  private void ensureLockTableExistsOrCreate() {\n+\n+    if (tableExists(lockTableName)) {\n+      return;\n+    }\n+\n+    LOG.info(\"Dynamo lock table {} not found, trying to create\", lockTableName);\n+    dynamo.createTable(CreateTableRequest.builder()\n+        .tableName(lockTableName)\n+        .keySchema(lockTableSchema())\n+        .attributeDefinitions(lockTableColDefinitions())\n+        .billingMode(BillingMode.PAY_PER_REQUEST)\n+        .build());\n+\n+    Tasks.foreach(lockTableName)\n+        .retry(LOCK_TABLE_CREATION_WAIT_ATTEMPTS_MAX)\n+        .throwFailureWhenFinished()\n+        .onlyRetryOn(IllegalStateException.class)\n+        .run(this::checkTableActive);\n+  }\n+\n+  @VisibleForTesting\n+  boolean tableExists(String tableName) {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(tableName)\n+          .build());\n+      return true;\n+    } catch (ResourceNotFoundException e) {\n+      return false;\n+    }\n+  }\n+\n+  private void checkTableActive(String tableName) {\n+    try {\n+      DescribeTableResponse response = dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(tableName)\n+          .build());\n+      TableStatus currentStatus = response.table().tableStatus();\n+      if (!currentStatus.equals(TableStatus.ACTIVE)) {\n+        throw new IllegalStateException(String.format(\"Dynamo table %s is not active, current status: %s\",\n+            tableName, currentStatus));\n+      }\n+    } catch (ResourceNotFoundException e) {\n+      throw new IllegalStateException(String.format(\"Cannot find Dynamo table %s\", tableName));\n+    }\n+  }\n+\n+  @Override\n+  public void initialize(Map<String, String> properties) {\n+    super.initialize(properties);\n+    this.dynamo = AwsClientFactories.from(properties).dynamo();\n+    this.lockTableName = properties.get(CatalogProperties.LOCK_TABLE);\n+    Preconditions.checkNotNull(lockTableName, \"DynamoDB lock table name must not be null\");\n+    ensureLockTableExistsOrCreate();\n+  }\n+\n+  @Override\n+  public void acquire(LockId lockId) {\n+    try {\n+      Tasks.foreach(lockId)\n+          .throwFailureWhenFinished()\n+          .retry(Integer.MAX_VALUE - 1)\n+          .exponentialBackoff(acquireIntervalMs(), acquireIntervalMs(), acquireTimeoutMs(), 1)\n+          .onlyRetryOn(\n+              ConditionalCheckFailedException.class,\n+              ProvisionedThroughputExceededException.class,\n+              TransactionConflictException.class,\n+              RequestLimitExceededException.class,\n+              InternalServerErrorException.class)\n+          .run(this::acquireOnce);\n+    } catch (RuntimeException e) {\n+      throw new LockNotAcquiredException(\"Fail to acquire lock \" + lockId, e);\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  void acquireOnce(LockId lockId) {\n+    GetItemResponse response = dynamo.getItem(GetItemRequest.builder()\n+        .tableName(lockTableName)\n+        .key(toKey(lockId))\n+        .build());\n+\n+    if (!response.hasItem()) {\n+      dynamo.putItem(PutItemRequest.builder()\n+          .tableName(lockTableName)\n+          .item(toNewItem(lockId))\n+          .conditionExpression(CONDITION_LOCK_ENTITY_NOT_EXIST)\n+          .build());\n+    } else {\n+      Map<String, AttributeValue> currentItem = response.item();\n+\n+      try {\n+        Thread.sleep(Long.parseLong(currentItem.get(COL_LEASE_DURATION_MS).n()));\n+      } catch (InterruptedException e) {\n+        throw new LockNotAcquiredException(\n+                String.format(\"Fail to acquire lock %s, interrupted during sleep\", lockId), e);\n+      }\n+\n+      Map<String, AttributeValue> expressionValues = Maps.newHashMap();\n+      expressionValues.put(\":eid\", AttributeValue.builder().s(lockId.entityId()).build());\n+      expressionValues.put(\":vid\", AttributeValue.builder().s(currentItem.get(COL_VERSION).s()).build());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d9b78176102d7cfa1234b04af780725554a74f8"}, "originalPosition": 219}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2cd14563a8e64de7e10c7e655a56fc144968314e", "author": {"user": {"login": "jackye1995", "name": "Jack Ye"}}, "url": "https://github.com/apache/iceberg/commit/2cd14563a8e64de7e10c7e655a56fc144968314e", "committedDate": "2021-01-04T18:39:10Z", "message": "remove dynamo contents"}, "afterCommit": {"oid": "02bf864b8e692b52cd0a9136e11baed9c4d5f64e", "author": {"user": {"login": "jackye1995", "name": "Jack Ye"}}, "url": "https://github.com/apache/iceberg/commit/02bf864b8e692b52cd0a9136e11baed9c4d5f64e", "committedDate": "2021-01-04T18:58:16Z", "message": "AWS: Glue catalog lock interface"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYxNDYwNTQx", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-561460541", "createdAt": "2021-01-05T01:35:30Z", "commit": {"oid": "fc214dd839b383ac592160663fbd46cabefa0c4d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQwMTozNTozMFrOIOHFbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQwMTozNTozMFrOIOHFbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTY2NzA1Mg==", "bodyText": "Why not return false?", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r551667052", "createdAt": "2021-01-05T01:35:30Z", "author": {"login": "rdblue"}, "path": "aws/src/main/java/org/apache/iceberg/aws/glue/LockManager.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.Map;\n+\n+/**\n+ * An interface for locking, used to ensure Glue catalog commit isolation.\n+ */\n+interface LockManager extends AutoCloseable {\n+\n+  /**\n+   * Try to acquire a lock\n+   * @param entityId ID of the entity to lock\n+   * @param ownerId ID of the owner if the lock\n+   * @throws LockNotAcquiredException if lock is not acquired", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc214dd839b383ac592160663fbd46cabefa0c4d"}, "originalPosition": 33}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYxNDYxNDM4", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-561461438", "createdAt": "2021-01-05T01:38:37Z", "commit": {"oid": "fc214dd839b383ac592160663fbd46cabefa0c4d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQwMTozODozOFrOIOHJhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQwMTozODozOFrOIOHJhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTY2ODEwMQ==", "bodyText": "Nit: in similar cases we use Base first, like BaseLockManager.", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r551668101", "createdAt": "2021-01-05T01:38:38Z", "author": {"login": "rdblue"}, "path": "aws/src/main/java/org/apache/iceberg/aws/glue/LockManagers.java", "diffHunk": "@@ -0,0 +1,236 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.Map;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.common.DynConstructors;\n+import org.apache.iceberg.relocated.com.google.common.annotations.VisibleForTesting;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.util.PropertyUtil;\n+import org.apache.iceberg.util.Tasks;\n+\n+class LockManagers {\n+\n+  private static final LockManager LOCK_MANAGER_DEFAULT = new InMemoryLockManager(Maps.newHashMap());\n+\n+  private LockManagers() {\n+  }\n+\n+  public static LockManager defaultLockManager() {\n+    return LOCK_MANAGER_DEFAULT;\n+  }\n+\n+  public static LockManager from(Map<String, String> properties) {\n+    if (properties.containsKey(CatalogProperties.LOCK_IMPL)) {\n+      return loadLockManager(properties.get(CatalogProperties.LOCK_IMPL), properties);\n+    } else {\n+      return defaultLockManager();\n+    }\n+  }\n+\n+  private static LockManager loadLockManager(String impl, Map<String, String> properties) {\n+    DynConstructors.Ctor<LockManager> ctor;\n+    try {\n+      ctor = DynConstructors.builder(LockManager.class).hiddenImpl(impl).buildChecked();\n+    } catch (NoSuchMethodException e) {\n+      throw new IllegalArgumentException(String.format(\n+          \"Cannot initialize LockManager, missing no-arg constructor: %s\", impl), e);\n+    }\n+\n+    LockManager lockManager;\n+    try {\n+      lockManager = ctor.newInstance();\n+    } catch (ClassCastException e) {\n+      throw new IllegalArgumentException(\n+          String.format(\"Cannot initialize LockManager, %s does not implement LockManager.\", impl), e);\n+    }\n+\n+    lockManager.initialize(properties);\n+    return lockManager;\n+  }\n+\n+  abstract static class LockManagerBase implements LockManager {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc214dd839b383ac592160663fbd46cabefa0c4d"}, "originalPosition": 74}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2270cec79b3c085654468a8ad9282dcb0437c6b7", "author": {"user": {"login": "jackye1995", "name": "Jack Ye"}}, "url": "https://github.com/apache/iceberg/commit/2270cec79b3c085654468a8ad9282dcb0437c6b7", "committedDate": "2021-01-05T06:20:50Z", "message": "AWS: Glue catalog lock interface"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fc214dd839b383ac592160663fbd46cabefa0c4d", "author": {"user": {"login": "jackye1995", "name": "Jack Ye"}}, "url": "https://github.com/apache/iceberg/commit/fc214dd839b383ac592160663fbd46cabefa0c4d", "committedDate": "2021-01-04T19:00:04Z", "message": "fix spacing"}, "afterCommit": {"oid": "2270cec79b3c085654468a8ad9282dcb0437c6b7", "author": {"user": {"login": "jackye1995", "name": "Jack Ye"}}, "url": "https://github.com/apache/iceberg/commit/2270cec79b3c085654468a8ad9282dcb0437c6b7", "committedDate": "2021-01-05T06:20:50Z", "message": "AWS: Glue catalog lock interface"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2c2822cf375b9d3473fb650d23c78106a2f10635", "author": {"user": {"login": "jackye1995", "name": "Jack Ye"}}, "url": "https://github.com/apache/iceberg/commit/2c2822cf375b9d3473fb650d23c78106a2f10635", "committedDate": "2021-01-05T06:26:06Z", "message": "update name BaseLockManager"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYxOTk1MDU0", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-561995054", "createdAt": "2021-01-05T17:39:51Z", "commit": {"oid": "2c2822cf375b9d3473fb650d23c78106a2f10635"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNzozOTo1MVrOIOgv9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNzozOTo1MVrOIOgv9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA4NzU0Mg==", "bodyText": "I think this also needs to shut down the heartbeat thread pool. That should probably be done in the base class, so probably just call super.close() here and add the shutdown there.", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r552087542", "createdAt": "2021-01-05T17:39:51Z", "author": {"login": "rdblue"}, "path": "aws/src/main/java/org/apache/iceberg/aws/glue/LockManagers.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.Map;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.common.DynConstructors;\n+import org.apache.iceberg.relocated.com.google.common.annotations.VisibleForTesting;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.util.PropertyUtil;\n+import org.apache.iceberg.util.Tasks;\n+\n+class LockManagers {\n+\n+  private static final LockManager LOCK_MANAGER_DEFAULT = new InMemoryLockManager(Maps.newHashMap());\n+\n+  private LockManagers() {\n+  }\n+\n+  public static LockManager defaultLockManager() {\n+    return LOCK_MANAGER_DEFAULT;\n+  }\n+\n+  public static LockManager from(Map<String, String> properties) {\n+    if (properties.containsKey(CatalogProperties.LOCK_IMPL)) {\n+      return loadLockManager(properties.get(CatalogProperties.LOCK_IMPL), properties);\n+    } else {\n+      return defaultLockManager();\n+    }\n+  }\n+\n+  private static LockManager loadLockManager(String impl, Map<String, String> properties) {\n+    DynConstructors.Ctor<LockManager> ctor;\n+    try {\n+      ctor = DynConstructors.builder(LockManager.class).hiddenImpl(impl).buildChecked();\n+    } catch (NoSuchMethodException e) {\n+      throw new IllegalArgumentException(String.format(\n+          \"Cannot initialize LockManager, missing no-arg constructor: %s\", impl), e);\n+    }\n+\n+    LockManager lockManager;\n+    try {\n+      lockManager = ctor.newInstance();\n+    } catch (ClassCastException e) {\n+      throw new IllegalArgumentException(\n+          String.format(\"Cannot initialize LockManager, %s does not implement LockManager.\", impl), e);\n+    }\n+\n+    lockManager.initialize(properties);\n+    return lockManager;\n+  }\n+\n+  abstract static class BaseLockManager implements LockManager {\n+\n+    private static volatile ScheduledExecutorService scheduler;\n+\n+    private long acquireTimeoutMs;\n+    private long acquireIntervalMs;\n+    private long heartbeatIntervalMs;\n+    private long heartbeatTimeoutMs;\n+    private int heartbeatThreads;\n+\n+    public long heartbeatTimeoutMs() {\n+      return heartbeatTimeoutMs;\n+    }\n+\n+    public long heartbeatIntervalMs() {\n+      return heartbeatIntervalMs;\n+    }\n+\n+    public long acquireIntervalMs() {\n+      return acquireIntervalMs;\n+    }\n+\n+    public long acquireTimeoutMs() {\n+      return acquireTimeoutMs;\n+    }\n+\n+    public int heartbeatThreads() {\n+      return heartbeatThreads;\n+    }\n+\n+    @SuppressWarnings(\"StaticGuardedByInstance\")\n+    public ScheduledExecutorService scheduler() {\n+      if (scheduler == null) {\n+        synchronized (this) {\n+          if (scheduler == null) {\n+            scheduler = Executors.newScheduledThreadPool(heartbeatThreads);\n+          }\n+        }\n+      }\n+      return scheduler;\n+    }\n+\n+    @Override\n+    public void initialize(Map<String, String> properties) {\n+      this.acquireTimeoutMs = PropertyUtil.propertyAsLong(properties,\n+          CatalogProperties.LOCK_ACQUIRE_TIMEOUT_MS, CatalogProperties.LOCK_ACQUIRE_TIMEOUT_MS_DEFAULT);\n+      this.acquireIntervalMs = PropertyUtil.propertyAsLong(properties,\n+          CatalogProperties.LOCK_ACQUIRE_INTERVAL_MS, CatalogProperties.LOCK_ACQUIRE_INTERVAL_MS_DEFAULT);\n+      this.heartbeatIntervalMs = PropertyUtil.propertyAsLong(properties,\n+          CatalogProperties.LOCK_HEARTBEAT_INTERVAL_MS, CatalogProperties.LOCK_HEARTBEAT_INTERVAL_MS_DEFAULT);\n+      this.heartbeatTimeoutMs = PropertyUtil.propertyAsLong(properties,\n+          CatalogProperties.LOCK_HEARTBEAT_TIMEOUT_MS, CatalogProperties.LOCK_HEARTBEAT_TIMEOUT_MS_DEFAULT);\n+      this.heartbeatThreads = PropertyUtil.propertyAsInt(properties,\n+          CatalogProperties.LOCK_HEARTBEAT_THREADS, CatalogProperties.LOCK_HEARTBEAT_THREADS_DEFAULT);\n+    }\n+  }\n+\n+  /**\n+   * Implementation of {@link LockManager} that uses an in-memory concurrent map for locking.\n+   * This implementation should only be used for testing,\n+   * or if the caller only needs locking within the same JVM during table commits.\n+   */\n+  static class InMemoryLockManager extends BaseLockManager {\n+\n+    private static final Map<String, DefaultLockContent> LOCKS = Maps.newConcurrentMap();\n+    private static final Map<String, ScheduledFuture<?>> HEARTBEATS = Maps.newHashMap();\n+\n+    InMemoryLockManager(Map<String, String> properties) {\n+      initialize(properties);\n+    }\n+\n+    @VisibleForTesting\n+    void acquireOnce(String entityId, String ownerId) {\n+      DefaultLockContent content = LOCKS.get(entityId);\n+      if (content != null && content.expireMs() > System.currentTimeMillis()) {\n+        throw new IllegalStateException(String.format(\"Lock for %s currently held by %s, expiration: %s\",\n+            entityId, content.ownerId(), content.expireMs()));\n+      }\n+\n+      long expiration = System.currentTimeMillis() + heartbeatTimeoutMs();\n+      boolean succeed;\n+      if (content == null) {\n+        DefaultLockContent previous = LOCKS.putIfAbsent(\n+            entityId, new DefaultLockContent(ownerId, expiration));\n+        succeed = previous == null;\n+      } else {\n+        succeed = LOCKS.replace(entityId, content, new DefaultLockContent(ownerId, expiration));\n+      }\n+\n+      if (succeed) {\n+        // cleanup old heartbeat\n+        if (HEARTBEATS.containsKey(entityId)) {\n+          HEARTBEATS.remove(entityId).cancel(false);\n+        }\n+\n+        HEARTBEATS.put(entityId, scheduler().scheduleAtFixedRate(() -> {\n+          DefaultLockContent lastContent = LOCKS.get(entityId);\n+          try {\n+            long newExpiration = System.currentTimeMillis() + heartbeatTimeoutMs();\n+            LOCKS.replace(entityId, lastContent, new DefaultLockContent(ownerId, newExpiration));\n+          } catch (NullPointerException e) {\n+            throw new RuntimeException(\"Cannot heartbeat to a deleted lock \" + entityId, e);\n+          }\n+\n+        }, 0, heartbeatIntervalMs(), TimeUnit.MILLISECONDS));\n+\n+      } else {\n+        throw new IllegalStateException(\"Unable to acquire lock \" + entityId);\n+      }\n+    }\n+\n+    @Override\n+    public boolean acquire(String entityId, String ownerId) {\n+      try {\n+        Tasks.foreach(entityId)\n+            .retry(Integer.MAX_VALUE - 1)\n+            .onlyRetryOn(IllegalStateException.class)\n+            .throwFailureWhenFinished()\n+            .exponentialBackoff(acquireIntervalMs(), acquireIntervalMs(), acquireTimeoutMs(), 1)\n+            .run(id -> acquireOnce(id, ownerId));\n+        return true;\n+      } catch (IllegalStateException e) {\n+        return false;\n+      }\n+    }\n+\n+    @Override\n+    public void release(String entityId, String ownerId) {\n+      DefaultLockContent currentContent = LOCKS.get(entityId);\n+      if (currentContent == null) {\n+        throw new IllegalArgumentException(\"Cannot find lock for entity \" + entityId);\n+      }\n+\n+      if (!currentContent.ownerId().equals(ownerId)) {\n+        throw new IllegalArgumentException(String.format(\n+            \"Cannot unlock %s by %s, current owner: %s\", entityId, ownerId, currentContent.ownerId()));\n+      }\n+      HEARTBEATS.remove(entityId).cancel(false);\n+      LOCKS.remove(entityId);\n+    }\n+\n+    @Override\n+    public void close() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c2822cf375b9d3473fb650d23c78106a2f10635"}, "originalPosition": 216}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyMDAxOTE4", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-562001918", "createdAt": "2021-01-05T17:49:19Z", "commit": {"oid": "2c2822cf375b9d3473fb650d23c78106a2f10635"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNzo0OToxOVrOIOhEzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNzo0OToxOVrOIOhEzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA5Mjg3Ng==", "bodyText": "Because this locks in the try block, the finally will be called when the lock fails. I think that's correct for cleaning up the metadata location, but the lock release will currently fail because the lock isn't held by this thread. That will cause the lock failure exception to get replaced by the unlock failure.\nI think the solution is to not throw exceptions in release. I'll comment on that below.", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r552092876", "createdAt": "2021-01-05T17:49:19Z", "author": {"login": "rdblue"}, "path": "aws/src/main/java/org/apache/iceberg/aws/glue/GlueTableOperations.java", "diffHunk": "@@ -100,10 +104,11 @@ protected void doRefresh() {\n   protected void doCommit(TableMetadata base, TableMetadata metadata) {\n     String newMetadataLocation = writeNewMetadata(metadata, currentVersion() + 1);\n     boolean exceptionThrown = true;\n-    Table glueTable = getGlueTable();\n-    checkMetadataLocation(glueTable, base);\n-    Map<String, String> properties = prepareProperties(glueTable, newMetadataLocation);\n     try {\n+      lock(newMetadataLocation);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c2822cf375b9d3473fb650d23c78106a2f10635"}, "originalPosition": 30}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e46fba906da05f1efd990e3301e36089b336fef3", "author": {"user": {"login": "jackye1995", "name": "Jack Ye"}}, "url": "https://github.com/apache/iceberg/commit/e46fba906da05f1efd990e3301e36089b336fef3", "committedDate": "2021-01-05T17:58:36Z", "message": "use ExitingScheduledExecutorService"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyMDExNjUx", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-562011651", "createdAt": "2021-01-05T18:02:37Z", "commit": {"oid": "2c2822cf375b9d3473fb650d23c78106a2f10635"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxODowMjozN1rOIOhiSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxODowMjozN1rOIOhiSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEwMDQyNw==", "bodyText": "IllegalArgumentException isn't quite right. The argument is correct, it is the lock state that is the problem. IllegalStateException is a better one to throw for this and the next case.\nWe also need to consider what this exception would cause if thrown. The release method is currently called in a finally block so if it throws an exception, it will replace the real failure. I noted that above where if the lock can't be acquired, either this or the next check's exception will be thrown.\nIn addition to that problem, a failure here could cause duplicate data. If the table state is updated, then success must be reported back. If not, then it is very likely that the operation will retry at some level and there is no guarantee that the operation is idempotent. For example, a writer moving data from Kafka to an Iceberg table will append data. If a checkpoint commit fails, it will retry. If the failure happened after the commit actually succeeded, then the append will be done twice causing duplicate data in the table.\nMost of the time, a failure like that would cause the metadata file that was to be committed to be deleted, which ends up locking up the table. But this unlock happens after the delete would happen, so the table would appear correct but the operation would probably retry.\nI think the solution to these problems is to make this log the error and return a boolean. If the lock was held and released, return true. If it was not held, then return false. That way the caller can decide how to handle it. And we should log the error messages you have here for context.", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r552100427", "createdAt": "2021-01-05T18:02:37Z", "author": {"login": "rdblue"}, "path": "aws/src/main/java/org/apache/iceberg/aws/glue/LockManagers.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.Map;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.common.DynConstructors;\n+import org.apache.iceberg.relocated.com.google.common.annotations.VisibleForTesting;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.util.PropertyUtil;\n+import org.apache.iceberg.util.Tasks;\n+\n+class LockManagers {\n+\n+  private static final LockManager LOCK_MANAGER_DEFAULT = new InMemoryLockManager(Maps.newHashMap());\n+\n+  private LockManagers() {\n+  }\n+\n+  public static LockManager defaultLockManager() {\n+    return LOCK_MANAGER_DEFAULT;\n+  }\n+\n+  public static LockManager from(Map<String, String> properties) {\n+    if (properties.containsKey(CatalogProperties.LOCK_IMPL)) {\n+      return loadLockManager(properties.get(CatalogProperties.LOCK_IMPL), properties);\n+    } else {\n+      return defaultLockManager();\n+    }\n+  }\n+\n+  private static LockManager loadLockManager(String impl, Map<String, String> properties) {\n+    DynConstructors.Ctor<LockManager> ctor;\n+    try {\n+      ctor = DynConstructors.builder(LockManager.class).hiddenImpl(impl).buildChecked();\n+    } catch (NoSuchMethodException e) {\n+      throw new IllegalArgumentException(String.format(\n+          \"Cannot initialize LockManager, missing no-arg constructor: %s\", impl), e);\n+    }\n+\n+    LockManager lockManager;\n+    try {\n+      lockManager = ctor.newInstance();\n+    } catch (ClassCastException e) {\n+      throw new IllegalArgumentException(\n+          String.format(\"Cannot initialize LockManager, %s does not implement LockManager.\", impl), e);\n+    }\n+\n+    lockManager.initialize(properties);\n+    return lockManager;\n+  }\n+\n+  abstract static class BaseLockManager implements LockManager {\n+\n+    private static volatile ScheduledExecutorService scheduler;\n+\n+    private long acquireTimeoutMs;\n+    private long acquireIntervalMs;\n+    private long heartbeatIntervalMs;\n+    private long heartbeatTimeoutMs;\n+    private int heartbeatThreads;\n+\n+    public long heartbeatTimeoutMs() {\n+      return heartbeatTimeoutMs;\n+    }\n+\n+    public long heartbeatIntervalMs() {\n+      return heartbeatIntervalMs;\n+    }\n+\n+    public long acquireIntervalMs() {\n+      return acquireIntervalMs;\n+    }\n+\n+    public long acquireTimeoutMs() {\n+      return acquireTimeoutMs;\n+    }\n+\n+    public int heartbeatThreads() {\n+      return heartbeatThreads;\n+    }\n+\n+    @SuppressWarnings(\"StaticGuardedByInstance\")\n+    public ScheduledExecutorService scheduler() {\n+      if (scheduler == null) {\n+        synchronized (this) {\n+          if (scheduler == null) {\n+            scheduler = Executors.newScheduledThreadPool(heartbeatThreads);\n+          }\n+        }\n+      }\n+      return scheduler;\n+    }\n+\n+    @Override\n+    public void initialize(Map<String, String> properties) {\n+      this.acquireTimeoutMs = PropertyUtil.propertyAsLong(properties,\n+          CatalogProperties.LOCK_ACQUIRE_TIMEOUT_MS, CatalogProperties.LOCK_ACQUIRE_TIMEOUT_MS_DEFAULT);\n+      this.acquireIntervalMs = PropertyUtil.propertyAsLong(properties,\n+          CatalogProperties.LOCK_ACQUIRE_INTERVAL_MS, CatalogProperties.LOCK_ACQUIRE_INTERVAL_MS_DEFAULT);\n+      this.heartbeatIntervalMs = PropertyUtil.propertyAsLong(properties,\n+          CatalogProperties.LOCK_HEARTBEAT_INTERVAL_MS, CatalogProperties.LOCK_HEARTBEAT_INTERVAL_MS_DEFAULT);\n+      this.heartbeatTimeoutMs = PropertyUtil.propertyAsLong(properties,\n+          CatalogProperties.LOCK_HEARTBEAT_TIMEOUT_MS, CatalogProperties.LOCK_HEARTBEAT_TIMEOUT_MS_DEFAULT);\n+      this.heartbeatThreads = PropertyUtil.propertyAsInt(properties,\n+          CatalogProperties.LOCK_HEARTBEAT_THREADS, CatalogProperties.LOCK_HEARTBEAT_THREADS_DEFAULT);\n+    }\n+  }\n+\n+  /**\n+   * Implementation of {@link LockManager} that uses an in-memory concurrent map for locking.\n+   * This implementation should only be used for testing,\n+   * or if the caller only needs locking within the same JVM during table commits.\n+   */\n+  static class InMemoryLockManager extends BaseLockManager {\n+\n+    private static final Map<String, DefaultLockContent> LOCKS = Maps.newConcurrentMap();\n+    private static final Map<String, ScheduledFuture<?>> HEARTBEATS = Maps.newHashMap();\n+\n+    InMemoryLockManager(Map<String, String> properties) {\n+      initialize(properties);\n+    }\n+\n+    @VisibleForTesting\n+    void acquireOnce(String entityId, String ownerId) {\n+      DefaultLockContent content = LOCKS.get(entityId);\n+      if (content != null && content.expireMs() > System.currentTimeMillis()) {\n+        throw new IllegalStateException(String.format(\"Lock for %s currently held by %s, expiration: %s\",\n+            entityId, content.ownerId(), content.expireMs()));\n+      }\n+\n+      long expiration = System.currentTimeMillis() + heartbeatTimeoutMs();\n+      boolean succeed;\n+      if (content == null) {\n+        DefaultLockContent previous = LOCKS.putIfAbsent(\n+            entityId, new DefaultLockContent(ownerId, expiration));\n+        succeed = previous == null;\n+      } else {\n+        succeed = LOCKS.replace(entityId, content, new DefaultLockContent(ownerId, expiration));\n+      }\n+\n+      if (succeed) {\n+        // cleanup old heartbeat\n+        if (HEARTBEATS.containsKey(entityId)) {\n+          HEARTBEATS.remove(entityId).cancel(false);\n+        }\n+\n+        HEARTBEATS.put(entityId, scheduler().scheduleAtFixedRate(() -> {\n+          DefaultLockContent lastContent = LOCKS.get(entityId);\n+          try {\n+            long newExpiration = System.currentTimeMillis() + heartbeatTimeoutMs();\n+            LOCKS.replace(entityId, lastContent, new DefaultLockContent(ownerId, newExpiration));\n+          } catch (NullPointerException e) {\n+            throw new RuntimeException(\"Cannot heartbeat to a deleted lock \" + entityId, e);\n+          }\n+\n+        }, 0, heartbeatIntervalMs(), TimeUnit.MILLISECONDS));\n+\n+      } else {\n+        throw new IllegalStateException(\"Unable to acquire lock \" + entityId);\n+      }\n+    }\n+\n+    @Override\n+    public boolean acquire(String entityId, String ownerId) {\n+      try {\n+        Tasks.foreach(entityId)\n+            .retry(Integer.MAX_VALUE - 1)\n+            .onlyRetryOn(IllegalStateException.class)\n+            .throwFailureWhenFinished()\n+            .exponentialBackoff(acquireIntervalMs(), acquireIntervalMs(), acquireTimeoutMs(), 1)\n+            .run(id -> acquireOnce(id, ownerId));\n+        return true;\n+      } catch (IllegalStateException e) {\n+        return false;\n+      }\n+    }\n+\n+    @Override\n+    public void release(String entityId, String ownerId) {\n+      DefaultLockContent currentContent = LOCKS.get(entityId);\n+      if (currentContent == null) {\n+        throw new IllegalArgumentException(\"Cannot find lock for entity \" + entityId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c2822cf375b9d3473fb650d23c78106a2f10635"}, "originalPosition": 204}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyMDEyODA1", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-562012805", "createdAt": "2021-01-05T18:04:19Z", "commit": {"oid": "2c2822cf375b9d3473fb650d23c78106a2f10635"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxODowNDoxOVrOIOhlog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxODowNDoxOVrOIOhlog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEwMTI4Mg==", "bodyText": "I'm fine with including this in the implementation, but it doesn't seem to me that there are that many cases where an internal heartbeat helps. If the thread that owns the lock fails, the heartbeat thread will continue to live. So the heartbeat is really a process heartbeat. And because the locks are all process-local anyway there isn't much value.", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r552101282", "createdAt": "2021-01-05T18:04:19Z", "author": {"login": "rdblue"}, "path": "aws/src/main/java/org/apache/iceberg/aws/glue/LockManagers.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.Map;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.common.DynConstructors;\n+import org.apache.iceberg.relocated.com.google.common.annotations.VisibleForTesting;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.util.PropertyUtil;\n+import org.apache.iceberg.util.Tasks;\n+\n+class LockManagers {\n+\n+  private static final LockManager LOCK_MANAGER_DEFAULT = new InMemoryLockManager(Maps.newHashMap());\n+\n+  private LockManagers() {\n+  }\n+\n+  public static LockManager defaultLockManager() {\n+    return LOCK_MANAGER_DEFAULT;\n+  }\n+\n+  public static LockManager from(Map<String, String> properties) {\n+    if (properties.containsKey(CatalogProperties.LOCK_IMPL)) {\n+      return loadLockManager(properties.get(CatalogProperties.LOCK_IMPL), properties);\n+    } else {\n+      return defaultLockManager();\n+    }\n+  }\n+\n+  private static LockManager loadLockManager(String impl, Map<String, String> properties) {\n+    DynConstructors.Ctor<LockManager> ctor;\n+    try {\n+      ctor = DynConstructors.builder(LockManager.class).hiddenImpl(impl).buildChecked();\n+    } catch (NoSuchMethodException e) {\n+      throw new IllegalArgumentException(String.format(\n+          \"Cannot initialize LockManager, missing no-arg constructor: %s\", impl), e);\n+    }\n+\n+    LockManager lockManager;\n+    try {\n+      lockManager = ctor.newInstance();\n+    } catch (ClassCastException e) {\n+      throw new IllegalArgumentException(\n+          String.format(\"Cannot initialize LockManager, %s does not implement LockManager.\", impl), e);\n+    }\n+\n+    lockManager.initialize(properties);\n+    return lockManager;\n+  }\n+\n+  abstract static class BaseLockManager implements LockManager {\n+\n+    private static volatile ScheduledExecutorService scheduler;\n+\n+    private long acquireTimeoutMs;\n+    private long acquireIntervalMs;\n+    private long heartbeatIntervalMs;\n+    private long heartbeatTimeoutMs;\n+    private int heartbeatThreads;\n+\n+    public long heartbeatTimeoutMs() {\n+      return heartbeatTimeoutMs;\n+    }\n+\n+    public long heartbeatIntervalMs() {\n+      return heartbeatIntervalMs;\n+    }\n+\n+    public long acquireIntervalMs() {\n+      return acquireIntervalMs;\n+    }\n+\n+    public long acquireTimeoutMs() {\n+      return acquireTimeoutMs;\n+    }\n+\n+    public int heartbeatThreads() {\n+      return heartbeatThreads;\n+    }\n+\n+    @SuppressWarnings(\"StaticGuardedByInstance\")\n+    public ScheduledExecutorService scheduler() {\n+      if (scheduler == null) {\n+        synchronized (this) {\n+          if (scheduler == null) {\n+            scheduler = Executors.newScheduledThreadPool(heartbeatThreads);\n+          }\n+        }\n+      }\n+      return scheduler;\n+    }\n+\n+    @Override\n+    public void initialize(Map<String, String> properties) {\n+      this.acquireTimeoutMs = PropertyUtil.propertyAsLong(properties,\n+          CatalogProperties.LOCK_ACQUIRE_TIMEOUT_MS, CatalogProperties.LOCK_ACQUIRE_TIMEOUT_MS_DEFAULT);\n+      this.acquireIntervalMs = PropertyUtil.propertyAsLong(properties,\n+          CatalogProperties.LOCK_ACQUIRE_INTERVAL_MS, CatalogProperties.LOCK_ACQUIRE_INTERVAL_MS_DEFAULT);\n+      this.heartbeatIntervalMs = PropertyUtil.propertyAsLong(properties,\n+          CatalogProperties.LOCK_HEARTBEAT_INTERVAL_MS, CatalogProperties.LOCK_HEARTBEAT_INTERVAL_MS_DEFAULT);\n+      this.heartbeatTimeoutMs = PropertyUtil.propertyAsLong(properties,\n+          CatalogProperties.LOCK_HEARTBEAT_TIMEOUT_MS, CatalogProperties.LOCK_HEARTBEAT_TIMEOUT_MS_DEFAULT);\n+      this.heartbeatThreads = PropertyUtil.propertyAsInt(properties,\n+          CatalogProperties.LOCK_HEARTBEAT_THREADS, CatalogProperties.LOCK_HEARTBEAT_THREADS_DEFAULT);\n+    }\n+  }\n+\n+  /**\n+   * Implementation of {@link LockManager} that uses an in-memory concurrent map for locking.\n+   * This implementation should only be used for testing,\n+   * or if the caller only needs locking within the same JVM during table commits.\n+   */\n+  static class InMemoryLockManager extends BaseLockManager {\n+\n+    private static final Map<String, DefaultLockContent> LOCKS = Maps.newConcurrentMap();\n+    private static final Map<String, ScheduledFuture<?>> HEARTBEATS = Maps.newHashMap();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c2822cf375b9d3473fb650d23c78106a2f10635"}, "originalPosition": 139}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyMDE0ODEy", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-562014812", "createdAt": "2021-01-05T18:07:10Z", "commit": {"oid": "2c2822cf375b9d3473fb650d23c78106a2f10635"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxODowNzoxMFrOIOhrqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxODowNzoxMFrOIOhrqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEwMjgyNA==", "bodyText": "I noted this below, but I think this pool needs to be shut down.\nWe also need to ensure that the threads are named and are daemon threads. That ensures that the JVM can exit even if this isn't shut down cleanly and naming helps when trying to debug what is happening in a process. To do that you just need to pass a thread factory, which you can create like this:\nimport org.apache.iceberg.relocated.com.google.common.util.concurrent.ThreadFactoryBuilder;\n...\n          new ThreadFactoryBuilder()\n              .setDaemon(true)\n              .setNameFormat(String.format(\"%s-heartbeat-pool-%d\"), this)\n              .build()", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r552102824", "createdAt": "2021-01-05T18:07:10Z", "author": {"login": "rdblue"}, "path": "aws/src/main/java/org/apache/iceberg/aws/glue/LockManagers.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.Map;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.common.DynConstructors;\n+import org.apache.iceberg.relocated.com.google.common.annotations.VisibleForTesting;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.util.PropertyUtil;\n+import org.apache.iceberg.util.Tasks;\n+\n+class LockManagers {\n+\n+  private static final LockManager LOCK_MANAGER_DEFAULT = new InMemoryLockManager(Maps.newHashMap());\n+\n+  private LockManagers() {\n+  }\n+\n+  public static LockManager defaultLockManager() {\n+    return LOCK_MANAGER_DEFAULT;\n+  }\n+\n+  public static LockManager from(Map<String, String> properties) {\n+    if (properties.containsKey(CatalogProperties.LOCK_IMPL)) {\n+      return loadLockManager(properties.get(CatalogProperties.LOCK_IMPL), properties);\n+    } else {\n+      return defaultLockManager();\n+    }\n+  }\n+\n+  private static LockManager loadLockManager(String impl, Map<String, String> properties) {\n+    DynConstructors.Ctor<LockManager> ctor;\n+    try {\n+      ctor = DynConstructors.builder(LockManager.class).hiddenImpl(impl).buildChecked();\n+    } catch (NoSuchMethodException e) {\n+      throw new IllegalArgumentException(String.format(\n+          \"Cannot initialize LockManager, missing no-arg constructor: %s\", impl), e);\n+    }\n+\n+    LockManager lockManager;\n+    try {\n+      lockManager = ctor.newInstance();\n+    } catch (ClassCastException e) {\n+      throw new IllegalArgumentException(\n+          String.format(\"Cannot initialize LockManager, %s does not implement LockManager.\", impl), e);\n+    }\n+\n+    lockManager.initialize(properties);\n+    return lockManager;\n+  }\n+\n+  abstract static class BaseLockManager implements LockManager {\n+\n+    private static volatile ScheduledExecutorService scheduler;\n+\n+    private long acquireTimeoutMs;\n+    private long acquireIntervalMs;\n+    private long heartbeatIntervalMs;\n+    private long heartbeatTimeoutMs;\n+    private int heartbeatThreads;\n+\n+    public long heartbeatTimeoutMs() {\n+      return heartbeatTimeoutMs;\n+    }\n+\n+    public long heartbeatIntervalMs() {\n+      return heartbeatIntervalMs;\n+    }\n+\n+    public long acquireIntervalMs() {\n+      return acquireIntervalMs;\n+    }\n+\n+    public long acquireTimeoutMs() {\n+      return acquireTimeoutMs;\n+    }\n+\n+    public int heartbeatThreads() {\n+      return heartbeatThreads;\n+    }\n+\n+    @SuppressWarnings(\"StaticGuardedByInstance\")\n+    public ScheduledExecutorService scheduler() {\n+      if (scheduler == null) {\n+        synchronized (this) {\n+          if (scheduler == null) {\n+            scheduler = Executors.newScheduledThreadPool(heartbeatThreads);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c2822cf375b9d3473fb650d23c78106a2f10635"}, "originalPosition": 109}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyMDE2MzE5", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-562016319", "createdAt": "2021-01-05T18:09:24Z", "commit": {"oid": "e46fba906da05f1efd990e3301e36089b336fef3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxODowOToyNVrOIOhwhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxODowOToyNVrOIOhwhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEwNDA2OQ==", "bodyText": "Because this isn't a static method, this is the instance of the lock manager, so it doesn't really protect creation of the thread pool. I think you'd need to lock on BaseLockManager.class or some other static shared object.", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r552104069", "createdAt": "2021-01-05T18:09:25Z", "author": {"login": "rdblue"}, "path": "aws/src/main/java/org/apache/iceberg/aws/glue/LockManagers.java", "diffHunk": "@@ -0,0 +1,250 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.Map;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.common.DynConstructors;\n+import org.apache.iceberg.relocated.com.google.common.annotations.VisibleForTesting;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.relocated.com.google.common.util.concurrent.MoreExecutors;\n+import org.apache.iceberg.relocated.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import org.apache.iceberg.util.PropertyUtil;\n+import org.apache.iceberg.util.Tasks;\n+\n+class LockManagers {\n+\n+  private static final LockManager LOCK_MANAGER_DEFAULT = new InMemoryLockManager(Maps.newHashMap());\n+\n+  private LockManagers() {\n+  }\n+\n+  public static LockManager defaultLockManager() {\n+    return LOCK_MANAGER_DEFAULT;\n+  }\n+\n+  public static LockManager from(Map<String, String> properties) {\n+    if (properties.containsKey(CatalogProperties.LOCK_IMPL)) {\n+      return loadLockManager(properties.get(CatalogProperties.LOCK_IMPL), properties);\n+    } else {\n+      return defaultLockManager();\n+    }\n+  }\n+\n+  private static LockManager loadLockManager(String impl, Map<String, String> properties) {\n+    DynConstructors.Ctor<LockManager> ctor;\n+    try {\n+      ctor = DynConstructors.builder(LockManager.class).hiddenImpl(impl).buildChecked();\n+    } catch (NoSuchMethodException e) {\n+      throw new IllegalArgumentException(String.format(\n+          \"Cannot initialize LockManager, missing no-arg constructor: %s\", impl), e);\n+    }\n+\n+    LockManager lockManager;\n+    try {\n+      lockManager = ctor.newInstance();\n+    } catch (ClassCastException e) {\n+      throw new IllegalArgumentException(\n+          String.format(\"Cannot initialize LockManager, %s does not implement LockManager.\", impl), e);\n+    }\n+\n+    lockManager.initialize(properties);\n+    return lockManager;\n+  }\n+\n+  abstract static class BaseLockManager implements LockManager {\n+\n+    private static volatile ScheduledExecutorService scheduler;\n+\n+    private long acquireTimeoutMs;\n+    private long acquireIntervalMs;\n+    private long heartbeatIntervalMs;\n+    private long heartbeatTimeoutMs;\n+    private int heartbeatThreads;\n+\n+    public long heartbeatTimeoutMs() {\n+      return heartbeatTimeoutMs;\n+    }\n+\n+    public long heartbeatIntervalMs() {\n+      return heartbeatIntervalMs;\n+    }\n+\n+    public long acquireIntervalMs() {\n+      return acquireIntervalMs;\n+    }\n+\n+    public long acquireTimeoutMs() {\n+      return acquireTimeoutMs;\n+    }\n+\n+    public int heartbeatThreads() {\n+      return heartbeatThreads;\n+    }\n+\n+    @SuppressWarnings(\"StaticGuardedByInstance\")\n+    public ScheduledExecutorService scheduler() {\n+      if (scheduler == null) {\n+        synchronized (this) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e46fba906da05f1efd990e3301e36089b336fef3"}, "originalPosition": 110}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyMDE4ODE5", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-562018819", "createdAt": "2021-01-05T18:12:58Z", "commit": {"oid": "e46fba906da05f1efd990e3301e36089b336fef3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxODoxMjo1OFrOIOh33Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxODoxMjo1OFrOIOh33Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEwNTk0OQ==", "bodyText": "If this is going to call private methods in lock manager, then I think it would be good to validate that the entity is actually locked. This test would pass with an empty implementation of acquireOnce.", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r552105949", "createdAt": "2021-01-05T18:12:58Z", "author": {"login": "rdblue"}, "path": "aws/src/test/java/org/apache/iceberg/aws/glue/InMemoryLockManagerTest.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class InMemoryLockManagerTest {\n+\n+  private LockManagers.InMemoryLockManager lockManager;\n+  private String lockEntityId;\n+  private String ownerId;\n+\n+  @Before\n+  public void before() {\n+    lockEntityId = UUID.randomUUID().toString();\n+    ownerId = UUID.randomUUID().toString();\n+    lockManager = new LockManagers.InMemoryLockManager(Maps.newHashMap());\n+  }\n+\n+  @After\n+  public void after() {\n+    lockManager.close();\n+  }\n+\n+  @Test\n+  public void testAcquireOnce_singleProcess() {\n+    lockManager.acquireOnce(lockEntityId, ownerId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e46fba906da05f1efd990e3301e36089b336fef3"}, "originalPosition": 56}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyMDE5NDI0", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-562019424", "createdAt": "2021-01-05T18:13:50Z", "commit": {"oid": "e46fba906da05f1efd990e3301e36089b336fef3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxODoxMzo1MFrOIOh5yQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxODoxMzo1MFrOIOh5yQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEwNjQ0MQ==", "bodyText": "This test would also pass with an empty implementation.", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r552106441", "createdAt": "2021-01-05T18:13:50Z", "author": {"login": "rdblue"}, "path": "aws/src/test/java/org/apache/iceberg/aws/glue/InMemoryLockManagerTest.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class InMemoryLockManagerTest {\n+\n+  private LockManagers.InMemoryLockManager lockManager;\n+  private String lockEntityId;\n+  private String ownerId;\n+\n+  @Before\n+  public void before() {\n+    lockEntityId = UUID.randomUUID().toString();\n+    ownerId = UUID.randomUUID().toString();\n+    lockManager = new LockManagers.InMemoryLockManager(Maps.newHashMap());\n+  }\n+\n+  @After\n+  public void after() {\n+    lockManager.close();\n+  }\n+\n+  @Test\n+  public void testAcquireOnce_singleProcess() {\n+    lockManager.acquireOnce(lockEntityId, ownerId);\n+  }\n+\n+  @Test\n+  public void testAcquireOnce_multiProcess() {\n+    List<Boolean> results = IntStream.range(0, 10).parallel()\n+        .mapToObj(i -> {\n+          try {\n+            lockManager.acquireOnce(lockEntityId, ownerId);\n+            return true;\n+          } catch (IllegalStateException e) {\n+            return false;\n+          }\n+        })\n+        .collect(Collectors.toList());\n+    Assert.assertEquals(\n+        \"only 1 thread should have acquired the lock\",\n+        1, results.stream().filter(s -> s).count());\n+  }\n+\n+  @Test\n+  public void testReleaseAndAcquire() {\n+    Assert.assertTrue(lockManager.acquire(lockEntityId, ownerId));\n+    lockManager.release(lockEntityId, ownerId);\n+    Assert.assertTrue(lockManager.acquire(lockEntityId, ownerId));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e46fba906da05f1efd990e3301e36089b336fef3"}, "originalPosition": 80}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyMDIwMzI1", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-562020325", "createdAt": "2021-01-05T18:14:52Z", "commit": {"oid": "e46fba906da05f1efd990e3301e36089b336fef3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxODoxNDo1MlrOIOh8GQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxODoxNDo1MlrOIOh8GQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEwNzAzMw==", "bodyText": "How long does this take to run? It seems like a good idea to use some settings to avoid long runtimes. What about setting the timeout to 1s or something?", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r552107033", "createdAt": "2021-01-05T18:14:52Z", "author": {"login": "rdblue"}, "path": "aws/src/test/java/org/apache/iceberg/aws/glue/InMemoryLockManagerTest.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class InMemoryLockManagerTest {\n+\n+  private LockManagers.InMemoryLockManager lockManager;\n+  private String lockEntityId;\n+  private String ownerId;\n+\n+  @Before\n+  public void before() {\n+    lockEntityId = UUID.randomUUID().toString();\n+    ownerId = UUID.randomUUID().toString();\n+    lockManager = new LockManagers.InMemoryLockManager(Maps.newHashMap());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e46fba906da05f1efd990e3301e36089b336fef3"}, "originalPosition": 46}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyMDIxNTc4", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-562021578", "createdAt": "2021-01-05T18:15:55Z", "commit": {"oid": "e46fba906da05f1efd990e3301e36089b336fef3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxODoxNTo1NVrOIOiAFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxODoxNTo1NVrOIOiAFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEwODA1Mw==", "bodyText": "Can you make this interval shorter? 5s is a long time to wait. 200ms would do fine.", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r552108053", "createdAt": "2021-01-05T18:15:55Z", "author": {"login": "rdblue"}, "path": "aws/src/test/java/org/apache/iceberg/aws/glue/InMemoryLockManagerTest.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class InMemoryLockManagerTest {\n+\n+  private LockManagers.InMemoryLockManager lockManager;\n+  private String lockEntityId;\n+  private String ownerId;\n+\n+  @Before\n+  public void before() {\n+    lockEntityId = UUID.randomUUID().toString();\n+    ownerId = UUID.randomUUID().toString();\n+    lockManager = new LockManagers.InMemoryLockManager(Maps.newHashMap());\n+  }\n+\n+  @After\n+  public void after() {\n+    lockManager.close();\n+  }\n+\n+  @Test\n+  public void testAcquireOnce_singleProcess() {\n+    lockManager.acquireOnce(lockEntityId, ownerId);\n+  }\n+\n+  @Test\n+  public void testAcquireOnce_multiProcess() {\n+    List<Boolean> results = IntStream.range(0, 10).parallel()\n+        .mapToObj(i -> {\n+          try {\n+            lockManager.acquireOnce(lockEntityId, ownerId);\n+            return true;\n+          } catch (IllegalStateException e) {\n+            return false;\n+          }\n+        })\n+        .collect(Collectors.toList());\n+    Assert.assertEquals(\n+        \"only 1 thread should have acquired the lock\",\n+        1, results.stream().filter(s -> s).count());\n+  }\n+\n+  @Test\n+  public void testReleaseAndAcquire() {\n+    Assert.assertTrue(lockManager.acquire(lockEntityId, ownerId));\n+    lockManager.release(lockEntityId, ownerId);\n+    Assert.assertTrue(lockManager.acquire(lockEntityId, ownerId));\n+  }\n+\n+  @Test\n+  public void testReleaseWithWrongOwner() {\n+    Assert.assertTrue(lockManager.acquire(lockEntityId, ownerId));\n+    AssertHelpers.assertThrows(\"should throw exception if ownerId is wrong\",\n+        IllegalArgumentException.class,\n+        \"current owner\",\n+        () -> lockManager.release(lockEntityId, UUID.randomUUID().toString()));\n+  }\n+\n+  @Test\n+  public void testAcquire_singleProcess() throws Exception {\n+    Assert.assertTrue(lockManager.acquire(lockEntityId, ownerId));\n+    String oldOwner = ownerId;\n+\n+    CompletableFuture.supplyAsync(() -> {\n+      try {\n+        Thread.sleep(5000);\n+      } catch (InterruptedException e) {\n+        throw new RuntimeException(e);\n+      }\n+      lockManager.release(lockEntityId, oldOwner);\n+      return null;\n+    });\n+\n+    ownerId = UUID.randomUUID().toString();\n+    long start = System.currentTimeMillis();\n+    Assert.assertTrue(lockManager.acquire(lockEntityId, ownerId));\n+    Assert.assertTrue(\"should succeed after 5 seconds\",\n+        System.currentTimeMillis() - start >= 5000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e46fba906da05f1efd990e3301e36089b336fef3"}, "originalPosition": 111}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4b953d3be031948520700b86b98e63f6b5674a49", "author": {"user": {"login": "jackye1995", "name": "Jack Ye"}}, "url": "https://github.com/apache/iceberg/commit/4b953d3be031948520700b86b98e63f6b5674a49", "committedDate": "2021-01-05T19:49:02Z", "message": "update tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyMTI4NTE3", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-562128517", "createdAt": "2021-01-05T21:00:39Z", "commit": {"oid": "4b953d3be031948520700b86b98e63f6b5674a49"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQyMTowMDozOVrOIOnGPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQyMTowMDozOVrOIOnGPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE5MTU0OA==", "bodyText": "This isn't quite correct. It should return true if the lock was held and released, and false otherwise. This should also note that the contract requires not throwing exceptions from this method.", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r552191548", "createdAt": "2021-01-05T21:00:39Z", "author": {"login": "rdblue"}, "path": "aws/src/main/java/org/apache/iceberg/aws/glue/LockManager.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.Map;\n+\n+/**\n+ * An interface for locking, used to ensure Glue catalog commit isolation.\n+ */\n+interface LockManager extends AutoCloseable {\n+\n+  /**\n+   * Try to acquire a lock\n+   * @param entityId ID of the entity to lock\n+   * @param ownerId ID of the owner if the lock\n+   * @return if the lock for the entity is acquired by the owner\n+   */\n+  boolean acquire(String entityId, String ownerId);\n+\n+  /**\n+   * Release a lock\n+   * @param entityId ID of the entity to lock\n+   * @param ownerId ID of the owner if the lock\n+   * @return if the lock for the entity of the owner is released", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b953d3be031948520700b86b98e63f6b5674a49"}, "originalPosition": 41}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyMTMwODk0", "url": "https://github.com/apache/iceberg/pull/1823#pullrequestreview-562130894", "createdAt": "2021-01-05T21:04:24Z", "commit": {"oid": "4b953d3be031948520700b86b98e63f6b5674a49"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3419, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}