{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMyMjUyNDQw", "number": 1873, "title": "Hive: Make lock check retries backoff exponentially", "bodyText": "50 milliseconds (constant) sleep time between \"checking lock status\" thrashes hive metastore databases when multiple jobs try to commit to the same Iceberg table. This fix allows the frequency of \"checking the WAITING lock status\" configurable and makes use of Tasks to backoff exponentially.\nEvery time a check on the lock is made, the HMS performs heartbeats on the lock record and the transaction record. It eventually ends up with the below errors if the number of jobs on the same table grew and commit at the same time. Ability to configure the delay between retries and slowing down retries further exponentially would help. Thanks.\nMetaException(message:Unable to update transaction database org.postgresql.util.PSQLException: ERROR: could not serialize access due to read/write dependencies among transactions\nDetail: Reason code: Canceled on identification as a pivot, during write.\nHint: The transaction might succeed if retried.", "createdAt": "2020-12-04T03:09:46Z", "url": "https://github.com/apache/iceberg/pull/1873", "merged": true, "mergeCommit": {"oid": "2cea824588bf6cdb313c288dc048727611bd7e3d"}, "closed": true, "closedAt": "2020-12-10T18:01:23Z", "author": {"login": "raptond"}, "timelineItems": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdiznA9AFqTU0NDc1MTQ0MA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdk3PlzgFqTU0OTQ2Mzc1NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0NzUxNDQw", "url": "https://github.com/apache/iceberg/pull/1873#pullrequestreview-544751440", "createdAt": "2020-12-04T08:38:25Z", "commit": {"oid": "b201863396dd365ec64d33a43aefa776e23c1cde"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwODozODoyNVrOH_GTiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwODozODoyNVrOH_GTiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTkyNTY0MQ==", "bodyText": "Might worth to mention in the documentation, or somewhere that this should be smaller than hive.txn.timeout or in newer versions metastore.txn.timeout otherwise the locks might be timed out without because of the lack of heartbeat.", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r535925641", "createdAt": "2020-12-04T08:38:25Z", "author": {"login": "pvary"}, "path": "hive-metastore/src/main/java/org/apache/iceberg/hive/HiveTableOperations.java", "diffHunk": "@@ -70,21 +72,38 @@\n public class HiveTableOperations extends BaseMetastoreTableOperations {\n   private static final Logger LOG = LoggerFactory.getLogger(HiveTableOperations.class);\n \n-  private static final String HIVE_ACQUIRE_LOCK_STATE_TIMEOUT_MS = \"iceberg.hive.lock-timeout-ms\";\n-  private static final long HIVE_ACQUIRE_LOCK_STATE_TIMEOUT_MS_DEFAULT = 3 * 60 * 1000; // 3 minutes\n+  private static final String HIVE_ACQUIRE_LOCK_TIMEOUT_MS = \"iceberg.hive.lock-timeout-ms\";\n+  private static final String HIVE_LOCK_CHECK_MIN_WAIT_MS = \"iceberg.hive.lock-check-min-wait-ms\";\n+  private static final String HIVE_LOCK_CHECK_MAX_WAIT_MS = \"iceberg.hive.lock-check-max-wait-ms\";\n+  private static final String HIVE_LOCK_CHECK_BACKOFF_SCALE_FACTOR = \"iceberg.hive.lock-check-backoff-scale-factor\";\n+  private static final long HIVE_ACQUIRE_LOCK_TIMEOUT_MS_DEFAULT = 3 * 60 * 1000; // 3 minutes\n+  private static final long HIVE_LOCK_CHECK_MIN_WAIT_MS_DEFAULT = 50; // 50 milliseconds\n+  private static final long HIVE_LOCK_CHECK_MAX_WAIT_MS_DEFAULT = 5 * 1000; // 5 seconds", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b201863396dd365ec64d33a43aefa776e23c1cde"}, "originalPosition": 28}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0NzYyOTc1", "url": "https://github.com/apache/iceberg/pull/1873#pullrequestreview-544762975", "createdAt": "2020-12-04T08:54:49Z", "commit": {"oid": "b201863396dd365ec64d33a43aefa776e23c1cde"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwODo1NDo0OVrOH_G75Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwODo1NDo0OVrOH_G75Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTkzNTk3Mw==", "bodyText": "nit: Could we use VisibleForTesting annotation here?", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r535935973", "createdAt": "2020-12-04T08:54:49Z", "author": {"login": "pvary"}, "path": "hive-metastore/src/test/java/org/apache/iceberg/hive/TestHiveMetastore.java", "diffHunk": "@@ -84,7 +84,7 @@\n   private ExecutorService executorService;\n   private TServer server;\n   private HiveMetaStore.HMSHandler baseHandler;\n-  private HiveClientPool clientPool;\n+  protected HiveClientPool clientPool; // Exposed for testing.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b201863396dd365ec64d33a43aefa776e23c1cde"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0ODMwNDY5", "url": "https://github.com/apache/iceberg/pull/1873#pullrequestreview-544830469", "createdAt": "2020-12-04T10:22:00Z", "commit": {"oid": "b201863396dd365ec64d33a43aefa776e23c1cde"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxMDoyMjowMFrOH_KYxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxMDoyMjowMFrOH_KYxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk5MjUxOQ==", "bodyText": "nit: it seems we use it only in one place. Would it make sense to just call throw new there?", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r535992519", "createdAt": "2020-12-04T10:22:00Z", "author": {"login": "aokolnychyi"}, "path": "hive-metastore/src/main/java/org/apache/iceberg/hive/HiveTableOperations.java", "diffHunk": "@@ -70,21 +72,38 @@\n public class HiveTableOperations extends BaseMetastoreTableOperations {\n   private static final Logger LOG = LoggerFactory.getLogger(HiveTableOperations.class);\n \n-  private static final String HIVE_ACQUIRE_LOCK_STATE_TIMEOUT_MS = \"iceberg.hive.lock-timeout-ms\";\n-  private static final long HIVE_ACQUIRE_LOCK_STATE_TIMEOUT_MS_DEFAULT = 3 * 60 * 1000; // 3 minutes\n+  private static final String HIVE_ACQUIRE_LOCK_TIMEOUT_MS = \"iceberg.hive.lock-timeout-ms\";\n+  private static final String HIVE_LOCK_CHECK_MIN_WAIT_MS = \"iceberg.hive.lock-check-min-wait-ms\";\n+  private static final String HIVE_LOCK_CHECK_MAX_WAIT_MS = \"iceberg.hive.lock-check-max-wait-ms\";\n+  private static final String HIVE_LOCK_CHECK_BACKOFF_SCALE_FACTOR = \"iceberg.hive.lock-check-backoff-scale-factor\";\n+  private static final long HIVE_ACQUIRE_LOCK_TIMEOUT_MS_DEFAULT = 3 * 60 * 1000; // 3 minutes\n+  private static final long HIVE_LOCK_CHECK_MIN_WAIT_MS_DEFAULT = 50; // 50 milliseconds\n+  private static final long HIVE_LOCK_CHECK_MAX_WAIT_MS_DEFAULT = 5 * 1000; // 5 seconds\n+  private static final double HIVE_LOCK_CHECK_BACKOFF_SCALE_FACTOR_DEFAULT = 1.5;\n   private static final DynMethods.UnboundMethod ALTER_TABLE = DynMethods.builder(\"alter_table\")\n       .impl(HiveMetaStoreClient.class, \"alter_table_with_environmentContext\",\n           String.class, String.class, Table.class, EnvironmentContext.class)\n       .impl(HiveMetaStoreClient.class, \"alter_table\",\n           String.class, String.class, Table.class, EnvironmentContext.class)\n       .build();\n \n+  protected static class WaitingForLockException extends RuntimeException {\n+    public WaitingForLockException(String message) {\n+      super(message);\n+    }\n+  }\n+\n+  private static final WaitingForLockException WAITING_FOR_LOCK_EXCEPTION =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b201863396dd365ec64d33a43aefa776e23c1cde"}, "originalPosition": 43}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0ODMyMDgx", "url": "https://github.com/apache/iceberg/pull/1873#pullrequestreview-544832081", "createdAt": "2020-12-04T10:24:07Z", "commit": {"oid": "b201863396dd365ec64d33a43aefa776e23c1cde"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxMDoyNDowOFrOH_Kd1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxMDoyNDowOFrOH_Kd1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk5MzgxNQ==", "bodyText": "Why protected?", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r535993815", "createdAt": "2020-12-04T10:24:08Z", "author": {"login": "aokolnychyi"}, "path": "hive-metastore/src/main/java/org/apache/iceberg/hive/HiveTableOperations.java", "diffHunk": "@@ -70,21 +72,38 @@\n public class HiveTableOperations extends BaseMetastoreTableOperations {\n   private static final Logger LOG = LoggerFactory.getLogger(HiveTableOperations.class);\n \n-  private static final String HIVE_ACQUIRE_LOCK_STATE_TIMEOUT_MS = \"iceberg.hive.lock-timeout-ms\";\n-  private static final long HIVE_ACQUIRE_LOCK_STATE_TIMEOUT_MS_DEFAULT = 3 * 60 * 1000; // 3 minutes\n+  private static final String HIVE_ACQUIRE_LOCK_TIMEOUT_MS = \"iceberg.hive.lock-timeout-ms\";\n+  private static final String HIVE_LOCK_CHECK_MIN_WAIT_MS = \"iceberg.hive.lock-check-min-wait-ms\";\n+  private static final String HIVE_LOCK_CHECK_MAX_WAIT_MS = \"iceberg.hive.lock-check-max-wait-ms\";\n+  private static final String HIVE_LOCK_CHECK_BACKOFF_SCALE_FACTOR = \"iceberg.hive.lock-check-backoff-scale-factor\";\n+  private static final long HIVE_ACQUIRE_LOCK_TIMEOUT_MS_DEFAULT = 3 * 60 * 1000; // 3 minutes\n+  private static final long HIVE_LOCK_CHECK_MIN_WAIT_MS_DEFAULT = 50; // 50 milliseconds\n+  private static final long HIVE_LOCK_CHECK_MAX_WAIT_MS_DEFAULT = 5 * 1000; // 5 seconds\n+  private static final double HIVE_LOCK_CHECK_BACKOFF_SCALE_FACTOR_DEFAULT = 1.5;\n   private static final DynMethods.UnboundMethod ALTER_TABLE = DynMethods.builder(\"alter_table\")\n       .impl(HiveMetaStoreClient.class, \"alter_table_with_environmentContext\",\n           String.class, String.class, Table.class, EnvironmentContext.class)\n       .impl(HiveMetaStoreClient.class, \"alter_table\",\n           String.class, String.class, Table.class, EnvironmentContext.class)\n       .build();\n \n+  protected static class WaitingForLockException extends RuntimeException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b201863396dd365ec64d33a43aefa776e23c1cde"}, "originalPosition": 37}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ1MDM5Nzgz", "url": "https://github.com/apache/iceberg/pull/1873#pullrequestreview-545039783", "createdAt": "2020-12-04T15:07:26Z", "commit": {"oid": "b201863396dd365ec64d33a43aefa776e23c1cde"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNTowNzoyNlrOH_U8BA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNTowNzoyNlrOH_U8BA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE2NTM4MA==", "bodyText": "Why - 100?", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r536165380", "createdAt": "2020-12-04T15:07:26Z", "author": {"login": "RussellSpitzer"}, "path": "hive-metastore/src/main/java/org/apache/iceberg/hive/HiveTableOperations.java", "diffHunk": "@@ -304,32 +330,57 @@ private long acquireLock() throws UnknownHostException, TException, InterruptedE\n         System.getProperty(\"user.name\"),\n         InetAddress.getLocalHost().getHostName());\n     LockResponse lockResponse = metaClients.run(client -> client.lock(lockRequest));\n-    LockState state = lockResponse.getState();\n+    AtomicReference<LockState> state = new AtomicReference<>(lockResponse.getState());\n     long lockId = lockResponse.getLockid();\n \n     final long start = System.currentTimeMillis();\n     long duration = 0;\n     boolean timeout = false;\n-    while (!timeout && state.equals(LockState.WAITING)) {\n-      lockResponse = metaClients.run(client -> client.checkLock(lockId));\n-      state = lockResponse.getState();\n \n-      // check timeout\n-      duration = System.currentTimeMillis() - start;\n-      if (duration > lockAcquireTimeout) {\n+    if (state.get().equals(LockState.WAITING)) {\n+      try {\n+        Tasks.foreach(lockId)\n+            .retry(Integer.MAX_VALUE - 100) // Endless retries bound by timeouts. Tasks.retry adds 1 for \"first try\".", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b201863396dd365ec64d33a43aefa776e23c1cde"}, "originalPosition": 94}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ1MDQzNDk1", "url": "https://github.com/apache/iceberg/pull/1873#pullrequestreview-545043495", "createdAt": "2020-12-04T15:11:41Z", "commit": {"oid": "b201863396dd365ec64d33a43aefa776e23c1cde"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNToxMTo0MlrOH_VHsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNToxMTo0MlrOH_VHsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE2ODM3MQ==", "bodyText": "Is InterruptedException needed?", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r536168371", "createdAt": "2020-12-04T15:11:42Z", "author": {"login": "aokolnychyi"}, "path": "hive-metastore/src/test/java/org/apache/iceberg/hive/TestHiveCommitLocks.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.hive;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hive.metastore.HiveMetaStoreClient;\n+import org.apache.hadoop.hive.metastore.api.LockResponse;\n+import org.apache.hadoop.hive.metastore.api.LockState;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.HasTableOperations;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.exceptions.CommitFailedException;\n+import org.apache.iceberg.types.Types;\n+import org.apache.thrift.TException;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.eq;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.when;\n+\n+public class TestHiveCommitLocks extends HiveTableBaseTest {\n+  HiveTableOperations ops = null;\n+  HiveTableOperations spyOps = null;\n+  HiveClientPool spyClientPool = null;\n+  HiveMetaStoreClient spyClient = null;\n+  TableMetadata metadataV1 = null;\n+  TableMetadata metadataV2 = null;\n+\n+  long dummyLockId = 500L;\n+  LockResponse waitLockResponse = new LockResponse(dummyLockId, LockState.WAITING);\n+  LockResponse acquiredLockResponse = new LockResponse(dummyLockId, LockState.ACQUIRED);\n+  LockResponse notAcquiredLockResponse = new LockResponse(dummyLockId, LockState.NOT_ACQUIRED);\n+\n+  @Before\n+  public void before() throws Exception {\n+    Table table = catalog.loadTable(TABLE_IDENTIFIER);\n+    ops = (HiveTableOperations) ((HasTableOperations) table).operations();\n+    String dbName = TABLE_IDENTIFIER.namespace().level(0);\n+    String tableName = TABLE_IDENTIFIER.name();\n+    Configuration overriddenHiveConf = new Configuration(hiveConf);\n+    overriddenHiveConf.setLong(\"iceberg.hive.lock-timeout-ms\", 10 * 1000);\n+    overriddenHiveConf.setLong(\"iceberg.hive.lock-check-min-wait-ms\", 50);\n+    overriddenHiveConf.setLong(\"iceberg.hive.lock-check-max-wait-ms\", 5 * 1000);\n+    overriddenHiveConf.setDouble(\"iceberg.hive.lock-check-backoff-scale-factor\", 3.0);\n+\n+    metadataV1 = ops.current();\n+\n+    table.updateSchema()\n+        .addColumn(\"n\", Types.IntegerType.get())\n+        .commit();\n+\n+    ops.refresh();\n+\n+    metadataV2 = ops.current();\n+\n+    Assert.assertEquals(2, ops.current().schema().columns().size());\n+\n+    spyClientPool = spy(new HiveClientPool(1, overriddenHiveConf));\n+    AtomicReference<HiveMetaStoreClient> spyClientRef = new AtomicReference<>();\n+\n+    when(spyClientPool.newClient()).thenAnswer(invocation -> {\n+      HiveMetaStoreClient client = (HiveMetaStoreClient) invocation.callRealMethod();\n+      spyClientRef.set(spy(client));\n+      return spyClientRef.get();\n+    });\n+\n+    spyOps = spy(new HiveTableOperations(overriddenHiveConf, spyClientPool, ops.io(), catalog.name(),\n+        dbName, tableName));\n+    spyClientPool.run(client -> client.isLocalMetaStore()); // To ensure new client is created.\n+    Assert.assertNotNull(spyClientRef.get());\n+\n+    spyClient = spyClientRef.get();\n+  }\n+\n+  @After\n+  public void cleanup() {\n+    try {\n+      spyClientPool.close();\n+    } catch (Throwable t) {\n+      // Ignore any exception\n+    }\n+  }\n+\n+  @Test\n+  public void testLockAcquisitionAtFirstTime() throws TException, InterruptedException {\n+    doReturn(acquiredLockResponse).when(spyClient).lock(any());\n+    doNothing().when(spyOps).doUnlock(eq(dummyLockId));\n+\n+    spyOps.doCommit(metadataV2, metadataV1);\n+\n+    Assert.assertEquals(1, spyOps.current().schema().columns().size()); // should be 1 again\n+  }\n+\n+  @Test\n+  public void testLockAcquisitionAfterRetries() throws TException, InterruptedException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b201863396dd365ec64d33a43aefa776e23c1cde"}, "originalPosition": 120}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ1MDQ1NDgw", "url": "https://github.com/apache/iceberg/pull/1873#pullrequestreview-545045480", "createdAt": "2020-12-04T15:14:00Z", "commit": {"oid": "b201863396dd365ec64d33a43aefa776e23c1cde"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNToxNDowMFrOH_VOLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNToxNDowMFrOH_VOLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE3MDAyOQ==", "bodyText": "nit: extra empty line", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r536170029", "createdAt": "2020-12-04T15:14:00Z", "author": {"login": "aokolnychyi"}, "path": "hive-metastore/src/main/java/org/apache/iceberg/hive/HiveTableOperations.java", "diffHunk": "@@ -96,7 +115,14 @@ protected HiveTableOperations(Configuration conf, HiveClientPool metaClients, Fi\n     this.database = database;\n     this.tableName = table;\n     this.lockAcquireTimeout =\n-        conf.getLong(HIVE_ACQUIRE_LOCK_STATE_TIMEOUT_MS, HIVE_ACQUIRE_LOCK_STATE_TIMEOUT_MS_DEFAULT);\n+        conf.getLong(HIVE_ACQUIRE_LOCK_TIMEOUT_MS, HIVE_ACQUIRE_LOCK_TIMEOUT_MS_DEFAULT);\n+    this.lockCheckMinWaitTime =\n+        conf.getLong(HIVE_LOCK_CHECK_MIN_WAIT_MS, HIVE_LOCK_CHECK_MIN_WAIT_MS_DEFAULT);\n+    this.lockCheckMaxWaitTime =\n+        conf.getLong(HIVE_LOCK_CHECK_MAX_WAIT_MS, HIVE_LOCK_CHECK_MAX_WAIT_MS_DEFAULT);\n+    this.lockCheckBackoffScaleFactor =\n+        conf.getDouble(HIVE_LOCK_CHECK_BACKOFF_SCALE_FACTOR, HIVE_LOCK_CHECK_BACKOFF_SCALE_FACTOR_DEFAULT);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b201863396dd365ec64d33a43aefa776e23c1cde"}, "originalPosition": 69}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ1MTQ5NjA3", "url": "https://github.com/apache/iceberg/pull/1873#pullrequestreview-545149607", "createdAt": "2020-12-04T17:19:24Z", "commit": {"oid": "b201863396dd365ec64d33a43aefa776e23c1cde"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNzoxOToyNFrOH_aTQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNzoxOToyNFrOH_aTQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjI1MzI1MA==", "bodyText": "We don't expose the scale factor in other places. I think it makes sense to keep it simple and not have one here either.", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r536253250", "createdAt": "2020-12-04T17:19:24Z", "author": {"login": "rdblue"}, "path": "hive-metastore/src/main/java/org/apache/iceberg/hive/HiveTableOperations.java", "diffHunk": "@@ -96,7 +115,14 @@ protected HiveTableOperations(Configuration conf, HiveClientPool metaClients, Fi\n     this.database = database;\n     this.tableName = table;\n     this.lockAcquireTimeout =\n-        conf.getLong(HIVE_ACQUIRE_LOCK_STATE_TIMEOUT_MS, HIVE_ACQUIRE_LOCK_STATE_TIMEOUT_MS_DEFAULT);\n+        conf.getLong(HIVE_ACQUIRE_LOCK_TIMEOUT_MS, HIVE_ACQUIRE_LOCK_TIMEOUT_MS_DEFAULT);\n+    this.lockCheckMinWaitTime =\n+        conf.getLong(HIVE_LOCK_CHECK_MIN_WAIT_MS, HIVE_LOCK_CHECK_MIN_WAIT_MS_DEFAULT);\n+    this.lockCheckMaxWaitTime =\n+        conf.getLong(HIVE_LOCK_CHECK_MAX_WAIT_MS, HIVE_LOCK_CHECK_MAX_WAIT_MS_DEFAULT);\n+    this.lockCheckBackoffScaleFactor =\n+        conf.getDouble(HIVE_LOCK_CHECK_BACKOFF_SCALE_FACTOR, HIVE_LOCK_CHECK_BACKOFF_SCALE_FACTOR_DEFAULT);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b201863396dd365ec64d33a43aefa776e23c1cde"}, "originalPosition": 68}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ1MTUyMDMy", "url": "https://github.com/apache/iceberg/pull/1873#pullrequestreview-545152032", "createdAt": "2020-12-04T17:22:30Z", "commit": {"oid": "b201863396dd365ec64d33a43aefa776e23c1cde"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNzoyMjozMVrOH_aaSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNzoyMjozMVrOH_aaSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjI1NTA0OQ==", "bodyText": "For InterruptedException, why not throw WaitingForLockException and signal that the thread was interrupted? Then this could use the checked exception call, run(id -> {...}, TException.class) and would not need to wrap the exceptions.", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r536255049", "createdAt": "2020-12-04T17:22:31Z", "author": {"login": "rdblue"}, "path": "hive-metastore/src/main/java/org/apache/iceberg/hive/HiveTableOperations.java", "diffHunk": "@@ -304,32 +330,57 @@ private long acquireLock() throws UnknownHostException, TException, InterruptedE\n         System.getProperty(\"user.name\"),\n         InetAddress.getLocalHost().getHostName());\n     LockResponse lockResponse = metaClients.run(client -> client.lock(lockRequest));\n-    LockState state = lockResponse.getState();\n+    AtomicReference<LockState> state = new AtomicReference<>(lockResponse.getState());\n     long lockId = lockResponse.getLockid();\n \n     final long start = System.currentTimeMillis();\n     long duration = 0;\n     boolean timeout = false;\n-    while (!timeout && state.equals(LockState.WAITING)) {\n-      lockResponse = metaClients.run(client -> client.checkLock(lockId));\n-      state = lockResponse.getState();\n \n-      // check timeout\n-      duration = System.currentTimeMillis() - start;\n-      if (duration > lockAcquireTimeout) {\n+    if (state.get().equals(LockState.WAITING)) {\n+      try {\n+        Tasks.foreach(lockId)\n+            .retry(Integer.MAX_VALUE - 100) // Endless retries bound by timeouts. Tasks.retry adds 1 for \"first try\".\n+            .exponentialBackoff(\n+                lockCheckMinWaitTime,\n+                lockCheckMaxWaitTime,\n+                lockAcquireTimeout,\n+                lockCheckBackoffScaleFactor)\n+            .throwFailureWhenFinished()\n+            .onlyRetryOn(WaitingForLockException.class)\n+            .run(id -> {\n+              try {\n+                LockResponse response = metaClients.run(client -> client.checkLock(id));\n+                LockState newState = response.getState();\n+                state.set(newState);\n+                if (newState.equals(LockState.WAITING)) {\n+                  throw WAITING_FOR_LOCK_EXCEPTION;\n+                }\n+              } catch (InterruptedException | TException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b201863396dd365ec64d33a43aefa776e23c1cde"}, "originalPosition": 110}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "599b679904933640a0bd12db790722beeb015626", "author": {"user": {"login": "raptond", "name": "Thiru Paramasivan"}}, "url": "https://github.com/apache/iceberg/commit/599b679904933640a0bd12db790722beeb015626", "committedDate": "2020-12-08T19:29:18Z", "message": "Hive: Make lock check retries backoff exponentially\n\n50 milliseconds (constant) sleep time between \"checking lock status\" thrashes hive metastore databases when multiple jobs try to commit to the same Iceberg table. This fix allows the frequency of \"checking the WAITING lock status\" configurable and makes use of Tasks to backoff exponentially."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c53108c2c8271d1679ecff60de4df249339c8f5f", "author": {"user": {"login": "raptond", "name": "Thiru Paramasivan"}}, "url": "https://github.com/apache/iceberg/commit/c53108c2c8271d1679ecff60de4df249339c8f5f", "committedDate": "2020-12-08T19:29:19Z", "message": "Fix review comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b201863396dd365ec64d33a43aefa776e23c1cde", "author": {"user": {"login": "raptond", "name": "Thiru Paramasivan"}}, "url": "https://github.com/apache/iceberg/commit/b201863396dd365ec64d33a43aefa776e23c1cde", "committedDate": "2020-12-04T01:56:54Z", "message": "Hive: Make lock check retries backoff exponentially\n\n50 milliseconds (constant) sleep time between \"checking lock status\" thrashes hive metastore databases when multiple jobs try to commit to the same Iceberg table. This fix allows the frequency of \"checking the WAITING lock status\" configurable and makes use of Tasks to backoff exponentially."}, "afterCommit": {"oid": "c53108c2c8271d1679ecff60de4df249339c8f5f", "author": {"user": {"login": "raptond", "name": "Thiru Paramasivan"}}, "url": "https://github.com/apache/iceberg/commit/c53108c2c8271d1679ecff60de4df249339c8f5f", "committedDate": "2020-12-08T19:29:19Z", "message": "Fix review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b4dcc67ead41606389948dab7bf3ff5293981528", "author": {"user": {"login": "raptond", "name": "Thiru Paramasivan"}}, "url": "https://github.com/apache/iceberg/commit/b4dcc67ead41606389948dab7bf3ff5293981528", "committedDate": "2020-12-08T19:52:40Z", "message": "Fix checkstyle issues"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "10c23b842145c0190c24b142965975e73739c077", "author": {"user": {"login": "raptond", "name": "Thiru Paramasivan"}}, "url": "https://github.com/apache/iceberg/commit/10c23b842145c0190c24b142965975e73739c077", "committedDate": "2020-12-08T20:44:49Z", "message": "Fix additional review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3Njg4Mjc5", "url": "https://github.com/apache/iceberg/pull/1873#pullrequestreview-547688279", "createdAt": "2020-12-08T22:31:49Z", "commit": {"oid": "b4dcc67ead41606389948dab7bf3ff5293981528"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQyMjozMTo1MFrOIB5QcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQyMjozMTo1MFrOIB5QcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg1NzU4NA==", "bodyText": "Nit: unnecessary whitespace change.", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r538857584", "createdAt": "2020-12-08T22:31:50Z", "author": {"login": "rdblue"}, "path": "hive-metastore/src/main/java/org/apache/iceberg/hive/HiveTableOperations.java", "diffHunk": "@@ -66,33 +68,50 @@\n public class HiveTableOperations extends BaseMetastoreTableOperations {\n   private static final Logger LOG = LoggerFactory.getLogger(HiveTableOperations.class);\n \n-  private static final String HIVE_ACQUIRE_LOCK_STATE_TIMEOUT_MS = \"iceberg.hive.lock-timeout-ms\";\n-  private static final long HIVE_ACQUIRE_LOCK_STATE_TIMEOUT_MS_DEFAULT = 3 * 60 * 1000; // 3 minutes\n+  private static final String HIVE_ACQUIRE_LOCK_TIMEOUT_MS = \"iceberg.hive.lock-timeout-ms\";\n+  private static final String HIVE_LOCK_CHECK_MIN_WAIT_MS = \"iceberg.hive.lock-check-min-wait-ms\";\n+  private static final String HIVE_LOCK_CHECK_MAX_WAIT_MS = \"iceberg.hive.lock-check-max-wait-ms\";\n+  private static final long HIVE_ACQUIRE_LOCK_TIMEOUT_MS_DEFAULT = 3 * 60 * 1000; // 3 minutes\n+  private static final long HIVE_LOCK_CHECK_MIN_WAIT_MS_DEFAULT = 50; // 50 milliseconds\n+  private static final long HIVE_LOCK_CHECK_MAX_WAIT_MS_DEFAULT = 5 * 1000; // 5 seconds\n   private static final DynMethods.UnboundMethod ALTER_TABLE = DynMethods.builder(\"alter_table\")\n       .impl(HiveMetaStoreClient.class, \"alter_table_with_environmentContext\",\n           String.class, String.class, Table.class, EnvironmentContext.class)\n       .impl(HiveMetaStoreClient.class, \"alter_table\",\n           String.class, String.class, Table.class, EnvironmentContext.class)\n       .build();\n \n+  private static class WaitingForLockException extends RuntimeException {\n+    WaitingForLockException(String message) {\n+      super(message);\n+    }\n+  }\n+\n   private final HiveClientPool metaClients;\n   private final String fullName;\n   private final String database;\n   private final String tableName;\n   private final Configuration conf;\n   private final long lockAcquireTimeout;\n+  private final long lockCheckMinWaitTime;\n+  private final long lockCheckMaxWaitTime;\n   private final FileIO fileIO;\n \n   protected HiveTableOperations(Configuration conf, HiveClientPool metaClients, FileIO fileIO,\n-                                String catalogName, String database, String table) {\n+      String catalogName, String database, String table) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4dcc67ead41606389948dab7bf3ff5293981528"}, "originalPosition": 53}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3NzI2NDc2", "url": "https://github.com/apache/iceberg/pull/1873#pullrequestreview-547726476", "createdAt": "2020-12-08T23:43:12Z", "commit": {"oid": "b4dcc67ead41606389948dab7bf3ff5293981528"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQyMzo0MzoxMlrOIB7eWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQyMzo0MzoxMlrOIB7eWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg5MzkxNA==", "bodyText": "I don't think it is necessary to throw RuntimeException here. If this doesn't throw WaitingForLockException then it will exit and move on. Since timeout is not set, it would hit the check for whether the lock was acquired and fail, resulting in the CommitFailedException.\nI think that's a fairly reasonable way to handle an interrupt without wrapping it in a RuntimeException.", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r538893914", "createdAt": "2020-12-08T23:43:12Z", "author": {"login": "rdblue"}, "path": "hive-metastore/src/main/java/org/apache/iceberg/hive/HiveTableOperations.java", "diffHunk": "@@ -294,32 +313,50 @@ private long acquireLock() throws UnknownHostException, TException, InterruptedE\n         System.getProperty(\"user.name\"),\n         InetAddress.getLocalHost().getHostName());\n     LockResponse lockResponse = metaClients.run(client -> client.lock(lockRequest));\n-    LockState state = lockResponse.getState();\n+    AtomicReference<LockState> state = new AtomicReference<>(lockResponse.getState());\n     long lockId = lockResponse.getLockid();\n \n     final long start = System.currentTimeMillis();\n     long duration = 0;\n     boolean timeout = false;\n-    while (!timeout && state.equals(LockState.WAITING)) {\n-      lockResponse = metaClients.run(client -> client.checkLock(lockId));\n-      state = lockResponse.getState();\n \n-      // check timeout\n-      duration = System.currentTimeMillis() - start;\n-      if (duration > lockAcquireTimeout) {\n+    if (state.get().equals(LockState.WAITING)) {\n+      try {\n+        Tasks.foreach(lockId)\n+            .retry(Integer.MAX_VALUE - 100) // Endless retries bound by timeouts. Tasks.retry adds 1 for \"first try\".\n+            .exponentialBackoff(\n+                lockCheckMinWaitTime,\n+                lockCheckMaxWaitTime,\n+                lockAcquireTimeout,\n+                1.5)\n+            .throwFailureWhenFinished()\n+            .onlyRetryOn(WaitingForLockException.class)\n+            .run(id -> {\n+              try {\n+                LockResponse response = metaClients.run(client -> client.checkLock(id));\n+                LockState newState = response.getState();\n+                state.set(newState);\n+                if (newState.equals(LockState.WAITING)) {\n+                  throw new WaitingForLockException(\"Waiting for lock.\");\n+                }\n+              } catch (InterruptedException e) {\n+                Thread.currentThread().interrupt();\n+                throw new RuntimeException(\"Interrupted while checking lock status.\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4dcc67ead41606389948dab7bf3ff5293981528"}, "originalPosition": 110}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3NzI3OTMw", "url": "https://github.com/apache/iceberg/pull/1873#pullrequestreview-547727930", "createdAt": "2020-12-08T23:46:40Z", "commit": {"oid": "b4dcc67ead41606389948dab7bf3ff5293981528"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e1f4d48efe87a0c9e83c66486dd1d0d6ac02c6ae", "author": {"user": {"login": "raptond", "name": "Thiru Paramasivan"}}, "url": "https://github.com/apache/iceberg/commit/e1f4d48efe87a0c9e83c66486dd1d0d6ac02c6ae", "committedDate": "2020-12-09T07:40:46Z", "message": "More review comments addressed."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "99f7ac1fddd37791b51316fd3d31e858c05ad8e7", "author": {"user": {"login": "raptond", "name": "Thiru Paramasivan"}}, "url": "https://github.com/apache/iceberg/commit/99f7ac1fddd37791b51316fd3d31e858c05ad8e7", "committedDate": "2020-12-09T07:39:21Z", "message": "More review comments addressed."}, "afterCommit": {"oid": "e1f4d48efe87a0c9e83c66486dd1d0d6ac02c6ae", "author": {"user": {"login": "raptond", "name": "Thiru Paramasivan"}}, "url": "https://github.com/apache/iceberg/commit/e1f4d48efe87a0c9e83c66486dd1d0d6ac02c6ae", "committedDate": "2020-12-09T07:40:46Z", "message": "More review comments addressed."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bb828ba5b940a821fd18cf11306ead5df2710ca3", "author": {"user": {"login": "raptond", "name": "Thiru Paramasivan"}}, "url": "https://github.com/apache/iceberg/commit/bb828ba5b940a821fd18cf11306ead5df2710ca3", "committedDate": "2020-12-09T07:49:18Z", "message": "Remove unused import"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bbc91e6caf62d3640af838f3489e73ff2a168680", "author": {"user": {"login": "raptond", "name": "Thiru Paramasivan"}}, "url": "https://github.com/apache/iceberg/commit/bbc91e6caf62d3640af838f3489e73ff2a168680", "committedDate": "2020-12-09T08:41:09Z", "message": "Add a note on iceberg.hive.lock-check-max-wait-ms"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5NDYzNzU1", "url": "https://github.com/apache/iceberg/pull/1873#pullrequestreview-549463755", "createdAt": "2020-12-10T18:00:19Z", "commit": {"oid": "bbc91e6caf62d3640af838f3489e73ff2a168680"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3522, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}