{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ2NDMyMjg3", "number": 1184, "title": "Read support for parquet int96 timestamps", "bodyText": "Summary\nAdd read support for Parquet INT96 timestamps (fixes #1138). This is needed so that parquet files written by Spark, that used INT96 timestamps, are able to be read by Iceberg without having to rewrite these files. This is specially useful for migrations.\napache/parquet-format#49 has more information about how parquet int96 timestamps are stored. Note that I only implemented read support since this representation has many issues (as visible in the conversation in the parquet-format PR).\nTesting\n\n Added unit test for spark readers\n Unsure about what is the best place to add unit-tests for the non-spark parquet readers. Would gladly add one.", "createdAt": "2020-07-08T19:11:24Z", "url": "https://github.com/apache/iceberg/pull/1184", "merged": true, "mergeCommit": {"oid": "62ab6a722e2989ad546b5588111002b469d9f660"}, "closed": true, "closedAt": "2020-07-24T20:52:26Z", "author": {"login": "gustavoatt"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcyu95OAH2gAyNDQ2NDMyMjg3OmNhM2U5NTVlZDlhNWY2NzMxNGU0M2M2ZDFjNzMzMzJhNjYzM2RhNzY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc4J1NFAH2gAyNDQ2NDMyMjg3OjY4ZGM0YzVlMDkxZWE2MTAwMTFmMzI2NGY2MTE2MTVmNzNjMWIwNWQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "ca3e955ed9a5f67314e43c6d1c73332a6633da76", "author": {"user": {"login": "gustavoatt", "name": "Gustavo Torres"}}, "url": "https://github.com/apache/iceberg/commit/ca3e955ed9a5f67314e43c6d1c73332a6633da76", "committedDate": "2020-07-08T00:05:32Z", "message": "Read support for int96 as timestamp"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cea839f58b8b0e3d73f415b2770913e1d0955f31", "author": {"user": {"login": "gustavoatt", "name": "Gustavo Torres"}}, "url": "https://github.com/apache/iceberg/commit/cea839f58b8b0e3d73f415b2770913e1d0955f31", "committedDate": "2020-07-08T19:07:11Z", "message": "Parquet int96 timestamp spark read tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3NzEzODY5", "url": "https://github.com/apache/iceberg/pull/1184#pullrequestreview-447713869", "createdAt": "2020-07-14T01:01:54Z", "commit": {"oid": "cea839f58b8b0e3d73f415b2770913e1d0955f31"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQwMTowMTo1NFrOGxAJXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQwMTowMTo1NFrOGxAJXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDAzNTgwNQ==", "bodyText": "Is it possible to avoid creating a Spark session just to write a timestamp? What about calling Spark's FileFormat to write directly instead?\nWe wrap Spark's FileFormat in our DSv2 table implementation: https://github.com/Netflix/iceberg/blob/netflix-spark-2.4/metacat/src/main/java/com/netflix/iceberg/batch/BatchPatternWrite.java#L90\nThis test would run much faster by using that to create a file instead of creating a Spark context.", "url": "https://github.com/apache/iceberg/pull/1184#discussion_r454035805", "createdAt": "2020-07-14T01:01:54Z", "author": {"login": "rdblue"}, "path": "spark/src/test/java/org/apache/iceberg/spark/data/TestSparkParquetReader.java", "diffHunk": "@@ -67,4 +78,49 @@ protected void writeAndValidate(Schema schema) throws IOException {\n       Assert.assertFalse(\"Should not have extra rows\", rows.hasNext());\n     }\n   }\n+\n+  protected List<InternalRow> rowsFromFile(InputFile inputFile, Schema schema) throws IOException {\n+    try (CloseableIterable<InternalRow> reader =\n+        Parquet.read(inputFile)\n+            .project(schema)\n+            .createReaderFunc(type -> SparkParquetReaders.buildReader(schema, type))\n+            .build()) {\n+      return Lists.newArrayList(reader);\n+    }\n+  }\n+\n+  @Test\n+  public void testInt96TimestampProducedBySparkIsReadCorrectly() throws IOException {\n+    final SparkSession spark =\n+        SparkSession.builder()\n+            .master(\"local[2]\")\n+            .config(\"spark.sql.parquet.int96AsTimestamp\", \"false\")\n+            .getOrCreate();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cea839f58b8b0e3d73f415b2770913e1d0955f31"}, "originalPosition": 54}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3NzE0Mjk5", "url": "https://github.com/apache/iceberg/pull/1184#pullrequestreview-447714299", "createdAt": "2020-07-14T01:03:22Z", "commit": {"oid": "cea839f58b8b0e3d73f415b2770913e1d0955f31"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQwMTowMzoyMlrOGxAKuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQwMTowMzoyMlrOGxAKuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDAzNjE1Mg==", "bodyText": "Using Spark's FileFormat would also make this test easier. You'd be able to pass in a value in micros and validate that you get the same value back, unmodified. You'd also not need to locate the Parquet file using find.", "url": "https://github.com/apache/iceberg/pull/1184#discussion_r454036152", "createdAt": "2020-07-14T01:03:22Z", "author": {"login": "rdblue"}, "path": "spark/src/test/java/org/apache/iceberg/spark/data/TestSparkParquetReader.java", "diffHunk": "@@ -67,4 +78,49 @@ protected void writeAndValidate(Schema schema) throws IOException {\n       Assert.assertFalse(\"Should not have extra rows\", rows.hasNext());\n     }\n   }\n+\n+  protected List<InternalRow> rowsFromFile(InputFile inputFile, Schema schema) throws IOException {\n+    try (CloseableIterable<InternalRow> reader =\n+        Parquet.read(inputFile)\n+            .project(schema)\n+            .createReaderFunc(type -> SparkParquetReaders.buildReader(schema, type))\n+            .build()) {\n+      return Lists.newArrayList(reader);\n+    }\n+  }\n+\n+  @Test\n+  public void testInt96TimestampProducedBySparkIsReadCorrectly() throws IOException {\n+    final SparkSession spark =\n+        SparkSession.builder()\n+            .master(\"local[2]\")\n+            .config(\"spark.sql.parquet.int96AsTimestamp\", \"false\")\n+            .getOrCreate();\n+\n+    final String parquetPath = temp.getRoot().getAbsolutePath() + \"/parquet_int96\";\n+    final java.sql.Timestamp ts = java.sql.Timestamp.valueOf(\"2014-01-01 23:00:01\");\n+    spark.createDataset(ImmutableList.of(ts), Encoders.TIMESTAMP()).write().parquet(parquetPath);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cea839f58b8b0e3d73f415b2770913e1d0955f31"}, "originalPosition": 58}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "944c325ec3c92530ddebae31e8f12da36ccbf9ec", "author": {"user": {"login": "gustavoatt", "name": "Gustavo Torres"}}, "url": "https://github.com/apache/iceberg/commit/944c325ec3c92530ddebae31e8f12da36ccbf9ec", "committedDate": "2020-07-23T21:09:21Z", "message": "Add int96 timestamp type for parquet-read support"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0c94f883d73fa552eb33ebe620945e00710185f5", "author": {"user": {"login": "gustavoatt", "name": "Gustavo Torres"}}, "url": "https://github.com/apache/iceberg/commit/0c94f883d73fa552eb33ebe620945e00710185f5", "committedDate": "2020-07-23T21:10:12Z", "message": "Use spark's ParquetWriteSupport to test int96 timestamps read support"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0NDk2MDQ0", "url": "https://github.com/apache/iceberg/pull/1184#pullrequestreview-454496044", "createdAt": "2020-07-23T21:07:37Z", "commit": {"oid": "cea839f58b8b0e3d73f415b2770913e1d0955f31"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMTowNzozN1rOG2bnmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMTowNzozN1rOG2bnmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcyODc5Mw==", "bodyText": "Yes, looking at one of the tests we do support writing parquet files using Spark's WriteSupport.\nTo be able to use a FileAppender I had to add a TimestampAsInt96 type (that can only be written using Spark's builtin WriteSupport) so that schema conversion within Iceberg's ParquetWriteSupport knows that this timestamps should be encoded as int96 in the  parquet  schema.", "url": "https://github.com/apache/iceberg/pull/1184#discussion_r459728793", "createdAt": "2020-07-23T21:07:37Z", "author": {"login": "gustavoatt"}, "path": "spark/src/test/java/org/apache/iceberg/spark/data/TestSparkParquetReader.java", "diffHunk": "@@ -67,4 +78,49 @@ protected void writeAndValidate(Schema schema) throws IOException {\n       Assert.assertFalse(\"Should not have extra rows\", rows.hasNext());\n     }\n   }\n+\n+  protected List<InternalRow> rowsFromFile(InputFile inputFile, Schema schema) throws IOException {\n+    try (CloseableIterable<InternalRow> reader =\n+        Parquet.read(inputFile)\n+            .project(schema)\n+            .createReaderFunc(type -> SparkParquetReaders.buildReader(schema, type))\n+            .build()) {\n+      return Lists.newArrayList(reader);\n+    }\n+  }\n+\n+  @Test\n+  public void testInt96TimestampProducedBySparkIsReadCorrectly() throws IOException {\n+    final SparkSession spark =\n+        SparkSession.builder()\n+            .master(\"local[2]\")\n+            .config(\"spark.sql.parquet.int96AsTimestamp\", \"false\")\n+            .getOrCreate();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDAzNTgwNQ=="}, "originalCommit": {"oid": "cea839f58b8b0e3d73f415b2770913e1d0955f31"}, "originalPosition": 54}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b35027be3f3056b23a546f02ea9e4a1fcc91392c", "author": {"user": {"login": "gustavoatt", "name": "Gustavo Torres"}}, "url": "https://github.com/apache/iceberg/commit/b35027be3f3056b23a546f02ea9e4a1fcc91392c", "committedDate": "2020-07-23T23:20:32Z", "message": "Fix style checks"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0NjA3MTI2", "url": "https://github.com/apache/iceberg/pull/1184#pullrequestreview-454607126", "createdAt": "2020-07-24T02:36:32Z", "commit": {"oid": "b35027be3f3056b23a546f02ea9e4a1fcc91392c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQwMjozNjozM1rOG2hj_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQwMjozNjozM1rOG2hj_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgyNjE3NQ==", "bodyText": "I don't think we should change the type system to support this. INT96 may be something that we can read, but Iceberg cannot write it, per the spec.\nWas this needed to build the tests?", "url": "https://github.com/apache/iceberg/pull/1184#discussion_r459826175", "createdAt": "2020-07-24T02:36:33Z", "author": {"login": "rdblue"}, "path": "api/src/main/java/org/apache/iceberg/types/Types.java", "diffHunk": "@@ -219,16 +220,30 @@ public static TimestampType withoutZone() {\n       return INSTANCE_WITHOUT_ZONE;\n     }\n \n+    /**\n+     * @return Timestamp type (with timezone) represented as INT96. This is only added for compatibility reasons\n+     * and can only be written using a Spark's ParquetWriteSupport. Writing this type should be avoided.\n+     */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b35027be3f3056b23a546f02ea9e4a1fcc91392c"}, "originalPosition": 19}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0NjA3Mzk1", "url": "https://github.com/apache/iceberg/pull/1184#pullrequestreview-454607395", "createdAt": "2020-07-24T02:37:56Z", "commit": {"oid": "b35027be3f3056b23a546f02ea9e4a1fcc91392c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQwMjozNzo1NlrOG2hlBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQwMjozNzo1NlrOG2hlBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgyNjQzNg==", "bodyText": "Nit: we don't use final for local variables.", "url": "https://github.com/apache/iceberg/pull/1184#discussion_r459826436", "createdAt": "2020-07-24T02:37:56Z", "author": {"login": "rdblue"}, "path": "spark/src/test/java/org/apache/iceberg/spark/data/TestSparkParquetReader.java", "diffHunk": "@@ -67,4 +76,41 @@ protected void writeAndValidate(Schema schema) throws IOException {\n       Assert.assertFalse(\"Should not have extra rows\", rows.hasNext());\n     }\n   }\n+\n+  protected List<InternalRow> rowsFromFile(InputFile inputFile, Schema schema) throws IOException {\n+    try (CloseableIterable<InternalRow> reader =\n+        Parquet.read(inputFile)\n+            .project(schema)\n+            .createReaderFunc(type -> SparkParquetReaders.buildReader(schema, type))\n+            .build()) {\n+      return Lists.newArrayList(reader);\n+    }\n+  }\n+\n+  @Test\n+  public void testInt96TimestampProducedBySparkIsReadCorrectly() throws IOException {\n+    final Schema schema = new Schema(required(1, \"ts\", Types.TimestampType.asSparkInt96()));\n+    final StructType sparkSchema = SparkSchemaUtil.convert(schema);\n+    final Path parquetFile = Paths.get(temp.getRoot().getAbsolutePath(), \"parquet_int96.parquet\");\n+    final List<InternalRow> rows = Lists.newArrayList(RandomData.generateSpark(schema, 10, 0L));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b35027be3f3056b23a546f02ea9e4a1fcc91392c"}, "originalPosition": 51}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0NjA3NjMx", "url": "https://github.com/apache/iceberg/pull/1184#pullrequestreview-454607631", "createdAt": "2020-07-24T02:39:09Z", "commit": {"oid": "b35027be3f3056b23a546f02ea9e4a1fcc91392c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQwMjozOTowOVrOG2hl2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQwMjozOTowOVrOG2hl2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgyNjY1MA==", "bodyText": "Why not use temp.newFile?", "url": "https://github.com/apache/iceberg/pull/1184#discussion_r459826650", "createdAt": "2020-07-24T02:39:09Z", "author": {"login": "rdblue"}, "path": "spark/src/test/java/org/apache/iceberg/spark/data/TestSparkParquetReader.java", "diffHunk": "@@ -67,4 +76,41 @@ protected void writeAndValidate(Schema schema) throws IOException {\n       Assert.assertFalse(\"Should not have extra rows\", rows.hasNext());\n     }\n   }\n+\n+  protected List<InternalRow> rowsFromFile(InputFile inputFile, Schema schema) throws IOException {\n+    try (CloseableIterable<InternalRow> reader =\n+        Parquet.read(inputFile)\n+            .project(schema)\n+            .createReaderFunc(type -> SparkParquetReaders.buildReader(schema, type))\n+            .build()) {\n+      return Lists.newArrayList(reader);\n+    }\n+  }\n+\n+  @Test\n+  public void testInt96TimestampProducedBySparkIsReadCorrectly() throws IOException {\n+    final Schema schema = new Schema(required(1, \"ts\", Types.TimestampType.asSparkInt96()));\n+    final StructType sparkSchema = SparkSchemaUtil.convert(schema);\n+    final Path parquetFile = Paths.get(temp.getRoot().getAbsolutePath(), \"parquet_int96.parquet\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b35027be3f3056b23a546f02ea9e4a1fcc91392c"}, "originalPosition": 50}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0NjA3NzU1", "url": "https://github.com/apache/iceberg/pull/1184#pullrequestreview-454607755", "createdAt": "2020-07-24T02:39:45Z", "commit": {"oid": "b35027be3f3056b23a546f02ea9e4a1fcc91392c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQwMjozOTo0NVrOG2hmRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQwMjozOTo0NVrOG2hmRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgyNjc1OQ==", "bodyText": "I'd prefer to pass in a normal timestamp type and set a property, if needed, to enable INT96 support.", "url": "https://github.com/apache/iceberg/pull/1184#discussion_r459826759", "createdAt": "2020-07-24T02:39:45Z", "author": {"login": "rdblue"}, "path": "spark/src/test/java/org/apache/iceberg/spark/data/TestSparkParquetReader.java", "diffHunk": "@@ -67,4 +76,41 @@ protected void writeAndValidate(Schema schema) throws IOException {\n       Assert.assertFalse(\"Should not have extra rows\", rows.hasNext());\n     }\n   }\n+\n+  protected List<InternalRow> rowsFromFile(InputFile inputFile, Schema schema) throws IOException {\n+    try (CloseableIterable<InternalRow> reader =\n+        Parquet.read(inputFile)\n+            .project(schema)\n+            .createReaderFunc(type -> SparkParquetReaders.buildReader(schema, type))\n+            .build()) {\n+      return Lists.newArrayList(reader);\n+    }\n+  }\n+\n+  @Test\n+  public void testInt96TimestampProducedBySparkIsReadCorrectly() throws IOException {\n+    final Schema schema = new Schema(required(1, \"ts\", Types.TimestampType.asSparkInt96()));\n+    final StructType sparkSchema = SparkSchemaUtil.convert(schema);\n+    final Path parquetFile = Paths.get(temp.getRoot().getAbsolutePath(), \"parquet_int96.parquet\");\n+    final List<InternalRow> rows = Lists.newArrayList(RandomData.generateSpark(schema, 10, 0L));\n+\n+    try (FileAppender<InternalRow> writer =\n+        Parquet.write(Files.localOutput(parquetFile.toString()))\n+            .writeSupport(\n+                new org.apache.spark.sql.execution.datasources.parquet.ParquetWriteSupport())\n+            .set(\"org.apache.spark.sql.parquet.row.attributes\", sparkSchema.json())\n+            .set(\"org.apache.spark.legacyDateTime\", \"false\")\n+            .set(\"spark.sql.parquet.int96AsTimestamp\", \"true\")\n+            .set(\"spark.sql.parquet.writeLegacyFormat\", \"false\")\n+            .set(\"spark.sql.parquet.outputTimestampType\", \"INT96\")\n+            .schema(schema)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b35027be3f3056b23a546f02ea9e4a1fcc91392c"}, "originalPosition": 62}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7e48187c68417a6c947480022dc8a6e6945ed5ca", "author": {"user": {"login": "gustavoatt", "name": "Gustavo Torres"}}, "url": "https://github.com/apache/iceberg/commit/7e48187c68417a6c947480022dc8a6e6945ed5ca", "committedDate": "2020-07-24T19:39:21Z", "message": "Rewrite spark int96 test without creating Int96 timestamp type"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0OTg5Mzkz", "url": "https://github.com/apache/iceberg/pull/1184#pullrequestreview-454989393", "createdAt": "2020-07-24T15:38:52Z", "commit": {"oid": "b35027be3f3056b23a546f02ea9e4a1fcc91392c"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxNTozODo1MlrOG20NVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxOTo0NzoyMVrOG27xSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDEzMTY2OA==", "bodyText": "I initially tried that way but the writer fails because the file already exists.", "url": "https://github.com/apache/iceberg/pull/1184#discussion_r460131668", "createdAt": "2020-07-24T15:38:52Z", "author": {"login": "gustavoatt"}, "path": "spark/src/test/java/org/apache/iceberg/spark/data/TestSparkParquetReader.java", "diffHunk": "@@ -67,4 +76,41 @@ protected void writeAndValidate(Schema schema) throws IOException {\n       Assert.assertFalse(\"Should not have extra rows\", rows.hasNext());\n     }\n   }\n+\n+  protected List<InternalRow> rowsFromFile(InputFile inputFile, Schema schema) throws IOException {\n+    try (CloseableIterable<InternalRow> reader =\n+        Parquet.read(inputFile)\n+            .project(schema)\n+            .createReaderFunc(type -> SparkParquetReaders.buildReader(schema, type))\n+            .build()) {\n+      return Lists.newArrayList(reader);\n+    }\n+  }\n+\n+  @Test\n+  public void testInt96TimestampProducedBySparkIsReadCorrectly() throws IOException {\n+    final Schema schema = new Schema(required(1, \"ts\", Types.TimestampType.asSparkInt96()));\n+    final StructType sparkSchema = SparkSchemaUtil.convert(schema);\n+    final Path parquetFile = Paths.get(temp.getRoot().getAbsolutePath(), \"parquet_int96.parquet\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgyNjY1MA=="}, "originalCommit": {"oid": "b35027be3f3056b23a546f02ea9e4a1fcc91392c"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDEzMjAxMw==", "bodyText": "Done. Removed these final modifiers.", "url": "https://github.com/apache/iceberg/pull/1184#discussion_r460132013", "createdAt": "2020-07-24T15:39:27Z", "author": {"login": "gustavoatt"}, "path": "spark/src/test/java/org/apache/iceberg/spark/data/TestSparkParquetReader.java", "diffHunk": "@@ -67,4 +76,41 @@ protected void writeAndValidate(Schema schema) throws IOException {\n       Assert.assertFalse(\"Should not have extra rows\", rows.hasNext());\n     }\n   }\n+\n+  protected List<InternalRow> rowsFromFile(InputFile inputFile, Schema schema) throws IOException {\n+    try (CloseableIterable<InternalRow> reader =\n+        Parquet.read(inputFile)\n+            .project(schema)\n+            .createReaderFunc(type -> SparkParquetReaders.buildReader(schema, type))\n+            .build()) {\n+      return Lists.newArrayList(reader);\n+    }\n+  }\n+\n+  @Test\n+  public void testInt96TimestampProducedBySparkIsReadCorrectly() throws IOException {\n+    final Schema schema = new Schema(required(1, \"ts\", Types.TimestampType.asSparkInt96()));\n+    final StructType sparkSchema = SparkSchemaUtil.convert(schema);\n+    final Path parquetFile = Paths.get(temp.getRoot().getAbsolutePath(), \"parquet_int96.parquet\");\n+    final List<InternalRow> rows = Lists.newArrayList(RandomData.generateSpark(schema, 10, 0L));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgyNjQzNg=="}, "originalCommit": {"oid": "b35027be3f3056b23a546f02ea9e4a1fcc91392c"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI1NDcyOQ==", "bodyText": "Agreed. I found a way to have tests running that doesn't add a new type, I had to create an implementation of ParquetWriter.Builder that uses Spark's ParquetWriteSupport and Iceberg's ParquetWriteAdapter to avoid creating a SparkSession.", "url": "https://github.com/apache/iceberg/pull/1184#discussion_r460254729", "createdAt": "2020-07-24T19:45:27Z", "author": {"login": "gustavoatt"}, "path": "api/src/main/java/org/apache/iceberg/types/Types.java", "diffHunk": "@@ -219,16 +220,30 @@ public static TimestampType withoutZone() {\n       return INSTANCE_WITHOUT_ZONE;\n     }\n \n+    /**\n+     * @return Timestamp type (with timezone) represented as INT96. This is only added for compatibility reasons\n+     * and can only be written using a Spark's ParquetWriteSupport. Writing this type should be avoided.\n+     */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgyNjE3NQ=="}, "originalCommit": {"oid": "b35027be3f3056b23a546f02ea9e4a1fcc91392c"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI1NTU2Mw==", "bodyText": "I'm not sure I fully understand this comment.\nBut I did change my approach here, and while still writing InternalRow I removed most of these properties and left only the relevant ones to make sure that Spark writes these as int96.", "url": "https://github.com/apache/iceberg/pull/1184#discussion_r460255563", "createdAt": "2020-07-24T19:47:21Z", "author": {"login": "gustavoatt"}, "path": "spark/src/test/java/org/apache/iceberg/spark/data/TestSparkParquetReader.java", "diffHunk": "@@ -67,4 +76,41 @@ protected void writeAndValidate(Schema schema) throws IOException {\n       Assert.assertFalse(\"Should not have extra rows\", rows.hasNext());\n     }\n   }\n+\n+  protected List<InternalRow> rowsFromFile(InputFile inputFile, Schema schema) throws IOException {\n+    try (CloseableIterable<InternalRow> reader =\n+        Parquet.read(inputFile)\n+            .project(schema)\n+            .createReaderFunc(type -> SparkParquetReaders.buildReader(schema, type))\n+            .build()) {\n+      return Lists.newArrayList(reader);\n+    }\n+  }\n+\n+  @Test\n+  public void testInt96TimestampProducedBySparkIsReadCorrectly() throws IOException {\n+    final Schema schema = new Schema(required(1, \"ts\", Types.TimestampType.asSparkInt96()));\n+    final StructType sparkSchema = SparkSchemaUtil.convert(schema);\n+    final Path parquetFile = Paths.get(temp.getRoot().getAbsolutePath(), \"parquet_int96.parquet\");\n+    final List<InternalRow> rows = Lists.newArrayList(RandomData.generateSpark(schema, 10, 0L));\n+\n+    try (FileAppender<InternalRow> writer =\n+        Parquet.write(Files.localOutput(parquetFile.toString()))\n+            .writeSupport(\n+                new org.apache.spark.sql.execution.datasources.parquet.ParquetWriteSupport())\n+            .set(\"org.apache.spark.sql.parquet.row.attributes\", sparkSchema.json())\n+            .set(\"org.apache.spark.legacyDateTime\", \"false\")\n+            .set(\"spark.sql.parquet.int96AsTimestamp\", \"true\")\n+            .set(\"spark.sql.parquet.writeLegacyFormat\", \"false\")\n+            .set(\"spark.sql.parquet.outputTimestampType\", \"INT96\")\n+            .schema(schema)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgyNjc1OQ=="}, "originalCommit": {"oid": "b35027be3f3056b23a546f02ea9e4a1fcc91392c"}, "originalPosition": 62}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU1MTUyNTU0", "url": "https://github.com/apache/iceberg/pull/1184#pullrequestreview-455152554", "createdAt": "2020-07-24T20:01:13Z", "commit": {"oid": "7e48187c68417a6c947480022dc8a6e6945ed5ca"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQyMDowMToxM1rOG28I_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQyMDowMToxM1rOG28I_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI2MTYyOA==", "bodyText": "Note for reviewers (and future me): toByteBuffer returns a duplicate of the internal buffer so that it is safe for uses of it to modify the buffer's position with methods like getLong.", "url": "https://github.com/apache/iceberg/pull/1184#discussion_r460261628", "createdAt": "2020-07-24T20:01:13Z", "author": {"login": "rdblue"}, "path": "data/src/main/java/org/apache/iceberg/data/parquet/BaseParquetReaders.java", "diffHunk": "@@ -345,6 +352,25 @@ public LocalDateTime read(LocalDateTime reuse) {\n     }\n   }\n \n+  private static class TimestampInt96Reader extends ParquetValueReaders.PrimitiveReader<LocalDateTime> {\n+    private static final long UNIX_EPOCH_JULIAN = 2_440_588L;\n+\n+    private TimestampInt96Reader(ColumnDescriptor desc) {\n+      super(desc);\n+    }\n+\n+    @Override\n+    public LocalDateTime read(LocalDateTime reuse) {\n+      final ByteBuffer byteBuffer = column.nextBinary().toByteBuffer().order(ByteOrder.LITTLE_ENDIAN);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e48187c68417a6c947480022dc8a6e6945ed5ca"}, "originalPosition": 41}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "68dc4c5e091ea610011f3264f611615f73c1b05d", "author": {"user": {"login": "gustavoatt", "name": "Gustavo Torres"}}, "url": "https://github.com/apache/iceberg/commit/68dc4c5e091ea610011f3264f611615f73c1b05d", "committedDate": "2020-07-24T20:13:06Z", "message": "Test checkstyle fixes"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4235, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}