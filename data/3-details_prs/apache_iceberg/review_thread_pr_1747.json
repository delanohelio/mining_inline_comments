{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE4MTQ0NTYw", "number": 1747, "reviewThreads": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMTozNDo0NFrOE34egA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNlQwMToxMDozNFrOFBWVBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3MDMyNDQ4OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/apache/iceberg/expressions/ExpressionVisitors.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMTozNDo0NFrOHxfGgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQwNDo1MDo1OFrOHxqcLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY1MTg0Mw==", "bodyText": "I think new methods should throw UnsupportedOperationException so that visitors must be updated to work with isNaN.", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r521651843", "createdAt": "2020-11-11T21:34:44Z", "author": {"login": "rdblue"}, "path": "api/src/main/java/org/apache/iceberg/expressions/ExpressionVisitors.java", "diffHunk": "@@ -75,6 +75,14 @@ public R or(R leftResult, R rightResult) {\n       return null;\n     }\n \n+    public <T> R isNaN(BoundReference<T> ref) {\n+      return null;\n+    }\n+\n+    public <T> R notNaN(BoundReference<T> ref) {\n+      return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgzNzYxMw==", "bodyText": "I initially made these methods abstract to ensure I implemented them in all the child classes, but UnsupportedOperationException is definitely a better idea!", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r521837613", "createdAt": "2020-11-12T04:50:58Z", "author": {"login": "yyanyy"}, "path": "api/src/main/java/org/apache/iceberg/expressions/ExpressionVisitors.java", "diffHunk": "@@ -75,6 +75,14 @@ public R or(R leftResult, R rightResult) {\n       return null;\n     }\n \n+    public <T> R isNaN(BoundReference<T> ref) {\n+      return null;\n+    }\n+\n+    public <T> R notNaN(BoundReference<T> ref) {\n+      return null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY1MTg0Mw=="}, "originalCommit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3MDMzNDc3OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/apache/iceberg/expressions/UnboundPredicate.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMTozNzoyM1rOHxfMPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMTozNzoyM1rOHxfMPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY1MzMxMA==", "bodyText": "I think \"accepts\" isn't quite the right verb. What about \"includes\" instead?", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r521653310", "createdAt": "2020-11-11T21:37:23Z", "author": {"login": "rdblue"}, "path": "api/src/main/java/org/apache/iceberg/expressions/UnboundPredicate.java", "diffHunk": "@@ -127,11 +128,27 @@ private Expression bindUnaryOperation(BoundTerm<T> boundTerm) {\n           return Expressions.alwaysTrue();\n         }\n         return new BoundUnaryPredicate<>(Operation.NOT_NULL, boundTerm);\n+      case IS_NAN:\n+        if (typeAcceptsNaN(boundTerm.type().typeId())) {\n+          return new BoundUnaryPredicate<>(Operation.IS_NAN, boundTerm);\n+        } else {\n+          return Expressions.alwaysFalse();\n+        }\n+      case NOT_NAN:\n+        if (typeAcceptsNaN(boundTerm.type().typeId())) {\n+          return new BoundUnaryPredicate<>(Operation.NOT_NAN, boundTerm);\n+        } else {\n+          return Expressions.alwaysTrue();\n+        }\n       default:\n-        throw new ValidationException(\"Operation must be IS_NULL or NOT_NULL\");\n+        throw new ValidationException(\"Operation must be IS_NULL, NOT_NULL, IS_NAN, or NOT_NAN\");\n     }\n   }\n \n+  private boolean typeAcceptsNaN(Type.TypeID typeID) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3MDM0MjMyOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/apache/iceberg/expressions/BoundUnaryPredicate.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMTozOToxN1rOHxfQkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMTozOToxN1rOHxfQkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY1NDQxNw==", "bodyText": "Should this be a static helper somewhere since it is duplicated here and in Evaluator?", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r521654417", "createdAt": "2020-11-11T21:39:17Z", "author": {"login": "rdblue"}, "path": "api/src/main/java/org/apache/iceberg/expressions/BoundUnaryPredicate.java", "diffHunk": "@@ -46,18 +46,35 @@ public boolean test(T value) {\n         return value == null;\n       case NOT_NULL:\n         return value != null;\n+      case IS_NAN:\n+        return isNaN(value);\n+      case NOT_NAN:\n+        return !isNaN(value);\n       default:\n         throw new IllegalStateException(\"Invalid operation for BoundUnaryPredicate: \" + op());\n     }\n   }\n \n+  private boolean isNaN(T value) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3MDM1MDM3OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/apache/iceberg/expressions/InclusiveMetricsEvaluator.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMTo0MTo1N1rOHxfVcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMTozOTowMFrOH4gZYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY1NTY2Ng==", "bodyText": "Should we define a similar containsNaNsOnly method to use in notNaN and for a similar use in isNull?", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r521655666", "createdAt": "2020-11-11T21:41:57Z", "author": {"login": "rdblue"}, "path": "api/src/main/java/org/apache/iceberg/expressions/InclusiveMetricsEvaluator.java", "diffHunk": "@@ -150,6 +152,53 @@ public Boolean or(Boolean leftResult, Boolean rightResult) {\n       return ROWS_MIGHT_MATCH;\n     }\n \n+    @Override\n+    public <T> Boolean isNaN(BoundReference<T> ref) {\n+      Integer id = ref.fieldId();\n+\n+      if (nanCounts != null && nanCounts.containsKey(id) && nanCounts.get(id) == 0) {\n+        return ROWS_CANNOT_MATCH;\n+      }\n+\n+      // when there's no nanCounts information, but we already know the column only contains null,\n+      // it's guaranteed that there's no NaN value\n+      if (containsNullsOnly(id)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgzNzg3Nw==", "bodyText": "I didn't define notNaN originally as I could directly return ROWS_CANNOT_MATCH when both nanCounts and valueCounts contain this column but numbers don't match, without going into the next block of logic (of checking upper == lower == NaN and null count == 0); but this advantage no longer exists since that block needs to be removed.\nBut I wasn't sure if we need it for isNull: currently in isNull() we are checking if nullCounts == 0 to return ROWS_CANNOT_MATCH, and I guess the only chance where we rely on containsNaNsOnly to return ROWS_CANNOT_MATCH is nullCounts for this column doesn't exist but nanCounts does. I personally feel the chance of this happening would be small, do you think we will run into this case often?", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r521837877", "createdAt": "2020-11-12T04:51:58Z", "author": {"login": "yyanyy"}, "path": "api/src/main/java/org/apache/iceberg/expressions/InclusiveMetricsEvaluator.java", "diffHunk": "@@ -150,6 +152,53 @@ public Boolean or(Boolean leftResult, Boolean rightResult) {\n       return ROWS_MIGHT_MATCH;\n     }\n \n+    @Override\n+    public <T> Boolean isNaN(BoundReference<T> ref) {\n+      Integer id = ref.fieldId();\n+\n+      if (nanCounts != null && nanCounts.containsKey(id) && nanCounts.get(id) == 0) {\n+        return ROWS_CANNOT_MATCH;\n+      }\n+\n+      // when there's no nanCounts information, but we already know the column only contains null,\n+      // it's guaranteed that there's no NaN value\n+      if (containsNullsOnly(id)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY1NTY2Ng=="}, "originalCommit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQ1MjgwNA==", "bodyText": "I agree that the containsNaNsOnly logic will not be very useful as Yan said, but I think it is also valuable to have that private method just for readability.\nThen the question reduces to: do we need to consider the case that null value metrics do not exist but NaN metrics do. For now I think the answer is no, because in all metrics modes NaN and null counters either both exist or both not exist.", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r528452804", "createdAt": "2020-11-23T03:08:32Z", "author": {"login": "jackye1995"}, "path": "api/src/main/java/org/apache/iceberg/expressions/InclusiveMetricsEvaluator.java", "diffHunk": "@@ -150,6 +152,53 @@ public Boolean or(Boolean leftResult, Boolean rightResult) {\n       return ROWS_MIGHT_MATCH;\n     }\n \n+    @Override\n+    public <T> Boolean isNaN(BoundReference<T> ref) {\n+      Integer id = ref.fieldId();\n+\n+      if (nanCounts != null && nanCounts.containsKey(id) && nanCounts.get(id) == 0) {\n+        return ROWS_CANNOT_MATCH;\n+      }\n+\n+      // when there's no nanCounts information, but we already know the column only contains null,\n+      // it's guaranteed that there's no NaN value\n+      if (containsNullsOnly(id)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY1NTY2Ng=="}, "originalCommit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkyOTk0Ng==", "bodyText": "Sounds good, I'll create a containsNaNsOnly for readability. Ryan, do you have comment on the other point?", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r528929946", "createdAt": "2020-11-23T19:01:50Z", "author": {"login": "yyanyy"}, "path": "api/src/main/java/org/apache/iceberg/expressions/InclusiveMetricsEvaluator.java", "diffHunk": "@@ -150,6 +152,53 @@ public Boolean or(Boolean leftResult, Boolean rightResult) {\n       return ROWS_MIGHT_MATCH;\n     }\n \n+    @Override\n+    public <T> Boolean isNaN(BoundReference<T> ref) {\n+      Integer id = ref.fieldId();\n+\n+      if (nanCounts != null && nanCounts.containsKey(id) && nanCounts.get(id) == 0) {\n+        return ROWS_CANNOT_MATCH;\n+      }\n+\n+      // when there's no nanCounts information, but we already know the column only contains null,\n+      // it's guaranteed that there's no NaN value\n+      if (containsNullsOnly(id)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY1NTY2Ng=="}, "originalCommit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTAxMzA4OA==", "bodyText": "I agree with the reasoning. If we have NaN counts, then we should have null counts. No need to over-complicated the null logic with a check for when we don't have null counts but do have NaN counts. Good catch!", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r529013088", "createdAt": "2020-11-23T21:39:00Z", "author": {"login": "rdblue"}, "path": "api/src/main/java/org/apache/iceberg/expressions/InclusiveMetricsEvaluator.java", "diffHunk": "@@ -150,6 +152,53 @@ public Boolean or(Boolean leftResult, Boolean rightResult) {\n       return ROWS_MIGHT_MATCH;\n     }\n \n+    @Override\n+    public <T> Boolean isNaN(BoundReference<T> ref) {\n+      Integer id = ref.fieldId();\n+\n+      if (nanCounts != null && nanCounts.containsKey(id) && nanCounts.get(id) == 0) {\n+        return ROWS_CANNOT_MATCH;\n+      }\n+\n+      // when there's no nanCounts information, but we already know the column only contains null,\n+      // it's guaranteed that there's no NaN value\n+      if (containsNullsOnly(id)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY1NTY2Ng=="}, "originalCommit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3MDM1NTkxOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/apache/iceberg/expressions/InclusiveMetricsEvaluator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMTo0NDowMFrOHxfY3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQwNDo1MjowNFrOHxqdZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY1NjU0MA==", "bodyText": "I don't think this is true. This test shows an ORC case where upper and lower are NaN, but there are non-NaN values in the column.", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r521656540", "createdAt": "2020-11-11T21:44:00Z", "author": {"login": "rdblue"}, "path": "api/src/main/java/org/apache/iceberg/expressions/InclusiveMetricsEvaluator.java", "diffHunk": "@@ -150,6 +152,53 @@ public Boolean or(Boolean leftResult, Boolean rightResult) {\n       return ROWS_MIGHT_MATCH;\n     }\n \n+    @Override\n+    public <T> Boolean isNaN(BoundReference<T> ref) {\n+      Integer id = ref.fieldId();\n+\n+      if (nanCounts != null && nanCounts.containsKey(id) && nanCounts.get(id) == 0) {\n+        return ROWS_CANNOT_MATCH;\n+      }\n+\n+      // when there's no nanCounts information, but we already know the column only contains null,\n+      // it's guaranteed that there's no NaN value\n+      if (containsNullsOnly(id)) {\n+        return ROWS_CANNOT_MATCH;\n+      }\n+\n+      return ROWS_MIGHT_MATCH;\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"checkstyle:CyclomaticComplexity\")\n+    public <T> Boolean notNaN(BoundReference<T> ref) {\n+      Integer id = ref.fieldId();\n+\n+      if (nanCounts != null && nanCounts.containsKey(id) &&\n+          valueCounts != null && valueCounts.containsKey(id)) {\n+        if (nanCounts.get(id).equals(valueCounts.get(id))) {\n+          return ROWS_CANNOT_MATCH;\n+        }\n+\n+        return ROWS_MIGHT_MATCH;\n+      }\n+\n+      // for v1 table, when NaN could still be upper/lower bound,\n+      // if upper == lower == NaN and null count == 0, the column will only contain NaN", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgzNzkyNA==", "bodyText": "I totally forgot that, thanks for reminding this! Will remove this logic.", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r521837924", "createdAt": "2020-11-12T04:52:04Z", "author": {"login": "yyanyy"}, "path": "api/src/main/java/org/apache/iceberg/expressions/InclusiveMetricsEvaluator.java", "diffHunk": "@@ -150,6 +152,53 @@ public Boolean or(Boolean leftResult, Boolean rightResult) {\n       return ROWS_MIGHT_MATCH;\n     }\n \n+    @Override\n+    public <T> Boolean isNaN(BoundReference<T> ref) {\n+      Integer id = ref.fieldId();\n+\n+      if (nanCounts != null && nanCounts.containsKey(id) && nanCounts.get(id) == 0) {\n+        return ROWS_CANNOT_MATCH;\n+      }\n+\n+      // when there's no nanCounts information, but we already know the column only contains null,\n+      // it's guaranteed that there's no NaN value\n+      if (containsNullsOnly(id)) {\n+        return ROWS_CANNOT_MATCH;\n+      }\n+\n+      return ROWS_MIGHT_MATCH;\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"checkstyle:CyclomaticComplexity\")\n+    public <T> Boolean notNaN(BoundReference<T> ref) {\n+      Integer id = ref.fieldId();\n+\n+      if (nanCounts != null && nanCounts.containsKey(id) &&\n+          valueCounts != null && valueCounts.containsKey(id)) {\n+        if (nanCounts.get(id).equals(valueCounts.get(id))) {\n+          return ROWS_CANNOT_MATCH;\n+        }\n+\n+        return ROWS_MIGHT_MATCH;\n+      }\n+\n+      // for v1 table, when NaN could still be upper/lower bound,\n+      // if upper == lower == NaN and null count == 0, the column will only contain NaN", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY1NjU0MA=="}, "originalCommit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3MDM4MzkxOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/apache/iceberg/expressions/Expressions.java", "isResolved": false, "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMTo1Mjo1MFrOHxfpmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQwMjo1NzozNFrOH6KKKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY2MDgyNg==", "bodyText": "Do we also need to update the equality predicate to catch NaN and rewrite to isNaN?", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r521660826", "createdAt": "2020-11-11T21:52:50Z", "author": {"login": "rdblue"}, "path": "api/src/main/java/org/apache/iceberg/expressions/Expressions.java", "diffHunk": "@@ -123,6 +123,22 @@ public static Expression not(Expression child) {\n     return new UnboundPredicate<>(Expression.Operation.NOT_NULL, expr);\n   }\n \n+  public static <T> UnboundPredicate<T> isNaN(String name) {\n+    return new UnboundPredicate<>(Expression.Operation.IS_NAN, ref(name));\n+  }\n+\n+  public static <T> UnboundPredicate<T> isNaN(UnboundTerm<T> expr) {\n+    return new UnboundPredicate<>(Expression.Operation.IS_NAN, expr);\n+  }\n+\n+  public static <T> UnboundPredicate<T> notNaN(String name) {\n+    return new UnboundPredicate<>(Expression.Operation.NOT_NAN, ref(name));\n+  }\n+\n+  public static <T> UnboundPredicate<T> notNaN(UnboundTerm<T> expr) {\n+    return new UnboundPredicate<>(Expression.Operation.NOT_NAN, expr);\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgzNzk3Mw==", "bodyText": "I originally thought to update SparkFilters to do the rewrite, but this is a much better place. Thanks for the suggestion!\nEdit: what do you think about doing rewriting eq within UnboundPredicate? And for rewriting in, I was thinking to let Expressions.in to do the rewrite logic of or(isNaN, in)/and(notNaN, notIn), but that means it will return Expression instead of Predicate; does that align with your thinking?", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r521837973", "createdAt": "2020-11-12T04:52:11Z", "author": {"login": "yyanyy"}, "path": "api/src/main/java/org/apache/iceberg/expressions/Expressions.java", "diffHunk": "@@ -123,6 +123,22 @@ public static Expression not(Expression child) {\n     return new UnboundPredicate<>(Expression.Operation.NOT_NULL, expr);\n   }\n \n+  public static <T> UnboundPredicate<T> isNaN(String name) {\n+    return new UnboundPredicate<>(Expression.Operation.IS_NAN, ref(name));\n+  }\n+\n+  public static <T> UnboundPredicate<T> isNaN(UnboundTerm<T> expr) {\n+    return new UnboundPredicate<>(Expression.Operation.IS_NAN, expr);\n+  }\n+\n+  public static <T> UnboundPredicate<T> notNaN(String name) {\n+    return new UnboundPredicate<>(Expression.Operation.NOT_NAN, ref(name));\n+  }\n+\n+  public static <T> UnboundPredicate<T> notNaN(UnboundTerm<T> expr) {\n+    return new UnboundPredicate<>(Expression.Operation.NOT_NAN, expr);\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY2MDgyNg=="}, "originalCommit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQ1NjMwOA==", "bodyText": "I do not fully understand what you mean by \"rewrite logic of or(isNaN, in)/and(notNaN, notIn)\" when you talk about rewriting in. Can you give some examples of what predicate are you trying to support?", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r528456308", "createdAt": "2020-11-23T03:28:51Z", "author": {"login": "jackye1995"}, "path": "api/src/main/java/org/apache/iceberg/expressions/Expressions.java", "diffHunk": "@@ -123,6 +123,22 @@ public static Expression not(Expression child) {\n     return new UnboundPredicate<>(Expression.Operation.NOT_NULL, expr);\n   }\n \n+  public static <T> UnboundPredicate<T> isNaN(String name) {\n+    return new UnboundPredicate<>(Expression.Operation.IS_NAN, ref(name));\n+  }\n+\n+  public static <T> UnboundPredicate<T> isNaN(UnboundTerm<T> expr) {\n+    return new UnboundPredicate<>(Expression.Operation.IS_NAN, expr);\n+  }\n+\n+  public static <T> UnboundPredicate<T> notNaN(String name) {\n+    return new UnboundPredicate<>(Expression.Operation.NOT_NAN, ref(name));\n+  }\n+\n+  public static <T> UnboundPredicate<T> notNaN(UnboundTerm<T> expr) {\n+    return new UnboundPredicate<>(Expression.Operation.NOT_NAN, expr);\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY2MDgyNg=="}, "originalCommit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk0MDQ5OQ==", "bodyText": "So now since we want to handle NaN in in predicate, for query in(1,2, NaN) to avoid checking for NaN in in evaluation all the time we can transform that to in(1,2) or isNaN, and notIn(1,2,NaN) to notIn(1, 2) and notNaN. The problem is where to do that, since in and notIn are both predicate, and if we are extending them we are transforming a predicate (simpler form) to an expression (complex form), and I think there's no such case in the current code base, and it would touch a lot of existing test cases for this.", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r528940499", "createdAt": "2020-11-23T19:20:47Z", "author": {"login": "yyanyy"}, "path": "api/src/main/java/org/apache/iceberg/expressions/Expressions.java", "diffHunk": "@@ -123,6 +123,22 @@ public static Expression not(Expression child) {\n     return new UnboundPredicate<>(Expression.Operation.NOT_NULL, expr);\n   }\n \n+  public static <T> UnboundPredicate<T> isNaN(String name) {\n+    return new UnboundPredicate<>(Expression.Operation.IS_NAN, ref(name));\n+  }\n+\n+  public static <T> UnboundPredicate<T> isNaN(UnboundTerm<T> expr) {\n+    return new UnboundPredicate<>(Expression.Operation.IS_NAN, expr);\n+  }\n+\n+  public static <T> UnboundPredicate<T> notNaN(String name) {\n+    return new UnboundPredicate<>(Expression.Operation.NOT_NAN, ref(name));\n+  }\n+\n+  public static <T> UnboundPredicate<T> notNaN(UnboundTerm<T> expr) {\n+    return new UnboundPredicate<>(Expression.Operation.NOT_NAN, expr);\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY2MDgyNg=="}, "originalCommit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTAxNjY0Mw==", "bodyText": "Okay so it's what I thought, just a bit confused by the notation.\nSo for eq, what is the benefit of doing it in UnboundedPredicate versus just rewriting it in the Expressions?\nFor in, I think it is a more complex question.We need to figure out:\n\nshould syntax like in(1,2,NaN) be supported, given it can be written as is_nan or in(1,2) on client side\nif so, Expressions.in should return Expression as you said, which looks fine to me because the only caller SparkFilters.convert also returns an Expression in the end.\nmaybe we should tackle this in another PR to keep changes concise.", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r529016643", "createdAt": "2020-11-23T21:46:12Z", "author": {"login": "jackye1995"}, "path": "api/src/main/java/org/apache/iceberg/expressions/Expressions.java", "diffHunk": "@@ -123,6 +123,22 @@ public static Expression not(Expression child) {\n     return new UnboundPredicate<>(Expression.Operation.NOT_NULL, expr);\n   }\n \n+  public static <T> UnboundPredicate<T> isNaN(String name) {\n+    return new UnboundPredicate<>(Expression.Operation.IS_NAN, ref(name));\n+  }\n+\n+  public static <T> UnboundPredicate<T> isNaN(UnboundTerm<T> expr) {\n+    return new UnboundPredicate<>(Expression.Operation.IS_NAN, expr);\n+  }\n+\n+  public static <T> UnboundPredicate<T> notNaN(String name) {\n+    return new UnboundPredicate<>(Expression.Operation.NOT_NAN, ref(name));\n+  }\n+\n+  public static <T> UnboundPredicate<T> notNaN(UnboundTerm<T> expr) {\n+    return new UnboundPredicate<>(Expression.Operation.NOT_NAN, expr);\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY2MDgyNg=="}, "originalCommit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTAzMDY3MA==", "bodyText": "I think it is important to catch problems as early as possible, so I'd rather not add logic to binding if we can do it here. I see what you mean that it would require more test changes, but I think we could avoid that problem by simply rejecting predicates that are passed NaN, just like these methods reject null literals. That's an easy way to get this PR done and not over-complicate binding. What do you think?\nWe could still rewrite equals and notEquals.", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r529030670", "createdAt": "2020-11-23T22:15:11Z", "author": {"login": "rdblue"}, "path": "api/src/main/java/org/apache/iceberg/expressions/Expressions.java", "diffHunk": "@@ -123,6 +123,22 @@ public static Expression not(Expression child) {\n     return new UnboundPredicate<>(Expression.Operation.NOT_NULL, expr);\n   }\n \n+  public static <T> UnboundPredicate<T> isNaN(String name) {\n+    return new UnboundPredicate<>(Expression.Operation.IS_NAN, ref(name));\n+  }\n+\n+  public static <T> UnboundPredicate<T> isNaN(UnboundTerm<T> expr) {\n+    return new UnboundPredicate<>(Expression.Operation.IS_NAN, expr);\n+  }\n+\n+  public static <T> UnboundPredicate<T> notNaN(String name) {\n+    return new UnboundPredicate<>(Expression.Operation.NOT_NAN, ref(name));\n+  }\n+\n+  public static <T> UnboundPredicate<T> notNaN(UnboundTerm<T> expr) {\n+    return new UnboundPredicate<>(Expression.Operation.NOT_NAN, expr);\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY2MDgyNg=="}, "originalCommit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA2MjY0NQ==", "bodyText": "The main reason for me to suggest rewriting in UnboundPredicate is mostly for readability, as UnboundPredicate already contains quite some rewritings, and updating Expressions will result in more changes to itself and related test cases.\nI agree with catching problems early, and just to confirm, I guess this only applies to rejecting invalid input, as rewriting equals/notEquals in Expressions probably won't help with catching problem early as it probably won't throw anything by rewriting without binding? Based on my understanding I will do the following:\n\nreject >/>=/</<= NaN in Expressions (currently in UnboundPredicate, will move to Expressions)\ncheck if in/notIn literals contain NaN and reject\nrewrite eq/notEq in UnboundPredicate (already happening)\n\nPlease let me know if you have comment!", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r529062645", "createdAt": "2020-11-23T23:28:10Z", "author": {"login": "yyanyy"}, "path": "api/src/main/java/org/apache/iceberg/expressions/Expressions.java", "diffHunk": "@@ -123,6 +123,22 @@ public static Expression not(Expression child) {\n     return new UnboundPredicate<>(Expression.Operation.NOT_NULL, expr);\n   }\n \n+  public static <T> UnboundPredicate<T> isNaN(String name) {\n+    return new UnboundPredicate<>(Expression.Operation.IS_NAN, ref(name));\n+  }\n+\n+  public static <T> UnboundPredicate<T> isNaN(UnboundTerm<T> expr) {\n+    return new UnboundPredicate<>(Expression.Operation.IS_NAN, expr);\n+  }\n+\n+  public static <T> UnboundPredicate<T> notNaN(String name) {\n+    return new UnboundPredicate<>(Expression.Operation.NOT_NAN, ref(name));\n+  }\n+\n+  public static <T> UnboundPredicate<T> notNaN(UnboundTerm<T> expr) {\n+    return new UnboundPredicate<>(Expression.Operation.NOT_NAN, expr);\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY2MDgyNg=="}, "originalCommit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA4NzMyOA==", "bodyText": "My suggestion to reject invalid predicates should help avoid the problem of rewriting so much test code. What I'm trying to say is that if it requires changing the return type of one of the factory methods, let's throw an IllegalArgumentException instead so that we don't need to.\nFrom your list, I agree with 1 and 2, but for 3 I would do the rewrite in Expressions because isNan and notNaN rewrites will produce UnboundPredicate and we don't have to change the tests. Only rewriting in and notIn would require changing lots of tests, right?", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r529087328", "createdAt": "2020-11-24T00:38:59Z", "author": {"login": "rdblue"}, "path": "api/src/main/java/org/apache/iceberg/expressions/Expressions.java", "diffHunk": "@@ -123,6 +123,22 @@ public static Expression not(Expression child) {\n     return new UnboundPredicate<>(Expression.Operation.NOT_NULL, expr);\n   }\n \n+  public static <T> UnboundPredicate<T> isNaN(String name) {\n+    return new UnboundPredicate<>(Expression.Operation.IS_NAN, ref(name));\n+  }\n+\n+  public static <T> UnboundPredicate<T> isNaN(UnboundTerm<T> expr) {\n+    return new UnboundPredicate<>(Expression.Operation.IS_NAN, expr);\n+  }\n+\n+  public static <T> UnboundPredicate<T> notNaN(String name) {\n+    return new UnboundPredicate<>(Expression.Operation.NOT_NAN, ref(name));\n+  }\n+\n+  public static <T> UnboundPredicate<T> notNaN(UnboundTerm<T> expr) {\n+    return new UnboundPredicate<>(Expression.Operation.NOT_NAN, expr);\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY2MDgyNg=="}, "originalCommit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA5MzIwNQ==", "bodyText": "Thanks for the quick response! Yeah I think the amount of change to method return type/tests is not a concern now. I just wasn't entirely sure if rewriting eq to isNan in Expressions will help with catching problems early (comparing to rewriting in UnboundPredicate), since it seems to me that the related code will not have a chance to throw any exception until bind() is called?", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r529093205", "createdAt": "2020-11-24T00:56:20Z", "author": {"login": "yyanyy"}, "path": "api/src/main/java/org/apache/iceberg/expressions/Expressions.java", "diffHunk": "@@ -123,6 +123,22 @@ public static Expression not(Expression child) {\n     return new UnboundPredicate<>(Expression.Operation.NOT_NULL, expr);\n   }\n \n+  public static <T> UnboundPredicate<T> isNaN(String name) {\n+    return new UnboundPredicate<>(Expression.Operation.IS_NAN, ref(name));\n+  }\n+\n+  public static <T> UnboundPredicate<T> isNaN(UnboundTerm<T> expr) {\n+    return new UnboundPredicate<>(Expression.Operation.IS_NAN, expr);\n+  }\n+\n+  public static <T> UnboundPredicate<T> notNaN(String name) {\n+    return new UnboundPredicate<>(Expression.Operation.NOT_NAN, ref(name));\n+  }\n+\n+  public static <T> UnboundPredicate<T> notNaN(UnboundTerm<T> expr) {\n+    return new UnboundPredicate<>(Expression.Operation.NOT_NAN, expr);\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY2MDgyNg=="}, "originalCommit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA5NjI5MQ==", "bodyText": "Yeah, it isn't much earlier in that case. Maybe that actually exposes a problem with rewriting, too.\nExpressions.equal(\"c\", Double.NaN) if c is not a floating point column would result in isNaN, which should be rejected while binding expressions. You could argue that it should rewrite to alwaysFalse instead following the same logic as Expressions.equal(\"intCol\", Long.MAX_VALUE) -- it can't be true.\nI think that it would be better to be strict and reject binding in that case because something is clearly wrong. I think a lot of the time, that kind of error would happen when columns are misaligned or predicates are incorrectly converted.\nIf the result of those errors is just to fail in expression binding, then why rewrite at all? Maybe we should just reject NaN in any predicate and force people to explicitly use isNaN and notNaN. That way we do throw an exception much earlier in all cases. Plus, we wouldn't have to worry about confusion over whether NaN is equal to itself: in Java, a Double that holds NaN is equal to itself, but a primitive is not. \ud83d\ude15", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r529096291", "createdAt": "2020-11-24T01:06:01Z", "author": {"login": "rdblue"}, "path": "api/src/main/java/org/apache/iceberg/expressions/Expressions.java", "diffHunk": "@@ -123,6 +123,22 @@ public static Expression not(Expression child) {\n     return new UnboundPredicate<>(Expression.Operation.NOT_NULL, expr);\n   }\n \n+  public static <T> UnboundPredicate<T> isNaN(String name) {\n+    return new UnboundPredicate<>(Expression.Operation.IS_NAN, ref(name));\n+  }\n+\n+  public static <T> UnboundPredicate<T> isNaN(UnboundTerm<T> expr) {\n+    return new UnboundPredicate<>(Expression.Operation.IS_NAN, expr);\n+  }\n+\n+  public static <T> UnboundPredicate<T> notNaN(String name) {\n+    return new UnboundPredicate<>(Expression.Operation.NOT_NAN, ref(name));\n+  }\n+\n+  public static <T> UnboundPredicate<T> notNaN(UnboundTerm<T> expr) {\n+    return new UnboundPredicate<>(Expression.Operation.NOT_NAN, expr);\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY2MDgyNg=="}, "originalCommit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE3NjE5NQ==", "bodyText": "Thanks, those are some good points! To make sure I understand correctly/know how to move forward, I have some questions:\n\nIf I understand correctly, to reject NaN in any predicate sounds like we might go back to the idea of rewriting equals in SparkFilters (or in general, the integration point with engines during the query-to-expression translation); or maybe even earlier than that, to let engines to support syntax of is NaN?\nSince to know if a query is eligible to be translated to isNaN there has to be some place that ensures the type has to be either double or float, and in iceberg code base we will only know this during binding; are we able to rely on engine to do this check before translating query to Expression?\nAnd seems like this may only impact eq as we decided to do input validation on other lg/lteq/gt/gteq and in anyway?\nAnd if we start to throw exceptions when the code passes in NaN to eq, that may sound backward incompatible until the engine starts to rewrite NaN?\n\nI guess the conversation is starting to get too detailed, if you wouldn't mind I'll try to follow up on Slack tomorrow and then post the conclusion here?", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r529176195", "createdAt": "2020-11-24T03:21:11Z", "author": {"login": "yyanyy"}, "path": "api/src/main/java/org/apache/iceberg/expressions/Expressions.java", "diffHunk": "@@ -123,6 +123,22 @@ public static Expression not(Expression child) {\n     return new UnboundPredicate<>(Expression.Operation.NOT_NULL, expr);\n   }\n \n+  public static <T> UnboundPredicate<T> isNaN(String name) {\n+    return new UnboundPredicate<>(Expression.Operation.IS_NAN, ref(name));\n+  }\n+\n+  public static <T> UnboundPredicate<T> isNaN(UnboundTerm<T> expr) {\n+    return new UnboundPredicate<>(Expression.Operation.IS_NAN, expr);\n+  }\n+\n+  public static <T> UnboundPredicate<T> notNaN(String name) {\n+    return new UnboundPredicate<>(Expression.Operation.NOT_NAN, ref(name));\n+  }\n+\n+  public static <T> UnboundPredicate<T> notNaN(UnboundTerm<T> expr) {\n+    return new UnboundPredicate<>(Expression.Operation.NOT_NAN, expr);\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY2MDgyNg=="}, "originalCommit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTgxMzg0Nw==", "bodyText": "If I understand correctly, to reject NaN in any predicate sounds like we might go back to the idea of rewriting equals in SparkFilters\n\nYes. If the engine generally uses d = NaN then we can convert that to isNaN. But that would be engine-dependent and the Iceberg expression API would not support equals with NaN.\n\nare we able to rely on engine to do this check before translating query to Expression?\n\nI think so. Most engines will optimize the SQL expressions and handle this already. If not, then it would result in an exception from Iceberg to the user. I think that's okay, too, because as I said above, we want to fail if a NaN is used in an expression with a non-floating-point column, not rewrite to false.\n\nAnd seems like this may only impact eq as we decided to do input validation on other lg/lteq/gt/gteq and in anyway?\n\nYes. This makes all of the handling in Expressions consistent: always reject NaN values.\n\nthat may sound backward incompatible until the engine starts to rewrite NaN?\n\nI'm not convinced either way. You could argue that d = NaN is ambiguous and that rejecting it is now fixing a bug. That's certainly the case with d > NaN, which is not defined. On the other hand, there was some bevhavior before that will now no longer work. So I'd be up for fixing this in Flink and Spark conversions as soon as we can.\nFeel free to ping me on Slack!", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r529813847", "createdAt": "2020-11-24T19:07:08Z", "author": {"login": "rdblue"}, "path": "api/src/main/java/org/apache/iceberg/expressions/Expressions.java", "diffHunk": "@@ -123,6 +123,22 @@ public static Expression not(Expression child) {\n     return new UnboundPredicate<>(Expression.Operation.NOT_NULL, expr);\n   }\n \n+  public static <T> UnboundPredicate<T> isNaN(String name) {\n+    return new UnboundPredicate<>(Expression.Operation.IS_NAN, ref(name));\n+  }\n+\n+  public static <T> UnboundPredicate<T> isNaN(UnboundTerm<T> expr) {\n+    return new UnboundPredicate<>(Expression.Operation.IS_NAN, expr);\n+  }\n+\n+  public static <T> UnboundPredicate<T> notNaN(String name) {\n+    return new UnboundPredicate<>(Expression.Operation.NOT_NAN, ref(name));\n+  }\n+\n+  public static <T> UnboundPredicate<T> notNaN(UnboundTerm<T> expr) {\n+    return new UnboundPredicate<>(Expression.Operation.NOT_NAN, expr);\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY2MDgyNg=="}, "originalCommit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDc0NTg5Nw==", "bodyText": "Thank you for the explanation! I think now I understand the full picture. I think I've addressed everything except for rewriting in SparkFilters and other engines, which I think this PR is already too big so I'll submit a separate PR for it (likely next week).", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r530745897", "createdAt": "2020-11-26T02:57:34Z", "author": {"login": "yyanyy"}, "path": "api/src/main/java/org/apache/iceberg/expressions/Expressions.java", "diffHunk": "@@ -123,6 +123,22 @@ public static Expression not(Expression child) {\n     return new UnboundPredicate<>(Expression.Operation.NOT_NULL, expr);\n   }\n \n+  public static <T> UnboundPredicate<T> isNaN(String name) {\n+    return new UnboundPredicate<>(Expression.Operation.IS_NAN, ref(name));\n+  }\n+\n+  public static <T> UnboundPredicate<T> isNaN(UnboundTerm<T> expr) {\n+    return new UnboundPredicate<>(Expression.Operation.IS_NAN, expr);\n+  }\n+\n+  public static <T> UnboundPredicate<T> notNaN(String name) {\n+    return new UnboundPredicate<>(Expression.Operation.NOT_NAN, ref(name));\n+  }\n+\n+  public static <T> UnboundPredicate<T> notNaN(UnboundTerm<T> expr) {\n+    return new UnboundPredicate<>(Expression.Operation.NOT_NAN, expr);\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY2MDgyNg=="}, "originalCommit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3MDM4OTQ4OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/apache/iceberg/expressions/ManifestEvaluator.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMTo1NDo0M1rOHxftHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMzoyODo1NlrOH4jcAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY2MTcyNA==", "bodyText": "To be safe, I think this should validate that containsNull is true.", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r521661724", "createdAt": "2020-11-11T21:54:43Z", "author": {"login": "rdblue"}, "path": "api/src/main/java/org/apache/iceberg/expressions/ManifestEvaluator.java", "diffHunk": "@@ -142,6 +142,25 @@ public Boolean or(Boolean leftResult, Boolean rightResult) {\n       return ROWS_MIGHT_MATCH;\n     }\n \n+    @Override\n+    public <T> Boolean isNaN(BoundReference<T> ref) {\n+      int pos = Accessors.toPosition(ref.accessor());\n+      // containsNull encodes whether at least one partition value is null, lowerBound is null if\n+      // all partition values are null.\n+      ByteBuffer lowerBound = stats.get(pos).lowerBound();\n+      if (lowerBound == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgzODIwMQ==", "bodyText": "You mean check for both containsNull and stats.get(pos).lowerBound() == null are true? When would lowerBound be null while the column doesn't contain null? I guess I'll also need to update notNull for this too (since I copied the logic from there)?", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r521838201", "createdAt": "2020-11-12T04:53:07Z", "author": {"login": "yyanyy"}, "path": "api/src/main/java/org/apache/iceberg/expressions/ManifestEvaluator.java", "diffHunk": "@@ -142,6 +142,25 @@ public Boolean or(Boolean leftResult, Boolean rightResult) {\n       return ROWS_MIGHT_MATCH;\n     }\n \n+    @Override\n+    public <T> Boolean isNaN(BoundReference<T> ref) {\n+      int pos = Accessors.toPosition(ref.accessor());\n+      // containsNull encodes whether at least one partition value is null, lowerBound is null if\n+      // all partition values are null.\n+      ByteBuffer lowerBound = stats.get(pos).lowerBound();\n+      if (lowerBound == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY2MTcyNA=="}, "originalCommit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQ1NDc2OA==", "bodyText": "Seems like #1803 is missing PartitionFieldSummary.containsNaN(), or is it in some other PR?", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r528454768", "createdAt": "2020-11-23T03:20:04Z", "author": {"login": "jackye1995"}, "path": "api/src/main/java/org/apache/iceberg/expressions/ManifestEvaluator.java", "diffHunk": "@@ -142,6 +142,25 @@ public Boolean or(Boolean leftResult, Boolean rightResult) {\n       return ROWS_MIGHT_MATCH;\n     }\n \n+    @Override\n+    public <T> Boolean isNaN(BoundReference<T> ref) {\n+      int pos = Accessors.toPosition(ref.accessor());\n+      // containsNull encodes whether at least one partition value is null, lowerBound is null if\n+      // all partition values are null.\n+      ByteBuffer lowerBound = stats.get(pos).lowerBound();\n+      if (lowerBound == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY2MTcyNA=="}, "originalCommit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkzNTYwNg==", "bodyText": "That should be doable, although I originally consider the scope of the NaN support to be only on manifest entry level, I  wasn't sure if we want to extend it beyond that?", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r528935606", "createdAt": "2020-11-23T19:11:56Z", "author": {"login": "yyanyy"}, "path": "api/src/main/java/org/apache/iceberg/expressions/ManifestEvaluator.java", "diffHunk": "@@ -142,6 +142,25 @@ public Boolean or(Boolean leftResult, Boolean rightResult) {\n       return ROWS_MIGHT_MATCH;\n     }\n \n+    @Override\n+    public <T> Boolean isNaN(BoundReference<T> ref) {\n+      int pos = Accessors.toPosition(ref.accessor());\n+      // containsNull encodes whether at least one partition value is null, lowerBound is null if\n+      // all partition values are null.\n+      ByteBuffer lowerBound = stats.get(pos).lowerBound();\n+      if (lowerBound == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY2MTcyNA=="}, "originalCommit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTAyMjk5MQ==", "bodyText": "I'm not sure of a case where it would happen, but containsNull is the source of truth for whether there are null values, not a missing bound value.", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r529022991", "createdAt": "2020-11-23T21:58:54Z", "author": {"login": "rdblue"}, "path": "api/src/main/java/org/apache/iceberg/expressions/ManifestEvaluator.java", "diffHunk": "@@ -142,6 +142,25 @@ public Boolean or(Boolean leftResult, Boolean rightResult) {\n       return ROWS_MIGHT_MATCH;\n     }\n \n+    @Override\n+    public <T> Boolean isNaN(BoundReference<T> ref) {\n+      int pos = Accessors.toPosition(ref.accessor());\n+      // containsNull encodes whether at least one partition value is null, lowerBound is null if\n+      // all partition values are null.\n+      ByteBuffer lowerBound = stats.get(pos).lowerBound();\n+      if (lowerBound == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY2MTcyNA=="}, "originalCommit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA2MjkxMw==", "bodyText": "Sounds good, I'll add containsNull to both here and notNull. And looks like we do want to update PartitionFieldSummary, that I'll do in a separate pr.", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r529062913", "createdAt": "2020-11-23T23:28:56Z", "author": {"login": "yyanyy"}, "path": "api/src/main/java/org/apache/iceberg/expressions/ManifestEvaluator.java", "diffHunk": "@@ -142,6 +142,25 @@ public Boolean or(Boolean leftResult, Boolean rightResult) {\n       return ROWS_MIGHT_MATCH;\n     }\n \n+    @Override\n+    public <T> Boolean isNaN(BoundReference<T> ref) {\n+      int pos = Accessors.toPosition(ref.accessor());\n+      // containsNull encodes whether at least one partition value is null, lowerBound is null if\n+      // all partition values are null.\n+      ByteBuffer lowerBound = stats.get(pos).lowerBound();\n+      if (lowerBound == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY2MTcyNA=="}, "originalCommit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3MDM5NzgxOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/apache/iceberg/expressions/StrictMetricsEvaluator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMTo1NzozOVrOHxfyEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMTo1NzozOVrOHxfyEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY2Mjk5NQ==", "bodyText": "Good catch.", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r521662995", "createdAt": "2020-11-11T21:57:39Z", "author": {"login": "rdblue"}, "path": "api/src/main/java/org/apache/iceberg/expressions/StrictMetricsEvaluator.java", "diffHunk": "@@ -57,10 +57,10 @@ public StrictMetricsEvaluator(Schema schema, Expression unbound) {\n   }\n \n   /**\n-   * Test whether the file may contain records that match the expression.\n+   * Test whether all records within the file match the expression.\n    *\n    * @param file a data file\n-   * @return false if the file cannot contain rows that match the expression, true otherwise.\n+   * @return false if the file may contain any row that doesn't match the expression, true otherwise.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3MDQwMTE0OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/apache/iceberg/expressions/StrictMetricsEvaluator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMTo1ODo0N1rOHxf0IQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQwNDo1MzoxMlrOHxqemQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY2MzUyMQ==", "bodyText": "Same here as above. If there are non-NaN values then this should return ROWS_MIGHT_NOT_MATCH.", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r521663521", "createdAt": "2020-11-11T21:58:47Z", "author": {"login": "rdblue"}, "path": "api/src/main/java/org/apache/iceberg/expressions/StrictMetricsEvaluator.java", "diffHunk": "@@ -144,6 +146,51 @@ public Boolean or(Boolean leftResult, Boolean rightResult) {\n       return ROWS_MIGHT_NOT_MATCH;\n     }\n \n+    @Override\n+    @SuppressWarnings(\"checkstyle:CyclomaticComplexity\")\n+    public <T> Boolean isNaN(BoundReference<T> ref) {\n+      int id = ref.fieldId();\n+\n+      if (nanCounts != null && nanCounts.containsKey(id) &&\n+          valueCounts != null && valueCounts.containsKey(id)) {\n+        if (nanCounts.get(id).equals(valueCounts.get(id))) {\n+          return ROWS_MUST_MATCH;\n+        }\n+\n+        return ROWS_MIGHT_NOT_MATCH;\n+      }\n+\n+      // for v1 table, when NaN could still be upper/lower bound,\n+      // if upper == lower == NaN and null count == 0, the column will only contain NaN", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgzODIzMw==", "bodyText": "\ud83d\udc4d  will remove this block", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r521838233", "createdAt": "2020-11-12T04:53:12Z", "author": {"login": "yyanyy"}, "path": "api/src/main/java/org/apache/iceberg/expressions/StrictMetricsEvaluator.java", "diffHunk": "@@ -144,6 +146,51 @@ public Boolean or(Boolean leftResult, Boolean rightResult) {\n       return ROWS_MIGHT_NOT_MATCH;\n     }\n \n+    @Override\n+    @SuppressWarnings(\"checkstyle:CyclomaticComplexity\")\n+    public <T> Boolean isNaN(BoundReference<T> ref) {\n+      int id = ref.fieldId();\n+\n+      if (nanCounts != null && nanCounts.containsKey(id) &&\n+          valueCounts != null && valueCounts.containsKey(id)) {\n+        if (nanCounts.get(id).equals(valueCounts.get(id))) {\n+          return ROWS_MUST_MATCH;\n+        }\n+\n+        return ROWS_MIGHT_NOT_MATCH;\n+      }\n+\n+      // for v1 table, when NaN could still be upper/lower bound,\n+      // if upper == lower == NaN and null count == 0, the column will only contain NaN", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY2MzUyMQ=="}, "originalCommit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3MDQwNjExOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/apache/iceberg/expressions/ResidualEvaluator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMjowMDoxOVrOHxf3FA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMjowMDoxOVrOHxf3FA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY2NDI3Ng==", "bodyText": "Here's another implementation of the same test.", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r521664276", "createdAt": "2020-11-11T22:00:19Z", "author": {"login": "rdblue"}, "path": "api/src/main/java/org/apache/iceberg/expressions/ResidualEvaluator.java", "diffHunk": "@@ -152,6 +152,30 @@ public Expression or(Expression leftResult, Expression rightResult) {\n       return (ref.eval(struct) != null) ? alwaysTrue() : alwaysFalse();\n     }\n \n+    @Override\n+    public <T> Expression isNaN(BoundReference<T> ref) {\n+      return isNaN(ref.eval(struct)) ? alwaysTrue() : alwaysFalse();\n+    }\n+\n+    @Override\n+    public <T> Expression notNaN(BoundReference<T> ref) {\n+      return isNaN(ref.eval(struct)) ? alwaysFalse() : alwaysTrue();\n+    }\n+\n+    private <T> boolean isNaN(T value) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3MDQyNjI5OnYy", "diffSide": "RIGHT", "path": "api/src/test/java/org/apache/iceberg/expressions/TestInclusiveMetricsEvaluator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMjowNzozN1rOHxgDQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMjowNzozN1rOHxgDQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY2NzM5NA==", "bodyText": "Minor: Using FILE_2 is a little strange to read because the column is still called \"no_nans\". Consider adding another column instead called no_nan_stats just like the no_stats column that is used for isNull/notNull.", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r521667394", "createdAt": "2020-11-11T22:07:37Z", "author": {"login": "rdblue"}, "path": "api/src/test/java/org/apache/iceberg/expressions/TestInclusiveMetricsEvaluator.java", "diffHunk": "@@ -156,6 +192,54 @@ public void testNoNulls() {\n     Assert.assertFalse(\"Should skip: non-null column contains no null values\", shouldRead);\n   }\n \n+  @Test\n+  public void testIsNaN() {\n+    boolean shouldRead = new InclusiveMetricsEvaluator(SCHEMA, isNaN(\"all_nans\")).eval(FILE);\n+    Assert.assertTrue(\"Should read: at least one nan value in all nan column\", shouldRead);\n+\n+    shouldRead = new InclusiveMetricsEvaluator(SCHEMA, isNaN(\"some_nans\")).eval(FILE);\n+    Assert.assertTrue(\"Should read: at least one nan value in some nan column\", shouldRead);\n+\n+    shouldRead = new InclusiveMetricsEvaluator(SCHEMA, isNaN(\"no_nans\")).eval(FILE);\n+    Assert.assertFalse(\"Should skip: no-nans column contains no nan values\", shouldRead);\n+\n+    shouldRead = new InclusiveMetricsEvaluator(SCHEMA, isNaN(\"all_nulls_double\")).eval(FILE);\n+    Assert.assertFalse(\"Should skip: all-null column doesn't contain nan value\", shouldRead);\n+\n+    shouldRead = new InclusiveMetricsEvaluator(SCHEMA, isNaN(\"no_nans\")).eval(FILE_2);\n+    Assert.assertTrue(\"Should read: no guarantee on if contains nan value without nan stats\", shouldRead);\n+\n+    shouldRead = new InclusiveMetricsEvaluator(SCHEMA, isNaN(\"all_nans_v1_stats\")).eval(FILE);\n+    Assert.assertTrue(\"Should read: at least one nan value in all nan column\", shouldRead);\n+\n+    shouldRead = new InclusiveMetricsEvaluator(SCHEMA, isNaN(\"nan_and_null_only\")).eval(FILE);\n+    Assert.assertTrue(\"Should read: at least one nan value in nan and nulls only column\", shouldRead);\n+  }\n+\n+  @Test\n+  public void testNotNaN() {\n+    boolean shouldRead = new InclusiveMetricsEvaluator(SCHEMA, notNaN(\"all_nans\")).eval(FILE);\n+    Assert.assertFalse(\"Should skip: column with all nans will not contain non-nan\", shouldRead);\n+\n+    shouldRead = new InclusiveMetricsEvaluator(SCHEMA, notNaN(\"some_nans\")).eval(FILE);\n+    Assert.assertTrue(\"Should read: at least one non-nan value in some nan column\", shouldRead);\n+\n+    shouldRead = new InclusiveMetricsEvaluator(SCHEMA, notNaN(\"no_nans\")).eval(FILE);\n+    Assert.assertTrue(\"Should read: at least one non-nan value in no nan column\", shouldRead);\n+\n+    shouldRead = new InclusiveMetricsEvaluator(SCHEMA, notNaN(\"all_nulls_double\")).eval(FILE);\n+    Assert.assertTrue(\"Should read: at least one non-nan value in all null column\", shouldRead);\n+\n+    shouldRead = new InclusiveMetricsEvaluator(SCHEMA, notNaN(\"no_nans\")).eval(FILE_2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "originalPosition": 152}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3MDQ2MDA1OnYy", "diffSide": "RIGHT", "path": "api/src/test/java/org/apache/iceberg/transforms/TestResiduals.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMjoxOToyMVrOHxgXYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQwMjo1OTozNVrOH6KMOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY3MjU0NQ==", "bodyText": "Do we need NaN cases for other evaluators?", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r521672545", "createdAt": "2020-11-11T22:19:21Z", "author": {"login": "rdblue"}, "path": "api/src/test/java/org/apache/iceberg/transforms/TestResiduals.java", "diffHunk": "@@ -214,6 +218,36 @@ public void testInTimestamp() {\n     Assert.assertEquals(\"Residual should be alwaysFalse\", alwaysFalse(), residual);\n   }\n \n+  @Test\n+  public void testInNaN() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgzODMxNA==", "bodyText": "You mean testing InNaN case for other evaluators? Yeah I'll do that", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r521838314", "createdAt": "2020-11-12T04:53:32Z", "author": {"login": "yyanyy"}, "path": "api/src/test/java/org/apache/iceberg/transforms/TestResiduals.java", "diffHunk": "@@ -214,6 +218,36 @@ public void testInTimestamp() {\n     Assert.assertEquals(\"Residual should be alwaysFalse\", alwaysFalse(), residual);\n   }\n \n+  @Test\n+  public void testInNaN() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY3MjU0NQ=="}, "originalCommit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDc0NjQyNA==", "bodyText": "Since we decided that we don't accept NaN in in, I guess this conversation is outdated. I've removed inNaN test from here.", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r530746424", "createdAt": "2020-11-26T02:59:35Z", "author": {"login": "yyanyy"}, "path": "api/src/test/java/org/apache/iceberg/transforms/TestResiduals.java", "diffHunk": "@@ -214,6 +218,36 @@ public void testInTimestamp() {\n     Assert.assertEquals(\"Residual should be alwaysFalse\", alwaysFalse(), residual);\n   }\n \n+  @Test\n+  public void testInNaN() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY3MjU0NQ=="}, "originalCommit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3MDQ3MjYyOnYy", "diffSide": "RIGHT", "path": "data/src/test/java/org/apache/iceberg/data/TestMetricsRowGroupFilter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMjoyMzozMFrOHxgetQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMjoyMzozMFrOHxgetQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY3NDQyMQ==", "bodyText": "Maybe update the context to \"NaN counts are not tracked in Parquet metrics\".", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r521674421", "createdAt": "2020-11-11T22:23:30Z", "author": {"login": "rdblue"}, "path": "data/src/test/java/org/apache/iceberg/data/TestMetricsRowGroupFilter.java", "diffHunk": "@@ -281,6 +295,37 @@ public void testNoNulls() {\n     Assert.assertTrue(\"Should read: struct type is not skipped\", shouldRead);\n   }\n \n+  @Test\n+  public void testIsNaN() {\n+    boolean shouldRead = shouldRead(isNaN(\"all_nans\"));\n+    Assert.assertTrue(\"Should read: not enough information\", shouldRead);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3MDQ3ODIzOnYy", "diffSide": "RIGHT", "path": "parquet/src/main/java/org/apache/iceberg/parquet/ParquetDictionaryRowGroupFilter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMjoyNToyOFrOHxgiEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQwNDo1MzozN1rOHxqfHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY3NTI4MQ==", "bodyText": "If there is a NaN value, then it would be in the Parquet dictionary. I think that we can implement this for Parquet.", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r521675281", "createdAt": "2020-11-11T22:25:28Z", "author": {"login": "rdblue"}, "path": "parquet/src/main/java/org/apache/iceberg/parquet/ParquetDictionaryRowGroupFilter.java", "diffHunk": "@@ -148,6 +148,16 @@ public Boolean or(Boolean leftResult, Boolean rightResult) {\n       return ROWS_MIGHT_MATCH;\n     }\n \n+    @Override\n+    public <T> Boolean isNaN(BoundReference<T> ref) {\n+      return ROWS_MIGHT_MATCH;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgzODM2Ng==", "bodyText": "Thanks! I'll see how it works", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r521838366", "createdAt": "2020-11-12T04:53:37Z", "author": {"login": "yyanyy"}, "path": "parquet/src/main/java/org/apache/iceberg/parquet/ParquetDictionaryRowGroupFilter.java", "diffHunk": "@@ -148,6 +148,16 @@ public Boolean or(Boolean leftResult, Boolean rightResult) {\n       return ROWS_MIGHT_MATCH;\n     }\n \n+    @Override\n+    public <T> Boolean isNaN(BoundReference<T> ref) {\n+      return ROWS_MIGHT_MATCH;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY3NTI4MQ=="}, "originalCommit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMzk1MzU5OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/apache/iceberg/expressions/ExpressionVisitors.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QwMToxOTozMVrOH39LwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMTo0MjozMFrOH4ggJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQzNjE2MQ==", "bodyText": "why not be consistent with isNull and notNull and return null?", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r528436161", "createdAt": "2020-11-23T01:19:31Z", "author": {"login": "jackye1995"}, "path": "api/src/main/java/org/apache/iceberg/expressions/ExpressionVisitors.java", "diffHunk": "@@ -75,6 +75,14 @@ public R or(R leftResult, R rightResult) {\n       return null;\n     }\n \n+    public <T> R isNaN(BoundReference<T> ref) {\n+      throw new UnsupportedOperationException(this.getClass().getName() + \" does not implement isNaN\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fc48a0f465426d032cbe2fe0a6c6026438536ec"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkzMDA1Ng==", "bodyText": "This is actually a point brought up by Ryan earlier :D This was so that visitors must be updated to work with isNaN.", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r528930056", "createdAt": "2020-11-23T19:02:00Z", "author": {"login": "yyanyy"}, "path": "api/src/main/java/org/apache/iceberg/expressions/ExpressionVisitors.java", "diffHunk": "@@ -75,6 +75,14 @@ public R or(R leftResult, R rightResult) {\n       return null;\n     }\n \n+    public <T> R isNaN(BoundReference<T> ref) {\n+      throw new UnsupportedOperationException(this.getClass().getName() + \" does not implement isNaN\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQzNjE2MQ=="}, "originalCommit": {"oid": "3fc48a0f465426d032cbe2fe0a6c6026438536ec"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTAxNDgyMQ==", "bodyText": "Thanks for updating this. And nice error message!", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r529014821", "createdAt": "2020-11-23T21:42:30Z", "author": {"login": "rdblue"}, "path": "api/src/main/java/org/apache/iceberg/expressions/ExpressionVisitors.java", "diffHunk": "@@ -75,6 +75,14 @@ public R or(R leftResult, R rightResult) {\n       return null;\n     }\n \n+    public <T> R isNaN(BoundReference<T> ref) {\n+      throw new UnsupportedOperationException(this.getClass().getName() + \" does not implement isNaN\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQzNjE2MQ=="}, "originalCommit": {"oid": "3fc48a0f465426d032cbe2fe0a6c6026438536ec"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMzk2NDYzOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/apache/iceberg/expressions/NaNUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QwMTozMDoxNFrOH39RMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QwMTozMDoxNFrOH39RMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQzNzU1NQ==", "bodyText": "nit: looks like iceberg util classes use XxxUtil instead of utils. And there is a org.apache.iceberg.util package path for utils in the api module.", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r528437555", "createdAt": "2020-11-23T01:30:14Z", "author": {"login": "jackye1995"}, "path": "api/src/main/java/org/apache/iceberg/expressions/NaNUtils.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fc48a0f465426d032cbe2fe0a6c6026438536ec"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxNDA5ODY0OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/apache/iceberg/expressions/StrictMetricsEvaluator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QwMzoyMzowNVrOH3-WeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QwMzoyMzowNVrOH3-WeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQ1NTI4OA==", "bodyText": "good catch", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r528455288", "createdAt": "2020-11-23T03:23:05Z", "author": {"login": "jackye1995"}, "path": "api/src/main/java/org/apache/iceberg/expressions/StrictMetricsEvaluator.java", "diffHunk": "@@ -118,7 +120,7 @@ public Boolean or(Boolean leftResult, Boolean rightResult) {\n     public <T> Boolean isNull(BoundReference<T> ref) {\n       // no need to check whether the field is required because binding evaluates that case\n       // if the column has any non-null values, the expression does not match\n-      Integer id = ref.fieldId();\n+      int id = ref.fieldId();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fc48a0f465426d032cbe2fe0a6c6026438536ec"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxNDA5OTY1OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/apache/iceberg/expressions/StrictMetricsEvaluator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QwMzoyMzo0NlrOH3-W9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QwMzoyMzo0NlrOH3-W9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQ1NTQxNQ==", "bodyText": "can refactor with containsNaNOnly as discussed above, and the checkstyle issue should not show up anymore.", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r528455415", "createdAt": "2020-11-23T03:23:46Z", "author": {"login": "jackye1995"}, "path": "api/src/main/java/org/apache/iceberg/expressions/StrictMetricsEvaluator.java", "diffHunk": "@@ -144,6 +146,35 @@ public Boolean or(Boolean leftResult, Boolean rightResult) {\n       return ROWS_MIGHT_NOT_MATCH;\n     }\n \n+    @Override\n+    @SuppressWarnings(\"checkstyle:CyclomaticComplexity\")\n+    public <T> Boolean isNaN(BoundReference<T> ref) {\n+      int id = ref.fieldId();\n+\n+      if (nanCounts != null && nanCounts.containsKey(id) &&", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fc48a0f465426d032cbe2fe0a6c6026438536ec"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxNzgxNDc3OnYy", "diffSide": "RIGHT", "path": "parquet/src/main/java/org/apache/iceberg/parquet/ParquetDictionaryRowGroupFilter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMTo1Mjo1NFrOH4g0rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMzozMDowNVrOH4jd0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTAyMDA3OA==", "bodyText": "You can also use Comparators.forType. The dictionary cannot contain null values so there is no need to wrap for null handling.", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r529020078", "createdAt": "2020-11-23T21:52:54Z", "author": {"login": "rdblue"}, "path": "parquet/src/main/java/org/apache/iceberg/parquet/ParquetDictionaryRowGroupFilter.java", "diffHunk": "@@ -148,6 +150,39 @@ public Boolean or(Boolean leftResult, Boolean rightResult) {\n       return ROWS_MIGHT_MATCH;\n     }\n \n+    @Override\n+    public <T> Boolean isNaN(BoundReference<T> ref) {\n+      int id = ref.fieldId();\n+\n+      Boolean hasNonDictPage = isFallback.get(id);\n+      if (hasNonDictPage == null || hasNonDictPage) {\n+        return ROWS_MIGHT_MATCH;\n+      }\n+\n+      Set<T> dictionary = dict(id, comparatorForNaNPredicate(ref));\n+      return dictionary.stream().anyMatch(NaNUtil::isNaN) ? ROWS_MIGHT_MATCH : ROWS_CANNOT_MATCH;\n+    }\n+\n+    @Override\n+    public <T> Boolean notNaN(BoundReference<T> ref) {\n+      int id = ref.fieldId();\n+\n+      Boolean hasNonDictPage = isFallback.get(id);\n+      if (hasNonDictPage == null || hasNonDictPage) {\n+        return ROWS_MIGHT_MATCH;\n+      }\n+\n+      Set<T> dictionary = dict(id, comparatorForNaNPredicate(ref));\n+      return dictionary.stream().allMatch(NaNUtil::isNaN) ? ROWS_CANNOT_MATCH : ROWS_MIGHT_MATCH;\n+    }\n+\n+    private <T> Comparator<T> comparatorForNaNPredicate(BoundReference<T> ref) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e853e50b369112ed337d46345d361b0c0697f6f1"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA2MzM3OA==", "bodyText": "Thanks for the info! I'll update this.", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r529063378", "createdAt": "2020-11-23T23:30:05Z", "author": {"login": "yyanyy"}, "path": "parquet/src/main/java/org/apache/iceberg/parquet/ParquetDictionaryRowGroupFilter.java", "diffHunk": "@@ -148,6 +150,39 @@ public Boolean or(Boolean leftResult, Boolean rightResult) {\n       return ROWS_MIGHT_MATCH;\n     }\n \n+    @Override\n+    public <T> Boolean isNaN(BoundReference<T> ref) {\n+      int id = ref.fieldId();\n+\n+      Boolean hasNonDictPage = isFallback.get(id);\n+      if (hasNonDictPage == null || hasNonDictPage) {\n+        return ROWS_MIGHT_MATCH;\n+      }\n+\n+      Set<T> dictionary = dict(id, comparatorForNaNPredicate(ref));\n+      return dictionary.stream().anyMatch(NaNUtil::isNaN) ? ROWS_MIGHT_MATCH : ROWS_CANNOT_MATCH;\n+    }\n+\n+    @Override\n+    public <T> Boolean notNaN(BoundReference<T> ref) {\n+      int id = ref.fieldId();\n+\n+      Boolean hasNonDictPage = isFallback.get(id);\n+      if (hasNonDictPage == null || hasNonDictPage) {\n+        return ROWS_MIGHT_MATCH;\n+      }\n+\n+      Set<T> dictionary = dict(id, comparatorForNaNPredicate(ref));\n+      return dictionary.stream().allMatch(NaNUtil::isNaN) ? ROWS_CANNOT_MATCH : ROWS_MIGHT_MATCH;\n+    }\n+\n+    private <T> Comparator<T> comparatorForNaNPredicate(BoundReference<T> ref) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTAyMDA3OA=="}, "originalCommit": {"oid": "e853e50b369112ed337d46345d361b0c0697f6f1"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2OTU4NzI3OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/apache/iceberg/expressions/Expressions.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNlQwMToxMDozNFrOIADZ6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQyMjo0NjoxNVrOIB5tfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjkyNjY5Nw==", "bodyText": "An easier way to do this is to add the check in Literal.from. That's where Iceberg enforces that the value cannot be null. Since a literal is created for every value that is passed in, we would only need to change that one place instead of all of the factory methods here.\nIt also ensures that we don't add factory methods later and forget to add the check to them.", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r536926697", "createdAt": "2020-12-06T01:10:34Z", "author": {"login": "rdblue"}, "path": "api/src/main/java/org/apache/iceberg/expressions/Expressions.java", "diffHunk": "@@ -123,51 +124,79 @@ public static Expression not(Expression child) {\n     return new UnboundPredicate<>(Expression.Operation.NOT_NULL, expr);\n   }\n \n+  public static <T> UnboundPredicate<T> isNaN(String name) {\n+    return new UnboundPredicate<>(Expression.Operation.IS_NAN, ref(name));\n+  }\n+\n+  public static <T> UnboundPredicate<T> isNaN(UnboundTerm<T> expr) {\n+    return new UnboundPredicate<>(Expression.Operation.IS_NAN, expr);\n+  }\n+\n+  public static <T> UnboundPredicate<T> notNaN(String name) {\n+    return new UnboundPredicate<>(Expression.Operation.NOT_NAN, ref(name));\n+  }\n+\n+  public static <T> UnboundPredicate<T> notNaN(UnboundTerm<T> expr) {\n+    return new UnboundPredicate<>(Expression.Operation.NOT_NAN, expr);\n+  }\n+\n   public static <T> UnboundPredicate<T> lessThan(String name, T value) {\n+    validateInput(\"lessThan\", value);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5e666399663685d5fc583a692c57c090de74de3"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg2NTAyMg==", "bodyText": "Thank you! I didn't notice Literals.from was called within constructor of UnboundPredicate when normal object is passed in. This is definitely much more cleaner! I have created #1892 to address this.\nThank you so much for your time reviewing this long PR!", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r538865022", "createdAt": "2020-12-08T22:46:15Z", "author": {"login": "yyanyy"}, "path": "api/src/main/java/org/apache/iceberg/expressions/Expressions.java", "diffHunk": "@@ -123,51 +124,79 @@ public static Expression not(Expression child) {\n     return new UnboundPredicate<>(Expression.Operation.NOT_NULL, expr);\n   }\n \n+  public static <T> UnboundPredicate<T> isNaN(String name) {\n+    return new UnboundPredicate<>(Expression.Operation.IS_NAN, ref(name));\n+  }\n+\n+  public static <T> UnboundPredicate<T> isNaN(UnboundTerm<T> expr) {\n+    return new UnboundPredicate<>(Expression.Operation.IS_NAN, expr);\n+  }\n+\n+  public static <T> UnboundPredicate<T> notNaN(String name) {\n+    return new UnboundPredicate<>(Expression.Operation.NOT_NAN, ref(name));\n+  }\n+\n+  public static <T> UnboundPredicate<T> notNaN(UnboundTerm<T> expr) {\n+    return new UnboundPredicate<>(Expression.Operation.NOT_NAN, expr);\n+  }\n+\n   public static <T> UnboundPredicate<T> lessThan(String name, T value) {\n+    validateInput(\"lessThan\", value);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjkyNjY5Nw=="}, "originalCommit": {"oid": "d5e666399663685d5fc583a692c57c090de74de3"}, "originalPosition": 29}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3427, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}