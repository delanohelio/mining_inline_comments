{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAxNTk5Mzg5", "number": 907, "title": "Add v2 manifest lists", "bodyText": "This extends #903 with a v2 manifest list. The v2 schema is not final and may change. This is mainly to implement a separate write path and a framework for compatibility tests.\nSpecific changes:\n\nSplit ManifestFile schema into v1 and v2 (with sequence numbers)\nUpdate GenericManifestFile to v2 schema\nUpdate v1 manifest list writer to use the v1 schema\nAdd a v2 manifest list writer\nAdd tests for v1 and v2 manifest list formats", "createdAt": "2020-04-09T19:18:08Z", "url": "https://github.com/apache/iceberg/pull/907", "merged": true, "mergeCommit": {"oid": "487fc1c71c36fba9d589ebff6fefdee6c19d0f24"}, "closed": true, "closedAt": "2020-04-14T23:40:49Z", "author": {"login": "rdblue"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcWDYjagFqTM5MTE0NDkzOQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcXr5gMAFqTM5MzM1NzUxNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxMTQ0OTM5", "url": "https://github.com/apache/iceberg/pull/907#pullrequestreview-391144939", "createdAt": "2020-04-09T21:28:57Z", "commit": {"oid": "456f2caca7da973c5147642b7534b0e8956b9720"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMToyODo1N1rOGDqD4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMToyODo1N1rOGDqD4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ4ODAzNQ==", "bodyText": "Moved into TestManifestFileVersions.", "url": "https://github.com/apache/iceberg/pull/907#discussion_r406488035", "createdAt": "2020-04-09T21:28:57Z", "author": {"login": "rdblue"}, "path": "core/src/test/java/org/apache/iceberg/TestGenericManifestFile.java", "diffHunk": "@@ -1,91 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package org.apache.iceberg;\n-\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.Iterables;\n-import java.io.File;\n-import java.io.IOException;\n-import java.util.Collection;\n-import org.apache.iceberg.avro.Avro;\n-import org.apache.iceberg.io.CloseableIterable;\n-import org.apache.iceberg.io.FileAppender;\n-import org.apache.iceberg.io.FileIO;\n-import org.apache.iceberg.io.InputFile;\n-import org.apache.iceberg.io.OutputFile;\n-import org.junit.Assert;\n-import org.junit.Rule;\n-import org.junit.Test;\n-import org.junit.rules.TemporaryFolder;\n-\n-public class TestGenericManifestFile {\n-\n-  private static final FileIO FILE_IO = new TestTables.LocalFileIO();\n-\n-  @Rule\n-  public TemporaryFolder temp = new TemporaryFolder();\n-\n-  @Test\n-  public void testManifestsWithoutRowStats() throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "456f2caca7da973c5147642b7534b0e8956b9720"}, "originalPosition": 46}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxNjkzMjA0", "url": "https://github.com/apache/iceberg/pull/907#pullrequestreview-391693204", "createdAt": "2020-04-10T22:35:55Z", "commit": {"oid": "456f2caca7da973c5147642b7534b0e8956b9720"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQyMjozNTo1NVrOGEHgXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQyMjozNTo1NVrOGEHgXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk3MDQ2MA==", "bodyText": "I'm going to move the schemas to a different file to avoid leaking them in the API, but I'll leave the schema method that returns the current unified read schema.", "url": "https://github.com/apache/iceberg/pull/907#discussion_r406970460", "createdAt": "2020-04-10T22:35:55Z", "author": {"login": "rdblue"}, "path": "api/src/main/java/org/apache/iceberg/ManifestFile.java", "diffHunk": "@@ -30,25 +30,62 @@\n  * Represents a manifest file that can be scanned to find data files in a table.\n  */\n public interface ManifestFile {\n-  Schema SCHEMA = new Schema(\n-      required(500, \"manifest_path\", Types.StringType.get()),\n-      required(501, \"manifest_length\", Types.LongType.get()),\n-      required(502, \"partition_spec_id\", Types.IntegerType.get()),\n-      optional(503, \"added_snapshot_id\", Types.LongType.get()),\n-      optional(504, \"added_data_files_count\", Types.IntegerType.get()),\n-      optional(505, \"existing_data_files_count\", Types.IntegerType.get()),\n-      optional(506, \"deleted_data_files_count\", Types.IntegerType.get()),\n-      optional(507, \"partitions\", Types.ListType.ofRequired(508, Types.StructType.of(\n-          required(509, \"contains_null\", Types.BooleanType.get()),\n-          optional(510, \"lower_bound\", Types.BinaryType.get()), // null if no non-null values\n-          optional(511, \"upper_bound\", Types.BinaryType.get())\n-      ))),\n-      optional(512, \"added_rows_count\", Types.LongType.get()),\n-      optional(513, \"existing_rows_count\", Types.LongType.get()),\n-      optional(514, \"deleted_rows_count\", Types.LongType.get()));\n+  Types.NestedField PATH = required(500, \"manifest_path\", Types.StringType.get());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "456f2caca7da973c5147642b7534b0e8956b9720"}, "originalPosition": 20}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "456f2caca7da973c5147642b7534b0e8956b9720", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/456f2caca7da973c5147642b7534b0e8956b9720", "committedDate": "2020-04-09T21:24:37Z", "message": "Fix checkstyle problems."}, "afterCommit": {"oid": "220c6a5d6dd51dba021768ad9dd908e99cf901ef", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/220c6a5d6dd51dba021768ad9dd908e99cf901ef", "committedDate": "2020-04-10T23:29:16Z", "message": "Add v2 manifest lists.\n\n* Update GenericManifestFile to v2 schema\n* Update v1 manifest list writer to use the v1 schema\n* Add a v2 manifest list writer\n* Add tests for v1 and v2 manifest list formats"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3b2fbd0932f37cf32e250f39c9e783c8ee27e455", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/3b2fbd0932f37cf32e250f39c9e783c8ee27e455", "committedDate": "2020-04-11T20:37:57Z", "message": "Add v2 manifest lists.\n\n* Update GenericManifestFile to v2 schema\n* Update v1 manifest list writer to use the v1 schema\n* Add a v2 manifest list writer\n* Add tests for v1 and v2 manifest list formats"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ba51ddace40fb313e7bba9930c0ab5206b402835", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/ba51ddace40fb313e7bba9930c0ab5206b402835", "committedDate": "2020-04-11T20:37:57Z", "message": "Write ManifestFile sequence number in v2 writer."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f5644567a13f94ce7a8e2eb820281080eff603c6", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/f5644567a13f94ce7a8e2eb820281080eff603c6", "committedDate": "2020-04-11T20:37:57Z", "message": "Make static metadata variables final."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "00cb37dae86e1b802c10430ee5e0086818d6c713", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/00cb37dae86e1b802c10430ee5e0086818d6c713", "committedDate": "2020-04-11T16:18:58Z", "message": "Make static metadata variables final."}, "afterCommit": {"oid": "f5644567a13f94ce7a8e2eb820281080eff603c6", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/f5644567a13f94ce7a8e2eb820281080eff603c6", "committedDate": "2020-04-11T20:37:57Z", "message": "Make static metadata variables final."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzMjgxMjAz", "url": "https://github.com/apache/iceberg/pull/907#pullrequestreview-393281203", "createdAt": "2020-04-14T20:44:13Z", "commit": {"oid": "f5644567a13f94ce7a8e2eb820281080eff603c6"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMDo0NDoxM1rOGFgMiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMjoyMTo1MVrOGFjEFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyMzU2MA==", "bodyText": "I remember we had issues with reordering fields in ManifestFile as GenericAvroWriter was using ordinal positions instead of field ids. Did we solve that?", "url": "https://github.com/apache/iceberg/pull/907#discussion_r408423560", "createdAt": "2020-04-14T20:44:13Z", "author": {"login": "aokolnychyi"}, "path": "api/src/main/java/org/apache/iceberg/ManifestFile.java", "diffHunk": "@@ -30,22 +30,33 @@\n  * Represents a manifest file that can be scanned to find data files in a table.\n  */\n public interface ManifestFile {\n+  Types.NestedField PATH = required(500, \"manifest_path\", Types.StringType.get());\n+  Types.NestedField LENGTH = required(501, \"manifest_length\", Types.LongType.get());\n+  Types.NestedField SPEC_ID = required(502, \"partition_spec_id\", Types.IntegerType.get());\n+  Types.NestedField SNAPSHOT_ID = optional(503, \"added_snapshot_id\", Types.LongType.get());\n+  Types.NestedField ADDED_FILES_COUNT = optional(504, \"added_data_files_count\", Types.IntegerType.get());\n+  Types.NestedField EXISTING_FILES_COUNT = optional(505, \"existing_data_files_count\", Types.IntegerType.get());\n+  Types.NestedField DELETED_FILES_COUNT = optional(506, \"deleted_data_files_count\", Types.IntegerType.get());\n+  Types.StructType PARTITION_SUMMARY_TYPE = Types.StructType.of(\n+      required(509, \"contains_null\", Types.BooleanType.get()),\n+      optional(510, \"lower_bound\", Types.BinaryType.get()), // null if no non-null values\n+      optional(511, \"upper_bound\", Types.BinaryType.get())\n+  );\n+  Types.NestedField PARTITION_SUMMARIES = optional(507, \"partitions\",\n+      Types.ListType.ofRequired(508, PARTITION_SUMMARY_TYPE));\n+  Types.NestedField ADDED_ROWS_COUNT = optional(512, \"added_rows_count\", Types.LongType.get());\n+  Types.NestedField EXISTING_ROWS_COUNT = optional(513, \"existing_rows_count\", Types.LongType.get());\n+  Types.NestedField DELETED_ROWS_COUNT = optional(514, \"deleted_rows_count\", Types.LongType.get());\n+  Types.NestedField SEQUENCE_NUMBER = optional(515, \"sequence_number\", Types.LongType.get());\n+  Types.NestedField MIN_SEQUENCE_NUMBER = optional(516, \"min_sequence_number\", Types.LongType.get());\n+  // next ID to assign: 517\n+\n   Schema SCHEMA = new Schema(\n-      required(500, \"manifest_path\", Types.StringType.get()),\n-      required(501, \"manifest_length\", Types.LongType.get()),\n-      required(502, \"partition_spec_id\", Types.IntegerType.get()),\n-      optional(503, \"added_snapshot_id\", Types.LongType.get()),\n-      optional(504, \"added_data_files_count\", Types.IntegerType.get()),\n-      optional(505, \"existing_data_files_count\", Types.IntegerType.get()),\n-      optional(506, \"deleted_data_files_count\", Types.IntegerType.get()),\n-      optional(507, \"partitions\", Types.ListType.ofRequired(508, Types.StructType.of(\n-          required(509, \"contains_null\", Types.BooleanType.get()),\n-          optional(510, \"lower_bound\", Types.BinaryType.get()), // null if no non-null values\n-          optional(511, \"upper_bound\", Types.BinaryType.get())\n-      ))),\n-      optional(512, \"added_rows_count\", Types.LongType.get()),\n-      optional(513, \"existing_rows_count\", Types.LongType.get()),\n-      optional(514, \"deleted_rows_count\", Types.LongType.get()));\n+      PATH, LENGTH, SPEC_ID,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5644567a13f94ce7a8e2eb820281080eff603c6"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyOTA5Nw==", "bodyText": "Even though it was public, I don't think anyone is using it. Seems OK to change.", "url": "https://github.com/apache/iceberg/pull/907#discussion_r408429097", "createdAt": "2020-04-14T20:54:34Z", "author": {"login": "aokolnychyi"}, "path": "core/src/main/java/org/apache/iceberg/GenericManifestFile.java", "diffHunk": "@@ -100,32 +101,17 @@ public GenericManifestFile(org.apache.avro.Schema avroSchema) {\n     this.fromProjectionPos = null;\n   }\n \n-  public GenericManifestFile(String path, long length, int specId, Long snapshotId,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5644567a13f94ce7a8e2eb820281080eff603c6"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQzMTIyMQ==", "bodyText": "Is this empty line intentional?", "url": "https://github.com/apache/iceberg/pull/907#discussion_r408431221", "createdAt": "2020-04-14T20:58:44Z", "author": {"login": "aokolnychyi"}, "path": "core/src/main/java/org/apache/iceberg/ManifestListWriter.java", "diffHunk": "@@ -84,23 +69,67 @@ public long length() {\n     return writer.length();\n   }\n \n-  private static FileAppender<ManifestFile> newAppender(OutputFile file, Map<String, String> meta) {\n-    try {\n-      return Avro.write(file)\n-          .schema(ManifestFile.schema())\n-          .named(\"manifest_file\")\n-          .meta(meta)\n-          .overwrite()\n-          .build();\n-\n-    } catch (IOException e) {\n-      throw new RuntimeIOException(e, \"Failed to create snapshot list writer for path: \" + file);\n+  static class V2Writer extends ManifestListWriter {\n+    private final V2Metadata.IndexedManifestFile wrapper;\n+\n+    V2Writer(OutputFile snapshotFile, long snapshotId, Long parentSnapshotId, long sequenceNumber) {\n+      super(snapshotFile, ImmutableMap.of(\n+          \"snapshot-id\", String.valueOf(snapshotId),\n+          \"parent-snapshot-id\", String.valueOf(parentSnapshotId),\n+          \"sequence-number\", String.valueOf(sequenceNumber),\n+          \"format-version\", \"2\"));\n+      this.wrapper = new V2Metadata.IndexedManifestFile(sequenceNumber);\n+    }\n+\n+    @Override\n+    protected ManifestFile prepare(ManifestFile manifest) {\n+      return wrapper.wrap(manifest);\n+    }\n+\n+    @Override\n+    protected FileAppender<ManifestFile> newAppender(OutputFile file, Map<String, String> meta) {\n+      try {\n+        return Avro.write(file)\n+            .schema(V2Metadata.MANIFEST_LIST_SCHEMA)\n+            .named(\"manifest_file\")\n+            .meta(meta)\n+            .overwrite()\n+            .build();\n+\n+      } catch (IOException e) {\n+        throw new RuntimeIOException(e, \"Failed to create snapshot list writer for path: \" + file);\n+      }\n     }\n   }\n \n   static class V1Writer extends ManifestListWriter {\n-    private V1Writer(OutputFile snapshotFile, long snapshotId, Long parentSnapshotId) {\n-      super(snapshotFile, snapshotId, parentSnapshotId);\n+    private final V1Metadata.IndexedManifestFile wrapper = new V1Metadata.IndexedManifestFile();\n+\n+    V1Writer(OutputFile snapshotFile, long snapshotId, Long parentSnapshotId) {\n+      super(snapshotFile, ImmutableMap.of(\n+          \"snapshot-id\", String.valueOf(snapshotId),\n+          \"parent-snapshot-id\", String.valueOf(parentSnapshotId),\n+          \"format-version\", \"1\"));\n+    }\n+\n+    @Override\n+    protected ManifestFile prepare(ManifestFile manifest) {\n+      return wrapper.wrap(manifest);\n+    }\n+\n+    protected FileAppender<ManifestFile> newAppender(OutputFile file, Map<String, String> meta) {\n+      try {\n+        return Avro.write(file)\n+            .schema(V1Metadata.MANIFEST_LIST_SCHEMA)\n+            .named(\"manifest_file\")\n+            .meta(meta)\n+            .overwrite()\n+            .build();\n+\n+      } catch (IOException e) {\n+        throw new RuntimeIOException(e, \"Failed to create snapshot list writer for path: \" + file);\n+      }\n     }\n   }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5644567a13f94ce7a8e2eb820281080eff603c6"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ0ODUxNA==", "bodyText": "Looks like we are trying to match the new ordering of fields in ManifestFile. Earlier, we co-located ...FilesCount with ...RowsCount to match the ordering of methods in ManifestFile and args in constructors. Is this change intentional?", "url": "https://github.com/apache/iceberg/pull/907#discussion_r408448514", "createdAt": "2020-04-14T21:31:56Z", "author": {"login": "aokolnychyi"}, "path": "core/src/main/java/org/apache/iceberg/GenericManifestFile.java", "diffHunk": "@@ -46,12 +46,14 @@\n   private String manifestPath = null;\n   private Long length = null;\n   private int specId = -1;\n+  private long sequenceNumber = 0;\n+  private long minSequenceNumber = 0;\n   private Long snapshotId = null;\n   private Integer addedFilesCount = null;\n-  private Long addedRowsCount = null;\n   private Integer existingFilesCount = null;\n-  private Long existingRowsCount = null;\n   private Integer deletedFilesCount = null;\n+  private Long addedRowsCount = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5644567a13f94ce7a8e2eb820281080eff603c6"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ1NjEyMQ==", "bodyText": "I see this is handled in V1Metadata.", "url": "https://github.com/apache/iceberg/pull/907#discussion_r408456121", "createdAt": "2020-04-14T21:47:50Z", "author": {"login": "aokolnychyi"}, "path": "api/src/main/java/org/apache/iceberg/ManifestFile.java", "diffHunk": "@@ -30,22 +30,33 @@\n  * Represents a manifest file that can be scanned to find data files in a table.\n  */\n public interface ManifestFile {\n+  Types.NestedField PATH = required(500, \"manifest_path\", Types.StringType.get());\n+  Types.NestedField LENGTH = required(501, \"manifest_length\", Types.LongType.get());\n+  Types.NestedField SPEC_ID = required(502, \"partition_spec_id\", Types.IntegerType.get());\n+  Types.NestedField SNAPSHOT_ID = optional(503, \"added_snapshot_id\", Types.LongType.get());\n+  Types.NestedField ADDED_FILES_COUNT = optional(504, \"added_data_files_count\", Types.IntegerType.get());\n+  Types.NestedField EXISTING_FILES_COUNT = optional(505, \"existing_data_files_count\", Types.IntegerType.get());\n+  Types.NestedField DELETED_FILES_COUNT = optional(506, \"deleted_data_files_count\", Types.IntegerType.get());\n+  Types.StructType PARTITION_SUMMARY_TYPE = Types.StructType.of(\n+      required(509, \"contains_null\", Types.BooleanType.get()),\n+      optional(510, \"lower_bound\", Types.BinaryType.get()), // null if no non-null values\n+      optional(511, \"upper_bound\", Types.BinaryType.get())\n+  );\n+  Types.NestedField PARTITION_SUMMARIES = optional(507, \"partitions\",\n+      Types.ListType.ofRequired(508, PARTITION_SUMMARY_TYPE));\n+  Types.NestedField ADDED_ROWS_COUNT = optional(512, \"added_rows_count\", Types.LongType.get());\n+  Types.NestedField EXISTING_ROWS_COUNT = optional(513, \"existing_rows_count\", Types.LongType.get());\n+  Types.NestedField DELETED_ROWS_COUNT = optional(514, \"deleted_rows_count\", Types.LongType.get());\n+  Types.NestedField SEQUENCE_NUMBER = optional(515, \"sequence_number\", Types.LongType.get());\n+  Types.NestedField MIN_SEQUENCE_NUMBER = optional(516, \"min_sequence_number\", Types.LongType.get());\n+  // next ID to assign: 517\n+\n   Schema SCHEMA = new Schema(\n-      required(500, \"manifest_path\", Types.StringType.get()),\n-      required(501, \"manifest_length\", Types.LongType.get()),\n-      required(502, \"partition_spec_id\", Types.IntegerType.get()),\n-      optional(503, \"added_snapshot_id\", Types.LongType.get()),\n-      optional(504, \"added_data_files_count\", Types.IntegerType.get()),\n-      optional(505, \"existing_data_files_count\", Types.IntegerType.get()),\n-      optional(506, \"deleted_data_files_count\", Types.IntegerType.get()),\n-      optional(507, \"partitions\", Types.ListType.ofRequired(508, Types.StructType.of(\n-          required(509, \"contains_null\", Types.BooleanType.get()),\n-          optional(510, \"lower_bound\", Types.BinaryType.get()), // null if no non-null values\n-          optional(511, \"upper_bound\", Types.BinaryType.get())\n-      ))),\n-      optional(512, \"added_rows_count\", Types.LongType.get()),\n-      optional(513, \"existing_rows_count\", Types.LongType.get()),\n-      optional(514, \"deleted_rows_count\", Types.LongType.get()));\n+      PATH, LENGTH, SPEC_ID,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyMzU2MA=="}, "originalCommit": {"oid": "f5644567a13f94ce7a8e2eb820281080eff603c6"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3MDU0OA==", "bodyText": "Seems like this is the place where we can pass a snapshot id similar to how we pass a sequence number to V2 and get rid of the logic for inheriting metadata for ManifestEntry via setSnapshotId and iterating through manifests during commit.\nDo I get it correctly, @rdblue?", "url": "https://github.com/apache/iceberg/pull/907#discussion_r408470548", "createdAt": "2020-04-14T22:21:51Z", "author": {"login": "aokolnychyi"}, "path": "core/src/main/java/org/apache/iceberg/ManifestListWriter.java", "diffHunk": "@@ -84,23 +69,67 @@ public long length() {\n     return writer.length();\n   }\n \n-  private static FileAppender<ManifestFile> newAppender(OutputFile file, Map<String, String> meta) {\n-    try {\n-      return Avro.write(file)\n-          .schema(ManifestFile.schema())\n-          .named(\"manifest_file\")\n-          .meta(meta)\n-          .overwrite()\n-          .build();\n-\n-    } catch (IOException e) {\n-      throw new RuntimeIOException(e, \"Failed to create snapshot list writer for path: \" + file);\n+  static class V2Writer extends ManifestListWriter {\n+    private final V2Metadata.IndexedManifestFile wrapper;\n+\n+    V2Writer(OutputFile snapshotFile, long snapshotId, Long parentSnapshotId, long sequenceNumber) {\n+      super(snapshotFile, ImmutableMap.of(\n+          \"snapshot-id\", String.valueOf(snapshotId),\n+          \"parent-snapshot-id\", String.valueOf(parentSnapshotId),\n+          \"sequence-number\", String.valueOf(sequenceNumber),\n+          \"format-version\", \"2\"));\n+      this.wrapper = new V2Metadata.IndexedManifestFile(sequenceNumber);\n+    }\n+\n+    @Override\n+    protected ManifestFile prepare(ManifestFile manifest) {\n+      return wrapper.wrap(manifest);\n+    }\n+\n+    @Override\n+    protected FileAppender<ManifestFile> newAppender(OutputFile file, Map<String, String> meta) {\n+      try {\n+        return Avro.write(file)\n+            .schema(V2Metadata.MANIFEST_LIST_SCHEMA)\n+            .named(\"manifest_file\")\n+            .meta(meta)\n+            .overwrite()\n+            .build();\n+\n+      } catch (IOException e) {\n+        throw new RuntimeIOException(e, \"Failed to create snapshot list writer for path: \" + file);\n+      }\n     }\n   }\n \n   static class V1Writer extends ManifestListWriter {\n-    private V1Writer(OutputFile snapshotFile, long snapshotId, Long parentSnapshotId) {\n-      super(snapshotFile, snapshotId, parentSnapshotId);\n+    private final V1Metadata.IndexedManifestFile wrapper = new V1Metadata.IndexedManifestFile();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5644567a13f94ce7a8e2eb820281080eff603c6"}, "originalPosition": 112}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8b1e3161c03dce69a3f251255742cd097a237c66", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/8b1e3161c03dce69a3f251255742cd097a237c66", "committedDate": "2020-04-14T22:35:51Z", "message": "Remove trailing newlines."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzMzU3NTE0", "url": "https://github.com/apache/iceberg/pull/907#pullrequestreview-393357514", "createdAt": "2020-04-14T23:15:04Z", "commit": {"oid": "8b1e3161c03dce69a3f251255742cd097a237c66"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4775, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}