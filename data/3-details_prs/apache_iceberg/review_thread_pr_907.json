{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAxNTk5Mzg5", "number": 907, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMToyODo1N1rODwkqfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMjoyMTo1MVrODx2BLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMjU4OTQzOnYy", "diffSide": "LEFT", "path": "core/src/test/java/org/apache/iceberg/TestGenericManifestFile.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMToyODo1N1rOGDqD4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMToyODo1N1rOGDqD4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ4ODAzNQ==", "bodyText": "Moved into TestManifestFileVersions.", "url": "https://github.com/apache/iceberg/pull/907#discussion_r406488035", "createdAt": "2020-04-09T21:28:57Z", "author": {"login": "rdblue"}, "path": "core/src/test/java/org/apache/iceberg/TestGenericManifestFile.java", "diffHunk": "@@ -1,91 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package org.apache.iceberg;\n-\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.Iterables;\n-import java.io.File;\n-import java.io.IOException;\n-import java.util.Collection;\n-import org.apache.iceberg.avro.Avro;\n-import org.apache.iceberg.io.CloseableIterable;\n-import org.apache.iceberg.io.FileAppender;\n-import org.apache.iceberg.io.FileIO;\n-import org.apache.iceberg.io.InputFile;\n-import org.apache.iceberg.io.OutputFile;\n-import org.junit.Assert;\n-import org.junit.Rule;\n-import org.junit.Test;\n-import org.junit.rules.TemporaryFolder;\n-\n-public class TestGenericManifestFile {\n-\n-  private static final FileIO FILE_IO = new TestTables.LocalFileIO();\n-\n-  @Rule\n-  public TemporaryFolder temp = new TemporaryFolder();\n-\n-  @Test\n-  public void testManifestsWithoutRowStats() throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "456f2caca7da973c5147642b7534b0e8956b9720"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyNTc4NDkzOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/apache/iceberg/ManifestFile.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQyMjozNTo1NVrOGEHgXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQyMjozNTo1NVrOGEHgXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk3MDQ2MA==", "bodyText": "I'm going to move the schemas to a different file to avoid leaking them in the API, but I'll leave the schema method that returns the current unified read schema.", "url": "https://github.com/apache/iceberg/pull/907#discussion_r406970460", "createdAt": "2020-04-10T22:35:55Z", "author": {"login": "rdblue"}, "path": "api/src/main/java/org/apache/iceberg/ManifestFile.java", "diffHunk": "@@ -30,25 +30,62 @@\n  * Represents a manifest file that can be scanned to find data files in a table.\n  */\n public interface ManifestFile {\n-  Schema SCHEMA = new Schema(\n-      required(500, \"manifest_path\", Types.StringType.get()),\n-      required(501, \"manifest_length\", Types.LongType.get()),\n-      required(502, \"partition_spec_id\", Types.IntegerType.get()),\n-      optional(503, \"added_snapshot_id\", Types.LongType.get()),\n-      optional(504, \"added_data_files_count\", Types.IntegerType.get()),\n-      optional(505, \"existing_data_files_count\", Types.IntegerType.get()),\n-      optional(506, \"deleted_data_files_count\", Types.IntegerType.get()),\n-      optional(507, \"partitions\", Types.ListType.ofRequired(508, Types.StructType.of(\n-          required(509, \"contains_null\", Types.BooleanType.get()),\n-          optional(510, \"lower_bound\", Types.BinaryType.get()), // null if no non-null values\n-          optional(511, \"upper_bound\", Types.BinaryType.get())\n-      ))),\n-      optional(512, \"added_rows_count\", Types.LongType.get()),\n-      optional(513, \"existing_rows_count\", Types.LongType.get()),\n-      optional(514, \"deleted_rows_count\", Types.LongType.get()));\n+  Types.NestedField PATH = required(500, \"manifest_path\", Types.StringType.get());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "456f2caca7da973c5147642b7534b0e8956b9720"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNTYxODM4OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/apache/iceberg/ManifestFile.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMDo0NDoxM1rOGFgMiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMjoyOTo0MFrOGFjQGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyMzU2MA==", "bodyText": "I remember we had issues with reordering fields in ManifestFile as GenericAvroWriter was using ordinal positions instead of field ids. Did we solve that?", "url": "https://github.com/apache/iceberg/pull/907#discussion_r408423560", "createdAt": "2020-04-14T20:44:13Z", "author": {"login": "aokolnychyi"}, "path": "api/src/main/java/org/apache/iceberg/ManifestFile.java", "diffHunk": "@@ -30,22 +30,33 @@\n  * Represents a manifest file that can be scanned to find data files in a table.\n  */\n public interface ManifestFile {\n+  Types.NestedField PATH = required(500, \"manifest_path\", Types.StringType.get());\n+  Types.NestedField LENGTH = required(501, \"manifest_length\", Types.LongType.get());\n+  Types.NestedField SPEC_ID = required(502, \"partition_spec_id\", Types.IntegerType.get());\n+  Types.NestedField SNAPSHOT_ID = optional(503, \"added_snapshot_id\", Types.LongType.get());\n+  Types.NestedField ADDED_FILES_COUNT = optional(504, \"added_data_files_count\", Types.IntegerType.get());\n+  Types.NestedField EXISTING_FILES_COUNT = optional(505, \"existing_data_files_count\", Types.IntegerType.get());\n+  Types.NestedField DELETED_FILES_COUNT = optional(506, \"deleted_data_files_count\", Types.IntegerType.get());\n+  Types.StructType PARTITION_SUMMARY_TYPE = Types.StructType.of(\n+      required(509, \"contains_null\", Types.BooleanType.get()),\n+      optional(510, \"lower_bound\", Types.BinaryType.get()), // null if no non-null values\n+      optional(511, \"upper_bound\", Types.BinaryType.get())\n+  );\n+  Types.NestedField PARTITION_SUMMARIES = optional(507, \"partitions\",\n+      Types.ListType.ofRequired(508, PARTITION_SUMMARY_TYPE));\n+  Types.NestedField ADDED_ROWS_COUNT = optional(512, \"added_rows_count\", Types.LongType.get());\n+  Types.NestedField EXISTING_ROWS_COUNT = optional(513, \"existing_rows_count\", Types.LongType.get());\n+  Types.NestedField DELETED_ROWS_COUNT = optional(514, \"deleted_rows_count\", Types.LongType.get());\n+  Types.NestedField SEQUENCE_NUMBER = optional(515, \"sequence_number\", Types.LongType.get());\n+  Types.NestedField MIN_SEQUENCE_NUMBER = optional(516, \"min_sequence_number\", Types.LongType.get());\n+  // next ID to assign: 517\n+\n   Schema SCHEMA = new Schema(\n-      required(500, \"manifest_path\", Types.StringType.get()),\n-      required(501, \"manifest_length\", Types.LongType.get()),\n-      required(502, \"partition_spec_id\", Types.IntegerType.get()),\n-      optional(503, \"added_snapshot_id\", Types.LongType.get()),\n-      optional(504, \"added_data_files_count\", Types.IntegerType.get()),\n-      optional(505, \"existing_data_files_count\", Types.IntegerType.get()),\n-      optional(506, \"deleted_data_files_count\", Types.IntegerType.get()),\n-      optional(507, \"partitions\", Types.ListType.ofRequired(508, Types.StructType.of(\n-          required(509, \"contains_null\", Types.BooleanType.get()),\n-          optional(510, \"lower_bound\", Types.BinaryType.get()), // null if no non-null values\n-          optional(511, \"upper_bound\", Types.BinaryType.get())\n-      ))),\n-      optional(512, \"added_rows_count\", Types.LongType.get()),\n-      optional(513, \"existing_rows_count\", Types.LongType.get()),\n-      optional(514, \"deleted_rows_count\", Types.LongType.get()));\n+      PATH, LENGTH, SPEC_ID,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5644567a13f94ce7a8e2eb820281080eff603c6"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ1NjEyMQ==", "bodyText": "I see this is handled in V1Metadata.", "url": "https://github.com/apache/iceberg/pull/907#discussion_r408456121", "createdAt": "2020-04-14T21:47:50Z", "author": {"login": "aokolnychyi"}, "path": "api/src/main/java/org/apache/iceberg/ManifestFile.java", "diffHunk": "@@ -30,22 +30,33 @@\n  * Represents a manifest file that can be scanned to find data files in a table.\n  */\n public interface ManifestFile {\n+  Types.NestedField PATH = required(500, \"manifest_path\", Types.StringType.get());\n+  Types.NestedField LENGTH = required(501, \"manifest_length\", Types.LongType.get());\n+  Types.NestedField SPEC_ID = required(502, \"partition_spec_id\", Types.IntegerType.get());\n+  Types.NestedField SNAPSHOT_ID = optional(503, \"added_snapshot_id\", Types.LongType.get());\n+  Types.NestedField ADDED_FILES_COUNT = optional(504, \"added_data_files_count\", Types.IntegerType.get());\n+  Types.NestedField EXISTING_FILES_COUNT = optional(505, \"existing_data_files_count\", Types.IntegerType.get());\n+  Types.NestedField DELETED_FILES_COUNT = optional(506, \"deleted_data_files_count\", Types.IntegerType.get());\n+  Types.StructType PARTITION_SUMMARY_TYPE = Types.StructType.of(\n+      required(509, \"contains_null\", Types.BooleanType.get()),\n+      optional(510, \"lower_bound\", Types.BinaryType.get()), // null if no non-null values\n+      optional(511, \"upper_bound\", Types.BinaryType.get())\n+  );\n+  Types.NestedField PARTITION_SUMMARIES = optional(507, \"partitions\",\n+      Types.ListType.ofRequired(508, PARTITION_SUMMARY_TYPE));\n+  Types.NestedField ADDED_ROWS_COUNT = optional(512, \"added_rows_count\", Types.LongType.get());\n+  Types.NestedField EXISTING_ROWS_COUNT = optional(513, \"existing_rows_count\", Types.LongType.get());\n+  Types.NestedField DELETED_ROWS_COUNT = optional(514, \"deleted_rows_count\", Types.LongType.get());\n+  Types.NestedField SEQUENCE_NUMBER = optional(515, \"sequence_number\", Types.LongType.get());\n+  Types.NestedField MIN_SEQUENCE_NUMBER = optional(516, \"min_sequence_number\", Types.LongType.get());\n+  // next ID to assign: 517\n+\n   Schema SCHEMA = new Schema(\n-      required(500, \"manifest_path\", Types.StringType.get()),\n-      required(501, \"manifest_length\", Types.LongType.get()),\n-      required(502, \"partition_spec_id\", Types.IntegerType.get()),\n-      optional(503, \"added_snapshot_id\", Types.LongType.get()),\n-      optional(504, \"added_data_files_count\", Types.IntegerType.get()),\n-      optional(505, \"existing_data_files_count\", Types.IntegerType.get()),\n-      optional(506, \"deleted_data_files_count\", Types.IntegerType.get()),\n-      optional(507, \"partitions\", Types.ListType.ofRequired(508, Types.StructType.of(\n-          required(509, \"contains_null\", Types.BooleanType.get()),\n-          optional(510, \"lower_bound\", Types.BinaryType.get()), // null if no non-null values\n-          optional(511, \"upper_bound\", Types.BinaryType.get())\n-      ))),\n-      optional(512, \"added_rows_count\", Types.LongType.get()),\n-      optional(513, \"existing_rows_count\", Types.LongType.get()),\n-      optional(514, \"deleted_rows_count\", Types.LongType.get()));\n+      PATH, LENGTH, SPEC_ID,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyMzU2MA=="}, "originalCommit": {"oid": "f5644567a13f94ce7a8e2eb820281080eff603c6"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3MzYyNQ==", "bodyText": "Yeah, the IndexedRecord field order needs to match the schema order. This is why I added a test for this as well.", "url": "https://github.com/apache/iceberg/pull/907#discussion_r408473625", "createdAt": "2020-04-14T22:29:40Z", "author": {"login": "rdblue"}, "path": "api/src/main/java/org/apache/iceberg/ManifestFile.java", "diffHunk": "@@ -30,22 +30,33 @@\n  * Represents a manifest file that can be scanned to find data files in a table.\n  */\n public interface ManifestFile {\n+  Types.NestedField PATH = required(500, \"manifest_path\", Types.StringType.get());\n+  Types.NestedField LENGTH = required(501, \"manifest_length\", Types.LongType.get());\n+  Types.NestedField SPEC_ID = required(502, \"partition_spec_id\", Types.IntegerType.get());\n+  Types.NestedField SNAPSHOT_ID = optional(503, \"added_snapshot_id\", Types.LongType.get());\n+  Types.NestedField ADDED_FILES_COUNT = optional(504, \"added_data_files_count\", Types.IntegerType.get());\n+  Types.NestedField EXISTING_FILES_COUNT = optional(505, \"existing_data_files_count\", Types.IntegerType.get());\n+  Types.NestedField DELETED_FILES_COUNT = optional(506, \"deleted_data_files_count\", Types.IntegerType.get());\n+  Types.StructType PARTITION_SUMMARY_TYPE = Types.StructType.of(\n+      required(509, \"contains_null\", Types.BooleanType.get()),\n+      optional(510, \"lower_bound\", Types.BinaryType.get()), // null if no non-null values\n+      optional(511, \"upper_bound\", Types.BinaryType.get())\n+  );\n+  Types.NestedField PARTITION_SUMMARIES = optional(507, \"partitions\",\n+      Types.ListType.ofRequired(508, PARTITION_SUMMARY_TYPE));\n+  Types.NestedField ADDED_ROWS_COUNT = optional(512, \"added_rows_count\", Types.LongType.get());\n+  Types.NestedField EXISTING_ROWS_COUNT = optional(513, \"existing_rows_count\", Types.LongType.get());\n+  Types.NestedField DELETED_ROWS_COUNT = optional(514, \"deleted_rows_count\", Types.LongType.get());\n+  Types.NestedField SEQUENCE_NUMBER = optional(515, \"sequence_number\", Types.LongType.get());\n+  Types.NestedField MIN_SEQUENCE_NUMBER = optional(516, \"min_sequence_number\", Types.LongType.get());\n+  // next ID to assign: 517\n+\n   Schema SCHEMA = new Schema(\n-      required(500, \"manifest_path\", Types.StringType.get()),\n-      required(501, \"manifest_length\", Types.LongType.get()),\n-      required(502, \"partition_spec_id\", Types.IntegerType.get()),\n-      optional(503, \"added_snapshot_id\", Types.LongType.get()),\n-      optional(504, \"added_data_files_count\", Types.IntegerType.get()),\n-      optional(505, \"existing_data_files_count\", Types.IntegerType.get()),\n-      optional(506, \"deleted_data_files_count\", Types.IntegerType.get()),\n-      optional(507, \"partitions\", Types.ListType.ofRequired(508, Types.StructType.of(\n-          required(509, \"contains_null\", Types.BooleanType.get()),\n-          optional(510, \"lower_bound\", Types.BinaryType.get()), // null if no non-null values\n-          optional(511, \"upper_bound\", Types.BinaryType.get())\n-      ))),\n-      optional(512, \"added_rows_count\", Types.LongType.get()),\n-      optional(513, \"existing_rows_count\", Types.LongType.get()),\n-      optional(514, \"deleted_rows_count\", Types.LongType.get()));\n+      PATH, LENGTH, SPEC_ID,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyMzU2MA=="}, "originalCommit": {"oid": "f5644567a13f94ce7a8e2eb820281080eff603c6"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNTY1MjU3OnYy", "diffSide": "LEFT", "path": "core/src/main/java/org/apache/iceberg/GenericManifestFile.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMDo1NDozNFrOGFgiKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMjozMjoxOVrOGFjTzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyOTA5Nw==", "bodyText": "Even though it was public, I don't think anyone is using it. Seems OK to change.", "url": "https://github.com/apache/iceberg/pull/907#discussion_r408429097", "createdAt": "2020-04-14T20:54:34Z", "author": {"login": "aokolnychyi"}, "path": "core/src/main/java/org/apache/iceberg/GenericManifestFile.java", "diffHunk": "@@ -100,32 +101,17 @@ public GenericManifestFile(org.apache.avro.Schema avroSchema) {\n     this.fromProjectionPos = null;\n   }\n \n-  public GenericManifestFile(String path, long length, int specId, Long snapshotId,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5644567a13f94ce7a8e2eb820281080eff603c6"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3NDU3NQ==", "bodyText": "Yeah, this should be fine. Classes in core are only semi-public and not part of the API. That module has stronger guarantees.", "url": "https://github.com/apache/iceberg/pull/907#discussion_r408474575", "createdAt": "2020-04-14T22:32:19Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/GenericManifestFile.java", "diffHunk": "@@ -100,32 +101,17 @@ public GenericManifestFile(org.apache.avro.Schema avroSchema) {\n     this.fromProjectionPos = null;\n   }\n \n-  public GenericManifestFile(String path, long length, int specId, Long snapshotId,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyOTA5Nw=="}, "originalCommit": {"oid": "f5644567a13f94ce7a8e2eb820281080eff603c6"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNTY2NTQ5OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/iceberg/ManifestListWriter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMDo1ODo0NFrOGFgqdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMjozMzoyMVrOGFjVWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQzMTIyMQ==", "bodyText": "Is this empty line intentional?", "url": "https://github.com/apache/iceberg/pull/907#discussion_r408431221", "createdAt": "2020-04-14T20:58:44Z", "author": {"login": "aokolnychyi"}, "path": "core/src/main/java/org/apache/iceberg/ManifestListWriter.java", "diffHunk": "@@ -84,23 +69,67 @@ public long length() {\n     return writer.length();\n   }\n \n-  private static FileAppender<ManifestFile> newAppender(OutputFile file, Map<String, String> meta) {\n-    try {\n-      return Avro.write(file)\n-          .schema(ManifestFile.schema())\n-          .named(\"manifest_file\")\n-          .meta(meta)\n-          .overwrite()\n-          .build();\n-\n-    } catch (IOException e) {\n-      throw new RuntimeIOException(e, \"Failed to create snapshot list writer for path: \" + file);\n+  static class V2Writer extends ManifestListWriter {\n+    private final V2Metadata.IndexedManifestFile wrapper;\n+\n+    V2Writer(OutputFile snapshotFile, long snapshotId, Long parentSnapshotId, long sequenceNumber) {\n+      super(snapshotFile, ImmutableMap.of(\n+          \"snapshot-id\", String.valueOf(snapshotId),\n+          \"parent-snapshot-id\", String.valueOf(parentSnapshotId),\n+          \"sequence-number\", String.valueOf(sequenceNumber),\n+          \"format-version\", \"2\"));\n+      this.wrapper = new V2Metadata.IndexedManifestFile(sequenceNumber);\n+    }\n+\n+    @Override\n+    protected ManifestFile prepare(ManifestFile manifest) {\n+      return wrapper.wrap(manifest);\n+    }\n+\n+    @Override\n+    protected FileAppender<ManifestFile> newAppender(OutputFile file, Map<String, String> meta) {\n+      try {\n+        return Avro.write(file)\n+            .schema(V2Metadata.MANIFEST_LIST_SCHEMA)\n+            .named(\"manifest_file\")\n+            .meta(meta)\n+            .overwrite()\n+            .build();\n+\n+      } catch (IOException e) {\n+        throw new RuntimeIOException(e, \"Failed to create snapshot list writer for path: \" + file);\n+      }\n     }\n   }\n \n   static class V1Writer extends ManifestListWriter {\n-    private V1Writer(OutputFile snapshotFile, long snapshotId, Long parentSnapshotId) {\n-      super(snapshotFile, snapshotId, parentSnapshotId);\n+    private final V1Metadata.IndexedManifestFile wrapper = new V1Metadata.IndexedManifestFile();\n+\n+    V1Writer(OutputFile snapshotFile, long snapshotId, Long parentSnapshotId) {\n+      super(snapshotFile, ImmutableMap.of(\n+          \"snapshot-id\", String.valueOf(snapshotId),\n+          \"parent-snapshot-id\", String.valueOf(parentSnapshotId),\n+          \"format-version\", \"1\"));\n+    }\n+\n+    @Override\n+    protected ManifestFile prepare(ManifestFile manifest) {\n+      return wrapper.wrap(manifest);\n+    }\n+\n+    protected FileAppender<ManifestFile> newAppender(OutputFile file, Map<String, String> meta) {\n+      try {\n+        return Avro.write(file)\n+            .schema(V1Metadata.MANIFEST_LIST_SCHEMA)\n+            .named(\"manifest_file\")\n+            .meta(meta)\n+            .overwrite()\n+            .build();\n+\n+      } catch (IOException e) {\n+        throw new RuntimeIOException(e, \"Failed to create snapshot list writer for path: \" + file);\n+      }\n     }\n   }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5644567a13f94ce7a8e2eb820281080eff603c6"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3NDk2OA==", "bodyText": "No.", "url": "https://github.com/apache/iceberg/pull/907#discussion_r408474968", "createdAt": "2020-04-14T22:33:21Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/ManifestListWriter.java", "diffHunk": "@@ -84,23 +69,67 @@ public long length() {\n     return writer.length();\n   }\n \n-  private static FileAppender<ManifestFile> newAppender(OutputFile file, Map<String, String> meta) {\n-    try {\n-      return Avro.write(file)\n-          .schema(ManifestFile.schema())\n-          .named(\"manifest_file\")\n-          .meta(meta)\n-          .overwrite()\n-          .build();\n-\n-    } catch (IOException e) {\n-      throw new RuntimeIOException(e, \"Failed to create snapshot list writer for path: \" + file);\n+  static class V2Writer extends ManifestListWriter {\n+    private final V2Metadata.IndexedManifestFile wrapper;\n+\n+    V2Writer(OutputFile snapshotFile, long snapshotId, Long parentSnapshotId, long sequenceNumber) {\n+      super(snapshotFile, ImmutableMap.of(\n+          \"snapshot-id\", String.valueOf(snapshotId),\n+          \"parent-snapshot-id\", String.valueOf(parentSnapshotId),\n+          \"sequence-number\", String.valueOf(sequenceNumber),\n+          \"format-version\", \"2\"));\n+      this.wrapper = new V2Metadata.IndexedManifestFile(sequenceNumber);\n+    }\n+\n+    @Override\n+    protected ManifestFile prepare(ManifestFile manifest) {\n+      return wrapper.wrap(manifest);\n+    }\n+\n+    @Override\n+    protected FileAppender<ManifestFile> newAppender(OutputFile file, Map<String, String> meta) {\n+      try {\n+        return Avro.write(file)\n+            .schema(V2Metadata.MANIFEST_LIST_SCHEMA)\n+            .named(\"manifest_file\")\n+            .meta(meta)\n+            .overwrite()\n+            .build();\n+\n+      } catch (IOException e) {\n+        throw new RuntimeIOException(e, \"Failed to create snapshot list writer for path: \" + file);\n+      }\n     }\n   }\n \n   static class V1Writer extends ManifestListWriter {\n-    private V1Writer(OutputFile snapshotFile, long snapshotId, Long parentSnapshotId) {\n-      super(snapshotFile, snapshotId, parentSnapshotId);\n+    private final V1Metadata.IndexedManifestFile wrapper = new V1Metadata.IndexedManifestFile();\n+\n+    V1Writer(OutputFile snapshotFile, long snapshotId, Long parentSnapshotId) {\n+      super(snapshotFile, ImmutableMap.of(\n+          \"snapshot-id\", String.valueOf(snapshotId),\n+          \"parent-snapshot-id\", String.valueOf(parentSnapshotId),\n+          \"format-version\", \"1\"));\n+    }\n+\n+    @Override\n+    protected ManifestFile prepare(ManifestFile manifest) {\n+      return wrapper.wrap(manifest);\n+    }\n+\n+    protected FileAppender<ManifestFile> newAppender(OutputFile file, Map<String, String> meta) {\n+      try {\n+        return Avro.write(file)\n+            .schema(V1Metadata.MANIFEST_LIST_SCHEMA)\n+            .named(\"manifest_file\")\n+            .meta(meta)\n+            .overwrite()\n+            .build();\n+\n+      } catch (IOException e) {\n+        throw new RuntimeIOException(e, \"Failed to create snapshot list writer for path: \" + file);\n+      }\n     }\n   }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQzMTIyMQ=="}, "originalCommit": {"oid": "f5644567a13f94ce7a8e2eb820281080eff603c6"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNTc3NjIyOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/iceberg/GenericManifestFile.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMTozMTo1NlrOGFhuAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMjozMTozOFrOGFjS6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ0ODUxNA==", "bodyText": "Looks like we are trying to match the new ordering of fields in ManifestFile. Earlier, we co-located ...FilesCount with ...RowsCount to match the ordering of methods in ManifestFile and args in constructors. Is this change intentional?", "url": "https://github.com/apache/iceberg/pull/907#discussion_r408448514", "createdAt": "2020-04-14T21:31:56Z", "author": {"login": "aokolnychyi"}, "path": "core/src/main/java/org/apache/iceberg/GenericManifestFile.java", "diffHunk": "@@ -46,12 +46,14 @@\n   private String manifestPath = null;\n   private Long length = null;\n   private int specId = -1;\n+  private long sequenceNumber = 0;\n+  private long minSequenceNumber = 0;\n   private Long snapshotId = null;\n   private Integer addedFilesCount = null;\n-  private Long addedRowsCount = null;\n   private Integer existingFilesCount = null;\n-  private Long existingRowsCount = null;\n   private Integer deletedFilesCount = null;\n+  private Long addedRowsCount = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5644567a13f94ce7a8e2eb820281080eff603c6"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3NDM0Ng==", "bodyText": "Yes. I think it's likely that these are going to be null in some cases, like manifests that contain equality delete files. Instead of mixing null, non-null, null, non-null, etc. I think it's better to keep the probably-null columns colocated for compression.", "url": "https://github.com/apache/iceberg/pull/907#discussion_r408474346", "createdAt": "2020-04-14T22:31:38Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/GenericManifestFile.java", "diffHunk": "@@ -46,12 +46,14 @@\n   private String manifestPath = null;\n   private Long length = null;\n   private int specId = -1;\n+  private long sequenceNumber = 0;\n+  private long minSequenceNumber = 0;\n   private Long snapshotId = null;\n   private Integer addedFilesCount = null;\n-  private Long addedRowsCount = null;\n   private Integer existingFilesCount = null;\n-  private Long existingRowsCount = null;\n   private Integer deletedFilesCount = null;\n+  private Long addedRowsCount = null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ0ODUxNA=="}, "originalCommit": {"oid": "f5644567a13f94ce7a8e2eb820281080eff603c6"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNTkxODUzOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/iceberg/ManifestListWriter.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMjoyMTo1MVrOGFjEFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMzoxNDo0M1rOGFkNvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3MDU0OA==", "bodyText": "Seems like this is the place where we can pass a snapshot id similar to how we pass a sequence number to V2 and get rid of the logic for inheriting metadata for ManifestEntry via setSnapshotId and iterating through manifests during commit.\nDo I get it correctly, @rdblue?", "url": "https://github.com/apache/iceberg/pull/907#discussion_r408470548", "createdAt": "2020-04-14T22:21:51Z", "author": {"login": "aokolnychyi"}, "path": "core/src/main/java/org/apache/iceberg/ManifestListWriter.java", "diffHunk": "@@ -84,23 +69,67 @@ public long length() {\n     return writer.length();\n   }\n \n-  private static FileAppender<ManifestFile> newAppender(OutputFile file, Map<String, String> meta) {\n-    try {\n-      return Avro.write(file)\n-          .schema(ManifestFile.schema())\n-          .named(\"manifest_file\")\n-          .meta(meta)\n-          .overwrite()\n-          .build();\n-\n-    } catch (IOException e) {\n-      throw new RuntimeIOException(e, \"Failed to create snapshot list writer for path: \" + file);\n+  static class V2Writer extends ManifestListWriter {\n+    private final V2Metadata.IndexedManifestFile wrapper;\n+\n+    V2Writer(OutputFile snapshotFile, long snapshotId, Long parentSnapshotId, long sequenceNumber) {\n+      super(snapshotFile, ImmutableMap.of(\n+          \"snapshot-id\", String.valueOf(snapshotId),\n+          \"parent-snapshot-id\", String.valueOf(parentSnapshotId),\n+          \"sequence-number\", String.valueOf(sequenceNumber),\n+          \"format-version\", \"2\"));\n+      this.wrapper = new V2Metadata.IndexedManifestFile(sequenceNumber);\n+    }\n+\n+    @Override\n+    protected ManifestFile prepare(ManifestFile manifest) {\n+      return wrapper.wrap(manifest);\n+    }\n+\n+    @Override\n+    protected FileAppender<ManifestFile> newAppender(OutputFile file, Map<String, String> meta) {\n+      try {\n+        return Avro.write(file)\n+            .schema(V2Metadata.MANIFEST_LIST_SCHEMA)\n+            .named(\"manifest_file\")\n+            .meta(meta)\n+            .overwrite()\n+            .build();\n+\n+      } catch (IOException e) {\n+        throw new RuntimeIOException(e, \"Failed to create snapshot list writer for path: \" + file);\n+      }\n     }\n   }\n \n   static class V1Writer extends ManifestListWriter {\n-    private V1Writer(OutputFile snapshotFile, long snapshotId, Long parentSnapshotId) {\n-      super(snapshotFile, snapshotId, parentSnapshotId);\n+    private final V1Metadata.IndexedManifestFile wrapper = new V1Metadata.IndexedManifestFile();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5644567a13f94ce7a8e2eb820281080eff603c6"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3NDg4NQ==", "bodyText": "Yes. I'm going to rework inheritance for snapshot ID in a separate commit.", "url": "https://github.com/apache/iceberg/pull/907#discussion_r408474885", "createdAt": "2020-04-14T22:33:04Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/ManifestListWriter.java", "diffHunk": "@@ -84,23 +69,67 @@ public long length() {\n     return writer.length();\n   }\n \n-  private static FileAppender<ManifestFile> newAppender(OutputFile file, Map<String, String> meta) {\n-    try {\n-      return Avro.write(file)\n-          .schema(ManifestFile.schema())\n-          .named(\"manifest_file\")\n-          .meta(meta)\n-          .overwrite()\n-          .build();\n-\n-    } catch (IOException e) {\n-      throw new RuntimeIOException(e, \"Failed to create snapshot list writer for path: \" + file);\n+  static class V2Writer extends ManifestListWriter {\n+    private final V2Metadata.IndexedManifestFile wrapper;\n+\n+    V2Writer(OutputFile snapshotFile, long snapshotId, Long parentSnapshotId, long sequenceNumber) {\n+      super(snapshotFile, ImmutableMap.of(\n+          \"snapshot-id\", String.valueOf(snapshotId),\n+          \"parent-snapshot-id\", String.valueOf(parentSnapshotId),\n+          \"sequence-number\", String.valueOf(sequenceNumber),\n+          \"format-version\", \"2\"));\n+      this.wrapper = new V2Metadata.IndexedManifestFile(sequenceNumber);\n+    }\n+\n+    @Override\n+    protected ManifestFile prepare(ManifestFile manifest) {\n+      return wrapper.wrap(manifest);\n+    }\n+\n+    @Override\n+    protected FileAppender<ManifestFile> newAppender(OutputFile file, Map<String, String> meta) {\n+      try {\n+        return Avro.write(file)\n+            .schema(V2Metadata.MANIFEST_LIST_SCHEMA)\n+            .named(\"manifest_file\")\n+            .meta(meta)\n+            .overwrite()\n+            .build();\n+\n+      } catch (IOException e) {\n+        throw new RuntimeIOException(e, \"Failed to create snapshot list writer for path: \" + file);\n+      }\n     }\n   }\n \n   static class V1Writer extends ManifestListWriter {\n-    private V1Writer(OutputFile snapshotFile, long snapshotId, Long parentSnapshotId) {\n-      super(snapshotFile, snapshotId, parentSnapshotId);\n+    private final V1Metadata.IndexedManifestFile wrapper = new V1Metadata.IndexedManifestFile();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3MDU0OA=="}, "originalCommit": {"oid": "f5644567a13f94ce7a8e2eb820281080eff603c6"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ4OTQwNQ==", "bodyText": "Great!", "url": "https://github.com/apache/iceberg/pull/907#discussion_r408489405", "createdAt": "2020-04-14T23:14:43Z", "author": {"login": "aokolnychyi"}, "path": "core/src/main/java/org/apache/iceberg/ManifestListWriter.java", "diffHunk": "@@ -84,23 +69,67 @@ public long length() {\n     return writer.length();\n   }\n \n-  private static FileAppender<ManifestFile> newAppender(OutputFile file, Map<String, String> meta) {\n-    try {\n-      return Avro.write(file)\n-          .schema(ManifestFile.schema())\n-          .named(\"manifest_file\")\n-          .meta(meta)\n-          .overwrite()\n-          .build();\n-\n-    } catch (IOException e) {\n-      throw new RuntimeIOException(e, \"Failed to create snapshot list writer for path: \" + file);\n+  static class V2Writer extends ManifestListWriter {\n+    private final V2Metadata.IndexedManifestFile wrapper;\n+\n+    V2Writer(OutputFile snapshotFile, long snapshotId, Long parentSnapshotId, long sequenceNumber) {\n+      super(snapshotFile, ImmutableMap.of(\n+          \"snapshot-id\", String.valueOf(snapshotId),\n+          \"parent-snapshot-id\", String.valueOf(parentSnapshotId),\n+          \"sequence-number\", String.valueOf(sequenceNumber),\n+          \"format-version\", \"2\"));\n+      this.wrapper = new V2Metadata.IndexedManifestFile(sequenceNumber);\n+    }\n+\n+    @Override\n+    protected ManifestFile prepare(ManifestFile manifest) {\n+      return wrapper.wrap(manifest);\n+    }\n+\n+    @Override\n+    protected FileAppender<ManifestFile> newAppender(OutputFile file, Map<String, String> meta) {\n+      try {\n+        return Avro.write(file)\n+            .schema(V2Metadata.MANIFEST_LIST_SCHEMA)\n+            .named(\"manifest_file\")\n+            .meta(meta)\n+            .overwrite()\n+            .build();\n+\n+      } catch (IOException e) {\n+        throw new RuntimeIOException(e, \"Failed to create snapshot list writer for path: \" + file);\n+      }\n     }\n   }\n \n   static class V1Writer extends ManifestListWriter {\n-    private V1Writer(OutputFile snapshotFile, long snapshotId, Long parentSnapshotId) {\n-      super(snapshotFile, snapshotId, parentSnapshotId);\n+    private final V1Metadata.IndexedManifestFile wrapper = new V1Metadata.IndexedManifestFile();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3MDU0OA=="}, "originalCommit": {"oid": "f5644567a13f94ce7a8e2eb820281080eff603c6"}, "originalPosition": 112}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2898, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}