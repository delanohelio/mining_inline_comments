{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ5NjI5NDk0", "number": 1208, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QwMzoxMTo0OFrOERSfow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQwMzoyOToyNlrOEWpS4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NTY0MjU5OnYy", "diffSide": "RIGHT", "path": "orc/src/test/java/org/apache/iceberg/orc/TestORCSchemaUtil.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QwMzoxMTo0OFrOG1664Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQwMDo1NzowMVrOG2gTNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE5MzA1Nw==", "bodyText": "If we are not comparing the attributes here, is there any value to adding this assert? Seems like name mapping's effect (assigning ids) is not actually being tested in this case.", "url": "https://github.com/apache/iceberg/pull/1208#discussion_r459193057", "createdAt": "2020-07-23T03:11:48Z", "author": {"login": "shardulm94"}, "path": "orc/src/test/java/org/apache/iceberg/orc/TestORCSchemaUtil.java", "diffHunk": "@@ -269,4 +278,68 @@ public void testSkipNonIcebergColumns() {\n     );\n     assertEquals(\"Schemas must match.\", expectedSchema2.asStruct(), icebergSchema2.asStruct());\n   }\n+\n+  @Test\n+  public void testHasIds() {\n+    Schema schema = new Schema(\n+        optional(1, \"data\", Types.StructType.of(\n+            optional(10, \"entries\", Types.MapType.ofOptional(11, 12, Types.StringType.get(), Types.DateType.get()))\n+        )),\n+        optional(2, \"intCol\", Types.IntegerType.get()),\n+        optional(3, \"longCol\", Types.LongType.get()),\n+        optional(4, \"listCol\", Types.ListType.ofOptional(40, Types.DoubleType.get()))\n+    );\n+\n+    TypeDescription orcSchema = ORCSchemaUtil.removeIds(ORCSchemaUtil.convert(schema));\n+    assertFalse(\"Should not have Ids\", ORCSchemaUtil.hasIds(orcSchema));\n+\n+    TypeDescription map2Col = TypeDescription.createMap(TypeDescription.createString(), TypeDescription.createBinary());\n+    map2Col.setAttribute(ICEBERG_ID_ATTRIBUTE, \"4\");\n+    orcSchema.addField(\"map2Col\", map2Col);\n+    assertTrue(\"Should have Ids after adding one type with Id\", ORCSchemaUtil.hasIds(orcSchema));\n+  }\n+\n+  @Test\n+  public void tetsAssignIdsByNameMapping() {\n+    Types.StructType structType = Types.StructType.of(\n+        required(0, \"id\", Types.LongType.get()),\n+        optional(1, \"list_of_maps\",\n+            Types.ListType.ofOptional(2, Types.MapType.ofOptional(3, 4,\n+                Types.StringType.get(),\n+                SUPPORTED_PRIMITIVES))),\n+        optional(5, \"map_of_lists\",\n+            Types.MapType.ofOptional(6, 7,\n+                Types.StringType.get(),\n+                Types.ListType.ofOptional(8, SUPPORTED_PRIMITIVES))),\n+        required(9, \"list_of_lists\",\n+            Types.ListType.ofOptional(10, Types.ListType.ofOptional(11, SUPPORTED_PRIMITIVES))),\n+        required(12, \"map_of_maps\",\n+            Types.MapType.ofOptional(13, 14,\n+                Types.StringType.get(),\n+                Types.MapType.ofOptional(15, 16,\n+                    Types.StringType.get(),\n+                    SUPPORTED_PRIMITIVES))),\n+        required(17, \"list_of_struct_of_nested_types\", Types.ListType.ofOptional(19, Types.StructType.of(\n+            Types.NestedField.required(20, \"m1\", Types.MapType.ofOptional(21, 22,\n+                Types.StringType.get(),\n+                SUPPORTED_PRIMITIVES)),\n+            Types.NestedField.optional(23, \"l1\", Types.ListType.ofRequired(24, SUPPORTED_PRIMITIVES)),\n+            Types.NestedField.required(25, \"l2\", Types.ListType.ofRequired(26, SUPPORTED_PRIMITIVES)),\n+            Types.NestedField.optional(27, \"m2\", Types.MapType.ofOptional(28, 29,\n+                Types.StringType.get(),\n+                SUPPORTED_PRIMITIVES))\n+        )))\n+    );\n+\n+    Schema schema = new Schema(TypeUtil.assignFreshIds(structType, new AtomicInteger(0)::incrementAndGet)\n+        .asStructType().fields());\n+\n+    NameMapping nameMapping = MappingUtil.create(schema);\n+    TypeDescription typeDescriptionWithIds = ORCSchemaUtil.convert(schema);\n+    TypeDescription typeDescriptionWithIdsFromNameMapping = ORCSchemaUtil\n+        .applyNameMapping(ORCSchemaUtil.removeIds(typeDescriptionWithIds), nameMapping);\n+\n+    assertTrue(\"TypeDescription schemas should be equal, not comparing Attributes\",\n+        typeDescriptionWithIds.equals(typeDescriptionWithIdsFromNameMapping, false /* checkAttributes */));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b365e8b4a88e82705f543f72d04a8f9dc7df4b4"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgwNTQ5NA==", "bodyText": "I've added a check for the IDs as well.", "url": "https://github.com/apache/iceberg/pull/1208#discussion_r459805494", "createdAt": "2020-07-24T00:57:01Z", "author": {"login": "edgarRd"}, "path": "orc/src/test/java/org/apache/iceberg/orc/TestORCSchemaUtil.java", "diffHunk": "@@ -269,4 +278,68 @@ public void testSkipNonIcebergColumns() {\n     );\n     assertEquals(\"Schemas must match.\", expectedSchema2.asStruct(), icebergSchema2.asStruct());\n   }\n+\n+  @Test\n+  public void testHasIds() {\n+    Schema schema = new Schema(\n+        optional(1, \"data\", Types.StructType.of(\n+            optional(10, \"entries\", Types.MapType.ofOptional(11, 12, Types.StringType.get(), Types.DateType.get()))\n+        )),\n+        optional(2, \"intCol\", Types.IntegerType.get()),\n+        optional(3, \"longCol\", Types.LongType.get()),\n+        optional(4, \"listCol\", Types.ListType.ofOptional(40, Types.DoubleType.get()))\n+    );\n+\n+    TypeDescription orcSchema = ORCSchemaUtil.removeIds(ORCSchemaUtil.convert(schema));\n+    assertFalse(\"Should not have Ids\", ORCSchemaUtil.hasIds(orcSchema));\n+\n+    TypeDescription map2Col = TypeDescription.createMap(TypeDescription.createString(), TypeDescription.createBinary());\n+    map2Col.setAttribute(ICEBERG_ID_ATTRIBUTE, \"4\");\n+    orcSchema.addField(\"map2Col\", map2Col);\n+    assertTrue(\"Should have Ids after adding one type with Id\", ORCSchemaUtil.hasIds(orcSchema));\n+  }\n+\n+  @Test\n+  public void tetsAssignIdsByNameMapping() {\n+    Types.StructType structType = Types.StructType.of(\n+        required(0, \"id\", Types.LongType.get()),\n+        optional(1, \"list_of_maps\",\n+            Types.ListType.ofOptional(2, Types.MapType.ofOptional(3, 4,\n+                Types.StringType.get(),\n+                SUPPORTED_PRIMITIVES))),\n+        optional(5, \"map_of_lists\",\n+            Types.MapType.ofOptional(6, 7,\n+                Types.StringType.get(),\n+                Types.ListType.ofOptional(8, SUPPORTED_PRIMITIVES))),\n+        required(9, \"list_of_lists\",\n+            Types.ListType.ofOptional(10, Types.ListType.ofOptional(11, SUPPORTED_PRIMITIVES))),\n+        required(12, \"map_of_maps\",\n+            Types.MapType.ofOptional(13, 14,\n+                Types.StringType.get(),\n+                Types.MapType.ofOptional(15, 16,\n+                    Types.StringType.get(),\n+                    SUPPORTED_PRIMITIVES))),\n+        required(17, \"list_of_struct_of_nested_types\", Types.ListType.ofOptional(19, Types.StructType.of(\n+            Types.NestedField.required(20, \"m1\", Types.MapType.ofOptional(21, 22,\n+                Types.StringType.get(),\n+                SUPPORTED_PRIMITIVES)),\n+            Types.NestedField.optional(23, \"l1\", Types.ListType.ofRequired(24, SUPPORTED_PRIMITIVES)),\n+            Types.NestedField.required(25, \"l2\", Types.ListType.ofRequired(26, SUPPORTED_PRIMITIVES)),\n+            Types.NestedField.optional(27, \"m2\", Types.MapType.ofOptional(28, 29,\n+                Types.StringType.get(),\n+                SUPPORTED_PRIMITIVES))\n+        )))\n+    );\n+\n+    Schema schema = new Schema(TypeUtil.assignFreshIds(structType, new AtomicInteger(0)::incrementAndGet)\n+        .asStructType().fields());\n+\n+    NameMapping nameMapping = MappingUtil.create(schema);\n+    TypeDescription typeDescriptionWithIds = ORCSchemaUtil.convert(schema);\n+    TypeDescription typeDescriptionWithIdsFromNameMapping = ORCSchemaUtil\n+        .applyNameMapping(ORCSchemaUtil.removeIds(typeDescriptionWithIds), nameMapping);\n+\n+    assertTrue(\"TypeDescription schemas should be equal, not comparing Attributes\",\n+        typeDescriptionWithIds.equals(typeDescriptionWithIdsFromNameMapping, false /* checkAttributes */));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE5MzA1Nw=="}, "originalCommit": {"oid": "2b365e8b4a88e82705f543f72d04a8f9dc7df4b4"}, "originalPosition": 133}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3MzIyMDQ5OnYy", "diffSide": "RIGHT", "path": "orc/src/main/java/org/apache/iceberg/orc/OrcIterable.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNVQwMzowMjo0M1rOG3B5_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwNDoxMDoyNlrOG374DQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM1NjA5NA==", "bodyText": "Should we also check if the file schema does not have ids before initializing nameMapping?", "url": "https://github.com/apache/iceberg/pull/1208#discussion_r460356094", "createdAt": "2020-07-25T03:02:43Z", "author": {"login": "rdsr"}, "path": "orc/src/main/java/org/apache/iceberg/orc/OrcIterable.java", "diffHunk": "@@ -51,14 +54,16 @@\n   private final boolean caseSensitive;\n   private final Function<TypeDescription, OrcBatchReader<?>> batchReaderFunction;\n   private final int recordsPerBatch;\n+  private final NameMapping nameMapping;\n \n   OrcIterable(InputFile file, Configuration config, Schema schema,\n-              Long start, Long length,\n+              NameMapping nameMapping, Long start, Long length,\n               Function<TypeDescription, OrcRowReader<?>> readerFunction, boolean caseSensitive, Expression filter,\n               Function<TypeDescription, OrcBatchReader<?>> batchReaderFunction, int recordsPerBatch) {\n     this.schema = schema;\n     this.readerFunction = readerFunction;\n     this.file = file;\n+    this.nameMapping = Optional.ofNullable(nameMapping).orElse(MappingUtil.create(schema));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0c4eb569de8e340803ae01a6e3367e8d1e37145"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTMwNTg2OQ==", "bodyText": "Done.", "url": "https://github.com/apache/iceberg/pull/1208#discussion_r461305869", "createdAt": "2020-07-28T04:10:26Z", "author": {"login": "edgarRd"}, "path": "orc/src/main/java/org/apache/iceberg/orc/OrcIterable.java", "diffHunk": "@@ -51,14 +54,16 @@\n   private final boolean caseSensitive;\n   private final Function<TypeDescription, OrcBatchReader<?>> batchReaderFunction;\n   private final int recordsPerBatch;\n+  private final NameMapping nameMapping;\n \n   OrcIterable(InputFile file, Configuration config, Schema schema,\n-              Long start, Long length,\n+              NameMapping nameMapping, Long start, Long length,\n               Function<TypeDescription, OrcRowReader<?>> readerFunction, boolean caseSensitive, Expression filter,\n               Function<TypeDescription, OrcBatchReader<?>> batchReaderFunction, int recordsPerBatch) {\n     this.schema = schema;\n     this.readerFunction = readerFunction;\n     this.file = file;\n+    this.nameMapping = Optional.ofNullable(nameMapping).orElse(MappingUtil.create(schema));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM1NjA5NA=="}, "originalCommit": {"oid": "c0c4eb569de8e340803ae01a6e3367e8d1e37145"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3MzI1ODk2OnYy", "diffSide": "RIGHT", "path": "orc/src/main/java/org/apache/iceberg/orc/ApplyNameMapping.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNVQwMzo1ODoyMFrOG3CMCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxNjowNjo0NVrOG3pTDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM2MDcxNQ==", "bodyText": "shouldn't a 'type' be pruned if a mappedField is missing or null?", "url": "https://github.com/apache/iceberg/pull/1208#discussion_r460360715", "createdAt": "2020-07-25T03:58:20Z", "author": {"login": "rdsr"}, "path": "orc/src/main/java/org/apache/iceberg/orc/ApplyNameMapping.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.orc;\n+\n+import java.util.List;\n+import org.apache.iceberg.mapping.MappedField;\n+import org.apache.iceberg.mapping.NameMapping;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.orc.TypeDescription;\n+\n+class ApplyNameMapping extends OrcSchemaVisitor<TypeDescription> {\n+  private final NameMapping nameMapping;\n+\n+  ApplyNameMapping(NameMapping nameMapping) {\n+    this.nameMapping = nameMapping;\n+  }\n+\n+  @Override\n+  public String elementName() {\n+    return \"element\";\n+  }\n+\n+  @Override\n+  public String keyName() {\n+    return \"key\";\n+  }\n+\n+  @Override\n+  public String valueName() {\n+    return \"value\";\n+  }\n+\n+  TypeDescription setId(TypeDescription type, MappedField mappedField) {\n+    if (mappedField != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0c4eb569de8e340803ae01a6e3367e8d1e37145"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM3NTk2Ng==", "bodyText": "I think this works as we are using the Iceberg read schema for building the projection.", "url": "https://github.com/apache/iceberg/pull/1208#discussion_r460375966", "createdAt": "2020-07-25T07:15:49Z", "author": {"login": "rdsr"}, "path": "orc/src/main/java/org/apache/iceberg/orc/ApplyNameMapping.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.orc;\n+\n+import java.util.List;\n+import org.apache.iceberg.mapping.MappedField;\n+import org.apache.iceberg.mapping.NameMapping;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.orc.TypeDescription;\n+\n+class ApplyNameMapping extends OrcSchemaVisitor<TypeDescription> {\n+  private final NameMapping nameMapping;\n+\n+  ApplyNameMapping(NameMapping nameMapping) {\n+    this.nameMapping = nameMapping;\n+  }\n+\n+  @Override\n+  public String elementName() {\n+    return \"element\";\n+  }\n+\n+  @Override\n+  public String keyName() {\n+    return \"key\";\n+  }\n+\n+  @Override\n+  public String valueName() {\n+    return \"value\";\n+  }\n+\n+  TypeDescription setId(TypeDescription type, MappedField mappedField) {\n+    if (mappedField != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM2MDcxNQ=="}, "originalCommit": {"oid": "c0c4eb569de8e340803ae01a6e3367e8d1e37145"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTAwMTQ4Nw==", "bodyText": "That logic was implemented in #1140", "url": "https://github.com/apache/iceberg/pull/1208#discussion_r461001487", "createdAt": "2020-07-27T16:06:45Z", "author": {"login": "edgarRd"}, "path": "orc/src/main/java/org/apache/iceberg/orc/ApplyNameMapping.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.orc;\n+\n+import java.util.List;\n+import org.apache.iceberg.mapping.MappedField;\n+import org.apache.iceberg.mapping.NameMapping;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.orc.TypeDescription;\n+\n+class ApplyNameMapping extends OrcSchemaVisitor<TypeDescription> {\n+  private final NameMapping nameMapping;\n+\n+  ApplyNameMapping(NameMapping nameMapping) {\n+    this.nameMapping = nameMapping;\n+  }\n+\n+  @Override\n+  public String elementName() {\n+    return \"element\";\n+  }\n+\n+  @Override\n+  public String keyName() {\n+    return \"key\";\n+  }\n+\n+  @Override\n+  public String valueName() {\n+    return \"value\";\n+  }\n+\n+  TypeDescription setId(TypeDescription type, MappedField mappedField) {\n+    if (mappedField != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM2MDcxNQ=="}, "originalCommit": {"oid": "c0c4eb569de8e340803ae01a6e3367e8d1e37145"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3MzI2MDgzOnYy", "diffSide": "RIGHT", "path": "orc/src/main/java/org/apache/iceberg/orc/ApplyNameMapping.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNVQwNDowMDo0NFrOG3CM3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxNjowODo0OVrOG3pX0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM2MDkyNQ==", "bodyText": "Why do we need to call clone here?", "url": "https://github.com/apache/iceberg/pull/1208#discussion_r460360925", "createdAt": "2020-07-25T04:00:44Z", "author": {"login": "rdsr"}, "path": "orc/src/main/java/org/apache/iceberg/orc/ApplyNameMapping.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.orc;\n+\n+import java.util.List;\n+import org.apache.iceberg.mapping.MappedField;\n+import org.apache.iceberg.mapping.NameMapping;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.orc.TypeDescription;\n+\n+class ApplyNameMapping extends OrcSchemaVisitor<TypeDescription> {\n+  private final NameMapping nameMapping;\n+\n+  ApplyNameMapping(NameMapping nameMapping) {\n+    this.nameMapping = nameMapping;\n+  }\n+\n+  @Override\n+  public String elementName() {\n+    return \"element\";\n+  }\n+\n+  @Override\n+  public String keyName() {\n+    return \"key\";\n+  }\n+\n+  @Override\n+  public String valueName() {\n+    return \"value\";\n+  }\n+\n+  TypeDescription setId(TypeDescription type, MappedField mappedField) {\n+    if (mappedField != null) {\n+      type.setAttribute(ORCSchemaUtil.ICEBERG_ID_ATTRIBUTE, mappedField.id().toString());\n+    }\n+    return type;\n+  }\n+\n+  @Override\n+  public TypeDescription record(TypeDescription record, List<String> names, List<TypeDescription> fields) {\n+    Preconditions.checkArgument(names.size() == fields.size(), \"All fields must have names\");\n+    MappedField field = nameMapping.find(currentPath());\n+    TypeDescription structType = TypeDescription.createStruct();\n+\n+    for (int i = 0; i < fields.size(); i++) {\n+      String fieldName = names.get(i);\n+      TypeDescription fieldType = fields.get(i);\n+      if (fieldType != null) {\n+        structType.addField(fieldName, fieldType);\n+      }\n+    }\n+    return setId(structType, field);\n+  }\n+\n+  @Override\n+  public TypeDescription list(TypeDescription array, TypeDescription element) {\n+    Preconditions.checkArgument(element != null, \"List type must have element type\");\n+\n+    MappedField field = nameMapping.find(currentPath());\n+    TypeDescription listType = TypeDescription.createList(element);\n+    return setId(listType, field);\n+  }\n+\n+  @Override\n+  public TypeDescription map(TypeDescription map, TypeDescription key, TypeDescription value) {\n+    Preconditions.checkArgument(key != null && value != null, \"Map type must have both key and value types\");\n+\n+    MappedField field = nameMapping.find(currentPath());\n+    TypeDescription mapType = TypeDescription.createMap(key, value);\n+    return setId(mapType, field);\n+  }\n+\n+  @Override\n+  public TypeDescription primitive(TypeDescription primitive) {\n+    MappedField field = nameMapping.find(currentPath());\n+    return setId(primitive.clone(), field);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0c4eb569de8e340803ae01a6e3367e8d1e37145"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTAwMjcwNw==", "bodyText": "The ApplyNameMapping returns new TypeDescription objects when mapped instead of the same references as input. For consistency, on primitives we clone the object to create a new one. This is consistent with the other format implementations of ApplyNameMapping creating a new tree as output.", "url": "https://github.com/apache/iceberg/pull/1208#discussion_r461002707", "createdAt": "2020-07-27T16:08:49Z", "author": {"login": "edgarRd"}, "path": "orc/src/main/java/org/apache/iceberg/orc/ApplyNameMapping.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.orc;\n+\n+import java.util.List;\n+import org.apache.iceberg.mapping.MappedField;\n+import org.apache.iceberg.mapping.NameMapping;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.orc.TypeDescription;\n+\n+class ApplyNameMapping extends OrcSchemaVisitor<TypeDescription> {\n+  private final NameMapping nameMapping;\n+\n+  ApplyNameMapping(NameMapping nameMapping) {\n+    this.nameMapping = nameMapping;\n+  }\n+\n+  @Override\n+  public String elementName() {\n+    return \"element\";\n+  }\n+\n+  @Override\n+  public String keyName() {\n+    return \"key\";\n+  }\n+\n+  @Override\n+  public String valueName() {\n+    return \"value\";\n+  }\n+\n+  TypeDescription setId(TypeDescription type, MappedField mappedField) {\n+    if (mappedField != null) {\n+      type.setAttribute(ORCSchemaUtil.ICEBERG_ID_ATTRIBUTE, mappedField.id().toString());\n+    }\n+    return type;\n+  }\n+\n+  @Override\n+  public TypeDescription record(TypeDescription record, List<String> names, List<TypeDescription> fields) {\n+    Preconditions.checkArgument(names.size() == fields.size(), \"All fields must have names\");\n+    MappedField field = nameMapping.find(currentPath());\n+    TypeDescription structType = TypeDescription.createStruct();\n+\n+    for (int i = 0; i < fields.size(); i++) {\n+      String fieldName = names.get(i);\n+      TypeDescription fieldType = fields.get(i);\n+      if (fieldType != null) {\n+        structType.addField(fieldName, fieldType);\n+      }\n+    }\n+    return setId(structType, field);\n+  }\n+\n+  @Override\n+  public TypeDescription list(TypeDescription array, TypeDescription element) {\n+    Preconditions.checkArgument(element != null, \"List type must have element type\");\n+\n+    MappedField field = nameMapping.find(currentPath());\n+    TypeDescription listType = TypeDescription.createList(element);\n+    return setId(listType, field);\n+  }\n+\n+  @Override\n+  public TypeDescription map(TypeDescription map, TypeDescription key, TypeDescription value) {\n+    Preconditions.checkArgument(key != null && value != null, \"Map type must have both key and value types\");\n+\n+    MappedField field = nameMapping.find(currentPath());\n+    TypeDescription mapType = TypeDescription.createMap(key, value);\n+    return setId(mapType, field);\n+  }\n+\n+  @Override\n+  public TypeDescription primitive(TypeDescription primitive) {\n+    MappedField field = nameMapping.find(currentPath());\n+    return setId(primitive.clone(), field);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM2MDkyNQ=="}, "originalCommit": {"oid": "c0c4eb569de8e340803ae01a6e3367e8d1e37145"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3MzI2MjQzOnYy", "diffSide": "RIGHT", "path": "orc/src/main/java/org/apache/iceberg/orc/OrcSchemaVisitor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNVQwNDowMzo0NVrOG3CNpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxNjoxMjozNVrOG3phiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM2MTEyNg==", "bodyText": "Why underscores?", "url": "https://github.com/apache/iceberg/pull/1208#discussion_r460361126", "createdAt": "2020-07-25T04:03:45Z", "author": {"login": "rdsr"}, "path": "orc/src/main/java/org/apache/iceberg/orc/OrcSchemaVisitor.java", "diffHunk": "@@ -83,9 +112,53 @@\n     return visitor.record(record, names, visitFields(fields, names, visitor));\n   }\n \n-  public void beforeField(String name, TypeDescription type) {}\n+  public String elementName() {\n+    return \"_elem\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0c4eb569de8e340803ae01a6e3367e8d1e37145"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTAwNTE5Mw==", "bodyText": "These are the ORC names for list elements. Same for Map as _key and _value.", "url": "https://github.com/apache/iceberg/pull/1208#discussion_r461005193", "createdAt": "2020-07-27T16:12:35Z", "author": {"login": "edgarRd"}, "path": "orc/src/main/java/org/apache/iceberg/orc/OrcSchemaVisitor.java", "diffHunk": "@@ -83,9 +112,53 @@\n     return visitor.record(record, names, visitFields(fields, names, visitor));\n   }\n \n-  public void beforeField(String name, TypeDescription type) {}\n+  public String elementName() {\n+    return \"_elem\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM2MTEyNg=="}, "originalCommit": {"oid": "c0c4eb569de8e340803ae01a6e3367e8d1e37145"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3MzI2NjE1OnYy", "diffSide": "RIGHT", "path": "orc/src/main/java/org/apache/iceberg/orc/RemoveIds.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNVQwNDowODoyN1rOG3CPRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxNjoxNDo1OVrOG3pnmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM2MTU0MQ==", "bodyText": "Why don't we only remove the ID attribute?", "url": "https://github.com/apache/iceberg/pull/1208#discussion_r460361541", "createdAt": "2020-07-25T04:08:27Z", "author": {"login": "rdsr"}, "path": "orc/src/main/java/org/apache/iceberg/orc/RemoveIds.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.orc;\n+\n+import java.util.List;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.orc.TypeDescription;\n+\n+class RemoveIds extends OrcSchemaVisitor<TypeDescription> {\n+\n+  @Override\n+  public TypeDescription record(TypeDescription record, List<String> names, List<TypeDescription> fields) {\n+    Preconditions.checkArgument(names.size() == fields.size(), \"All fields must have names.\");\n+    TypeDescription struct = TypeDescription.createStruct();\n+\n+    for (int i = 0; i < fields.size(); i++) {\n+      struct.addField(names.get(i), fields.get(i));\n+    }\n+    return struct;\n+  }\n+\n+  @Override\n+  public TypeDescription list(TypeDescription array, TypeDescription element) {\n+    return TypeDescription.createList(element);\n+  }\n+\n+  @Override\n+  public TypeDescription map(TypeDescription map, TypeDescription key, TypeDescription value) {\n+    return TypeDescription.createMap(key, value);\n+  }\n+\n+  @Override\n+  public TypeDescription primitive(TypeDescription primitive) {\n+    return removeIcebergAttributes(primitive.clone());\n+  }\n+\n+  private static TypeDescription removeIcebergAttributes(TypeDescription orcType) {\n+    orcType.removeAttribute(ORCSchemaUtil.ICEBERG_ID_ATTRIBUTE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0c4eb569de8e340803ae01a6e3367e8d1e37145"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTAwNjc0Nw==", "bodyText": "We could, for completeness I removed the other Iceberg attributes but definitely not needed.", "url": "https://github.com/apache/iceberg/pull/1208#discussion_r461006747", "createdAt": "2020-07-27T16:14:59Z", "author": {"login": "edgarRd"}, "path": "orc/src/main/java/org/apache/iceberg/orc/RemoveIds.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.orc;\n+\n+import java.util.List;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.orc.TypeDescription;\n+\n+class RemoveIds extends OrcSchemaVisitor<TypeDescription> {\n+\n+  @Override\n+  public TypeDescription record(TypeDescription record, List<String> names, List<TypeDescription> fields) {\n+    Preconditions.checkArgument(names.size() == fields.size(), \"All fields must have names.\");\n+    TypeDescription struct = TypeDescription.createStruct();\n+\n+    for (int i = 0; i < fields.size(); i++) {\n+      struct.addField(names.get(i), fields.get(i));\n+    }\n+    return struct;\n+  }\n+\n+  @Override\n+  public TypeDescription list(TypeDescription array, TypeDescription element) {\n+    return TypeDescription.createList(element);\n+  }\n+\n+  @Override\n+  public TypeDescription map(TypeDescription map, TypeDescription key, TypeDescription value) {\n+    return TypeDescription.createMap(key, value);\n+  }\n+\n+  @Override\n+  public TypeDescription primitive(TypeDescription primitive) {\n+    return removeIcebergAttributes(primitive.clone());\n+  }\n+\n+  private static TypeDescription removeIcebergAttributes(TypeDescription orcType) {\n+    orcType.removeAttribute(ORCSchemaUtil.ICEBERG_ID_ATTRIBUTE);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM2MTU0MQ=="}, "originalCommit": {"oid": "c0c4eb569de8e340803ae01a6e3367e8d1e37145"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3MzI3NDU2OnYy", "diffSide": "RIGHT", "path": "orc/src/main/java/org/apache/iceberg/orc/OrcIterable.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNVQwNDoxOTowMFrOG3CTBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxNjowNjoxMlrOG3pRvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM2MjUwMg==", "bodyText": "IIRC, nameMapping may not have all the fields which maybe present in the file schema. I think we need a way to prune columns which does not have an associated mapping defined. I can't say whether buildOrcProjection is handling that case or not.", "url": "https://github.com/apache/iceberg/pull/1208#discussion_r460362502", "createdAt": "2020-07-25T04:19:00Z", "author": {"login": "rdsr"}, "path": "orc/src/main/java/org/apache/iceberg/orc/OrcIterable.java", "diffHunk": "@@ -73,7 +78,15 @@\n   public CloseableIterator<T> iterator() {\n     Reader orcFileReader = ORC.newFileReader(file, config);\n     addCloseable(orcFileReader);\n-    TypeDescription readOrcSchema = ORCSchemaUtil.buildOrcProjection(schema, orcFileReader.getSchema());\n+\n+    TypeDescription fileSchema = orcFileReader.getSchema();\n+    final TypeDescription readOrcSchema;\n+    if (ORCSchemaUtil.hasIds(fileSchema)) {\n+      readOrcSchema = ORCSchemaUtil.buildOrcProjection(schema, fileSchema);\n+    } else {\n+      TypeDescription typeWithIds = ORCSchemaUtil.applyNameMapping(fileSchema, nameMapping);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0c4eb569de8e340803ae01a6e3367e8d1e37145"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM3NjEyNA==", "bodyText": "Seems like buildOrcProjection is handling it by traversing iceberg read schema to build the read projection", "url": "https://github.com/apache/iceberg/pull/1208#discussion_r460376124", "createdAt": "2020-07-25T07:18:15Z", "author": {"login": "rdsr"}, "path": "orc/src/main/java/org/apache/iceberg/orc/OrcIterable.java", "diffHunk": "@@ -73,7 +78,15 @@\n   public CloseableIterator<T> iterator() {\n     Reader orcFileReader = ORC.newFileReader(file, config);\n     addCloseable(orcFileReader);\n-    TypeDescription readOrcSchema = ORCSchemaUtil.buildOrcProjection(schema, orcFileReader.getSchema());\n+\n+    TypeDescription fileSchema = orcFileReader.getSchema();\n+    final TypeDescription readOrcSchema;\n+    if (ORCSchemaUtil.hasIds(fileSchema)) {\n+      readOrcSchema = ORCSchemaUtil.buildOrcProjection(schema, fileSchema);\n+    } else {\n+      TypeDescription typeWithIds = ORCSchemaUtil.applyNameMapping(fileSchema, nameMapping);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM2MjUwMg=="}, "originalCommit": {"oid": "c0c4eb569de8e340803ae01a6e3367e8d1e37145"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTAwMTE1MA==", "bodyText": "Yes, buildOrcProjection has the logic to skip columns without IDs, that was implemented in #1140.", "url": "https://github.com/apache/iceberg/pull/1208#discussion_r461001150", "createdAt": "2020-07-27T16:06:12Z", "author": {"login": "edgarRd"}, "path": "orc/src/main/java/org/apache/iceberg/orc/OrcIterable.java", "diffHunk": "@@ -73,7 +78,15 @@\n   public CloseableIterator<T> iterator() {\n     Reader orcFileReader = ORC.newFileReader(file, config);\n     addCloseable(orcFileReader);\n-    TypeDescription readOrcSchema = ORCSchemaUtil.buildOrcProjection(schema, orcFileReader.getSchema());\n+\n+    TypeDescription fileSchema = orcFileReader.getSchema();\n+    final TypeDescription readOrcSchema;\n+    if (ORCSchemaUtil.hasIds(fileSchema)) {\n+      readOrcSchema = ORCSchemaUtil.buildOrcProjection(schema, fileSchema);\n+    } else {\n+      TypeDescription typeWithIds = ORCSchemaUtil.applyNameMapping(fileSchema, nameMapping);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM2MjUwMg=="}, "originalCommit": {"oid": "c0c4eb569de8e340803ae01a6e3367e8d1e37145"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3MzI5MzAwOnYy", "diffSide": "RIGHT", "path": "orc/src/test/java/org/apache/iceberg/orc/TestExpressionToSearchArgument.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNVQwNDo0Njo1OVrOG3CblA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwNDoxMDoxM1rOG3732Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM2NDY5Mg==", "bodyText": "can we have a test case for where complex fields are also pruned? For instance if all fields of a struct are pruned, the struct is pruned. Similarly for maps and lists?", "url": "https://github.com/apache/iceberg/pull/1208#discussion_r460364692", "createdAt": "2020-07-25T04:46:59Z", "author": {"login": "rdsr"}, "path": "orc/src/test/java/org/apache/iceberg/orc/TestExpressionToSearchArgument.java", "diffHunk": "@@ -262,4 +264,65 @@ public void testEvolvedSchema() {\n     actual = ExpressionToSearchArgument.convert(boundFilter, readSchema);\n     Assert.assertEquals(expected.toString(), actual.toString());\n   }\n+\n+  @Test\n+  public void testOriginalSchemaNameMapping() {\n+    Schema originalSchema = new Schema(\n+        required(1, \"int\", Types.IntegerType.get()),\n+        optional(2, \"long\", Types.LongType.get())\n+    );\n+\n+    TypeDescription orcSchemaWithoutIds = ORCSchemaUtil.removeIds(ORCSchemaUtil.convert(originalSchema));\n+    NameMapping nameMapping = MappingUtil.create(originalSchema);\n+\n+    TypeDescription readSchema = ORCSchemaUtil.buildOrcProjection(originalSchema,\n+        ORCSchemaUtil.applyNameMapping(orcSchemaWithoutIds, nameMapping));\n+\n+    Expression expr = and(equal(\"int\", 1), equal(\"long\", 1));\n+    Expression boundFilter = Binder.bind(originalSchema.asStruct(), expr, true);\n+    SearchArgument expected = SearchArgumentFactory.newBuilder()\n+        .equals(\"`int`\", Type.LONG, 1L)\n+        .equals(\"`long`\", Type.LONG, 1L)\n+        .build();\n+\n+    SearchArgument actual = ExpressionToSearchArgument.convert(boundFilter, readSchema);\n+    Assert.assertEquals(expected.toString(), actual.toString());\n+  }\n+\n+  @Test\n+  public void testModifiedSchemaNameMapping() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0c4eb569de8e340803ae01a6e3367e8d1e37145"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTAwODk1MQ==", "bodyText": "I think that test is https://github.com/apache/iceberg/pull/1140/files#diff-27a14477d32c8e2921027e1353a76753R216 and does not seem related to test the name mapping as that'd test buldOrcProjection. I can definitely add those cases you mention on that test.", "url": "https://github.com/apache/iceberg/pull/1208#discussion_r461008951", "createdAt": "2020-07-27T16:18:27Z", "author": {"login": "edgarRd"}, "path": "orc/src/test/java/org/apache/iceberg/orc/TestExpressionToSearchArgument.java", "diffHunk": "@@ -262,4 +264,65 @@ public void testEvolvedSchema() {\n     actual = ExpressionToSearchArgument.convert(boundFilter, readSchema);\n     Assert.assertEquals(expected.toString(), actual.toString());\n   }\n+\n+  @Test\n+  public void testOriginalSchemaNameMapping() {\n+    Schema originalSchema = new Schema(\n+        required(1, \"int\", Types.IntegerType.get()),\n+        optional(2, \"long\", Types.LongType.get())\n+    );\n+\n+    TypeDescription orcSchemaWithoutIds = ORCSchemaUtil.removeIds(ORCSchemaUtil.convert(originalSchema));\n+    NameMapping nameMapping = MappingUtil.create(originalSchema);\n+\n+    TypeDescription readSchema = ORCSchemaUtil.buildOrcProjection(originalSchema,\n+        ORCSchemaUtil.applyNameMapping(orcSchemaWithoutIds, nameMapping));\n+\n+    Expression expr = and(equal(\"int\", 1), equal(\"long\", 1));\n+    Expression boundFilter = Binder.bind(originalSchema.asStruct(), expr, true);\n+    SearchArgument expected = SearchArgumentFactory.newBuilder()\n+        .equals(\"`int`\", Type.LONG, 1L)\n+        .equals(\"`long`\", Type.LONG, 1L)\n+        .build();\n+\n+    SearchArgument actual = ExpressionToSearchArgument.convert(boundFilter, readSchema);\n+    Assert.assertEquals(expected.toString(), actual.toString());\n+  }\n+\n+  @Test\n+  public void testModifiedSchemaNameMapping() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM2NDY5Mg=="}, "originalCommit": {"oid": "c0c4eb569de8e340803ae01a6e3367e8d1e37145"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTMwNTgxNw==", "bodyText": "I've added a couple tests to address this.", "url": "https://github.com/apache/iceberg/pull/1208#discussion_r461305817", "createdAt": "2020-07-28T04:10:13Z", "author": {"login": "edgarRd"}, "path": "orc/src/test/java/org/apache/iceberg/orc/TestExpressionToSearchArgument.java", "diffHunk": "@@ -262,4 +264,65 @@ public void testEvolvedSchema() {\n     actual = ExpressionToSearchArgument.convert(boundFilter, readSchema);\n     Assert.assertEquals(expected.toString(), actual.toString());\n   }\n+\n+  @Test\n+  public void testOriginalSchemaNameMapping() {\n+    Schema originalSchema = new Schema(\n+        required(1, \"int\", Types.IntegerType.get()),\n+        optional(2, \"long\", Types.LongType.get())\n+    );\n+\n+    TypeDescription orcSchemaWithoutIds = ORCSchemaUtil.removeIds(ORCSchemaUtil.convert(originalSchema));\n+    NameMapping nameMapping = MappingUtil.create(originalSchema);\n+\n+    TypeDescription readSchema = ORCSchemaUtil.buildOrcProjection(originalSchema,\n+        ORCSchemaUtil.applyNameMapping(orcSchemaWithoutIds, nameMapping));\n+\n+    Expression expr = and(equal(\"int\", 1), equal(\"long\", 1));\n+    Expression boundFilter = Binder.bind(originalSchema.asStruct(), expr, true);\n+    SearchArgument expected = SearchArgumentFactory.newBuilder()\n+        .equals(\"`int`\", Type.LONG, 1L)\n+        .equals(\"`long`\", Type.LONG, 1L)\n+        .build();\n+\n+    SearchArgument actual = ExpressionToSearchArgument.convert(boundFilter, readSchema);\n+    Assert.assertEquals(expected.toString(), actual.toString());\n+  }\n+\n+  @Test\n+  public void testModifiedSchemaNameMapping() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM2NDY5Mg=="}, "originalCommit": {"oid": "c0c4eb569de8e340803ae01a6e3367e8d1e37145"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyMTgwNzA2OnYy", "diffSide": "RIGHT", "path": "orc/src/test/java/org/apache/iceberg/orc/TestExpressionToSearchArgument.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQwMzoyOToyNlrOG-Ag1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQwMzoyOToyNlrOG-Ag1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY3MzMwMQ==", "bodyText": "Nit: Typo struct.long", "url": "https://github.com/apache/iceberg/pull/1208#discussion_r467673301", "createdAt": "2020-08-10T03:29:26Z", "author": {"login": "shardulm94"}, "path": "orc/src/test/java/org/apache/iceberg/orc/TestExpressionToSearchArgument.java", "diffHunk": "@@ -262,4 +264,132 @@ public void testEvolvedSchema() {\n     actual = ExpressionToSearchArgument.convert(boundFilter, readSchema);\n     Assert.assertEquals(expected.toString(), actual.toString());\n   }\n+\n+  @Test\n+  public void testOriginalSchemaNameMapping() {\n+    Schema originalSchema = new Schema(\n+        required(1, \"int\", Types.IntegerType.get()),\n+        optional(2, \"long\", Types.LongType.get())\n+    );\n+\n+    TypeDescription orcSchemaWithoutIds = ORCSchemaUtil.removeIds(ORCSchemaUtil.convert(originalSchema));\n+    NameMapping nameMapping = MappingUtil.create(originalSchema);\n+\n+    TypeDescription readSchema = ORCSchemaUtil.buildOrcProjection(originalSchema,\n+        ORCSchemaUtil.applyNameMapping(orcSchemaWithoutIds, nameMapping));\n+\n+    Expression expr = and(equal(\"int\", 1), equal(\"long\", 1));\n+    Expression boundFilter = Binder.bind(originalSchema.asStruct(), expr, true);\n+    SearchArgument expected = SearchArgumentFactory.newBuilder()\n+        .equals(\"`int`\", Type.LONG, 1L)\n+        .equals(\"`long`\", Type.LONG, 1L)\n+        .build();\n+\n+    SearchArgument actual = ExpressionToSearchArgument.convert(boundFilter, readSchema);\n+    Assert.assertEquals(expected.toString(), actual.toString());\n+  }\n+\n+  @Test\n+  public void testModifiedSimpleSchemaNameMapping() {\n+    Schema originalSchema = new Schema(\n+        required(1, \"int\", Types.IntegerType.get()),\n+        optional(2, \"long_to_be_dropped\", Types.LongType.get())\n+    );\n+    Schema mappingSchema = new Schema(\n+        required(1, \"int\", Types.IntegerType.get()),\n+        optional(3, \"new_float_field\", Types.FloatType.get())\n+    );\n+    TypeDescription orcSchemaWithoutIds = ORCSchemaUtil.removeIds(ORCSchemaUtil.convert(originalSchema));\n+    NameMapping nameMapping = MappingUtil.create(mappingSchema);\n+\n+    TypeDescription readSchema = ORCSchemaUtil.buildOrcProjection(mappingSchema,\n+        ORCSchemaUtil.applyNameMapping(orcSchemaWithoutIds, nameMapping));\n+\n+    Expression expr = equal(\"int\", 1);\n+    Expression boundFilter = Binder.bind(mappingSchema.asStruct(), expr, true);\n+    SearchArgument expected = SearchArgumentFactory.newBuilder()\n+        .equals(\"`int`\", Type.LONG, 1L)\n+        .build();\n+\n+    SearchArgument actual = ExpressionToSearchArgument.convert(boundFilter, readSchema);\n+    Assert.assertEquals(expected.toString(), actual.toString());\n+\n+    // for columns not in the file, buildOrcProjection will append field names with _r<ID>\n+    // this will be passed down to ORC, but ORC will handle such cases and return a TruthValue during evaluation\n+    expr = equal(\"new_float_field\", 1);\n+    boundFilter = Binder.bind(mappingSchema.asStruct(), expr, true);\n+    expected = SearchArgumentFactory.newBuilder()\n+        .equals(\"`new_float_field_r3`\", Type.FLOAT, 1.0)\n+        .build();\n+\n+    actual = ExpressionToSearchArgument.convert(boundFilter, readSchema);\n+    Assert.assertEquals(expected.toString(), actual.toString());\n+  }\n+\n+  @Test\n+  public void testModifiedComplexSchemaNameMapping() {\n+    Schema originalSchema = new Schema(\n+        optional(1, \"struct\", Types.StructType.of(\n+            required(2, \"long\", Types.LongType.get())\n+        )),\n+        optional(3, \"list\", Types.ListType.ofRequired(4, Types.LongType.get())),\n+        optional(5, \"map\", Types.MapType.ofRequired(6, 7, Types.LongType.get(), Types.LongType.get())),\n+        optional(8, \"listOfStruct\", Types.ListType.ofRequired(9, Types.StructType.of(\n+            required(10, \"long\", Types.LongType.get())))),\n+        optional(11, \"listOfPeople\", Types.ListType.ofRequired(12, Types.StructType.of(\n+            required(13, \"name\", Types.StringType.get()),\n+            required(14, \"birth_date\", Types.DateType.get()))))\n+    );\n+    Schema mappingSchema = new Schema(\n+        optional(1, \"struct\", Types.StructType.of(\n+            required(2, \"int\", Types.LongType.get())\n+        )),\n+        optional(3, \"list\", Types.ListType.ofRequired(4, Types.LongType.get())),\n+        optional(5, \"newMap\", Types.MapType.ofRequired(6, 7, Types.StringType.get(), Types.LongType.get())),\n+        optional(8, \"listOfStruct\", Types.ListType.ofRequired(9, Types.StructType.of(\n+            required(10, \"newLong\", Types.LongType.get())))),\n+        optional(11, \"listOfPeople\", Types.ListType.ofRequired(12, Types.StructType.of(\n+            required(13, \"name\", Types.StringType.get()),\n+            required(14, \"age\", Types.IntegerType.get()))))\n+    );\n+    TypeDescription orcSchemaWithoutIds = ORCSchemaUtil.removeIds(ORCSchemaUtil.convert(originalSchema));\n+    NameMapping nameMapping = MappingUtil.create(mappingSchema);\n+\n+    TypeDescription readSchema = ORCSchemaUtil.buildOrcProjection(mappingSchema,\n+        ORCSchemaUtil.applyNameMapping(orcSchemaWithoutIds, nameMapping));\n+\n+    Expression expr = and(\n+        and(\n+            equal(\"struct.int\", 1), and(\n+                lessThanOrEqual(\"list.element\", 5),\n+                equal(\"newMap.key\", \"country\")\n+            ),\n+            and(\n+                equal(\"listOfStruct.newLong\", 100L),\n+                notEqual(\"listOfPeople.name\", \"Bob\")\n+            )\n+\n+        ),\n+        lessThan(\"listOfPeople.age\", 30)\n+    );\n+    Expression boundFilter = Binder.bind(mappingSchema.asStruct(), expr, true);\n+    SearchArgument expected = SearchArgumentFactory.newBuilder()\n+        .startAnd()\n+        // Drops strict.long", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b74abd8cdb25a94c3033404b324e95575216b493"}, "originalPosition": 124}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3770, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}