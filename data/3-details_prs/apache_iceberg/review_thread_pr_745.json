{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY1NTA5MTcz", "number": 745, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwMDo1OTo1MFrODaW9lQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwMDo1Mjo1NlrODfA7tg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4OTY1NzgxOnYy", "diffSide": "LEFT", "path": "api/src/test/java/org/apache/iceberg/types/TestReadabilityChecks.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwMDo1OTo1MFrOFhRXmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwMDo1OTo1MFrOFhRXmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQzMTg5OA==", "bodyText": "This test is still valid when checkOrdering is true. Can you restore it?", "url": "https://github.com/apache/iceberg/pull/745#discussion_r370431898", "createdAt": "2020-01-24T00:59:50Z", "author": {"login": "rdblue"}, "path": "api/src/test/java/org/apache/iceberg/types/TestReadabilityChecks.java", "diffHunk": "@@ -331,26 +331,6 @@ public void testIncompatibleListAndPrimitive() {\n         errors.get(0).contains(\"list cannot be read as a string\"));\n   }\n \n-  @Test\n-  public void testStructWriteReordering() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b24c6f07f84716978ccca679d2ee274cee62ff0"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4OTY1OTc0OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/apache/iceberg/types/CheckCompatibility.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwMTowMToxMVrOFhRYuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwMTowMToxMVrOFhRYuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQzMjE4NA==", "bodyText": "I think this should still pass checkOrdering correctly. To fix the problem this is trying to address, I think this should add a write option to that gets passed into this.", "url": "https://github.com/apache/iceberg/pull/745#discussion_r370432184", "createdAt": "2020-01-24T01:01:11Z", "author": {"login": "rdblue"}, "path": "api/src/main/java/org/apache/iceberg/types/CheckCompatibility.java", "diffHunk": "@@ -78,7 +78,7 @@\n \n   private CheckCompatibility(Schema schema, boolean checkOrdering, boolean checkNullability) {\n     this.schema = schema;\n-    this.checkOrdering = checkOrdering;\n+    this.checkOrdering = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b24c6f07f84716978ccca679d2ee274cee62ff0"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4OTY2MDgyOnYy", "diffSide": "LEFT", "path": "spark/src/main/java/org/apache/iceberg/spark/source/PartitionKey.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwMTowMTo0OVrOFhRZUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwMTowMTo0OVrOFhRZUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQzMjMzNg==", "bodyText": "Can you add back these newlines? We try to avoid non-functional changes like this because they can cause commit conflicts.", "url": "https://github.com/apache/iceberg/pull/745#discussion_r370432336", "createdAt": "2020-01-24T01:01:49Z", "author": {"login": "rdblue"}, "path": "spark/src/main/java/org/apache/iceberg/spark/source/PartitionKey.java", "diffHunk": "@@ -48,17 +48,16 @@\n   private final Accessor<InternalRow>[] accessors;\n \n   @SuppressWarnings(\"unchecked\")\n-  PartitionKey(PartitionSpec spec) {\n+  PartitionKey(PartitionSpec spec, Schema inputSchema) {\n     this.spec = spec;\n-", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b24c6f07f84716978ccca679d2ee274cee62ff0"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4OTY2MTY3OnYy", "diffSide": "RIGHT", "path": "spark/src/main/java/org/apache/iceberg/spark/source/Writer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwMTowMjozMFrOFhRZ0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwMTowMjozMFrOFhRZ0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQzMjQ2NQ==", "bodyText": "Can we call this writeSchema or some name that indicates it is the schema of the incoming data, not necessarily the table schema?", "url": "https://github.com/apache/iceberg/pull/745#discussion_r370432465", "createdAt": "2020-01-24T01:02:30Z", "author": {"login": "rdblue"}, "path": "spark/src/main/java/org/apache/iceberg/spark/source/Writer.java", "diffHunk": "@@ -491,10 +491,10 @@ public void write(InternalRow row) throws IOException {\n         AppenderFactory<InternalRow> appenderFactory,\n         WriterFactory.OutputFileFactory fileFactory,\n         FileIO fileIo,\n-        long targetFileSize) {\n+        long targetFileSize,\n+        Schema schema) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b24c6f07f84716978ccca679d2ee274cee62ff0"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4OTY2MjA5OnYy", "diffSide": "RIGHT", "path": "spark/src/test/java/org/apache/iceberg/spark/source/TestPartitionValues.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwMTowMjo1MlrOFhRaHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwMTowMjo1MlrOFhRaHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQzMjU0MQ==", "bodyText": "We should be able to remove this TODO.", "url": "https://github.com/apache/iceberg/pull/745#discussion_r370432541", "createdAt": "2020-01-24T01:02:52Z", "author": {"login": "rdblue"}, "path": "spark/src/test/java/org/apache/iceberg/spark/source/TestPartitionValues.java", "diffHunk": "@@ -132,7 +132,7 @@ public void testNullPartitionValue() throws Exception {\n \n     try {\n       // TODO: incoming columns must be ordered according to the table's schema", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b24c6f07f84716978ccca679d2ee274cee62ff0"}, "originalPosition": 3}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMTM5MjM0OnYy", "diffSide": "RIGHT", "path": "spark/src/main/java/org/apache/iceberg/spark/source/IcebergSource.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQwNzo0MjowN1rOFi_CUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQwNzo0MjowN1rOFi_CUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjIyODY4OA==", "bodyText": "@ravichinoy checkOrdering needs to be passed here as well. You should be able to turn off both the nullability and ordering checks.", "url": "https://github.com/apache/iceberg/pull/745#discussion_r372228688", "createdAt": "2020-01-29T07:42:07Z", "author": {"login": "davrmac"}, "path": "spark/src/main/java/org/apache/iceberg/spark/source/IcebergSource.java", "diffHunk": "@@ -189,10 +189,11 @@ private static void mergeIcebergHadoopConfs(\n         .forEach(key -> baseConf.set(key.replaceFirst(\"hadoop.\", \"\"), options.get(key)));\n   }\n \n-  private void validateWriteSchema(Schema tableSchema, Schema dsSchema, Boolean checkNullability) {\n+  private void validateWriteSchema(\n+          Schema tableSchema, Schema dsSchema, Boolean checkNullability, Boolean checkOrdering) {\n     List<String> errors;\n     if (checkNullability) {\n-      errors = CheckCompatibility.writeCompatibilityErrors(tableSchema, dsSchema);\n+      errors = CheckCompatibility.writeCompatibilityErrors(tableSchema, dsSchema, checkOrdering);\n     } else {\n       errors = CheckCompatibility.typeCompatibilityErrors(tableSchema, dsSchema);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a25c9b7351e9954c280aadbcfdad31e385954a1"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzODQ2NzA4OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/apache/iceberg/types/CheckCompatibility.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwMDo0NzowNFrOFoeX8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwMDo0NzowNFrOFoeX8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk4NTAxMA==", "bodyText": "Why is this a boxed boolean?", "url": "https://github.com/apache/iceberg/pull/745#discussion_r377985010", "createdAt": "2020-02-12T00:47:04Z", "author": {"login": "rdblue"}, "path": "api/src/main/java/org/apache/iceberg/types/CheckCompatibility.java", "diffHunk": "@@ -39,7 +39,36 @@\n    * @return a list of error details, or an empty list if there are no compatibility problems\n    */\n   public static List<String> writeCompatibilityErrors(Schema readSchema, Schema writeSchema) {\n-    return TypeUtil.visit(readSchema, new CheckCompatibility(writeSchema, true, true));\n+    return writeCompatibilityErrors(readSchema, writeSchema, true);\n+  }\n+\n+  /**\n+   * Returns a list of compatibility errors for writing with the given write schema.\n+   * This includes nullability: writing optional (nullable) values to a required field is an error\n+   * Optionally this method allows case where input schema has different ordering than table schema.\n+   * @param readSchema a read schema\n+   * @param writeSchema a write schema\n+   * @param checkOrdering If false, allow input schema to have different ordering than table schema\n+   * @return a list of error details, or an empty list if there are no compatibility problems\n+   */\n+  public static List<String> writeCompatibilityErrors(Schema readSchema, Schema writeSchema, Boolean checkOrdering) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28c529715f6a841c784fe98e4f8db33c5b0e1c34"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzODQ3NzM0OnYy", "diffSide": "RIGHT", "path": "spark/src/main/java/org/apache/iceberg/spark/source/IcebergSource.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwMDo1Mjo1NlrOFoeeDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwMDo1Mjo1NlrOFoeeDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk4NjU3Mw==", "bodyText": "It looks like this is getting too complicated. We now have 2 boolean options, one of which is used to select the compatibility checking method (which have similar names) and the other is passed as an arg (which isn't readable). I think it is a good idea to convert compatibility checking to a builder-like pattern:\nCheckCompatibility\n    .writeSchema(dsSchema)\n    .readSchema(tableSchema)\n    .checkOrdering(true)\n    .checkNullability(false)\n    .throwOnValidationError();", "url": "https://github.com/apache/iceberg/pull/745#discussion_r377986573", "createdAt": "2020-02-12T00:52:56Z", "author": {"login": "rdblue"}, "path": "spark/src/main/java/org/apache/iceberg/spark/source/IcebergSource.java", "diffHunk": "@@ -189,12 +189,13 @@ private static void mergeIcebergHadoopConfs(\n         .forEach(key -> baseConf.set(key.replaceFirst(\"hadoop.\", \"\"), options.get(key)));\n   }\n \n-  private void validateWriteSchema(Schema tableSchema, Schema dsSchema, Boolean checkNullability) {\n+  private void validateWriteSchema(\n+          Schema tableSchema, Schema dsSchema, Boolean checkNullability, Boolean checkOrdering) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28c529715f6a841c784fe98e4f8db33c5b0e1c34"}, "originalPosition": 24}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2990, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}