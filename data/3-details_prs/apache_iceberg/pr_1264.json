{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU4MDA2NTY4", "number": 1264, "title": "Expire snapshots action", "bodyText": "WIP I'll update this and the commit messages when the underlying PR's are merged", "createdAt": "2020-07-28T19:30:43Z", "url": "https://github.com/apache/iceberg/pull/1264", "merged": true, "mergeCommit": {"oid": "cf3be0a0bfdafd2147999127ee349dcd1becc95f"}, "closed": true, "closedAt": "2020-08-11T00:47:03Z", "author": {"login": "RussellSpitzer"}, "timelineItems": {"totalCount": 45, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc791GEgH2gAyNDU4MDA2NTY4Ojg5NmM2Y2Y0YWQzNGZhMjczMjg3ZDA5M2NlYmUxODlmZGViNGMyN2I=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc9r2TxAFqTQ2NDY3NTkwMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "896c6cf4ad34fa273287d093cebe189fdeb4c27b", "author": {"user": {"login": "RussellSpitzer", "name": "Russell Spitzer"}}, "url": "https://github.com/apache/iceberg/commit/896c6cf4ad34fa273287d093cebe189fdeb4c27b", "committedDate": "2020-08-05T16:29:49Z", "message": "Expire Snapshots Spark Action\n\nPreviously ther only way to expire snapshots was through a single machine table\noperation with RemoveSnapshots. In this patch we add a new Spark Action which\ndoes the same work, but does so in a scalable way. Instead of using the old\nlogic for analyzing files to remove, we use the Metadata Table representations\nof the table both before and after Snapshot Expiration to determine un-needed\nfiles."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6ae991b1b218ba99d5ef6bf1a8fc80803566bc16", "author": {"user": {"login": "RussellSpitzer", "name": "Russell Spitzer"}}, "url": "https://github.com/apache/iceberg/commit/6ae991b1b218ba99d5ef6bf1a8fc80803566bc16", "committedDate": "2020-07-28T19:30:05Z", "message": "Expire Snapshot Spark Action\n\nWIP"}, "afterCommit": {"oid": "896c6cf4ad34fa273287d093cebe189fdeb4c27b", "author": {"user": {"login": "RussellSpitzer", "name": "Russell Spitzer"}}, "url": "https://github.com/apache/iceberg/commit/896c6cf4ad34fa273287d093cebe189fdeb4c27b", "committedDate": "2020-08-05T16:29:49Z", "message": "Expire Snapshots Spark Action\n\nPreviously ther only way to expire snapshots was through a single machine table\noperation with RemoveSnapshots. In this patch we add a new Spark Action which\ndoes the same work, but does so in a scalable way. Instead of using the old\nlogic for analyzing files to remove, we use the Metadata Table representations\nof the table both before and after Snapshot Expiration to determine un-needed\nfiles."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxOTExMDEx", "url": "https://github.com/apache/iceberg/pull/1264#pullrequestreview-461911011", "createdAt": "2020-08-05T18:17:18Z", "commit": {"oid": "896c6cf4ad34fa273287d093cebe189fdeb4c27b"}, "state": "COMMENTED", "comments": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxODoxNzoxOFrOG8VNAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxOTo0Nzo1NFrOG8YJ-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkxNTEzOQ==", "bodyText": "nit: do we need this extra variable? My IDE always highlights such cases.", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r465915139", "createdAt": "2020-08-05T18:17:18Z", "author": {"login": "aokolnychyi"}, "path": "spark/src/main/java/org/apache/iceberg/actions/BaseAction.java", "diffHunk": "@@ -41,4 +51,59 @@ protected String metadataTableName(MetadataTableType type) {\n       return tableName + \".\" + type;\n     }\n   }\n+\n+  protected Dataset<Row> buildValidDataFileDF(SparkSession spark) {\n+    String allDataFilesMetadataTable = metadataTableName(MetadataTableType.ALL_DATA_FILES);\n+    return spark.read().format(\"iceberg\")\n+        .load(allDataFilesMetadataTable)\n+        .select(\"file_path\");\n+  }\n+\n+  protected Dataset<Row> buildManifestFileDF(SparkSession spark) {\n+    String allManifestsMetadataTable = metadataTableName(MetadataTableType.ALL_MANIFESTS);\n+    Dataset<Row> manifestDF = spark.read().format(\"iceberg\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "896c6cf4ad34fa273287d093cebe189fdeb4c27b"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkzODA4Mg==", "bodyText": "nit: same here", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r465938082", "createdAt": "2020-08-05T18:59:04Z", "author": {"login": "aokolnychyi"}, "path": "spark/src/main/java/org/apache/iceberg/actions/BaseAction.java", "diffHunk": "@@ -41,4 +51,59 @@ protected String metadataTableName(MetadataTableType type) {\n       return tableName + \".\" + type;\n     }\n   }\n+\n+  protected Dataset<Row> buildValidDataFileDF(SparkSession spark) {\n+    String allDataFilesMetadataTable = metadataTableName(MetadataTableType.ALL_DATA_FILES);\n+    return spark.read().format(\"iceberg\")\n+        .load(allDataFilesMetadataTable)\n+        .select(\"file_path\");\n+  }\n+\n+  protected Dataset<Row> buildManifestFileDF(SparkSession spark) {\n+    String allManifestsMetadataTable = metadataTableName(MetadataTableType.ALL_MANIFESTS);\n+    Dataset<Row> manifestDF = spark.read().format(\"iceberg\")\n+        .load(allManifestsMetadataTable)\n+        .selectExpr(\"path as file_path\");\n+    return manifestDF;\n+  }\n+\n+  protected Dataset<Row> buildManifestListDF(SparkSession spark, Table table) {\n+    List<String> manifestLists = Lists.newArrayList();\n+\n+    for (Snapshot snapshot : table.snapshots()) {\n+      String manifestListLocation = snapshot.manifestListLocation();\n+      if (manifestListLocation != null) {\n+        manifestLists.add(manifestListLocation);\n+      }\n+    }\n+\n+    Dataset<Row> manifestListDF = spark", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "896c6cf4ad34fa273287d093cebe189fdeb4c27b"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkzODE5Mg==", "bodyText": "nit: same here", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r465938192", "createdAt": "2020-08-05T18:59:13Z", "author": {"login": "aokolnychyi"}, "path": "spark/src/main/java/org/apache/iceberg/actions/BaseAction.java", "diffHunk": "@@ -41,4 +51,59 @@ protected String metadataTableName(MetadataTableType type) {\n       return tableName + \".\" + type;\n     }\n   }\n+\n+  protected Dataset<Row> buildValidDataFileDF(SparkSession spark) {\n+    String allDataFilesMetadataTable = metadataTableName(MetadataTableType.ALL_DATA_FILES);\n+    return spark.read().format(\"iceberg\")\n+        .load(allDataFilesMetadataTable)\n+        .select(\"file_path\");\n+  }\n+\n+  protected Dataset<Row> buildManifestFileDF(SparkSession spark) {\n+    String allManifestsMetadataTable = metadataTableName(MetadataTableType.ALL_MANIFESTS);\n+    Dataset<Row> manifestDF = spark.read().format(\"iceberg\")\n+        .load(allManifestsMetadataTable)\n+        .selectExpr(\"path as file_path\");\n+    return manifestDF;\n+  }\n+\n+  protected Dataset<Row> buildManifestListDF(SparkSession spark, Table table) {\n+    List<String> manifestLists = Lists.newArrayList();\n+\n+    for (Snapshot snapshot : table.snapshots()) {\n+      String manifestListLocation = snapshot.manifestListLocation();\n+      if (manifestListLocation != null) {\n+        manifestLists.add(manifestListLocation);\n+      }\n+    }\n+\n+    Dataset<Row> manifestListDF = spark\n+        .createDataset(manifestLists, Encoders.STRING())\n+        .toDF(\"file_path\");\n+\n+    return manifestListDF;\n+  }\n+\n+  protected Dataset<Row> buildOtherMetadataFileDF(SparkSession spark, TableOperations ops) {\n+    List<String> otherMetadataFiles = Lists.newArrayList();\n+    otherMetadataFiles.add(ops.metadataFileLocation(\"version-hint.text\"));\n+    TableMetadata metadata = ops.current();\n+    otherMetadataFiles.add(metadata.metadataFileLocation());\n+    for (TableMetadata.MetadataLogEntry previousMetadataFile : metadata.previousFiles()) {\n+      otherMetadataFiles.add(previousMetadataFile.file());\n+    }\n+\n+    Dataset<Row> otherMetadataFileDF = spark\n+        .createDataset(otherMetadataFiles, Encoders.STRING())\n+        .toDF(\"file_path\");\n+    return otherMetadataFileDF;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "896c6cf4ad34fa273287d093cebe189fdeb4c27b"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk0MTI3OQ==", "bodyText": "Looks like we don't need this var anymore.", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r465941279", "createdAt": "2020-08-05T19:04:55Z", "author": {"login": "aokolnychyi"}, "path": "spark/src/main/java/org/apache/iceberg/actions/ExpireSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import org.apache.iceberg.ExpireSnapshots;\n+import org.apache.iceberg.HasTableOperations;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.exceptions.NotFoundException;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.util.Tasks;\n+import org.apache.iceberg.util.ThreadPools;\n+import org.apache.spark.api.java.JavaSparkContext;\n+import org.apache.spark.sql.Column;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SparkSession;\n+import org.apache.spark.sql.functions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ExpireSnapshotsAction extends BaseAction<ExpireSnapshotActionResult> {\n+  private static final Logger LOG = LoggerFactory.getLogger(ExpireSnapshotsAction.class);\n+\n+  private final SparkSession spark;\n+  private final JavaSparkContext sparkContext;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "896c6cf4ad34fa273287d093cebe189fdeb4c27b"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk0MTUzMw==", "bodyText": "Looks like we can remove this one as well.", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r465941533", "createdAt": "2020-08-05T19:05:25Z", "author": {"login": "aokolnychyi"}, "path": "spark/src/main/java/org/apache/iceberg/actions/ExpireSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import org.apache.iceberg.ExpireSnapshots;\n+import org.apache.iceberg.HasTableOperations;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.exceptions.NotFoundException;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.util.Tasks;\n+import org.apache.iceberg.util.ThreadPools;\n+import org.apache.spark.api.java.JavaSparkContext;\n+import org.apache.spark.sql.Column;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SparkSession;\n+import org.apache.spark.sql.functions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ExpireSnapshotsAction extends BaseAction<ExpireSnapshotActionResult> {\n+  private static final Logger LOG = LoggerFactory.getLogger(ExpireSnapshotsAction.class);\n+\n+  private final SparkSession spark;\n+  private final JavaSparkContext sparkContext;\n+  private final Table table;\n+  private final TableOperations ops;\n+  private final ExpireSnapshots localExpireSnapshots;\n+  private final TableMetadata base;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "896c6cf4ad34fa273287d093cebe189fdeb4c27b"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk0NTAxMg==", "bodyText": "I think it should be Snapshots instead of Snapshot to be consistent with the action name.", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r465945012", "createdAt": "2020-08-05T19:12:07Z", "author": {"login": "aokolnychyi"}, "path": "spark/src/main/java/org/apache/iceberg/actions/ExpireSnapshotActionResult.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+public class ExpireSnapshotActionResult {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "896c6cf4ad34fa273287d093cebe189fdeb4c27b"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk0NjIxMA==", "bodyText": "Let's move static constants above instance variables.", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r465946210", "createdAt": "2020-08-05T19:14:25Z", "author": {"login": "aokolnychyi"}, "path": "spark/src/main/java/org/apache/iceberg/actions/ExpireSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import org.apache.iceberg.ExpireSnapshots;\n+import org.apache.iceberg.HasTableOperations;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.exceptions.NotFoundException;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.util.Tasks;\n+import org.apache.iceberg.util.ThreadPools;\n+import org.apache.spark.api.java.JavaSparkContext;\n+import org.apache.spark.sql.Column;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SparkSession;\n+import org.apache.spark.sql.functions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ExpireSnapshotsAction extends BaseAction<ExpireSnapshotActionResult> {\n+  private static final Logger LOG = LoggerFactory.getLogger(ExpireSnapshotsAction.class);\n+\n+  private final SparkSession spark;\n+  private final JavaSparkContext sparkContext;\n+  private final Table table;\n+  private final TableOperations ops;\n+  private final ExpireSnapshots localExpireSnapshots;\n+  private final TableMetadata base;\n+  private static final String DATAFILE = \"Data File\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "896c6cf4ad34fa273287d093cebe189fdeb4c27b"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk0NzIzNw==", "bodyText": "Let's add one empty line before and after adding version hint to have some logical grouping.", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r465947237", "createdAt": "2020-08-05T19:16:15Z", "author": {"login": "aokolnychyi"}, "path": "spark/src/main/java/org/apache/iceberg/actions/BaseAction.java", "diffHunk": "@@ -41,4 +51,59 @@ protected String metadataTableName(MetadataTableType type) {\n       return tableName + \".\" + type;\n     }\n   }\n+\n+  protected Dataset<Row> buildValidDataFileDF(SparkSession spark) {\n+    String allDataFilesMetadataTable = metadataTableName(MetadataTableType.ALL_DATA_FILES);\n+    return spark.read().format(\"iceberg\")\n+        .load(allDataFilesMetadataTable)\n+        .select(\"file_path\");\n+  }\n+\n+  protected Dataset<Row> buildManifestFileDF(SparkSession spark) {\n+    String allManifestsMetadataTable = metadataTableName(MetadataTableType.ALL_MANIFESTS);\n+    Dataset<Row> manifestDF = spark.read().format(\"iceberg\")\n+        .load(allManifestsMetadataTable)\n+        .selectExpr(\"path as file_path\");\n+    return manifestDF;\n+  }\n+\n+  protected Dataset<Row> buildManifestListDF(SparkSession spark, Table table) {\n+    List<String> manifestLists = Lists.newArrayList();\n+\n+    for (Snapshot snapshot : table.snapshots()) {\n+      String manifestListLocation = snapshot.manifestListLocation();\n+      if (manifestListLocation != null) {\n+        manifestLists.add(manifestListLocation);\n+      }\n+    }\n+\n+    Dataset<Row> manifestListDF = spark\n+        .createDataset(manifestLists, Encoders.STRING())\n+        .toDF(\"file_path\");\n+\n+    return manifestListDF;\n+  }\n+\n+  protected Dataset<Row> buildOtherMetadataFileDF(SparkSession spark, TableOperations ops) {\n+    List<String> otherMetadataFiles = Lists.newArrayList();\n+    otherMetadataFiles.add(ops.metadataFileLocation(\"version-hint.text\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "896c6cf4ad34fa273287d093cebe189fdeb4c27b"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk0ODI0OQ==", "bodyText": "nit: let's keep only 1 empty line, no need for 2.", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r465948249", "createdAt": "2020-08-05T19:18:08Z", "author": {"login": "aokolnychyi"}, "path": "spark/src/main/java/org/apache/iceberg/actions/ExpireSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import org.apache.iceberg.ExpireSnapshots;\n+import org.apache.iceberg.HasTableOperations;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.exceptions.NotFoundException;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.util.Tasks;\n+import org.apache.iceberg.util.ThreadPools;\n+import org.apache.spark.api.java.JavaSparkContext;\n+import org.apache.spark.sql.Column;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SparkSession;\n+import org.apache.spark.sql.functions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ExpireSnapshotsAction extends BaseAction<ExpireSnapshotActionResult> {\n+  private static final Logger LOG = LoggerFactory.getLogger(ExpireSnapshotsAction.class);\n+\n+  private final SparkSession spark;\n+  private final JavaSparkContext sparkContext;\n+  private final Table table;\n+  private final TableOperations ops;\n+  private final ExpireSnapshots localExpireSnapshots;\n+  private final TableMetadata base;\n+  private static final String DATAFILE = \"Data File\";\n+  private static final String MANIFEST = \"Manifest\";\n+  private static final String MANIFESTLIST = \"Manifest List\";\n+  private static final String OTHER = \"Other\";\n+\n+  private final Consumer<String> defaultDelete = new Consumer<String>() {\n+    @Override\n+    public void accept(String file) {\n+      ops.io().deleteFile(file);\n+    }\n+  };\n+  private Consumer<String> deleteFunc = defaultDelete;\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "896c6cf4ad34fa273287d093cebe189fdeb4c27b"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk0ODUyMw==", "bodyText": "nit: extra line here", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r465948523", "createdAt": "2020-08-05T19:18:41Z", "author": {"login": "aokolnychyi"}, "path": "spark/src/main/java/org/apache/iceberg/actions/ExpireSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import org.apache.iceberg.ExpireSnapshots;\n+import org.apache.iceberg.HasTableOperations;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.exceptions.NotFoundException;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.util.Tasks;\n+import org.apache.iceberg.util.ThreadPools;\n+import org.apache.spark.api.java.JavaSparkContext;\n+import org.apache.spark.sql.Column;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SparkSession;\n+import org.apache.spark.sql.functions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ExpireSnapshotsAction extends BaseAction<ExpireSnapshotActionResult> {\n+  private static final Logger LOG = LoggerFactory.getLogger(ExpireSnapshotsAction.class);\n+\n+  private final SparkSession spark;\n+  private final JavaSparkContext sparkContext;\n+  private final Table table;\n+  private final TableOperations ops;\n+  private final ExpireSnapshots localExpireSnapshots;\n+  private final TableMetadata base;\n+  private static final String DATAFILE = \"Data File\";\n+  private static final String MANIFEST = \"Manifest\";\n+  private static final String MANIFESTLIST = \"Manifest List\";\n+  private static final String OTHER = \"Other\";\n+\n+  private final Consumer<String> defaultDelete = new Consumer<String>() {\n+    @Override\n+    public void accept(String file) {\n+      ops.io().deleteFile(file);\n+    }\n+  };\n+  private Consumer<String> deleteFunc = defaultDelete;\n+\n+\n+  ExpireSnapshotsAction(SparkSession spark, Table table) {\n+    this.spark = spark;\n+    this.sparkContext = JavaSparkContext.fromSparkContext(spark.sparkContext());\n+    this.table = table;\n+    this.ops = ((HasTableOperations) table).operations();\n+    this.base = ops.current();\n+    this.localExpireSnapshots = table.expireSnapshots().cleanExpiredFiles(false);\n+  }\n+\n+  public ExpireSnapshotsAction expireSnapshotId(long expireSnapshotId) {\n+    localExpireSnapshots.expireSnapshotId(expireSnapshotId);\n+    return this;\n+  }\n+\n+  public ExpireSnapshotsAction expireOlderThan(long timestampMillis) {\n+    localExpireSnapshots.expireOlderThan(timestampMillis);\n+    return this;\n+  }\n+\n+  public ExpireSnapshotsAction retainLast(int numSnapshots) {\n+    localExpireSnapshots.retainLast(numSnapshots);\n+    return this;\n+  }\n+\n+  public ExpireSnapshotsAction deleteWith(Consumer<String> newDeleteFunc) {\n+    deleteFunc = newDeleteFunc;\n+    return this;\n+  }\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "896c6cf4ad34fa273287d093cebe189fdeb4c27b"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk0OTI2MQ==", "bodyText": "Why DataFile and not file_type?", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r465949261", "createdAt": "2020-08-05T19:20:07Z", "author": {"login": "aokolnychyi"}, "path": "spark/src/main/java/org/apache/iceberg/actions/ExpireSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import org.apache.iceberg.ExpireSnapshots;\n+import org.apache.iceberg.HasTableOperations;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.exceptions.NotFoundException;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.util.Tasks;\n+import org.apache.iceberg.util.ThreadPools;\n+import org.apache.spark.api.java.JavaSparkContext;\n+import org.apache.spark.sql.Column;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SparkSession;\n+import org.apache.spark.sql.functions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ExpireSnapshotsAction extends BaseAction<ExpireSnapshotActionResult> {\n+  private static final Logger LOG = LoggerFactory.getLogger(ExpireSnapshotsAction.class);\n+\n+  private final SparkSession spark;\n+  private final JavaSparkContext sparkContext;\n+  private final Table table;\n+  private final TableOperations ops;\n+  private final ExpireSnapshots localExpireSnapshots;\n+  private final TableMetadata base;\n+  private static final String DATAFILE = \"Data File\";\n+  private static final String MANIFEST = \"Manifest\";\n+  private static final String MANIFESTLIST = \"Manifest List\";\n+  private static final String OTHER = \"Other\";\n+\n+  private final Consumer<String> defaultDelete = new Consumer<String>() {\n+    @Override\n+    public void accept(String file) {\n+      ops.io().deleteFile(file);\n+    }\n+  };\n+  private Consumer<String> deleteFunc = defaultDelete;\n+\n+\n+  ExpireSnapshotsAction(SparkSession spark, Table table) {\n+    this.spark = spark;\n+    this.sparkContext = JavaSparkContext.fromSparkContext(spark.sparkContext());\n+    this.table = table;\n+    this.ops = ((HasTableOperations) table).operations();\n+    this.base = ops.current();\n+    this.localExpireSnapshots = table.expireSnapshots().cleanExpiredFiles(false);\n+  }\n+\n+  public ExpireSnapshotsAction expireSnapshotId(long expireSnapshotId) {\n+    localExpireSnapshots.expireSnapshotId(expireSnapshotId);\n+    return this;\n+  }\n+\n+  public ExpireSnapshotsAction expireOlderThan(long timestampMillis) {\n+    localExpireSnapshots.expireOlderThan(timestampMillis);\n+    return this;\n+  }\n+\n+  public ExpireSnapshotsAction retainLast(int numSnapshots) {\n+    localExpireSnapshots.retainLast(numSnapshots);\n+    return this;\n+  }\n+\n+  public ExpireSnapshotsAction deleteWith(Consumer<String> newDeleteFunc) {\n+    deleteFunc = newDeleteFunc;\n+    return this;\n+  }\n+\n+\n+  @Override\n+  protected Table table() {\n+    return table;\n+  }\n+\n+  private Dataset<Row> appendTypeString(Dataset<Row> ds, String type) {\n+    return ds.select(new Column(\"file_path\"), functions.lit(type).as(\"DataFile\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "896c6cf4ad34fa273287d093cebe189fdeb4c27b"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk0OTc2NQ==", "bodyText": "It would also more natural to have underscores to separate words.\nFor example, DATA_FILE and MANIFEST_LIST.", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r465949765", "createdAt": "2020-08-05T19:21:07Z", "author": {"login": "aokolnychyi"}, "path": "spark/src/main/java/org/apache/iceberg/actions/ExpireSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import org.apache.iceberg.ExpireSnapshots;\n+import org.apache.iceberg.HasTableOperations;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.exceptions.NotFoundException;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.util.Tasks;\n+import org.apache.iceberg.util.ThreadPools;\n+import org.apache.spark.api.java.JavaSparkContext;\n+import org.apache.spark.sql.Column;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SparkSession;\n+import org.apache.spark.sql.functions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ExpireSnapshotsAction extends BaseAction<ExpireSnapshotActionResult> {\n+  private static final Logger LOG = LoggerFactory.getLogger(ExpireSnapshotsAction.class);\n+\n+  private final SparkSession spark;\n+  private final JavaSparkContext sparkContext;\n+  private final Table table;\n+  private final TableOperations ops;\n+  private final ExpireSnapshots localExpireSnapshots;\n+  private final TableMetadata base;\n+  private static final String DATAFILE = \"Data File\";\n+  private static final String MANIFEST = \"Manifest\";\n+  private static final String MANIFESTLIST = \"Manifest List\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "896c6cf4ad34fa273287d093cebe189fdeb4c27b"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk1NjI2MA==", "bodyText": "nit: all other actions define overridden methods after the constructor, then public methods to configure the action, then public execute, then private methods. I think it makes to follow that here too.", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r465956260", "createdAt": "2020-08-05T19:34:00Z", "author": {"login": "aokolnychyi"}, "path": "spark/src/main/java/org/apache/iceberg/actions/ExpireSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import org.apache.iceberg.ExpireSnapshots;\n+import org.apache.iceberg.HasTableOperations;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.exceptions.NotFoundException;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.util.Tasks;\n+import org.apache.iceberg.util.ThreadPools;\n+import org.apache.spark.api.java.JavaSparkContext;\n+import org.apache.spark.sql.Column;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SparkSession;\n+import org.apache.spark.sql.functions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ExpireSnapshotsAction extends BaseAction<ExpireSnapshotActionResult> {\n+  private static final Logger LOG = LoggerFactory.getLogger(ExpireSnapshotsAction.class);\n+\n+  private final SparkSession spark;\n+  private final JavaSparkContext sparkContext;\n+  private final Table table;\n+  private final TableOperations ops;\n+  private final ExpireSnapshots localExpireSnapshots;\n+  private final TableMetadata base;\n+  private static final String DATAFILE = \"Data File\";\n+  private static final String MANIFEST = \"Manifest\";\n+  private static final String MANIFESTLIST = \"Manifest List\";\n+  private static final String OTHER = \"Other\";\n+\n+  private final Consumer<String> defaultDelete = new Consumer<String>() {\n+    @Override\n+    public void accept(String file) {\n+      ops.io().deleteFile(file);\n+    }\n+  };\n+  private Consumer<String> deleteFunc = defaultDelete;\n+\n+\n+  ExpireSnapshotsAction(SparkSession spark, Table table) {\n+    this.spark = spark;\n+    this.sparkContext = JavaSparkContext.fromSparkContext(spark.sparkContext());\n+    this.table = table;\n+    this.ops = ((HasTableOperations) table).operations();\n+    this.base = ops.current();\n+    this.localExpireSnapshots = table.expireSnapshots().cleanExpiredFiles(false);\n+  }\n+\n+  public ExpireSnapshotsAction expireSnapshotId(long expireSnapshotId) {\n+    localExpireSnapshots.expireSnapshotId(expireSnapshotId);\n+    return this;\n+  }\n+\n+  public ExpireSnapshotsAction expireOlderThan(long timestampMillis) {\n+    localExpireSnapshots.expireOlderThan(timestampMillis);\n+    return this;\n+  }\n+\n+  public ExpireSnapshotsAction retainLast(int numSnapshots) {\n+    localExpireSnapshots.retainLast(numSnapshots);\n+    return this;\n+  }\n+\n+  public ExpireSnapshotsAction deleteWith(Consumer<String> newDeleteFunc) {\n+    deleteFunc = newDeleteFunc;\n+    return this;\n+  }\n+\n+\n+  @Override\n+  protected Table table() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "896c6cf4ad34fa273287d093cebe189fdeb4c27b"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk2MjU2MQ==", "bodyText": "I think we have to match the behavior in ExpireSnapshots where the executor service is optional. I am not sure on the best name for the method, though.", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r465962561", "createdAt": "2020-08-05T19:46:04Z", "author": {"login": "aokolnychyi"}, "path": "spark/src/main/java/org/apache/iceberg/actions/ExpireSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import org.apache.iceberg.ExpireSnapshots;\n+import org.apache.iceberg.HasTableOperations;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.exceptions.NotFoundException;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.util.Tasks;\n+import org.apache.iceberg.util.ThreadPools;\n+import org.apache.spark.api.java.JavaSparkContext;\n+import org.apache.spark.sql.Column;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SparkSession;\n+import org.apache.spark.sql.functions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ExpireSnapshotsAction extends BaseAction<ExpireSnapshotActionResult> {\n+  private static final Logger LOG = LoggerFactory.getLogger(ExpireSnapshotsAction.class);\n+\n+  private final SparkSession spark;\n+  private final JavaSparkContext sparkContext;\n+  private final Table table;\n+  private final TableOperations ops;\n+  private final ExpireSnapshots localExpireSnapshots;\n+  private final TableMetadata base;\n+  private static final String DATAFILE = \"Data File\";\n+  private static final String MANIFEST = \"Manifest\";\n+  private static final String MANIFESTLIST = \"Manifest List\";\n+  private static final String OTHER = \"Other\";\n+\n+  private final Consumer<String> defaultDelete = new Consumer<String>() {\n+    @Override\n+    public void accept(String file) {\n+      ops.io().deleteFile(file);\n+    }\n+  };\n+  private Consumer<String> deleteFunc = defaultDelete;\n+\n+\n+  ExpireSnapshotsAction(SparkSession spark, Table table) {\n+    this.spark = spark;\n+    this.sparkContext = JavaSparkContext.fromSparkContext(spark.sparkContext());\n+    this.table = table;\n+    this.ops = ((HasTableOperations) table).operations();\n+    this.base = ops.current();\n+    this.localExpireSnapshots = table.expireSnapshots().cleanExpiredFiles(false);\n+  }\n+\n+  public ExpireSnapshotsAction expireSnapshotId(long expireSnapshotId) {\n+    localExpireSnapshots.expireSnapshotId(expireSnapshotId);\n+    return this;\n+  }\n+\n+  public ExpireSnapshotsAction expireOlderThan(long timestampMillis) {\n+    localExpireSnapshots.expireOlderThan(timestampMillis);\n+    return this;\n+  }\n+\n+  public ExpireSnapshotsAction retainLast(int numSnapshots) {\n+    localExpireSnapshots.retainLast(numSnapshots);\n+    return this;\n+  }\n+\n+  public ExpireSnapshotsAction deleteWith(Consumer<String> newDeleteFunc) {\n+    deleteFunc = newDeleteFunc;\n+    return this;\n+  }\n+\n+\n+  @Override\n+  protected Table table() {\n+    return table;\n+  }\n+\n+  private Dataset<Row> appendTypeString(Dataset<Row> ds, String type) {\n+    return ds.select(new Column(\"file_path\"), functions.lit(type).as(\"DataFile\"));\n+  }\n+\n+  private Dataset<Row> getValidFileDF() {\n+    return appendTypeString(buildValidDataFileDF(spark), DATAFILE)\n+        .union(appendTypeString(buildManifestFileDF(spark), MANIFEST))\n+        .union(appendTypeString(buildManifestListDF(spark, table), MANIFESTLIST))\n+        .union(appendTypeString(buildOtherMetadataFileDF(spark, ops), OTHER));\n+  }\n+\n+  private Set<String> getFilesOfType(List<Row> files, String type) {\n+    return files.stream()\n+        .filter(row -> row.getString(1).equals(type))\n+        .map(row -> row.getString(0))\n+        .collect(Collectors.toSet());\n+  }\n+\n+  @Override\n+  public ExpireSnapshotActionResult execute() {\n+\n+    Dataset<Row> originalFiles = getValidFileDF().persist();\n+    originalFiles.count(); // Trigger Persist\n+\n+    localExpireSnapshots.commit();\n+\n+    Dataset<Row> validFiles = getValidFileDF();\n+\n+    List<Row> filesToDelete = originalFiles.except(validFiles).collectAsList();\n+\n+    LOG.warn(\"Deleting {} files\", filesToDelete.size());\n+    return new ExpireSnapshotActionResult(\n+        deleteFiles(getFilesOfType(filesToDelete, DATAFILE), DATAFILE),\n+        deleteFiles(getFilesOfType(filesToDelete, MANIFEST), MANIFEST),\n+        deleteFiles(getFilesOfType(filesToDelete, MANIFESTLIST), MANIFESTLIST),\n+        deleteFiles(getFilesOfType(filesToDelete, OTHER), OTHER));\n+  }\n+\n+  private Long deleteFiles(Set<String> paths, String fileType) {\n+    LOG.warn(\"{}s to delete: {}\", fileType, Joiner.on(\", \").join(paths));\n+    AtomicReference<Long> deleteCount = new AtomicReference<>(0L);\n+\n+    Tasks.foreach(paths)\n+        .retry(3).stopRetryOn(NotFoundException.class).suppressFailureWhenFinished()\n+        .executeWith(ThreadPools.getWorkerPool())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "896c6cf4ad34fa273287d093cebe189fdeb4c27b"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk2MzMyNA==", "bodyText": "It may be okay to log this for manifests and manifest lists but there may be 10-100k data files to remove. Logging all of them may not be a good idea.", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r465963324", "createdAt": "2020-08-05T19:47:32Z", "author": {"login": "aokolnychyi"}, "path": "spark/src/main/java/org/apache/iceberg/actions/ExpireSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import org.apache.iceberg.ExpireSnapshots;\n+import org.apache.iceberg.HasTableOperations;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.exceptions.NotFoundException;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.util.Tasks;\n+import org.apache.iceberg.util.ThreadPools;\n+import org.apache.spark.api.java.JavaSparkContext;\n+import org.apache.spark.sql.Column;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SparkSession;\n+import org.apache.spark.sql.functions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ExpireSnapshotsAction extends BaseAction<ExpireSnapshotActionResult> {\n+  private static final Logger LOG = LoggerFactory.getLogger(ExpireSnapshotsAction.class);\n+\n+  private final SparkSession spark;\n+  private final JavaSparkContext sparkContext;\n+  private final Table table;\n+  private final TableOperations ops;\n+  private final ExpireSnapshots localExpireSnapshots;\n+  private final TableMetadata base;\n+  private static final String DATAFILE = \"Data File\";\n+  private static final String MANIFEST = \"Manifest\";\n+  private static final String MANIFESTLIST = \"Manifest List\";\n+  private static final String OTHER = \"Other\";\n+\n+  private final Consumer<String> defaultDelete = new Consumer<String>() {\n+    @Override\n+    public void accept(String file) {\n+      ops.io().deleteFile(file);\n+    }\n+  };\n+  private Consumer<String> deleteFunc = defaultDelete;\n+\n+\n+  ExpireSnapshotsAction(SparkSession spark, Table table) {\n+    this.spark = spark;\n+    this.sparkContext = JavaSparkContext.fromSparkContext(spark.sparkContext());\n+    this.table = table;\n+    this.ops = ((HasTableOperations) table).operations();\n+    this.base = ops.current();\n+    this.localExpireSnapshots = table.expireSnapshots().cleanExpiredFiles(false);\n+  }\n+\n+  public ExpireSnapshotsAction expireSnapshotId(long expireSnapshotId) {\n+    localExpireSnapshots.expireSnapshotId(expireSnapshotId);\n+    return this;\n+  }\n+\n+  public ExpireSnapshotsAction expireOlderThan(long timestampMillis) {\n+    localExpireSnapshots.expireOlderThan(timestampMillis);\n+    return this;\n+  }\n+\n+  public ExpireSnapshotsAction retainLast(int numSnapshots) {\n+    localExpireSnapshots.retainLast(numSnapshots);\n+    return this;\n+  }\n+\n+  public ExpireSnapshotsAction deleteWith(Consumer<String> newDeleteFunc) {\n+    deleteFunc = newDeleteFunc;\n+    return this;\n+  }\n+\n+\n+  @Override\n+  protected Table table() {\n+    return table;\n+  }\n+\n+  private Dataset<Row> appendTypeString(Dataset<Row> ds, String type) {\n+    return ds.select(new Column(\"file_path\"), functions.lit(type).as(\"DataFile\"));\n+  }\n+\n+  private Dataset<Row> getValidFileDF() {\n+    return appendTypeString(buildValidDataFileDF(spark), DATAFILE)\n+        .union(appendTypeString(buildManifestFileDF(spark), MANIFEST))\n+        .union(appendTypeString(buildManifestListDF(spark, table), MANIFESTLIST))\n+        .union(appendTypeString(buildOtherMetadataFileDF(spark, ops), OTHER));\n+  }\n+\n+  private Set<String> getFilesOfType(List<Row> files, String type) {\n+    return files.stream()\n+        .filter(row -> row.getString(1).equals(type))\n+        .map(row -> row.getString(0))\n+        .collect(Collectors.toSet());\n+  }\n+\n+  @Override\n+  public ExpireSnapshotActionResult execute() {\n+\n+    Dataset<Row> originalFiles = getValidFileDF().persist();\n+    originalFiles.count(); // Trigger Persist\n+\n+    localExpireSnapshots.commit();\n+\n+    Dataset<Row> validFiles = getValidFileDF();\n+\n+    List<Row> filesToDelete = originalFiles.except(validFiles).collectAsList();\n+\n+    LOG.warn(\"Deleting {} files\", filesToDelete.size());\n+    return new ExpireSnapshotActionResult(\n+        deleteFiles(getFilesOfType(filesToDelete, DATAFILE), DATAFILE),\n+        deleteFiles(getFilesOfType(filesToDelete, MANIFEST), MANIFEST),\n+        deleteFiles(getFilesOfType(filesToDelete, MANIFESTLIST), MANIFESTLIST),\n+        deleteFiles(getFilesOfType(filesToDelete, OTHER), OTHER));\n+  }\n+\n+  private Long deleteFiles(Set<String> paths, String fileType) {\n+    LOG.warn(\"{}s to delete: {}\", fileType, Joiner.on(\", \").join(paths));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "896c6cf4ad34fa273287d093cebe189fdeb4c27b"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk2MzUxNA==", "bodyText": "I think build will be a better name than get.", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r465963514", "createdAt": "2020-08-05T19:47:54Z", "author": {"login": "aokolnychyi"}, "path": "spark/src/main/java/org/apache/iceberg/actions/ExpireSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import org.apache.iceberg.ExpireSnapshots;\n+import org.apache.iceberg.HasTableOperations;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.exceptions.NotFoundException;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.util.Tasks;\n+import org.apache.iceberg.util.ThreadPools;\n+import org.apache.spark.api.java.JavaSparkContext;\n+import org.apache.spark.sql.Column;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SparkSession;\n+import org.apache.spark.sql.functions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ExpireSnapshotsAction extends BaseAction<ExpireSnapshotActionResult> {\n+  private static final Logger LOG = LoggerFactory.getLogger(ExpireSnapshotsAction.class);\n+\n+  private final SparkSession spark;\n+  private final JavaSparkContext sparkContext;\n+  private final Table table;\n+  private final TableOperations ops;\n+  private final ExpireSnapshots localExpireSnapshots;\n+  private final TableMetadata base;\n+  private static final String DATAFILE = \"Data File\";\n+  private static final String MANIFEST = \"Manifest\";\n+  private static final String MANIFESTLIST = \"Manifest List\";\n+  private static final String OTHER = \"Other\";\n+\n+  private final Consumer<String> defaultDelete = new Consumer<String>() {\n+    @Override\n+    public void accept(String file) {\n+      ops.io().deleteFile(file);\n+    }\n+  };\n+  private Consumer<String> deleteFunc = defaultDelete;\n+\n+\n+  ExpireSnapshotsAction(SparkSession spark, Table table) {\n+    this.spark = spark;\n+    this.sparkContext = JavaSparkContext.fromSparkContext(spark.sparkContext());\n+    this.table = table;\n+    this.ops = ((HasTableOperations) table).operations();\n+    this.base = ops.current();\n+    this.localExpireSnapshots = table.expireSnapshots().cleanExpiredFiles(false);\n+  }\n+\n+  public ExpireSnapshotsAction expireSnapshotId(long expireSnapshotId) {\n+    localExpireSnapshots.expireSnapshotId(expireSnapshotId);\n+    return this;\n+  }\n+\n+  public ExpireSnapshotsAction expireOlderThan(long timestampMillis) {\n+    localExpireSnapshots.expireOlderThan(timestampMillis);\n+    return this;\n+  }\n+\n+  public ExpireSnapshotsAction retainLast(int numSnapshots) {\n+    localExpireSnapshots.retainLast(numSnapshots);\n+    return this;\n+  }\n+\n+  public ExpireSnapshotsAction deleteWith(Consumer<String> newDeleteFunc) {\n+    deleteFunc = newDeleteFunc;\n+    return this;\n+  }\n+\n+\n+  @Override\n+  protected Table table() {\n+    return table;\n+  }\n+\n+  private Dataset<Row> appendTypeString(Dataset<Row> ds, String type) {\n+    return ds.select(new Column(\"file_path\"), functions.lit(type).as(\"DataFile\"));\n+  }\n+\n+  private Dataset<Row> getValidFileDF() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "896c6cf4ad34fa273287d093cebe189fdeb4c27b"}, "originalPosition": 107}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2e0af0a1121d923978344676d593e46d89686962", "author": {"user": {"login": "RussellSpitzer", "name": "Russell Spitzer"}}, "url": "https://github.com/apache/iceberg/commit/2e0af0a1121d923978344676d593e46d89686962", "committedDate": "2020-08-05T22:00:28Z", "message": "Reviewer Comments\n\nLazy construction of Expire Snapshots Action.\nProcessing of deletes using Local Iterator\nIgnoring Versioning Files\nAdding ExecutorService Option Like RemoveSnapshots"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYyNjIzNDE5", "url": "https://github.com/apache/iceberg/pull/1264#pullrequestreview-462623419", "createdAt": "2020-08-06T15:20:58Z", "commit": {"oid": "2e0af0a1121d923978344676d593e46d89686962"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNToyMDo1OFrOG84WOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNToyOTowNVrOG84s7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQ5MDkzOA==", "bodyText": "Can we add Javadoc to the class and methods as we have in RewriteManifestsAction?", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r466490938", "createdAt": "2020-08-06T15:20:58Z", "author": {"login": "aokolnychyi"}, "path": "spark/src/main/java/org/apache/iceberg/actions/ExpireSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Consumer;\n+import org.apache.iceberg.ExpireSnapshots;\n+import org.apache.iceberg.HasTableOperations;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.exceptions.NotFoundException;\n+import org.apache.iceberg.relocated.com.google.common.util.concurrent.MoreExecutors;\n+import org.apache.iceberg.util.Tasks;\n+import org.apache.spark.sql.Column;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SparkSession;\n+import org.apache.spark.sql.functions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ExpireSnapshotsAction extends BaseAction<ExpireSnapshotsActionResult> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e0af0a1121d923978344676d593e46d89686962"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQ5MTgxMg==", "bodyText": "nit: I am not sure whether it is a convention but we tend to add a space between // and the start of the comment.", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r466491812", "createdAt": "2020-08-06T15:22:12Z", "author": {"login": "aokolnychyi"}, "path": "spark/src/main/java/org/apache/iceberg/actions/ExpireSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Consumer;\n+import org.apache.iceberg.ExpireSnapshots;\n+import org.apache.iceberg.HasTableOperations;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.exceptions.NotFoundException;\n+import org.apache.iceberg.relocated.com.google.common.util.concurrent.MoreExecutors;\n+import org.apache.iceberg.util.Tasks;\n+import org.apache.spark.sql.Column;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SparkSession;\n+import org.apache.spark.sql.functions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ExpireSnapshotsAction extends BaseAction<ExpireSnapshotsActionResult> {\n+  private static final Logger LOG = LoggerFactory.getLogger(ExpireSnapshotsAction.class);\n+\n+  private static final String DATA_FILE = \"Data File\";\n+  private static final String MANIFEST = \"Manifest\";\n+  private static final String MANIFEST_LIST = \"Manifest List\";\n+\n+  // Creates an executor service that runs each task in the thread that invokes execute/submit.\n+  private static final ExecutorService DEFAULT_DELETE_EXECUTOR_SERVICE = MoreExecutors.newDirectExecutorService();\n+\n+  private final SparkSession spark;\n+  private final Table table;\n+  private final TableOperations ops;\n+  private final Consumer<String> defaultDelete = new Consumer<String>() {\n+    @Override\n+    public void accept(String file) {\n+      ops.io().deleteFile(file);\n+    }\n+  };\n+\n+  private Long expireSnapshotIdValue = null;\n+  private Long expireOlderThanValue = null;\n+  private Integer retainLastValue = null;\n+  private Consumer<String> deleteFunc = defaultDelete;\n+  private ExecutorService deleteExecutorService = DEFAULT_DELETE_EXECUTOR_SERVICE;\n+\n+  ExpireSnapshotsAction(SparkSession spark, Table table) {\n+    this.spark = spark;\n+    this.table = table;\n+    this.ops = ((HasTableOperations) table).operations();\n+  }\n+\n+  @Override\n+  protected Table table() {\n+    return table;\n+  }\n+\n+  /**\n+   * An executor service used when deleting files. Only used during the local delete phase of this Spark action\n+   * @param executorService the service to use\n+   * @return this for method chaining\n+   */\n+  public ExpireSnapshotsAction executeDeleteWith(ExecutorService executorService) {\n+    this.deleteExecutorService = executorService;\n+    return this;\n+  }\n+\n+  public ExpireSnapshotsAction expireSnapshotId(long expireSnapshotId) {\n+    this.expireSnapshotIdValue = expireSnapshotId;\n+    return this;\n+  }\n+\n+  public ExpireSnapshotsAction expireOlderThan(long timestampMillis) {\n+    this.expireOlderThanValue = timestampMillis;\n+    return this;\n+  }\n+\n+  public ExpireSnapshotsAction retainLast(int numSnapshots) {\n+    this.retainLastValue = numSnapshots;\n+    return this;\n+  }\n+\n+  public ExpireSnapshotsAction deleteWith(Consumer<String> newDeleteFunc) {\n+    this.deleteFunc = newDeleteFunc;\n+    return this;\n+  }\n+\n+  @Override\n+  public ExpireSnapshotsActionResult execute() {\n+    //Metadata before Expiration", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e0af0a1121d923978344676d593e46d89686962"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQ5MTkzMg==", "bodyText": "nit: same here", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r466491932", "createdAt": "2020-08-06T15:22:22Z", "author": {"login": "aokolnychyi"}, "path": "spark/src/main/java/org/apache/iceberg/actions/ExpireSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Consumer;\n+import org.apache.iceberg.ExpireSnapshots;\n+import org.apache.iceberg.HasTableOperations;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.exceptions.NotFoundException;\n+import org.apache.iceberg.relocated.com.google.common.util.concurrent.MoreExecutors;\n+import org.apache.iceberg.util.Tasks;\n+import org.apache.spark.sql.Column;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SparkSession;\n+import org.apache.spark.sql.functions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ExpireSnapshotsAction extends BaseAction<ExpireSnapshotsActionResult> {\n+  private static final Logger LOG = LoggerFactory.getLogger(ExpireSnapshotsAction.class);\n+\n+  private static final String DATA_FILE = \"Data File\";\n+  private static final String MANIFEST = \"Manifest\";\n+  private static final String MANIFEST_LIST = \"Manifest List\";\n+\n+  // Creates an executor service that runs each task in the thread that invokes execute/submit.\n+  private static final ExecutorService DEFAULT_DELETE_EXECUTOR_SERVICE = MoreExecutors.newDirectExecutorService();\n+\n+  private final SparkSession spark;\n+  private final Table table;\n+  private final TableOperations ops;\n+  private final Consumer<String> defaultDelete = new Consumer<String>() {\n+    @Override\n+    public void accept(String file) {\n+      ops.io().deleteFile(file);\n+    }\n+  };\n+\n+  private Long expireSnapshotIdValue = null;\n+  private Long expireOlderThanValue = null;\n+  private Integer retainLastValue = null;\n+  private Consumer<String> deleteFunc = defaultDelete;\n+  private ExecutorService deleteExecutorService = DEFAULT_DELETE_EXECUTOR_SERVICE;\n+\n+  ExpireSnapshotsAction(SparkSession spark, Table table) {\n+    this.spark = spark;\n+    this.table = table;\n+    this.ops = ((HasTableOperations) table).operations();\n+  }\n+\n+  @Override\n+  protected Table table() {\n+    return table;\n+  }\n+\n+  /**\n+   * An executor service used when deleting files. Only used during the local delete phase of this Spark action\n+   * @param executorService the service to use\n+   * @return this for method chaining\n+   */\n+  public ExpireSnapshotsAction executeDeleteWith(ExecutorService executorService) {\n+    this.deleteExecutorService = executorService;\n+    return this;\n+  }\n+\n+  public ExpireSnapshotsAction expireSnapshotId(long expireSnapshotId) {\n+    this.expireSnapshotIdValue = expireSnapshotId;\n+    return this;\n+  }\n+\n+  public ExpireSnapshotsAction expireOlderThan(long timestampMillis) {\n+    this.expireOlderThanValue = timestampMillis;\n+    return this;\n+  }\n+\n+  public ExpireSnapshotsAction retainLast(int numSnapshots) {\n+    this.retainLastValue = numSnapshots;\n+    return this;\n+  }\n+\n+  public ExpireSnapshotsAction deleteWith(Consumer<String> newDeleteFunc) {\n+    this.deleteFunc = newDeleteFunc;\n+    return this;\n+  }\n+\n+  @Override\n+  public ExpireSnapshotsActionResult execute() {\n+    //Metadata before Expiration\n+    Dataset<Row> originalFiles = buildValidFileDF().persist();\n+    originalFiles.count(); // Action to trigger persist\n+\n+    //Perform Expiration", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e0af0a1121d923978344676d593e46d89686962"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQ5MjcyOA==", "bodyText": "Can we add tests for validating all params? I know we simply delegate but I think it would be better to check.", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r466492728", "createdAt": "2020-08-06T15:23:32Z", "author": {"login": "aokolnychyi"}, "path": "spark/src/main/java/org/apache/iceberg/actions/ExpireSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Consumer;\n+import org.apache.iceberg.ExpireSnapshots;\n+import org.apache.iceberg.HasTableOperations;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.exceptions.NotFoundException;\n+import org.apache.iceberg.relocated.com.google.common.util.concurrent.MoreExecutors;\n+import org.apache.iceberg.util.Tasks;\n+import org.apache.spark.sql.Column;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SparkSession;\n+import org.apache.spark.sql.functions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ExpireSnapshotsAction extends BaseAction<ExpireSnapshotsActionResult> {\n+  private static final Logger LOG = LoggerFactory.getLogger(ExpireSnapshotsAction.class);\n+\n+  private static final String DATA_FILE = \"Data File\";\n+  private static final String MANIFEST = \"Manifest\";\n+  private static final String MANIFEST_LIST = \"Manifest List\";\n+\n+  // Creates an executor service that runs each task in the thread that invokes execute/submit.\n+  private static final ExecutorService DEFAULT_DELETE_EXECUTOR_SERVICE = MoreExecutors.newDirectExecutorService();\n+\n+  private final SparkSession spark;\n+  private final Table table;\n+  private final TableOperations ops;\n+  private final Consumer<String> defaultDelete = new Consumer<String>() {\n+    @Override\n+    public void accept(String file) {\n+      ops.io().deleteFile(file);\n+    }\n+  };\n+\n+  private Long expireSnapshotIdValue = null;\n+  private Long expireOlderThanValue = null;\n+  private Integer retainLastValue = null;\n+  private Consumer<String> deleteFunc = defaultDelete;\n+  private ExecutorService deleteExecutorService = DEFAULT_DELETE_EXECUTOR_SERVICE;\n+\n+  ExpireSnapshotsAction(SparkSession spark, Table table) {\n+    this.spark = spark;\n+    this.table = table;\n+    this.ops = ((HasTableOperations) table).operations();\n+  }\n+\n+  @Override\n+  protected Table table() {\n+    return table;\n+  }\n+\n+  /**\n+   * An executor service used when deleting files. Only used during the local delete phase of this Spark action\n+   * @param executorService the service to use\n+   * @return this for method chaining\n+   */\n+  public ExpireSnapshotsAction executeDeleteWith(ExecutorService executorService) {\n+    this.deleteExecutorService = executorService;\n+    return this;\n+  }\n+\n+  public ExpireSnapshotsAction expireSnapshotId(long expireSnapshotId) {\n+    this.expireSnapshotIdValue = expireSnapshotId;\n+    return this;\n+  }\n+\n+  public ExpireSnapshotsAction expireOlderThan(long timestampMillis) {\n+    this.expireOlderThanValue = timestampMillis;\n+    return this;\n+  }\n+\n+  public ExpireSnapshotsAction retainLast(int numSnapshots) {\n+    this.retainLastValue = numSnapshots;\n+    return this;\n+  }\n+\n+  public ExpireSnapshotsAction deleteWith(Consumer<String> newDeleteFunc) {\n+    this.deleteFunc = newDeleteFunc;\n+    return this;\n+  }\n+\n+  @Override\n+  public ExpireSnapshotsActionResult execute() {\n+    //Metadata before Expiration\n+    Dataset<Row> originalFiles = buildValidFileDF().persist();\n+    originalFiles.count(); // Action to trigger persist\n+\n+    //Perform Expiration\n+    ExpireSnapshots expireSnaps = table.expireSnapshots().cleanExpiredFiles(false);\n+    if (expireSnapshotIdValue != null) {\n+      expireSnaps = expireSnaps.expireSnapshotId(expireSnapshotIdValue);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e0af0a1121d923978344676d593e46d89686962"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQ5MzMwNQ==", "bodyText": "I think this has to be wrapped into try-finally. We will have to always unpersist if a commit fails, for example.", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r466493305", "createdAt": "2020-08-06T15:24:21Z", "author": {"login": "aokolnychyi"}, "path": "spark/src/main/java/org/apache/iceberg/actions/ExpireSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Consumer;\n+import org.apache.iceberg.ExpireSnapshots;\n+import org.apache.iceberg.HasTableOperations;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.exceptions.NotFoundException;\n+import org.apache.iceberg.relocated.com.google.common.util.concurrent.MoreExecutors;\n+import org.apache.iceberg.util.Tasks;\n+import org.apache.spark.sql.Column;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SparkSession;\n+import org.apache.spark.sql.functions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ExpireSnapshotsAction extends BaseAction<ExpireSnapshotsActionResult> {\n+  private static final Logger LOG = LoggerFactory.getLogger(ExpireSnapshotsAction.class);\n+\n+  private static final String DATA_FILE = \"Data File\";\n+  private static final String MANIFEST = \"Manifest\";\n+  private static final String MANIFEST_LIST = \"Manifest List\";\n+\n+  // Creates an executor service that runs each task in the thread that invokes execute/submit.\n+  private static final ExecutorService DEFAULT_DELETE_EXECUTOR_SERVICE = MoreExecutors.newDirectExecutorService();\n+\n+  private final SparkSession spark;\n+  private final Table table;\n+  private final TableOperations ops;\n+  private final Consumer<String> defaultDelete = new Consumer<String>() {\n+    @Override\n+    public void accept(String file) {\n+      ops.io().deleteFile(file);\n+    }\n+  };\n+\n+  private Long expireSnapshotIdValue = null;\n+  private Long expireOlderThanValue = null;\n+  private Integer retainLastValue = null;\n+  private Consumer<String> deleteFunc = defaultDelete;\n+  private ExecutorService deleteExecutorService = DEFAULT_DELETE_EXECUTOR_SERVICE;\n+\n+  ExpireSnapshotsAction(SparkSession spark, Table table) {\n+    this.spark = spark;\n+    this.table = table;\n+    this.ops = ((HasTableOperations) table).operations();\n+  }\n+\n+  @Override\n+  protected Table table() {\n+    return table;\n+  }\n+\n+  /**\n+   * An executor service used when deleting files. Only used during the local delete phase of this Spark action\n+   * @param executorService the service to use\n+   * @return this for method chaining\n+   */\n+  public ExpireSnapshotsAction executeDeleteWith(ExecutorService executorService) {\n+    this.deleteExecutorService = executorService;\n+    return this;\n+  }\n+\n+  public ExpireSnapshotsAction expireSnapshotId(long expireSnapshotId) {\n+    this.expireSnapshotIdValue = expireSnapshotId;\n+    return this;\n+  }\n+\n+  public ExpireSnapshotsAction expireOlderThan(long timestampMillis) {\n+    this.expireOlderThanValue = timestampMillis;\n+    return this;\n+  }\n+\n+  public ExpireSnapshotsAction retainLast(int numSnapshots) {\n+    this.retainLastValue = numSnapshots;\n+    return this;\n+  }\n+\n+  public ExpireSnapshotsAction deleteWith(Consumer<String> newDeleteFunc) {\n+    this.deleteFunc = newDeleteFunc;\n+    return this;\n+  }\n+\n+  @Override\n+  public ExpireSnapshotsActionResult execute() {\n+    //Metadata before Expiration\n+    Dataset<Row> originalFiles = buildValidFileDF().persist();\n+    originalFiles.count(); // Action to trigger persist\n+\n+    //Perform Expiration\n+    ExpireSnapshots expireSnaps = table.expireSnapshots().cleanExpiredFiles(false);\n+    if (expireSnapshotIdValue != null) {\n+      expireSnaps = expireSnaps.expireSnapshotId(expireSnapshotIdValue);\n+    }\n+    if (expireOlderThanValue != null) {\n+      expireSnaps = expireSnaps.expireOlderThan(expireOlderThanValue);\n+    }\n+    if (retainLastValue != null) {\n+      expireSnaps = expireSnaps.retainLast(retainLastValue);\n+    }\n+    expireSnaps.commit();\n+\n+    // Metadata after Expiration\n+    Dataset<Row> validFiles = buildValidFileDF();\n+    Dataset<Row> filesToDelete = originalFiles.except(validFiles);\n+\n+    ExpireSnapshotsActionResult result =  deleteFiles(filesToDelete.toLocalIterator());\n+    originalFiles.unpersist();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e0af0a1121d923978344676d593e46d89686962"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQ5MzU2NQ==", "bodyText": "nit: extra space after =", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r466493565", "createdAt": "2020-08-06T15:24:44Z", "author": {"login": "aokolnychyi"}, "path": "spark/src/main/java/org/apache/iceberg/actions/ExpireSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Consumer;\n+import org.apache.iceberg.ExpireSnapshots;\n+import org.apache.iceberg.HasTableOperations;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.exceptions.NotFoundException;\n+import org.apache.iceberg.relocated.com.google.common.util.concurrent.MoreExecutors;\n+import org.apache.iceberg.util.Tasks;\n+import org.apache.spark.sql.Column;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SparkSession;\n+import org.apache.spark.sql.functions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ExpireSnapshotsAction extends BaseAction<ExpireSnapshotsActionResult> {\n+  private static final Logger LOG = LoggerFactory.getLogger(ExpireSnapshotsAction.class);\n+\n+  private static final String DATA_FILE = \"Data File\";\n+  private static final String MANIFEST = \"Manifest\";\n+  private static final String MANIFEST_LIST = \"Manifest List\";\n+\n+  // Creates an executor service that runs each task in the thread that invokes execute/submit.\n+  private static final ExecutorService DEFAULT_DELETE_EXECUTOR_SERVICE = MoreExecutors.newDirectExecutorService();\n+\n+  private final SparkSession spark;\n+  private final Table table;\n+  private final TableOperations ops;\n+  private final Consumer<String> defaultDelete = new Consumer<String>() {\n+    @Override\n+    public void accept(String file) {\n+      ops.io().deleteFile(file);\n+    }\n+  };\n+\n+  private Long expireSnapshotIdValue = null;\n+  private Long expireOlderThanValue = null;\n+  private Integer retainLastValue = null;\n+  private Consumer<String> deleteFunc = defaultDelete;\n+  private ExecutorService deleteExecutorService = DEFAULT_DELETE_EXECUTOR_SERVICE;\n+\n+  ExpireSnapshotsAction(SparkSession spark, Table table) {\n+    this.spark = spark;\n+    this.table = table;\n+    this.ops = ((HasTableOperations) table).operations();\n+  }\n+\n+  @Override\n+  protected Table table() {\n+    return table;\n+  }\n+\n+  /**\n+   * An executor service used when deleting files. Only used during the local delete phase of this Spark action\n+   * @param executorService the service to use\n+   * @return this for method chaining\n+   */\n+  public ExpireSnapshotsAction executeDeleteWith(ExecutorService executorService) {\n+    this.deleteExecutorService = executorService;\n+    return this;\n+  }\n+\n+  public ExpireSnapshotsAction expireSnapshotId(long expireSnapshotId) {\n+    this.expireSnapshotIdValue = expireSnapshotId;\n+    return this;\n+  }\n+\n+  public ExpireSnapshotsAction expireOlderThan(long timestampMillis) {\n+    this.expireOlderThanValue = timestampMillis;\n+    return this;\n+  }\n+\n+  public ExpireSnapshotsAction retainLast(int numSnapshots) {\n+    this.retainLastValue = numSnapshots;\n+    return this;\n+  }\n+\n+  public ExpireSnapshotsAction deleteWith(Consumer<String> newDeleteFunc) {\n+    this.deleteFunc = newDeleteFunc;\n+    return this;\n+  }\n+\n+  @Override\n+  public ExpireSnapshotsActionResult execute() {\n+    //Metadata before Expiration\n+    Dataset<Row> originalFiles = buildValidFileDF().persist();\n+    originalFiles.count(); // Action to trigger persist\n+\n+    //Perform Expiration\n+    ExpireSnapshots expireSnaps = table.expireSnapshots().cleanExpiredFiles(false);\n+    if (expireSnapshotIdValue != null) {\n+      expireSnaps = expireSnaps.expireSnapshotId(expireSnapshotIdValue);\n+    }\n+    if (expireOlderThanValue != null) {\n+      expireSnaps = expireSnaps.expireOlderThan(expireOlderThanValue);\n+    }\n+    if (retainLastValue != null) {\n+      expireSnaps = expireSnaps.retainLast(retainLastValue);\n+    }\n+    expireSnaps.commit();\n+\n+    // Metadata after Expiration\n+    Dataset<Row> validFiles = buildValidFileDF();\n+    Dataset<Row> filesToDelete = originalFiles.except(validFiles);\n+\n+    ExpireSnapshotsActionResult result =  deleteFiles(filesToDelete.toLocalIterator());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e0af0a1121d923978344676d593e46d89686962"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQ5NDM0OQ==", "bodyText": "paths -> expiredFiles? Just an idea.", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r466494349", "createdAt": "2020-08-06T15:25:45Z", "author": {"login": "aokolnychyi"}, "path": "spark/src/main/java/org/apache/iceberg/actions/ExpireSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Consumer;\n+import org.apache.iceberg.ExpireSnapshots;\n+import org.apache.iceberg.HasTableOperations;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.exceptions.NotFoundException;\n+import org.apache.iceberg.relocated.com.google.common.util.concurrent.MoreExecutors;\n+import org.apache.iceberg.util.Tasks;\n+import org.apache.spark.sql.Column;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SparkSession;\n+import org.apache.spark.sql.functions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ExpireSnapshotsAction extends BaseAction<ExpireSnapshotsActionResult> {\n+  private static final Logger LOG = LoggerFactory.getLogger(ExpireSnapshotsAction.class);\n+\n+  private static final String DATA_FILE = \"Data File\";\n+  private static final String MANIFEST = \"Manifest\";\n+  private static final String MANIFEST_LIST = \"Manifest List\";\n+\n+  // Creates an executor service that runs each task in the thread that invokes execute/submit.\n+  private static final ExecutorService DEFAULT_DELETE_EXECUTOR_SERVICE = MoreExecutors.newDirectExecutorService();\n+\n+  private final SparkSession spark;\n+  private final Table table;\n+  private final TableOperations ops;\n+  private final Consumer<String> defaultDelete = new Consumer<String>() {\n+    @Override\n+    public void accept(String file) {\n+      ops.io().deleteFile(file);\n+    }\n+  };\n+\n+  private Long expireSnapshotIdValue = null;\n+  private Long expireOlderThanValue = null;\n+  private Integer retainLastValue = null;\n+  private Consumer<String> deleteFunc = defaultDelete;\n+  private ExecutorService deleteExecutorService = DEFAULT_DELETE_EXECUTOR_SERVICE;\n+\n+  ExpireSnapshotsAction(SparkSession spark, Table table) {\n+    this.spark = spark;\n+    this.table = table;\n+    this.ops = ((HasTableOperations) table).operations();\n+  }\n+\n+  @Override\n+  protected Table table() {\n+    return table;\n+  }\n+\n+  /**\n+   * An executor service used when deleting files. Only used during the local delete phase of this Spark action\n+   * @param executorService the service to use\n+   * @return this for method chaining\n+   */\n+  public ExpireSnapshotsAction executeDeleteWith(ExecutorService executorService) {\n+    this.deleteExecutorService = executorService;\n+    return this;\n+  }\n+\n+  public ExpireSnapshotsAction expireSnapshotId(long expireSnapshotId) {\n+    this.expireSnapshotIdValue = expireSnapshotId;\n+    return this;\n+  }\n+\n+  public ExpireSnapshotsAction expireOlderThan(long timestampMillis) {\n+    this.expireOlderThanValue = timestampMillis;\n+    return this;\n+  }\n+\n+  public ExpireSnapshotsAction retainLast(int numSnapshots) {\n+    this.retainLastValue = numSnapshots;\n+    return this;\n+  }\n+\n+  public ExpireSnapshotsAction deleteWith(Consumer<String> newDeleteFunc) {\n+    this.deleteFunc = newDeleteFunc;\n+    return this;\n+  }\n+\n+  @Override\n+  public ExpireSnapshotsActionResult execute() {\n+    //Metadata before Expiration\n+    Dataset<Row> originalFiles = buildValidFileDF().persist();\n+    originalFiles.count(); // Action to trigger persist\n+\n+    //Perform Expiration\n+    ExpireSnapshots expireSnaps = table.expireSnapshots().cleanExpiredFiles(false);\n+    if (expireSnapshotIdValue != null) {\n+      expireSnaps = expireSnaps.expireSnapshotId(expireSnapshotIdValue);\n+    }\n+    if (expireOlderThanValue != null) {\n+      expireSnaps = expireSnaps.expireOlderThan(expireOlderThanValue);\n+    }\n+    if (retainLastValue != null) {\n+      expireSnaps = expireSnaps.retainLast(retainLastValue);\n+    }\n+    expireSnaps.commit();\n+\n+    // Metadata after Expiration\n+    Dataset<Row> validFiles = buildValidFileDF();\n+    Dataset<Row> filesToDelete = originalFiles.except(validFiles);\n+\n+    ExpireSnapshotsActionResult result =  deleteFiles(filesToDelete.toLocalIterator());\n+    originalFiles.unpersist();\n+    return result;\n+  }\n+\n+  private Dataset<Row> appendTypeString(Dataset<Row> ds, String type) {\n+    return ds.select(new Column(\"file_path\"), functions.lit(type).as(\"file_type\"));\n+  }\n+\n+  private Dataset<Row> buildValidFileDF() {\n+    return appendTypeString(buildValidDataFileDF(spark), DATA_FILE)\n+        .union(appendTypeString(buildManifestFileDF(spark), MANIFEST))\n+        .union(appendTypeString(buildManifestListDF(spark, table), MANIFEST_LIST));\n+  }\n+\n+  private ExpireSnapshotsActionResult deleteFiles(Iterator<Row> paths) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e0af0a1121d923978344676d593e46d89686962"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQ5NTc0MQ==", "bodyText": "@rdblue, I know this action follows what we had before and uses warn level. How appropriate is that, though? I think warn indicates that there is an unusual situation or something went wrong. Here, that's expected, no?", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r466495741", "createdAt": "2020-08-06T15:27:39Z", "author": {"login": "aokolnychyi"}, "path": "spark/src/main/java/org/apache/iceberg/actions/ExpireSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Consumer;\n+import org.apache.iceberg.ExpireSnapshots;\n+import org.apache.iceberg.HasTableOperations;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.exceptions.NotFoundException;\n+import org.apache.iceberg.relocated.com.google.common.util.concurrent.MoreExecutors;\n+import org.apache.iceberg.util.Tasks;\n+import org.apache.spark.sql.Column;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SparkSession;\n+import org.apache.spark.sql.functions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ExpireSnapshotsAction extends BaseAction<ExpireSnapshotsActionResult> {\n+  private static final Logger LOG = LoggerFactory.getLogger(ExpireSnapshotsAction.class);\n+\n+  private static final String DATA_FILE = \"Data File\";\n+  private static final String MANIFEST = \"Manifest\";\n+  private static final String MANIFEST_LIST = \"Manifest List\";\n+\n+  // Creates an executor service that runs each task in the thread that invokes execute/submit.\n+  private static final ExecutorService DEFAULT_DELETE_EXECUTOR_SERVICE = MoreExecutors.newDirectExecutorService();\n+\n+  private final SparkSession spark;\n+  private final Table table;\n+  private final TableOperations ops;\n+  private final Consumer<String> defaultDelete = new Consumer<String>() {\n+    @Override\n+    public void accept(String file) {\n+      ops.io().deleteFile(file);\n+    }\n+  };\n+\n+  private Long expireSnapshotIdValue = null;\n+  private Long expireOlderThanValue = null;\n+  private Integer retainLastValue = null;\n+  private Consumer<String> deleteFunc = defaultDelete;\n+  private ExecutorService deleteExecutorService = DEFAULT_DELETE_EXECUTOR_SERVICE;\n+\n+  ExpireSnapshotsAction(SparkSession spark, Table table) {\n+    this.spark = spark;\n+    this.table = table;\n+    this.ops = ((HasTableOperations) table).operations();\n+  }\n+\n+  @Override\n+  protected Table table() {\n+    return table;\n+  }\n+\n+  /**\n+   * An executor service used when deleting files. Only used during the local delete phase of this Spark action\n+   * @param executorService the service to use\n+   * @return this for method chaining\n+   */\n+  public ExpireSnapshotsAction executeDeleteWith(ExecutorService executorService) {\n+    this.deleteExecutorService = executorService;\n+    return this;\n+  }\n+\n+  public ExpireSnapshotsAction expireSnapshotId(long expireSnapshotId) {\n+    this.expireSnapshotIdValue = expireSnapshotId;\n+    return this;\n+  }\n+\n+  public ExpireSnapshotsAction expireOlderThan(long timestampMillis) {\n+    this.expireOlderThanValue = timestampMillis;\n+    return this;\n+  }\n+\n+  public ExpireSnapshotsAction retainLast(int numSnapshots) {\n+    this.retainLastValue = numSnapshots;\n+    return this;\n+  }\n+\n+  public ExpireSnapshotsAction deleteWith(Consumer<String> newDeleteFunc) {\n+    this.deleteFunc = newDeleteFunc;\n+    return this;\n+  }\n+\n+  @Override\n+  public ExpireSnapshotsActionResult execute() {\n+    //Metadata before Expiration\n+    Dataset<Row> originalFiles = buildValidFileDF().persist();\n+    originalFiles.count(); // Action to trigger persist\n+\n+    //Perform Expiration\n+    ExpireSnapshots expireSnaps = table.expireSnapshots().cleanExpiredFiles(false);\n+    if (expireSnapshotIdValue != null) {\n+      expireSnaps = expireSnaps.expireSnapshotId(expireSnapshotIdValue);\n+    }\n+    if (expireOlderThanValue != null) {\n+      expireSnaps = expireSnaps.expireOlderThan(expireOlderThanValue);\n+    }\n+    if (retainLastValue != null) {\n+      expireSnaps = expireSnaps.retainLast(retainLastValue);\n+    }\n+    expireSnaps.commit();\n+\n+    // Metadata after Expiration\n+    Dataset<Row> validFiles = buildValidFileDF();\n+    Dataset<Row> filesToDelete = originalFiles.except(validFiles);\n+\n+    ExpireSnapshotsActionResult result =  deleteFiles(filesToDelete.toLocalIterator());\n+    originalFiles.unpersist();\n+    return result;\n+  }\n+\n+  private Dataset<Row> appendTypeString(Dataset<Row> ds, String type) {\n+    return ds.select(new Column(\"file_path\"), functions.lit(type).as(\"file_type\"));\n+  }\n+\n+  private Dataset<Row> buildValidFileDF() {\n+    return appendTypeString(buildValidDataFileDF(spark), DATA_FILE)\n+        .union(appendTypeString(buildManifestFileDF(spark), MANIFEST))\n+        .union(appendTypeString(buildManifestListDF(spark, table), MANIFEST_LIST));\n+  }\n+\n+  private ExpireSnapshotsActionResult deleteFiles(Iterator<Row> paths) {\n+    AtomicLong dataFileCount = new AtomicLong(0L);\n+    AtomicLong manifestCount = new AtomicLong(0L);\n+    AtomicLong manifestListCount = new AtomicLong(0L);\n+\n+    Tasks.foreach(paths)\n+        .retry(3).stopRetryOn(NotFoundException.class).suppressFailureWhenFinished()\n+        .executeWith(deleteExecutorService)\n+        .onFailure((fileInfo, exc) ->\n+            LOG.warn(\"Delete failed for {}: {}\", fileInfo.getString(1), fileInfo.getString(0), exc))\n+        .run(fileInfo -> {\n+          String file = fileInfo.getString(0);\n+          String type = fileInfo.getString(1);\n+          deleteFunc.accept(file);\n+          switch (type) {\n+            case DATA_FILE:\n+              dataFileCount.incrementAndGet();\n+              LOG.trace(\"Deleted Data File: {}\", file);\n+              break;\n+            case MANIFEST:\n+              manifestCount.incrementAndGet();\n+              LOG.warn(\"Deleted Manifest: {}\", file);\n+              break;\n+            case MANIFEST_LIST:\n+              manifestListCount.incrementAndGet();\n+              LOG.warn(\"Deleted Manifest List: {}\", file);\n+              break;\n+          }\n+        });\n+    LOG.warn(\"Deleted {} total files\", dataFileCount.get() + manifestCount.get() + manifestListCount.get());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e0af0a1121d923978344676d593e46d89686962"}, "originalPosition": 175}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQ5Njc1MQ==", "bodyText": "By default, this will use memory and disk. I am OK with this. In the future, we will replace it with reading from an old version file.", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r466496751", "createdAt": "2020-08-06T15:29:05Z", "author": {"login": "aokolnychyi"}, "path": "spark/src/main/java/org/apache/iceberg/actions/ExpireSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Consumer;\n+import org.apache.iceberg.ExpireSnapshots;\n+import org.apache.iceberg.HasTableOperations;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.exceptions.NotFoundException;\n+import org.apache.iceberg.relocated.com.google.common.util.concurrent.MoreExecutors;\n+import org.apache.iceberg.util.Tasks;\n+import org.apache.spark.sql.Column;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SparkSession;\n+import org.apache.spark.sql.functions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ExpireSnapshotsAction extends BaseAction<ExpireSnapshotsActionResult> {\n+  private static final Logger LOG = LoggerFactory.getLogger(ExpireSnapshotsAction.class);\n+\n+  private static final String DATA_FILE = \"Data File\";\n+  private static final String MANIFEST = \"Manifest\";\n+  private static final String MANIFEST_LIST = \"Manifest List\";\n+\n+  // Creates an executor service that runs each task in the thread that invokes execute/submit.\n+  private static final ExecutorService DEFAULT_DELETE_EXECUTOR_SERVICE = MoreExecutors.newDirectExecutorService();\n+\n+  private final SparkSession spark;\n+  private final Table table;\n+  private final TableOperations ops;\n+  private final Consumer<String> defaultDelete = new Consumer<String>() {\n+    @Override\n+    public void accept(String file) {\n+      ops.io().deleteFile(file);\n+    }\n+  };\n+\n+  private Long expireSnapshotIdValue = null;\n+  private Long expireOlderThanValue = null;\n+  private Integer retainLastValue = null;\n+  private Consumer<String> deleteFunc = defaultDelete;\n+  private ExecutorService deleteExecutorService = DEFAULT_DELETE_EXECUTOR_SERVICE;\n+\n+  ExpireSnapshotsAction(SparkSession spark, Table table) {\n+    this.spark = spark;\n+    this.table = table;\n+    this.ops = ((HasTableOperations) table).operations();\n+  }\n+\n+  @Override\n+  protected Table table() {\n+    return table;\n+  }\n+\n+  /**\n+   * An executor service used when deleting files. Only used during the local delete phase of this Spark action\n+   * @param executorService the service to use\n+   * @return this for method chaining\n+   */\n+  public ExpireSnapshotsAction executeDeleteWith(ExecutorService executorService) {\n+    this.deleteExecutorService = executorService;\n+    return this;\n+  }\n+\n+  public ExpireSnapshotsAction expireSnapshotId(long expireSnapshotId) {\n+    this.expireSnapshotIdValue = expireSnapshotId;\n+    return this;\n+  }\n+\n+  public ExpireSnapshotsAction expireOlderThan(long timestampMillis) {\n+    this.expireOlderThanValue = timestampMillis;\n+    return this;\n+  }\n+\n+  public ExpireSnapshotsAction retainLast(int numSnapshots) {\n+    this.retainLastValue = numSnapshots;\n+    return this;\n+  }\n+\n+  public ExpireSnapshotsAction deleteWith(Consumer<String> newDeleteFunc) {\n+    this.deleteFunc = newDeleteFunc;\n+    return this;\n+  }\n+\n+  @Override\n+  public ExpireSnapshotsActionResult execute() {\n+    //Metadata before Expiration\n+    Dataset<Row> originalFiles = buildValidFileDF().persist();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e0af0a1121d923978344676d593e46d89686962"}, "originalPosition": 111}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYyNjUxMDkz", "url": "https://github.com/apache/iceberg/pull/1264#pullrequestreview-462651093", "createdAt": "2020-08-06T15:51:56Z", "commit": {"oid": "2e0af0a1121d923978344676d593e46d89686962"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNTo1MTo1NlrOG85rlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNTo1MTo1NlrOG85rlg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUxMjc5MA==", "bodyText": "I like this name better than executeWith we have in RemoveSnapshots. Shall we update RemoveSnapshots too before we release it? @fbocse @rdblue, what do you think?", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r466512790", "createdAt": "2020-08-06T15:51:56Z", "author": {"login": "aokolnychyi"}, "path": "spark/src/main/java/org/apache/iceberg/actions/ExpireSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Consumer;\n+import org.apache.iceberg.ExpireSnapshots;\n+import org.apache.iceberg.HasTableOperations;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.exceptions.NotFoundException;\n+import org.apache.iceberg.relocated.com.google.common.util.concurrent.MoreExecutors;\n+import org.apache.iceberg.util.Tasks;\n+import org.apache.spark.sql.Column;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SparkSession;\n+import org.apache.spark.sql.functions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ExpireSnapshotsAction extends BaseAction<ExpireSnapshotsActionResult> {\n+  private static final Logger LOG = LoggerFactory.getLogger(ExpireSnapshotsAction.class);\n+\n+  private static final String DATA_FILE = \"Data File\";\n+  private static final String MANIFEST = \"Manifest\";\n+  private static final String MANIFEST_LIST = \"Manifest List\";\n+\n+  // Creates an executor service that runs each task in the thread that invokes execute/submit.\n+  private static final ExecutorService DEFAULT_DELETE_EXECUTOR_SERVICE = MoreExecutors.newDirectExecutorService();\n+\n+  private final SparkSession spark;\n+  private final Table table;\n+  private final TableOperations ops;\n+  private final Consumer<String> defaultDelete = new Consumer<String>() {\n+    @Override\n+    public void accept(String file) {\n+      ops.io().deleteFile(file);\n+    }\n+  };\n+\n+  private Long expireSnapshotIdValue = null;\n+  private Long expireOlderThanValue = null;\n+  private Integer retainLastValue = null;\n+  private Consumer<String> deleteFunc = defaultDelete;\n+  private ExecutorService deleteExecutorService = DEFAULT_DELETE_EXECUTOR_SERVICE;\n+\n+  ExpireSnapshotsAction(SparkSession spark, Table table) {\n+    this.spark = spark;\n+    this.table = table;\n+    this.ops = ((HasTableOperations) table).operations();\n+  }\n+\n+  @Override\n+  protected Table table() {\n+    return table;\n+  }\n+\n+  /**\n+   * An executor service used when deleting files. Only used during the local delete phase of this Spark action\n+   * @param executorService the service to use\n+   * @return this for method chaining\n+   */\n+  public ExpireSnapshotsAction executeDeleteWith(ExecutorService executorService) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e0af0a1121d923978344676d593e46d89686962"}, "originalPosition": 83}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYyNjcyNTA2", "url": "https://github.com/apache/iceberg/pull/1264#pullrequestreview-462672506", "createdAt": "2020-08-06T16:18:13Z", "commit": {"oid": "2e0af0a1121d923978344676d593e46d89686962"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNjoxODoxM1rOG86t2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNjozNToxMVrOG87UIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUyOTc1Mg==", "bodyText": "Shouldn't this be trace as well?", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r466529752", "createdAt": "2020-08-06T16:18:13Z", "author": {"login": "mehtaashish23"}, "path": "spark/src/main/java/org/apache/iceberg/actions/ExpireSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Consumer;\n+import org.apache.iceberg.ExpireSnapshots;\n+import org.apache.iceberg.HasTableOperations;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.exceptions.NotFoundException;\n+import org.apache.iceberg.relocated.com.google.common.util.concurrent.MoreExecutors;\n+import org.apache.iceberg.util.Tasks;\n+import org.apache.spark.sql.Column;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SparkSession;\n+import org.apache.spark.sql.functions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ExpireSnapshotsAction extends BaseAction<ExpireSnapshotsActionResult> {\n+  private static final Logger LOG = LoggerFactory.getLogger(ExpireSnapshotsAction.class);\n+\n+  private static final String DATA_FILE = \"Data File\";\n+  private static final String MANIFEST = \"Manifest\";\n+  private static final String MANIFEST_LIST = \"Manifest List\";\n+\n+  // Creates an executor service that runs each task in the thread that invokes execute/submit.\n+  private static final ExecutorService DEFAULT_DELETE_EXECUTOR_SERVICE = MoreExecutors.newDirectExecutorService();\n+\n+  private final SparkSession spark;\n+  private final Table table;\n+  private final TableOperations ops;\n+  private final Consumer<String> defaultDelete = new Consumer<String>() {\n+    @Override\n+    public void accept(String file) {\n+      ops.io().deleteFile(file);\n+    }\n+  };\n+\n+  private Long expireSnapshotIdValue = null;\n+  private Long expireOlderThanValue = null;\n+  private Integer retainLastValue = null;\n+  private Consumer<String> deleteFunc = defaultDelete;\n+  private ExecutorService deleteExecutorService = DEFAULT_DELETE_EXECUTOR_SERVICE;\n+\n+  ExpireSnapshotsAction(SparkSession spark, Table table) {\n+    this.spark = spark;\n+    this.table = table;\n+    this.ops = ((HasTableOperations) table).operations();\n+  }\n+\n+  @Override\n+  protected Table table() {\n+    return table;\n+  }\n+\n+  /**\n+   * An executor service used when deleting files. Only used during the local delete phase of this Spark action\n+   * @param executorService the service to use\n+   * @return this for method chaining\n+   */\n+  public ExpireSnapshotsAction executeDeleteWith(ExecutorService executorService) {\n+    this.deleteExecutorService = executorService;\n+    return this;\n+  }\n+\n+  public ExpireSnapshotsAction expireSnapshotId(long expireSnapshotId) {\n+    this.expireSnapshotIdValue = expireSnapshotId;\n+    return this;\n+  }\n+\n+  public ExpireSnapshotsAction expireOlderThan(long timestampMillis) {\n+    this.expireOlderThanValue = timestampMillis;\n+    return this;\n+  }\n+\n+  public ExpireSnapshotsAction retainLast(int numSnapshots) {\n+    this.retainLastValue = numSnapshots;\n+    return this;\n+  }\n+\n+  public ExpireSnapshotsAction deleteWith(Consumer<String> newDeleteFunc) {\n+    this.deleteFunc = newDeleteFunc;\n+    return this;\n+  }\n+\n+  @Override\n+  public ExpireSnapshotsActionResult execute() {\n+    //Metadata before Expiration\n+    Dataset<Row> originalFiles = buildValidFileDF().persist();\n+    originalFiles.count(); // Action to trigger persist\n+\n+    //Perform Expiration\n+    ExpireSnapshots expireSnaps = table.expireSnapshots().cleanExpiredFiles(false);\n+    if (expireSnapshotIdValue != null) {\n+      expireSnaps = expireSnaps.expireSnapshotId(expireSnapshotIdValue);\n+    }\n+    if (expireOlderThanValue != null) {\n+      expireSnaps = expireSnaps.expireOlderThan(expireOlderThanValue);\n+    }\n+    if (retainLastValue != null) {\n+      expireSnaps = expireSnaps.retainLast(retainLastValue);\n+    }\n+    expireSnaps.commit();\n+\n+    // Metadata after Expiration\n+    Dataset<Row> validFiles = buildValidFileDF();\n+    Dataset<Row> filesToDelete = originalFiles.except(validFiles);\n+\n+    ExpireSnapshotsActionResult result =  deleteFiles(filesToDelete.toLocalIterator());\n+    originalFiles.unpersist();\n+    return result;\n+  }\n+\n+  private Dataset<Row> appendTypeString(Dataset<Row> ds, String type) {\n+    return ds.select(new Column(\"file_path\"), functions.lit(type).as(\"file_type\"));\n+  }\n+\n+  private Dataset<Row> buildValidFileDF() {\n+    return appendTypeString(buildValidDataFileDF(spark), DATA_FILE)\n+        .union(appendTypeString(buildManifestFileDF(spark), MANIFEST))\n+        .union(appendTypeString(buildManifestListDF(spark, table), MANIFEST_LIST));\n+  }\n+\n+  private ExpireSnapshotsActionResult deleteFiles(Iterator<Row> paths) {\n+    AtomicLong dataFileCount = new AtomicLong(0L);\n+    AtomicLong manifestCount = new AtomicLong(0L);\n+    AtomicLong manifestListCount = new AtomicLong(0L);\n+\n+    Tasks.foreach(paths)\n+        .retry(3).stopRetryOn(NotFoundException.class).suppressFailureWhenFinished()\n+        .executeWith(deleteExecutorService)\n+        .onFailure((fileInfo, exc) ->\n+            LOG.warn(\"Delete failed for {}: {}\", fileInfo.getString(1), fileInfo.getString(0), exc))\n+        .run(fileInfo -> {\n+          String file = fileInfo.getString(0);\n+          String type = fileInfo.getString(1);\n+          deleteFunc.accept(file);\n+          switch (type) {\n+            case DATA_FILE:\n+              dataFileCount.incrementAndGet();\n+              LOG.trace(\"Deleted Data File: {}\", file);\n+              break;\n+            case MANIFEST:\n+              manifestCount.incrementAndGet();\n+              LOG.warn(\"Deleted Manifest: {}\", file);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e0af0a1121d923978344676d593e46d89686962"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUzMDY1Nw==", "bodyText": "Unnecessary file?", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r466530657", "createdAt": "2020-08-06T16:19:49Z", "author": {"login": "mehtaashish23"}, "path": "spark2/src/test/java/org/apache/iceberg/actions/TestExpireSnapshotsAction24.java", "diffHunk": "@@ -0,0 +1,23 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+public class TestExpireSnapshotsAction24 extends TestExpireSnapshotsAction{", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e0af0a1121d923978344676d593e46d89686962"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUzMDg2NQ==", "bodyText": "same: Unnecessary files?", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r466530865", "createdAt": "2020-08-06T16:20:07Z", "author": {"login": "mehtaashish23"}, "path": "spark3/src/test/java/org/apache/iceberg/spark/actions/TestExpireSnapshotsAction3.java", "diffHunk": "@@ -0,0 +1,25 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.actions;\n+\n+import org.apache.iceberg.actions.TestExpireSnapshotsAction;\n+\n+public class TestExpireSnapshotsAction3 extends TestExpireSnapshotsAction {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e0af0a1121d923978344676d593e46d89686962"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUzOTU1NA==", "bodyText": "I wonder executeDeleteWith would become very specific to only use thread-pool for delete operation. What if we have some task in the operation, where the same thread pool can be re-used.", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r466539554", "createdAt": "2020-08-06T16:35:11Z", "author": {"login": "mehtaashish23"}, "path": "spark/src/main/java/org/apache/iceberg/actions/ExpireSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Consumer;\n+import org.apache.iceberg.ExpireSnapshots;\n+import org.apache.iceberg.HasTableOperations;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.exceptions.NotFoundException;\n+import org.apache.iceberg.relocated.com.google.common.util.concurrent.MoreExecutors;\n+import org.apache.iceberg.util.Tasks;\n+import org.apache.spark.sql.Column;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SparkSession;\n+import org.apache.spark.sql.functions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ExpireSnapshotsAction extends BaseAction<ExpireSnapshotsActionResult> {\n+  private static final Logger LOG = LoggerFactory.getLogger(ExpireSnapshotsAction.class);\n+\n+  private static final String DATA_FILE = \"Data File\";\n+  private static final String MANIFEST = \"Manifest\";\n+  private static final String MANIFEST_LIST = \"Manifest List\";\n+\n+  // Creates an executor service that runs each task in the thread that invokes execute/submit.\n+  private static final ExecutorService DEFAULT_DELETE_EXECUTOR_SERVICE = MoreExecutors.newDirectExecutorService();\n+\n+  private final SparkSession spark;\n+  private final Table table;\n+  private final TableOperations ops;\n+  private final Consumer<String> defaultDelete = new Consumer<String>() {\n+    @Override\n+    public void accept(String file) {\n+      ops.io().deleteFile(file);\n+    }\n+  };\n+\n+  private Long expireSnapshotIdValue = null;\n+  private Long expireOlderThanValue = null;\n+  private Integer retainLastValue = null;\n+  private Consumer<String> deleteFunc = defaultDelete;\n+  private ExecutorService deleteExecutorService = DEFAULT_DELETE_EXECUTOR_SERVICE;\n+\n+  ExpireSnapshotsAction(SparkSession spark, Table table) {\n+    this.spark = spark;\n+    this.table = table;\n+    this.ops = ((HasTableOperations) table).operations();\n+  }\n+\n+  @Override\n+  protected Table table() {\n+    return table;\n+  }\n+\n+  /**\n+   * An executor service used when deleting files. Only used during the local delete phase of this Spark action\n+   * @param executorService the service to use\n+   * @return this for method chaining\n+   */\n+  public ExpireSnapshotsAction executeDeleteWith(ExecutorService executorService) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUxMjc5MA=="}, "originalCommit": {"oid": "2e0af0a1121d923978344676d593e46d89686962"}, "originalPosition": 83}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYyNjg4OTkz", "url": "https://github.com/apache/iceberg/pull/1264#pullrequestreview-462688993", "createdAt": "2020-08-06T16:39:59Z", "commit": {"oid": "2e0af0a1121d923978344676d593e46d89686962"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNjozOTo1OVrOG87fQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNjozOTo1OVrOG87fQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU0MjQwMg==", "bodyText": "same here.", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r466542402", "createdAt": "2020-08-06T16:39:59Z", "author": {"login": "mehtaashish23"}, "path": "spark/src/main/java/org/apache/iceberg/actions/ExpireSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Consumer;\n+import org.apache.iceberg.ExpireSnapshots;\n+import org.apache.iceberg.HasTableOperations;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.exceptions.NotFoundException;\n+import org.apache.iceberg.relocated.com.google.common.util.concurrent.MoreExecutors;\n+import org.apache.iceberg.util.Tasks;\n+import org.apache.spark.sql.Column;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SparkSession;\n+import org.apache.spark.sql.functions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ExpireSnapshotsAction extends BaseAction<ExpireSnapshotsActionResult> {\n+  private static final Logger LOG = LoggerFactory.getLogger(ExpireSnapshotsAction.class);\n+\n+  private static final String DATA_FILE = \"Data File\";\n+  private static final String MANIFEST = \"Manifest\";\n+  private static final String MANIFEST_LIST = \"Manifest List\";\n+\n+  // Creates an executor service that runs each task in the thread that invokes execute/submit.\n+  private static final ExecutorService DEFAULT_DELETE_EXECUTOR_SERVICE = MoreExecutors.newDirectExecutorService();\n+\n+  private final SparkSession spark;\n+  private final Table table;\n+  private final TableOperations ops;\n+  private final Consumer<String> defaultDelete = new Consumer<String>() {\n+    @Override\n+    public void accept(String file) {\n+      ops.io().deleteFile(file);\n+    }\n+  };\n+\n+  private Long expireSnapshotIdValue = null;\n+  private Long expireOlderThanValue = null;\n+  private Integer retainLastValue = null;\n+  private Consumer<String> deleteFunc = defaultDelete;\n+  private ExecutorService deleteExecutorService = DEFAULT_DELETE_EXECUTOR_SERVICE;\n+\n+  ExpireSnapshotsAction(SparkSession spark, Table table) {\n+    this.spark = spark;\n+    this.table = table;\n+    this.ops = ((HasTableOperations) table).operations();\n+  }\n+\n+  @Override\n+  protected Table table() {\n+    return table;\n+  }\n+\n+  /**\n+   * An executor service used when deleting files. Only used during the local delete phase of this Spark action\n+   * @param executorService the service to use\n+   * @return this for method chaining\n+   */\n+  public ExpireSnapshotsAction executeDeleteWith(ExecutorService executorService) {\n+    this.deleteExecutorService = executorService;\n+    return this;\n+  }\n+\n+  public ExpireSnapshotsAction expireSnapshotId(long expireSnapshotId) {\n+    this.expireSnapshotIdValue = expireSnapshotId;\n+    return this;\n+  }\n+\n+  public ExpireSnapshotsAction expireOlderThan(long timestampMillis) {\n+    this.expireOlderThanValue = timestampMillis;\n+    return this;\n+  }\n+\n+  public ExpireSnapshotsAction retainLast(int numSnapshots) {\n+    this.retainLastValue = numSnapshots;\n+    return this;\n+  }\n+\n+  public ExpireSnapshotsAction deleteWith(Consumer<String> newDeleteFunc) {\n+    this.deleteFunc = newDeleteFunc;\n+    return this;\n+  }\n+\n+  @Override\n+  public ExpireSnapshotsActionResult execute() {\n+    //Metadata before Expiration\n+    Dataset<Row> originalFiles = buildValidFileDF().persist();\n+    originalFiles.count(); // Action to trigger persist\n+\n+    //Perform Expiration\n+    ExpireSnapshots expireSnaps = table.expireSnapshots().cleanExpiredFiles(false);\n+    if (expireSnapshotIdValue != null) {\n+      expireSnaps = expireSnaps.expireSnapshotId(expireSnapshotIdValue);\n+    }\n+    if (expireOlderThanValue != null) {\n+      expireSnaps = expireSnaps.expireOlderThan(expireOlderThanValue);\n+    }\n+    if (retainLastValue != null) {\n+      expireSnaps = expireSnaps.retainLast(retainLastValue);\n+    }\n+    expireSnaps.commit();\n+\n+    // Metadata after Expiration\n+    Dataset<Row> validFiles = buildValidFileDF();\n+    Dataset<Row> filesToDelete = originalFiles.except(validFiles);\n+\n+    ExpireSnapshotsActionResult result =  deleteFiles(filesToDelete.toLocalIterator());\n+    originalFiles.unpersist();\n+    return result;\n+  }\n+\n+  private Dataset<Row> appendTypeString(Dataset<Row> ds, String type) {\n+    return ds.select(new Column(\"file_path\"), functions.lit(type).as(\"file_type\"));\n+  }\n+\n+  private Dataset<Row> buildValidFileDF() {\n+    return appendTypeString(buildValidDataFileDF(spark), DATA_FILE)\n+        .union(appendTypeString(buildManifestFileDF(spark), MANIFEST))\n+        .union(appendTypeString(buildManifestListDF(spark, table), MANIFEST_LIST));\n+  }\n+\n+  private ExpireSnapshotsActionResult deleteFiles(Iterator<Row> paths) {\n+    AtomicLong dataFileCount = new AtomicLong(0L);\n+    AtomicLong manifestCount = new AtomicLong(0L);\n+    AtomicLong manifestListCount = new AtomicLong(0L);\n+\n+    Tasks.foreach(paths)\n+        .retry(3).stopRetryOn(NotFoundException.class).suppressFailureWhenFinished()\n+        .executeWith(deleteExecutorService)\n+        .onFailure((fileInfo, exc) ->\n+            LOG.warn(\"Delete failed for {}: {}\", fileInfo.getString(1), fileInfo.getString(0), exc))\n+        .run(fileInfo -> {\n+          String file = fileInfo.getString(0);\n+          String type = fileInfo.getString(1);\n+          deleteFunc.accept(file);\n+          switch (type) {\n+            case DATA_FILE:\n+              dataFileCount.incrementAndGet();\n+              LOG.trace(\"Deleted Data File: {}\", file);\n+              break;\n+            case MANIFEST:\n+              manifestCount.incrementAndGet();\n+              LOG.warn(\"Deleted Manifest: {}\", file);\n+              break;\n+            case MANIFEST_LIST:\n+              manifestListCount.incrementAndGet();\n+              LOG.warn(\"Deleted Manifest List: {}\", file);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e0af0a1121d923978344676d593e46d89686962"}, "originalPosition": 171}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e73f76971caa117d3fbadf8c70450f46a8ef51a2", "author": {"user": {"login": "RussellSpitzer", "name": "Russell Spitzer"}}, "url": "https://github.com/apache/iceberg/commit/e73f76971caa117d3fbadf8c70450f46a8ef51a2", "committedDate": "2020-08-07T00:07:13Z", "message": "Port over all the tests from TestRemoveSnapshots"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzMzA2NTM2", "url": "https://github.com/apache/iceberg/pull/1264#pullrequestreview-463306536", "createdAt": "2020-08-07T13:21:26Z", "commit": {"oid": "e73f76971caa117d3fbadf8c70450f46a8ef51a2"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxMzoyMToyNlrOG9ZnQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNDoxMzo0MVrOG9bgsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzAzNTk2OQ==", "bodyText": "Sounds like creating manifestLists can be placed in core module, so that it can be reused from action for other execution engine, or even without engine-specific action.", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r467035969", "createdAt": "2020-08-07T13:21:26Z", "author": {"login": "HeartSaVioR"}, "path": "spark/src/main/java/org/apache/iceberg/actions/BaseAction.java", "diffHunk": "@@ -41,4 +51,47 @@ protected String metadataTableName(MetadataTableType type) {\n       return tableName + \".\" + type;\n     }\n   }\n+\n+  protected Dataset<Row> buildValidDataFileDF(SparkSession spark) {\n+    String allDataFilesMetadataTable = metadataTableName(MetadataTableType.ALL_DATA_FILES);\n+    return spark.read().format(\"iceberg\").load(allDataFilesMetadataTable).select(\"file_path\");\n+  }\n+\n+  protected Dataset<Row> buildManifestFileDF(SparkSession spark) {\n+    String allManifestsMetadataTable = metadataTableName(MetadataTableType.ALL_MANIFESTS);\n+    return spark.read().format(\"iceberg\").load(allManifestsMetadataTable).selectExpr(\"path as file_path\");\n+  }\n+\n+  protected Dataset<Row> buildManifestListDF(SparkSession spark, Table table) {\n+    List<String> manifestLists = Lists.newArrayList();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e73f76971caa117d3fbadf8c70450f46a8ef51a2"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzAzNjQxMw==", "bodyText": "Ditto.", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r467036413", "createdAt": "2020-08-07T13:22:13Z", "author": {"login": "HeartSaVioR"}, "path": "spark/src/main/java/org/apache/iceberg/actions/BaseAction.java", "diffHunk": "@@ -41,4 +51,47 @@ protected String metadataTableName(MetadataTableType type) {\n       return tableName + \".\" + type;\n     }\n   }\n+\n+  protected Dataset<Row> buildValidDataFileDF(SparkSession spark) {\n+    String allDataFilesMetadataTable = metadataTableName(MetadataTableType.ALL_DATA_FILES);\n+    return spark.read().format(\"iceberg\").load(allDataFilesMetadataTable).select(\"file_path\");\n+  }\n+\n+  protected Dataset<Row> buildManifestFileDF(SparkSession spark) {\n+    String allManifestsMetadataTable = metadataTableName(MetadataTableType.ALL_MANIFESTS);\n+    return spark.read().format(\"iceberg\").load(allManifestsMetadataTable).selectExpr(\"path as file_path\");\n+  }\n+\n+  protected Dataset<Row> buildManifestListDF(SparkSession spark, Table table) {\n+    List<String> manifestLists = Lists.newArrayList();\n+    for (Snapshot snapshot : table.snapshots()) {\n+      String manifestListLocation = snapshot.manifestListLocation();\n+      if (manifestListLocation != null) {\n+        manifestLists.add(manifestListLocation);\n+      }\n+    }\n+\n+    return spark.createDataset(manifestLists, Encoders.STRING()).toDF(\"file_path\");\n+  }\n+\n+  protected Dataset<Row> buildOtherMetadataFileDF(SparkSession spark, TableOperations ops) {\n+    List<String> otherMetadataFiles = Lists.newArrayList();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e73f76971caa117d3fbadf8c70450f46a8ef51a2"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA0MTIxMQ==", "bodyText": "\"apply that\" seems redundant.", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r467041211", "createdAt": "2020-08-07T13:30:38Z", "author": {"login": "HeartSaVioR"}, "path": "spark/src/main/java/org/apache/iceberg/actions/ExpireSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Consumer;\n+import org.apache.iceberg.ExpireSnapshots;\n+import org.apache.iceberg.HasTableOperations;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.exceptions.NotFoundException;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.util.concurrent.MoreExecutors;\n+import org.apache.iceberg.util.Tasks;\n+import org.apache.spark.sql.Column;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SparkSession;\n+import org.apache.spark.sql.functions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * An action which performs the same operation as {@link org.apache.iceberg.ExpireSnapshots} but uses Spark\n+ * to to determine the delta in files between the pre and post-expiration table metadata. All of the same\n+ * restrictions apply that apply to Remove Snapshots.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e73f76971caa117d3fbadf8c70450f46a8ef51a2"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA0Mjc2OA==", "bodyText": "nit: MetadataTables -> metadata tables", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r467042768", "createdAt": "2020-08-07T13:33:22Z", "author": {"login": "HeartSaVioR"}, "path": "spark/src/main/java/org/apache/iceberg/actions/ExpireSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Consumer;\n+import org.apache.iceberg.ExpireSnapshots;\n+import org.apache.iceberg.HasTableOperations;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.exceptions.NotFoundException;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.util.concurrent.MoreExecutors;\n+import org.apache.iceberg.util.Tasks;\n+import org.apache.spark.sql.Column;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SparkSession;\n+import org.apache.spark.sql.functions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * An action which performs the same operation as {@link org.apache.iceberg.ExpireSnapshots} but uses Spark\n+ * to to determine the delta in files between the pre and post-expiration table metadata. All of the same\n+ * restrictions apply that apply to Remove Snapshots.\n+ * <p>\n+ * This implementation uses the MetadataTables for the table being expired to list all Manifest and DataFiles. This", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e73f76971caa117d3fbadf8c70450f46a8ef51a2"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA0Mzc4OQ==", "bodyText": "nit: Dataframes which are anti-joined", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r467043789", "createdAt": "2020-08-07T13:35:02Z", "author": {"login": "HeartSaVioR"}, "path": "spark/src/main/java/org/apache/iceberg/actions/ExpireSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Consumer;\n+import org.apache.iceberg.ExpireSnapshots;\n+import org.apache.iceberg.HasTableOperations;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.exceptions.NotFoundException;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.util.concurrent.MoreExecutors;\n+import org.apache.iceberg.util.Tasks;\n+import org.apache.spark.sql.Column;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SparkSession;\n+import org.apache.spark.sql.functions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * An action which performs the same operation as {@link org.apache.iceberg.ExpireSnapshots} but uses Spark\n+ * to to determine the delta in files between the pre and post-expiration table metadata. All of the same\n+ * restrictions apply that apply to Remove Snapshots.\n+ * <p>\n+ * This implementation uses the MetadataTables for the table being expired to list all Manifest and DataFiles. This\n+ * is made into a Dataframe which is antiJoined with the same list read after the expiration. This operation will", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e73f76971caa117d3fbadf8c70450f46a8ef51a2"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA0NTI2OQ==", "bodyText": "nit: Shuffle -> shuffle, so -> , and", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r467045269", "createdAt": "2020-08-07T13:37:29Z", "author": {"login": "HeartSaVioR"}, "path": "spark/src/main/java/org/apache/iceberg/actions/ExpireSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Consumer;\n+import org.apache.iceberg.ExpireSnapshots;\n+import org.apache.iceberg.HasTableOperations;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.exceptions.NotFoundException;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.util.concurrent.MoreExecutors;\n+import org.apache.iceberg.util.Tasks;\n+import org.apache.spark.sql.Column;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SparkSession;\n+import org.apache.spark.sql.functions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * An action which performs the same operation as {@link org.apache.iceberg.ExpireSnapshots} but uses Spark\n+ * to to determine the delta in files between the pre and post-expiration table metadata. All of the same\n+ * restrictions apply that apply to Remove Snapshots.\n+ * <p>\n+ * This implementation uses the MetadataTables for the table being expired to list all Manifest and DataFiles. This\n+ * is made into a Dataframe which is antiJoined with the same list read after the expiration. This operation will\n+ * require a Shuffle so parallelism can be controlled through spark.sql.shuffle.partitions. The expiration is done", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e73f76971caa117d3fbadf8c70450f46a8ef51a2"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA0NjMzNA==", "bodyText": "Probably it'd be nice to describe about expiring snapshots and removing obsolete files sequentially, not mixing up.", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r467046334", "createdAt": "2020-08-07T13:39:22Z", "author": {"login": "HeartSaVioR"}, "path": "spark/src/main/java/org/apache/iceberg/actions/ExpireSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Consumer;\n+import org.apache.iceberg.ExpireSnapshots;\n+import org.apache.iceberg.HasTableOperations;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.exceptions.NotFoundException;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.util.concurrent.MoreExecutors;\n+import org.apache.iceberg.util.Tasks;\n+import org.apache.spark.sql.Column;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SparkSession;\n+import org.apache.spark.sql.functions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * An action which performs the same operation as {@link org.apache.iceberg.ExpireSnapshots} but uses Spark\n+ * to to determine the delta in files between the pre and post-expiration table metadata. All of the same\n+ * restrictions apply that apply to Remove Snapshots.\n+ * <p>\n+ * This implementation uses the MetadataTables for the table being expired to list all Manifest and DataFiles. This\n+ * is made into a Dataframe which is antiJoined with the same list read after the expiration. This operation will\n+ * require a Shuffle so parallelism can be controlled through spark.sql.shuffle.partitions. The expiration is done", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e73f76971caa117d3fbadf8c70450f46a8ef51a2"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA0NjUxMA==", "bodyText": "nit: Spark executors", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r467046510", "createdAt": "2020-08-07T13:39:40Z", "author": {"login": "HeartSaVioR"}, "path": "spark/src/main/java/org/apache/iceberg/actions/ExpireSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Consumer;\n+import org.apache.iceberg.ExpireSnapshots;\n+import org.apache.iceberg.HasTableOperations;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.exceptions.NotFoundException;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.util.concurrent.MoreExecutors;\n+import org.apache.iceberg.util.Tasks;\n+import org.apache.spark.sql.Column;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SparkSession;\n+import org.apache.spark.sql.functions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * An action which performs the same operation as {@link org.apache.iceberg.ExpireSnapshots} but uses Spark\n+ * to to determine the delta in files between the pre and post-expiration table metadata. All of the same\n+ * restrictions apply that apply to Remove Snapshots.\n+ * <p>\n+ * This implementation uses the MetadataTables for the table being expired to list all Manifest and DataFiles. This\n+ * is made into a Dataframe which is antiJoined with the same list read after the expiration. This operation will\n+ * require a Shuffle so parallelism can be controlled through spark.sql.shuffle.partitions. The expiration is done\n+ * locally using a direct call to RemoveSnapshots. Deletes are still performed locally after retrieving the results\n+ * from the SparkExecutors.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e73f76971caa117d3fbadf8c70450f46a8ef51a2"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA2NzA1Ng==", "bodyText": "nit: double empty lines", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r467067056", "createdAt": "2020-08-07T14:13:41Z", "author": {"login": "HeartSaVioR"}, "path": "spark/src/test/java/org/apache/iceberg/actions/TestExpireSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,781 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.BaseTable;\n+import org.apache.iceberg.DataFile;\n+import org.apache.iceberg.DataFiles;\n+import org.apache.iceberg.PartitionSpec;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.Snapshot;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableProperties;\n+import org.apache.iceberg.hadoop.HadoopTables;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableSet;\n+import org.apache.iceberg.relocated.com.google.common.collect.Iterables;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.relocated.com.google.common.collect.Sets;\n+import org.apache.iceberg.spark.SparkTestBase;\n+import org.apache.iceberg.spark.source.ThreeColumnRecord;\n+import org.apache.iceberg.types.Types;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import static org.apache.iceberg.types.Types.NestedField.optional;\n+\n+public abstract class TestExpireSnapshotsAction extends SparkTestBase {\n+\n+  private static final HadoopTables TABLES = new HadoopTables(new Configuration());\n+  private static final Schema SCHEMA = new Schema(\n+      optional(1, \"c1\", Types.IntegerType.get()),\n+      optional(2, \"c2\", Types.StringType.get()),\n+      optional(3, \"c3\", Types.StringType.get())\n+  );\n+\n+  private static final PartitionSpec SPEC = PartitionSpec.builderFor(SCHEMA).identity(\"c1\").build();\n+\n+  private static final List<ThreeColumnRecord> RECORDS = Lists.newArrayList(new ThreeColumnRecord(1, \"AAAA\", \"AAAA\"));\n+\n+  static final DataFile FILE_A = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-a.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=0\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+  static final DataFile FILE_B = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-b.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=1\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+  static final DataFile FILE_C = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-c.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=2\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+  static final DataFile FILE_D = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-d.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=3\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+\n+  @Rule\n+  public TemporaryFolder temp = new TemporaryFolder();\n+\n+  private File tableDir;\n+  private String tableLocation;\n+  private Table table;\n+\n+  @Before\n+  public void setupTableLocation() throws Exception {\n+    this.tableDir = temp.newFolder();\n+    this.tableLocation = tableDir.toURI().toString();\n+    this.table = TABLES.create(SCHEMA, SPEC, Maps.newHashMap(), tableLocation);\n+  }\n+\n+  private Dataset<Row> buildDF(List<ThreeColumnRecord> records) {\n+    return spark.createDataFrame(records, ThreeColumnRecord.class).coalesce(1);\n+  }\n+\n+  private void writeDF(Dataset<Row> df, String mode) {\n+    df.select(\"c1\", \"c2\", \"c3\")\n+        .write()\n+        .format(\"iceberg\")\n+        .mode(mode)\n+        .save(tableLocation);\n+  }\n+\n+  private void checkExpirationResults(Long expectedDatafiles, Long expectedManifestsDeleted,\n+      Long expectedManifestListsDeleted, ExpireSnapshotsActionResult results) {\n+\n+    Assert.assertEquals(\"Incorrect number of manifest files deleted\",\n+        expectedManifestsDeleted, results.getManifestFilesDeleted());\n+    Assert.assertEquals(\"Incorrect number of datafiles deleted\",\n+        expectedDatafiles, results.getDataFilesDeleted());\n+    Assert.assertEquals(\"Incorrect number of manifest lists deleted\",\n+        expectedManifestListsDeleted, results.getManifestListsDeleted());\n+  }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e73f76971caa117d3fbadf8c70450f46a8ef51a2"}, "originalPosition": 138}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9cc4e831679d0aab1e4409210f3a7c57094c440c", "author": {"user": {"login": "RussellSpitzer", "name": "Russell Spitzer"}}, "url": "https://github.com/apache/iceberg/commit/9cc4e831679d0aab1e4409210f3a7c57094c440c", "committedDate": "2020-08-07T15:38:45Z", "message": "Review Comments\n\nMove getManifestLists / getOtherManifestPaths to Core Module\nFixup of doc typos"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzNDE0MDc1", "url": "https://github.com/apache/iceberg/pull/1264#pullrequestreview-463414075", "createdAt": "2020-08-07T15:41:52Z", "commit": {"oid": "9cc4e831679d0aab1e4409210f3a7c57094c440c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNTo0MTo1MlrOG9er_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNTo0MTo1MlrOG9er_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzExOTEwMw==", "bodyText": "Partitioning changed from TestTableBase to match the schema I was using here", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r467119103", "createdAt": "2020-08-07T15:41:52Z", "author": {"login": "RussellSpitzer"}, "path": "spark/src/test/java/org/apache/iceberg/actions/TestExpireSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,780 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.BaseTable;\n+import org.apache.iceberg.DataFile;\n+import org.apache.iceberg.DataFiles;\n+import org.apache.iceberg.PartitionSpec;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.Snapshot;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableProperties;\n+import org.apache.iceberg.hadoop.HadoopTables;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableSet;\n+import org.apache.iceberg.relocated.com.google.common.collect.Iterables;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.relocated.com.google.common.collect.Sets;\n+import org.apache.iceberg.spark.SparkTestBase;\n+import org.apache.iceberg.spark.source.ThreeColumnRecord;\n+import org.apache.iceberg.types.Types;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import static org.apache.iceberg.types.Types.NestedField.optional;\n+\n+public abstract class TestExpireSnapshotsAction extends SparkTestBase {\n+\n+  private static final HadoopTables TABLES = new HadoopTables(new Configuration());\n+  private static final Schema SCHEMA = new Schema(\n+      optional(1, \"c1\", Types.IntegerType.get()),\n+      optional(2, \"c2\", Types.StringType.get()),\n+      optional(3, \"c3\", Types.StringType.get())\n+  );\n+\n+  private static final PartitionSpec SPEC = PartitionSpec.builderFor(SCHEMA).identity(\"c1\").build();\n+\n+  private static final List<ThreeColumnRecord> RECORDS = Lists.newArrayList(new ThreeColumnRecord(1, \"AAAA\", \"AAAA\"));\n+\n+  static final DataFile FILE_A = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-a.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=0\") // easy way to set partition data for now", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9cc4e831679d0aab1e4409210f3a7c57094c440c"}, "originalPosition": 80}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzNDE0NjQz", "url": "https://github.com/apache/iceberg/pull/1264#pullrequestreview-463414643", "createdAt": "2020-08-07T15:42:43Z", "commit": {"oid": "9cc4e831679d0aab1e4409210f3a7c57094c440c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNTo0Mjo0M1rOG9ettg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNTo0Mjo0M1rOG9ettg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzExOTU0Mg==", "bodyText": "Manual metadata rewrite code removed from here since it wasn't really part of the test and I couldn't easily move those functions into Spark module", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r467119542", "createdAt": "2020-08-07T15:42:43Z", "author": {"login": "RussellSpitzer"}, "path": "spark/src/test/java/org/apache/iceberg/actions/TestExpireSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,780 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.BaseTable;\n+import org.apache.iceberg.DataFile;\n+import org.apache.iceberg.DataFiles;\n+import org.apache.iceberg.PartitionSpec;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.Snapshot;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableProperties;\n+import org.apache.iceberg.hadoop.HadoopTables;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableSet;\n+import org.apache.iceberg.relocated.com.google.common.collect.Iterables;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.relocated.com.google.common.collect.Sets;\n+import org.apache.iceberg.spark.SparkTestBase;\n+import org.apache.iceberg.spark.source.ThreeColumnRecord;\n+import org.apache.iceberg.types.Types;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import static org.apache.iceberg.types.Types.NestedField.optional;\n+\n+public abstract class TestExpireSnapshotsAction extends SparkTestBase {\n+\n+  private static final HadoopTables TABLES = new HadoopTables(new Configuration());\n+  private static final Schema SCHEMA = new Schema(\n+      optional(1, \"c1\", Types.IntegerType.get()),\n+      optional(2, \"c2\", Types.StringType.get()),\n+      optional(3, \"c3\", Types.StringType.get())\n+  );\n+\n+  private static final PartitionSpec SPEC = PartitionSpec.builderFor(SCHEMA).identity(\"c1\").build();\n+\n+  private static final List<ThreeColumnRecord> RECORDS = Lists.newArrayList(new ThreeColumnRecord(1, \"AAAA\", \"AAAA\"));\n+\n+  static final DataFile FILE_A = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-a.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=0\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+  static final DataFile FILE_B = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-b.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=1\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+  static final DataFile FILE_C = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-c.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=2\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+  static final DataFile FILE_D = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-d.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=3\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+\n+  @Rule\n+  public TemporaryFolder temp = new TemporaryFolder();\n+\n+  private File tableDir;\n+  private String tableLocation;\n+  private Table table;\n+\n+  @Before\n+  public void setupTableLocation() throws Exception {\n+    this.tableDir = temp.newFolder();\n+    this.tableLocation = tableDir.toURI().toString();\n+    this.table = TABLES.create(SCHEMA, SPEC, Maps.newHashMap(), tableLocation);\n+  }\n+\n+  private Dataset<Row> buildDF(List<ThreeColumnRecord> records) {\n+    return spark.createDataFrame(records, ThreeColumnRecord.class).coalesce(1);\n+  }\n+\n+  private void writeDF(Dataset<Row> df, String mode) {\n+    df.select(\"c1\", \"c2\", \"c3\")\n+        .write()\n+        .format(\"iceberg\")\n+        .mode(mode)\n+        .save(tableLocation);\n+  }\n+\n+  private void checkExpirationResults(Long expectedDatafiles, Long expectedManifestsDeleted,\n+      Long expectedManifestListsDeleted, ExpireSnapshotsActionResult results) {\n+\n+    Assert.assertEquals(\"Incorrect number of manifest files deleted\",\n+        expectedManifestsDeleted, results.getManifestFilesDeleted());\n+    Assert.assertEquals(\"Incorrect number of datafiles deleted\",\n+        expectedDatafiles, results.getDataFilesDeleted());\n+    Assert.assertEquals(\"Incorrect number of manifest lists deleted\",\n+        expectedManifestListsDeleted, results.getManifestListsDeleted());\n+  }\n+\n+  @Test\n+  public void testFilesCleaned() throws Exception {\n+    Dataset<Row> df = buildDF(RECORDS);\n+\n+    writeDF(df, \"append\");\n+\n+    List<Path> expiredDataFiles = Files\n+        .list(tableDir.toPath().resolve(\"data\").resolve(\"c1=1\"))\n+        .collect(Collectors.toList());\n+\n+    Assert.assertEquals(\"There should be a data file to delete but there was none.\",\n+        2, expiredDataFiles.size());\n+\n+    writeDF(df, \"overwrite\");\n+    writeDF(df, \"append\");\n+\n+    long end = System.currentTimeMillis();\n+    while (end <= table.currentSnapshot().timestampMillis()) {\n+      end = System.currentTimeMillis();\n+    }\n+\n+    ExpireSnapshotsActionResult results =\n+        Actions.forTable(table).expireSnapshots().expireOlderThan(end).execute();\n+\n+    table.refresh();\n+\n+    Assert.assertEquals(\"Table does not have 1 snapshot after expiration\", 1, Iterables.size(table.snapshots()));\n+\n+    for (Path p : expiredDataFiles) {\n+      Assert.assertFalse(String.format(\"File %s still exists but should have been deleted\", p),\n+          Files.exists(p));\n+    }\n+\n+    checkExpirationResults(1L, 2L, 2L, results);\n+  }\n+\n+  @Test\n+  public void dataFilesCleanupWithParallelTasks() throws IOException {\n+\n+    table.newFastAppend()\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    table.newFastAppend()\n+        .appendFile(FILE_B)\n+        .commit();\n+\n+    table.newRewrite()\n+        .rewriteFiles(ImmutableSet.of(FILE_B), ImmutableSet.of(FILE_D))\n+        .commit();\n+    long thirdSnapshotId = table.currentSnapshot().snapshotId();\n+\n+    table.newRewrite()\n+        .rewriteFiles(ImmutableSet.of(FILE_A), ImmutableSet.of(FILE_C))\n+        .commit();\n+    long fourthSnapshotId = table.currentSnapshot().snapshotId();\n+\n+    long t4 = System.currentTimeMillis();\n+    while (t4 <= table.currentSnapshot().timestampMillis()) {\n+      t4 = System.currentTimeMillis();\n+    }\n+\n+    Set<String> deletedFiles = Sets.newHashSet();\n+    Set<String> deleteThreads = ConcurrentHashMap.newKeySet();\n+    AtomicInteger deleteThreadsIndex = new AtomicInteger(0);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9cc4e831679d0aab1e4409210f3a7c57094c440c"}, "originalPosition": 204}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzNDE0Nzgw", "url": "https://github.com/apache/iceberg/pull/1264#pullrequestreview-463414780", "createdAt": "2020-08-07T15:42:56Z", "commit": {"oid": "9cc4e831679d0aab1e4409210f3a7c57094c440c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNTo0Mjo1NlrOG9euJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNTo0Mjo1NlrOG9euJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzExOTY1Mg==", "bodyText": "New Test - Not Ported", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r467119652", "createdAt": "2020-08-07T15:42:56Z", "author": {"login": "RussellSpitzer"}, "path": "spark/src/test/java/org/apache/iceberg/actions/TestExpireSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,780 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.BaseTable;\n+import org.apache.iceberg.DataFile;\n+import org.apache.iceberg.DataFiles;\n+import org.apache.iceberg.PartitionSpec;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.Snapshot;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableProperties;\n+import org.apache.iceberg.hadoop.HadoopTables;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableSet;\n+import org.apache.iceberg.relocated.com.google.common.collect.Iterables;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.relocated.com.google.common.collect.Sets;\n+import org.apache.iceberg.spark.SparkTestBase;\n+import org.apache.iceberg.spark.source.ThreeColumnRecord;\n+import org.apache.iceberg.types.Types;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import static org.apache.iceberg.types.Types.NestedField.optional;\n+\n+public abstract class TestExpireSnapshotsAction extends SparkTestBase {\n+\n+  private static final HadoopTables TABLES = new HadoopTables(new Configuration());\n+  private static final Schema SCHEMA = new Schema(\n+      optional(1, \"c1\", Types.IntegerType.get()),\n+      optional(2, \"c2\", Types.StringType.get()),\n+      optional(3, \"c3\", Types.StringType.get())\n+  );\n+\n+  private static final PartitionSpec SPEC = PartitionSpec.builderFor(SCHEMA).identity(\"c1\").build();\n+\n+  private static final List<ThreeColumnRecord> RECORDS = Lists.newArrayList(new ThreeColumnRecord(1, \"AAAA\", \"AAAA\"));\n+\n+  static final DataFile FILE_A = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-a.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=0\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+  static final DataFile FILE_B = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-b.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=1\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+  static final DataFile FILE_C = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-c.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=2\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+  static final DataFile FILE_D = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-d.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=3\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+\n+  @Rule\n+  public TemporaryFolder temp = new TemporaryFolder();\n+\n+  private File tableDir;\n+  private String tableLocation;\n+  private Table table;\n+\n+  @Before\n+  public void setupTableLocation() throws Exception {\n+    this.tableDir = temp.newFolder();\n+    this.tableLocation = tableDir.toURI().toString();\n+    this.table = TABLES.create(SCHEMA, SPEC, Maps.newHashMap(), tableLocation);\n+  }\n+\n+  private Dataset<Row> buildDF(List<ThreeColumnRecord> records) {\n+    return spark.createDataFrame(records, ThreeColumnRecord.class).coalesce(1);\n+  }\n+\n+  private void writeDF(Dataset<Row> df, String mode) {\n+    df.select(\"c1\", \"c2\", \"c3\")\n+        .write()\n+        .format(\"iceberg\")\n+        .mode(mode)\n+        .save(tableLocation);\n+  }\n+\n+  private void checkExpirationResults(Long expectedDatafiles, Long expectedManifestsDeleted,\n+      Long expectedManifestListsDeleted, ExpireSnapshotsActionResult results) {\n+\n+    Assert.assertEquals(\"Incorrect number of manifest files deleted\",\n+        expectedManifestsDeleted, results.getManifestFilesDeleted());\n+    Assert.assertEquals(\"Incorrect number of datafiles deleted\",\n+        expectedDatafiles, results.getDataFilesDeleted());\n+    Assert.assertEquals(\"Incorrect number of manifest lists deleted\",\n+        expectedManifestListsDeleted, results.getManifestListsDeleted());\n+  }\n+\n+  @Test\n+  public void testFilesCleaned() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9cc4e831679d0aab1e4409210f3a7c57094c440c"}, "originalPosition": 140}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzNDE0OTUy", "url": "https://github.com/apache/iceberg/pull/1264#pullrequestreview-463414952", "createdAt": "2020-08-07T15:43:10Z", "commit": {"oid": "9cc4e831679d0aab1e4409210f3a7c57094c440c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNTo0MzoxMVrOG9eumg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNTo0MzoxMVrOG9eumg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzExOTc3MA==", "bodyText": "New test - Not Ported", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r467119770", "createdAt": "2020-08-07T15:43:11Z", "author": {"login": "RussellSpitzer"}, "path": "spark/src/test/java/org/apache/iceberg/actions/TestExpireSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,780 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.BaseTable;\n+import org.apache.iceberg.DataFile;\n+import org.apache.iceberg.DataFiles;\n+import org.apache.iceberg.PartitionSpec;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.Snapshot;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableProperties;\n+import org.apache.iceberg.hadoop.HadoopTables;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableSet;\n+import org.apache.iceberg.relocated.com.google.common.collect.Iterables;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.relocated.com.google.common.collect.Sets;\n+import org.apache.iceberg.spark.SparkTestBase;\n+import org.apache.iceberg.spark.source.ThreeColumnRecord;\n+import org.apache.iceberg.types.Types;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import static org.apache.iceberg.types.Types.NestedField.optional;\n+\n+public abstract class TestExpireSnapshotsAction extends SparkTestBase {\n+\n+  private static final HadoopTables TABLES = new HadoopTables(new Configuration());\n+  private static final Schema SCHEMA = new Schema(\n+      optional(1, \"c1\", Types.IntegerType.get()),\n+      optional(2, \"c2\", Types.StringType.get()),\n+      optional(3, \"c3\", Types.StringType.get())\n+  );\n+\n+  private static final PartitionSpec SPEC = PartitionSpec.builderFor(SCHEMA).identity(\"c1\").build();\n+\n+  private static final List<ThreeColumnRecord> RECORDS = Lists.newArrayList(new ThreeColumnRecord(1, \"AAAA\", \"AAAA\"));\n+\n+  static final DataFile FILE_A = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-a.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=0\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+  static final DataFile FILE_B = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-b.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=1\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+  static final DataFile FILE_C = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-c.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=2\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+  static final DataFile FILE_D = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-d.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=3\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+\n+  @Rule\n+  public TemporaryFolder temp = new TemporaryFolder();\n+\n+  private File tableDir;\n+  private String tableLocation;\n+  private Table table;\n+\n+  @Before\n+  public void setupTableLocation() throws Exception {\n+    this.tableDir = temp.newFolder();\n+    this.tableLocation = tableDir.toURI().toString();\n+    this.table = TABLES.create(SCHEMA, SPEC, Maps.newHashMap(), tableLocation);\n+  }\n+\n+  private Dataset<Row> buildDF(List<ThreeColumnRecord> records) {\n+    return spark.createDataFrame(records, ThreeColumnRecord.class).coalesce(1);\n+  }\n+\n+  private void writeDF(Dataset<Row> df, String mode) {\n+    df.select(\"c1\", \"c2\", \"c3\")\n+        .write()\n+        .format(\"iceberg\")\n+        .mode(mode)\n+        .save(tableLocation);\n+  }\n+\n+  private void checkExpirationResults(Long expectedDatafiles, Long expectedManifestsDeleted,\n+      Long expectedManifestListsDeleted, ExpireSnapshotsActionResult results) {\n+\n+    Assert.assertEquals(\"Incorrect number of manifest files deleted\",\n+        expectedManifestsDeleted, results.getManifestFilesDeleted());\n+    Assert.assertEquals(\"Incorrect number of datafiles deleted\",\n+        expectedDatafiles, results.getDataFilesDeleted());\n+    Assert.assertEquals(\"Incorrect number of manifest lists deleted\",\n+        expectedManifestListsDeleted, results.getManifestListsDeleted());\n+  }\n+\n+  @Test\n+  public void testFilesCleaned() throws Exception {\n+    Dataset<Row> df = buildDF(RECORDS);\n+\n+    writeDF(df, \"append\");\n+\n+    List<Path> expiredDataFiles = Files\n+        .list(tableDir.toPath().resolve(\"data\").resolve(\"c1=1\"))\n+        .collect(Collectors.toList());\n+\n+    Assert.assertEquals(\"There should be a data file to delete but there was none.\",\n+        2, expiredDataFiles.size());\n+\n+    writeDF(df, \"overwrite\");\n+    writeDF(df, \"append\");\n+\n+    long end = System.currentTimeMillis();\n+    while (end <= table.currentSnapshot().timestampMillis()) {\n+      end = System.currentTimeMillis();\n+    }\n+\n+    ExpireSnapshotsActionResult results =\n+        Actions.forTable(table).expireSnapshots().expireOlderThan(end).execute();\n+\n+    table.refresh();\n+\n+    Assert.assertEquals(\"Table does not have 1 snapshot after expiration\", 1, Iterables.size(table.snapshots()));\n+\n+    for (Path p : expiredDataFiles) {\n+      Assert.assertFalse(String.format(\"File %s still exists but should have been deleted\", p),\n+          Files.exists(p));\n+    }\n+\n+    checkExpirationResults(1L, 2L, 2L, results);\n+  }\n+\n+  @Test\n+  public void dataFilesCleanupWithParallelTasks() throws IOException {\n+\n+    table.newFastAppend()\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    table.newFastAppend()\n+        .appendFile(FILE_B)\n+        .commit();\n+\n+    table.newRewrite()\n+        .rewriteFiles(ImmutableSet.of(FILE_B), ImmutableSet.of(FILE_D))\n+        .commit();\n+    long thirdSnapshotId = table.currentSnapshot().snapshotId();\n+\n+    table.newRewrite()\n+        .rewriteFiles(ImmutableSet.of(FILE_A), ImmutableSet.of(FILE_C))\n+        .commit();\n+    long fourthSnapshotId = table.currentSnapshot().snapshotId();\n+\n+    long t4 = System.currentTimeMillis();\n+    while (t4 <= table.currentSnapshot().timestampMillis()) {\n+      t4 = System.currentTimeMillis();\n+    }\n+\n+    Set<String> deletedFiles = Sets.newHashSet();\n+    Set<String> deleteThreads = ConcurrentHashMap.newKeySet();\n+    AtomicInteger deleteThreadsIndex = new AtomicInteger(0);\n+\n+    Actions.forTable(table).expireSnapshots()\n+        .executeDeleteWith(Executors.newFixedThreadPool(4, runnable -> {\n+          Thread thread = new Thread(runnable);\n+          thread.setName(\"remove-snapshot-\" + deleteThreadsIndex.getAndIncrement());\n+          thread.setDaemon(true); // daemon threads will be terminated abruptly when the JVM exits\n+          return thread;\n+        }))\n+        .expireOlderThan(t4)\n+        .deleteWith(s -> {\n+          deleteThreads.add(Thread.currentThread().getName());\n+          deletedFiles.add(s);\n+        })\n+        .execute();\n+\n+    // Verifies that the delete methods ran in the threads created by the provided ExecutorService ThreadFactory\n+    Assert.assertEquals(deleteThreads,\n+        Sets.newHashSet(\"remove-snapshot-0\", \"remove-snapshot-1\", \"remove-snapshot-2\", \"remove-snapshot-3\"));\n+\n+    Assert.assertTrue(\"FILE_A should be deleted\", deletedFiles.contains(FILE_A.path().toString()));\n+    Assert.assertTrue(\"FILE_B should be deleted\", deletedFiles.contains(FILE_B.path().toString()));\n+  }\n+\n+  @Test\n+  public void testNoFilesDeletedWhenNoSnapshotsExpired() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9cc4e831679d0aab1e4409210f3a7c57094c440c"}, "originalPosition": 228}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzNDE1MDk5", "url": "https://github.com/apache/iceberg/pull/1264#pullrequestreview-463415099", "createdAt": "2020-08-07T15:43:21Z", "commit": {"oid": "9cc4e831679d0aab1e4409210f3a7c57094c440c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNTo0MzoyMVrOG9evCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNTo0MzoyMVrOG9evCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzExOTg4MA==", "bodyText": "New test - Not Ported", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r467119880", "createdAt": "2020-08-07T15:43:21Z", "author": {"login": "RussellSpitzer"}, "path": "spark/src/test/java/org/apache/iceberg/actions/TestExpireSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,780 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.BaseTable;\n+import org.apache.iceberg.DataFile;\n+import org.apache.iceberg.DataFiles;\n+import org.apache.iceberg.PartitionSpec;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.Snapshot;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableProperties;\n+import org.apache.iceberg.hadoop.HadoopTables;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableSet;\n+import org.apache.iceberg.relocated.com.google.common.collect.Iterables;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.relocated.com.google.common.collect.Sets;\n+import org.apache.iceberg.spark.SparkTestBase;\n+import org.apache.iceberg.spark.source.ThreeColumnRecord;\n+import org.apache.iceberg.types.Types;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import static org.apache.iceberg.types.Types.NestedField.optional;\n+\n+public abstract class TestExpireSnapshotsAction extends SparkTestBase {\n+\n+  private static final HadoopTables TABLES = new HadoopTables(new Configuration());\n+  private static final Schema SCHEMA = new Schema(\n+      optional(1, \"c1\", Types.IntegerType.get()),\n+      optional(2, \"c2\", Types.StringType.get()),\n+      optional(3, \"c3\", Types.StringType.get())\n+  );\n+\n+  private static final PartitionSpec SPEC = PartitionSpec.builderFor(SCHEMA).identity(\"c1\").build();\n+\n+  private static final List<ThreeColumnRecord> RECORDS = Lists.newArrayList(new ThreeColumnRecord(1, \"AAAA\", \"AAAA\"));\n+\n+  static final DataFile FILE_A = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-a.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=0\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+  static final DataFile FILE_B = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-b.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=1\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+  static final DataFile FILE_C = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-c.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=2\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+  static final DataFile FILE_D = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-d.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=3\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+\n+  @Rule\n+  public TemporaryFolder temp = new TemporaryFolder();\n+\n+  private File tableDir;\n+  private String tableLocation;\n+  private Table table;\n+\n+  @Before\n+  public void setupTableLocation() throws Exception {\n+    this.tableDir = temp.newFolder();\n+    this.tableLocation = tableDir.toURI().toString();\n+    this.table = TABLES.create(SCHEMA, SPEC, Maps.newHashMap(), tableLocation);\n+  }\n+\n+  private Dataset<Row> buildDF(List<ThreeColumnRecord> records) {\n+    return spark.createDataFrame(records, ThreeColumnRecord.class).coalesce(1);\n+  }\n+\n+  private void writeDF(Dataset<Row> df, String mode) {\n+    df.select(\"c1\", \"c2\", \"c3\")\n+        .write()\n+        .format(\"iceberg\")\n+        .mode(mode)\n+        .save(tableLocation);\n+  }\n+\n+  private void checkExpirationResults(Long expectedDatafiles, Long expectedManifestsDeleted,\n+      Long expectedManifestListsDeleted, ExpireSnapshotsActionResult results) {\n+\n+    Assert.assertEquals(\"Incorrect number of manifest files deleted\",\n+        expectedManifestsDeleted, results.getManifestFilesDeleted());\n+    Assert.assertEquals(\"Incorrect number of datafiles deleted\",\n+        expectedDatafiles, results.getDataFilesDeleted());\n+    Assert.assertEquals(\"Incorrect number of manifest lists deleted\",\n+        expectedManifestListsDeleted, results.getManifestListsDeleted());\n+  }\n+\n+  @Test\n+  public void testFilesCleaned() throws Exception {\n+    Dataset<Row> df = buildDF(RECORDS);\n+\n+    writeDF(df, \"append\");\n+\n+    List<Path> expiredDataFiles = Files\n+        .list(tableDir.toPath().resolve(\"data\").resolve(\"c1=1\"))\n+        .collect(Collectors.toList());\n+\n+    Assert.assertEquals(\"There should be a data file to delete but there was none.\",\n+        2, expiredDataFiles.size());\n+\n+    writeDF(df, \"overwrite\");\n+    writeDF(df, \"append\");\n+\n+    long end = System.currentTimeMillis();\n+    while (end <= table.currentSnapshot().timestampMillis()) {\n+      end = System.currentTimeMillis();\n+    }\n+\n+    ExpireSnapshotsActionResult results =\n+        Actions.forTable(table).expireSnapshots().expireOlderThan(end).execute();\n+\n+    table.refresh();\n+\n+    Assert.assertEquals(\"Table does not have 1 snapshot after expiration\", 1, Iterables.size(table.snapshots()));\n+\n+    for (Path p : expiredDataFiles) {\n+      Assert.assertFalse(String.format(\"File %s still exists but should have been deleted\", p),\n+          Files.exists(p));\n+    }\n+\n+    checkExpirationResults(1L, 2L, 2L, results);\n+  }\n+\n+  @Test\n+  public void dataFilesCleanupWithParallelTasks() throws IOException {\n+\n+    table.newFastAppend()\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    table.newFastAppend()\n+        .appendFile(FILE_B)\n+        .commit();\n+\n+    table.newRewrite()\n+        .rewriteFiles(ImmutableSet.of(FILE_B), ImmutableSet.of(FILE_D))\n+        .commit();\n+    long thirdSnapshotId = table.currentSnapshot().snapshotId();\n+\n+    table.newRewrite()\n+        .rewriteFiles(ImmutableSet.of(FILE_A), ImmutableSet.of(FILE_C))\n+        .commit();\n+    long fourthSnapshotId = table.currentSnapshot().snapshotId();\n+\n+    long t4 = System.currentTimeMillis();\n+    while (t4 <= table.currentSnapshot().timestampMillis()) {\n+      t4 = System.currentTimeMillis();\n+    }\n+\n+    Set<String> deletedFiles = Sets.newHashSet();\n+    Set<String> deleteThreads = ConcurrentHashMap.newKeySet();\n+    AtomicInteger deleteThreadsIndex = new AtomicInteger(0);\n+\n+    Actions.forTable(table).expireSnapshots()\n+        .executeDeleteWith(Executors.newFixedThreadPool(4, runnable -> {\n+          Thread thread = new Thread(runnable);\n+          thread.setName(\"remove-snapshot-\" + deleteThreadsIndex.getAndIncrement());\n+          thread.setDaemon(true); // daemon threads will be terminated abruptly when the JVM exits\n+          return thread;\n+        }))\n+        .expireOlderThan(t4)\n+        .deleteWith(s -> {\n+          deleteThreads.add(Thread.currentThread().getName());\n+          deletedFiles.add(s);\n+        })\n+        .execute();\n+\n+    // Verifies that the delete methods ran in the threads created by the provided ExecutorService ThreadFactory\n+    Assert.assertEquals(deleteThreads,\n+        Sets.newHashSet(\"remove-snapshot-0\", \"remove-snapshot-1\", \"remove-snapshot-2\", \"remove-snapshot-3\"));\n+\n+    Assert.assertTrue(\"FILE_A should be deleted\", deletedFiles.contains(FILE_A.path().toString()));\n+    Assert.assertTrue(\"FILE_B should be deleted\", deletedFiles.contains(FILE_B.path().toString()));\n+  }\n+\n+  @Test\n+  public void testNoFilesDeletedWhenNoSnapshotsExpired() throws Exception {\n+    Dataset<Row> df = buildDF(RECORDS);\n+\n+    writeDF(df, \"append\");\n+\n+    ExpireSnapshotsActionResult results =\n+        Actions.forTable(table).expireSnapshots().execute();\n+\n+    checkExpirationResults(0L, 0L, 0L, results);\n+  }\n+\n+  @Test\n+  public void testCleanupRepeatedOverwrites() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9cc4e831679d0aab1e4409210f3a7c57094c440c"}, "originalPosition": 240}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzNDE1NTU3", "url": "https://github.com/apache/iceberg/pull/1264#pullrequestreview-463415557", "createdAt": "2020-08-07T15:44:03Z", "commit": {"oid": "9cc4e831679d0aab1e4409210f3a7c57094c440c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNTo0NDowM1rOG9ewZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNTo0NDowM1rOG9ewZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzEyMDIyOA==", "bodyText": "Ported test - everything the same except for the manifest manipulation see comment below", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r467120228", "createdAt": "2020-08-07T15:44:03Z", "author": {"login": "RussellSpitzer"}, "path": "spark/src/test/java/org/apache/iceberg/actions/TestExpireSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,780 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.BaseTable;\n+import org.apache.iceberg.DataFile;\n+import org.apache.iceberg.DataFiles;\n+import org.apache.iceberg.PartitionSpec;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.Snapshot;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableProperties;\n+import org.apache.iceberg.hadoop.HadoopTables;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableSet;\n+import org.apache.iceberg.relocated.com.google.common.collect.Iterables;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.relocated.com.google.common.collect.Sets;\n+import org.apache.iceberg.spark.SparkTestBase;\n+import org.apache.iceberg.spark.source.ThreeColumnRecord;\n+import org.apache.iceberg.types.Types;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import static org.apache.iceberg.types.Types.NestedField.optional;\n+\n+public abstract class TestExpireSnapshotsAction extends SparkTestBase {\n+\n+  private static final HadoopTables TABLES = new HadoopTables(new Configuration());\n+  private static final Schema SCHEMA = new Schema(\n+      optional(1, \"c1\", Types.IntegerType.get()),\n+      optional(2, \"c2\", Types.StringType.get()),\n+      optional(3, \"c3\", Types.StringType.get())\n+  );\n+\n+  private static final PartitionSpec SPEC = PartitionSpec.builderFor(SCHEMA).identity(\"c1\").build();\n+\n+  private static final List<ThreeColumnRecord> RECORDS = Lists.newArrayList(new ThreeColumnRecord(1, \"AAAA\", \"AAAA\"));\n+\n+  static final DataFile FILE_A = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-a.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=0\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+  static final DataFile FILE_B = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-b.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=1\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+  static final DataFile FILE_C = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-c.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=2\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+  static final DataFile FILE_D = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-d.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=3\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+\n+  @Rule\n+  public TemporaryFolder temp = new TemporaryFolder();\n+\n+  private File tableDir;\n+  private String tableLocation;\n+  private Table table;\n+\n+  @Before\n+  public void setupTableLocation() throws Exception {\n+    this.tableDir = temp.newFolder();\n+    this.tableLocation = tableDir.toURI().toString();\n+    this.table = TABLES.create(SCHEMA, SPEC, Maps.newHashMap(), tableLocation);\n+  }\n+\n+  private Dataset<Row> buildDF(List<ThreeColumnRecord> records) {\n+    return spark.createDataFrame(records, ThreeColumnRecord.class).coalesce(1);\n+  }\n+\n+  private void writeDF(Dataset<Row> df, String mode) {\n+    df.select(\"c1\", \"c2\", \"c3\")\n+        .write()\n+        .format(\"iceberg\")\n+        .mode(mode)\n+        .save(tableLocation);\n+  }\n+\n+  private void checkExpirationResults(Long expectedDatafiles, Long expectedManifestsDeleted,\n+      Long expectedManifestListsDeleted, ExpireSnapshotsActionResult results) {\n+\n+    Assert.assertEquals(\"Incorrect number of manifest files deleted\",\n+        expectedManifestsDeleted, results.getManifestFilesDeleted());\n+    Assert.assertEquals(\"Incorrect number of datafiles deleted\",\n+        expectedDatafiles, results.getDataFilesDeleted());\n+    Assert.assertEquals(\"Incorrect number of manifest lists deleted\",\n+        expectedManifestListsDeleted, results.getManifestListsDeleted());\n+  }\n+\n+  @Test\n+  public void testFilesCleaned() throws Exception {\n+    Dataset<Row> df = buildDF(RECORDS);\n+\n+    writeDF(df, \"append\");\n+\n+    List<Path> expiredDataFiles = Files\n+        .list(tableDir.toPath().resolve(\"data\").resolve(\"c1=1\"))\n+        .collect(Collectors.toList());\n+\n+    Assert.assertEquals(\"There should be a data file to delete but there was none.\",\n+        2, expiredDataFiles.size());\n+\n+    writeDF(df, \"overwrite\");\n+    writeDF(df, \"append\");\n+\n+    long end = System.currentTimeMillis();\n+    while (end <= table.currentSnapshot().timestampMillis()) {\n+      end = System.currentTimeMillis();\n+    }\n+\n+    ExpireSnapshotsActionResult results =\n+        Actions.forTable(table).expireSnapshots().expireOlderThan(end).execute();\n+\n+    table.refresh();\n+\n+    Assert.assertEquals(\"Table does not have 1 snapshot after expiration\", 1, Iterables.size(table.snapshots()));\n+\n+    for (Path p : expiredDataFiles) {\n+      Assert.assertFalse(String.format(\"File %s still exists but should have been deleted\", p),\n+          Files.exists(p));\n+    }\n+\n+    checkExpirationResults(1L, 2L, 2L, results);\n+  }\n+\n+  @Test\n+  public void dataFilesCleanupWithParallelTasks() throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9cc4e831679d0aab1e4409210f3a7c57094c440c"}, "originalPosition": 176}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzNDE1OTMx", "url": "https://github.com/apache/iceberg/pull/1264#pullrequestreview-463415931", "createdAt": "2020-08-07T15:44:31Z", "commit": {"oid": "9cc4e831679d0aab1e4409210f3a7c57094c440c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNTo0NDozMVrOG9exsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNTo0NDozMVrOG9exsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzEyMDU2MQ==", "bodyText": "Ported Test - Only change is using ExpireSnapshotsAction", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r467120561", "createdAt": "2020-08-07T15:44:31Z", "author": {"login": "RussellSpitzer"}, "path": "spark/src/test/java/org/apache/iceberg/actions/TestExpireSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,780 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.BaseTable;\n+import org.apache.iceberg.DataFile;\n+import org.apache.iceberg.DataFiles;\n+import org.apache.iceberg.PartitionSpec;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.Snapshot;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableProperties;\n+import org.apache.iceberg.hadoop.HadoopTables;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableSet;\n+import org.apache.iceberg.relocated.com.google.common.collect.Iterables;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.relocated.com.google.common.collect.Sets;\n+import org.apache.iceberg.spark.SparkTestBase;\n+import org.apache.iceberg.spark.source.ThreeColumnRecord;\n+import org.apache.iceberg.types.Types;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import static org.apache.iceberg.types.Types.NestedField.optional;\n+\n+public abstract class TestExpireSnapshotsAction extends SparkTestBase {\n+\n+  private static final HadoopTables TABLES = new HadoopTables(new Configuration());\n+  private static final Schema SCHEMA = new Schema(\n+      optional(1, \"c1\", Types.IntegerType.get()),\n+      optional(2, \"c2\", Types.StringType.get()),\n+      optional(3, \"c3\", Types.StringType.get())\n+  );\n+\n+  private static final PartitionSpec SPEC = PartitionSpec.builderFor(SCHEMA).identity(\"c1\").build();\n+\n+  private static final List<ThreeColumnRecord> RECORDS = Lists.newArrayList(new ThreeColumnRecord(1, \"AAAA\", \"AAAA\"));\n+\n+  static final DataFile FILE_A = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-a.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=0\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+  static final DataFile FILE_B = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-b.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=1\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+  static final DataFile FILE_C = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-c.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=2\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+  static final DataFile FILE_D = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-d.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=3\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+\n+  @Rule\n+  public TemporaryFolder temp = new TemporaryFolder();\n+\n+  private File tableDir;\n+  private String tableLocation;\n+  private Table table;\n+\n+  @Before\n+  public void setupTableLocation() throws Exception {\n+    this.tableDir = temp.newFolder();\n+    this.tableLocation = tableDir.toURI().toString();\n+    this.table = TABLES.create(SCHEMA, SPEC, Maps.newHashMap(), tableLocation);\n+  }\n+\n+  private Dataset<Row> buildDF(List<ThreeColumnRecord> records) {\n+    return spark.createDataFrame(records, ThreeColumnRecord.class).coalesce(1);\n+  }\n+\n+  private void writeDF(Dataset<Row> df, String mode) {\n+    df.select(\"c1\", \"c2\", \"c3\")\n+        .write()\n+        .format(\"iceberg\")\n+        .mode(mode)\n+        .save(tableLocation);\n+  }\n+\n+  private void checkExpirationResults(Long expectedDatafiles, Long expectedManifestsDeleted,\n+      Long expectedManifestListsDeleted, ExpireSnapshotsActionResult results) {\n+\n+    Assert.assertEquals(\"Incorrect number of manifest files deleted\",\n+        expectedManifestsDeleted, results.getManifestFilesDeleted());\n+    Assert.assertEquals(\"Incorrect number of datafiles deleted\",\n+        expectedDatafiles, results.getDataFilesDeleted());\n+    Assert.assertEquals(\"Incorrect number of manifest lists deleted\",\n+        expectedManifestListsDeleted, results.getManifestListsDeleted());\n+  }\n+\n+  @Test\n+  public void testFilesCleaned() throws Exception {\n+    Dataset<Row> df = buildDF(RECORDS);\n+\n+    writeDF(df, \"append\");\n+\n+    List<Path> expiredDataFiles = Files\n+        .list(tableDir.toPath().resolve(\"data\").resolve(\"c1=1\"))\n+        .collect(Collectors.toList());\n+\n+    Assert.assertEquals(\"There should be a data file to delete but there was none.\",\n+        2, expiredDataFiles.size());\n+\n+    writeDF(df, \"overwrite\");\n+    writeDF(df, \"append\");\n+\n+    long end = System.currentTimeMillis();\n+    while (end <= table.currentSnapshot().timestampMillis()) {\n+      end = System.currentTimeMillis();\n+    }\n+\n+    ExpireSnapshotsActionResult results =\n+        Actions.forTable(table).expireSnapshots().expireOlderThan(end).execute();\n+\n+    table.refresh();\n+\n+    Assert.assertEquals(\"Table does not have 1 snapshot after expiration\", 1, Iterables.size(table.snapshots()));\n+\n+    for (Path p : expiredDataFiles) {\n+      Assert.assertFalse(String.format(\"File %s still exists but should have been deleted\", p),\n+          Files.exists(p));\n+    }\n+\n+    checkExpirationResults(1L, 2L, 2L, results);\n+  }\n+\n+  @Test\n+  public void dataFilesCleanupWithParallelTasks() throws IOException {\n+\n+    table.newFastAppend()\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    table.newFastAppend()\n+        .appendFile(FILE_B)\n+        .commit();\n+\n+    table.newRewrite()\n+        .rewriteFiles(ImmutableSet.of(FILE_B), ImmutableSet.of(FILE_D))\n+        .commit();\n+    long thirdSnapshotId = table.currentSnapshot().snapshotId();\n+\n+    table.newRewrite()\n+        .rewriteFiles(ImmutableSet.of(FILE_A), ImmutableSet.of(FILE_C))\n+        .commit();\n+    long fourthSnapshotId = table.currentSnapshot().snapshotId();\n+\n+    long t4 = System.currentTimeMillis();\n+    while (t4 <= table.currentSnapshot().timestampMillis()) {\n+      t4 = System.currentTimeMillis();\n+    }\n+\n+    Set<String> deletedFiles = Sets.newHashSet();\n+    Set<String> deleteThreads = ConcurrentHashMap.newKeySet();\n+    AtomicInteger deleteThreadsIndex = new AtomicInteger(0);\n+\n+    Actions.forTable(table).expireSnapshots()\n+        .executeDeleteWith(Executors.newFixedThreadPool(4, runnable -> {\n+          Thread thread = new Thread(runnable);\n+          thread.setName(\"remove-snapshot-\" + deleteThreadsIndex.getAndIncrement());\n+          thread.setDaemon(true); // daemon threads will be terminated abruptly when the JVM exits\n+          return thread;\n+        }))\n+        .expireOlderThan(t4)\n+        .deleteWith(s -> {\n+          deleteThreads.add(Thread.currentThread().getName());\n+          deletedFiles.add(s);\n+        })\n+        .execute();\n+\n+    // Verifies that the delete methods ran in the threads created by the provided ExecutorService ThreadFactory\n+    Assert.assertEquals(deleteThreads,\n+        Sets.newHashSet(\"remove-snapshot-0\", \"remove-snapshot-1\", \"remove-snapshot-2\", \"remove-snapshot-3\"));\n+\n+    Assert.assertTrue(\"FILE_A should be deleted\", deletedFiles.contains(FILE_A.path().toString()));\n+    Assert.assertTrue(\"FILE_B should be deleted\", deletedFiles.contains(FILE_B.path().toString()));\n+  }\n+\n+  @Test\n+  public void testNoFilesDeletedWhenNoSnapshotsExpired() throws Exception {\n+    Dataset<Row> df = buildDF(RECORDS);\n+\n+    writeDF(df, \"append\");\n+\n+    ExpireSnapshotsActionResult results =\n+        Actions.forTable(table).expireSnapshots().execute();\n+\n+    checkExpirationResults(0L, 0L, 0L, results);\n+  }\n+\n+  @Test\n+  public void testCleanupRepeatedOverwrites() throws Exception {\n+    Dataset<Row> df = buildDF(RECORDS);\n+\n+    writeDF(df, \"append\");\n+\n+    for (int i = 0; i < 10; i++) {\n+      writeDF(df, \"overwrite\");\n+    }\n+\n+    long end = System.currentTimeMillis();\n+    while (end <= table.currentSnapshot().timestampMillis()) {\n+      end = System.currentTimeMillis();\n+    }\n+\n+    ExpireSnapshotsActionResult results =\n+        Actions.forTable(table).expireSnapshots().expireOlderThan(end).execute();\n+\n+    checkExpirationResults(10L, 19L, 10L, results);\n+  }\n+\n+  @Test\n+  public void testRetainLastWithExpireOlderThan() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9cc4e831679d0aab1e4409210f3a7c57094c440c"}, "originalPosition": 261}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzNDE2MDU0", "url": "https://github.com/apache/iceberg/pull/1264#pullrequestreview-463416054", "createdAt": "2020-08-07T15:44:40Z", "commit": {"oid": "9cc4e831679d0aab1e4409210f3a7c57094c440c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNTo0NDo0MVrOG9eyGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNTo0NDo0MVrOG9eyGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzEyMDY2Ng==", "bodyText": "Ported Test - Only change is using ExpireSnapshotsAction", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r467120666", "createdAt": "2020-08-07T15:44:41Z", "author": {"login": "RussellSpitzer"}, "path": "spark/src/test/java/org/apache/iceberg/actions/TestExpireSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,780 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.BaseTable;\n+import org.apache.iceberg.DataFile;\n+import org.apache.iceberg.DataFiles;\n+import org.apache.iceberg.PartitionSpec;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.Snapshot;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableProperties;\n+import org.apache.iceberg.hadoop.HadoopTables;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableSet;\n+import org.apache.iceberg.relocated.com.google.common.collect.Iterables;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.relocated.com.google.common.collect.Sets;\n+import org.apache.iceberg.spark.SparkTestBase;\n+import org.apache.iceberg.spark.source.ThreeColumnRecord;\n+import org.apache.iceberg.types.Types;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import static org.apache.iceberg.types.Types.NestedField.optional;\n+\n+public abstract class TestExpireSnapshotsAction extends SparkTestBase {\n+\n+  private static final HadoopTables TABLES = new HadoopTables(new Configuration());\n+  private static final Schema SCHEMA = new Schema(\n+      optional(1, \"c1\", Types.IntegerType.get()),\n+      optional(2, \"c2\", Types.StringType.get()),\n+      optional(3, \"c3\", Types.StringType.get())\n+  );\n+\n+  private static final PartitionSpec SPEC = PartitionSpec.builderFor(SCHEMA).identity(\"c1\").build();\n+\n+  private static final List<ThreeColumnRecord> RECORDS = Lists.newArrayList(new ThreeColumnRecord(1, \"AAAA\", \"AAAA\"));\n+\n+  static final DataFile FILE_A = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-a.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=0\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+  static final DataFile FILE_B = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-b.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=1\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+  static final DataFile FILE_C = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-c.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=2\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+  static final DataFile FILE_D = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-d.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=3\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+\n+  @Rule\n+  public TemporaryFolder temp = new TemporaryFolder();\n+\n+  private File tableDir;\n+  private String tableLocation;\n+  private Table table;\n+\n+  @Before\n+  public void setupTableLocation() throws Exception {\n+    this.tableDir = temp.newFolder();\n+    this.tableLocation = tableDir.toURI().toString();\n+    this.table = TABLES.create(SCHEMA, SPEC, Maps.newHashMap(), tableLocation);\n+  }\n+\n+  private Dataset<Row> buildDF(List<ThreeColumnRecord> records) {\n+    return spark.createDataFrame(records, ThreeColumnRecord.class).coalesce(1);\n+  }\n+\n+  private void writeDF(Dataset<Row> df, String mode) {\n+    df.select(\"c1\", \"c2\", \"c3\")\n+        .write()\n+        .format(\"iceberg\")\n+        .mode(mode)\n+        .save(tableLocation);\n+  }\n+\n+  private void checkExpirationResults(Long expectedDatafiles, Long expectedManifestsDeleted,\n+      Long expectedManifestListsDeleted, ExpireSnapshotsActionResult results) {\n+\n+    Assert.assertEquals(\"Incorrect number of manifest files deleted\",\n+        expectedManifestsDeleted, results.getManifestFilesDeleted());\n+    Assert.assertEquals(\"Incorrect number of datafiles deleted\",\n+        expectedDatafiles, results.getDataFilesDeleted());\n+    Assert.assertEquals(\"Incorrect number of manifest lists deleted\",\n+        expectedManifestListsDeleted, results.getManifestListsDeleted());\n+  }\n+\n+  @Test\n+  public void testFilesCleaned() throws Exception {\n+    Dataset<Row> df = buildDF(RECORDS);\n+\n+    writeDF(df, \"append\");\n+\n+    List<Path> expiredDataFiles = Files\n+        .list(tableDir.toPath().resolve(\"data\").resolve(\"c1=1\"))\n+        .collect(Collectors.toList());\n+\n+    Assert.assertEquals(\"There should be a data file to delete but there was none.\",\n+        2, expiredDataFiles.size());\n+\n+    writeDF(df, \"overwrite\");\n+    writeDF(df, \"append\");\n+\n+    long end = System.currentTimeMillis();\n+    while (end <= table.currentSnapshot().timestampMillis()) {\n+      end = System.currentTimeMillis();\n+    }\n+\n+    ExpireSnapshotsActionResult results =\n+        Actions.forTable(table).expireSnapshots().expireOlderThan(end).execute();\n+\n+    table.refresh();\n+\n+    Assert.assertEquals(\"Table does not have 1 snapshot after expiration\", 1, Iterables.size(table.snapshots()));\n+\n+    for (Path p : expiredDataFiles) {\n+      Assert.assertFalse(String.format(\"File %s still exists but should have been deleted\", p),\n+          Files.exists(p));\n+    }\n+\n+    checkExpirationResults(1L, 2L, 2L, results);\n+  }\n+\n+  @Test\n+  public void dataFilesCleanupWithParallelTasks() throws IOException {\n+\n+    table.newFastAppend()\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    table.newFastAppend()\n+        .appendFile(FILE_B)\n+        .commit();\n+\n+    table.newRewrite()\n+        .rewriteFiles(ImmutableSet.of(FILE_B), ImmutableSet.of(FILE_D))\n+        .commit();\n+    long thirdSnapshotId = table.currentSnapshot().snapshotId();\n+\n+    table.newRewrite()\n+        .rewriteFiles(ImmutableSet.of(FILE_A), ImmutableSet.of(FILE_C))\n+        .commit();\n+    long fourthSnapshotId = table.currentSnapshot().snapshotId();\n+\n+    long t4 = System.currentTimeMillis();\n+    while (t4 <= table.currentSnapshot().timestampMillis()) {\n+      t4 = System.currentTimeMillis();\n+    }\n+\n+    Set<String> deletedFiles = Sets.newHashSet();\n+    Set<String> deleteThreads = ConcurrentHashMap.newKeySet();\n+    AtomicInteger deleteThreadsIndex = new AtomicInteger(0);\n+\n+    Actions.forTable(table).expireSnapshots()\n+        .executeDeleteWith(Executors.newFixedThreadPool(4, runnable -> {\n+          Thread thread = new Thread(runnable);\n+          thread.setName(\"remove-snapshot-\" + deleteThreadsIndex.getAndIncrement());\n+          thread.setDaemon(true); // daemon threads will be terminated abruptly when the JVM exits\n+          return thread;\n+        }))\n+        .expireOlderThan(t4)\n+        .deleteWith(s -> {\n+          deleteThreads.add(Thread.currentThread().getName());\n+          deletedFiles.add(s);\n+        })\n+        .execute();\n+\n+    // Verifies that the delete methods ran in the threads created by the provided ExecutorService ThreadFactory\n+    Assert.assertEquals(deleteThreads,\n+        Sets.newHashSet(\"remove-snapshot-0\", \"remove-snapshot-1\", \"remove-snapshot-2\", \"remove-snapshot-3\"));\n+\n+    Assert.assertTrue(\"FILE_A should be deleted\", deletedFiles.contains(FILE_A.path().toString()));\n+    Assert.assertTrue(\"FILE_B should be deleted\", deletedFiles.contains(FILE_B.path().toString()));\n+  }\n+\n+  @Test\n+  public void testNoFilesDeletedWhenNoSnapshotsExpired() throws Exception {\n+    Dataset<Row> df = buildDF(RECORDS);\n+\n+    writeDF(df, \"append\");\n+\n+    ExpireSnapshotsActionResult results =\n+        Actions.forTable(table).expireSnapshots().execute();\n+\n+    checkExpirationResults(0L, 0L, 0L, results);\n+  }\n+\n+  @Test\n+  public void testCleanupRepeatedOverwrites() throws Exception {\n+    Dataset<Row> df = buildDF(RECORDS);\n+\n+    writeDF(df, \"append\");\n+\n+    for (int i = 0; i < 10; i++) {\n+      writeDF(df, \"overwrite\");\n+    }\n+\n+    long end = System.currentTimeMillis();\n+    while (end <= table.currentSnapshot().timestampMillis()) {\n+      end = System.currentTimeMillis();\n+    }\n+\n+    ExpireSnapshotsActionResult results =\n+        Actions.forTable(table).expireSnapshots().expireOlderThan(end).execute();\n+\n+    checkExpirationResults(10L, 19L, 10L, results);\n+  }\n+\n+  @Test\n+  public void testRetainLastWithExpireOlderThan() {\n+    long t0 = System.currentTimeMillis();\n+    table.newAppend()\n+        .appendFile(FILE_A) // data_bucket=0\n+        .commit();\n+    long firstSnapshotId = table.currentSnapshot().snapshotId();\n+    long t1 = System.currentTimeMillis();\n+    while (t1 <= table.currentSnapshot().timestampMillis()) {\n+      t1 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_B) // data_bucket=1\n+        .commit();\n+\n+    long t2 = System.currentTimeMillis();\n+    while (t2 <= table.currentSnapshot().timestampMillis()) {\n+      t2 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_C) // data_bucket=2\n+        .commit();\n+\n+    long t3 = System.currentTimeMillis();\n+    while (t3 <= table.currentSnapshot().timestampMillis()) {\n+      t3 = System.currentTimeMillis();\n+    }\n+\n+    // Retain last 2 snapshots\n+    Actions.forTable(table).expireSnapshots()\n+        .expireOlderThan(t3)\n+        .retainLast(2)\n+        .execute();\n+\n+    Assert.assertEquals(\"Should have two snapshots.\",\n+        2, Lists.newArrayList(table.snapshots()).size());\n+    Assert.assertEquals(\"First snapshot should not present.\",\n+        null, table.snapshot(firstSnapshotId));\n+  }\n+\n+  @Test\n+  public void testRetainLastWithExpireById() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9cc4e831679d0aab1e4409210f3a7c57094c440c"}, "originalPosition": 303}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzNDE2MTE1", "url": "https://github.com/apache/iceberg/pull/1264#pullrequestreview-463416115", "createdAt": "2020-08-07T15:44:47Z", "commit": {"oid": "9cc4e831679d0aab1e4409210f3a7c57094c440c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNTo0NDo0OFrOG9eyVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNTo0NDo0OFrOG9eyVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzEyMDcyNg==", "bodyText": "Ported Test - Only change is using ExpireSnapshotsAction", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r467120726", "createdAt": "2020-08-07T15:44:48Z", "author": {"login": "RussellSpitzer"}, "path": "spark/src/test/java/org/apache/iceberg/actions/TestExpireSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,780 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.BaseTable;\n+import org.apache.iceberg.DataFile;\n+import org.apache.iceberg.DataFiles;\n+import org.apache.iceberg.PartitionSpec;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.Snapshot;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableProperties;\n+import org.apache.iceberg.hadoop.HadoopTables;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableSet;\n+import org.apache.iceberg.relocated.com.google.common.collect.Iterables;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.relocated.com.google.common.collect.Sets;\n+import org.apache.iceberg.spark.SparkTestBase;\n+import org.apache.iceberg.spark.source.ThreeColumnRecord;\n+import org.apache.iceberg.types.Types;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import static org.apache.iceberg.types.Types.NestedField.optional;\n+\n+public abstract class TestExpireSnapshotsAction extends SparkTestBase {\n+\n+  private static final HadoopTables TABLES = new HadoopTables(new Configuration());\n+  private static final Schema SCHEMA = new Schema(\n+      optional(1, \"c1\", Types.IntegerType.get()),\n+      optional(2, \"c2\", Types.StringType.get()),\n+      optional(3, \"c3\", Types.StringType.get())\n+  );\n+\n+  private static final PartitionSpec SPEC = PartitionSpec.builderFor(SCHEMA).identity(\"c1\").build();\n+\n+  private static final List<ThreeColumnRecord> RECORDS = Lists.newArrayList(new ThreeColumnRecord(1, \"AAAA\", \"AAAA\"));\n+\n+  static final DataFile FILE_A = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-a.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=0\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+  static final DataFile FILE_B = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-b.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=1\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+  static final DataFile FILE_C = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-c.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=2\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+  static final DataFile FILE_D = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-d.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=3\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+\n+  @Rule\n+  public TemporaryFolder temp = new TemporaryFolder();\n+\n+  private File tableDir;\n+  private String tableLocation;\n+  private Table table;\n+\n+  @Before\n+  public void setupTableLocation() throws Exception {\n+    this.tableDir = temp.newFolder();\n+    this.tableLocation = tableDir.toURI().toString();\n+    this.table = TABLES.create(SCHEMA, SPEC, Maps.newHashMap(), tableLocation);\n+  }\n+\n+  private Dataset<Row> buildDF(List<ThreeColumnRecord> records) {\n+    return spark.createDataFrame(records, ThreeColumnRecord.class).coalesce(1);\n+  }\n+\n+  private void writeDF(Dataset<Row> df, String mode) {\n+    df.select(\"c1\", \"c2\", \"c3\")\n+        .write()\n+        .format(\"iceberg\")\n+        .mode(mode)\n+        .save(tableLocation);\n+  }\n+\n+  private void checkExpirationResults(Long expectedDatafiles, Long expectedManifestsDeleted,\n+      Long expectedManifestListsDeleted, ExpireSnapshotsActionResult results) {\n+\n+    Assert.assertEquals(\"Incorrect number of manifest files deleted\",\n+        expectedManifestsDeleted, results.getManifestFilesDeleted());\n+    Assert.assertEquals(\"Incorrect number of datafiles deleted\",\n+        expectedDatafiles, results.getDataFilesDeleted());\n+    Assert.assertEquals(\"Incorrect number of manifest lists deleted\",\n+        expectedManifestListsDeleted, results.getManifestListsDeleted());\n+  }\n+\n+  @Test\n+  public void testFilesCleaned() throws Exception {\n+    Dataset<Row> df = buildDF(RECORDS);\n+\n+    writeDF(df, \"append\");\n+\n+    List<Path> expiredDataFiles = Files\n+        .list(tableDir.toPath().resolve(\"data\").resolve(\"c1=1\"))\n+        .collect(Collectors.toList());\n+\n+    Assert.assertEquals(\"There should be a data file to delete but there was none.\",\n+        2, expiredDataFiles.size());\n+\n+    writeDF(df, \"overwrite\");\n+    writeDF(df, \"append\");\n+\n+    long end = System.currentTimeMillis();\n+    while (end <= table.currentSnapshot().timestampMillis()) {\n+      end = System.currentTimeMillis();\n+    }\n+\n+    ExpireSnapshotsActionResult results =\n+        Actions.forTable(table).expireSnapshots().expireOlderThan(end).execute();\n+\n+    table.refresh();\n+\n+    Assert.assertEquals(\"Table does not have 1 snapshot after expiration\", 1, Iterables.size(table.snapshots()));\n+\n+    for (Path p : expiredDataFiles) {\n+      Assert.assertFalse(String.format(\"File %s still exists but should have been deleted\", p),\n+          Files.exists(p));\n+    }\n+\n+    checkExpirationResults(1L, 2L, 2L, results);\n+  }\n+\n+  @Test\n+  public void dataFilesCleanupWithParallelTasks() throws IOException {\n+\n+    table.newFastAppend()\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    table.newFastAppend()\n+        .appendFile(FILE_B)\n+        .commit();\n+\n+    table.newRewrite()\n+        .rewriteFiles(ImmutableSet.of(FILE_B), ImmutableSet.of(FILE_D))\n+        .commit();\n+    long thirdSnapshotId = table.currentSnapshot().snapshotId();\n+\n+    table.newRewrite()\n+        .rewriteFiles(ImmutableSet.of(FILE_A), ImmutableSet.of(FILE_C))\n+        .commit();\n+    long fourthSnapshotId = table.currentSnapshot().snapshotId();\n+\n+    long t4 = System.currentTimeMillis();\n+    while (t4 <= table.currentSnapshot().timestampMillis()) {\n+      t4 = System.currentTimeMillis();\n+    }\n+\n+    Set<String> deletedFiles = Sets.newHashSet();\n+    Set<String> deleteThreads = ConcurrentHashMap.newKeySet();\n+    AtomicInteger deleteThreadsIndex = new AtomicInteger(0);\n+\n+    Actions.forTable(table).expireSnapshots()\n+        .executeDeleteWith(Executors.newFixedThreadPool(4, runnable -> {\n+          Thread thread = new Thread(runnable);\n+          thread.setName(\"remove-snapshot-\" + deleteThreadsIndex.getAndIncrement());\n+          thread.setDaemon(true); // daemon threads will be terminated abruptly when the JVM exits\n+          return thread;\n+        }))\n+        .expireOlderThan(t4)\n+        .deleteWith(s -> {\n+          deleteThreads.add(Thread.currentThread().getName());\n+          deletedFiles.add(s);\n+        })\n+        .execute();\n+\n+    // Verifies that the delete methods ran in the threads created by the provided ExecutorService ThreadFactory\n+    Assert.assertEquals(deleteThreads,\n+        Sets.newHashSet(\"remove-snapshot-0\", \"remove-snapshot-1\", \"remove-snapshot-2\", \"remove-snapshot-3\"));\n+\n+    Assert.assertTrue(\"FILE_A should be deleted\", deletedFiles.contains(FILE_A.path().toString()));\n+    Assert.assertTrue(\"FILE_B should be deleted\", deletedFiles.contains(FILE_B.path().toString()));\n+  }\n+\n+  @Test\n+  public void testNoFilesDeletedWhenNoSnapshotsExpired() throws Exception {\n+    Dataset<Row> df = buildDF(RECORDS);\n+\n+    writeDF(df, \"append\");\n+\n+    ExpireSnapshotsActionResult results =\n+        Actions.forTable(table).expireSnapshots().execute();\n+\n+    checkExpirationResults(0L, 0L, 0L, results);\n+  }\n+\n+  @Test\n+  public void testCleanupRepeatedOverwrites() throws Exception {\n+    Dataset<Row> df = buildDF(RECORDS);\n+\n+    writeDF(df, \"append\");\n+\n+    for (int i = 0; i < 10; i++) {\n+      writeDF(df, \"overwrite\");\n+    }\n+\n+    long end = System.currentTimeMillis();\n+    while (end <= table.currentSnapshot().timestampMillis()) {\n+      end = System.currentTimeMillis();\n+    }\n+\n+    ExpireSnapshotsActionResult results =\n+        Actions.forTable(table).expireSnapshots().expireOlderThan(end).execute();\n+\n+    checkExpirationResults(10L, 19L, 10L, results);\n+  }\n+\n+  @Test\n+  public void testRetainLastWithExpireOlderThan() {\n+    long t0 = System.currentTimeMillis();\n+    table.newAppend()\n+        .appendFile(FILE_A) // data_bucket=0\n+        .commit();\n+    long firstSnapshotId = table.currentSnapshot().snapshotId();\n+    long t1 = System.currentTimeMillis();\n+    while (t1 <= table.currentSnapshot().timestampMillis()) {\n+      t1 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_B) // data_bucket=1\n+        .commit();\n+\n+    long t2 = System.currentTimeMillis();\n+    while (t2 <= table.currentSnapshot().timestampMillis()) {\n+      t2 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_C) // data_bucket=2\n+        .commit();\n+\n+    long t3 = System.currentTimeMillis();\n+    while (t3 <= table.currentSnapshot().timestampMillis()) {\n+      t3 = System.currentTimeMillis();\n+    }\n+\n+    // Retain last 2 snapshots\n+    Actions.forTable(table).expireSnapshots()\n+        .expireOlderThan(t3)\n+        .retainLast(2)\n+        .execute();\n+\n+    Assert.assertEquals(\"Should have two snapshots.\",\n+        2, Lists.newArrayList(table.snapshots()).size());\n+    Assert.assertEquals(\"First snapshot should not present.\",\n+        null, table.snapshot(firstSnapshotId));\n+  }\n+\n+  @Test\n+  public void testRetainLastWithExpireById() {\n+    long t0 = System.currentTimeMillis();\n+    table.newAppend()\n+        .appendFile(FILE_A) // data_bucket=0\n+        .commit();\n+    long firstSnapshotId = table.currentSnapshot().snapshotId();\n+    long t1 = System.currentTimeMillis();\n+    while (t1 <= table.currentSnapshot().timestampMillis()) {\n+      t1 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_B) // data_bucket=1\n+        .commit();\n+\n+    long t2 = System.currentTimeMillis();\n+    while (t2 <= table.currentSnapshot().timestampMillis()) {\n+      t2 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_C) // data_bucket=2\n+        .commit();\n+\n+    long t3 = System.currentTimeMillis();\n+    while (t3 <= table.currentSnapshot().timestampMillis()) {\n+      t3 = System.currentTimeMillis();\n+    }\n+\n+    // Retain last 3 snapshots, but explicitly remove the first snapshot\n+    Actions.forTable(table).expireSnapshots()\n+        .expireSnapshotId(firstSnapshotId)\n+        .retainLast(3)\n+        .execute();\n+\n+    Assert.assertEquals(\"Should have two snapshots.\",\n+        2, Lists.newArrayList(table.snapshots()).size());\n+    Assert.assertEquals(\"First snapshot should not present.\",\n+        null, table.snapshot(firstSnapshotId));\n+  }\n+\n+  @Test\n+  public void testRetainLastWithTooFewSnapshots() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9cc4e831679d0aab1e4409210f3a7c57094c440c"}, "originalPosition": 345}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzNDE2MjA3", "url": "https://github.com/apache/iceberg/pull/1264#pullrequestreview-463416207", "createdAt": "2020-08-07T15:44:55Z", "commit": {"oid": "9cc4e831679d0aab1e4409210f3a7c57094c440c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNTo0NDo1NVrOG9eyqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNTo0NDo1NVrOG9eyqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzEyMDgwOQ==", "bodyText": "Ported Test - Only change is using ExpireSnapshotsAction", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r467120809", "createdAt": "2020-08-07T15:44:55Z", "author": {"login": "RussellSpitzer"}, "path": "spark/src/test/java/org/apache/iceberg/actions/TestExpireSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,780 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.BaseTable;\n+import org.apache.iceberg.DataFile;\n+import org.apache.iceberg.DataFiles;\n+import org.apache.iceberg.PartitionSpec;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.Snapshot;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableProperties;\n+import org.apache.iceberg.hadoop.HadoopTables;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableSet;\n+import org.apache.iceberg.relocated.com.google.common.collect.Iterables;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.relocated.com.google.common.collect.Sets;\n+import org.apache.iceberg.spark.SparkTestBase;\n+import org.apache.iceberg.spark.source.ThreeColumnRecord;\n+import org.apache.iceberg.types.Types;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import static org.apache.iceberg.types.Types.NestedField.optional;\n+\n+public abstract class TestExpireSnapshotsAction extends SparkTestBase {\n+\n+  private static final HadoopTables TABLES = new HadoopTables(new Configuration());\n+  private static final Schema SCHEMA = new Schema(\n+      optional(1, \"c1\", Types.IntegerType.get()),\n+      optional(2, \"c2\", Types.StringType.get()),\n+      optional(3, \"c3\", Types.StringType.get())\n+  );\n+\n+  private static final PartitionSpec SPEC = PartitionSpec.builderFor(SCHEMA).identity(\"c1\").build();\n+\n+  private static final List<ThreeColumnRecord> RECORDS = Lists.newArrayList(new ThreeColumnRecord(1, \"AAAA\", \"AAAA\"));\n+\n+  static final DataFile FILE_A = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-a.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=0\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+  static final DataFile FILE_B = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-b.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=1\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+  static final DataFile FILE_C = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-c.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=2\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+  static final DataFile FILE_D = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-d.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=3\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+\n+  @Rule\n+  public TemporaryFolder temp = new TemporaryFolder();\n+\n+  private File tableDir;\n+  private String tableLocation;\n+  private Table table;\n+\n+  @Before\n+  public void setupTableLocation() throws Exception {\n+    this.tableDir = temp.newFolder();\n+    this.tableLocation = tableDir.toURI().toString();\n+    this.table = TABLES.create(SCHEMA, SPEC, Maps.newHashMap(), tableLocation);\n+  }\n+\n+  private Dataset<Row> buildDF(List<ThreeColumnRecord> records) {\n+    return spark.createDataFrame(records, ThreeColumnRecord.class).coalesce(1);\n+  }\n+\n+  private void writeDF(Dataset<Row> df, String mode) {\n+    df.select(\"c1\", \"c2\", \"c3\")\n+        .write()\n+        .format(\"iceberg\")\n+        .mode(mode)\n+        .save(tableLocation);\n+  }\n+\n+  private void checkExpirationResults(Long expectedDatafiles, Long expectedManifestsDeleted,\n+      Long expectedManifestListsDeleted, ExpireSnapshotsActionResult results) {\n+\n+    Assert.assertEquals(\"Incorrect number of manifest files deleted\",\n+        expectedManifestsDeleted, results.getManifestFilesDeleted());\n+    Assert.assertEquals(\"Incorrect number of datafiles deleted\",\n+        expectedDatafiles, results.getDataFilesDeleted());\n+    Assert.assertEquals(\"Incorrect number of manifest lists deleted\",\n+        expectedManifestListsDeleted, results.getManifestListsDeleted());\n+  }\n+\n+  @Test\n+  public void testFilesCleaned() throws Exception {\n+    Dataset<Row> df = buildDF(RECORDS);\n+\n+    writeDF(df, \"append\");\n+\n+    List<Path> expiredDataFiles = Files\n+        .list(tableDir.toPath().resolve(\"data\").resolve(\"c1=1\"))\n+        .collect(Collectors.toList());\n+\n+    Assert.assertEquals(\"There should be a data file to delete but there was none.\",\n+        2, expiredDataFiles.size());\n+\n+    writeDF(df, \"overwrite\");\n+    writeDF(df, \"append\");\n+\n+    long end = System.currentTimeMillis();\n+    while (end <= table.currentSnapshot().timestampMillis()) {\n+      end = System.currentTimeMillis();\n+    }\n+\n+    ExpireSnapshotsActionResult results =\n+        Actions.forTable(table).expireSnapshots().expireOlderThan(end).execute();\n+\n+    table.refresh();\n+\n+    Assert.assertEquals(\"Table does not have 1 snapshot after expiration\", 1, Iterables.size(table.snapshots()));\n+\n+    for (Path p : expiredDataFiles) {\n+      Assert.assertFalse(String.format(\"File %s still exists but should have been deleted\", p),\n+          Files.exists(p));\n+    }\n+\n+    checkExpirationResults(1L, 2L, 2L, results);\n+  }\n+\n+  @Test\n+  public void dataFilesCleanupWithParallelTasks() throws IOException {\n+\n+    table.newFastAppend()\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    table.newFastAppend()\n+        .appendFile(FILE_B)\n+        .commit();\n+\n+    table.newRewrite()\n+        .rewriteFiles(ImmutableSet.of(FILE_B), ImmutableSet.of(FILE_D))\n+        .commit();\n+    long thirdSnapshotId = table.currentSnapshot().snapshotId();\n+\n+    table.newRewrite()\n+        .rewriteFiles(ImmutableSet.of(FILE_A), ImmutableSet.of(FILE_C))\n+        .commit();\n+    long fourthSnapshotId = table.currentSnapshot().snapshotId();\n+\n+    long t4 = System.currentTimeMillis();\n+    while (t4 <= table.currentSnapshot().timestampMillis()) {\n+      t4 = System.currentTimeMillis();\n+    }\n+\n+    Set<String> deletedFiles = Sets.newHashSet();\n+    Set<String> deleteThreads = ConcurrentHashMap.newKeySet();\n+    AtomicInteger deleteThreadsIndex = new AtomicInteger(0);\n+\n+    Actions.forTable(table).expireSnapshots()\n+        .executeDeleteWith(Executors.newFixedThreadPool(4, runnable -> {\n+          Thread thread = new Thread(runnable);\n+          thread.setName(\"remove-snapshot-\" + deleteThreadsIndex.getAndIncrement());\n+          thread.setDaemon(true); // daemon threads will be terminated abruptly when the JVM exits\n+          return thread;\n+        }))\n+        .expireOlderThan(t4)\n+        .deleteWith(s -> {\n+          deleteThreads.add(Thread.currentThread().getName());\n+          deletedFiles.add(s);\n+        })\n+        .execute();\n+\n+    // Verifies that the delete methods ran in the threads created by the provided ExecutorService ThreadFactory\n+    Assert.assertEquals(deleteThreads,\n+        Sets.newHashSet(\"remove-snapshot-0\", \"remove-snapshot-1\", \"remove-snapshot-2\", \"remove-snapshot-3\"));\n+\n+    Assert.assertTrue(\"FILE_A should be deleted\", deletedFiles.contains(FILE_A.path().toString()));\n+    Assert.assertTrue(\"FILE_B should be deleted\", deletedFiles.contains(FILE_B.path().toString()));\n+  }\n+\n+  @Test\n+  public void testNoFilesDeletedWhenNoSnapshotsExpired() throws Exception {\n+    Dataset<Row> df = buildDF(RECORDS);\n+\n+    writeDF(df, \"append\");\n+\n+    ExpireSnapshotsActionResult results =\n+        Actions.forTable(table).expireSnapshots().execute();\n+\n+    checkExpirationResults(0L, 0L, 0L, results);\n+  }\n+\n+  @Test\n+  public void testCleanupRepeatedOverwrites() throws Exception {\n+    Dataset<Row> df = buildDF(RECORDS);\n+\n+    writeDF(df, \"append\");\n+\n+    for (int i = 0; i < 10; i++) {\n+      writeDF(df, \"overwrite\");\n+    }\n+\n+    long end = System.currentTimeMillis();\n+    while (end <= table.currentSnapshot().timestampMillis()) {\n+      end = System.currentTimeMillis();\n+    }\n+\n+    ExpireSnapshotsActionResult results =\n+        Actions.forTable(table).expireSnapshots().expireOlderThan(end).execute();\n+\n+    checkExpirationResults(10L, 19L, 10L, results);\n+  }\n+\n+  @Test\n+  public void testRetainLastWithExpireOlderThan() {\n+    long t0 = System.currentTimeMillis();\n+    table.newAppend()\n+        .appendFile(FILE_A) // data_bucket=0\n+        .commit();\n+    long firstSnapshotId = table.currentSnapshot().snapshotId();\n+    long t1 = System.currentTimeMillis();\n+    while (t1 <= table.currentSnapshot().timestampMillis()) {\n+      t1 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_B) // data_bucket=1\n+        .commit();\n+\n+    long t2 = System.currentTimeMillis();\n+    while (t2 <= table.currentSnapshot().timestampMillis()) {\n+      t2 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_C) // data_bucket=2\n+        .commit();\n+\n+    long t3 = System.currentTimeMillis();\n+    while (t3 <= table.currentSnapshot().timestampMillis()) {\n+      t3 = System.currentTimeMillis();\n+    }\n+\n+    // Retain last 2 snapshots\n+    Actions.forTable(table).expireSnapshots()\n+        .expireOlderThan(t3)\n+        .retainLast(2)\n+        .execute();\n+\n+    Assert.assertEquals(\"Should have two snapshots.\",\n+        2, Lists.newArrayList(table.snapshots()).size());\n+    Assert.assertEquals(\"First snapshot should not present.\",\n+        null, table.snapshot(firstSnapshotId));\n+  }\n+\n+  @Test\n+  public void testRetainLastWithExpireById() {\n+    long t0 = System.currentTimeMillis();\n+    table.newAppend()\n+        .appendFile(FILE_A) // data_bucket=0\n+        .commit();\n+    long firstSnapshotId = table.currentSnapshot().snapshotId();\n+    long t1 = System.currentTimeMillis();\n+    while (t1 <= table.currentSnapshot().timestampMillis()) {\n+      t1 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_B) // data_bucket=1\n+        .commit();\n+\n+    long t2 = System.currentTimeMillis();\n+    while (t2 <= table.currentSnapshot().timestampMillis()) {\n+      t2 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_C) // data_bucket=2\n+        .commit();\n+\n+    long t3 = System.currentTimeMillis();\n+    while (t3 <= table.currentSnapshot().timestampMillis()) {\n+      t3 = System.currentTimeMillis();\n+    }\n+\n+    // Retain last 3 snapshots, but explicitly remove the first snapshot\n+    Actions.forTable(table).expireSnapshots()\n+        .expireSnapshotId(firstSnapshotId)\n+        .retainLast(3)\n+        .execute();\n+\n+    Assert.assertEquals(\"Should have two snapshots.\",\n+        2, Lists.newArrayList(table.snapshots()).size());\n+    Assert.assertEquals(\"First snapshot should not present.\",\n+        null, table.snapshot(firstSnapshotId));\n+  }\n+\n+  @Test\n+  public void testRetainLastWithTooFewSnapshots() {\n+    long t0 = System.currentTimeMillis();\n+    table.newAppend()\n+        .appendFile(FILE_A) // data_bucket=0\n+        .appendFile(FILE_B) // data_bucket=1\n+        .commit();\n+    long firstSnapshotId = table.currentSnapshot().snapshotId();\n+\n+    long t1 = System.currentTimeMillis();\n+    while (t1 <= table.currentSnapshot().timestampMillis()) {\n+      t1 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_C) // data_bucket=2\n+        .commit();\n+\n+    long t2 = System.currentTimeMillis();\n+    while (t2 <= table.currentSnapshot().timestampMillis()) {\n+      t2 = System.currentTimeMillis();\n+    }\n+\n+    // Retain last 3 snapshots\n+    Actions.forTable(table).expireSnapshots()\n+        .expireOlderThan(t2)\n+        .retainLast(3)\n+        .execute();\n+\n+    Assert.assertEquals(\"Should have two snapshots\",\n+        2, Lists.newArrayList(table.snapshots()).size());\n+    Assert.assertEquals(\"First snapshot should still present\",\n+        firstSnapshotId, table.snapshot(firstSnapshotId).snapshotId());\n+  }\n+\n+  @Test\n+  public void testRetainLastKeepsExpiringSnapshot() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9cc4e831679d0aab1e4409210f3a7c57094c440c"}, "originalPosition": 380}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzNDE2MzI0", "url": "https://github.com/apache/iceberg/pull/1264#pullrequestreview-463416324", "createdAt": "2020-08-07T15:45:04Z", "commit": {"oid": "9cc4e831679d0aab1e4409210f3a7c57094c440c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNTo0NTowNFrOG9ezKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNTo0NTowNFrOG9ezKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzEyMDkzNg==", "bodyText": "Ported Test - Only change is using ExpireSnapshotsAction", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r467120936", "createdAt": "2020-08-07T15:45:04Z", "author": {"login": "RussellSpitzer"}, "path": "spark/src/test/java/org/apache/iceberg/actions/TestExpireSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,780 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.BaseTable;\n+import org.apache.iceberg.DataFile;\n+import org.apache.iceberg.DataFiles;\n+import org.apache.iceberg.PartitionSpec;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.Snapshot;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableProperties;\n+import org.apache.iceberg.hadoop.HadoopTables;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableSet;\n+import org.apache.iceberg.relocated.com.google.common.collect.Iterables;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.relocated.com.google.common.collect.Sets;\n+import org.apache.iceberg.spark.SparkTestBase;\n+import org.apache.iceberg.spark.source.ThreeColumnRecord;\n+import org.apache.iceberg.types.Types;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import static org.apache.iceberg.types.Types.NestedField.optional;\n+\n+public abstract class TestExpireSnapshotsAction extends SparkTestBase {\n+\n+  private static final HadoopTables TABLES = new HadoopTables(new Configuration());\n+  private static final Schema SCHEMA = new Schema(\n+      optional(1, \"c1\", Types.IntegerType.get()),\n+      optional(2, \"c2\", Types.StringType.get()),\n+      optional(3, \"c3\", Types.StringType.get())\n+  );\n+\n+  private static final PartitionSpec SPEC = PartitionSpec.builderFor(SCHEMA).identity(\"c1\").build();\n+\n+  private static final List<ThreeColumnRecord> RECORDS = Lists.newArrayList(new ThreeColumnRecord(1, \"AAAA\", \"AAAA\"));\n+\n+  static final DataFile FILE_A = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-a.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=0\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+  static final DataFile FILE_B = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-b.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=1\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+  static final DataFile FILE_C = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-c.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=2\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+  static final DataFile FILE_D = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-d.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=3\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+\n+  @Rule\n+  public TemporaryFolder temp = new TemporaryFolder();\n+\n+  private File tableDir;\n+  private String tableLocation;\n+  private Table table;\n+\n+  @Before\n+  public void setupTableLocation() throws Exception {\n+    this.tableDir = temp.newFolder();\n+    this.tableLocation = tableDir.toURI().toString();\n+    this.table = TABLES.create(SCHEMA, SPEC, Maps.newHashMap(), tableLocation);\n+  }\n+\n+  private Dataset<Row> buildDF(List<ThreeColumnRecord> records) {\n+    return spark.createDataFrame(records, ThreeColumnRecord.class).coalesce(1);\n+  }\n+\n+  private void writeDF(Dataset<Row> df, String mode) {\n+    df.select(\"c1\", \"c2\", \"c3\")\n+        .write()\n+        .format(\"iceberg\")\n+        .mode(mode)\n+        .save(tableLocation);\n+  }\n+\n+  private void checkExpirationResults(Long expectedDatafiles, Long expectedManifestsDeleted,\n+      Long expectedManifestListsDeleted, ExpireSnapshotsActionResult results) {\n+\n+    Assert.assertEquals(\"Incorrect number of manifest files deleted\",\n+        expectedManifestsDeleted, results.getManifestFilesDeleted());\n+    Assert.assertEquals(\"Incorrect number of datafiles deleted\",\n+        expectedDatafiles, results.getDataFilesDeleted());\n+    Assert.assertEquals(\"Incorrect number of manifest lists deleted\",\n+        expectedManifestListsDeleted, results.getManifestListsDeleted());\n+  }\n+\n+  @Test\n+  public void testFilesCleaned() throws Exception {\n+    Dataset<Row> df = buildDF(RECORDS);\n+\n+    writeDF(df, \"append\");\n+\n+    List<Path> expiredDataFiles = Files\n+        .list(tableDir.toPath().resolve(\"data\").resolve(\"c1=1\"))\n+        .collect(Collectors.toList());\n+\n+    Assert.assertEquals(\"There should be a data file to delete but there was none.\",\n+        2, expiredDataFiles.size());\n+\n+    writeDF(df, \"overwrite\");\n+    writeDF(df, \"append\");\n+\n+    long end = System.currentTimeMillis();\n+    while (end <= table.currentSnapshot().timestampMillis()) {\n+      end = System.currentTimeMillis();\n+    }\n+\n+    ExpireSnapshotsActionResult results =\n+        Actions.forTable(table).expireSnapshots().expireOlderThan(end).execute();\n+\n+    table.refresh();\n+\n+    Assert.assertEquals(\"Table does not have 1 snapshot after expiration\", 1, Iterables.size(table.snapshots()));\n+\n+    for (Path p : expiredDataFiles) {\n+      Assert.assertFalse(String.format(\"File %s still exists but should have been deleted\", p),\n+          Files.exists(p));\n+    }\n+\n+    checkExpirationResults(1L, 2L, 2L, results);\n+  }\n+\n+  @Test\n+  public void dataFilesCleanupWithParallelTasks() throws IOException {\n+\n+    table.newFastAppend()\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    table.newFastAppend()\n+        .appendFile(FILE_B)\n+        .commit();\n+\n+    table.newRewrite()\n+        .rewriteFiles(ImmutableSet.of(FILE_B), ImmutableSet.of(FILE_D))\n+        .commit();\n+    long thirdSnapshotId = table.currentSnapshot().snapshotId();\n+\n+    table.newRewrite()\n+        .rewriteFiles(ImmutableSet.of(FILE_A), ImmutableSet.of(FILE_C))\n+        .commit();\n+    long fourthSnapshotId = table.currentSnapshot().snapshotId();\n+\n+    long t4 = System.currentTimeMillis();\n+    while (t4 <= table.currentSnapshot().timestampMillis()) {\n+      t4 = System.currentTimeMillis();\n+    }\n+\n+    Set<String> deletedFiles = Sets.newHashSet();\n+    Set<String> deleteThreads = ConcurrentHashMap.newKeySet();\n+    AtomicInteger deleteThreadsIndex = new AtomicInteger(0);\n+\n+    Actions.forTable(table).expireSnapshots()\n+        .executeDeleteWith(Executors.newFixedThreadPool(4, runnable -> {\n+          Thread thread = new Thread(runnable);\n+          thread.setName(\"remove-snapshot-\" + deleteThreadsIndex.getAndIncrement());\n+          thread.setDaemon(true); // daemon threads will be terminated abruptly when the JVM exits\n+          return thread;\n+        }))\n+        .expireOlderThan(t4)\n+        .deleteWith(s -> {\n+          deleteThreads.add(Thread.currentThread().getName());\n+          deletedFiles.add(s);\n+        })\n+        .execute();\n+\n+    // Verifies that the delete methods ran in the threads created by the provided ExecutorService ThreadFactory\n+    Assert.assertEquals(deleteThreads,\n+        Sets.newHashSet(\"remove-snapshot-0\", \"remove-snapshot-1\", \"remove-snapshot-2\", \"remove-snapshot-3\"));\n+\n+    Assert.assertTrue(\"FILE_A should be deleted\", deletedFiles.contains(FILE_A.path().toString()));\n+    Assert.assertTrue(\"FILE_B should be deleted\", deletedFiles.contains(FILE_B.path().toString()));\n+  }\n+\n+  @Test\n+  public void testNoFilesDeletedWhenNoSnapshotsExpired() throws Exception {\n+    Dataset<Row> df = buildDF(RECORDS);\n+\n+    writeDF(df, \"append\");\n+\n+    ExpireSnapshotsActionResult results =\n+        Actions.forTable(table).expireSnapshots().execute();\n+\n+    checkExpirationResults(0L, 0L, 0L, results);\n+  }\n+\n+  @Test\n+  public void testCleanupRepeatedOverwrites() throws Exception {\n+    Dataset<Row> df = buildDF(RECORDS);\n+\n+    writeDF(df, \"append\");\n+\n+    for (int i = 0; i < 10; i++) {\n+      writeDF(df, \"overwrite\");\n+    }\n+\n+    long end = System.currentTimeMillis();\n+    while (end <= table.currentSnapshot().timestampMillis()) {\n+      end = System.currentTimeMillis();\n+    }\n+\n+    ExpireSnapshotsActionResult results =\n+        Actions.forTable(table).expireSnapshots().expireOlderThan(end).execute();\n+\n+    checkExpirationResults(10L, 19L, 10L, results);\n+  }\n+\n+  @Test\n+  public void testRetainLastWithExpireOlderThan() {\n+    long t0 = System.currentTimeMillis();\n+    table.newAppend()\n+        .appendFile(FILE_A) // data_bucket=0\n+        .commit();\n+    long firstSnapshotId = table.currentSnapshot().snapshotId();\n+    long t1 = System.currentTimeMillis();\n+    while (t1 <= table.currentSnapshot().timestampMillis()) {\n+      t1 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_B) // data_bucket=1\n+        .commit();\n+\n+    long t2 = System.currentTimeMillis();\n+    while (t2 <= table.currentSnapshot().timestampMillis()) {\n+      t2 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_C) // data_bucket=2\n+        .commit();\n+\n+    long t3 = System.currentTimeMillis();\n+    while (t3 <= table.currentSnapshot().timestampMillis()) {\n+      t3 = System.currentTimeMillis();\n+    }\n+\n+    // Retain last 2 snapshots\n+    Actions.forTable(table).expireSnapshots()\n+        .expireOlderThan(t3)\n+        .retainLast(2)\n+        .execute();\n+\n+    Assert.assertEquals(\"Should have two snapshots.\",\n+        2, Lists.newArrayList(table.snapshots()).size());\n+    Assert.assertEquals(\"First snapshot should not present.\",\n+        null, table.snapshot(firstSnapshotId));\n+  }\n+\n+  @Test\n+  public void testRetainLastWithExpireById() {\n+    long t0 = System.currentTimeMillis();\n+    table.newAppend()\n+        .appendFile(FILE_A) // data_bucket=0\n+        .commit();\n+    long firstSnapshotId = table.currentSnapshot().snapshotId();\n+    long t1 = System.currentTimeMillis();\n+    while (t1 <= table.currentSnapshot().timestampMillis()) {\n+      t1 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_B) // data_bucket=1\n+        .commit();\n+\n+    long t2 = System.currentTimeMillis();\n+    while (t2 <= table.currentSnapshot().timestampMillis()) {\n+      t2 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_C) // data_bucket=2\n+        .commit();\n+\n+    long t3 = System.currentTimeMillis();\n+    while (t3 <= table.currentSnapshot().timestampMillis()) {\n+      t3 = System.currentTimeMillis();\n+    }\n+\n+    // Retain last 3 snapshots, but explicitly remove the first snapshot\n+    Actions.forTable(table).expireSnapshots()\n+        .expireSnapshotId(firstSnapshotId)\n+        .retainLast(3)\n+        .execute();\n+\n+    Assert.assertEquals(\"Should have two snapshots.\",\n+        2, Lists.newArrayList(table.snapshots()).size());\n+    Assert.assertEquals(\"First snapshot should not present.\",\n+        null, table.snapshot(firstSnapshotId));\n+  }\n+\n+  @Test\n+  public void testRetainLastWithTooFewSnapshots() {\n+    long t0 = System.currentTimeMillis();\n+    table.newAppend()\n+        .appendFile(FILE_A) // data_bucket=0\n+        .appendFile(FILE_B) // data_bucket=1\n+        .commit();\n+    long firstSnapshotId = table.currentSnapshot().snapshotId();\n+\n+    long t1 = System.currentTimeMillis();\n+    while (t1 <= table.currentSnapshot().timestampMillis()) {\n+      t1 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_C) // data_bucket=2\n+        .commit();\n+\n+    long t2 = System.currentTimeMillis();\n+    while (t2 <= table.currentSnapshot().timestampMillis()) {\n+      t2 = System.currentTimeMillis();\n+    }\n+\n+    // Retain last 3 snapshots\n+    Actions.forTable(table).expireSnapshots()\n+        .expireOlderThan(t2)\n+        .retainLast(3)\n+        .execute();\n+\n+    Assert.assertEquals(\"Should have two snapshots\",\n+        2, Lists.newArrayList(table.snapshots()).size());\n+    Assert.assertEquals(\"First snapshot should still present\",\n+        firstSnapshotId, table.snapshot(firstSnapshotId).snapshotId());\n+  }\n+\n+  @Test\n+  public void testRetainLastKeepsExpiringSnapshot() {\n+    long t0 = System.currentTimeMillis();\n+    table.newAppend()\n+        .appendFile(FILE_A) // data_bucket=0\n+        .commit();\n+    long t1 = System.currentTimeMillis();\n+    while (t1 <= table.currentSnapshot().timestampMillis()) {\n+      t1 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_B) // data_bucket=1\n+        .commit();\n+\n+    Snapshot secondSnapshot = table.currentSnapshot();\n+    long t2 = System.currentTimeMillis();\n+    while (t2 <= table.currentSnapshot().timestampMillis()) {\n+      t2 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_C) // data_bucket=2\n+        .commit();\n+\n+    long t3 = System.currentTimeMillis();\n+    while (t3 <= table.currentSnapshot().timestampMillis()) {\n+      t3 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_D) // data_bucket=3\n+        .commit();\n+\n+    long t4 = System.currentTimeMillis();\n+    while (t4 <= table.currentSnapshot().timestampMillis()) {\n+      t4 = System.currentTimeMillis();\n+    }\n+\n+    // Retain last 2 snapshots and expire older than t3\n+    Actions.forTable(table).expireSnapshots()\n+        .expireOlderThan(secondSnapshot.timestampMillis())\n+        .retainLast(2)\n+        .execute();\n+\n+    Assert.assertEquals(\"Should have three snapshots.\",\n+        3, Lists.newArrayList(table.snapshots()).size());\n+    Assert.assertNotNull(\"Second snapshot should present.\",\n+        table.snapshot(secondSnapshot.snapshotId()));\n+  }\n+\n+  @Test\n+  public void testExpireOlderThanMultipleCalls() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9cc4e831679d0aab1e4409210f3a7c57094c440c"}, "originalPosition": 431}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzNDE2NDgx", "url": "https://github.com/apache/iceberg/pull/1264#pullrequestreview-463416481", "createdAt": "2020-08-07T15:45:16Z", "commit": {"oid": "9cc4e831679d0aab1e4409210f3a7c57094c440c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNTo0NToxNlrOG9ezrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNTo0NToxNlrOG9ezrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzEyMTA2OQ==", "bodyText": "Ported Test - Only change is using ExpireSnapshotsAction", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r467121069", "createdAt": "2020-08-07T15:45:16Z", "author": {"login": "RussellSpitzer"}, "path": "spark/src/test/java/org/apache/iceberg/actions/TestExpireSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,780 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.BaseTable;\n+import org.apache.iceberg.DataFile;\n+import org.apache.iceberg.DataFiles;\n+import org.apache.iceberg.PartitionSpec;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.Snapshot;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableProperties;\n+import org.apache.iceberg.hadoop.HadoopTables;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableSet;\n+import org.apache.iceberg.relocated.com.google.common.collect.Iterables;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.relocated.com.google.common.collect.Sets;\n+import org.apache.iceberg.spark.SparkTestBase;\n+import org.apache.iceberg.spark.source.ThreeColumnRecord;\n+import org.apache.iceberg.types.Types;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import static org.apache.iceberg.types.Types.NestedField.optional;\n+\n+public abstract class TestExpireSnapshotsAction extends SparkTestBase {\n+\n+  private static final HadoopTables TABLES = new HadoopTables(new Configuration());\n+  private static final Schema SCHEMA = new Schema(\n+      optional(1, \"c1\", Types.IntegerType.get()),\n+      optional(2, \"c2\", Types.StringType.get()),\n+      optional(3, \"c3\", Types.StringType.get())\n+  );\n+\n+  private static final PartitionSpec SPEC = PartitionSpec.builderFor(SCHEMA).identity(\"c1\").build();\n+\n+  private static final List<ThreeColumnRecord> RECORDS = Lists.newArrayList(new ThreeColumnRecord(1, \"AAAA\", \"AAAA\"));\n+\n+  static final DataFile FILE_A = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-a.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=0\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+  static final DataFile FILE_B = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-b.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=1\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+  static final DataFile FILE_C = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-c.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=2\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+  static final DataFile FILE_D = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-d.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=3\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+\n+  @Rule\n+  public TemporaryFolder temp = new TemporaryFolder();\n+\n+  private File tableDir;\n+  private String tableLocation;\n+  private Table table;\n+\n+  @Before\n+  public void setupTableLocation() throws Exception {\n+    this.tableDir = temp.newFolder();\n+    this.tableLocation = tableDir.toURI().toString();\n+    this.table = TABLES.create(SCHEMA, SPEC, Maps.newHashMap(), tableLocation);\n+  }\n+\n+  private Dataset<Row> buildDF(List<ThreeColumnRecord> records) {\n+    return spark.createDataFrame(records, ThreeColumnRecord.class).coalesce(1);\n+  }\n+\n+  private void writeDF(Dataset<Row> df, String mode) {\n+    df.select(\"c1\", \"c2\", \"c3\")\n+        .write()\n+        .format(\"iceberg\")\n+        .mode(mode)\n+        .save(tableLocation);\n+  }\n+\n+  private void checkExpirationResults(Long expectedDatafiles, Long expectedManifestsDeleted,\n+      Long expectedManifestListsDeleted, ExpireSnapshotsActionResult results) {\n+\n+    Assert.assertEquals(\"Incorrect number of manifest files deleted\",\n+        expectedManifestsDeleted, results.getManifestFilesDeleted());\n+    Assert.assertEquals(\"Incorrect number of datafiles deleted\",\n+        expectedDatafiles, results.getDataFilesDeleted());\n+    Assert.assertEquals(\"Incorrect number of manifest lists deleted\",\n+        expectedManifestListsDeleted, results.getManifestListsDeleted());\n+  }\n+\n+  @Test\n+  public void testFilesCleaned() throws Exception {\n+    Dataset<Row> df = buildDF(RECORDS);\n+\n+    writeDF(df, \"append\");\n+\n+    List<Path> expiredDataFiles = Files\n+        .list(tableDir.toPath().resolve(\"data\").resolve(\"c1=1\"))\n+        .collect(Collectors.toList());\n+\n+    Assert.assertEquals(\"There should be a data file to delete but there was none.\",\n+        2, expiredDataFiles.size());\n+\n+    writeDF(df, \"overwrite\");\n+    writeDF(df, \"append\");\n+\n+    long end = System.currentTimeMillis();\n+    while (end <= table.currentSnapshot().timestampMillis()) {\n+      end = System.currentTimeMillis();\n+    }\n+\n+    ExpireSnapshotsActionResult results =\n+        Actions.forTable(table).expireSnapshots().expireOlderThan(end).execute();\n+\n+    table.refresh();\n+\n+    Assert.assertEquals(\"Table does not have 1 snapshot after expiration\", 1, Iterables.size(table.snapshots()));\n+\n+    for (Path p : expiredDataFiles) {\n+      Assert.assertFalse(String.format(\"File %s still exists but should have been deleted\", p),\n+          Files.exists(p));\n+    }\n+\n+    checkExpirationResults(1L, 2L, 2L, results);\n+  }\n+\n+  @Test\n+  public void dataFilesCleanupWithParallelTasks() throws IOException {\n+\n+    table.newFastAppend()\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    table.newFastAppend()\n+        .appendFile(FILE_B)\n+        .commit();\n+\n+    table.newRewrite()\n+        .rewriteFiles(ImmutableSet.of(FILE_B), ImmutableSet.of(FILE_D))\n+        .commit();\n+    long thirdSnapshotId = table.currentSnapshot().snapshotId();\n+\n+    table.newRewrite()\n+        .rewriteFiles(ImmutableSet.of(FILE_A), ImmutableSet.of(FILE_C))\n+        .commit();\n+    long fourthSnapshotId = table.currentSnapshot().snapshotId();\n+\n+    long t4 = System.currentTimeMillis();\n+    while (t4 <= table.currentSnapshot().timestampMillis()) {\n+      t4 = System.currentTimeMillis();\n+    }\n+\n+    Set<String> deletedFiles = Sets.newHashSet();\n+    Set<String> deleteThreads = ConcurrentHashMap.newKeySet();\n+    AtomicInteger deleteThreadsIndex = new AtomicInteger(0);\n+\n+    Actions.forTable(table).expireSnapshots()\n+        .executeDeleteWith(Executors.newFixedThreadPool(4, runnable -> {\n+          Thread thread = new Thread(runnable);\n+          thread.setName(\"remove-snapshot-\" + deleteThreadsIndex.getAndIncrement());\n+          thread.setDaemon(true); // daemon threads will be terminated abruptly when the JVM exits\n+          return thread;\n+        }))\n+        .expireOlderThan(t4)\n+        .deleteWith(s -> {\n+          deleteThreads.add(Thread.currentThread().getName());\n+          deletedFiles.add(s);\n+        })\n+        .execute();\n+\n+    // Verifies that the delete methods ran in the threads created by the provided ExecutorService ThreadFactory\n+    Assert.assertEquals(deleteThreads,\n+        Sets.newHashSet(\"remove-snapshot-0\", \"remove-snapshot-1\", \"remove-snapshot-2\", \"remove-snapshot-3\"));\n+\n+    Assert.assertTrue(\"FILE_A should be deleted\", deletedFiles.contains(FILE_A.path().toString()));\n+    Assert.assertTrue(\"FILE_B should be deleted\", deletedFiles.contains(FILE_B.path().toString()));\n+  }\n+\n+  @Test\n+  public void testNoFilesDeletedWhenNoSnapshotsExpired() throws Exception {\n+    Dataset<Row> df = buildDF(RECORDS);\n+\n+    writeDF(df, \"append\");\n+\n+    ExpireSnapshotsActionResult results =\n+        Actions.forTable(table).expireSnapshots().execute();\n+\n+    checkExpirationResults(0L, 0L, 0L, results);\n+  }\n+\n+  @Test\n+  public void testCleanupRepeatedOverwrites() throws Exception {\n+    Dataset<Row> df = buildDF(RECORDS);\n+\n+    writeDF(df, \"append\");\n+\n+    for (int i = 0; i < 10; i++) {\n+      writeDF(df, \"overwrite\");\n+    }\n+\n+    long end = System.currentTimeMillis();\n+    while (end <= table.currentSnapshot().timestampMillis()) {\n+      end = System.currentTimeMillis();\n+    }\n+\n+    ExpireSnapshotsActionResult results =\n+        Actions.forTable(table).expireSnapshots().expireOlderThan(end).execute();\n+\n+    checkExpirationResults(10L, 19L, 10L, results);\n+  }\n+\n+  @Test\n+  public void testRetainLastWithExpireOlderThan() {\n+    long t0 = System.currentTimeMillis();\n+    table.newAppend()\n+        .appendFile(FILE_A) // data_bucket=0\n+        .commit();\n+    long firstSnapshotId = table.currentSnapshot().snapshotId();\n+    long t1 = System.currentTimeMillis();\n+    while (t1 <= table.currentSnapshot().timestampMillis()) {\n+      t1 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_B) // data_bucket=1\n+        .commit();\n+\n+    long t2 = System.currentTimeMillis();\n+    while (t2 <= table.currentSnapshot().timestampMillis()) {\n+      t2 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_C) // data_bucket=2\n+        .commit();\n+\n+    long t3 = System.currentTimeMillis();\n+    while (t3 <= table.currentSnapshot().timestampMillis()) {\n+      t3 = System.currentTimeMillis();\n+    }\n+\n+    // Retain last 2 snapshots\n+    Actions.forTable(table).expireSnapshots()\n+        .expireOlderThan(t3)\n+        .retainLast(2)\n+        .execute();\n+\n+    Assert.assertEquals(\"Should have two snapshots.\",\n+        2, Lists.newArrayList(table.snapshots()).size());\n+    Assert.assertEquals(\"First snapshot should not present.\",\n+        null, table.snapshot(firstSnapshotId));\n+  }\n+\n+  @Test\n+  public void testRetainLastWithExpireById() {\n+    long t0 = System.currentTimeMillis();\n+    table.newAppend()\n+        .appendFile(FILE_A) // data_bucket=0\n+        .commit();\n+    long firstSnapshotId = table.currentSnapshot().snapshotId();\n+    long t1 = System.currentTimeMillis();\n+    while (t1 <= table.currentSnapshot().timestampMillis()) {\n+      t1 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_B) // data_bucket=1\n+        .commit();\n+\n+    long t2 = System.currentTimeMillis();\n+    while (t2 <= table.currentSnapshot().timestampMillis()) {\n+      t2 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_C) // data_bucket=2\n+        .commit();\n+\n+    long t3 = System.currentTimeMillis();\n+    while (t3 <= table.currentSnapshot().timestampMillis()) {\n+      t3 = System.currentTimeMillis();\n+    }\n+\n+    // Retain last 3 snapshots, but explicitly remove the first snapshot\n+    Actions.forTable(table).expireSnapshots()\n+        .expireSnapshotId(firstSnapshotId)\n+        .retainLast(3)\n+        .execute();\n+\n+    Assert.assertEquals(\"Should have two snapshots.\",\n+        2, Lists.newArrayList(table.snapshots()).size());\n+    Assert.assertEquals(\"First snapshot should not present.\",\n+        null, table.snapshot(firstSnapshotId));\n+  }\n+\n+  @Test\n+  public void testRetainLastWithTooFewSnapshots() {\n+    long t0 = System.currentTimeMillis();\n+    table.newAppend()\n+        .appendFile(FILE_A) // data_bucket=0\n+        .appendFile(FILE_B) // data_bucket=1\n+        .commit();\n+    long firstSnapshotId = table.currentSnapshot().snapshotId();\n+\n+    long t1 = System.currentTimeMillis();\n+    while (t1 <= table.currentSnapshot().timestampMillis()) {\n+      t1 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_C) // data_bucket=2\n+        .commit();\n+\n+    long t2 = System.currentTimeMillis();\n+    while (t2 <= table.currentSnapshot().timestampMillis()) {\n+      t2 = System.currentTimeMillis();\n+    }\n+\n+    // Retain last 3 snapshots\n+    Actions.forTable(table).expireSnapshots()\n+        .expireOlderThan(t2)\n+        .retainLast(3)\n+        .execute();\n+\n+    Assert.assertEquals(\"Should have two snapshots\",\n+        2, Lists.newArrayList(table.snapshots()).size());\n+    Assert.assertEquals(\"First snapshot should still present\",\n+        firstSnapshotId, table.snapshot(firstSnapshotId).snapshotId());\n+  }\n+\n+  @Test\n+  public void testRetainLastKeepsExpiringSnapshot() {\n+    long t0 = System.currentTimeMillis();\n+    table.newAppend()\n+        .appendFile(FILE_A) // data_bucket=0\n+        .commit();\n+    long t1 = System.currentTimeMillis();\n+    while (t1 <= table.currentSnapshot().timestampMillis()) {\n+      t1 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_B) // data_bucket=1\n+        .commit();\n+\n+    Snapshot secondSnapshot = table.currentSnapshot();\n+    long t2 = System.currentTimeMillis();\n+    while (t2 <= table.currentSnapshot().timestampMillis()) {\n+      t2 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_C) // data_bucket=2\n+        .commit();\n+\n+    long t3 = System.currentTimeMillis();\n+    while (t3 <= table.currentSnapshot().timestampMillis()) {\n+      t3 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_D) // data_bucket=3\n+        .commit();\n+\n+    long t4 = System.currentTimeMillis();\n+    while (t4 <= table.currentSnapshot().timestampMillis()) {\n+      t4 = System.currentTimeMillis();\n+    }\n+\n+    // Retain last 2 snapshots and expire older than t3\n+    Actions.forTable(table).expireSnapshots()\n+        .expireOlderThan(secondSnapshot.timestampMillis())\n+        .retainLast(2)\n+        .execute();\n+\n+    Assert.assertEquals(\"Should have three snapshots.\",\n+        3, Lists.newArrayList(table.snapshots()).size());\n+    Assert.assertNotNull(\"Second snapshot should present.\",\n+        table.snapshot(secondSnapshot.snapshotId()));\n+  }\n+\n+  @Test\n+  public void testExpireOlderThanMultipleCalls() {\n+    long t0 = System.currentTimeMillis();\n+    table.newAppend()\n+        .appendFile(FILE_A) // data_bucket=0\n+        .commit();\n+    long t1 = System.currentTimeMillis();\n+    while (t1 <= table.currentSnapshot().timestampMillis()) {\n+      t1 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_B) // data_bucket=1\n+        .commit();\n+\n+    Snapshot secondSnapshot = table.currentSnapshot();\n+    long t2 = System.currentTimeMillis();\n+    while (t2 <= table.currentSnapshot().timestampMillis()) {\n+      t2 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_C) // data_bucket=2\n+        .commit();\n+\n+    Snapshot thirdSnapshot = table.currentSnapshot();\n+    long t3 = System.currentTimeMillis();\n+    while (t3 <= table.currentSnapshot().timestampMillis()) {\n+      t3 = System.currentTimeMillis();\n+    }\n+\n+    // Retain last 2 snapshots and expire older than t3\n+    Actions.forTable(table).expireSnapshots()\n+        .expireOlderThan(secondSnapshot.timestampMillis())\n+        .expireOlderThan(thirdSnapshot.timestampMillis())\n+        .execute();\n+\n+    Assert.assertEquals(\"Should have one snapshots.\",\n+        1, Lists.newArrayList(table.snapshots()).size());\n+    Assert.assertNull(\"Second snapshot should not present.\",\n+        table.snapshot(secondSnapshot.snapshotId()));\n+  }\n+\n+  @Test\n+  public void testRetainLastMultipleCalls() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9cc4e831679d0aab1e4409210f3a7c57094c440c"}, "originalPosition": 474}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzNDE2NjE2", "url": "https://github.com/apache/iceberg/pull/1264#pullrequestreview-463416616", "createdAt": "2020-08-07T15:45:28Z", "commit": {"oid": "9cc4e831679d0aab1e4409210f3a7c57094c440c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNTo0NToyOFrOG9e0JQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNTo0NToyOFrOG9e0JQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzEyMTE4OQ==", "bodyText": "Ported Test - Only change is using ExpireSnapshotsAction", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r467121189", "createdAt": "2020-08-07T15:45:28Z", "author": {"login": "RussellSpitzer"}, "path": "spark/src/test/java/org/apache/iceberg/actions/TestExpireSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,780 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.BaseTable;\n+import org.apache.iceberg.DataFile;\n+import org.apache.iceberg.DataFiles;\n+import org.apache.iceberg.PartitionSpec;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.Snapshot;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableProperties;\n+import org.apache.iceberg.hadoop.HadoopTables;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableSet;\n+import org.apache.iceberg.relocated.com.google.common.collect.Iterables;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.relocated.com.google.common.collect.Sets;\n+import org.apache.iceberg.spark.SparkTestBase;\n+import org.apache.iceberg.spark.source.ThreeColumnRecord;\n+import org.apache.iceberg.types.Types;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import static org.apache.iceberg.types.Types.NestedField.optional;\n+\n+public abstract class TestExpireSnapshotsAction extends SparkTestBase {\n+\n+  private static final HadoopTables TABLES = new HadoopTables(new Configuration());\n+  private static final Schema SCHEMA = new Schema(\n+      optional(1, \"c1\", Types.IntegerType.get()),\n+      optional(2, \"c2\", Types.StringType.get()),\n+      optional(3, \"c3\", Types.StringType.get())\n+  );\n+\n+  private static final PartitionSpec SPEC = PartitionSpec.builderFor(SCHEMA).identity(\"c1\").build();\n+\n+  private static final List<ThreeColumnRecord> RECORDS = Lists.newArrayList(new ThreeColumnRecord(1, \"AAAA\", \"AAAA\"));\n+\n+  static final DataFile FILE_A = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-a.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=0\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+  static final DataFile FILE_B = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-b.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=1\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+  static final DataFile FILE_C = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-c.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=2\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+  static final DataFile FILE_D = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-d.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=3\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+\n+  @Rule\n+  public TemporaryFolder temp = new TemporaryFolder();\n+\n+  private File tableDir;\n+  private String tableLocation;\n+  private Table table;\n+\n+  @Before\n+  public void setupTableLocation() throws Exception {\n+    this.tableDir = temp.newFolder();\n+    this.tableLocation = tableDir.toURI().toString();\n+    this.table = TABLES.create(SCHEMA, SPEC, Maps.newHashMap(), tableLocation);\n+  }\n+\n+  private Dataset<Row> buildDF(List<ThreeColumnRecord> records) {\n+    return spark.createDataFrame(records, ThreeColumnRecord.class).coalesce(1);\n+  }\n+\n+  private void writeDF(Dataset<Row> df, String mode) {\n+    df.select(\"c1\", \"c2\", \"c3\")\n+        .write()\n+        .format(\"iceberg\")\n+        .mode(mode)\n+        .save(tableLocation);\n+  }\n+\n+  private void checkExpirationResults(Long expectedDatafiles, Long expectedManifestsDeleted,\n+      Long expectedManifestListsDeleted, ExpireSnapshotsActionResult results) {\n+\n+    Assert.assertEquals(\"Incorrect number of manifest files deleted\",\n+        expectedManifestsDeleted, results.getManifestFilesDeleted());\n+    Assert.assertEquals(\"Incorrect number of datafiles deleted\",\n+        expectedDatafiles, results.getDataFilesDeleted());\n+    Assert.assertEquals(\"Incorrect number of manifest lists deleted\",\n+        expectedManifestListsDeleted, results.getManifestListsDeleted());\n+  }\n+\n+  @Test\n+  public void testFilesCleaned() throws Exception {\n+    Dataset<Row> df = buildDF(RECORDS);\n+\n+    writeDF(df, \"append\");\n+\n+    List<Path> expiredDataFiles = Files\n+        .list(tableDir.toPath().resolve(\"data\").resolve(\"c1=1\"))\n+        .collect(Collectors.toList());\n+\n+    Assert.assertEquals(\"There should be a data file to delete but there was none.\",\n+        2, expiredDataFiles.size());\n+\n+    writeDF(df, \"overwrite\");\n+    writeDF(df, \"append\");\n+\n+    long end = System.currentTimeMillis();\n+    while (end <= table.currentSnapshot().timestampMillis()) {\n+      end = System.currentTimeMillis();\n+    }\n+\n+    ExpireSnapshotsActionResult results =\n+        Actions.forTable(table).expireSnapshots().expireOlderThan(end).execute();\n+\n+    table.refresh();\n+\n+    Assert.assertEquals(\"Table does not have 1 snapshot after expiration\", 1, Iterables.size(table.snapshots()));\n+\n+    for (Path p : expiredDataFiles) {\n+      Assert.assertFalse(String.format(\"File %s still exists but should have been deleted\", p),\n+          Files.exists(p));\n+    }\n+\n+    checkExpirationResults(1L, 2L, 2L, results);\n+  }\n+\n+  @Test\n+  public void dataFilesCleanupWithParallelTasks() throws IOException {\n+\n+    table.newFastAppend()\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    table.newFastAppend()\n+        .appendFile(FILE_B)\n+        .commit();\n+\n+    table.newRewrite()\n+        .rewriteFiles(ImmutableSet.of(FILE_B), ImmutableSet.of(FILE_D))\n+        .commit();\n+    long thirdSnapshotId = table.currentSnapshot().snapshotId();\n+\n+    table.newRewrite()\n+        .rewriteFiles(ImmutableSet.of(FILE_A), ImmutableSet.of(FILE_C))\n+        .commit();\n+    long fourthSnapshotId = table.currentSnapshot().snapshotId();\n+\n+    long t4 = System.currentTimeMillis();\n+    while (t4 <= table.currentSnapshot().timestampMillis()) {\n+      t4 = System.currentTimeMillis();\n+    }\n+\n+    Set<String> deletedFiles = Sets.newHashSet();\n+    Set<String> deleteThreads = ConcurrentHashMap.newKeySet();\n+    AtomicInteger deleteThreadsIndex = new AtomicInteger(0);\n+\n+    Actions.forTable(table).expireSnapshots()\n+        .executeDeleteWith(Executors.newFixedThreadPool(4, runnable -> {\n+          Thread thread = new Thread(runnable);\n+          thread.setName(\"remove-snapshot-\" + deleteThreadsIndex.getAndIncrement());\n+          thread.setDaemon(true); // daemon threads will be terminated abruptly when the JVM exits\n+          return thread;\n+        }))\n+        .expireOlderThan(t4)\n+        .deleteWith(s -> {\n+          deleteThreads.add(Thread.currentThread().getName());\n+          deletedFiles.add(s);\n+        })\n+        .execute();\n+\n+    // Verifies that the delete methods ran in the threads created by the provided ExecutorService ThreadFactory\n+    Assert.assertEquals(deleteThreads,\n+        Sets.newHashSet(\"remove-snapshot-0\", \"remove-snapshot-1\", \"remove-snapshot-2\", \"remove-snapshot-3\"));\n+\n+    Assert.assertTrue(\"FILE_A should be deleted\", deletedFiles.contains(FILE_A.path().toString()));\n+    Assert.assertTrue(\"FILE_B should be deleted\", deletedFiles.contains(FILE_B.path().toString()));\n+  }\n+\n+  @Test\n+  public void testNoFilesDeletedWhenNoSnapshotsExpired() throws Exception {\n+    Dataset<Row> df = buildDF(RECORDS);\n+\n+    writeDF(df, \"append\");\n+\n+    ExpireSnapshotsActionResult results =\n+        Actions.forTable(table).expireSnapshots().execute();\n+\n+    checkExpirationResults(0L, 0L, 0L, results);\n+  }\n+\n+  @Test\n+  public void testCleanupRepeatedOverwrites() throws Exception {\n+    Dataset<Row> df = buildDF(RECORDS);\n+\n+    writeDF(df, \"append\");\n+\n+    for (int i = 0; i < 10; i++) {\n+      writeDF(df, \"overwrite\");\n+    }\n+\n+    long end = System.currentTimeMillis();\n+    while (end <= table.currentSnapshot().timestampMillis()) {\n+      end = System.currentTimeMillis();\n+    }\n+\n+    ExpireSnapshotsActionResult results =\n+        Actions.forTable(table).expireSnapshots().expireOlderThan(end).execute();\n+\n+    checkExpirationResults(10L, 19L, 10L, results);\n+  }\n+\n+  @Test\n+  public void testRetainLastWithExpireOlderThan() {\n+    long t0 = System.currentTimeMillis();\n+    table.newAppend()\n+        .appendFile(FILE_A) // data_bucket=0\n+        .commit();\n+    long firstSnapshotId = table.currentSnapshot().snapshotId();\n+    long t1 = System.currentTimeMillis();\n+    while (t1 <= table.currentSnapshot().timestampMillis()) {\n+      t1 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_B) // data_bucket=1\n+        .commit();\n+\n+    long t2 = System.currentTimeMillis();\n+    while (t2 <= table.currentSnapshot().timestampMillis()) {\n+      t2 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_C) // data_bucket=2\n+        .commit();\n+\n+    long t3 = System.currentTimeMillis();\n+    while (t3 <= table.currentSnapshot().timestampMillis()) {\n+      t3 = System.currentTimeMillis();\n+    }\n+\n+    // Retain last 2 snapshots\n+    Actions.forTable(table).expireSnapshots()\n+        .expireOlderThan(t3)\n+        .retainLast(2)\n+        .execute();\n+\n+    Assert.assertEquals(\"Should have two snapshots.\",\n+        2, Lists.newArrayList(table.snapshots()).size());\n+    Assert.assertEquals(\"First snapshot should not present.\",\n+        null, table.snapshot(firstSnapshotId));\n+  }\n+\n+  @Test\n+  public void testRetainLastWithExpireById() {\n+    long t0 = System.currentTimeMillis();\n+    table.newAppend()\n+        .appendFile(FILE_A) // data_bucket=0\n+        .commit();\n+    long firstSnapshotId = table.currentSnapshot().snapshotId();\n+    long t1 = System.currentTimeMillis();\n+    while (t1 <= table.currentSnapshot().timestampMillis()) {\n+      t1 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_B) // data_bucket=1\n+        .commit();\n+\n+    long t2 = System.currentTimeMillis();\n+    while (t2 <= table.currentSnapshot().timestampMillis()) {\n+      t2 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_C) // data_bucket=2\n+        .commit();\n+\n+    long t3 = System.currentTimeMillis();\n+    while (t3 <= table.currentSnapshot().timestampMillis()) {\n+      t3 = System.currentTimeMillis();\n+    }\n+\n+    // Retain last 3 snapshots, but explicitly remove the first snapshot\n+    Actions.forTable(table).expireSnapshots()\n+        .expireSnapshotId(firstSnapshotId)\n+        .retainLast(3)\n+        .execute();\n+\n+    Assert.assertEquals(\"Should have two snapshots.\",\n+        2, Lists.newArrayList(table.snapshots()).size());\n+    Assert.assertEquals(\"First snapshot should not present.\",\n+        null, table.snapshot(firstSnapshotId));\n+  }\n+\n+  @Test\n+  public void testRetainLastWithTooFewSnapshots() {\n+    long t0 = System.currentTimeMillis();\n+    table.newAppend()\n+        .appendFile(FILE_A) // data_bucket=0\n+        .appendFile(FILE_B) // data_bucket=1\n+        .commit();\n+    long firstSnapshotId = table.currentSnapshot().snapshotId();\n+\n+    long t1 = System.currentTimeMillis();\n+    while (t1 <= table.currentSnapshot().timestampMillis()) {\n+      t1 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_C) // data_bucket=2\n+        .commit();\n+\n+    long t2 = System.currentTimeMillis();\n+    while (t2 <= table.currentSnapshot().timestampMillis()) {\n+      t2 = System.currentTimeMillis();\n+    }\n+\n+    // Retain last 3 snapshots\n+    Actions.forTable(table).expireSnapshots()\n+        .expireOlderThan(t2)\n+        .retainLast(3)\n+        .execute();\n+\n+    Assert.assertEquals(\"Should have two snapshots\",\n+        2, Lists.newArrayList(table.snapshots()).size());\n+    Assert.assertEquals(\"First snapshot should still present\",\n+        firstSnapshotId, table.snapshot(firstSnapshotId).snapshotId());\n+  }\n+\n+  @Test\n+  public void testRetainLastKeepsExpiringSnapshot() {\n+    long t0 = System.currentTimeMillis();\n+    table.newAppend()\n+        .appendFile(FILE_A) // data_bucket=0\n+        .commit();\n+    long t1 = System.currentTimeMillis();\n+    while (t1 <= table.currentSnapshot().timestampMillis()) {\n+      t1 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_B) // data_bucket=1\n+        .commit();\n+\n+    Snapshot secondSnapshot = table.currentSnapshot();\n+    long t2 = System.currentTimeMillis();\n+    while (t2 <= table.currentSnapshot().timestampMillis()) {\n+      t2 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_C) // data_bucket=2\n+        .commit();\n+\n+    long t3 = System.currentTimeMillis();\n+    while (t3 <= table.currentSnapshot().timestampMillis()) {\n+      t3 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_D) // data_bucket=3\n+        .commit();\n+\n+    long t4 = System.currentTimeMillis();\n+    while (t4 <= table.currentSnapshot().timestampMillis()) {\n+      t4 = System.currentTimeMillis();\n+    }\n+\n+    // Retain last 2 snapshots and expire older than t3\n+    Actions.forTable(table).expireSnapshots()\n+        .expireOlderThan(secondSnapshot.timestampMillis())\n+        .retainLast(2)\n+        .execute();\n+\n+    Assert.assertEquals(\"Should have three snapshots.\",\n+        3, Lists.newArrayList(table.snapshots()).size());\n+    Assert.assertNotNull(\"Second snapshot should present.\",\n+        table.snapshot(secondSnapshot.snapshotId()));\n+  }\n+\n+  @Test\n+  public void testExpireOlderThanMultipleCalls() {\n+    long t0 = System.currentTimeMillis();\n+    table.newAppend()\n+        .appendFile(FILE_A) // data_bucket=0\n+        .commit();\n+    long t1 = System.currentTimeMillis();\n+    while (t1 <= table.currentSnapshot().timestampMillis()) {\n+      t1 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_B) // data_bucket=1\n+        .commit();\n+\n+    Snapshot secondSnapshot = table.currentSnapshot();\n+    long t2 = System.currentTimeMillis();\n+    while (t2 <= table.currentSnapshot().timestampMillis()) {\n+      t2 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_C) // data_bucket=2\n+        .commit();\n+\n+    Snapshot thirdSnapshot = table.currentSnapshot();\n+    long t3 = System.currentTimeMillis();\n+    while (t3 <= table.currentSnapshot().timestampMillis()) {\n+      t3 = System.currentTimeMillis();\n+    }\n+\n+    // Retain last 2 snapshots and expire older than t3\n+    Actions.forTable(table).expireSnapshots()\n+        .expireOlderThan(secondSnapshot.timestampMillis())\n+        .expireOlderThan(thirdSnapshot.timestampMillis())\n+        .execute();\n+\n+    Assert.assertEquals(\"Should have one snapshots.\",\n+        1, Lists.newArrayList(table.snapshots()).size());\n+    Assert.assertNull(\"Second snapshot should not present.\",\n+        table.snapshot(secondSnapshot.snapshotId()));\n+  }\n+\n+  @Test\n+  public void testRetainLastMultipleCalls() {\n+    long t0 = System.currentTimeMillis();\n+    table.newAppend()\n+        .appendFile(FILE_A) // data_bucket=0\n+        .commit();\n+    long t1 = System.currentTimeMillis();\n+    while (t1 <= table.currentSnapshot().timestampMillis()) {\n+      t1 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_B) // data_bucket=1\n+        .commit();\n+\n+    Snapshot secondSnapshot = table.currentSnapshot();\n+    long t2 = System.currentTimeMillis();\n+    while (t2 <= table.currentSnapshot().timestampMillis()) {\n+      t2 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_C) // data_bucket=2\n+        .commit();\n+\n+    long t3 = System.currentTimeMillis();\n+    while (t3 <= table.currentSnapshot().timestampMillis()) {\n+      t3 = System.currentTimeMillis();\n+    }\n+\n+    // Retain last 2 snapshots and expire older than t3\n+    Actions.forTable(table).expireSnapshots()\n+        .expireOlderThan(t3)\n+        .retainLast(2)\n+        .retainLast(1)\n+        .execute();\n+\n+    Assert.assertEquals(\"Should have one snapshots.\",\n+        1, Lists.newArrayList(table.snapshots()).size());\n+    Assert.assertNull(\"Second snapshot should not present.\",\n+        table.snapshot(secondSnapshot.snapshotId()));\n+  }\n+\n+  @Test\n+  public void testRetainZeroSnapshots() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9cc4e831679d0aab1e4409210f3a7c57094c440c"}, "originalPosition": 517}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzNDE2Njgz", "url": "https://github.com/apache/iceberg/pull/1264#pullrequestreview-463416683", "createdAt": "2020-08-07T15:45:35Z", "commit": {"oid": "9cc4e831679d0aab1e4409210f3a7c57094c440c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNTo0NTozNVrOG9e0WQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNTo0NTozNVrOG9e0WQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzEyMTI0MQ==", "bodyText": "Ported Test - Only change is using ExpireSnapshotsAction", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r467121241", "createdAt": "2020-08-07T15:45:35Z", "author": {"login": "RussellSpitzer"}, "path": "spark/src/test/java/org/apache/iceberg/actions/TestExpireSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,780 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.BaseTable;\n+import org.apache.iceberg.DataFile;\n+import org.apache.iceberg.DataFiles;\n+import org.apache.iceberg.PartitionSpec;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.Snapshot;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableProperties;\n+import org.apache.iceberg.hadoop.HadoopTables;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableSet;\n+import org.apache.iceberg.relocated.com.google.common.collect.Iterables;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.relocated.com.google.common.collect.Sets;\n+import org.apache.iceberg.spark.SparkTestBase;\n+import org.apache.iceberg.spark.source.ThreeColumnRecord;\n+import org.apache.iceberg.types.Types;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import static org.apache.iceberg.types.Types.NestedField.optional;\n+\n+public abstract class TestExpireSnapshotsAction extends SparkTestBase {\n+\n+  private static final HadoopTables TABLES = new HadoopTables(new Configuration());\n+  private static final Schema SCHEMA = new Schema(\n+      optional(1, \"c1\", Types.IntegerType.get()),\n+      optional(2, \"c2\", Types.StringType.get()),\n+      optional(3, \"c3\", Types.StringType.get())\n+  );\n+\n+  private static final PartitionSpec SPEC = PartitionSpec.builderFor(SCHEMA).identity(\"c1\").build();\n+\n+  private static final List<ThreeColumnRecord> RECORDS = Lists.newArrayList(new ThreeColumnRecord(1, \"AAAA\", \"AAAA\"));\n+\n+  static final DataFile FILE_A = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-a.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=0\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+  static final DataFile FILE_B = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-b.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=1\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+  static final DataFile FILE_C = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-c.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=2\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+  static final DataFile FILE_D = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-d.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=3\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+\n+  @Rule\n+  public TemporaryFolder temp = new TemporaryFolder();\n+\n+  private File tableDir;\n+  private String tableLocation;\n+  private Table table;\n+\n+  @Before\n+  public void setupTableLocation() throws Exception {\n+    this.tableDir = temp.newFolder();\n+    this.tableLocation = tableDir.toURI().toString();\n+    this.table = TABLES.create(SCHEMA, SPEC, Maps.newHashMap(), tableLocation);\n+  }\n+\n+  private Dataset<Row> buildDF(List<ThreeColumnRecord> records) {\n+    return spark.createDataFrame(records, ThreeColumnRecord.class).coalesce(1);\n+  }\n+\n+  private void writeDF(Dataset<Row> df, String mode) {\n+    df.select(\"c1\", \"c2\", \"c3\")\n+        .write()\n+        .format(\"iceberg\")\n+        .mode(mode)\n+        .save(tableLocation);\n+  }\n+\n+  private void checkExpirationResults(Long expectedDatafiles, Long expectedManifestsDeleted,\n+      Long expectedManifestListsDeleted, ExpireSnapshotsActionResult results) {\n+\n+    Assert.assertEquals(\"Incorrect number of manifest files deleted\",\n+        expectedManifestsDeleted, results.getManifestFilesDeleted());\n+    Assert.assertEquals(\"Incorrect number of datafiles deleted\",\n+        expectedDatafiles, results.getDataFilesDeleted());\n+    Assert.assertEquals(\"Incorrect number of manifest lists deleted\",\n+        expectedManifestListsDeleted, results.getManifestListsDeleted());\n+  }\n+\n+  @Test\n+  public void testFilesCleaned() throws Exception {\n+    Dataset<Row> df = buildDF(RECORDS);\n+\n+    writeDF(df, \"append\");\n+\n+    List<Path> expiredDataFiles = Files\n+        .list(tableDir.toPath().resolve(\"data\").resolve(\"c1=1\"))\n+        .collect(Collectors.toList());\n+\n+    Assert.assertEquals(\"There should be a data file to delete but there was none.\",\n+        2, expiredDataFiles.size());\n+\n+    writeDF(df, \"overwrite\");\n+    writeDF(df, \"append\");\n+\n+    long end = System.currentTimeMillis();\n+    while (end <= table.currentSnapshot().timestampMillis()) {\n+      end = System.currentTimeMillis();\n+    }\n+\n+    ExpireSnapshotsActionResult results =\n+        Actions.forTable(table).expireSnapshots().expireOlderThan(end).execute();\n+\n+    table.refresh();\n+\n+    Assert.assertEquals(\"Table does not have 1 snapshot after expiration\", 1, Iterables.size(table.snapshots()));\n+\n+    for (Path p : expiredDataFiles) {\n+      Assert.assertFalse(String.format(\"File %s still exists but should have been deleted\", p),\n+          Files.exists(p));\n+    }\n+\n+    checkExpirationResults(1L, 2L, 2L, results);\n+  }\n+\n+  @Test\n+  public void dataFilesCleanupWithParallelTasks() throws IOException {\n+\n+    table.newFastAppend()\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    table.newFastAppend()\n+        .appendFile(FILE_B)\n+        .commit();\n+\n+    table.newRewrite()\n+        .rewriteFiles(ImmutableSet.of(FILE_B), ImmutableSet.of(FILE_D))\n+        .commit();\n+    long thirdSnapshotId = table.currentSnapshot().snapshotId();\n+\n+    table.newRewrite()\n+        .rewriteFiles(ImmutableSet.of(FILE_A), ImmutableSet.of(FILE_C))\n+        .commit();\n+    long fourthSnapshotId = table.currentSnapshot().snapshotId();\n+\n+    long t4 = System.currentTimeMillis();\n+    while (t4 <= table.currentSnapshot().timestampMillis()) {\n+      t4 = System.currentTimeMillis();\n+    }\n+\n+    Set<String> deletedFiles = Sets.newHashSet();\n+    Set<String> deleteThreads = ConcurrentHashMap.newKeySet();\n+    AtomicInteger deleteThreadsIndex = new AtomicInteger(0);\n+\n+    Actions.forTable(table).expireSnapshots()\n+        .executeDeleteWith(Executors.newFixedThreadPool(4, runnable -> {\n+          Thread thread = new Thread(runnable);\n+          thread.setName(\"remove-snapshot-\" + deleteThreadsIndex.getAndIncrement());\n+          thread.setDaemon(true); // daemon threads will be terminated abruptly when the JVM exits\n+          return thread;\n+        }))\n+        .expireOlderThan(t4)\n+        .deleteWith(s -> {\n+          deleteThreads.add(Thread.currentThread().getName());\n+          deletedFiles.add(s);\n+        })\n+        .execute();\n+\n+    // Verifies that the delete methods ran in the threads created by the provided ExecutorService ThreadFactory\n+    Assert.assertEquals(deleteThreads,\n+        Sets.newHashSet(\"remove-snapshot-0\", \"remove-snapshot-1\", \"remove-snapshot-2\", \"remove-snapshot-3\"));\n+\n+    Assert.assertTrue(\"FILE_A should be deleted\", deletedFiles.contains(FILE_A.path().toString()));\n+    Assert.assertTrue(\"FILE_B should be deleted\", deletedFiles.contains(FILE_B.path().toString()));\n+  }\n+\n+  @Test\n+  public void testNoFilesDeletedWhenNoSnapshotsExpired() throws Exception {\n+    Dataset<Row> df = buildDF(RECORDS);\n+\n+    writeDF(df, \"append\");\n+\n+    ExpireSnapshotsActionResult results =\n+        Actions.forTable(table).expireSnapshots().execute();\n+\n+    checkExpirationResults(0L, 0L, 0L, results);\n+  }\n+\n+  @Test\n+  public void testCleanupRepeatedOverwrites() throws Exception {\n+    Dataset<Row> df = buildDF(RECORDS);\n+\n+    writeDF(df, \"append\");\n+\n+    for (int i = 0; i < 10; i++) {\n+      writeDF(df, \"overwrite\");\n+    }\n+\n+    long end = System.currentTimeMillis();\n+    while (end <= table.currentSnapshot().timestampMillis()) {\n+      end = System.currentTimeMillis();\n+    }\n+\n+    ExpireSnapshotsActionResult results =\n+        Actions.forTable(table).expireSnapshots().expireOlderThan(end).execute();\n+\n+    checkExpirationResults(10L, 19L, 10L, results);\n+  }\n+\n+  @Test\n+  public void testRetainLastWithExpireOlderThan() {\n+    long t0 = System.currentTimeMillis();\n+    table.newAppend()\n+        .appendFile(FILE_A) // data_bucket=0\n+        .commit();\n+    long firstSnapshotId = table.currentSnapshot().snapshotId();\n+    long t1 = System.currentTimeMillis();\n+    while (t1 <= table.currentSnapshot().timestampMillis()) {\n+      t1 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_B) // data_bucket=1\n+        .commit();\n+\n+    long t2 = System.currentTimeMillis();\n+    while (t2 <= table.currentSnapshot().timestampMillis()) {\n+      t2 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_C) // data_bucket=2\n+        .commit();\n+\n+    long t3 = System.currentTimeMillis();\n+    while (t3 <= table.currentSnapshot().timestampMillis()) {\n+      t3 = System.currentTimeMillis();\n+    }\n+\n+    // Retain last 2 snapshots\n+    Actions.forTable(table).expireSnapshots()\n+        .expireOlderThan(t3)\n+        .retainLast(2)\n+        .execute();\n+\n+    Assert.assertEquals(\"Should have two snapshots.\",\n+        2, Lists.newArrayList(table.snapshots()).size());\n+    Assert.assertEquals(\"First snapshot should not present.\",\n+        null, table.snapshot(firstSnapshotId));\n+  }\n+\n+  @Test\n+  public void testRetainLastWithExpireById() {\n+    long t0 = System.currentTimeMillis();\n+    table.newAppend()\n+        .appendFile(FILE_A) // data_bucket=0\n+        .commit();\n+    long firstSnapshotId = table.currentSnapshot().snapshotId();\n+    long t1 = System.currentTimeMillis();\n+    while (t1 <= table.currentSnapshot().timestampMillis()) {\n+      t1 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_B) // data_bucket=1\n+        .commit();\n+\n+    long t2 = System.currentTimeMillis();\n+    while (t2 <= table.currentSnapshot().timestampMillis()) {\n+      t2 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_C) // data_bucket=2\n+        .commit();\n+\n+    long t3 = System.currentTimeMillis();\n+    while (t3 <= table.currentSnapshot().timestampMillis()) {\n+      t3 = System.currentTimeMillis();\n+    }\n+\n+    // Retain last 3 snapshots, but explicitly remove the first snapshot\n+    Actions.forTable(table).expireSnapshots()\n+        .expireSnapshotId(firstSnapshotId)\n+        .retainLast(3)\n+        .execute();\n+\n+    Assert.assertEquals(\"Should have two snapshots.\",\n+        2, Lists.newArrayList(table.snapshots()).size());\n+    Assert.assertEquals(\"First snapshot should not present.\",\n+        null, table.snapshot(firstSnapshotId));\n+  }\n+\n+  @Test\n+  public void testRetainLastWithTooFewSnapshots() {\n+    long t0 = System.currentTimeMillis();\n+    table.newAppend()\n+        .appendFile(FILE_A) // data_bucket=0\n+        .appendFile(FILE_B) // data_bucket=1\n+        .commit();\n+    long firstSnapshotId = table.currentSnapshot().snapshotId();\n+\n+    long t1 = System.currentTimeMillis();\n+    while (t1 <= table.currentSnapshot().timestampMillis()) {\n+      t1 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_C) // data_bucket=2\n+        .commit();\n+\n+    long t2 = System.currentTimeMillis();\n+    while (t2 <= table.currentSnapshot().timestampMillis()) {\n+      t2 = System.currentTimeMillis();\n+    }\n+\n+    // Retain last 3 snapshots\n+    Actions.forTable(table).expireSnapshots()\n+        .expireOlderThan(t2)\n+        .retainLast(3)\n+        .execute();\n+\n+    Assert.assertEquals(\"Should have two snapshots\",\n+        2, Lists.newArrayList(table.snapshots()).size());\n+    Assert.assertEquals(\"First snapshot should still present\",\n+        firstSnapshotId, table.snapshot(firstSnapshotId).snapshotId());\n+  }\n+\n+  @Test\n+  public void testRetainLastKeepsExpiringSnapshot() {\n+    long t0 = System.currentTimeMillis();\n+    table.newAppend()\n+        .appendFile(FILE_A) // data_bucket=0\n+        .commit();\n+    long t1 = System.currentTimeMillis();\n+    while (t1 <= table.currentSnapshot().timestampMillis()) {\n+      t1 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_B) // data_bucket=1\n+        .commit();\n+\n+    Snapshot secondSnapshot = table.currentSnapshot();\n+    long t2 = System.currentTimeMillis();\n+    while (t2 <= table.currentSnapshot().timestampMillis()) {\n+      t2 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_C) // data_bucket=2\n+        .commit();\n+\n+    long t3 = System.currentTimeMillis();\n+    while (t3 <= table.currentSnapshot().timestampMillis()) {\n+      t3 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_D) // data_bucket=3\n+        .commit();\n+\n+    long t4 = System.currentTimeMillis();\n+    while (t4 <= table.currentSnapshot().timestampMillis()) {\n+      t4 = System.currentTimeMillis();\n+    }\n+\n+    // Retain last 2 snapshots and expire older than t3\n+    Actions.forTable(table).expireSnapshots()\n+        .expireOlderThan(secondSnapshot.timestampMillis())\n+        .retainLast(2)\n+        .execute();\n+\n+    Assert.assertEquals(\"Should have three snapshots.\",\n+        3, Lists.newArrayList(table.snapshots()).size());\n+    Assert.assertNotNull(\"Second snapshot should present.\",\n+        table.snapshot(secondSnapshot.snapshotId()));\n+  }\n+\n+  @Test\n+  public void testExpireOlderThanMultipleCalls() {\n+    long t0 = System.currentTimeMillis();\n+    table.newAppend()\n+        .appendFile(FILE_A) // data_bucket=0\n+        .commit();\n+    long t1 = System.currentTimeMillis();\n+    while (t1 <= table.currentSnapshot().timestampMillis()) {\n+      t1 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_B) // data_bucket=1\n+        .commit();\n+\n+    Snapshot secondSnapshot = table.currentSnapshot();\n+    long t2 = System.currentTimeMillis();\n+    while (t2 <= table.currentSnapshot().timestampMillis()) {\n+      t2 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_C) // data_bucket=2\n+        .commit();\n+\n+    Snapshot thirdSnapshot = table.currentSnapshot();\n+    long t3 = System.currentTimeMillis();\n+    while (t3 <= table.currentSnapshot().timestampMillis()) {\n+      t3 = System.currentTimeMillis();\n+    }\n+\n+    // Retain last 2 snapshots and expire older than t3\n+    Actions.forTable(table).expireSnapshots()\n+        .expireOlderThan(secondSnapshot.timestampMillis())\n+        .expireOlderThan(thirdSnapshot.timestampMillis())\n+        .execute();\n+\n+    Assert.assertEquals(\"Should have one snapshots.\",\n+        1, Lists.newArrayList(table.snapshots()).size());\n+    Assert.assertNull(\"Second snapshot should not present.\",\n+        table.snapshot(secondSnapshot.snapshotId()));\n+  }\n+\n+  @Test\n+  public void testRetainLastMultipleCalls() {\n+    long t0 = System.currentTimeMillis();\n+    table.newAppend()\n+        .appendFile(FILE_A) // data_bucket=0\n+        .commit();\n+    long t1 = System.currentTimeMillis();\n+    while (t1 <= table.currentSnapshot().timestampMillis()) {\n+      t1 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_B) // data_bucket=1\n+        .commit();\n+\n+    Snapshot secondSnapshot = table.currentSnapshot();\n+    long t2 = System.currentTimeMillis();\n+    while (t2 <= table.currentSnapshot().timestampMillis()) {\n+      t2 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_C) // data_bucket=2\n+        .commit();\n+\n+    long t3 = System.currentTimeMillis();\n+    while (t3 <= table.currentSnapshot().timestampMillis()) {\n+      t3 = System.currentTimeMillis();\n+    }\n+\n+    // Retain last 2 snapshots and expire older than t3\n+    Actions.forTable(table).expireSnapshots()\n+        .expireOlderThan(t3)\n+        .retainLast(2)\n+        .retainLast(1)\n+        .execute();\n+\n+    Assert.assertEquals(\"Should have one snapshots.\",\n+        1, Lists.newArrayList(table.snapshots()).size());\n+    Assert.assertNull(\"Second snapshot should not present.\",\n+        table.snapshot(secondSnapshot.snapshotId()));\n+  }\n+\n+  @Test\n+  public void testRetainZeroSnapshots() {\n+    AssertHelpers.assertThrows(\"Should fail retain 0 snapshots \" +\n+            \"because number of snapshots to retain cannot be zero\",\n+        IllegalArgumentException.class,\n+        \"Number of snapshots to retain must be at least 1, cannot be: 0\",\n+        () -> Actions.forTable(table).expireSnapshots().retainLast(0).execute());\n+  }\n+\n+  @Test\n+  public void testScanExpiredManifestInValidSnapshotAppend() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9cc4e831679d0aab1e4409210f3a7c57094c440c"}, "originalPosition": 526}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzNDE2ODIx", "url": "https://github.com/apache/iceberg/pull/1264#pullrequestreview-463416821", "createdAt": "2020-08-07T15:45:46Z", "commit": {"oid": "9cc4e831679d0aab1e4409210f3a7c57094c440c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNTo0NTo0N1rOG9e00Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNTo0NTo0N1rOG9e00Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzEyMTM2MQ==", "bodyText": "Ported Test - Only change is using ExpireSnapshotsAction", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r467121361", "createdAt": "2020-08-07T15:45:47Z", "author": {"login": "RussellSpitzer"}, "path": "spark/src/test/java/org/apache/iceberg/actions/TestExpireSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,780 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.BaseTable;\n+import org.apache.iceberg.DataFile;\n+import org.apache.iceberg.DataFiles;\n+import org.apache.iceberg.PartitionSpec;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.Snapshot;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableProperties;\n+import org.apache.iceberg.hadoop.HadoopTables;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableSet;\n+import org.apache.iceberg.relocated.com.google.common.collect.Iterables;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.relocated.com.google.common.collect.Sets;\n+import org.apache.iceberg.spark.SparkTestBase;\n+import org.apache.iceberg.spark.source.ThreeColumnRecord;\n+import org.apache.iceberg.types.Types;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import static org.apache.iceberg.types.Types.NestedField.optional;\n+\n+public abstract class TestExpireSnapshotsAction extends SparkTestBase {\n+\n+  private static final HadoopTables TABLES = new HadoopTables(new Configuration());\n+  private static final Schema SCHEMA = new Schema(\n+      optional(1, \"c1\", Types.IntegerType.get()),\n+      optional(2, \"c2\", Types.StringType.get()),\n+      optional(3, \"c3\", Types.StringType.get())\n+  );\n+\n+  private static final PartitionSpec SPEC = PartitionSpec.builderFor(SCHEMA).identity(\"c1\").build();\n+\n+  private static final List<ThreeColumnRecord> RECORDS = Lists.newArrayList(new ThreeColumnRecord(1, \"AAAA\", \"AAAA\"));\n+\n+  static final DataFile FILE_A = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-a.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=0\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+  static final DataFile FILE_B = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-b.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=1\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+  static final DataFile FILE_C = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-c.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=2\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+  static final DataFile FILE_D = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-d.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=3\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+\n+  @Rule\n+  public TemporaryFolder temp = new TemporaryFolder();\n+\n+  private File tableDir;\n+  private String tableLocation;\n+  private Table table;\n+\n+  @Before\n+  public void setupTableLocation() throws Exception {\n+    this.tableDir = temp.newFolder();\n+    this.tableLocation = tableDir.toURI().toString();\n+    this.table = TABLES.create(SCHEMA, SPEC, Maps.newHashMap(), tableLocation);\n+  }\n+\n+  private Dataset<Row> buildDF(List<ThreeColumnRecord> records) {\n+    return spark.createDataFrame(records, ThreeColumnRecord.class).coalesce(1);\n+  }\n+\n+  private void writeDF(Dataset<Row> df, String mode) {\n+    df.select(\"c1\", \"c2\", \"c3\")\n+        .write()\n+        .format(\"iceberg\")\n+        .mode(mode)\n+        .save(tableLocation);\n+  }\n+\n+  private void checkExpirationResults(Long expectedDatafiles, Long expectedManifestsDeleted,\n+      Long expectedManifestListsDeleted, ExpireSnapshotsActionResult results) {\n+\n+    Assert.assertEquals(\"Incorrect number of manifest files deleted\",\n+        expectedManifestsDeleted, results.getManifestFilesDeleted());\n+    Assert.assertEquals(\"Incorrect number of datafiles deleted\",\n+        expectedDatafiles, results.getDataFilesDeleted());\n+    Assert.assertEquals(\"Incorrect number of manifest lists deleted\",\n+        expectedManifestListsDeleted, results.getManifestListsDeleted());\n+  }\n+\n+  @Test\n+  public void testFilesCleaned() throws Exception {\n+    Dataset<Row> df = buildDF(RECORDS);\n+\n+    writeDF(df, \"append\");\n+\n+    List<Path> expiredDataFiles = Files\n+        .list(tableDir.toPath().resolve(\"data\").resolve(\"c1=1\"))\n+        .collect(Collectors.toList());\n+\n+    Assert.assertEquals(\"There should be a data file to delete but there was none.\",\n+        2, expiredDataFiles.size());\n+\n+    writeDF(df, \"overwrite\");\n+    writeDF(df, \"append\");\n+\n+    long end = System.currentTimeMillis();\n+    while (end <= table.currentSnapshot().timestampMillis()) {\n+      end = System.currentTimeMillis();\n+    }\n+\n+    ExpireSnapshotsActionResult results =\n+        Actions.forTable(table).expireSnapshots().expireOlderThan(end).execute();\n+\n+    table.refresh();\n+\n+    Assert.assertEquals(\"Table does not have 1 snapshot after expiration\", 1, Iterables.size(table.snapshots()));\n+\n+    for (Path p : expiredDataFiles) {\n+      Assert.assertFalse(String.format(\"File %s still exists but should have been deleted\", p),\n+          Files.exists(p));\n+    }\n+\n+    checkExpirationResults(1L, 2L, 2L, results);\n+  }\n+\n+  @Test\n+  public void dataFilesCleanupWithParallelTasks() throws IOException {\n+\n+    table.newFastAppend()\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    table.newFastAppend()\n+        .appendFile(FILE_B)\n+        .commit();\n+\n+    table.newRewrite()\n+        .rewriteFiles(ImmutableSet.of(FILE_B), ImmutableSet.of(FILE_D))\n+        .commit();\n+    long thirdSnapshotId = table.currentSnapshot().snapshotId();\n+\n+    table.newRewrite()\n+        .rewriteFiles(ImmutableSet.of(FILE_A), ImmutableSet.of(FILE_C))\n+        .commit();\n+    long fourthSnapshotId = table.currentSnapshot().snapshotId();\n+\n+    long t4 = System.currentTimeMillis();\n+    while (t4 <= table.currentSnapshot().timestampMillis()) {\n+      t4 = System.currentTimeMillis();\n+    }\n+\n+    Set<String> deletedFiles = Sets.newHashSet();\n+    Set<String> deleteThreads = ConcurrentHashMap.newKeySet();\n+    AtomicInteger deleteThreadsIndex = new AtomicInteger(0);\n+\n+    Actions.forTable(table).expireSnapshots()\n+        .executeDeleteWith(Executors.newFixedThreadPool(4, runnable -> {\n+          Thread thread = new Thread(runnable);\n+          thread.setName(\"remove-snapshot-\" + deleteThreadsIndex.getAndIncrement());\n+          thread.setDaemon(true); // daemon threads will be terminated abruptly when the JVM exits\n+          return thread;\n+        }))\n+        .expireOlderThan(t4)\n+        .deleteWith(s -> {\n+          deleteThreads.add(Thread.currentThread().getName());\n+          deletedFiles.add(s);\n+        })\n+        .execute();\n+\n+    // Verifies that the delete methods ran in the threads created by the provided ExecutorService ThreadFactory\n+    Assert.assertEquals(deleteThreads,\n+        Sets.newHashSet(\"remove-snapshot-0\", \"remove-snapshot-1\", \"remove-snapshot-2\", \"remove-snapshot-3\"));\n+\n+    Assert.assertTrue(\"FILE_A should be deleted\", deletedFiles.contains(FILE_A.path().toString()));\n+    Assert.assertTrue(\"FILE_B should be deleted\", deletedFiles.contains(FILE_B.path().toString()));\n+  }\n+\n+  @Test\n+  public void testNoFilesDeletedWhenNoSnapshotsExpired() throws Exception {\n+    Dataset<Row> df = buildDF(RECORDS);\n+\n+    writeDF(df, \"append\");\n+\n+    ExpireSnapshotsActionResult results =\n+        Actions.forTable(table).expireSnapshots().execute();\n+\n+    checkExpirationResults(0L, 0L, 0L, results);\n+  }\n+\n+  @Test\n+  public void testCleanupRepeatedOverwrites() throws Exception {\n+    Dataset<Row> df = buildDF(RECORDS);\n+\n+    writeDF(df, \"append\");\n+\n+    for (int i = 0; i < 10; i++) {\n+      writeDF(df, \"overwrite\");\n+    }\n+\n+    long end = System.currentTimeMillis();\n+    while (end <= table.currentSnapshot().timestampMillis()) {\n+      end = System.currentTimeMillis();\n+    }\n+\n+    ExpireSnapshotsActionResult results =\n+        Actions.forTable(table).expireSnapshots().expireOlderThan(end).execute();\n+\n+    checkExpirationResults(10L, 19L, 10L, results);\n+  }\n+\n+  @Test\n+  public void testRetainLastWithExpireOlderThan() {\n+    long t0 = System.currentTimeMillis();\n+    table.newAppend()\n+        .appendFile(FILE_A) // data_bucket=0\n+        .commit();\n+    long firstSnapshotId = table.currentSnapshot().snapshotId();\n+    long t1 = System.currentTimeMillis();\n+    while (t1 <= table.currentSnapshot().timestampMillis()) {\n+      t1 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_B) // data_bucket=1\n+        .commit();\n+\n+    long t2 = System.currentTimeMillis();\n+    while (t2 <= table.currentSnapshot().timestampMillis()) {\n+      t2 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_C) // data_bucket=2\n+        .commit();\n+\n+    long t3 = System.currentTimeMillis();\n+    while (t3 <= table.currentSnapshot().timestampMillis()) {\n+      t3 = System.currentTimeMillis();\n+    }\n+\n+    // Retain last 2 snapshots\n+    Actions.forTable(table).expireSnapshots()\n+        .expireOlderThan(t3)\n+        .retainLast(2)\n+        .execute();\n+\n+    Assert.assertEquals(\"Should have two snapshots.\",\n+        2, Lists.newArrayList(table.snapshots()).size());\n+    Assert.assertEquals(\"First snapshot should not present.\",\n+        null, table.snapshot(firstSnapshotId));\n+  }\n+\n+  @Test\n+  public void testRetainLastWithExpireById() {\n+    long t0 = System.currentTimeMillis();\n+    table.newAppend()\n+        .appendFile(FILE_A) // data_bucket=0\n+        .commit();\n+    long firstSnapshotId = table.currentSnapshot().snapshotId();\n+    long t1 = System.currentTimeMillis();\n+    while (t1 <= table.currentSnapshot().timestampMillis()) {\n+      t1 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_B) // data_bucket=1\n+        .commit();\n+\n+    long t2 = System.currentTimeMillis();\n+    while (t2 <= table.currentSnapshot().timestampMillis()) {\n+      t2 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_C) // data_bucket=2\n+        .commit();\n+\n+    long t3 = System.currentTimeMillis();\n+    while (t3 <= table.currentSnapshot().timestampMillis()) {\n+      t3 = System.currentTimeMillis();\n+    }\n+\n+    // Retain last 3 snapshots, but explicitly remove the first snapshot\n+    Actions.forTable(table).expireSnapshots()\n+        .expireSnapshotId(firstSnapshotId)\n+        .retainLast(3)\n+        .execute();\n+\n+    Assert.assertEquals(\"Should have two snapshots.\",\n+        2, Lists.newArrayList(table.snapshots()).size());\n+    Assert.assertEquals(\"First snapshot should not present.\",\n+        null, table.snapshot(firstSnapshotId));\n+  }\n+\n+  @Test\n+  public void testRetainLastWithTooFewSnapshots() {\n+    long t0 = System.currentTimeMillis();\n+    table.newAppend()\n+        .appendFile(FILE_A) // data_bucket=0\n+        .appendFile(FILE_B) // data_bucket=1\n+        .commit();\n+    long firstSnapshotId = table.currentSnapshot().snapshotId();\n+\n+    long t1 = System.currentTimeMillis();\n+    while (t1 <= table.currentSnapshot().timestampMillis()) {\n+      t1 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_C) // data_bucket=2\n+        .commit();\n+\n+    long t2 = System.currentTimeMillis();\n+    while (t2 <= table.currentSnapshot().timestampMillis()) {\n+      t2 = System.currentTimeMillis();\n+    }\n+\n+    // Retain last 3 snapshots\n+    Actions.forTable(table).expireSnapshots()\n+        .expireOlderThan(t2)\n+        .retainLast(3)\n+        .execute();\n+\n+    Assert.assertEquals(\"Should have two snapshots\",\n+        2, Lists.newArrayList(table.snapshots()).size());\n+    Assert.assertEquals(\"First snapshot should still present\",\n+        firstSnapshotId, table.snapshot(firstSnapshotId).snapshotId());\n+  }\n+\n+  @Test\n+  public void testRetainLastKeepsExpiringSnapshot() {\n+    long t0 = System.currentTimeMillis();\n+    table.newAppend()\n+        .appendFile(FILE_A) // data_bucket=0\n+        .commit();\n+    long t1 = System.currentTimeMillis();\n+    while (t1 <= table.currentSnapshot().timestampMillis()) {\n+      t1 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_B) // data_bucket=1\n+        .commit();\n+\n+    Snapshot secondSnapshot = table.currentSnapshot();\n+    long t2 = System.currentTimeMillis();\n+    while (t2 <= table.currentSnapshot().timestampMillis()) {\n+      t2 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_C) // data_bucket=2\n+        .commit();\n+\n+    long t3 = System.currentTimeMillis();\n+    while (t3 <= table.currentSnapshot().timestampMillis()) {\n+      t3 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_D) // data_bucket=3\n+        .commit();\n+\n+    long t4 = System.currentTimeMillis();\n+    while (t4 <= table.currentSnapshot().timestampMillis()) {\n+      t4 = System.currentTimeMillis();\n+    }\n+\n+    // Retain last 2 snapshots and expire older than t3\n+    Actions.forTable(table).expireSnapshots()\n+        .expireOlderThan(secondSnapshot.timestampMillis())\n+        .retainLast(2)\n+        .execute();\n+\n+    Assert.assertEquals(\"Should have three snapshots.\",\n+        3, Lists.newArrayList(table.snapshots()).size());\n+    Assert.assertNotNull(\"Second snapshot should present.\",\n+        table.snapshot(secondSnapshot.snapshotId()));\n+  }\n+\n+  @Test\n+  public void testExpireOlderThanMultipleCalls() {\n+    long t0 = System.currentTimeMillis();\n+    table.newAppend()\n+        .appendFile(FILE_A) // data_bucket=0\n+        .commit();\n+    long t1 = System.currentTimeMillis();\n+    while (t1 <= table.currentSnapshot().timestampMillis()) {\n+      t1 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_B) // data_bucket=1\n+        .commit();\n+\n+    Snapshot secondSnapshot = table.currentSnapshot();\n+    long t2 = System.currentTimeMillis();\n+    while (t2 <= table.currentSnapshot().timestampMillis()) {\n+      t2 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_C) // data_bucket=2\n+        .commit();\n+\n+    Snapshot thirdSnapshot = table.currentSnapshot();\n+    long t3 = System.currentTimeMillis();\n+    while (t3 <= table.currentSnapshot().timestampMillis()) {\n+      t3 = System.currentTimeMillis();\n+    }\n+\n+    // Retain last 2 snapshots and expire older than t3\n+    Actions.forTable(table).expireSnapshots()\n+        .expireOlderThan(secondSnapshot.timestampMillis())\n+        .expireOlderThan(thirdSnapshot.timestampMillis())\n+        .execute();\n+\n+    Assert.assertEquals(\"Should have one snapshots.\",\n+        1, Lists.newArrayList(table.snapshots()).size());\n+    Assert.assertNull(\"Second snapshot should not present.\",\n+        table.snapshot(secondSnapshot.snapshotId()));\n+  }\n+\n+  @Test\n+  public void testRetainLastMultipleCalls() {\n+    long t0 = System.currentTimeMillis();\n+    table.newAppend()\n+        .appendFile(FILE_A) // data_bucket=0\n+        .commit();\n+    long t1 = System.currentTimeMillis();\n+    while (t1 <= table.currentSnapshot().timestampMillis()) {\n+      t1 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_B) // data_bucket=1\n+        .commit();\n+\n+    Snapshot secondSnapshot = table.currentSnapshot();\n+    long t2 = System.currentTimeMillis();\n+    while (t2 <= table.currentSnapshot().timestampMillis()) {\n+      t2 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_C) // data_bucket=2\n+        .commit();\n+\n+    long t3 = System.currentTimeMillis();\n+    while (t3 <= table.currentSnapshot().timestampMillis()) {\n+      t3 = System.currentTimeMillis();\n+    }\n+\n+    // Retain last 2 snapshots and expire older than t3\n+    Actions.forTable(table).expireSnapshots()\n+        .expireOlderThan(t3)\n+        .retainLast(2)\n+        .retainLast(1)\n+        .execute();\n+\n+    Assert.assertEquals(\"Should have one snapshots.\",\n+        1, Lists.newArrayList(table.snapshots()).size());\n+    Assert.assertNull(\"Second snapshot should not present.\",\n+        table.snapshot(secondSnapshot.snapshotId()));\n+  }\n+\n+  @Test\n+  public void testRetainZeroSnapshots() {\n+    AssertHelpers.assertThrows(\"Should fail retain 0 snapshots \" +\n+            \"because number of snapshots to retain cannot be zero\",\n+        IllegalArgumentException.class,\n+        \"Number of snapshots to retain must be at least 1, cannot be: 0\",\n+        () -> Actions.forTable(table).expireSnapshots().retainLast(0).execute());\n+  }\n+\n+  @Test\n+  public void testScanExpiredManifestInValidSnapshotAppend() {\n+    table.newAppend()\n+        .appendFile(FILE_A)\n+        .appendFile(FILE_B)\n+        .commit();\n+\n+    table.newOverwrite()\n+        .addFile(FILE_C)\n+        .deleteFile(FILE_A)\n+        .commit();\n+\n+    table.newAppend()\n+        .appendFile(FILE_D)\n+        .commit();\n+\n+    long t3 = System.currentTimeMillis();\n+    while (t3 <= table.currentSnapshot().timestampMillis()) {\n+      t3 = System.currentTimeMillis();\n+    }\n+\n+    Set<String> deletedFiles = Sets.newHashSet();\n+\n+    Actions.forTable(table).expireSnapshots()\n+        .expireOlderThan(t3)\n+        .deleteWith(deletedFiles::add)\n+        .execute();\n+\n+    Assert.assertTrue(\"FILE_A should be deleted\", deletedFiles.contains(FILE_A.path().toString()));\n+\n+  }\n+\n+  @Test\n+  public void testScanExpiredManifestInValidSnapshotFastAppend() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9cc4e831679d0aab1e4409210f3a7c57094c440c"}, "originalPosition": 558}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzNDE2OTA4", "url": "https://github.com/apache/iceberg/pull/1264#pullrequestreview-463416908", "createdAt": "2020-08-07T15:45:54Z", "commit": {"oid": "9cc4e831679d0aab1e4409210f3a7c57094c440c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNTo0NTo1NFrOG9e1GA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNTo0NTo1NFrOG9e1GA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzEyMTQzMg==", "bodyText": "Ported Test - Only change is using ExpireSnapshotsAction", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r467121432", "createdAt": "2020-08-07T15:45:54Z", "author": {"login": "RussellSpitzer"}, "path": "spark/src/test/java/org/apache/iceberg/actions/TestExpireSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,780 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.BaseTable;\n+import org.apache.iceberg.DataFile;\n+import org.apache.iceberg.DataFiles;\n+import org.apache.iceberg.PartitionSpec;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.Snapshot;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableProperties;\n+import org.apache.iceberg.hadoop.HadoopTables;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableSet;\n+import org.apache.iceberg.relocated.com.google.common.collect.Iterables;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.relocated.com.google.common.collect.Sets;\n+import org.apache.iceberg.spark.SparkTestBase;\n+import org.apache.iceberg.spark.source.ThreeColumnRecord;\n+import org.apache.iceberg.types.Types;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import static org.apache.iceberg.types.Types.NestedField.optional;\n+\n+public abstract class TestExpireSnapshotsAction extends SparkTestBase {\n+\n+  private static final HadoopTables TABLES = new HadoopTables(new Configuration());\n+  private static final Schema SCHEMA = new Schema(\n+      optional(1, \"c1\", Types.IntegerType.get()),\n+      optional(2, \"c2\", Types.StringType.get()),\n+      optional(3, \"c3\", Types.StringType.get())\n+  );\n+\n+  private static final PartitionSpec SPEC = PartitionSpec.builderFor(SCHEMA).identity(\"c1\").build();\n+\n+  private static final List<ThreeColumnRecord> RECORDS = Lists.newArrayList(new ThreeColumnRecord(1, \"AAAA\", \"AAAA\"));\n+\n+  static final DataFile FILE_A = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-a.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=0\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+  static final DataFile FILE_B = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-b.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=1\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+  static final DataFile FILE_C = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-c.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=2\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+  static final DataFile FILE_D = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-d.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=3\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+\n+  @Rule\n+  public TemporaryFolder temp = new TemporaryFolder();\n+\n+  private File tableDir;\n+  private String tableLocation;\n+  private Table table;\n+\n+  @Before\n+  public void setupTableLocation() throws Exception {\n+    this.tableDir = temp.newFolder();\n+    this.tableLocation = tableDir.toURI().toString();\n+    this.table = TABLES.create(SCHEMA, SPEC, Maps.newHashMap(), tableLocation);\n+  }\n+\n+  private Dataset<Row> buildDF(List<ThreeColumnRecord> records) {\n+    return spark.createDataFrame(records, ThreeColumnRecord.class).coalesce(1);\n+  }\n+\n+  private void writeDF(Dataset<Row> df, String mode) {\n+    df.select(\"c1\", \"c2\", \"c3\")\n+        .write()\n+        .format(\"iceberg\")\n+        .mode(mode)\n+        .save(tableLocation);\n+  }\n+\n+  private void checkExpirationResults(Long expectedDatafiles, Long expectedManifestsDeleted,\n+      Long expectedManifestListsDeleted, ExpireSnapshotsActionResult results) {\n+\n+    Assert.assertEquals(\"Incorrect number of manifest files deleted\",\n+        expectedManifestsDeleted, results.getManifestFilesDeleted());\n+    Assert.assertEquals(\"Incorrect number of datafiles deleted\",\n+        expectedDatafiles, results.getDataFilesDeleted());\n+    Assert.assertEquals(\"Incorrect number of manifest lists deleted\",\n+        expectedManifestListsDeleted, results.getManifestListsDeleted());\n+  }\n+\n+  @Test\n+  public void testFilesCleaned() throws Exception {\n+    Dataset<Row> df = buildDF(RECORDS);\n+\n+    writeDF(df, \"append\");\n+\n+    List<Path> expiredDataFiles = Files\n+        .list(tableDir.toPath().resolve(\"data\").resolve(\"c1=1\"))\n+        .collect(Collectors.toList());\n+\n+    Assert.assertEquals(\"There should be a data file to delete but there was none.\",\n+        2, expiredDataFiles.size());\n+\n+    writeDF(df, \"overwrite\");\n+    writeDF(df, \"append\");\n+\n+    long end = System.currentTimeMillis();\n+    while (end <= table.currentSnapshot().timestampMillis()) {\n+      end = System.currentTimeMillis();\n+    }\n+\n+    ExpireSnapshotsActionResult results =\n+        Actions.forTable(table).expireSnapshots().expireOlderThan(end).execute();\n+\n+    table.refresh();\n+\n+    Assert.assertEquals(\"Table does not have 1 snapshot after expiration\", 1, Iterables.size(table.snapshots()));\n+\n+    for (Path p : expiredDataFiles) {\n+      Assert.assertFalse(String.format(\"File %s still exists but should have been deleted\", p),\n+          Files.exists(p));\n+    }\n+\n+    checkExpirationResults(1L, 2L, 2L, results);\n+  }\n+\n+  @Test\n+  public void dataFilesCleanupWithParallelTasks() throws IOException {\n+\n+    table.newFastAppend()\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    table.newFastAppend()\n+        .appendFile(FILE_B)\n+        .commit();\n+\n+    table.newRewrite()\n+        .rewriteFiles(ImmutableSet.of(FILE_B), ImmutableSet.of(FILE_D))\n+        .commit();\n+    long thirdSnapshotId = table.currentSnapshot().snapshotId();\n+\n+    table.newRewrite()\n+        .rewriteFiles(ImmutableSet.of(FILE_A), ImmutableSet.of(FILE_C))\n+        .commit();\n+    long fourthSnapshotId = table.currentSnapshot().snapshotId();\n+\n+    long t4 = System.currentTimeMillis();\n+    while (t4 <= table.currentSnapshot().timestampMillis()) {\n+      t4 = System.currentTimeMillis();\n+    }\n+\n+    Set<String> deletedFiles = Sets.newHashSet();\n+    Set<String> deleteThreads = ConcurrentHashMap.newKeySet();\n+    AtomicInteger deleteThreadsIndex = new AtomicInteger(0);\n+\n+    Actions.forTable(table).expireSnapshots()\n+        .executeDeleteWith(Executors.newFixedThreadPool(4, runnable -> {\n+          Thread thread = new Thread(runnable);\n+          thread.setName(\"remove-snapshot-\" + deleteThreadsIndex.getAndIncrement());\n+          thread.setDaemon(true); // daemon threads will be terminated abruptly when the JVM exits\n+          return thread;\n+        }))\n+        .expireOlderThan(t4)\n+        .deleteWith(s -> {\n+          deleteThreads.add(Thread.currentThread().getName());\n+          deletedFiles.add(s);\n+        })\n+        .execute();\n+\n+    // Verifies that the delete methods ran in the threads created by the provided ExecutorService ThreadFactory\n+    Assert.assertEquals(deleteThreads,\n+        Sets.newHashSet(\"remove-snapshot-0\", \"remove-snapshot-1\", \"remove-snapshot-2\", \"remove-snapshot-3\"));\n+\n+    Assert.assertTrue(\"FILE_A should be deleted\", deletedFiles.contains(FILE_A.path().toString()));\n+    Assert.assertTrue(\"FILE_B should be deleted\", deletedFiles.contains(FILE_B.path().toString()));\n+  }\n+\n+  @Test\n+  public void testNoFilesDeletedWhenNoSnapshotsExpired() throws Exception {\n+    Dataset<Row> df = buildDF(RECORDS);\n+\n+    writeDF(df, \"append\");\n+\n+    ExpireSnapshotsActionResult results =\n+        Actions.forTable(table).expireSnapshots().execute();\n+\n+    checkExpirationResults(0L, 0L, 0L, results);\n+  }\n+\n+  @Test\n+  public void testCleanupRepeatedOverwrites() throws Exception {\n+    Dataset<Row> df = buildDF(RECORDS);\n+\n+    writeDF(df, \"append\");\n+\n+    for (int i = 0; i < 10; i++) {\n+      writeDF(df, \"overwrite\");\n+    }\n+\n+    long end = System.currentTimeMillis();\n+    while (end <= table.currentSnapshot().timestampMillis()) {\n+      end = System.currentTimeMillis();\n+    }\n+\n+    ExpireSnapshotsActionResult results =\n+        Actions.forTable(table).expireSnapshots().expireOlderThan(end).execute();\n+\n+    checkExpirationResults(10L, 19L, 10L, results);\n+  }\n+\n+  @Test\n+  public void testRetainLastWithExpireOlderThan() {\n+    long t0 = System.currentTimeMillis();\n+    table.newAppend()\n+        .appendFile(FILE_A) // data_bucket=0\n+        .commit();\n+    long firstSnapshotId = table.currentSnapshot().snapshotId();\n+    long t1 = System.currentTimeMillis();\n+    while (t1 <= table.currentSnapshot().timestampMillis()) {\n+      t1 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_B) // data_bucket=1\n+        .commit();\n+\n+    long t2 = System.currentTimeMillis();\n+    while (t2 <= table.currentSnapshot().timestampMillis()) {\n+      t2 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_C) // data_bucket=2\n+        .commit();\n+\n+    long t3 = System.currentTimeMillis();\n+    while (t3 <= table.currentSnapshot().timestampMillis()) {\n+      t3 = System.currentTimeMillis();\n+    }\n+\n+    // Retain last 2 snapshots\n+    Actions.forTable(table).expireSnapshots()\n+        .expireOlderThan(t3)\n+        .retainLast(2)\n+        .execute();\n+\n+    Assert.assertEquals(\"Should have two snapshots.\",\n+        2, Lists.newArrayList(table.snapshots()).size());\n+    Assert.assertEquals(\"First snapshot should not present.\",\n+        null, table.snapshot(firstSnapshotId));\n+  }\n+\n+  @Test\n+  public void testRetainLastWithExpireById() {\n+    long t0 = System.currentTimeMillis();\n+    table.newAppend()\n+        .appendFile(FILE_A) // data_bucket=0\n+        .commit();\n+    long firstSnapshotId = table.currentSnapshot().snapshotId();\n+    long t1 = System.currentTimeMillis();\n+    while (t1 <= table.currentSnapshot().timestampMillis()) {\n+      t1 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_B) // data_bucket=1\n+        .commit();\n+\n+    long t2 = System.currentTimeMillis();\n+    while (t2 <= table.currentSnapshot().timestampMillis()) {\n+      t2 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_C) // data_bucket=2\n+        .commit();\n+\n+    long t3 = System.currentTimeMillis();\n+    while (t3 <= table.currentSnapshot().timestampMillis()) {\n+      t3 = System.currentTimeMillis();\n+    }\n+\n+    // Retain last 3 snapshots, but explicitly remove the first snapshot\n+    Actions.forTable(table).expireSnapshots()\n+        .expireSnapshotId(firstSnapshotId)\n+        .retainLast(3)\n+        .execute();\n+\n+    Assert.assertEquals(\"Should have two snapshots.\",\n+        2, Lists.newArrayList(table.snapshots()).size());\n+    Assert.assertEquals(\"First snapshot should not present.\",\n+        null, table.snapshot(firstSnapshotId));\n+  }\n+\n+  @Test\n+  public void testRetainLastWithTooFewSnapshots() {\n+    long t0 = System.currentTimeMillis();\n+    table.newAppend()\n+        .appendFile(FILE_A) // data_bucket=0\n+        .appendFile(FILE_B) // data_bucket=1\n+        .commit();\n+    long firstSnapshotId = table.currentSnapshot().snapshotId();\n+\n+    long t1 = System.currentTimeMillis();\n+    while (t1 <= table.currentSnapshot().timestampMillis()) {\n+      t1 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_C) // data_bucket=2\n+        .commit();\n+\n+    long t2 = System.currentTimeMillis();\n+    while (t2 <= table.currentSnapshot().timestampMillis()) {\n+      t2 = System.currentTimeMillis();\n+    }\n+\n+    // Retain last 3 snapshots\n+    Actions.forTable(table).expireSnapshots()\n+        .expireOlderThan(t2)\n+        .retainLast(3)\n+        .execute();\n+\n+    Assert.assertEquals(\"Should have two snapshots\",\n+        2, Lists.newArrayList(table.snapshots()).size());\n+    Assert.assertEquals(\"First snapshot should still present\",\n+        firstSnapshotId, table.snapshot(firstSnapshotId).snapshotId());\n+  }\n+\n+  @Test\n+  public void testRetainLastKeepsExpiringSnapshot() {\n+    long t0 = System.currentTimeMillis();\n+    table.newAppend()\n+        .appendFile(FILE_A) // data_bucket=0\n+        .commit();\n+    long t1 = System.currentTimeMillis();\n+    while (t1 <= table.currentSnapshot().timestampMillis()) {\n+      t1 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_B) // data_bucket=1\n+        .commit();\n+\n+    Snapshot secondSnapshot = table.currentSnapshot();\n+    long t2 = System.currentTimeMillis();\n+    while (t2 <= table.currentSnapshot().timestampMillis()) {\n+      t2 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_C) // data_bucket=2\n+        .commit();\n+\n+    long t3 = System.currentTimeMillis();\n+    while (t3 <= table.currentSnapshot().timestampMillis()) {\n+      t3 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_D) // data_bucket=3\n+        .commit();\n+\n+    long t4 = System.currentTimeMillis();\n+    while (t4 <= table.currentSnapshot().timestampMillis()) {\n+      t4 = System.currentTimeMillis();\n+    }\n+\n+    // Retain last 2 snapshots and expire older than t3\n+    Actions.forTable(table).expireSnapshots()\n+        .expireOlderThan(secondSnapshot.timestampMillis())\n+        .retainLast(2)\n+        .execute();\n+\n+    Assert.assertEquals(\"Should have three snapshots.\",\n+        3, Lists.newArrayList(table.snapshots()).size());\n+    Assert.assertNotNull(\"Second snapshot should present.\",\n+        table.snapshot(secondSnapshot.snapshotId()));\n+  }\n+\n+  @Test\n+  public void testExpireOlderThanMultipleCalls() {\n+    long t0 = System.currentTimeMillis();\n+    table.newAppend()\n+        .appendFile(FILE_A) // data_bucket=0\n+        .commit();\n+    long t1 = System.currentTimeMillis();\n+    while (t1 <= table.currentSnapshot().timestampMillis()) {\n+      t1 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_B) // data_bucket=1\n+        .commit();\n+\n+    Snapshot secondSnapshot = table.currentSnapshot();\n+    long t2 = System.currentTimeMillis();\n+    while (t2 <= table.currentSnapshot().timestampMillis()) {\n+      t2 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_C) // data_bucket=2\n+        .commit();\n+\n+    Snapshot thirdSnapshot = table.currentSnapshot();\n+    long t3 = System.currentTimeMillis();\n+    while (t3 <= table.currentSnapshot().timestampMillis()) {\n+      t3 = System.currentTimeMillis();\n+    }\n+\n+    // Retain last 2 snapshots and expire older than t3\n+    Actions.forTable(table).expireSnapshots()\n+        .expireOlderThan(secondSnapshot.timestampMillis())\n+        .expireOlderThan(thirdSnapshot.timestampMillis())\n+        .execute();\n+\n+    Assert.assertEquals(\"Should have one snapshots.\",\n+        1, Lists.newArrayList(table.snapshots()).size());\n+    Assert.assertNull(\"Second snapshot should not present.\",\n+        table.snapshot(secondSnapshot.snapshotId()));\n+  }\n+\n+  @Test\n+  public void testRetainLastMultipleCalls() {\n+    long t0 = System.currentTimeMillis();\n+    table.newAppend()\n+        .appendFile(FILE_A) // data_bucket=0\n+        .commit();\n+    long t1 = System.currentTimeMillis();\n+    while (t1 <= table.currentSnapshot().timestampMillis()) {\n+      t1 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_B) // data_bucket=1\n+        .commit();\n+\n+    Snapshot secondSnapshot = table.currentSnapshot();\n+    long t2 = System.currentTimeMillis();\n+    while (t2 <= table.currentSnapshot().timestampMillis()) {\n+      t2 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_C) // data_bucket=2\n+        .commit();\n+\n+    long t3 = System.currentTimeMillis();\n+    while (t3 <= table.currentSnapshot().timestampMillis()) {\n+      t3 = System.currentTimeMillis();\n+    }\n+\n+    // Retain last 2 snapshots and expire older than t3\n+    Actions.forTable(table).expireSnapshots()\n+        .expireOlderThan(t3)\n+        .retainLast(2)\n+        .retainLast(1)\n+        .execute();\n+\n+    Assert.assertEquals(\"Should have one snapshots.\",\n+        1, Lists.newArrayList(table.snapshots()).size());\n+    Assert.assertNull(\"Second snapshot should not present.\",\n+        table.snapshot(secondSnapshot.snapshotId()));\n+  }\n+\n+  @Test\n+  public void testRetainZeroSnapshots() {\n+    AssertHelpers.assertThrows(\"Should fail retain 0 snapshots \" +\n+            \"because number of snapshots to retain cannot be zero\",\n+        IllegalArgumentException.class,\n+        \"Number of snapshots to retain must be at least 1, cannot be: 0\",\n+        () -> Actions.forTable(table).expireSnapshots().retainLast(0).execute());\n+  }\n+\n+  @Test\n+  public void testScanExpiredManifestInValidSnapshotAppend() {\n+    table.newAppend()\n+        .appendFile(FILE_A)\n+        .appendFile(FILE_B)\n+        .commit();\n+\n+    table.newOverwrite()\n+        .addFile(FILE_C)\n+        .deleteFile(FILE_A)\n+        .commit();\n+\n+    table.newAppend()\n+        .appendFile(FILE_D)\n+        .commit();\n+\n+    long t3 = System.currentTimeMillis();\n+    while (t3 <= table.currentSnapshot().timestampMillis()) {\n+      t3 = System.currentTimeMillis();\n+    }\n+\n+    Set<String> deletedFiles = Sets.newHashSet();\n+\n+    Actions.forTable(table).expireSnapshots()\n+        .expireOlderThan(t3)\n+        .deleteWith(deletedFiles::add)\n+        .execute();\n+\n+    Assert.assertTrue(\"FILE_A should be deleted\", deletedFiles.contains(FILE_A.path().toString()));\n+\n+  }\n+\n+  @Test\n+  public void testScanExpiredManifestInValidSnapshotFastAppend() {\n+    table.updateProperties()\n+        .set(TableProperties.MANIFEST_MERGE_ENABLED, \"true\")\n+        .set(TableProperties.MANIFEST_MIN_MERGE_COUNT, \"1\")\n+        .commit();\n+\n+    table.newAppend()\n+        .appendFile(FILE_A)\n+        .appendFile(FILE_B)\n+        .commit();\n+\n+    table.newOverwrite()\n+        .addFile(FILE_C)\n+        .deleteFile(FILE_A)\n+        .commit();\n+\n+    table.newFastAppend()\n+        .appendFile(FILE_D)\n+        .commit();\n+\n+    long t3 = System.currentTimeMillis();\n+    while (t3 <= table.currentSnapshot().timestampMillis()) {\n+      t3 = System.currentTimeMillis();\n+    }\n+\n+    Set<String> deletedFiles = Sets.newHashSet();\n+\n+    Actions.forTable(table).expireSnapshots()\n+        .expireOlderThan(t3)\n+        .deleteWith(deletedFiles::add)\n+        .execute();\n+\n+    Assert.assertTrue(\"FILE_A should be deleted\", deletedFiles.contains(FILE_A.path().toString()));\n+  }\n+\n+  /**\n+   * Test on table below, and expiring the staged commit `B` using `expireOlderThan` API.\n+   * Table: A - C\n+   *          ` B (staged)\n+   */\n+  @Test\n+  public void testWithExpiringDanglingStageCommit() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9cc4e831679d0aab1e4409210f3a7c57094c440c"}, "originalPosition": 599}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzNDE2OTk1", "url": "https://github.com/apache/iceberg/pull/1264#pullrequestreview-463416995", "createdAt": "2020-08-07T15:46:01Z", "commit": {"oid": "9cc4e831679d0aab1e4409210f3a7c57094c440c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNTo0NjowMlrOG9e1VA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNTo0NjowMlrOG9e1VA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzEyMTQ5Mg==", "bodyText": "Ported Test - Only change is using ExpireSnapshotsAction", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r467121492", "createdAt": "2020-08-07T15:46:02Z", "author": {"login": "RussellSpitzer"}, "path": "spark/src/test/java/org/apache/iceberg/actions/TestExpireSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,780 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.BaseTable;\n+import org.apache.iceberg.DataFile;\n+import org.apache.iceberg.DataFiles;\n+import org.apache.iceberg.PartitionSpec;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.Snapshot;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableProperties;\n+import org.apache.iceberg.hadoop.HadoopTables;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableSet;\n+import org.apache.iceberg.relocated.com.google.common.collect.Iterables;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.relocated.com.google.common.collect.Sets;\n+import org.apache.iceberg.spark.SparkTestBase;\n+import org.apache.iceberg.spark.source.ThreeColumnRecord;\n+import org.apache.iceberg.types.Types;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import static org.apache.iceberg.types.Types.NestedField.optional;\n+\n+public abstract class TestExpireSnapshotsAction extends SparkTestBase {\n+\n+  private static final HadoopTables TABLES = new HadoopTables(new Configuration());\n+  private static final Schema SCHEMA = new Schema(\n+      optional(1, \"c1\", Types.IntegerType.get()),\n+      optional(2, \"c2\", Types.StringType.get()),\n+      optional(3, \"c3\", Types.StringType.get())\n+  );\n+\n+  private static final PartitionSpec SPEC = PartitionSpec.builderFor(SCHEMA).identity(\"c1\").build();\n+\n+  private static final List<ThreeColumnRecord> RECORDS = Lists.newArrayList(new ThreeColumnRecord(1, \"AAAA\", \"AAAA\"));\n+\n+  static final DataFile FILE_A = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-a.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=0\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+  static final DataFile FILE_B = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-b.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=1\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+  static final DataFile FILE_C = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-c.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=2\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+  static final DataFile FILE_D = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-d.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=3\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+\n+  @Rule\n+  public TemporaryFolder temp = new TemporaryFolder();\n+\n+  private File tableDir;\n+  private String tableLocation;\n+  private Table table;\n+\n+  @Before\n+  public void setupTableLocation() throws Exception {\n+    this.tableDir = temp.newFolder();\n+    this.tableLocation = tableDir.toURI().toString();\n+    this.table = TABLES.create(SCHEMA, SPEC, Maps.newHashMap(), tableLocation);\n+  }\n+\n+  private Dataset<Row> buildDF(List<ThreeColumnRecord> records) {\n+    return spark.createDataFrame(records, ThreeColumnRecord.class).coalesce(1);\n+  }\n+\n+  private void writeDF(Dataset<Row> df, String mode) {\n+    df.select(\"c1\", \"c2\", \"c3\")\n+        .write()\n+        .format(\"iceberg\")\n+        .mode(mode)\n+        .save(tableLocation);\n+  }\n+\n+  private void checkExpirationResults(Long expectedDatafiles, Long expectedManifestsDeleted,\n+      Long expectedManifestListsDeleted, ExpireSnapshotsActionResult results) {\n+\n+    Assert.assertEquals(\"Incorrect number of manifest files deleted\",\n+        expectedManifestsDeleted, results.getManifestFilesDeleted());\n+    Assert.assertEquals(\"Incorrect number of datafiles deleted\",\n+        expectedDatafiles, results.getDataFilesDeleted());\n+    Assert.assertEquals(\"Incorrect number of manifest lists deleted\",\n+        expectedManifestListsDeleted, results.getManifestListsDeleted());\n+  }\n+\n+  @Test\n+  public void testFilesCleaned() throws Exception {\n+    Dataset<Row> df = buildDF(RECORDS);\n+\n+    writeDF(df, \"append\");\n+\n+    List<Path> expiredDataFiles = Files\n+        .list(tableDir.toPath().resolve(\"data\").resolve(\"c1=1\"))\n+        .collect(Collectors.toList());\n+\n+    Assert.assertEquals(\"There should be a data file to delete but there was none.\",\n+        2, expiredDataFiles.size());\n+\n+    writeDF(df, \"overwrite\");\n+    writeDF(df, \"append\");\n+\n+    long end = System.currentTimeMillis();\n+    while (end <= table.currentSnapshot().timestampMillis()) {\n+      end = System.currentTimeMillis();\n+    }\n+\n+    ExpireSnapshotsActionResult results =\n+        Actions.forTable(table).expireSnapshots().expireOlderThan(end).execute();\n+\n+    table.refresh();\n+\n+    Assert.assertEquals(\"Table does not have 1 snapshot after expiration\", 1, Iterables.size(table.snapshots()));\n+\n+    for (Path p : expiredDataFiles) {\n+      Assert.assertFalse(String.format(\"File %s still exists but should have been deleted\", p),\n+          Files.exists(p));\n+    }\n+\n+    checkExpirationResults(1L, 2L, 2L, results);\n+  }\n+\n+  @Test\n+  public void dataFilesCleanupWithParallelTasks() throws IOException {\n+\n+    table.newFastAppend()\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    table.newFastAppend()\n+        .appendFile(FILE_B)\n+        .commit();\n+\n+    table.newRewrite()\n+        .rewriteFiles(ImmutableSet.of(FILE_B), ImmutableSet.of(FILE_D))\n+        .commit();\n+    long thirdSnapshotId = table.currentSnapshot().snapshotId();\n+\n+    table.newRewrite()\n+        .rewriteFiles(ImmutableSet.of(FILE_A), ImmutableSet.of(FILE_C))\n+        .commit();\n+    long fourthSnapshotId = table.currentSnapshot().snapshotId();\n+\n+    long t4 = System.currentTimeMillis();\n+    while (t4 <= table.currentSnapshot().timestampMillis()) {\n+      t4 = System.currentTimeMillis();\n+    }\n+\n+    Set<String> deletedFiles = Sets.newHashSet();\n+    Set<String> deleteThreads = ConcurrentHashMap.newKeySet();\n+    AtomicInteger deleteThreadsIndex = new AtomicInteger(0);\n+\n+    Actions.forTable(table).expireSnapshots()\n+        .executeDeleteWith(Executors.newFixedThreadPool(4, runnable -> {\n+          Thread thread = new Thread(runnable);\n+          thread.setName(\"remove-snapshot-\" + deleteThreadsIndex.getAndIncrement());\n+          thread.setDaemon(true); // daemon threads will be terminated abruptly when the JVM exits\n+          return thread;\n+        }))\n+        .expireOlderThan(t4)\n+        .deleteWith(s -> {\n+          deleteThreads.add(Thread.currentThread().getName());\n+          deletedFiles.add(s);\n+        })\n+        .execute();\n+\n+    // Verifies that the delete methods ran in the threads created by the provided ExecutorService ThreadFactory\n+    Assert.assertEquals(deleteThreads,\n+        Sets.newHashSet(\"remove-snapshot-0\", \"remove-snapshot-1\", \"remove-snapshot-2\", \"remove-snapshot-3\"));\n+\n+    Assert.assertTrue(\"FILE_A should be deleted\", deletedFiles.contains(FILE_A.path().toString()));\n+    Assert.assertTrue(\"FILE_B should be deleted\", deletedFiles.contains(FILE_B.path().toString()));\n+  }\n+\n+  @Test\n+  public void testNoFilesDeletedWhenNoSnapshotsExpired() throws Exception {\n+    Dataset<Row> df = buildDF(RECORDS);\n+\n+    writeDF(df, \"append\");\n+\n+    ExpireSnapshotsActionResult results =\n+        Actions.forTable(table).expireSnapshots().execute();\n+\n+    checkExpirationResults(0L, 0L, 0L, results);\n+  }\n+\n+  @Test\n+  public void testCleanupRepeatedOverwrites() throws Exception {\n+    Dataset<Row> df = buildDF(RECORDS);\n+\n+    writeDF(df, \"append\");\n+\n+    for (int i = 0; i < 10; i++) {\n+      writeDF(df, \"overwrite\");\n+    }\n+\n+    long end = System.currentTimeMillis();\n+    while (end <= table.currentSnapshot().timestampMillis()) {\n+      end = System.currentTimeMillis();\n+    }\n+\n+    ExpireSnapshotsActionResult results =\n+        Actions.forTable(table).expireSnapshots().expireOlderThan(end).execute();\n+\n+    checkExpirationResults(10L, 19L, 10L, results);\n+  }\n+\n+  @Test\n+  public void testRetainLastWithExpireOlderThan() {\n+    long t0 = System.currentTimeMillis();\n+    table.newAppend()\n+        .appendFile(FILE_A) // data_bucket=0\n+        .commit();\n+    long firstSnapshotId = table.currentSnapshot().snapshotId();\n+    long t1 = System.currentTimeMillis();\n+    while (t1 <= table.currentSnapshot().timestampMillis()) {\n+      t1 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_B) // data_bucket=1\n+        .commit();\n+\n+    long t2 = System.currentTimeMillis();\n+    while (t2 <= table.currentSnapshot().timestampMillis()) {\n+      t2 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_C) // data_bucket=2\n+        .commit();\n+\n+    long t3 = System.currentTimeMillis();\n+    while (t3 <= table.currentSnapshot().timestampMillis()) {\n+      t3 = System.currentTimeMillis();\n+    }\n+\n+    // Retain last 2 snapshots\n+    Actions.forTable(table).expireSnapshots()\n+        .expireOlderThan(t3)\n+        .retainLast(2)\n+        .execute();\n+\n+    Assert.assertEquals(\"Should have two snapshots.\",\n+        2, Lists.newArrayList(table.snapshots()).size());\n+    Assert.assertEquals(\"First snapshot should not present.\",\n+        null, table.snapshot(firstSnapshotId));\n+  }\n+\n+  @Test\n+  public void testRetainLastWithExpireById() {\n+    long t0 = System.currentTimeMillis();\n+    table.newAppend()\n+        .appendFile(FILE_A) // data_bucket=0\n+        .commit();\n+    long firstSnapshotId = table.currentSnapshot().snapshotId();\n+    long t1 = System.currentTimeMillis();\n+    while (t1 <= table.currentSnapshot().timestampMillis()) {\n+      t1 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_B) // data_bucket=1\n+        .commit();\n+\n+    long t2 = System.currentTimeMillis();\n+    while (t2 <= table.currentSnapshot().timestampMillis()) {\n+      t2 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_C) // data_bucket=2\n+        .commit();\n+\n+    long t3 = System.currentTimeMillis();\n+    while (t3 <= table.currentSnapshot().timestampMillis()) {\n+      t3 = System.currentTimeMillis();\n+    }\n+\n+    // Retain last 3 snapshots, but explicitly remove the first snapshot\n+    Actions.forTable(table).expireSnapshots()\n+        .expireSnapshotId(firstSnapshotId)\n+        .retainLast(3)\n+        .execute();\n+\n+    Assert.assertEquals(\"Should have two snapshots.\",\n+        2, Lists.newArrayList(table.snapshots()).size());\n+    Assert.assertEquals(\"First snapshot should not present.\",\n+        null, table.snapshot(firstSnapshotId));\n+  }\n+\n+  @Test\n+  public void testRetainLastWithTooFewSnapshots() {\n+    long t0 = System.currentTimeMillis();\n+    table.newAppend()\n+        .appendFile(FILE_A) // data_bucket=0\n+        .appendFile(FILE_B) // data_bucket=1\n+        .commit();\n+    long firstSnapshotId = table.currentSnapshot().snapshotId();\n+\n+    long t1 = System.currentTimeMillis();\n+    while (t1 <= table.currentSnapshot().timestampMillis()) {\n+      t1 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_C) // data_bucket=2\n+        .commit();\n+\n+    long t2 = System.currentTimeMillis();\n+    while (t2 <= table.currentSnapshot().timestampMillis()) {\n+      t2 = System.currentTimeMillis();\n+    }\n+\n+    // Retain last 3 snapshots\n+    Actions.forTable(table).expireSnapshots()\n+        .expireOlderThan(t2)\n+        .retainLast(3)\n+        .execute();\n+\n+    Assert.assertEquals(\"Should have two snapshots\",\n+        2, Lists.newArrayList(table.snapshots()).size());\n+    Assert.assertEquals(\"First snapshot should still present\",\n+        firstSnapshotId, table.snapshot(firstSnapshotId).snapshotId());\n+  }\n+\n+  @Test\n+  public void testRetainLastKeepsExpiringSnapshot() {\n+    long t0 = System.currentTimeMillis();\n+    table.newAppend()\n+        .appendFile(FILE_A) // data_bucket=0\n+        .commit();\n+    long t1 = System.currentTimeMillis();\n+    while (t1 <= table.currentSnapshot().timestampMillis()) {\n+      t1 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_B) // data_bucket=1\n+        .commit();\n+\n+    Snapshot secondSnapshot = table.currentSnapshot();\n+    long t2 = System.currentTimeMillis();\n+    while (t2 <= table.currentSnapshot().timestampMillis()) {\n+      t2 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_C) // data_bucket=2\n+        .commit();\n+\n+    long t3 = System.currentTimeMillis();\n+    while (t3 <= table.currentSnapshot().timestampMillis()) {\n+      t3 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_D) // data_bucket=3\n+        .commit();\n+\n+    long t4 = System.currentTimeMillis();\n+    while (t4 <= table.currentSnapshot().timestampMillis()) {\n+      t4 = System.currentTimeMillis();\n+    }\n+\n+    // Retain last 2 snapshots and expire older than t3\n+    Actions.forTable(table).expireSnapshots()\n+        .expireOlderThan(secondSnapshot.timestampMillis())\n+        .retainLast(2)\n+        .execute();\n+\n+    Assert.assertEquals(\"Should have three snapshots.\",\n+        3, Lists.newArrayList(table.snapshots()).size());\n+    Assert.assertNotNull(\"Second snapshot should present.\",\n+        table.snapshot(secondSnapshot.snapshotId()));\n+  }\n+\n+  @Test\n+  public void testExpireOlderThanMultipleCalls() {\n+    long t0 = System.currentTimeMillis();\n+    table.newAppend()\n+        .appendFile(FILE_A) // data_bucket=0\n+        .commit();\n+    long t1 = System.currentTimeMillis();\n+    while (t1 <= table.currentSnapshot().timestampMillis()) {\n+      t1 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_B) // data_bucket=1\n+        .commit();\n+\n+    Snapshot secondSnapshot = table.currentSnapshot();\n+    long t2 = System.currentTimeMillis();\n+    while (t2 <= table.currentSnapshot().timestampMillis()) {\n+      t2 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_C) // data_bucket=2\n+        .commit();\n+\n+    Snapshot thirdSnapshot = table.currentSnapshot();\n+    long t3 = System.currentTimeMillis();\n+    while (t3 <= table.currentSnapshot().timestampMillis()) {\n+      t3 = System.currentTimeMillis();\n+    }\n+\n+    // Retain last 2 snapshots and expire older than t3\n+    Actions.forTable(table).expireSnapshots()\n+        .expireOlderThan(secondSnapshot.timestampMillis())\n+        .expireOlderThan(thirdSnapshot.timestampMillis())\n+        .execute();\n+\n+    Assert.assertEquals(\"Should have one snapshots.\",\n+        1, Lists.newArrayList(table.snapshots()).size());\n+    Assert.assertNull(\"Second snapshot should not present.\",\n+        table.snapshot(secondSnapshot.snapshotId()));\n+  }\n+\n+  @Test\n+  public void testRetainLastMultipleCalls() {\n+    long t0 = System.currentTimeMillis();\n+    table.newAppend()\n+        .appendFile(FILE_A) // data_bucket=0\n+        .commit();\n+    long t1 = System.currentTimeMillis();\n+    while (t1 <= table.currentSnapshot().timestampMillis()) {\n+      t1 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_B) // data_bucket=1\n+        .commit();\n+\n+    Snapshot secondSnapshot = table.currentSnapshot();\n+    long t2 = System.currentTimeMillis();\n+    while (t2 <= table.currentSnapshot().timestampMillis()) {\n+      t2 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_C) // data_bucket=2\n+        .commit();\n+\n+    long t3 = System.currentTimeMillis();\n+    while (t3 <= table.currentSnapshot().timestampMillis()) {\n+      t3 = System.currentTimeMillis();\n+    }\n+\n+    // Retain last 2 snapshots and expire older than t3\n+    Actions.forTable(table).expireSnapshots()\n+        .expireOlderThan(t3)\n+        .retainLast(2)\n+        .retainLast(1)\n+        .execute();\n+\n+    Assert.assertEquals(\"Should have one snapshots.\",\n+        1, Lists.newArrayList(table.snapshots()).size());\n+    Assert.assertNull(\"Second snapshot should not present.\",\n+        table.snapshot(secondSnapshot.snapshotId()));\n+  }\n+\n+  @Test\n+  public void testRetainZeroSnapshots() {\n+    AssertHelpers.assertThrows(\"Should fail retain 0 snapshots \" +\n+            \"because number of snapshots to retain cannot be zero\",\n+        IllegalArgumentException.class,\n+        \"Number of snapshots to retain must be at least 1, cannot be: 0\",\n+        () -> Actions.forTable(table).expireSnapshots().retainLast(0).execute());\n+  }\n+\n+  @Test\n+  public void testScanExpiredManifestInValidSnapshotAppend() {\n+    table.newAppend()\n+        .appendFile(FILE_A)\n+        .appendFile(FILE_B)\n+        .commit();\n+\n+    table.newOverwrite()\n+        .addFile(FILE_C)\n+        .deleteFile(FILE_A)\n+        .commit();\n+\n+    table.newAppend()\n+        .appendFile(FILE_D)\n+        .commit();\n+\n+    long t3 = System.currentTimeMillis();\n+    while (t3 <= table.currentSnapshot().timestampMillis()) {\n+      t3 = System.currentTimeMillis();\n+    }\n+\n+    Set<String> deletedFiles = Sets.newHashSet();\n+\n+    Actions.forTable(table).expireSnapshots()\n+        .expireOlderThan(t3)\n+        .deleteWith(deletedFiles::add)\n+        .execute();\n+\n+    Assert.assertTrue(\"FILE_A should be deleted\", deletedFiles.contains(FILE_A.path().toString()));\n+\n+  }\n+\n+  @Test\n+  public void testScanExpiredManifestInValidSnapshotFastAppend() {\n+    table.updateProperties()\n+        .set(TableProperties.MANIFEST_MERGE_ENABLED, \"true\")\n+        .set(TableProperties.MANIFEST_MIN_MERGE_COUNT, \"1\")\n+        .commit();\n+\n+    table.newAppend()\n+        .appendFile(FILE_A)\n+        .appendFile(FILE_B)\n+        .commit();\n+\n+    table.newOverwrite()\n+        .addFile(FILE_C)\n+        .deleteFile(FILE_A)\n+        .commit();\n+\n+    table.newFastAppend()\n+        .appendFile(FILE_D)\n+        .commit();\n+\n+    long t3 = System.currentTimeMillis();\n+    while (t3 <= table.currentSnapshot().timestampMillis()) {\n+      t3 = System.currentTimeMillis();\n+    }\n+\n+    Set<String> deletedFiles = Sets.newHashSet();\n+\n+    Actions.forTable(table).expireSnapshots()\n+        .expireOlderThan(t3)\n+        .deleteWith(deletedFiles::add)\n+        .execute();\n+\n+    Assert.assertTrue(\"FILE_A should be deleted\", deletedFiles.contains(FILE_A.path().toString()));\n+  }\n+\n+  /**\n+   * Test on table below, and expiring the staged commit `B` using `expireOlderThan` API.\n+   * Table: A - C\n+   *          ` B (staged)\n+   */\n+  @Test\n+  public void testWithExpiringDanglingStageCommit() {\n+    // `A` commit\n+    table.newAppend()\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    // `B` staged commit\n+    table.newAppend()\n+        .appendFile(FILE_B)\n+        .stageOnly()\n+        .commit();\n+\n+    TableMetadata base = ((BaseTable) table).operations().current();\n+    Snapshot snapshotA = base.snapshots().get(0);\n+    Snapshot snapshotB = base.snapshots().get(1);\n+\n+    // `C` commit\n+    table.newAppend()\n+        .appendFile(FILE_C)\n+        .commit();\n+\n+    Set<String> deletedFiles = new HashSet<>();\n+\n+    // Expire all commits including dangling staged snapshot.\n+    Actions.forTable(table).expireSnapshots()\n+        .deleteWith(deletedFiles::add)\n+        .expireOlderThan(snapshotB.timestampMillis() + 1)\n+        .execute();\n+\n+    Set<String> expectedDeletes = new HashSet<>();\n+    expectedDeletes.add(snapshotA.manifestListLocation());\n+\n+    // Files should be deleted of dangling staged snapshot\n+    snapshotB.addedFiles().forEach(i -> {\n+      expectedDeletes.add(i.path().toString());\n+    });\n+\n+    // ManifestList should be deleted too\n+    expectedDeletes.add(snapshotB.manifestListLocation());\n+    snapshotB.dataManifests().forEach(file -> {\n+      //Only the manifest of B should be deleted.\n+      if (file.snapshotId() == snapshotB.snapshotId()) {\n+        expectedDeletes.add(file.path());\n+      }\n+    });\n+    Assert.assertSame(\"Files deleted count should be expected\", expectedDeletes.size(), deletedFiles.size());\n+    //Take the diff\n+    expectedDeletes.removeAll(deletedFiles);\n+    Assert.assertTrue(\"Exactly same files should be deleted\", expectedDeletes.isEmpty());\n+  }\n+\n+  /**\n+   * Expire cherry-pick the commit as shown below, when `B` is in table's current state\n+   *  Table:\n+   *  A - B - C <--current snapshot\n+   *   `- D (source=B)\n+   */\n+  @Test\n+  public void testWithCherryPickTableSnapshot() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9cc4e831679d0aab1e4409210f3a7c57094c440c"}, "originalPosition": 657}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzNDE3MDkw", "url": "https://github.com/apache/iceberg/pull/1264#pullrequestreview-463417090", "createdAt": "2020-08-07T15:46:10Z", "commit": {"oid": "9cc4e831679d0aab1e4409210f3a7c57094c440c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNTo0NjoxMFrOG9e1mw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNTo0NjoxMFrOG9e1mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzEyMTU2Mw==", "bodyText": "Ported Test - Only change is using ExpireSnapshotsAction", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r467121563", "createdAt": "2020-08-07T15:46:10Z", "author": {"login": "RussellSpitzer"}, "path": "spark/src/test/java/org/apache/iceberg/actions/TestExpireSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,780 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.BaseTable;\n+import org.apache.iceberg.DataFile;\n+import org.apache.iceberg.DataFiles;\n+import org.apache.iceberg.PartitionSpec;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.Snapshot;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableProperties;\n+import org.apache.iceberg.hadoop.HadoopTables;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableSet;\n+import org.apache.iceberg.relocated.com.google.common.collect.Iterables;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.relocated.com.google.common.collect.Sets;\n+import org.apache.iceberg.spark.SparkTestBase;\n+import org.apache.iceberg.spark.source.ThreeColumnRecord;\n+import org.apache.iceberg.types.Types;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import static org.apache.iceberg.types.Types.NestedField.optional;\n+\n+public abstract class TestExpireSnapshotsAction extends SparkTestBase {\n+\n+  private static final HadoopTables TABLES = new HadoopTables(new Configuration());\n+  private static final Schema SCHEMA = new Schema(\n+      optional(1, \"c1\", Types.IntegerType.get()),\n+      optional(2, \"c2\", Types.StringType.get()),\n+      optional(3, \"c3\", Types.StringType.get())\n+  );\n+\n+  private static final PartitionSpec SPEC = PartitionSpec.builderFor(SCHEMA).identity(\"c1\").build();\n+\n+  private static final List<ThreeColumnRecord> RECORDS = Lists.newArrayList(new ThreeColumnRecord(1, \"AAAA\", \"AAAA\"));\n+\n+  static final DataFile FILE_A = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-a.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=0\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+  static final DataFile FILE_B = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-b.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=1\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+  static final DataFile FILE_C = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-c.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=2\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+  static final DataFile FILE_D = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-d.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=3\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+\n+  @Rule\n+  public TemporaryFolder temp = new TemporaryFolder();\n+\n+  private File tableDir;\n+  private String tableLocation;\n+  private Table table;\n+\n+  @Before\n+  public void setupTableLocation() throws Exception {\n+    this.tableDir = temp.newFolder();\n+    this.tableLocation = tableDir.toURI().toString();\n+    this.table = TABLES.create(SCHEMA, SPEC, Maps.newHashMap(), tableLocation);\n+  }\n+\n+  private Dataset<Row> buildDF(List<ThreeColumnRecord> records) {\n+    return spark.createDataFrame(records, ThreeColumnRecord.class).coalesce(1);\n+  }\n+\n+  private void writeDF(Dataset<Row> df, String mode) {\n+    df.select(\"c1\", \"c2\", \"c3\")\n+        .write()\n+        .format(\"iceberg\")\n+        .mode(mode)\n+        .save(tableLocation);\n+  }\n+\n+  private void checkExpirationResults(Long expectedDatafiles, Long expectedManifestsDeleted,\n+      Long expectedManifestListsDeleted, ExpireSnapshotsActionResult results) {\n+\n+    Assert.assertEquals(\"Incorrect number of manifest files deleted\",\n+        expectedManifestsDeleted, results.getManifestFilesDeleted());\n+    Assert.assertEquals(\"Incorrect number of datafiles deleted\",\n+        expectedDatafiles, results.getDataFilesDeleted());\n+    Assert.assertEquals(\"Incorrect number of manifest lists deleted\",\n+        expectedManifestListsDeleted, results.getManifestListsDeleted());\n+  }\n+\n+  @Test\n+  public void testFilesCleaned() throws Exception {\n+    Dataset<Row> df = buildDF(RECORDS);\n+\n+    writeDF(df, \"append\");\n+\n+    List<Path> expiredDataFiles = Files\n+        .list(tableDir.toPath().resolve(\"data\").resolve(\"c1=1\"))\n+        .collect(Collectors.toList());\n+\n+    Assert.assertEquals(\"There should be a data file to delete but there was none.\",\n+        2, expiredDataFiles.size());\n+\n+    writeDF(df, \"overwrite\");\n+    writeDF(df, \"append\");\n+\n+    long end = System.currentTimeMillis();\n+    while (end <= table.currentSnapshot().timestampMillis()) {\n+      end = System.currentTimeMillis();\n+    }\n+\n+    ExpireSnapshotsActionResult results =\n+        Actions.forTable(table).expireSnapshots().expireOlderThan(end).execute();\n+\n+    table.refresh();\n+\n+    Assert.assertEquals(\"Table does not have 1 snapshot after expiration\", 1, Iterables.size(table.snapshots()));\n+\n+    for (Path p : expiredDataFiles) {\n+      Assert.assertFalse(String.format(\"File %s still exists but should have been deleted\", p),\n+          Files.exists(p));\n+    }\n+\n+    checkExpirationResults(1L, 2L, 2L, results);\n+  }\n+\n+  @Test\n+  public void dataFilesCleanupWithParallelTasks() throws IOException {\n+\n+    table.newFastAppend()\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    table.newFastAppend()\n+        .appendFile(FILE_B)\n+        .commit();\n+\n+    table.newRewrite()\n+        .rewriteFiles(ImmutableSet.of(FILE_B), ImmutableSet.of(FILE_D))\n+        .commit();\n+    long thirdSnapshotId = table.currentSnapshot().snapshotId();\n+\n+    table.newRewrite()\n+        .rewriteFiles(ImmutableSet.of(FILE_A), ImmutableSet.of(FILE_C))\n+        .commit();\n+    long fourthSnapshotId = table.currentSnapshot().snapshotId();\n+\n+    long t4 = System.currentTimeMillis();\n+    while (t4 <= table.currentSnapshot().timestampMillis()) {\n+      t4 = System.currentTimeMillis();\n+    }\n+\n+    Set<String> deletedFiles = Sets.newHashSet();\n+    Set<String> deleteThreads = ConcurrentHashMap.newKeySet();\n+    AtomicInteger deleteThreadsIndex = new AtomicInteger(0);\n+\n+    Actions.forTable(table).expireSnapshots()\n+        .executeDeleteWith(Executors.newFixedThreadPool(4, runnable -> {\n+          Thread thread = new Thread(runnable);\n+          thread.setName(\"remove-snapshot-\" + deleteThreadsIndex.getAndIncrement());\n+          thread.setDaemon(true); // daemon threads will be terminated abruptly when the JVM exits\n+          return thread;\n+        }))\n+        .expireOlderThan(t4)\n+        .deleteWith(s -> {\n+          deleteThreads.add(Thread.currentThread().getName());\n+          deletedFiles.add(s);\n+        })\n+        .execute();\n+\n+    // Verifies that the delete methods ran in the threads created by the provided ExecutorService ThreadFactory\n+    Assert.assertEquals(deleteThreads,\n+        Sets.newHashSet(\"remove-snapshot-0\", \"remove-snapshot-1\", \"remove-snapshot-2\", \"remove-snapshot-3\"));\n+\n+    Assert.assertTrue(\"FILE_A should be deleted\", deletedFiles.contains(FILE_A.path().toString()));\n+    Assert.assertTrue(\"FILE_B should be deleted\", deletedFiles.contains(FILE_B.path().toString()));\n+  }\n+\n+  @Test\n+  public void testNoFilesDeletedWhenNoSnapshotsExpired() throws Exception {\n+    Dataset<Row> df = buildDF(RECORDS);\n+\n+    writeDF(df, \"append\");\n+\n+    ExpireSnapshotsActionResult results =\n+        Actions.forTable(table).expireSnapshots().execute();\n+\n+    checkExpirationResults(0L, 0L, 0L, results);\n+  }\n+\n+  @Test\n+  public void testCleanupRepeatedOverwrites() throws Exception {\n+    Dataset<Row> df = buildDF(RECORDS);\n+\n+    writeDF(df, \"append\");\n+\n+    for (int i = 0; i < 10; i++) {\n+      writeDF(df, \"overwrite\");\n+    }\n+\n+    long end = System.currentTimeMillis();\n+    while (end <= table.currentSnapshot().timestampMillis()) {\n+      end = System.currentTimeMillis();\n+    }\n+\n+    ExpireSnapshotsActionResult results =\n+        Actions.forTable(table).expireSnapshots().expireOlderThan(end).execute();\n+\n+    checkExpirationResults(10L, 19L, 10L, results);\n+  }\n+\n+  @Test\n+  public void testRetainLastWithExpireOlderThan() {\n+    long t0 = System.currentTimeMillis();\n+    table.newAppend()\n+        .appendFile(FILE_A) // data_bucket=0\n+        .commit();\n+    long firstSnapshotId = table.currentSnapshot().snapshotId();\n+    long t1 = System.currentTimeMillis();\n+    while (t1 <= table.currentSnapshot().timestampMillis()) {\n+      t1 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_B) // data_bucket=1\n+        .commit();\n+\n+    long t2 = System.currentTimeMillis();\n+    while (t2 <= table.currentSnapshot().timestampMillis()) {\n+      t2 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_C) // data_bucket=2\n+        .commit();\n+\n+    long t3 = System.currentTimeMillis();\n+    while (t3 <= table.currentSnapshot().timestampMillis()) {\n+      t3 = System.currentTimeMillis();\n+    }\n+\n+    // Retain last 2 snapshots\n+    Actions.forTable(table).expireSnapshots()\n+        .expireOlderThan(t3)\n+        .retainLast(2)\n+        .execute();\n+\n+    Assert.assertEquals(\"Should have two snapshots.\",\n+        2, Lists.newArrayList(table.snapshots()).size());\n+    Assert.assertEquals(\"First snapshot should not present.\",\n+        null, table.snapshot(firstSnapshotId));\n+  }\n+\n+  @Test\n+  public void testRetainLastWithExpireById() {\n+    long t0 = System.currentTimeMillis();\n+    table.newAppend()\n+        .appendFile(FILE_A) // data_bucket=0\n+        .commit();\n+    long firstSnapshotId = table.currentSnapshot().snapshotId();\n+    long t1 = System.currentTimeMillis();\n+    while (t1 <= table.currentSnapshot().timestampMillis()) {\n+      t1 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_B) // data_bucket=1\n+        .commit();\n+\n+    long t2 = System.currentTimeMillis();\n+    while (t2 <= table.currentSnapshot().timestampMillis()) {\n+      t2 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_C) // data_bucket=2\n+        .commit();\n+\n+    long t3 = System.currentTimeMillis();\n+    while (t3 <= table.currentSnapshot().timestampMillis()) {\n+      t3 = System.currentTimeMillis();\n+    }\n+\n+    // Retain last 3 snapshots, but explicitly remove the first snapshot\n+    Actions.forTable(table).expireSnapshots()\n+        .expireSnapshotId(firstSnapshotId)\n+        .retainLast(3)\n+        .execute();\n+\n+    Assert.assertEquals(\"Should have two snapshots.\",\n+        2, Lists.newArrayList(table.snapshots()).size());\n+    Assert.assertEquals(\"First snapshot should not present.\",\n+        null, table.snapshot(firstSnapshotId));\n+  }\n+\n+  @Test\n+  public void testRetainLastWithTooFewSnapshots() {\n+    long t0 = System.currentTimeMillis();\n+    table.newAppend()\n+        .appendFile(FILE_A) // data_bucket=0\n+        .appendFile(FILE_B) // data_bucket=1\n+        .commit();\n+    long firstSnapshotId = table.currentSnapshot().snapshotId();\n+\n+    long t1 = System.currentTimeMillis();\n+    while (t1 <= table.currentSnapshot().timestampMillis()) {\n+      t1 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_C) // data_bucket=2\n+        .commit();\n+\n+    long t2 = System.currentTimeMillis();\n+    while (t2 <= table.currentSnapshot().timestampMillis()) {\n+      t2 = System.currentTimeMillis();\n+    }\n+\n+    // Retain last 3 snapshots\n+    Actions.forTable(table).expireSnapshots()\n+        .expireOlderThan(t2)\n+        .retainLast(3)\n+        .execute();\n+\n+    Assert.assertEquals(\"Should have two snapshots\",\n+        2, Lists.newArrayList(table.snapshots()).size());\n+    Assert.assertEquals(\"First snapshot should still present\",\n+        firstSnapshotId, table.snapshot(firstSnapshotId).snapshotId());\n+  }\n+\n+  @Test\n+  public void testRetainLastKeepsExpiringSnapshot() {\n+    long t0 = System.currentTimeMillis();\n+    table.newAppend()\n+        .appendFile(FILE_A) // data_bucket=0\n+        .commit();\n+    long t1 = System.currentTimeMillis();\n+    while (t1 <= table.currentSnapshot().timestampMillis()) {\n+      t1 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_B) // data_bucket=1\n+        .commit();\n+\n+    Snapshot secondSnapshot = table.currentSnapshot();\n+    long t2 = System.currentTimeMillis();\n+    while (t2 <= table.currentSnapshot().timestampMillis()) {\n+      t2 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_C) // data_bucket=2\n+        .commit();\n+\n+    long t3 = System.currentTimeMillis();\n+    while (t3 <= table.currentSnapshot().timestampMillis()) {\n+      t3 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_D) // data_bucket=3\n+        .commit();\n+\n+    long t4 = System.currentTimeMillis();\n+    while (t4 <= table.currentSnapshot().timestampMillis()) {\n+      t4 = System.currentTimeMillis();\n+    }\n+\n+    // Retain last 2 snapshots and expire older than t3\n+    Actions.forTable(table).expireSnapshots()\n+        .expireOlderThan(secondSnapshot.timestampMillis())\n+        .retainLast(2)\n+        .execute();\n+\n+    Assert.assertEquals(\"Should have three snapshots.\",\n+        3, Lists.newArrayList(table.snapshots()).size());\n+    Assert.assertNotNull(\"Second snapshot should present.\",\n+        table.snapshot(secondSnapshot.snapshotId()));\n+  }\n+\n+  @Test\n+  public void testExpireOlderThanMultipleCalls() {\n+    long t0 = System.currentTimeMillis();\n+    table.newAppend()\n+        .appendFile(FILE_A) // data_bucket=0\n+        .commit();\n+    long t1 = System.currentTimeMillis();\n+    while (t1 <= table.currentSnapshot().timestampMillis()) {\n+      t1 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_B) // data_bucket=1\n+        .commit();\n+\n+    Snapshot secondSnapshot = table.currentSnapshot();\n+    long t2 = System.currentTimeMillis();\n+    while (t2 <= table.currentSnapshot().timestampMillis()) {\n+      t2 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_C) // data_bucket=2\n+        .commit();\n+\n+    Snapshot thirdSnapshot = table.currentSnapshot();\n+    long t3 = System.currentTimeMillis();\n+    while (t3 <= table.currentSnapshot().timestampMillis()) {\n+      t3 = System.currentTimeMillis();\n+    }\n+\n+    // Retain last 2 snapshots and expire older than t3\n+    Actions.forTable(table).expireSnapshots()\n+        .expireOlderThan(secondSnapshot.timestampMillis())\n+        .expireOlderThan(thirdSnapshot.timestampMillis())\n+        .execute();\n+\n+    Assert.assertEquals(\"Should have one snapshots.\",\n+        1, Lists.newArrayList(table.snapshots()).size());\n+    Assert.assertNull(\"Second snapshot should not present.\",\n+        table.snapshot(secondSnapshot.snapshotId()));\n+  }\n+\n+  @Test\n+  public void testRetainLastMultipleCalls() {\n+    long t0 = System.currentTimeMillis();\n+    table.newAppend()\n+        .appendFile(FILE_A) // data_bucket=0\n+        .commit();\n+    long t1 = System.currentTimeMillis();\n+    while (t1 <= table.currentSnapshot().timestampMillis()) {\n+      t1 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_B) // data_bucket=1\n+        .commit();\n+\n+    Snapshot secondSnapshot = table.currentSnapshot();\n+    long t2 = System.currentTimeMillis();\n+    while (t2 <= table.currentSnapshot().timestampMillis()) {\n+      t2 = System.currentTimeMillis();\n+    }\n+\n+    table.newAppend()\n+        .appendFile(FILE_C) // data_bucket=2\n+        .commit();\n+\n+    long t3 = System.currentTimeMillis();\n+    while (t3 <= table.currentSnapshot().timestampMillis()) {\n+      t3 = System.currentTimeMillis();\n+    }\n+\n+    // Retain last 2 snapshots and expire older than t3\n+    Actions.forTable(table).expireSnapshots()\n+        .expireOlderThan(t3)\n+        .retainLast(2)\n+        .retainLast(1)\n+        .execute();\n+\n+    Assert.assertEquals(\"Should have one snapshots.\",\n+        1, Lists.newArrayList(table.snapshots()).size());\n+    Assert.assertNull(\"Second snapshot should not present.\",\n+        table.snapshot(secondSnapshot.snapshotId()));\n+  }\n+\n+  @Test\n+  public void testRetainZeroSnapshots() {\n+    AssertHelpers.assertThrows(\"Should fail retain 0 snapshots \" +\n+            \"because number of snapshots to retain cannot be zero\",\n+        IllegalArgumentException.class,\n+        \"Number of snapshots to retain must be at least 1, cannot be: 0\",\n+        () -> Actions.forTable(table).expireSnapshots().retainLast(0).execute());\n+  }\n+\n+  @Test\n+  public void testScanExpiredManifestInValidSnapshotAppend() {\n+    table.newAppend()\n+        .appendFile(FILE_A)\n+        .appendFile(FILE_B)\n+        .commit();\n+\n+    table.newOverwrite()\n+        .addFile(FILE_C)\n+        .deleteFile(FILE_A)\n+        .commit();\n+\n+    table.newAppend()\n+        .appendFile(FILE_D)\n+        .commit();\n+\n+    long t3 = System.currentTimeMillis();\n+    while (t3 <= table.currentSnapshot().timestampMillis()) {\n+      t3 = System.currentTimeMillis();\n+    }\n+\n+    Set<String> deletedFiles = Sets.newHashSet();\n+\n+    Actions.forTable(table).expireSnapshots()\n+        .expireOlderThan(t3)\n+        .deleteWith(deletedFiles::add)\n+        .execute();\n+\n+    Assert.assertTrue(\"FILE_A should be deleted\", deletedFiles.contains(FILE_A.path().toString()));\n+\n+  }\n+\n+  @Test\n+  public void testScanExpiredManifestInValidSnapshotFastAppend() {\n+    table.updateProperties()\n+        .set(TableProperties.MANIFEST_MERGE_ENABLED, \"true\")\n+        .set(TableProperties.MANIFEST_MIN_MERGE_COUNT, \"1\")\n+        .commit();\n+\n+    table.newAppend()\n+        .appendFile(FILE_A)\n+        .appendFile(FILE_B)\n+        .commit();\n+\n+    table.newOverwrite()\n+        .addFile(FILE_C)\n+        .deleteFile(FILE_A)\n+        .commit();\n+\n+    table.newFastAppend()\n+        .appendFile(FILE_D)\n+        .commit();\n+\n+    long t3 = System.currentTimeMillis();\n+    while (t3 <= table.currentSnapshot().timestampMillis()) {\n+      t3 = System.currentTimeMillis();\n+    }\n+\n+    Set<String> deletedFiles = Sets.newHashSet();\n+\n+    Actions.forTable(table).expireSnapshots()\n+        .expireOlderThan(t3)\n+        .deleteWith(deletedFiles::add)\n+        .execute();\n+\n+    Assert.assertTrue(\"FILE_A should be deleted\", deletedFiles.contains(FILE_A.path().toString()));\n+  }\n+\n+  /**\n+   * Test on table below, and expiring the staged commit `B` using `expireOlderThan` API.\n+   * Table: A - C\n+   *          ` B (staged)\n+   */\n+  @Test\n+  public void testWithExpiringDanglingStageCommit() {\n+    // `A` commit\n+    table.newAppend()\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    // `B` staged commit\n+    table.newAppend()\n+        .appendFile(FILE_B)\n+        .stageOnly()\n+        .commit();\n+\n+    TableMetadata base = ((BaseTable) table).operations().current();\n+    Snapshot snapshotA = base.snapshots().get(0);\n+    Snapshot snapshotB = base.snapshots().get(1);\n+\n+    // `C` commit\n+    table.newAppend()\n+        .appendFile(FILE_C)\n+        .commit();\n+\n+    Set<String> deletedFiles = new HashSet<>();\n+\n+    // Expire all commits including dangling staged snapshot.\n+    Actions.forTable(table).expireSnapshots()\n+        .deleteWith(deletedFiles::add)\n+        .expireOlderThan(snapshotB.timestampMillis() + 1)\n+        .execute();\n+\n+    Set<String> expectedDeletes = new HashSet<>();\n+    expectedDeletes.add(snapshotA.manifestListLocation());\n+\n+    // Files should be deleted of dangling staged snapshot\n+    snapshotB.addedFiles().forEach(i -> {\n+      expectedDeletes.add(i.path().toString());\n+    });\n+\n+    // ManifestList should be deleted too\n+    expectedDeletes.add(snapshotB.manifestListLocation());\n+    snapshotB.dataManifests().forEach(file -> {\n+      //Only the manifest of B should be deleted.\n+      if (file.snapshotId() == snapshotB.snapshotId()) {\n+        expectedDeletes.add(file.path());\n+      }\n+    });\n+    Assert.assertSame(\"Files deleted count should be expected\", expectedDeletes.size(), deletedFiles.size());\n+    //Take the diff\n+    expectedDeletes.removeAll(deletedFiles);\n+    Assert.assertTrue(\"Exactly same files should be deleted\", expectedDeletes.isEmpty());\n+  }\n+\n+  /**\n+   * Expire cherry-pick the commit as shown below, when `B` is in table's current state\n+   *  Table:\n+   *  A - B - C <--current snapshot\n+   *   `- D (source=B)\n+   */\n+  @Test\n+  public void testWithCherryPickTableSnapshot() {\n+    // `A` commit\n+    table.newAppend()\n+        .appendFile(FILE_A)\n+        .commit();\n+    Snapshot snapshotA = table.currentSnapshot();\n+\n+    // `B` commit\n+    Set<String> deletedAFiles = new HashSet<>();\n+    table.newOverwrite()\n+        .addFile(FILE_B)\n+        .deleteFile(FILE_A)\n+        .deleteWith(deletedAFiles::add)\n+        .commit();\n+    Assert.assertTrue(\"No files should be physically deleted\", deletedAFiles.isEmpty());\n+\n+    // pick the snapshot 'B`\n+    Snapshot snapshotB = table.currentSnapshot();\n+\n+    // `C` commit to let cherry-pick take effect, and avoid fast-forward of `B` with cherry-pick\n+    table.newAppend()\n+        .appendFile(FILE_C)\n+        .commit();\n+    Snapshot snapshotC = table.currentSnapshot();\n+\n+    // Move the table back to `A`\n+    table.manageSnapshots()\n+        .setCurrentSnapshot(snapshotA.snapshotId())\n+        .commit();\n+\n+    // Generate A -> `D (B)`\n+    table.manageSnapshots()\n+        .cherrypick(snapshotB.snapshotId())\n+        .commit();\n+    Snapshot snapshotD = table.currentSnapshot();\n+\n+    // Move the table back to `C`\n+    table.manageSnapshots()\n+        .setCurrentSnapshot(snapshotC.snapshotId())\n+        .commit();\n+    List<String> deletedFiles = new ArrayList<>();\n+\n+    // Expire `C`\n+    Actions.forTable(table).expireSnapshots()\n+        .deleteWith(deletedFiles::add)\n+        .expireOlderThan(snapshotC.timestampMillis() + 1)\n+        .execute();\n+\n+    // Make sure no dataFiles are deleted for the B, C, D snapshot\n+    Lists.newArrayList(snapshotB, snapshotC, snapshotD).forEach(i -> {\n+      i.addedFiles().forEach(item -> {\n+        Assert.assertFalse(deletedFiles.contains(item.path().toString()));\n+      });\n+    });\n+  }\n+\n+  /**\n+   * Test on table below, and expiring `B` which is not in current table state.\n+   *  1) Expire `B`\n+   *  2) All commit\n+   * Table: A - C - D (B)\n+   *          ` B (staged)\n+   */\n+  @Test\n+  public void testWithExpiringStagedThenCherrypick() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9cc4e831679d0aab1e4409210f3a7c57094c440c"}, "originalPosition": 721}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzNDE3NDg1", "url": "https://github.com/apache/iceberg/pull/1264#pullrequestreview-463417485", "createdAt": "2020-08-07T15:46:48Z", "commit": {"oid": "9cc4e831679d0aab1e4409210f3a7c57094c440c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNTo0Njo0OFrOG9e22w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNTo0Njo0OFrOG9e22w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzEyMTg4Mw==", "bodyText": "These files are directly copied out of the Core Test Base, only modification is in the partitioning path", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r467121883", "createdAt": "2020-08-07T15:46:48Z", "author": {"login": "RussellSpitzer"}, "path": "spark/src/test/java/org/apache/iceberg/actions/TestExpireSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,780 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.BaseTable;\n+import org.apache.iceberg.DataFile;\n+import org.apache.iceberg.DataFiles;\n+import org.apache.iceberg.PartitionSpec;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.Snapshot;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableProperties;\n+import org.apache.iceberg.hadoop.HadoopTables;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableSet;\n+import org.apache.iceberg.relocated.com.google.common.collect.Iterables;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.relocated.com.google.common.collect.Sets;\n+import org.apache.iceberg.spark.SparkTestBase;\n+import org.apache.iceberg.spark.source.ThreeColumnRecord;\n+import org.apache.iceberg.types.Types;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import static org.apache.iceberg.types.Types.NestedField.optional;\n+\n+public abstract class TestExpireSnapshotsAction extends SparkTestBase {\n+\n+  private static final HadoopTables TABLES = new HadoopTables(new Configuration());\n+  private static final Schema SCHEMA = new Schema(\n+      optional(1, \"c1\", Types.IntegerType.get()),\n+      optional(2, \"c2\", Types.StringType.get()),\n+      optional(3, \"c3\", Types.StringType.get())\n+  );\n+\n+  private static final PartitionSpec SPEC = PartitionSpec.builderFor(SCHEMA).identity(\"c1\").build();\n+\n+  private static final List<ThreeColumnRecord> RECORDS = Lists.newArrayList(new ThreeColumnRecord(1, \"AAAA\", \"AAAA\"));\n+\n+  static final DataFile FILE_A = DataFiles.builder(SPEC)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9cc4e831679d0aab1e4409210f3a7c57094c440c"}, "originalPosition": 77}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzNDE4MTM3", "url": "https://github.com/apache/iceberg/pull/1264#pullrequestreview-463418137", "createdAt": "2020-08-07T15:47:41Z", "commit": {"oid": "9cc4e831679d0aab1e4409210f3a7c57094c440c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNTo0Nzo0MVrOG9e43A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNTo0Nzo0MVrOG9e43A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzEyMjM5Ng==", "bodyText": "The only tests not directly ported were those doing file cleanup (except for the parallel delete one) since we already had new tests for those functions.", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r467122396", "createdAt": "2020-08-07T15:47:41Z", "author": {"login": "RussellSpitzer"}, "path": "spark/src/test/java/org/apache/iceberg/actions/TestExpireSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,780 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.BaseTable;\n+import org.apache.iceberg.DataFile;\n+import org.apache.iceberg.DataFiles;\n+import org.apache.iceberg.PartitionSpec;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.Snapshot;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableProperties;\n+import org.apache.iceberg.hadoop.HadoopTables;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableSet;\n+import org.apache.iceberg.relocated.com.google.common.collect.Iterables;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.relocated.com.google.common.collect.Sets;\n+import org.apache.iceberg.spark.SparkTestBase;\n+import org.apache.iceberg.spark.source.ThreeColumnRecord;\n+import org.apache.iceberg.types.Types;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import static org.apache.iceberg.types.Types.NestedField.optional;\n+\n+public abstract class TestExpireSnapshotsAction extends SparkTestBase {\n+\n+  private static final HadoopTables TABLES = new HadoopTables(new Configuration());\n+  private static final Schema SCHEMA = new Schema(\n+      optional(1, \"c1\", Types.IntegerType.get()),\n+      optional(2, \"c2\", Types.StringType.get()),\n+      optional(3, \"c3\", Types.StringType.get())\n+  );\n+\n+  private static final PartitionSpec SPEC = PartitionSpec.builderFor(SCHEMA).identity(\"c1\").build();\n+\n+  private static final List<ThreeColumnRecord> RECORDS = Lists.newArrayList(new ThreeColumnRecord(1, \"AAAA\", \"AAAA\"));\n+\n+  static final DataFile FILE_A = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-a.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=0\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+  static final DataFile FILE_B = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-b.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=1\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+  static final DataFile FILE_C = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-c.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=2\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+  static final DataFile FILE_D = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-d.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=3\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+\n+  @Rule\n+  public TemporaryFolder temp = new TemporaryFolder();\n+\n+  private File tableDir;\n+  private String tableLocation;\n+  private Table table;\n+\n+  @Before\n+  public void setupTableLocation() throws Exception {\n+    this.tableDir = temp.newFolder();\n+    this.tableLocation = tableDir.toURI().toString();\n+    this.table = TABLES.create(SCHEMA, SPEC, Maps.newHashMap(), tableLocation);\n+  }\n+\n+  private Dataset<Row> buildDF(List<ThreeColumnRecord> records) {\n+    return spark.createDataFrame(records, ThreeColumnRecord.class).coalesce(1);\n+  }\n+\n+  private void writeDF(Dataset<Row> df, String mode) {\n+    df.select(\"c1\", \"c2\", \"c3\")\n+        .write()\n+        .format(\"iceberg\")\n+        .mode(mode)\n+        .save(tableLocation);\n+  }\n+\n+  private void checkExpirationResults(Long expectedDatafiles, Long expectedManifestsDeleted,\n+      Long expectedManifestListsDeleted, ExpireSnapshotsActionResult results) {\n+\n+    Assert.assertEquals(\"Incorrect number of manifest files deleted\",\n+        expectedManifestsDeleted, results.getManifestFilesDeleted());\n+    Assert.assertEquals(\"Incorrect number of datafiles deleted\",\n+        expectedDatafiles, results.getDataFilesDeleted());\n+    Assert.assertEquals(\"Incorrect number of manifest lists deleted\",\n+        expectedManifestListsDeleted, results.getManifestListsDeleted());\n+  }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9cc4e831679d0aab1e4409210f3a7c57094c440c"}, "originalPosition": 138}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a50e3e8afe7dd209e0d17404654c7c00a547ceb1", "author": {"user": {"login": "RussellSpitzer", "name": "Russell Spitzer"}}, "url": "https://github.com/apache/iceberg/commit/a50e3e8afe7dd209e0d17404654c7c00a547ceb1", "committedDate": "2020-08-10T15:24:47Z", "message": "Change Log Level of  File Delete Count to INFO"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0MzY1MzU0", "url": "https://github.com/apache/iceberg/pull/1264#pullrequestreview-464365354", "createdAt": "2020-08-10T15:59:18Z", "commit": {"oid": "a50e3e8afe7dd209e0d17404654c7c00a547ceb1"}, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxNTo1OToxOVrOG-VK4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxNjoxNjowM1rOG-VzKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODAxMTc0Ng==", "bodyText": "I am OK with the way it is done. An alternative would be to add more methods to TableMetadata directly. It has access to snapshots and previous metadata files. We don't have access to version-hint.text, though. Any thoughts, @rdblue?", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r468011746", "createdAt": "2020-08-10T15:59:19Z", "author": {"login": "aokolnychyi"}, "path": "core/src/main/java/org/apache/iceberg/util/TableUtil.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.util;\n+\n+import java.util.List;\n+import org.apache.iceberg.Snapshot;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+\n+public class TableUtil {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a50e3e8afe7dd209e0d17404654c7c00a547ceb1"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODAxMjQ0OA==", "bodyText": "nit: I think we can skip org.apache.iceberg in the doc as it is already imported.", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r468012448", "createdAt": "2020-08-10T16:00:25Z", "author": {"login": "aokolnychyi"}, "path": "spark/src/main/java/org/apache/iceberg/actions/ExpireSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Consumer;\n+import org.apache.iceberg.ExpireSnapshots;\n+import org.apache.iceberg.HasTableOperations;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.exceptions.NotFoundException;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.util.concurrent.MoreExecutors;\n+import org.apache.iceberg.util.Tasks;\n+import org.apache.spark.sql.Column;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SparkSession;\n+import org.apache.spark.sql.functions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * An action which performs the same operation as {@link org.apache.iceberg.ExpireSnapshots} but uses Spark", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a50e3e8afe7dd209e0d17404654c7c00a547ceb1"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODAxMjU5OQ==", "bodyText": "nit: to to", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r468012599", "createdAt": "2020-08-10T16:00:40Z", "author": {"login": "aokolnychyi"}, "path": "spark/src/main/java/org/apache/iceberg/actions/ExpireSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Consumer;\n+import org.apache.iceberg.ExpireSnapshots;\n+import org.apache.iceberg.HasTableOperations;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.exceptions.NotFoundException;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.util.concurrent.MoreExecutors;\n+import org.apache.iceberg.util.Tasks;\n+import org.apache.spark.sql.Column;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SparkSession;\n+import org.apache.spark.sql.functions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * An action which performs the same operation as {@link org.apache.iceberg.ExpireSnapshots} but uses Spark\n+ * to to determine the delta in files between the pre and post-expiration table metadata. All of the same", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a50e3e8afe7dd209e0d17404654c7c00a547ceb1"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODAxNDM0OQ==", "bodyText": "nit: org.apache.iceberg. can be dropped.", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r468014349", "createdAt": "2020-08-10T16:03:34Z", "author": {"login": "aokolnychyi"}, "path": "spark/src/main/java/org/apache/iceberg/actions/ExpireSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Consumer;\n+import org.apache.iceberg.ExpireSnapshots;\n+import org.apache.iceberg.HasTableOperations;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.exceptions.NotFoundException;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.util.concurrent.MoreExecutors;\n+import org.apache.iceberg.util.Tasks;\n+import org.apache.spark.sql.Column;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SparkSession;\n+import org.apache.spark.sql.functions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * An action which performs the same operation as {@link org.apache.iceberg.ExpireSnapshots} but uses Spark\n+ * to to determine the delta in files between the pre and post-expiration table metadata. All of the same\n+ * restrictions of Remove Snapshots also apply to this action.\n+ * <p>\n+ * This implementation uses the metadata tables for the table being expired to list all Manifest and DataFiles. This\n+ * is made into a Dataframe which are anti-joined with the same list read after the expiration. This operation will\n+ * require a shuffle so parallelism can be controlled through spark.sql.shuffle.partitions. The expiration is done\n+ * locally using a direct call to RemoveSnapshots. The snapshot expiration will be fully committed before any deletes\n+ * are issued. Deletes are still performed locally after retrieving the results from the Spark executors.\n+ */\n+public class ExpireSnapshotsAction extends BaseAction<ExpireSnapshotsActionResult> {\n+  private static final Logger LOG = LoggerFactory.getLogger(ExpireSnapshotsAction.class);\n+\n+  private static final String DATA_FILE = \"Data File\";\n+  private static final String MANIFEST = \"Manifest\";\n+  private static final String MANIFEST_LIST = \"Manifest List\";\n+\n+  // Creates an executor service that runs each task in the thread that invokes execute/submit.\n+  private static final ExecutorService DEFAULT_DELETE_EXECUTOR_SERVICE = MoreExecutors.newDirectExecutorService();\n+\n+  private final SparkSession spark;\n+  private final Table table;\n+  private final TableOperations ops;\n+  private final Consumer<String> defaultDelete = new Consumer<String>() {\n+    @Override\n+    public void accept(String file) {\n+      ops.io().deleteFile(file);\n+    }\n+  };\n+\n+  private Long expireSnapshotIdValue = null;\n+  private Long expireOlderThanValue = null;\n+  private Integer retainLastValue = null;\n+  private Consumer<String> deleteFunc = defaultDelete;\n+  private ExecutorService deleteExecutorService = DEFAULT_DELETE_EXECUTOR_SERVICE;\n+\n+  ExpireSnapshotsAction(SparkSession spark, Table table) {\n+    this.spark = spark;\n+    this.table = table;\n+    this.ops = ((HasTableOperations) table).operations();\n+  }\n+\n+  @Override\n+  protected Table table() {\n+    return table;\n+  }\n+\n+  /**\n+   * An executor service used when deleting files. Only used during the local delete phase of this Spark action\n+   * Similar to {@link org.apache.iceberg.ExpireSnapshots#executeWith(ExecutorService)}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a50e3e8afe7dd209e0d17404654c7c00a547ceb1"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODAxNTQwMw==", "bodyText": "Similar -> similar or we need . after Spark action.", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r468015403", "createdAt": "2020-08-10T16:05:14Z", "author": {"login": "aokolnychyi"}, "path": "spark/src/main/java/org/apache/iceberg/actions/ExpireSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Consumer;\n+import org.apache.iceberg.ExpireSnapshots;\n+import org.apache.iceberg.HasTableOperations;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.exceptions.NotFoundException;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.util.concurrent.MoreExecutors;\n+import org.apache.iceberg.util.Tasks;\n+import org.apache.spark.sql.Column;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SparkSession;\n+import org.apache.spark.sql.functions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * An action which performs the same operation as {@link org.apache.iceberg.ExpireSnapshots} but uses Spark\n+ * to to determine the delta in files between the pre and post-expiration table metadata. All of the same\n+ * restrictions of Remove Snapshots also apply to this action.\n+ * <p>\n+ * This implementation uses the metadata tables for the table being expired to list all Manifest and DataFiles. This\n+ * is made into a Dataframe which are anti-joined with the same list read after the expiration. This operation will\n+ * require a shuffle so parallelism can be controlled through spark.sql.shuffle.partitions. The expiration is done\n+ * locally using a direct call to RemoveSnapshots. The snapshot expiration will be fully committed before any deletes\n+ * are issued. Deletes are still performed locally after retrieving the results from the Spark executors.\n+ */\n+public class ExpireSnapshotsAction extends BaseAction<ExpireSnapshotsActionResult> {\n+  private static final Logger LOG = LoggerFactory.getLogger(ExpireSnapshotsAction.class);\n+\n+  private static final String DATA_FILE = \"Data File\";\n+  private static final String MANIFEST = \"Manifest\";\n+  private static final String MANIFEST_LIST = \"Manifest List\";\n+\n+  // Creates an executor service that runs each task in the thread that invokes execute/submit.\n+  private static final ExecutorService DEFAULT_DELETE_EXECUTOR_SERVICE = MoreExecutors.newDirectExecutorService();\n+\n+  private final SparkSession spark;\n+  private final Table table;\n+  private final TableOperations ops;\n+  private final Consumer<String> defaultDelete = new Consumer<String>() {\n+    @Override\n+    public void accept(String file) {\n+      ops.io().deleteFile(file);\n+    }\n+  };\n+\n+  private Long expireSnapshotIdValue = null;\n+  private Long expireOlderThanValue = null;\n+  private Integer retainLastValue = null;\n+  private Consumer<String> deleteFunc = defaultDelete;\n+  private ExecutorService deleteExecutorService = DEFAULT_DELETE_EXECUTOR_SERVICE;\n+\n+  ExpireSnapshotsAction(SparkSession spark, Table table) {\n+    this.spark = spark;\n+    this.table = table;\n+    this.ops = ((HasTableOperations) table).operations();\n+  }\n+\n+  @Override\n+  protected Table table() {\n+    return table;\n+  }\n+\n+  /**\n+   * An executor service used when deleting files. Only used during the local delete phase of this Spark action\n+   * Similar to {@link org.apache.iceberg.ExpireSnapshots#executeWith(ExecutorService)}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a50e3e8afe7dd209e0d17404654c7c00a547ceb1"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODAxNjU1Mg==", "bodyText": "nit: org.apache.iceberg. can be dropped in all javadocs.", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r468016552", "createdAt": "2020-08-10T16:07:11Z", "author": {"login": "aokolnychyi"}, "path": "spark/src/main/java/org/apache/iceberg/actions/ExpireSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Consumer;\n+import org.apache.iceberg.ExpireSnapshots;\n+import org.apache.iceberg.HasTableOperations;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.exceptions.NotFoundException;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.util.concurrent.MoreExecutors;\n+import org.apache.iceberg.util.Tasks;\n+import org.apache.spark.sql.Column;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SparkSession;\n+import org.apache.spark.sql.functions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * An action which performs the same operation as {@link org.apache.iceberg.ExpireSnapshots} but uses Spark\n+ * to to determine the delta in files between the pre and post-expiration table metadata. All of the same\n+ * restrictions of Remove Snapshots also apply to this action.\n+ * <p>\n+ * This implementation uses the metadata tables for the table being expired to list all Manifest and DataFiles. This\n+ * is made into a Dataframe which are anti-joined with the same list read after the expiration. This operation will\n+ * require a shuffle so parallelism can be controlled through spark.sql.shuffle.partitions. The expiration is done\n+ * locally using a direct call to RemoveSnapshots. The snapshot expiration will be fully committed before any deletes\n+ * are issued. Deletes are still performed locally after retrieving the results from the Spark executors.\n+ */\n+public class ExpireSnapshotsAction extends BaseAction<ExpireSnapshotsActionResult> {\n+  private static final Logger LOG = LoggerFactory.getLogger(ExpireSnapshotsAction.class);\n+\n+  private static final String DATA_FILE = \"Data File\";\n+  private static final String MANIFEST = \"Manifest\";\n+  private static final String MANIFEST_LIST = \"Manifest List\";\n+\n+  // Creates an executor service that runs each task in the thread that invokes execute/submit.\n+  private static final ExecutorService DEFAULT_DELETE_EXECUTOR_SERVICE = MoreExecutors.newDirectExecutorService();\n+\n+  private final SparkSession spark;\n+  private final Table table;\n+  private final TableOperations ops;\n+  private final Consumer<String> defaultDelete = new Consumer<String>() {\n+    @Override\n+    public void accept(String file) {\n+      ops.io().deleteFile(file);\n+    }\n+  };\n+\n+  private Long expireSnapshotIdValue = null;\n+  private Long expireOlderThanValue = null;\n+  private Integer retainLastValue = null;\n+  private Consumer<String> deleteFunc = defaultDelete;\n+  private ExecutorService deleteExecutorService = DEFAULT_DELETE_EXECUTOR_SERVICE;\n+\n+  ExpireSnapshotsAction(SparkSession spark, Table table) {\n+    this.spark = spark;\n+    this.table = table;\n+    this.ops = ((HasTableOperations) table).operations();\n+  }\n+\n+  @Override\n+  protected Table table() {\n+    return table;\n+  }\n+\n+  /**\n+   * An executor service used when deleting files. Only used during the local delete phase of this Spark action\n+   * Similar to {@link org.apache.iceberg.ExpireSnapshots#executeWith(ExecutorService)}\n+   * @param executorService the service to use\n+   * @return this for method chaining\n+   */\n+  public ExpireSnapshotsAction executeDeleteWith(ExecutorService executorService) {\n+    this.deleteExecutorService = executorService;\n+    return this;\n+  }\n+\n+  /**\n+   * A specific snapshot to expire.\n+   * Identical to {@link org.apache.iceberg.ExpireSnapshots#expireSnapshotId(long)}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a50e3e8afe7dd209e0d17404654c7c00a547ceb1"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODAxODQ0Mg==", "bodyText": "This must be a list as expireSnapshotId can be called multiple times just like in RemoveSnapshots.", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r468018442", "createdAt": "2020-08-10T16:10:16Z", "author": {"login": "aokolnychyi"}, "path": "spark/src/main/java/org/apache/iceberg/actions/ExpireSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Consumer;\n+import org.apache.iceberg.ExpireSnapshots;\n+import org.apache.iceberg.HasTableOperations;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.exceptions.NotFoundException;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.util.concurrent.MoreExecutors;\n+import org.apache.iceberg.util.Tasks;\n+import org.apache.spark.sql.Column;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SparkSession;\n+import org.apache.spark.sql.functions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * An action which performs the same operation as {@link org.apache.iceberg.ExpireSnapshots} but uses Spark\n+ * to to determine the delta in files between the pre and post-expiration table metadata. All of the same\n+ * restrictions of Remove Snapshots also apply to this action.\n+ * <p>\n+ * This implementation uses the metadata tables for the table being expired to list all Manifest and DataFiles. This\n+ * is made into a Dataframe which are anti-joined with the same list read after the expiration. This operation will\n+ * require a shuffle so parallelism can be controlled through spark.sql.shuffle.partitions. The expiration is done\n+ * locally using a direct call to RemoveSnapshots. The snapshot expiration will be fully committed before any deletes\n+ * are issued. Deletes are still performed locally after retrieving the results from the Spark executors.\n+ */\n+public class ExpireSnapshotsAction extends BaseAction<ExpireSnapshotsActionResult> {\n+  private static final Logger LOG = LoggerFactory.getLogger(ExpireSnapshotsAction.class);\n+\n+  private static final String DATA_FILE = \"Data File\";\n+  private static final String MANIFEST = \"Manifest\";\n+  private static final String MANIFEST_LIST = \"Manifest List\";\n+\n+  // Creates an executor service that runs each task in the thread that invokes execute/submit.\n+  private static final ExecutorService DEFAULT_DELETE_EXECUTOR_SERVICE = MoreExecutors.newDirectExecutorService();\n+\n+  private final SparkSession spark;\n+  private final Table table;\n+  private final TableOperations ops;\n+  private final Consumer<String> defaultDelete = new Consumer<String>() {\n+    @Override\n+    public void accept(String file) {\n+      ops.io().deleteFile(file);\n+    }\n+  };\n+\n+  private Long expireSnapshotIdValue = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a50e3e8afe7dd209e0d17404654c7c00a547ceb1"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODAxOTM0OA==", "bodyText": "Sounds good. I know @RussellSpitzer has a separate PR for renaming.", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r468019348", "createdAt": "2020-08-10T16:11:32Z", "author": {"login": "aokolnychyi"}, "path": "spark/src/main/java/org/apache/iceberg/actions/ExpireSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Consumer;\n+import org.apache.iceberg.ExpireSnapshots;\n+import org.apache.iceberg.HasTableOperations;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.exceptions.NotFoundException;\n+import org.apache.iceberg.relocated.com.google.common.util.concurrent.MoreExecutors;\n+import org.apache.iceberg.util.Tasks;\n+import org.apache.spark.sql.Column;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SparkSession;\n+import org.apache.spark.sql.functions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ExpireSnapshotsAction extends BaseAction<ExpireSnapshotsActionResult> {\n+  private static final Logger LOG = LoggerFactory.getLogger(ExpireSnapshotsAction.class);\n+\n+  private static final String DATA_FILE = \"Data File\";\n+  private static final String MANIFEST = \"Manifest\";\n+  private static final String MANIFEST_LIST = \"Manifest List\";\n+\n+  // Creates an executor service that runs each task in the thread that invokes execute/submit.\n+  private static final ExecutorService DEFAULT_DELETE_EXECUTOR_SERVICE = MoreExecutors.newDirectExecutorService();\n+\n+  private final SparkSession spark;\n+  private final Table table;\n+  private final TableOperations ops;\n+  private final Consumer<String> defaultDelete = new Consumer<String>() {\n+    @Override\n+    public void accept(String file) {\n+      ops.io().deleteFile(file);\n+    }\n+  };\n+\n+  private Long expireSnapshotIdValue = null;\n+  private Long expireOlderThanValue = null;\n+  private Integer retainLastValue = null;\n+  private Consumer<String> deleteFunc = defaultDelete;\n+  private ExecutorService deleteExecutorService = DEFAULT_DELETE_EXECUTOR_SERVICE;\n+\n+  ExpireSnapshotsAction(SparkSession spark, Table table) {\n+    this.spark = spark;\n+    this.table = table;\n+    this.ops = ((HasTableOperations) table).operations();\n+  }\n+\n+  @Override\n+  protected Table table() {\n+    return table;\n+  }\n+\n+  /**\n+   * An executor service used when deleting files. Only used during the local delete phase of this Spark action\n+   * @param executorService the service to use\n+   * @return this for method chaining\n+   */\n+  public ExpireSnapshotsAction executeDeleteWith(ExecutorService executorService) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUxMjc5MA=="}, "originalCommit": {"oid": "2e0af0a1121d923978344676d593e46d89686962"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODAyMDA3MQ==", "bodyText": "We will need a test that catches this as well.", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r468020071", "createdAt": "2020-08-10T16:12:48Z", "author": {"login": "aokolnychyi"}, "path": "spark/src/main/java/org/apache/iceberg/actions/ExpireSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Consumer;\n+import org.apache.iceberg.ExpireSnapshots;\n+import org.apache.iceberg.HasTableOperations;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.exceptions.NotFoundException;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.util.concurrent.MoreExecutors;\n+import org.apache.iceberg.util.Tasks;\n+import org.apache.spark.sql.Column;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SparkSession;\n+import org.apache.spark.sql.functions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * An action which performs the same operation as {@link org.apache.iceberg.ExpireSnapshots} but uses Spark\n+ * to to determine the delta in files between the pre and post-expiration table metadata. All of the same\n+ * restrictions of Remove Snapshots also apply to this action.\n+ * <p>\n+ * This implementation uses the metadata tables for the table being expired to list all Manifest and DataFiles. This\n+ * is made into a Dataframe which are anti-joined with the same list read after the expiration. This operation will\n+ * require a shuffle so parallelism can be controlled through spark.sql.shuffle.partitions. The expiration is done\n+ * locally using a direct call to RemoveSnapshots. The snapshot expiration will be fully committed before any deletes\n+ * are issued. Deletes are still performed locally after retrieving the results from the Spark executors.\n+ */\n+public class ExpireSnapshotsAction extends BaseAction<ExpireSnapshotsActionResult> {\n+  private static final Logger LOG = LoggerFactory.getLogger(ExpireSnapshotsAction.class);\n+\n+  private static final String DATA_FILE = \"Data File\";\n+  private static final String MANIFEST = \"Manifest\";\n+  private static final String MANIFEST_LIST = \"Manifest List\";\n+\n+  // Creates an executor service that runs each task in the thread that invokes execute/submit.\n+  private static final ExecutorService DEFAULT_DELETE_EXECUTOR_SERVICE = MoreExecutors.newDirectExecutorService();\n+\n+  private final SparkSession spark;\n+  private final Table table;\n+  private final TableOperations ops;\n+  private final Consumer<String> defaultDelete = new Consumer<String>() {\n+    @Override\n+    public void accept(String file) {\n+      ops.io().deleteFile(file);\n+    }\n+  };\n+\n+  private Long expireSnapshotIdValue = null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODAxODQ0Mg=="}, "originalCommit": {"oid": "a50e3e8afe7dd209e0d17404654c7c00a547ceb1"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODAyMjA1Nw==", "bodyText": "nit: unnecessary variable, can simply return", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r468022057", "createdAt": "2020-08-10T16:16:03Z", "author": {"login": "aokolnychyi"}, "path": "spark/src/main/java/org/apache/iceberg/actions/ExpireSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Consumer;\n+import org.apache.iceberg.ExpireSnapshots;\n+import org.apache.iceberg.HasTableOperations;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.exceptions.NotFoundException;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.util.concurrent.MoreExecutors;\n+import org.apache.iceberg.util.Tasks;\n+import org.apache.spark.sql.Column;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SparkSession;\n+import org.apache.spark.sql.functions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * An action which performs the same operation as {@link org.apache.iceberg.ExpireSnapshots} but uses Spark\n+ * to to determine the delta in files between the pre and post-expiration table metadata. All of the same\n+ * restrictions of Remove Snapshots also apply to this action.\n+ * <p>\n+ * This implementation uses the metadata tables for the table being expired to list all Manifest and DataFiles. This\n+ * is made into a Dataframe which are anti-joined with the same list read after the expiration. This operation will\n+ * require a shuffle so parallelism can be controlled through spark.sql.shuffle.partitions. The expiration is done\n+ * locally using a direct call to RemoveSnapshots. The snapshot expiration will be fully committed before any deletes\n+ * are issued. Deletes are still performed locally after retrieving the results from the Spark executors.\n+ */\n+public class ExpireSnapshotsAction extends BaseAction<ExpireSnapshotsActionResult> {\n+  private static final Logger LOG = LoggerFactory.getLogger(ExpireSnapshotsAction.class);\n+\n+  private static final String DATA_FILE = \"Data File\";\n+  private static final String MANIFEST = \"Manifest\";\n+  private static final String MANIFEST_LIST = \"Manifest List\";\n+\n+  // Creates an executor service that runs each task in the thread that invokes execute/submit.\n+  private static final ExecutorService DEFAULT_DELETE_EXECUTOR_SERVICE = MoreExecutors.newDirectExecutorService();\n+\n+  private final SparkSession spark;\n+  private final Table table;\n+  private final TableOperations ops;\n+  private final Consumer<String> defaultDelete = new Consumer<String>() {\n+    @Override\n+    public void accept(String file) {\n+      ops.io().deleteFile(file);\n+    }\n+  };\n+\n+  private Long expireSnapshotIdValue = null;\n+  private Long expireOlderThanValue = null;\n+  private Integer retainLastValue = null;\n+  private Consumer<String> deleteFunc = defaultDelete;\n+  private ExecutorService deleteExecutorService = DEFAULT_DELETE_EXECUTOR_SERVICE;\n+\n+  ExpireSnapshotsAction(SparkSession spark, Table table) {\n+    this.spark = spark;\n+    this.table = table;\n+    this.ops = ((HasTableOperations) table).operations();\n+  }\n+\n+  @Override\n+  protected Table table() {\n+    return table;\n+  }\n+\n+  /**\n+   * An executor service used when deleting files. Only used during the local delete phase of this Spark action\n+   * Similar to {@link org.apache.iceberg.ExpireSnapshots#executeWith(ExecutorService)}\n+   * @param executorService the service to use\n+   * @return this for method chaining\n+   */\n+  public ExpireSnapshotsAction executeDeleteWith(ExecutorService executorService) {\n+    this.deleteExecutorService = executorService;\n+    return this;\n+  }\n+\n+  /**\n+   * A specific snapshot to expire.\n+   * Identical to {@link org.apache.iceberg.ExpireSnapshots#expireSnapshotId(long)}\n+   * @param expireSnapshotId Id of the snapshot to expire\n+   * @return this for method chaining\n+   */\n+  public ExpireSnapshotsAction expireSnapshotId(long expireSnapshotId) {\n+    this.expireSnapshotIdValue = expireSnapshotId;\n+    return this;\n+  }\n+\n+  /**\n+   * Expire all snapshots older than a given timestamp.\n+   * Identical to {@link org.apache.iceberg.ExpireSnapshots#expireOlderThan(long)}\n+   * @param timestampMillis all snapshots before this time will be expired\n+   * @return this for method chaining\n+   */\n+  public ExpireSnapshotsAction expireOlderThan(long timestampMillis) {\n+    this.expireOlderThanValue = timestampMillis;\n+    return this;\n+  }\n+\n+  /**\n+   * Retain at least x snapshots when expiring\n+   * Identical to {@link org.apache.iceberg.ExpireSnapshots#retainLast(int)}\n+   * @param numSnapshots number of snapshots to leave\n+   * @return this for method chaining\n+   */\n+  public ExpireSnapshotsAction retainLast(int numSnapshots) {\n+    Preconditions.checkArgument(1 <= numSnapshots,\n+        \"Number of snapshots to retain must be at least 1, cannot be: %s\", numSnapshots);\n+    this.retainLastValue = numSnapshots;\n+    return this;\n+  }\n+\n+  /**\n+   * The Consumer used on files which have been determined to be expired. By default uses a filesystem delete.\n+   * Identical to {@link org.apache.iceberg.ExpireSnapshots#deleteWith(Consumer)}\n+   * @param newDeleteFunc Consumer which takes a path and deletes it\n+   * @return this for method chaining\n+   */\n+  public ExpireSnapshotsAction deleteWith(Consumer<String> newDeleteFunc) {\n+    this.deleteFunc = newDeleteFunc;\n+    return this;\n+  }\n+\n+  @Override\n+  public ExpireSnapshotsActionResult execute() {\n+    Dataset<Row> originalFiles = null;\n+    try {\n+      // Metadata before Expiration\n+      originalFiles = buildValidFileDF().persist();\n+      // Action to trigger persist\n+      originalFiles.count();\n+\n+      // Perform Expiration\n+      ExpireSnapshots expireSnaps = table.expireSnapshots().cleanExpiredFiles(false);\n+      if (expireSnapshotIdValue != null) {\n+        expireSnaps = expireSnaps.expireSnapshotId(expireSnapshotIdValue);\n+      }\n+      if (expireOlderThanValue != null) {\n+        expireSnaps = expireSnaps.expireOlderThan(expireOlderThanValue);\n+      }\n+      if (retainLastValue != null) {\n+        expireSnaps = expireSnaps.retainLast(retainLastValue);\n+      }\n+      expireSnaps.commit();\n+\n+      // Metadata after Expiration\n+      Dataset<Row> validFiles = buildValidFileDF();\n+      Dataset<Row> filesToDelete = originalFiles.except(validFiles);\n+\n+      ExpireSnapshotsActionResult result = deleteFiles(filesToDelete.toLocalIterator());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a50e3e8afe7dd209e0d17404654c7c00a547ceb1"}, "originalPosition": 173}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0MzkyNzA1", "url": "https://github.com/apache/iceberg/pull/1264#pullrequestreview-464392705", "createdAt": "2020-08-10T16:34:46Z", "commit": {"oid": "a50e3e8afe7dd209e0d17404654c7c00a547ceb1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxNjozNDo0NlrOG-WfGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxNjozNDo0NlrOG-WfGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODAzMzMwNw==", "bodyText": "Nit: extra newline added.", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r468033307", "createdAt": "2020-08-10T16:34:46Z", "author": {"login": "rdblue"}, "path": "spark/src/main/java/org/apache/iceberg/actions/BaseAction.java", "diffHunk": "@@ -19,8 +19,16 @@\n \n package org.apache.iceberg.actions;\n \n+import java.util.List;\n import org.apache.iceberg.MetadataTableType;\n import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.util.TableUtil;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Encoders;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SparkSession;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a50e3e8afe7dd209e0d17404654c7c00a547ceb1"}, "originalPosition": 13}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0Mzk1Mzk4", "url": "https://github.com/apache/iceberg/pull/1264#pullrequestreview-464395398", "createdAt": "2020-08-10T16:38:31Z", "commit": {"oid": "a50e3e8afe7dd209e0d17404654c7c00a547ceb1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxNjozODozMVrOG-Wnrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxNjozODozMVrOG-Wnrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODAzNTUwMw==", "bodyText": "Nit: formatting here is off. We always add a space between method args and curly braces.", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r468035503", "createdAt": "2020-08-10T16:38:31Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/util/TableUtil.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.util;\n+\n+import java.util.List;\n+import org.apache.iceberg.Snapshot;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+\n+public class TableUtil {\n+\n+  private TableUtil(){}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a50e3e8afe7dd209e0d17404654c7c00a547ceb1"}, "originalPosition": 31}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NDAxMjMw", "url": "https://github.com/apache/iceberg/pull/1264#pullrequestreview-464401230", "createdAt": "2020-08-10T16:46:29Z", "commit": {"oid": "a50e3e8afe7dd209e0d17404654c7c00a547ceb1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxNjo0NjoyOVrOG-W56w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxNjo0NjoyOVrOG-W56w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA0MDE3MQ==", "bodyText": "Why does this exclude other data files? I would expect this to use valid files and valid metadata files, as returned by the base action.", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r468040171", "createdAt": "2020-08-10T16:46:29Z", "author": {"login": "rdblue"}, "path": "spark/src/main/java/org/apache/iceberg/actions/ExpireSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Consumer;\n+import org.apache.iceberg.ExpireSnapshots;\n+import org.apache.iceberg.HasTableOperations;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.exceptions.NotFoundException;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.util.concurrent.MoreExecutors;\n+import org.apache.iceberg.util.Tasks;\n+import org.apache.spark.sql.Column;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SparkSession;\n+import org.apache.spark.sql.functions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * An action which performs the same operation as {@link org.apache.iceberg.ExpireSnapshots} but uses Spark\n+ * to to determine the delta in files between the pre and post-expiration table metadata. All of the same\n+ * restrictions of Remove Snapshots also apply to this action.\n+ * <p>\n+ * This implementation uses the metadata tables for the table being expired to list all Manifest and DataFiles. This\n+ * is made into a Dataframe which are anti-joined with the same list read after the expiration. This operation will\n+ * require a shuffle so parallelism can be controlled through spark.sql.shuffle.partitions. The expiration is done\n+ * locally using a direct call to RemoveSnapshots. The snapshot expiration will be fully committed before any deletes\n+ * are issued. Deletes are still performed locally after retrieving the results from the Spark executors.\n+ */\n+public class ExpireSnapshotsAction extends BaseAction<ExpireSnapshotsActionResult> {\n+  private static final Logger LOG = LoggerFactory.getLogger(ExpireSnapshotsAction.class);\n+\n+  private static final String DATA_FILE = \"Data File\";\n+  private static final String MANIFEST = \"Manifest\";\n+  private static final String MANIFEST_LIST = \"Manifest List\";\n+\n+  // Creates an executor service that runs each task in the thread that invokes execute/submit.\n+  private static final ExecutorService DEFAULT_DELETE_EXECUTOR_SERVICE = MoreExecutors.newDirectExecutorService();\n+\n+  private final SparkSession spark;\n+  private final Table table;\n+  private final TableOperations ops;\n+  private final Consumer<String> defaultDelete = new Consumer<String>() {\n+    @Override\n+    public void accept(String file) {\n+      ops.io().deleteFile(file);\n+    }\n+  };\n+\n+  private Long expireSnapshotIdValue = null;\n+  private Long expireOlderThanValue = null;\n+  private Integer retainLastValue = null;\n+  private Consumer<String> deleteFunc = defaultDelete;\n+  private ExecutorService deleteExecutorService = DEFAULT_DELETE_EXECUTOR_SERVICE;\n+\n+  ExpireSnapshotsAction(SparkSession spark, Table table) {\n+    this.spark = spark;\n+    this.table = table;\n+    this.ops = ((HasTableOperations) table).operations();\n+  }\n+\n+  @Override\n+  protected Table table() {\n+    return table;\n+  }\n+\n+  /**\n+   * An executor service used when deleting files. Only used during the local delete phase of this Spark action\n+   * Similar to {@link org.apache.iceberg.ExpireSnapshots#executeWith(ExecutorService)}\n+   * @param executorService the service to use\n+   * @return this for method chaining\n+   */\n+  public ExpireSnapshotsAction executeDeleteWith(ExecutorService executorService) {\n+    this.deleteExecutorService = executorService;\n+    return this;\n+  }\n+\n+  /**\n+   * A specific snapshot to expire.\n+   * Identical to {@link org.apache.iceberg.ExpireSnapshots#expireSnapshotId(long)}\n+   * @param expireSnapshotId Id of the snapshot to expire\n+   * @return this for method chaining\n+   */\n+  public ExpireSnapshotsAction expireSnapshotId(long expireSnapshotId) {\n+    this.expireSnapshotIdValue = expireSnapshotId;\n+    return this;\n+  }\n+\n+  /**\n+   * Expire all snapshots older than a given timestamp.\n+   * Identical to {@link org.apache.iceberg.ExpireSnapshots#expireOlderThan(long)}\n+   * @param timestampMillis all snapshots before this time will be expired\n+   * @return this for method chaining\n+   */\n+  public ExpireSnapshotsAction expireOlderThan(long timestampMillis) {\n+    this.expireOlderThanValue = timestampMillis;\n+    return this;\n+  }\n+\n+  /**\n+   * Retain at least x snapshots when expiring\n+   * Identical to {@link org.apache.iceberg.ExpireSnapshots#retainLast(int)}\n+   * @param numSnapshots number of snapshots to leave\n+   * @return this for method chaining\n+   */\n+  public ExpireSnapshotsAction retainLast(int numSnapshots) {\n+    Preconditions.checkArgument(1 <= numSnapshots,\n+        \"Number of snapshots to retain must be at least 1, cannot be: %s\", numSnapshots);\n+    this.retainLastValue = numSnapshots;\n+    return this;\n+  }\n+\n+  /**\n+   * The Consumer used on files which have been determined to be expired. By default uses a filesystem delete.\n+   * Identical to {@link org.apache.iceberg.ExpireSnapshots#deleteWith(Consumer)}\n+   * @param newDeleteFunc Consumer which takes a path and deletes it\n+   * @return this for method chaining\n+   */\n+  public ExpireSnapshotsAction deleteWith(Consumer<String> newDeleteFunc) {\n+    this.deleteFunc = newDeleteFunc;\n+    return this;\n+  }\n+\n+  @Override\n+  public ExpireSnapshotsActionResult execute() {\n+    Dataset<Row> originalFiles = null;\n+    try {\n+      // Metadata before Expiration\n+      originalFiles = buildValidFileDF().persist();\n+      // Action to trigger persist\n+      originalFiles.count();\n+\n+      // Perform Expiration\n+      ExpireSnapshots expireSnaps = table.expireSnapshots().cleanExpiredFiles(false);\n+      if (expireSnapshotIdValue != null) {\n+        expireSnaps = expireSnaps.expireSnapshotId(expireSnapshotIdValue);\n+      }\n+      if (expireOlderThanValue != null) {\n+        expireSnaps = expireSnaps.expireOlderThan(expireOlderThanValue);\n+      }\n+      if (retainLastValue != null) {\n+        expireSnaps = expireSnaps.retainLast(retainLastValue);\n+      }\n+      expireSnaps.commit();\n+\n+      // Metadata after Expiration\n+      Dataset<Row> validFiles = buildValidFileDF();\n+      Dataset<Row> filesToDelete = originalFiles.except(validFiles);\n+\n+      ExpireSnapshotsActionResult result = deleteFiles(filesToDelete.toLocalIterator());\n+      return result;\n+    } finally {\n+      if (originalFiles != null) {\n+        originalFiles.unpersist();\n+      }\n+    }\n+  }\n+\n+  private Dataset<Row> appendTypeString(Dataset<Row> ds, String type) {\n+    return ds.select(new Column(\"file_path\"), functions.lit(type).as(\"file_type\"));\n+  }\n+\n+  private Dataset<Row> buildValidFileDF() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a50e3e8afe7dd209e0d17404654c7c00a547ceb1"}, "originalPosition": 186}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NDA0NTM5", "url": "https://github.com/apache/iceberg/pull/1264#pullrequestreview-464404539", "createdAt": "2020-08-10T16:51:07Z", "commit": {"oid": "a50e3e8afe7dd209e0d17404654c7c00a547ceb1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxNjo1MTowN1rOG-XEEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxNjo1MTowN1rOG-XEEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA0Mjc2OQ==", "bodyText": "Nit: we usually add blank lines after if and loop control flow statements.", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r468042769", "createdAt": "2020-08-10T16:51:07Z", "author": {"login": "rdblue"}, "path": "spark/src/main/java/org/apache/iceberg/actions/ExpireSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Consumer;\n+import org.apache.iceberg.ExpireSnapshots;\n+import org.apache.iceberg.HasTableOperations;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.exceptions.NotFoundException;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.util.concurrent.MoreExecutors;\n+import org.apache.iceberg.util.Tasks;\n+import org.apache.spark.sql.Column;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SparkSession;\n+import org.apache.spark.sql.functions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * An action which performs the same operation as {@link org.apache.iceberg.ExpireSnapshots} but uses Spark\n+ * to to determine the delta in files between the pre and post-expiration table metadata. All of the same\n+ * restrictions of Remove Snapshots also apply to this action.\n+ * <p>\n+ * This implementation uses the metadata tables for the table being expired to list all Manifest and DataFiles. This\n+ * is made into a Dataframe which are anti-joined with the same list read after the expiration. This operation will\n+ * require a shuffle so parallelism can be controlled through spark.sql.shuffle.partitions. The expiration is done\n+ * locally using a direct call to RemoveSnapshots. The snapshot expiration will be fully committed before any deletes\n+ * are issued. Deletes are still performed locally after retrieving the results from the Spark executors.\n+ */\n+public class ExpireSnapshotsAction extends BaseAction<ExpireSnapshotsActionResult> {\n+  private static final Logger LOG = LoggerFactory.getLogger(ExpireSnapshotsAction.class);\n+\n+  private static final String DATA_FILE = \"Data File\";\n+  private static final String MANIFEST = \"Manifest\";\n+  private static final String MANIFEST_LIST = \"Manifest List\";\n+\n+  // Creates an executor service that runs each task in the thread that invokes execute/submit.\n+  private static final ExecutorService DEFAULT_DELETE_EXECUTOR_SERVICE = MoreExecutors.newDirectExecutorService();\n+\n+  private final SparkSession spark;\n+  private final Table table;\n+  private final TableOperations ops;\n+  private final Consumer<String> defaultDelete = new Consumer<String>() {\n+    @Override\n+    public void accept(String file) {\n+      ops.io().deleteFile(file);\n+    }\n+  };\n+\n+  private Long expireSnapshotIdValue = null;\n+  private Long expireOlderThanValue = null;\n+  private Integer retainLastValue = null;\n+  private Consumer<String> deleteFunc = defaultDelete;\n+  private ExecutorService deleteExecutorService = DEFAULT_DELETE_EXECUTOR_SERVICE;\n+\n+  ExpireSnapshotsAction(SparkSession spark, Table table) {\n+    this.spark = spark;\n+    this.table = table;\n+    this.ops = ((HasTableOperations) table).operations();\n+  }\n+\n+  @Override\n+  protected Table table() {\n+    return table;\n+  }\n+\n+  /**\n+   * An executor service used when deleting files. Only used during the local delete phase of this Spark action\n+   * Similar to {@link org.apache.iceberg.ExpireSnapshots#executeWith(ExecutorService)}\n+   * @param executorService the service to use\n+   * @return this for method chaining\n+   */\n+  public ExpireSnapshotsAction executeDeleteWith(ExecutorService executorService) {\n+    this.deleteExecutorService = executorService;\n+    return this;\n+  }\n+\n+  /**\n+   * A specific snapshot to expire.\n+   * Identical to {@link org.apache.iceberg.ExpireSnapshots#expireSnapshotId(long)}\n+   * @param expireSnapshotId Id of the snapshot to expire\n+   * @return this for method chaining\n+   */\n+  public ExpireSnapshotsAction expireSnapshotId(long expireSnapshotId) {\n+    this.expireSnapshotIdValue = expireSnapshotId;\n+    return this;\n+  }\n+\n+  /**\n+   * Expire all snapshots older than a given timestamp.\n+   * Identical to {@link org.apache.iceberg.ExpireSnapshots#expireOlderThan(long)}\n+   * @param timestampMillis all snapshots before this time will be expired\n+   * @return this for method chaining\n+   */\n+  public ExpireSnapshotsAction expireOlderThan(long timestampMillis) {\n+    this.expireOlderThanValue = timestampMillis;\n+    return this;\n+  }\n+\n+  /**\n+   * Retain at least x snapshots when expiring\n+   * Identical to {@link org.apache.iceberg.ExpireSnapshots#retainLast(int)}\n+   * @param numSnapshots number of snapshots to leave\n+   * @return this for method chaining\n+   */\n+  public ExpireSnapshotsAction retainLast(int numSnapshots) {\n+    Preconditions.checkArgument(1 <= numSnapshots,\n+        \"Number of snapshots to retain must be at least 1, cannot be: %s\", numSnapshots);\n+    this.retainLastValue = numSnapshots;\n+    return this;\n+  }\n+\n+  /**\n+   * The Consumer used on files which have been determined to be expired. By default uses a filesystem delete.\n+   * Identical to {@link org.apache.iceberg.ExpireSnapshots#deleteWith(Consumer)}\n+   * @param newDeleteFunc Consumer which takes a path and deletes it\n+   * @return this for method chaining\n+   */\n+  public ExpireSnapshotsAction deleteWith(Consumer<String> newDeleteFunc) {\n+    this.deleteFunc = newDeleteFunc;\n+    return this;\n+  }\n+\n+  @Override\n+  public ExpireSnapshotsActionResult execute() {\n+    Dataset<Row> originalFiles = null;\n+    try {\n+      // Metadata before Expiration\n+      originalFiles = buildValidFileDF().persist();\n+      // Action to trigger persist\n+      originalFiles.count();\n+\n+      // Perform Expiration\n+      ExpireSnapshots expireSnaps = table.expireSnapshots().cleanExpiredFiles(false);\n+      if (expireSnapshotIdValue != null) {\n+        expireSnaps = expireSnaps.expireSnapshotId(expireSnapshotIdValue);\n+      }\n+      if (expireOlderThanValue != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a50e3e8afe7dd209e0d17404654c7c00a547ceb1"}, "originalPosition": 161}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NDA5NTk3", "url": "https://github.com/apache/iceberg/pull/1264#pullrequestreview-464409597", "createdAt": "2020-08-10T16:57:44Z", "commit": {"oid": "a50e3e8afe7dd209e0d17404654c7c00a547ceb1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxNjo1Nzo0NFrOG-XT3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxNjo1Nzo0NFrOG-XT3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA0NjgxMw==", "bodyText": "Minor: We don't use get because it doesn't generally add any value. In most cases, the right thing to do is to use a more descriptive verb, like load or create. If there isn't a more descriptive verb because it is just accessing a member field, then we omit get. That's more readable and the convention in most other JVM languages.", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r468046813", "createdAt": "2020-08-10T16:57:44Z", "author": {"login": "rdblue"}, "path": "spark/src/main/java/org/apache/iceberg/actions/ExpireSnapshotsActionResult.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+public class ExpireSnapshotsActionResult {\n+\n+  private final Long dataFilesDeleted;\n+  private final Long manifestFilesDeleted;\n+  private final Long manifestListsDeleted;\n+\n+  public ExpireSnapshotsActionResult(Long dataFilesDeleted, Long manifestFilesDeleted, Long manifestListsDeleted) {\n+    this.dataFilesDeleted = dataFilesDeleted;\n+    this.manifestFilesDeleted = manifestFilesDeleted;\n+    this.manifestListsDeleted = manifestListsDeleted;\n+  }\n+\n+  public Long getDataFilesDeleted() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a50e3e8afe7dd209e0d17404654c7c00a547ceb1"}, "originalPosition": 34}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NDEyNDY5", "url": "https://github.com/apache/iceberg/pull/1264#pullrequestreview-464412469", "createdAt": "2020-08-10T17:01:34Z", "commit": {"oid": "a50e3e8afe7dd209e0d17404654c7c00a547ceb1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxNzowMTozNFrOG-Xchw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxNzowMTozNFrOG-Xchw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA0OTAzMQ==", "bodyText": "Should this be a util method?", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r468049031", "createdAt": "2020-08-10T17:01:34Z", "author": {"login": "rdblue"}, "path": "spark/src/test/java/org/apache/iceberg/actions/TestExpireSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,780 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.BaseTable;\n+import org.apache.iceberg.DataFile;\n+import org.apache.iceberg.DataFiles;\n+import org.apache.iceberg.PartitionSpec;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.Snapshot;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableProperties;\n+import org.apache.iceberg.hadoop.HadoopTables;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableSet;\n+import org.apache.iceberg.relocated.com.google.common.collect.Iterables;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.relocated.com.google.common.collect.Sets;\n+import org.apache.iceberg.spark.SparkTestBase;\n+import org.apache.iceberg.spark.source.ThreeColumnRecord;\n+import org.apache.iceberg.types.Types;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import static org.apache.iceberg.types.Types.NestedField.optional;\n+\n+public abstract class TestExpireSnapshotsAction extends SparkTestBase {\n+\n+  private static final HadoopTables TABLES = new HadoopTables(new Configuration());\n+  private static final Schema SCHEMA = new Schema(\n+      optional(1, \"c1\", Types.IntegerType.get()),\n+      optional(2, \"c2\", Types.StringType.get()),\n+      optional(3, \"c3\", Types.StringType.get())\n+  );\n+\n+  private static final PartitionSpec SPEC = PartitionSpec.builderFor(SCHEMA).identity(\"c1\").build();\n+\n+  private static final List<ThreeColumnRecord> RECORDS = Lists.newArrayList(new ThreeColumnRecord(1, \"AAAA\", \"AAAA\"));\n+\n+  static final DataFile FILE_A = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-a.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=0\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+  static final DataFile FILE_B = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-b.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=1\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+  static final DataFile FILE_C = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-c.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=2\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+  static final DataFile FILE_D = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-d.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=3\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+\n+  @Rule\n+  public TemporaryFolder temp = new TemporaryFolder();\n+\n+  private File tableDir;\n+  private String tableLocation;\n+  private Table table;\n+\n+  @Before\n+  public void setupTableLocation() throws Exception {\n+    this.tableDir = temp.newFolder();\n+    this.tableLocation = tableDir.toURI().toString();\n+    this.table = TABLES.create(SCHEMA, SPEC, Maps.newHashMap(), tableLocation);\n+  }\n+\n+  private Dataset<Row> buildDF(List<ThreeColumnRecord> records) {\n+    return spark.createDataFrame(records, ThreeColumnRecord.class).coalesce(1);\n+  }\n+\n+  private void writeDF(Dataset<Row> df, String mode) {\n+    df.select(\"c1\", \"c2\", \"c3\")\n+        .write()\n+        .format(\"iceberg\")\n+        .mode(mode)\n+        .save(tableLocation);\n+  }\n+\n+  private void checkExpirationResults(Long expectedDatafiles, Long expectedManifestsDeleted,\n+      Long expectedManifestListsDeleted, ExpireSnapshotsActionResult results) {\n+\n+    Assert.assertEquals(\"Incorrect number of manifest files deleted\",\n+        expectedManifestsDeleted, results.getManifestFilesDeleted());\n+    Assert.assertEquals(\"Incorrect number of datafiles deleted\",\n+        expectedDatafiles, results.getDataFilesDeleted());\n+    Assert.assertEquals(\"Incorrect number of manifest lists deleted\",\n+        expectedManifestListsDeleted, results.getManifestListsDeleted());\n+  }\n+\n+  @Test\n+  public void testFilesCleaned() throws Exception {\n+    Dataset<Row> df = buildDF(RECORDS);\n+\n+    writeDF(df, \"append\");\n+\n+    List<Path> expiredDataFiles = Files\n+        .list(tableDir.toPath().resolve(\"data\").resolve(\"c1=1\"))\n+        .collect(Collectors.toList());\n+\n+    Assert.assertEquals(\"There should be a data file to delete but there was none.\",\n+        2, expiredDataFiles.size());\n+\n+    writeDF(df, \"overwrite\");\n+    writeDF(df, \"append\");\n+\n+    long end = System.currentTimeMillis();\n+    while (end <= table.currentSnapshot().timestampMillis()) {\n+      end = System.currentTimeMillis();\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a50e3e8afe7dd209e0d17404654c7c00a547ceb1"}, "originalPosition": 158}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NDE2Mjgz", "url": "https://github.com/apache/iceberg/pull/1264#pullrequestreview-464416283", "createdAt": "2020-08-10T17:07:05Z", "commit": {"oid": "a50e3e8afe7dd209e0d17404654c7c00a547ceb1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxNzowNzowNVrOG-XnrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxNzowNzowNVrOG-XnrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA1MTg4NQ==", "bodyText": "A couple of things on these tests:\n\nThe ported tests don't validate the action result in many cases. Can you add those checks?\nThe new tests use Spark to write data, which I don't think is necessary. Using Spark to write data makes the tests harder to maintain because you have to go list files to find the ones you want, rather than constructing commits directly with known file paths (e.g., FILE_A, FILE_B, etc.).\nI find tests that use ThreeColumnRecord and values like AAAA to be a bit hard to read, since there isn't much difference between AAAA and AAAAAA or between c2 and c3. If you remove Spark writes, then you could avoid needing this.", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r468051885", "createdAt": "2020-08-10T17:07:05Z", "author": {"login": "rdblue"}, "path": "spark/src/test/java/org/apache/iceberg/actions/TestExpireSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,780 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.BaseTable;\n+import org.apache.iceberg.DataFile;\n+import org.apache.iceberg.DataFiles;\n+import org.apache.iceberg.PartitionSpec;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.Snapshot;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableProperties;\n+import org.apache.iceberg.hadoop.HadoopTables;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableSet;\n+import org.apache.iceberg.relocated.com.google.common.collect.Iterables;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.relocated.com.google.common.collect.Sets;\n+import org.apache.iceberg.spark.SparkTestBase;\n+import org.apache.iceberg.spark.source.ThreeColumnRecord;\n+import org.apache.iceberg.types.Types;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import static org.apache.iceberg.types.Types.NestedField.optional;\n+\n+public abstract class TestExpireSnapshotsAction extends SparkTestBase {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a50e3e8afe7dd209e0d17404654c7c00a547ceb1"}, "originalPosition": 64}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NDE2NjM1", "url": "https://github.com/apache/iceberg/pull/1264#pullrequestreview-464416635", "createdAt": "2020-08-10T17:07:36Z", "commit": {"oid": "a50e3e8afe7dd209e0d17404654c7c00a547ceb1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxNzowNzozNlrOG-Xong==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxNzowNzozNlrOG-Xong==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA1MjEyNg==", "bodyText": "The table instance is used for the expire commit, right? If that's the case, then there should be no need to refresh here.", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r468052126", "createdAt": "2020-08-10T17:07:36Z", "author": {"login": "rdblue"}, "path": "spark/src/test/java/org/apache/iceberg/actions/TestExpireSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,780 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.BaseTable;\n+import org.apache.iceberg.DataFile;\n+import org.apache.iceberg.DataFiles;\n+import org.apache.iceberg.PartitionSpec;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.Snapshot;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableProperties;\n+import org.apache.iceberg.hadoop.HadoopTables;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableSet;\n+import org.apache.iceberg.relocated.com.google.common.collect.Iterables;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.relocated.com.google.common.collect.Sets;\n+import org.apache.iceberg.spark.SparkTestBase;\n+import org.apache.iceberg.spark.source.ThreeColumnRecord;\n+import org.apache.iceberg.types.Types;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import static org.apache.iceberg.types.Types.NestedField.optional;\n+\n+public abstract class TestExpireSnapshotsAction extends SparkTestBase {\n+\n+  private static final HadoopTables TABLES = new HadoopTables(new Configuration());\n+  private static final Schema SCHEMA = new Schema(\n+      optional(1, \"c1\", Types.IntegerType.get()),\n+      optional(2, \"c2\", Types.StringType.get()),\n+      optional(3, \"c3\", Types.StringType.get())\n+  );\n+\n+  private static final PartitionSpec SPEC = PartitionSpec.builderFor(SCHEMA).identity(\"c1\").build();\n+\n+  private static final List<ThreeColumnRecord> RECORDS = Lists.newArrayList(new ThreeColumnRecord(1, \"AAAA\", \"AAAA\"));\n+\n+  static final DataFile FILE_A = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-a.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=0\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+  static final DataFile FILE_B = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-b.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=1\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+  static final DataFile FILE_C = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-c.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=2\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+  static final DataFile FILE_D = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-d.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"c1=3\") // easy way to set partition data for now\n+      .withRecordCount(1)\n+      .build();\n+\n+  @Rule\n+  public TemporaryFolder temp = new TemporaryFolder();\n+\n+  private File tableDir;\n+  private String tableLocation;\n+  private Table table;\n+\n+  @Before\n+  public void setupTableLocation() throws Exception {\n+    this.tableDir = temp.newFolder();\n+    this.tableLocation = tableDir.toURI().toString();\n+    this.table = TABLES.create(SCHEMA, SPEC, Maps.newHashMap(), tableLocation);\n+  }\n+\n+  private Dataset<Row> buildDF(List<ThreeColumnRecord> records) {\n+    return spark.createDataFrame(records, ThreeColumnRecord.class).coalesce(1);\n+  }\n+\n+  private void writeDF(Dataset<Row> df, String mode) {\n+    df.select(\"c1\", \"c2\", \"c3\")\n+        .write()\n+        .format(\"iceberg\")\n+        .mode(mode)\n+        .save(tableLocation);\n+  }\n+\n+  private void checkExpirationResults(Long expectedDatafiles, Long expectedManifestsDeleted,\n+      Long expectedManifestListsDeleted, ExpireSnapshotsActionResult results) {\n+\n+    Assert.assertEquals(\"Incorrect number of manifest files deleted\",\n+        expectedManifestsDeleted, results.getManifestFilesDeleted());\n+    Assert.assertEquals(\"Incorrect number of datafiles deleted\",\n+        expectedDatafiles, results.getDataFilesDeleted());\n+    Assert.assertEquals(\"Incorrect number of manifest lists deleted\",\n+        expectedManifestListsDeleted, results.getManifestListsDeleted());\n+  }\n+\n+  @Test\n+  public void testFilesCleaned() throws Exception {\n+    Dataset<Row> df = buildDF(RECORDS);\n+\n+    writeDF(df, \"append\");\n+\n+    List<Path> expiredDataFiles = Files\n+        .list(tableDir.toPath().resolve(\"data\").resolve(\"c1=1\"))\n+        .collect(Collectors.toList());\n+\n+    Assert.assertEquals(\"There should be a data file to delete but there was none.\",\n+        2, expiredDataFiles.size());\n+\n+    writeDF(df, \"overwrite\");\n+    writeDF(df, \"append\");\n+\n+    long end = System.currentTimeMillis();\n+    while (end <= table.currentSnapshot().timestampMillis()) {\n+      end = System.currentTimeMillis();\n+    }\n+\n+    ExpireSnapshotsActionResult results =\n+        Actions.forTable(table).expireSnapshots().expireOlderThan(end).execute();\n+\n+    table.refresh();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a50e3e8afe7dd209e0d17404654c7c00a547ceb1"}, "originalPosition": 163}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NDM0OTQ0", "url": "https://github.com/apache/iceberg/pull/1264#pullrequestreview-464434944", "createdAt": "2020-08-10T17:34:19Z", "commit": {"oid": "a50e3e8afe7dd209e0d17404654c7c00a547ceb1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxNzozNDoxOVrOG-YiMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxNzozNDoxOVrOG-YiMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA2Njg2Ng==", "bodyText": "One more question: it seems passing any executor service will trigger runParallel in Tasks.\nIn turn, that will call  for (final I item : items) that I assume would load all files on the driver?", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r468066866", "createdAt": "2020-08-10T17:34:19Z", "author": {"login": "aokolnychyi"}, "path": "spark/src/main/java/org/apache/iceberg/actions/ExpireSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.actions;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Consumer;\n+import org.apache.iceberg.ExpireSnapshots;\n+import org.apache.iceberg.HasTableOperations;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.exceptions.NotFoundException;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.util.concurrent.MoreExecutors;\n+import org.apache.iceberg.util.Tasks;\n+import org.apache.spark.sql.Column;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SparkSession;\n+import org.apache.spark.sql.functions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * An action which performs the same operation as {@link org.apache.iceberg.ExpireSnapshots} but uses Spark\n+ * to to determine the delta in files between the pre and post-expiration table metadata. All of the same\n+ * restrictions of Remove Snapshots also apply to this action.\n+ * <p>\n+ * This implementation uses the metadata tables for the table being expired to list all Manifest and DataFiles. This\n+ * is made into a Dataframe which are anti-joined with the same list read after the expiration. This operation will\n+ * require a shuffle so parallelism can be controlled through spark.sql.shuffle.partitions. The expiration is done\n+ * locally using a direct call to RemoveSnapshots. The snapshot expiration will be fully committed before any deletes\n+ * are issued. Deletes are still performed locally after retrieving the results from the Spark executors.\n+ */\n+public class ExpireSnapshotsAction extends BaseAction<ExpireSnapshotsActionResult> {\n+  private static final Logger LOG = LoggerFactory.getLogger(ExpireSnapshotsAction.class);\n+\n+  private static final String DATA_FILE = \"Data File\";\n+  private static final String MANIFEST = \"Manifest\";\n+  private static final String MANIFEST_LIST = \"Manifest List\";\n+\n+  // Creates an executor service that runs each task in the thread that invokes execute/submit.\n+  private static final ExecutorService DEFAULT_DELETE_EXECUTOR_SERVICE = MoreExecutors.newDirectExecutorService();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a50e3e8afe7dd209e0d17404654c7c00a547ceb1"}, "originalPosition": 61}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1732bc27804666d2a7dc7907331e2d5000a66a98", "author": {"user": {"login": "RussellSpitzer", "name": "Russell Spitzer"}}, "url": "https://github.com/apache/iceberg/commit/1732bc27804666d2a7dc7907331e2d5000a66a98", "committedDate": "2020-08-10T23:03:59Z", "message": "Reviewer Comments\n\nRefactoring of Tests, All tests use only table.operations no Spark Writes\nAll tests now check file deletions\nRenaming of class methods to fit style\nRemoval of TableUtils, Functions moved back into BaseAction\nExpireSnapshotsAction defaults to single threaded deleter"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0Njc1NzI1", "url": "https://github.com/apache/iceberg/pull/1264#pullrequestreview-464675725", "createdAt": "2020-08-11T00:40:05Z", "commit": {"oid": "1732bc27804666d2a7dc7907331e2d5000a66a98"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwMDo0MDowNVrOG-kaeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwMDo0MDowNVrOG-kaeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI2MTQ5Nw==", "bodyText": "I think this should be private. We don't want actions using it directly, do we?", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r468261497", "createdAt": "2020-08-11T00:40:05Z", "author": {"login": "rdblue"}, "path": "spark/src/main/java/org/apache/iceberg/actions/BaseAction.java", "diffHunk": "@@ -41,4 +50,66 @@ protected String metadataTableName(MetadataTableType type) {\n       return tableName + \".\" + type;\n     }\n   }\n+\n+  /**\n+   * Returns all the path locations of all Manifest Lists for a given table\n+   * @param table the table\n+   * @return the paths of the Manifest Lists\n+   */\n+  protected List<String> getManifestListPaths(Table table) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1732bc27804666d2a7dc7907331e2d5000a66a98"}, "originalPosition": 28}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0Njc1OTAw", "url": "https://github.com/apache/iceberg/pull/1264#pullrequestreview-464675900", "createdAt": "2020-08-11T00:40:41Z", "commit": {"oid": "1732bc27804666d2a7dc7907331e2d5000a66a98"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwMDo0MDo0MlrOG-kbXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwMDo0MDo0MlrOG-kbXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI2MTcyNg==", "bodyText": "Same here. Since we aren't making these common utility methods, we should keep them private so we aren't committing to support them later on.", "url": "https://github.com/apache/iceberg/pull/1264#discussion_r468261726", "createdAt": "2020-08-11T00:40:42Z", "author": {"login": "rdblue"}, "path": "spark/src/main/java/org/apache/iceberg/actions/BaseAction.java", "diffHunk": "@@ -41,4 +50,66 @@ protected String metadataTableName(MetadataTableType type) {\n       return tableName + \".\" + type;\n     }\n   }\n+\n+  /**\n+   * Returns all the path locations of all Manifest Lists for a given table\n+   * @param table the table\n+   * @return the paths of the Manifest Lists\n+   */\n+  protected List<String> getManifestListPaths(Table table) {\n+    List<String> manifestLists = Lists.newArrayList();\n+    for (Snapshot snapshot : table.snapshots()) {\n+      String manifestListLocation = snapshot.manifestListLocation();\n+      if (manifestListLocation != null) {\n+        manifestLists.add(manifestListLocation);\n+      }\n+    }\n+    return manifestLists;\n+  }\n+\n+  /**\n+   * Returns all Metadata file paths which may not be in the current metadata. Specifically\n+   * this includes \"version-hint\" files as well as entries in metadata.previousFiles.\n+   * @param ops TableOperations for the table we will be getting paths from\n+   * @return a list of paths to metadata files\n+   */\n+  protected List<String> getOtherMetadataFilePaths(TableOperations ops) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1732bc27804666d2a7dc7907331e2d5000a66a98"}, "originalPosition": 45}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4353, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}