{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQyODU4NDQy", "number": 1156, "title": "Add Spark 3 SQL tests", "bodyText": "This adds tests for Spark SQL operations.\nThe tests primarily focus on the way that query info is passed to Iceberg. This is not intended to be exhaustive for either ways to express changes as SQL or for what Iceberg supports. For example, this only tests updating an int column to long to validate that TableChange.UpdateColumnType is handled.\nThese tests have exposed a few bugs:\n\nThe Spark session catalog doesn't support metadata tables because Spark validates the namespace independent of the catalog. We could add a suffix convention to make the metadata tables accessible, since many people will want to use this catalog. (The session catalog can delegate to Spark's v1 catalog, so this catalog can load any existing table as well as Iceberg from the same Hive namespace.)\nSpark has a bug (apache/spark#28993) in determining when an overwrite should be static or dynamic. If Spark's number of static values in an INSERT OVERWRITE is the same as the number of partition columns (identity), then Spark will use a static overwrite. This doesn't account for hidden partition columns. This should be fixed in Spark 3.0.1 and is a Spark bug, so I the test for this case is disabled for now.\nSpark passes the catalog name in the identifier passed to renameTable. It looks like there is no validation on the to identifier.\nThe replace table transaction discarded the old table state. This has been fixed so table history is kept.", "createdAt": "2020-07-01T18:04:32Z", "url": "https://github.com/apache/iceberg/pull/1156", "merged": true, "mergeCommit": {"oid": "115a1450c0e62edd835d0dd77a6513ff3717479c"}, "closed": true, "closedAt": "2020-07-08T23:03:51Z", "author": {"login": "rdblue"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcwwncBABqjM1MDQyMDUxOTM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABczBZNyAFqTQ0NTE0NDg4OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ce452ee5fe5c903fe08680cf0c97026778736e62", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/ce452ee5fe5c903fe08680cf0c97026778736e62", "committedDate": "2020-07-01T17:57:31Z", "message": "Spark: Add tests for create and alter table."}, "afterCommit": {"oid": "d9da5e4c57d49dc590cd3b131941feec1e2183f4", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/d9da5e4c57d49dc590cd3b131941feec1e2183f4", "committedDate": "2020-07-01T20:52:46Z", "message": "Spark: Add tests for create and alter table."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "09ceccde1e9249ed64793e197177b60ae8597634", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/09ceccde1e9249ed64793e197177b60ae8597634", "committedDate": "2020-07-01T22:47:09Z", "message": "Add write tests."}, "afterCommit": {"oid": "b88ec468f67a4edfc0e5532c7af68e5a621c37f2", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/b88ec468f67a4edfc0e5532c7af68e5a621c37f2", "committedDate": "2020-07-01T22:51:26Z", "message": "Add write tests."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a2dafe1da7805681593c7f5fa2c673c6a3adaf11", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/a2dafe1da7805681593c7f5fa2c673c6a3adaf11", "committedDate": "2020-07-01T23:48:43Z", "message": "Spark: Add tests for create, alter, insert, and select."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d2bc1da8117de6923793ed456f55c3f205a289f4", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/d2bc1da8117de6923793ed456f55c3f205a289f4", "committedDate": "2020-07-02T00:33:12Z", "message": "Add CTAS tests."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "061a12457bc5028920f27a1266282aa61de6d39f", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/061a12457bc5028920f27a1266282aa61de6d39f", "committedDate": "2020-07-01T22:53:18Z", "message": "Un-ignore tests now that #1147 was merged."}, "afterCommit": {"oid": "d2bc1da8117de6923793ed456f55c3f205a289f4", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/d2bc1da8117de6923793ed456f55c3f205a289f4", "committedDate": "2020-07-02T00:33:12Z", "message": "Add CTAS tests."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5c9b92954be103e71d2d965bdf8a29e68e9ed10e", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/5c9b92954be103e71d2d965bdf8a29e68e9ed10e", "committedDate": "2020-07-02T00:45:35Z", "message": "Fix checkstyle and Hive replace table tests."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxMjgwMzMy", "url": "https://github.com/apache/iceberg/pull/1156#pullrequestreview-441280332", "createdAt": "2020-07-02T00:48:09Z", "commit": {"oid": "d2bc1da8117de6923793ed456f55c3f205a289f4"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQwMDo0ODowOVrOGr5wnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQwMToxODo0MlrOGr6OqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY4ODI4NA==", "bodyText": "You can probably take this out of the if...else since it's repeated and has to be done on either case.", "url": "https://github.com/apache/iceberg/pull/1156#discussion_r448688284", "createdAt": "2020-07-02T00:48:09Z", "author": {"login": "edgarRd"}, "path": "core/src/main/java/org/apache/iceberg/BaseMetastoreCatalog.java", "diffHunk": "@@ -110,9 +110,17 @@ public Transaction newReplaceTableTransaction(\n       throw new NoSuchTableException(\"No such table: \" + identifier);\n     }\n \n-    String baseLocation = location != null ? location : defaultWarehouseLocation(identifier);\n-    Map<String, String> tableProperties = properties != null ? properties : Maps.newHashMap();\n-    TableMetadata metadata = TableMetadata.newTableMetadata(schema, spec, baseLocation, tableProperties);\n+    TableMetadata metadata;\n+    if (ops.current() != null) {\n+      String baseLocation = location != null ? location : ops.current().location();\n+      Map<String, String> tableProperties = properties != null ? properties : Maps.newHashMap();\n+      metadata = ops.current().buildReplacement(schema, spec, baseLocation, tableProperties);\n+    } else {\n+      String baseLocation = location != null ? location : defaultWarehouseLocation(identifier);\n+      Map<String, String> tableProperties = properties != null ? properties : Maps.newHashMap();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2bc1da8117de6923793ed456f55c3f205a289f4"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY4OTQyNw==", "bodyText": "Is the catalog case sensitive? If not, equalsIgnoreCase may need to be used.", "url": "https://github.com/apache/iceberg/pull/1156#discussion_r448689427", "createdAt": "2020-07-02T00:52:35Z", "author": {"login": "edgarRd"}, "path": "hive/src/main/java/org/apache/iceberg/hive/HiveCatalog.java", "diffHunk": "@@ -347,6 +349,20 @@ protected boolean isValidIdentifier(TableIdentifier tableIdentifier) {\n     return tableIdentifier.namespace().levels().length == 1;\n   }\n \n+  private TableIdentifier removeCatalogName(TableIdentifier to) {\n+    if (isValidIdentifier(to)) {\n+      return to;\n+    }\n+\n+    // check if the identifier includes the catalog name and remove it\n+    if (to.namespace().levels().length == 2 && name().equals(to.namespace().level(0))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2bc1da8117de6923793ed456f55c3f205a289f4"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY5MTYyMA==", "bodyText": "Is any PartitionSpecwith 0 fields the unpartitioned spec or should it match a certain spec (like in the removed version)? Seems like the equals method takes fields and specId into the contract.", "url": "https://github.com/apache/iceberg/pull/1156#discussion_r448691620", "createdAt": "2020-07-02T01:00:52Z", "author": {"login": "edgarRd"}, "path": "hive/src/test/java/org/apache/iceberg/hive/HiveCreateReplaceTableTest.java", "diffHunk": "@@ -155,7 +155,7 @@ public void testReplaceTableTxn() {\n     txn.commitTransaction();\n \n     Table table = catalog.loadTable(TABLE_IDENTIFIER);\n-    Assert.assertEquals(\"Partition spec should match\", PartitionSpec.unpartitioned(), table.spec());\n+    Assert.assertEquals(\"Partition spec should be unpartitioned\", 0, table.spec().fields().size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c9b92954be103e71d2d965bdf8a29e68e9ed10e"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY5NTk3Ng==", "bodyText": "Should we add tests for the other file formats?", "url": "https://github.com/apache/iceberg/pull/1156#discussion_r448695976", "createdAt": "2020-07-02T01:18:42Z", "author": {"login": "edgarRd"}, "path": "spark3/src/test/java/org/apache/iceberg/spark/sql/TestCreateTable.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.sql;\n+\n+import java.io.File;\n+import java.util.Map;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.PartitionSpec;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableProperties;\n+import org.apache.iceberg.hadoop.HadoopCatalog;\n+import org.apache.iceberg.spark.SparkCatalogTestBase;\n+import org.apache.iceberg.types.Types;\n+import org.apache.iceberg.types.Types.NestedField;\n+import org.apache.iceberg.types.Types.StructType;\n+import org.apache.spark.sql.connector.catalog.TableCatalog;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Assume;\n+import org.junit.Test;\n+\n+public class TestCreateTable extends SparkCatalogTestBase {\n+  public TestCreateTable(String catalogName, String implementation, Map<String, String> config) {\n+    super(catalogName, implementation, config);\n+  }\n+\n+  @After\n+  public void dropTestTable() {\n+    sql(\"DROP TABLE IF EXISTS %s\", tableName);\n+  }\n+\n+  @Test\n+  public void testCreateTable() {\n+    Assert.assertFalse(\"Table should not already exist\", validationCatalog.tableExists(tableIdent));\n+\n+    sql(\"CREATE TABLE %s (id BIGINT NOT NULL, data STRING) USING iceberg\", tableName);\n+\n+    Table table = validationCatalog.loadTable(tableIdent);\n+    Assert.assertNotNull(\"Should load the new table\", table);\n+\n+    StructType expectedSchema = StructType.of(\n+        NestedField.required(1, \"id\", Types.LongType.get()),\n+        NestedField.optional(2, \"data\", Types.StringType.get()));\n+    Assert.assertEquals(\"Should have the expected schema\", expectedSchema, table.schema().asStruct());\n+    Assert.assertEquals(\"Should not be partitioned\", 0, table.spec().fields().size());\n+    Assert.assertNull(\"Should not have the default format set\",\n+        table.properties().get(TableProperties.DEFAULT_FILE_FORMAT));\n+  }\n+\n+  @Test\n+  public void testCreateTableUsingParquet() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c9b92954be103e71d2d965bdf8a29e68e9ed10e"}, "originalPosition": 69}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "66b7904c769208e87470a4e2a0ca78200d7344d8", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/66b7904c769208e87470a4e2a0ca78200d7344d8", "committedDate": "2020-07-03T00:06:20Z", "message": "Ensure the default database is created."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "06c137eb2364bb53394ac99bd96bcd54a5f40f9c", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/06c137eb2364bb53394ac99bd96bcd54a5f40f9c", "committedDate": "2020-07-03T00:17:34Z", "message": "Add tests for DataFrameWriterV2 CTAS and RTAS."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "20e524752f62dfa5e9d375eee8d08804a591f809", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/20e524752f62dfa5e9d375eee8d08804a591f809", "committedDate": "2020-07-03T00:32:56Z", "message": "Add DELETE FROM tests."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5414590e56b325c3dc5051593de15cc383280fa1", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/5414590e56b325c3dc5051593de15cc383280fa1", "committedDate": "2020-07-03T00:39:20Z", "message": "Fix review comments."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b34455e58ac55c76c0a5283265d1aa8351a26d01", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/b34455e58ac55c76c0a5283265d1aa8351a26d01", "committedDate": "2020-07-03T00:58:04Z", "message": "Fix checkstyle."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzMjgyMjEx", "url": "https://github.com/apache/iceberg/pull/1156#pullrequestreview-443282211", "createdAt": "2020-07-06T17:39:34Z", "commit": {"oid": "b34455e58ac55c76c0a5283265d1aa8351a26d01"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "58a9eb5672d2c807bf3b6bda61889ccc5a07428b", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/58a9eb5672d2c807bf3b6bda61889ccc5a07428b", "committedDate": "2020-07-07T18:15:17Z", "message": "Remove work-around for SPARK-32168."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1MDA2NzQ1", "url": "https://github.com/apache/iceberg/pull/1156#pullrequestreview-445006745", "createdAt": "2020-07-08T18:01:15Z", "commit": {"oid": "58a9eb5672d2c807bf3b6bda61889ccc5a07428b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxODowMToxNVrOGuzZOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxODowMToxNVrOGuzZOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTcyOTcyMw==", "bodyText": "This behavior is fixed in #1183. If this goes in first, I'll add the fix to that PR before merging.", "url": "https://github.com/apache/iceberg/pull/1156#discussion_r451729723", "createdAt": "2020-07-08T18:01:15Z", "author": {"login": "rdblue"}, "path": "spark3/src/test/java/org/apache/iceberg/spark/sql/TestCreateTableAsSelect.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.sql;\n+\n+import java.util.Map;\n+import org.apache.iceberg.PartitionSpec;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.relocated.com.google.common.collect.Iterables;\n+import org.apache.iceberg.spark.SparkCatalogTestBase;\n+import org.apache.iceberg.types.Types;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import static org.apache.spark.sql.functions.col;\n+import static org.apache.spark.sql.functions.lit;\n+import static org.apache.spark.sql.functions.when;\n+\n+public class TestCreateTableAsSelect extends SparkCatalogTestBase {\n+\n+  private final String sourceName;\n+\n+  public TestCreateTableAsSelect(String catalogName, String implementation, Map<String, String> config) {\n+    super(catalogName, implementation, config);\n+    this.sourceName = tableName(\"source\");\n+\n+    sql(\"CREATE TABLE IF NOT EXISTS %s (id bigint NOT NULL, data string) \" +\n+        \"USING iceberg PARTITIONED BY (truncate(id, 3))\", sourceName);\n+    sql(\"INSERT INTO %s VALUES (1, 'a'), (2, 'b'), (3, 'c')\", sourceName);\n+  }\n+\n+  @After\n+  public void removeTables() {\n+    sql(\"DROP TABLE IF EXISTS %s\", tableName);\n+  }\n+\n+  @Test\n+  public void testUnpartitionedCTAS() {\n+    sql(\"CREATE TABLE %s USING iceberg AS SELECT * FROM %s\", tableName, sourceName);\n+\n+    Schema expectedSchema = new Schema(\n+        Types.NestedField.optional(1, \"id\", Types.LongType.get()),\n+        Types.NestedField.optional(2, \"data\", Types.StringType.get())\n+    );\n+\n+    Table ctasTable = validationCatalog.loadTable(tableIdent);\n+\n+    Assert.assertEquals(\"Should have expected nullable schema\",\n+        expectedSchema.asStruct(), ctasTable.schema().asStruct());\n+    Assert.assertEquals(\"Should be an unpartitioned table\",\n+        0, ctasTable.spec().fields().size());\n+    assertEquals(\"Should have rows matching the source table\",\n+        sql(\"SELECT * FROM %s ORDER BY id\", sourceName),\n+        sql(\"SELECT * FROM %s ORDER BY id\", tableName));\n+  }\n+\n+  @Test\n+  public void testPartitionedCTAS() {\n+    sql(\"CREATE TABLE %s USING iceberg PARTITIONED BY (id) AS SELECT * FROM %s ORDER BY id\", tableName, sourceName);\n+\n+    Schema expectedSchema = new Schema(\n+        Types.NestedField.optional(1, \"id\", Types.LongType.get()),\n+        Types.NestedField.optional(2, \"data\", Types.StringType.get())\n+    );\n+\n+    PartitionSpec expectedSpec = PartitionSpec.builderFor(expectedSchema)\n+        .identity(\"id\")\n+        .build();\n+\n+    Table ctasTable = validationCatalog.loadTable(tableIdent);\n+\n+    Assert.assertEquals(\"Should have expected nullable schema\",\n+        expectedSchema.asStruct(), ctasTable.schema().asStruct());\n+    Assert.assertEquals(\"Should be partitioned by id\",\n+        expectedSpec, ctasTable.spec());\n+    assertEquals(\"Should have rows matching the source table\",\n+        sql(\"SELECT * FROM %s ORDER BY id\", sourceName),\n+        sql(\"SELECT * FROM %s ORDER BY id\", tableName));\n+  }\n+\n+  @Test\n+  public void testRTAS() {\n+    sql(\"CREATE TABLE %s USING iceberg AS SELECT * FROM %s\", tableName, sourceName);\n+\n+    assertEquals(\"Should have rows matching the source table\",\n+        sql(\"SELECT * FROM %s ORDER BY id\", sourceName),\n+        sql(\"SELECT * FROM %s ORDER BY id\", tableName));\n+\n+    sql(\"REPLACE TABLE %s USING iceberg PARTITIONED BY (part) AS \" +\n+        \"SELECT id, data, CASE WHEN (id %% 2) = 0 THEN 'even' ELSE 'odd' END AS part \" +\n+        \"FROM %s ORDER BY 3, 1\", tableName, sourceName);\n+\n+    // spark_catalog does not use an atomic replace, so the table history and old spec is dropped\n+    // the other catalogs do use atomic replace, so the spec id is incremented\n+    boolean isAtomic = !\"spark_catalog\".equals(catalogName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58a9eb5672d2c807bf3b6bda61889ccc5a07428b"}, "originalPosition": 113}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1MTQ0ODg4", "url": "https://github.com/apache/iceberg/pull/1156#pullrequestreview-445144888", "createdAt": "2020-07-08T21:33:40Z", "commit": {"oid": "58a9eb5672d2c807bf3b6bda61889ccc5a07428b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQyMTozMzo0MFrOGu6ATA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQyMTozMzo0MFrOGu6ATA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgzODAyOA==", "bodyText": "I'm not clear on whether this really should be the right behavior.  Basically we're saying that a replace table will keep the existing location (as opposed to using defaults).  I suspect we don't have create or replace with location semantics, but this is making some assumptions that a replacement is somehow the same as the old.  If we were to go with id based pathing convention, this wouldn't work.\nI don't think this is an issue at this point, but it might make sense to push this down to the location provider.", "url": "https://github.com/apache/iceberg/pull/1156#discussion_r451838028", "createdAt": "2020-07-08T21:33:40Z", "author": {"login": "danielcweeks"}, "path": "core/src/main/java/org/apache/iceberg/BaseMetastoreCatalog.java", "diffHunk": "@@ -110,9 +110,17 @@ public Transaction newReplaceTableTransaction(\n       throw new NoSuchTableException(\"No such table: \" + identifier);\n     }\n \n-    String baseLocation = location != null ? location : defaultWarehouseLocation(identifier);\n     Map<String, String> tableProperties = properties != null ? properties : Maps.newHashMap();\n-    TableMetadata metadata = TableMetadata.newTableMetadata(schema, spec, baseLocation, tableProperties);\n+\n+    TableMetadata metadata;\n+    if (ops.current() != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58a9eb5672d2c807bf3b6bda61889ccc5a07428b"}, "originalPosition": 9}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4589, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}