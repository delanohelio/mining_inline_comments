{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAyMjU5NjM0", "number": 1607, "title": "Test out complex stuctures: MAP/LIST/STRUCT", "bodyText": "Introduce additional testcases to cover scenarios involving complex types and embedded complex types.", "createdAt": "2020-10-13T12:29:37Z", "url": "https://github.com/apache/iceberg/pull/1607", "merged": true, "mergeCommit": {"oid": "a3ab89b393ac9defb7268fe0b4dcaea9df569e6c"}, "closed": true, "closedAt": "2020-11-23T19:03:37Z", "author": {"login": "lcspinter"}, "timelineItems": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdSLbIqAFqTUwNzY0MDQ2Ng==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdfZ8C7AFqTUzNjc2MzUzMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA3NjQwNDY2", "url": "https://github.com/apache/iceberg/pull/1607#pullrequestreview-507640466", "createdAt": "2020-10-13T16:46:28Z", "commit": {"oid": "6e1228fd085822b7784ca862370cfabd505a1fc5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QxNjo0NjoyOFrOHgwTvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QxNjo0NjoyOFrOHgwTvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEwNzk2NQ==", "bodyText": "Style:\n\nWe don't use final for local variables because Java does a good job of inferring it and it is debatable whether it actually helps the compiler make better decisions.\nThe indentation is off. It should be 4 spaces (2 indents) for a continuing indent.", "url": "https://github.com/apache/iceberg/pull/1607#discussion_r504107965", "createdAt": "2020-10-13T16:46:28Z", "author": {"login": "rdblue"}, "path": "mr/src/test/java/org/apache/iceberg/mr/hive/HiveIcebergStorageHandlerBaseTest.java", "diffHunk": "@@ -230,6 +276,250 @@ public void testJoinTables(FileFormat format) throws IOException {\n     Assert.assertArrayEquals(new Object[] {1L, \"Bob\", 102L, 33.33d}, rows.get(2));\n   }\n \n+  private void testArrayTypeInTable(FileFormat format) throws IOException {\n+    final Schema schema = new Schema(\n+            required(1, \"arrayofprimitives\", Types.ListType.ofRequired(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e1228fd085822b7784ca862370cfabd505a1fc5"}, "originalPosition": 80}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6e1228fd085822b7784ca862370cfabd505a1fc5", "author": {"user": {"login": "lcspinter", "name": "L\u00e1szl\u00f3 Pint\u00e9r"}}, "url": "https://github.com/apache/iceberg/commit/6e1228fd085822b7784ca862370cfabd505a1fc5", "committedDate": "2020-10-13T14:47:51Z", "message": "Lowercase table names in queries"}, "afterCommit": {"oid": "157fbcca552b073c49de3030dabbec69f136a28e", "author": {"user": {"login": "lcspinter", "name": "L\u00e1szl\u00f3 Pint\u00e9r"}}, "url": "https://github.com/apache/iceberg/commit/157fbcca552b073c49de3030dabbec69f136a28e", "committedDate": "2020-10-14T12:22:24Z", "message": "Lowercase table names in queries"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e65dde4c3d4334b78f36061343644bd1aaa7f46f", "author": {"user": {"login": "lcspinter", "name": "L\u00e1szl\u00f3 Pint\u00e9r"}}, "url": "https://github.com/apache/iceberg/commit/e65dde4c3d4334b78f36061343644bd1aaa7f46f", "committedDate": "2020-10-14T12:39:06Z", "message": "Remove final keyword for local variables"}, "afterCommit": {"oid": "f39573db44877eb1b8a8ce986422fd3728b5a5ac", "author": {"user": {"login": "lcspinter", "name": "L\u00e1szl\u00f3 Pint\u00e9r"}}, "url": "https://github.com/apache/iceberg/commit/f39573db44877eb1b8a8ce986422fd3728b5a5ac", "committedDate": "2020-10-29T12:24:40Z", "message": "Test out complex stuctures: MAP/LIST/STRUCT"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE5ODk2NDky", "url": "https://github.com/apache/iceberg/pull/1607#pullrequestreview-519896492", "createdAt": "2020-10-29T17:14:09Z", "commit": {"oid": "1abc954a1a93f139044c54db564e1931fefd7548"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxNzoxNDowOVrOHqmRSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxNzoxNDowOVrOHqmRSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQyOTI1Ng==", "bodyText": "you can remove these drop statements, since the @ After should clean up all the tables", "url": "https://github.com/apache/iceberg/pull/1607#discussion_r514429256", "createdAt": "2020-10-29T17:14:09Z", "author": {"login": "marton-bod"}, "path": "mr/src/test/java/org/apache/iceberg/mr/hive/HiveIcebergStorageHandlerBaseTest.java", "diffHunk": "@@ -481,6 +482,287 @@ public void testCreateTableAboveExistingTable() throws TException, IOException,\n     }\n   }\n \n+  @Test\n+  public void testArrayOfPrimitivesInTable() throws IOException {\n+    Schema schema =\n+            new Schema(required(1, \"arrayofprimitives\", Types.ListType.ofRequired(2, Types.IntegerType.get())));\n+    List<Record> records = createTableWithGeneratedRecords(schema, 1, 0L, \"arraytable\");\n+    // access a single element from the array\n+    for (int i = 0; i < records.size(); i++) {\n+      List<?> expectedList = (List<?>) records.get(i).getField(\"arrayofprimitives\");\n+      for (int j = 0; j < expectedList.size(); j++) {\n+        List<Object[]> queryResult = shell.executeStatement(\n+                String.format(\"SELECT arrayofprimitives[%d] FROM default.arraytable \" + \"LIMIT 1 OFFSET %d\", j, i));\n+        Assert.assertEquals(expectedList.get(j), queryResult.get(0)[0]);\n+      }\n+    }\n+    // drop test table\n+    shell.executeStatement(\"DROP TABLE default.arraytable\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1abc954a1a93f139044c54db564e1931fefd7548"}, "originalPosition": 27}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1abc954a1a93f139044c54db564e1931fefd7548", "author": {"user": {"login": "lcspinter", "name": "L\u00e1szl\u00f3 Pint\u00e9r"}}, "url": "https://github.com/apache/iceberg/commit/1abc954a1a93f139044c54db564e1931fefd7548", "committedDate": "2020-10-29T14:42:49Z", "message": "Split complex types tests"}, "afterCommit": {"oid": "f378684d7ea42370178f4d65de0908c72ba8a0c6", "author": {"user": {"login": "lcspinter", "name": "L\u00e1szl\u00f3 Pint\u00e9r"}}, "url": "https://github.com/apache/iceberg/commit/f378684d7ea42370178f4d65de0908c72ba8a0c6", "committedDate": "2020-10-29T17:35:11Z", "message": "Remove drop statement"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2NDMxNzM5", "url": "https://github.com/apache/iceberg/pull/1607#pullrequestreview-536431739", "createdAt": "2020-11-23T12:35:35Z", "commit": {"oid": "f378684d7ea42370178f4d65de0908c72ba8a0c6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxMjozNTozNVrOH4LlYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxMjozNTozNVrOH4LlYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODY3MjA5Nw==", "bodyText": "Do we need this test? This adds an extra sql statement which could be costly when run 24 times. I think that if the number of rows are not correct when preparing the table, then the tests will fail anyway.\nOr did I miss something?", "url": "https://github.com/apache/iceberg/pull/1607#discussion_r528672097", "createdAt": "2020-11-23T12:35:35Z", "author": {"login": "pvary"}, "path": "mr/src/test/java/org/apache/iceberg/mr/hive/HiveIcebergStorageHandlerBaseTest.java", "diffHunk": "@@ -512,4 +770,14 @@ protected void createHiveTable(String tableName, String location) {\n   protected String locationForCreateTable(String tempDirName, String tableName) {\n     return null;\n   }\n+\n+  private List<Record> createTableWithGeneratedRecords(Schema schema, int numRecords, long seed, String tableName)\n+          throws IOException {\n+    List<Record> records = TestHelper.generateRandomRecords(schema, numRecords, seed);\n+    createTable(tableName, schema, records);\n+    // sanity check, fetch all rows\n+    List<Object[]> allRows = shell.executeStatement(\"SELECT * from default.\" + tableName);\n+    Assert.assertEquals(\"Number of rows doesn't match expected.\", records.size(), allRows.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f378684d7ea42370178f4d65de0908c72ba8a0c6"}, "originalPosition": 283}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2NDMyMDIz", "url": "https://github.com/apache/iceberg/pull/1607#pullrequestreview-536432023", "createdAt": "2020-11-23T12:35:58Z", "commit": {"oid": "f378684d7ea42370178f4d65de0908c72ba8a0c6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxMjozNTo1OFrOH4LmIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxMjozNTo1OFrOH4LmIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODY3MjI4OQ==", "bodyText": "nit: would you mind removing this line?", "url": "https://github.com/apache/iceberg/pull/1607#discussion_r528672289", "createdAt": "2020-11-23T12:35:58Z", "author": {"login": "pvary"}, "path": "mr/src/test/java/org/apache/iceberg/mr/hive/HiveIcebergStorageHandlerBaseTest.java", "diffHunk": "@@ -481,6 +482,263 @@ public void testCreateTableAboveExistingTable() throws TException, IOException,\n     }\n   }\n \n+  @Test\n+  public void testArrayOfPrimitivesInTable() throws IOException {\n+    Schema schema =\n+            new Schema(required(1, \"arrayofprimitives\", Types.ListType.ofRequired(2, Types.IntegerType.get())));\n+    List<Record> records = createTableWithGeneratedRecords(schema, 1, 0L, \"arraytable\");\n+    // access a single element from the array\n+    for (int i = 0; i < records.size(); i++) {\n+      List<?> expectedList = (List<?>) records.get(i).getField(\"arrayofprimitives\");\n+      for (int j = 0; j < expectedList.size(); j++) {\n+        List<Object[]> queryResult = shell.executeStatement(\n+                String.format(\"SELECT arrayofprimitives[%d] FROM default.arraytable \" + \"LIMIT 1 OFFSET %d\", j, i));\n+        Assert.assertEquals(expectedList.get(j), queryResult.get(0)[0]);\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testArrayOfArraysInTable() throws IOException {\n+    Schema schema =\n+            new Schema(\n+                    required(1, \"arrayofarrays\",\n+                            Types.ListType.ofRequired(2, Types.ListType.ofRequired(3, Types.DateType.get()))));\n+    List<Record> records = createTableWithGeneratedRecords(schema, 1, 0L, \"arraytable\");\n+    // access an element from a matrix\n+    for (int i = 0; i < records.size(); i++) {\n+      List<?> expectedList = (List<?>) records.get(i).getField(\"arrayofarrays\");\n+      for (int j = 0; j < expectedList.size(); j++) {\n+        List<?> expectedInnerList = (List<?>) expectedList.get(j);\n+        for (int k = 0; k < expectedInnerList.size(); k++) {\n+          List<Object[]> queryResult = shell.executeStatement(\n+                  String.format(\"SELECT arrayofarrays[%d][%d] FROM default.arraytable \" + \"LIMIT 1 OFFSET %d\",\n+                          j, k, i));\n+          Assert.assertEquals(expectedInnerList.get(k).toString(), queryResult.get(0)[0]);\n+        }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f378684d7ea42370178f4d65de0908c72ba8a0c6"}, "originalPosition": 46}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "32ff2f2a4dfd29e8c73d1ea387ad1fc107bc8269", "author": {"user": {"login": "lcspinter", "name": "L\u00e1szl\u00f3 Pint\u00e9r"}}, "url": "https://github.com/apache/iceberg/commit/32ff2f2a4dfd29e8c73d1ea387ad1fc107bc8269", "committedDate": "2020-11-23T14:40:52Z", "message": "Test out complex stuctures: MAP/LIST/STRUCT"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "00e7a43d45a2b42a2a84fd63c677ea581b281e14", "author": {"user": {"login": "lcspinter", "name": "L\u00e1szl\u00f3 Pint\u00e9r"}}, "url": "https://github.com/apache/iceberg/commit/00e7a43d45a2b42a2a84fd63c677ea581b281e14", "committedDate": "2020-11-23T14:40:53Z", "message": "Split complex types tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3574abaa4bb16cd143998bfe6a4aff7433090bd8", "author": {"user": {"login": "lcspinter", "name": "L\u00e1szl\u00f3 Pint\u00e9r"}}, "url": "https://github.com/apache/iceberg/commit/3574abaa4bb16cd143998bfe6a4aff7433090bd8", "committedDate": "2020-11-23T14:40:53Z", "message": "Remove drop statement"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eb5f31bcc5d0433413a80b1e9a36a590ae6f5e08", "author": {"user": {"login": "lcspinter", "name": "L\u00e1szl\u00f3 Pint\u00e9r"}}, "url": "https://github.com/apache/iceberg/commit/eb5f31bcc5d0433413a80b1e9a36a590ae6f5e08", "committedDate": "2020-11-23T14:45:14Z", "message": "Review changes."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f378684d7ea42370178f4d65de0908c72ba8a0c6", "author": {"user": {"login": "lcspinter", "name": "L\u00e1szl\u00f3 Pint\u00e9r"}}, "url": "https://github.com/apache/iceberg/commit/f378684d7ea42370178f4d65de0908c72ba8a0c6", "committedDate": "2020-10-29T17:35:11Z", "message": "Remove drop statement"}, "afterCommit": {"oid": "eb5f31bcc5d0433413a80b1e9a36a590ae6f5e08", "author": {"user": {"login": "lcspinter", "name": "L\u00e1szl\u00f3 Pint\u00e9r"}}, "url": "https://github.com/apache/iceberg/commit/eb5f31bcc5d0433413a80b1e9a36a590ae6f5e08", "committedDate": "2020-11-23T14:45:14Z", "message": "Review changes."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2NzYzNTMy", "url": "https://github.com/apache/iceberg/pull/1607#pullrequestreview-536763532", "createdAt": "2020-11-23T19:02:06Z", "commit": {"oid": "eb5f31bcc5d0433413a80b1e9a36a590ae6f5e08"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxOTowMjowNlrOH4bVPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxOTowMjowNlrOH4bVPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkzMDEwOA==", "bodyText": "I think these tests may be quite a bit cleaner if this had a method to check the result given a schema and the expected record. It would require less code in each test case. That's what we do with other tests. Spark, for example, has helpers that can check the contents of a generic record against the contents of an InternalRow or a public Row. Probably good as a follow-up to this.", "url": "https://github.com/apache/iceberg/pull/1607#discussion_r528930108", "createdAt": "2020-11-23T19:02:06Z", "author": {"login": "rdblue"}, "path": "mr/src/test/java/org/apache/iceberg/mr/hive/HiveIcebergStorageHandlerBaseTest.java", "diffHunk": "@@ -581,6 +582,262 @@ public void testCreateTableAboveExistingTable() throws TException, IOException,\n     }\n   }\n \n+  @Test\n+  public void testArrayOfPrimitivesInTable() throws IOException {\n+    Schema schema =\n+            new Schema(required(1, \"arrayofprimitives\", Types.ListType.ofRequired(2, Types.IntegerType.get())));\n+    List<Record> records = createTableWithGeneratedRecords(schema, 1, 0L, \"arraytable\");\n+    // access a single element from the array\n+    for (int i = 0; i < records.size(); i++) {\n+      List<?> expectedList = (List<?>) records.get(i).getField(\"arrayofprimitives\");\n+      for (int j = 0; j < expectedList.size(); j++) {\n+        List<Object[]> queryResult = shell.executeStatement(\n+                String.format(\"SELECT arrayofprimitives[%d] FROM default.arraytable \" + \"LIMIT 1 OFFSET %d\", j, i));\n+        Assert.assertEquals(expectedList.get(j), queryResult.get(0)[0]);\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testArrayOfArraysInTable() throws IOException {\n+    Schema schema =\n+            new Schema(\n+                    required(1, \"arrayofarrays\",\n+                            Types.ListType.ofRequired(2, Types.ListType.ofRequired(3, Types.DateType.get()))));\n+    List<Record> records = createTableWithGeneratedRecords(schema, 1, 0L, \"arraytable\");\n+    // access an element from a matrix\n+    for (int i = 0; i < records.size(); i++) {\n+      List<?> expectedList = (List<?>) records.get(i).getField(\"arrayofarrays\");\n+      for (int j = 0; j < expectedList.size(); j++) {\n+        List<?> expectedInnerList = (List<?>) expectedList.get(j);\n+        for (int k = 0; k < expectedInnerList.size(); k++) {\n+          List<Object[]> queryResult = shell.executeStatement(\n+                  String.format(\"SELECT arrayofarrays[%d][%d] FROM default.arraytable \" + \"LIMIT 1 OFFSET %d\",\n+                          j, k, i));\n+          Assert.assertEquals(expectedInnerList.get(k).toString(), queryResult.get(0)[0]);\n+        }\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testArrayOfMapsInTable() throws IOException {\n+    Schema schema =\n+            new Schema(required(1, \"arrayofmaps\", Types.ListType\n+                    .ofRequired(2, Types.MapType.ofRequired(3, 4, Types.StringType.get(),\n+                            Types.BooleanType.get()))));\n+    List<Record> records = createTableWithGeneratedRecords(schema, 1, 0L, \"arraytable\");\n+    // access an element from a map in an array\n+    for (int i = 0; i < records.size(); i++) {\n+      List<?> expectedList = (List<?>) records.get(i).getField(\"arrayofmaps\");\n+      for (int j = 0; j < expectedList.size(); j++) {\n+        Map<?, ?> expectedMap = (Map<?, ?>) expectedList.get(j);\n+        for (Map.Entry<?, ?> entry : expectedMap.entrySet()) {\n+          List<Object[]> queryResult = shell.executeStatement(String\n+                  .format(\"SELECT arrayofmaps[%d][\\\"%s\\\"] FROM default.arraytable LIMIT 1 OFFSET %d\", j,\n+                          entry.getKey(), i));\n+          Assert.assertEquals(entry.getValue(), queryResult.get(0)[0]);\n+        }\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testArrayOfStructsInTable() throws IOException {\n+    Schema schema =\n+            new Schema(\n+                    required(1, \"arrayofstructs\", Types.ListType.ofRequired(2, Types.StructType\n+                            .of(required(3, \"something\", Types.DoubleType.get()), required(4, \"someone\",\n+                                    Types.LongType.get()), required(5, \"somewhere\", Types.StringType.get())))));\n+    List<Record> records = createTableWithGeneratedRecords(schema, 1, 0L, \"arraytable\");\n+    // access an element from a struct in an array\n+    for (int i = 0; i < records.size(); i++) {\n+      List<?> expectedList = (List<?>) records.get(i).getField(\"arrayofstructs\");\n+      for (int j = 0; j < expectedList.size(); j++) {\n+        List<Object[]> queryResult = shell.executeStatement(String.format(\"SELECT arrayofstructs[%d].something, \" +\n+                \"arrayofstructs[%d].someone, arrayofstructs[%d].somewhere FROM default.arraytable LIMIT 1 \" +\n+                \"OFFSET %d\", j, j, j, i));\n+        GenericRecord genericRecord = (GenericRecord) expectedList.get(j);\n+        Assert.assertEquals(genericRecord.getField(\"something\"), queryResult.get(0)[0]);\n+        Assert.assertEquals(genericRecord.getField(\"someone\"), queryResult.get(0)[1]);\n+        Assert.assertEquals(genericRecord.getField(\"somewhere\"), queryResult.get(0)[2]);\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testMapOfPrimitivesInTable() throws IOException {\n+    Schema schema = new Schema(\n+            required(1, \"mapofprimitives\", Types.MapType.ofRequired(2, 3, Types.StringType.get(),\n+                    Types.IntegerType.get())));\n+    List<Record> records = createTableWithGeneratedRecords(schema, 1, 0L, \"maptable\");\n+    // access a single value from the map\n+    for (int i = 0; i < records.size(); i++) {\n+      Map<?, ?> expectedMap = (Map<?, ?>) records.get(i).getField(\"mapofprimitives\");\n+      for (Map.Entry<?, ?> entry : expectedMap.entrySet()) {\n+        List<Object[]> queryResult = shell.executeStatement(String\n+                .format(\"SELECT mapofprimitives[\\\"%s\\\"] \" + \"FROM default.maptable LIMIT 1 OFFSET %d\", entry.getKey(),\n+                        i));\n+        Assert.assertEquals(entry.getValue(), queryResult.get(0)[0]);\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testMapOfArraysInTable() throws IOException {\n+    Schema schema = new Schema(\n+            required(1, \"mapofarrays\",\n+                    Types.MapType.ofRequired(2, 3, Types.StringType.get(), Types.ListType.ofRequired(4,\n+                            Types.DateType.get()))));\n+    List<Record> records = createTableWithGeneratedRecords(schema, 1, 0L, \"maptable\");\n+    // access a single element from a list in a map\n+    for (int i = 0; i < records.size(); i++) {\n+      Map<?, ?> expectedMap = (Map<?, ?>) records.get(i).getField(\"mapofarrays\");\n+      for (Map.Entry<?, ?> entry : expectedMap.entrySet()) {\n+        List<?> expectedList = (List<?>) entry.getValue();\n+        for (int j = 0; j < expectedList.size(); j++) {\n+          List<Object[]> queryResult = shell.executeStatement(String\n+                  .format(\"SELECT mapofarrays[\\\"%s\\\"]\" + \"[%d] FROM maptable LIMIT 1 OFFSET %d\", entry.getKey(), j, i));\n+          Assert.assertEquals(expectedList.get(j).toString(), queryResult.get(0)[0]);\n+        }\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testMapOfMapsInTable() throws IOException {\n+    Schema schema = new Schema(\n+            required(1, \"mapofmaps\", Types.MapType.ofRequired(2, 3, Types.StringType.get(),\n+                    Types.MapType.ofRequired(4, 5, Types.StringType.get(), Types.StringType.get()))));\n+    List<Record> records = createTableWithGeneratedRecords(schema, 1, 0L, \"maptable\");\n+    // access a single element from a map in a map\n+    for (int i = 0; i < records.size(); i++) {\n+      Map<?, ?> expectedMap = (Map<?, ?>) records.get(i).getField(\"mapofmaps\");\n+      for (Map.Entry<?, ?> entry : expectedMap.entrySet()) {\n+        Map<?, ?> expectedInnerMap = (Map<?, ?>) entry.getValue();\n+        for (Map.Entry<?, ?> innerEntry : expectedInnerMap.entrySet()) {\n+          List<Object[]> queryResult = shell.executeStatement(String\n+                  .format(\"SELECT mapofmaps[\\\"%s\\\"]\" + \"[\\\"%s\\\"] FROM maptable LIMIT 1 OFFSET %d\", entry.getKey(),\n+                          innerEntry.getKey(), i));\n+          Assert.assertEquals(innerEntry.getValue(), queryResult.get(0)[0]);\n+        }\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testMapOfStructsInTable() throws IOException {\n+    Schema schema = new Schema(\n+            required(1, \"mapofstructs\", Types.MapType.ofRequired(2, 3, Types.StringType.get(),\n+                    Types.StructType.of(required(4, \"something\", Types.DoubleType.get()),\n+                            required(5, \"someone\", Types.LongType.get()),\n+                            required(6, \"somewhere\", Types.StringType.get())))));\n+    List<Record> records = createTableWithGeneratedRecords(schema, 1, 0L, \"maptable\");\n+    // access a single element from a struct in a map\n+    for (int i = 0; i < records.size(); i++) {\n+      Map<?, ?> expectedMap = (Map<?, ?>) records.get(i).getField(\"mapofstructs\");\n+      for (Map.Entry<?, ?> entry : expectedMap.entrySet()) {\n+        List<Object[]> queryResult = shell.executeStatement(String.format(\"SELECT mapofstructs[\\\"%s\\\"].something, \" +\n+                \"mapofstructs[\\\"%s\\\"].someone, mapofstructs[\\\"%s\\\"].somewhere FROM default.maptable LIMIT 1 \" +\n+                \"OFFSET %d\", entry.getKey(), entry.getKey(), entry.getKey(), i));\n+        GenericRecord genericRecord = (GenericRecord) entry.getValue();\n+        Assert.assertEquals(genericRecord.getField(\"something\"), queryResult.get(0)[0]);\n+        Assert.assertEquals(genericRecord.getField(\"someone\"), queryResult.get(0)[1]);\n+        Assert.assertEquals(genericRecord.getField(\"somewhere\"), queryResult.get(0)[2]);\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testStructOfPrimitivesInTable() throws IOException {\n+    Schema schema = new Schema(required(1, \"structofprimitives\",\n+            Types.StructType.of(required(2, \"key\", Types.StringType.get()), required(3, \"value\",\n+                    Types.IntegerType.get()))));\n+    List<Record> records = createTableWithGeneratedRecords(schema, 1, 0L, \"structtable\");\n+    // access a single value in a struct\n+    for (int i = 0; i < records.size(); i++) {\n+      GenericRecord expectedStruct = (GenericRecord) records.get(i).getField(\"structofprimitives\");\n+      List<Object[]> queryResult = shell.executeStatement(String.format(\n+              \"SELECT structofprimitives.key, structofprimitives.value FROM default.structtable LIMIT 1 OFFSET %d\", i));\n+      Assert.assertEquals(expectedStruct.getField(\"key\"), queryResult.get(0)[0]);\n+      Assert.assertEquals(expectedStruct.getField(\"value\"), queryResult.get(0)[1]);\n+    }\n+  }\n+\n+  @Test\n+  public void testStructOfArraysInTable() throws IOException {\n+    Schema schema = new Schema(\n+            required(1, \"structofarrays\", Types.StructType\n+                    .of(required(2, \"names\", Types.ListType.ofRequired(3, Types.StringType.get())),\n+                            required(4, \"birthdays\", Types.ListType.ofRequired(5,\n+                                    Types.DateType.get())))));\n+    List<Record> records = createTableWithGeneratedRecords(schema, 1, 0L, \"structtable\");\n+    // access an element of an array inside a struct\n+    for (int i = 0; i < records.size(); i++) {\n+      GenericRecord expectedStruct = (GenericRecord) records.get(i).getField(\"structofarrays\");\n+      List<?> expectedList = (List<?>) expectedStruct.getField(\"names\");\n+      for (int j = 0; j < expectedList.size(); j++) {\n+        List<Object[]> queryResult = shell.executeStatement(\n+                String.format(\"SELECT structofarrays.names[%d] FROM default.structtable LIMIT 1 OFFSET %d\", j, i));\n+        Assert.assertEquals(expectedList.get(j), queryResult.get(0)[0]);\n+      }\n+      expectedList = (List<?>) expectedStruct.getField(\"birthdays\");\n+      for (int j = 0; j < expectedList.size(); j++) {\n+        List<Object[]> queryResult = shell.executeStatement(\n+                String.format(\"SELECT structofarrays.birthdays[%d] FROM default.structtable LIMIT 1 OFFSET %d\", j, i));\n+        Assert.assertEquals(expectedList.get(j).toString(), queryResult.get(0)[0]);\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testStructOfMapsInTable() throws IOException {\n+    Schema schema = new Schema(\n+            required(1, \"structofmaps\", Types.StructType\n+                    .of(required(2, \"map1\", Types.MapType.ofRequired(3, 4,\n+                            Types.StringType.get(), Types.StringType.get())), required(5, \"map2\",\n+                            Types.MapType.ofRequired(6, 7, Types.StringType.get(),\n+                                    Types.IntegerType.get())))));\n+    List<Record> records = createTableWithGeneratedRecords(schema, 1, 0L, \"structtable\");\n+    // access a map entry inside a struct\n+    for (int i = 0; i < records.size(); i++) {\n+      GenericRecord expectedStruct = (GenericRecord) records.get(i).getField(\"structofmaps\");\n+      Map<?, ?> expectedMap = (Map<?, ?>) expectedStruct.getField(\"map1\");\n+      for (Map.Entry<?, ?> entry : expectedMap.entrySet()) {\n+        List<Object[]> queryResult = shell.executeStatement(String\n+                .format(\"SELECT structofmaps.map1[\\\"%s\\\"] from default.structtable LIMIT 1 OFFSET %d\", entry.getKey(),\n+                        i));\n+        Assert.assertEquals(entry.getValue(), queryResult.get(0)[0]);\n+      }\n+      expectedMap = (Map<?, ?>) expectedStruct.getField(\"map2\");\n+      for (Map.Entry<?, ?> entry : expectedMap.entrySet()) {\n+        List<Object[]> queryResult = shell.executeStatement(String\n+                .format(\"SELECT structofmaps.map2[\\\"%s\\\"] from default.structtable LIMIT 1 OFFSET %d\", entry.getKey(),\n+                        i));\n+        Assert.assertEquals(entry.getValue(), queryResult.get(0)[0]);\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testStructOfStructsInTable() throws IOException {\n+    Schema schema = new Schema(\n+            required(1, \"structofstructs\", Types.StructType.of(required(2, \"struct1\", Types.StructType\n+                    .of(required(3, \"key\", Types.StringType.get()), required(4, \"value\",\n+                            Types.IntegerType.get()))))));\n+    List<Record> records = createTableWithGeneratedRecords(schema, 1, 0L, \"structtable\");\n+    // access a struct element inside a struct\n+    for (int i = 0; i < records.size(); i++) {\n+      GenericRecord expectedStruct = (GenericRecord) records.get(i).getField(\"structofstructs\");\n+      GenericRecord expectedInnerStruct = (GenericRecord) expectedStruct.getField(\"struct1\");\n+      List<Object[]> queryResult = shell.executeStatement(String.format(\n+              \"SELECT structofstructs.struct1.key, structofstructs.struct1.value FROM default.structtable \" +\n+                      \"LIMIT 1 OFFSET %d\", i));\n+      Assert.assertEquals(expectedInnerStruct.getField(\"key\"), queryResult.get(0)[0]);\n+      Assert.assertEquals(expectedInnerStruct.getField(\"value\"), queryResult.get(0)[1]);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb5f31bcc5d0433413a80b1e9a36a590ae6f5e08"}, "originalPosition": 264}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3952, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}