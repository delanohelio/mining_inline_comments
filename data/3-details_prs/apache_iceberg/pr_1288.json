{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYyNDc4OTkw", "number": 1288, "title": "Update scan planning with DeleteFiles in each task", "bodyText": "This adds DeleteFileIndex to scan delete manifests and index delete files, updates ManifestGroup to use the index when planning tasks, and adds delete files to FileScanTask.\nThe DeleteFileIndex uses a map keyed by partition spec ID and partition tuple. Values of the map are sorted list of sequence numbers and corresponding DeleteFile instances. When looking up a DataFile, the potentially matching delete files are fetched using its partition tuple, then the sequence numbers are binary searched to find the matching set of delete files with sequence numbers higher than the data file.\nThe index also supports global equality delete files. If an equality delete file is added to the table with an unpartitioned spec, it will be returned for all data files with a lower sequence number, regardless of partition.", "createdAt": "2020-08-04T01:45:04Z", "url": "https://github.com/apache/iceberg/pull/1288", "merged": true, "mergeCommit": {"oid": "0cd284978c3800a30d44aa2454dd5730b9bebfa7"}, "closed": true, "closedAt": "2020-08-05T20:22:25Z", "author": {"login": "rdblue"}, "timelineItems": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc7chHyAH2gAyNDYyNDc4OTkwOjIzOGRhODA2ODg4YjgyOTRlZDZlMTdhZWRiMGExZGI5MWQ0NDljNWI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc8BJWDgFqTQ2MTk5NTA4OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "238da806888b8294ed6e17aedb0a1db91d449c5b", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/238da806888b8294ed6e17aedb0a1db91d449c5b", "committedDate": "2020-08-04T01:41:08Z", "message": "Add deletes to FileScanTask."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "21402a2ddee157b0ecfb044c6249615d71861e0a", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/21402a2ddee157b0ecfb044c6249615d71861e0a", "committedDate": "2020-08-04T01:42:34Z", "message": "Add DeleteFileIndex to provide access to delete files."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwNDQyNDc1", "url": "https://github.com/apache/iceberg/pull/1288#pullrequestreview-460442475", "createdAt": "2020-08-04T01:47:32Z", "commit": {"oid": "21402a2ddee157b0ecfb044c6249615d71861e0a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQwMTo0NzozMlrOG7OLVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQwMTo0NzozMlrOG7OLVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc1MTQ0NQ==", "bodyText": "This was missing and causing tests to fail because manifest entries are copied.", "url": "https://github.com/apache/iceberg/pull/1288#discussion_r464751445", "createdAt": "2020-08-04T01:47:32Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/GenericManifestEntry.java", "diffHunk": "@@ -45,6 +45,7 @@ private GenericManifestEntry(GenericManifestEntry<F> toCopy, boolean fullCopy) {\n     this.schema = toCopy.schema;\n     this.status = toCopy.status;\n     this.snapshotId = toCopy.snapshotId;\n+    this.sequenceNumber = toCopy.sequenceNumber;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21402a2ddee157b0ecfb044c6249615d71861e0a"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwODczMjQ2", "url": "https://github.com/apache/iceberg/pull/1288#pullrequestreview-460873246", "createdAt": "2020-08-04T14:33:37Z", "commit": {"oid": "21402a2ddee157b0ecfb044c6249615d71861e0a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNDozMzozOFrOG7jRCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNDozMzozOFrOG7jRCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTA5Njk3MQ==", "bodyText": "This is mostly for my understanding: is DeleteFile[] deletes  a mandatory builder param now for file scan tasks? If not, from a v1 / v2 compatibility standpoint would it make sense to add an overloaded constructor?", "url": "https://github.com/apache/iceberg/pull/1288#discussion_r465096971", "createdAt": "2020-08-04T14:33:38Z", "author": {"login": "prodeezy"}, "path": "core/src/main/java/org/apache/iceberg/BaseFileScanTask.java", "diffHunk": "@@ -31,14 +31,17 @@\n \n class BaseFileScanTask implements FileScanTask {\n   private final DataFile file;\n+  private final DeleteFile[] deletes;\n   private final String schemaString;\n   private final String specString;\n   private final ResidualEvaluator residuals;\n \n   private transient PartitionSpec spec = null;\n \n-  BaseFileScanTask(DataFile file, String schemaString, String specString, ResidualEvaluator residuals) {\n+  BaseFileScanTask(DataFile file, DeleteFile[] deletes, String schemaString, String specString,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21402a2ddee157b0ecfb044c6249615d71861e0a"}, "originalPosition": 12}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c6f7155d2a1aab3a03e35910f2407ec8c3ed670a", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/c6f7155d2a1aab3a03e35910f2407ec8c3ed670a", "committedDate": "2020-08-04T18:07:43Z", "message": "Add partition spec ID to DeleteFileIndex."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0bb2ba1899ded7e0d8a7f1b755908293efe79f3d", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/0bb2ba1899ded7e0d8a7f1b755908293efe79f3d", "committedDate": "2020-08-04T18:49:47Z", "message": "Make unpartitioned equality deletes apply globally."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "43a85a4d54c91d7f767f1fa89ecf718ae02cda84", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/43a85a4d54c91d7f767f1fa89ecf718ae02cda84", "committedDate": "2020-08-04T21:03:25Z", "message": "Add more test cases."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f8847ba353c36c07dfb9f0f4010815456bebebc1", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/f8847ba353c36c07dfb9f0f4010815456bebebc1", "committedDate": "2020-08-04T21:06:35Z", "message": "Fix checkstyle."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dbe8740dbd742f73e30ca4959767fef7a964720b", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/dbe8740dbd742f73e30ca4959767fef7a964720b", "committedDate": "2020-08-04T21:17:19Z", "message": "Add more comments to DeleteFileIndex."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2dc29b5b899b6313956cbd2a4055a2cd0b84f0b8", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/2dc29b5b899b6313956cbd2a4055a2cd0b84f0b8", "committedDate": "2020-08-05T01:04:21Z", "message": "Fix checkstyle."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxODQ3MTEw", "url": "https://github.com/apache/iceberg/pull/1288#pullrequestreview-461847110", "createdAt": "2020-08-05T16:50:33Z", "commit": {"oid": "2dc29b5b899b6313956cbd2a4055a2cd0b84f0b8"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNjo1MDozM1rOG8SM-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNzozNzoxN1rOG8T3KQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg2NTk3Ng==", "bodyText": "nit: would it make sense to split this into two lines?", "url": "https://github.com/apache/iceberg/pull/1288#discussion_r465865976", "createdAt": "2020-08-05T16:50:33Z", "author": {"login": "aokolnychyi"}, "path": "core/src/main/java/org/apache/iceberg/DeleteFileIndex.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.LoadingCache;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ExecutorService;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.iceberg.exceptions.RuntimeIOException;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.expressions.ManifestEvaluator;\n+import org.apache.iceberg.expressions.Projections;\n+import org.apache.iceberg.io.CloseableIterable;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Iterables;\n+import org.apache.iceberg.relocated.com.google.common.collect.ListMultimap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.relocated.com.google.common.collect.Multimaps;\n+import org.apache.iceberg.relocated.com.google.common.collect.Sets;\n+import org.apache.iceberg.util.Pair;\n+import org.apache.iceberg.util.StructLikeWrapper;\n+import org.apache.iceberg.util.Tasks;\n+\n+/**\n+ * An index of {@link DeleteFile delete files} by sequence number.\n+ * <p>\n+ * Use {@link #builderFor(FileIO, Iterable)} to construct an index, and {@link #forDataFile(int, long, DataFile)} or\n+ * {@link #forEntry(int, ManifestEntry)} to get the the delete files to apply to a given data file.\n+ */\n+class DeleteFileIndex {\n+  private static final DeleteFile[] NO_DELETE_FILES = new DeleteFile[0];\n+\n+  private final long[] globalSeqs;\n+  private final DeleteFile[] globalDeletes;\n+  private final Map<Pair<Integer, StructLikeWrapper>, Pair<long[], DeleteFile[]>> sortedDeletesByPartition;\n+  private final ThreadLocal<StructLikeWrapper> lookupWrapper = ThreadLocal.withInitial(\n+      () -> StructLikeWrapper.wrap(null));\n+\n+  DeleteFileIndex(long[] globalSeqs, DeleteFile[] globalDeletes,\n+                  Map<Pair<Integer, StructLikeWrapper>, Pair<long[], DeleteFile[]>> sortedDeletesByPartition) {\n+    this.globalSeqs = globalSeqs;\n+    this.globalDeletes = globalDeletes;\n+    this.sortedDeletesByPartition = sortedDeletesByPartition;\n+  }\n+\n+  DeleteFile[] forEntry(int specId, ManifestEntry<DataFile> entry) {\n+    return forDataFile(specId, entry.sequenceNumber(), entry.file());\n+  }\n+\n+  DeleteFile[] forDataFile(int specId, long sequenceNumber, DataFile file) {\n+    Pair<long[], DeleteFile[]> partitionDeletes = sortedDeletesByPartition\n+        .get(Pair.of(specId, lookupWrapper.get().set(file.partition())));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2dc29b5b899b6313956cbd2a4055a2cd0b84f0b8"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg3MDAxMQ==", "bodyText": "Do we need ThreadLocal as we plan jobs using multiple threads?", "url": "https://github.com/apache/iceberg/pull/1288#discussion_r465870011", "createdAt": "2020-08-05T16:57:10Z", "author": {"login": "aokolnychyi"}, "path": "core/src/main/java/org/apache/iceberg/DeleteFileIndex.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.LoadingCache;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ExecutorService;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.iceberg.exceptions.RuntimeIOException;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.expressions.ManifestEvaluator;\n+import org.apache.iceberg.expressions.Projections;\n+import org.apache.iceberg.io.CloseableIterable;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Iterables;\n+import org.apache.iceberg.relocated.com.google.common.collect.ListMultimap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.relocated.com.google.common.collect.Multimaps;\n+import org.apache.iceberg.relocated.com.google.common.collect.Sets;\n+import org.apache.iceberg.util.Pair;\n+import org.apache.iceberg.util.StructLikeWrapper;\n+import org.apache.iceberg.util.Tasks;\n+\n+/**\n+ * An index of {@link DeleteFile delete files} by sequence number.\n+ * <p>\n+ * Use {@link #builderFor(FileIO, Iterable)} to construct an index, and {@link #forDataFile(int, long, DataFile)} or\n+ * {@link #forEntry(int, ManifestEntry)} to get the the delete files to apply to a given data file.\n+ */\n+class DeleteFileIndex {\n+  private static final DeleteFile[] NO_DELETE_FILES = new DeleteFile[0];\n+\n+  private final long[] globalSeqs;\n+  private final DeleteFile[] globalDeletes;\n+  private final Map<Pair<Integer, StructLikeWrapper>, Pair<long[], DeleteFile[]>> sortedDeletesByPartition;\n+  private final ThreadLocal<StructLikeWrapper> lookupWrapper = ThreadLocal.withInitial(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2dc29b5b899b6313956cbd2a4055a2cd0b84f0b8"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg3MTAxNg==", "bodyText": "Why we cannot just construct Pair in forDataFile using file.partition()?", "url": "https://github.com/apache/iceberg/pull/1288#discussion_r465871016", "createdAt": "2020-08-05T16:58:42Z", "author": {"login": "aokolnychyi"}, "path": "core/src/main/java/org/apache/iceberg/DeleteFileIndex.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.LoadingCache;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ExecutorService;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.iceberg.exceptions.RuntimeIOException;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.expressions.ManifestEvaluator;\n+import org.apache.iceberg.expressions.Projections;\n+import org.apache.iceberg.io.CloseableIterable;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Iterables;\n+import org.apache.iceberg.relocated.com.google.common.collect.ListMultimap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.relocated.com.google.common.collect.Multimaps;\n+import org.apache.iceberg.relocated.com.google.common.collect.Sets;\n+import org.apache.iceberg.util.Pair;\n+import org.apache.iceberg.util.StructLikeWrapper;\n+import org.apache.iceberg.util.Tasks;\n+\n+/**\n+ * An index of {@link DeleteFile delete files} by sequence number.\n+ * <p>\n+ * Use {@link #builderFor(FileIO, Iterable)} to construct an index, and {@link #forDataFile(int, long, DataFile)} or\n+ * {@link #forEntry(int, ManifestEntry)} to get the the delete files to apply to a given data file.\n+ */\n+class DeleteFileIndex {\n+  private static final DeleteFile[] NO_DELETE_FILES = new DeleteFile[0];\n+\n+  private final long[] globalSeqs;\n+  private final DeleteFile[] globalDeletes;\n+  private final Map<Pair<Integer, StructLikeWrapper>, Pair<long[], DeleteFile[]>> sortedDeletesByPartition;\n+  private final ThreadLocal<StructLikeWrapper> lookupWrapper = ThreadLocal.withInitial(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg3MDAxMQ=="}, "originalCommit": {"oid": "2dc29b5b899b6313956cbd2a4055a2cd0b84f0b8"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg4MjcyMg==", "bodyText": "We iterate through delete files twice because we don't anticipate too many global delete files?", "url": "https://github.com/apache/iceberg/pull/1288#discussion_r465882722", "createdAt": "2020-08-05T17:18:47Z", "author": {"login": "aokolnychyi"}, "path": "core/src/main/java/org/apache/iceberg/DeleteFileIndex.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.LoadingCache;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ExecutorService;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.iceberg.exceptions.RuntimeIOException;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.expressions.ManifestEvaluator;\n+import org.apache.iceberg.expressions.Projections;\n+import org.apache.iceberg.io.CloseableIterable;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Iterables;\n+import org.apache.iceberg.relocated.com.google.common.collect.ListMultimap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.relocated.com.google.common.collect.Multimaps;\n+import org.apache.iceberg.relocated.com.google.common.collect.Sets;\n+import org.apache.iceberg.util.Pair;\n+import org.apache.iceberg.util.StructLikeWrapper;\n+import org.apache.iceberg.util.Tasks;\n+\n+/**\n+ * An index of {@link DeleteFile delete files} by sequence number.\n+ * <p>\n+ * Use {@link #builderFor(FileIO, Iterable)} to construct an index, and {@link #forDataFile(int, long, DataFile)} or\n+ * {@link #forEntry(int, ManifestEntry)} to get the the delete files to apply to a given data file.\n+ */\n+class DeleteFileIndex {\n+  private static final DeleteFile[] NO_DELETE_FILES = new DeleteFile[0];\n+\n+  private final long[] globalSeqs;\n+  private final DeleteFile[] globalDeletes;\n+  private final Map<Pair<Integer, StructLikeWrapper>, Pair<long[], DeleteFile[]>> sortedDeletesByPartition;\n+  private final ThreadLocal<StructLikeWrapper> lookupWrapper = ThreadLocal.withInitial(\n+      () -> StructLikeWrapper.wrap(null));\n+\n+  DeleteFileIndex(long[] globalSeqs, DeleteFile[] globalDeletes,\n+                  Map<Pair<Integer, StructLikeWrapper>, Pair<long[], DeleteFile[]>> sortedDeletesByPartition) {\n+    this.globalSeqs = globalSeqs;\n+    this.globalDeletes = globalDeletes;\n+    this.sortedDeletesByPartition = sortedDeletesByPartition;\n+  }\n+\n+  DeleteFile[] forEntry(int specId, ManifestEntry<DataFile> entry) {\n+    return forDataFile(specId, entry.sequenceNumber(), entry.file());\n+  }\n+\n+  DeleteFile[] forDataFile(int specId, long sequenceNumber, DataFile file) {\n+    Pair<long[], DeleteFile[]> partitionDeletes = sortedDeletesByPartition\n+        .get(Pair.of(specId, lookupWrapper.get().set(file.partition())));\n+\n+    if (partitionDeletes == null) {\n+      return limitBySequenceNumber(sequenceNumber, globalSeqs, globalDeletes);\n+    } else if (globalDeletes == null) {\n+      return limitBySequenceNumber(sequenceNumber, partitionDeletes.first(), partitionDeletes.second());\n+    } else {\n+      return Stream.concat(\n+          Stream.of(limitBySequenceNumber(sequenceNumber, globalSeqs, globalDeletes)),\n+          Stream.of(limitBySequenceNumber(sequenceNumber, partitionDeletes.first(), partitionDeletes.second()))\n+      ).toArray(DeleteFile[]::new);\n+    }\n+  }\n+\n+  private static DeleteFile[] limitBySequenceNumber(long sequenceNumber, long[] seqs, DeleteFile[] files) {\n+    if (files == null) {\n+      return NO_DELETE_FILES;\n+    }\n+\n+    int pos = Arrays.binarySearch(seqs, sequenceNumber);\n+    int start;\n+    if (pos < 0) {\n+      // the sequence number was not found, where it would be inserted is -(pos + 1)\n+      start = -(pos + 1);\n+    } else {\n+      // the sequence number was found, but may not be the first\n+      // find the first delete file with the given sequence number by decrementing the position\n+      start = pos;\n+      while (start > 0 && seqs[start - 1] >= sequenceNumber) {\n+        start -= 1;\n+      }\n+    }\n+\n+    return Arrays.copyOfRange(files, start, files.length);\n+  }\n+\n+  static Builder builderFor(FileIO io, Iterable<ManifestFile> deleteManifests) {\n+    return new Builder(io, Sets.newHashSet(deleteManifests));\n+  }\n+\n+  static class Builder {\n+    private final FileIO io;\n+    private final Set<ManifestFile> deleteManifests;\n+    private Map<Integer, PartitionSpec> specsById;\n+    private Expression dataFilter;\n+    private Expression partitionFilter;\n+    private boolean caseSensitive;\n+    private ExecutorService executorService;\n+\n+    Builder(FileIO io, Set<ManifestFile> deleteManifests) {\n+      this.io = io;\n+      this.deleteManifests = Sets.newHashSet(deleteManifests);\n+      this.specsById = null;\n+      this.dataFilter = Expressions.alwaysTrue();\n+      this.partitionFilter = Expressions.alwaysTrue();\n+      this.caseSensitive = true;\n+      this.executorService = null;\n+    }\n+\n+    Builder specsById(Map<Integer, PartitionSpec> newSpecsById) {\n+      this.specsById = newSpecsById;\n+      return this;\n+    }\n+\n+    Builder filterData(Expression newDataFilter) {\n+      this.dataFilter = Expressions.and(dataFilter, newDataFilter);\n+      return this;\n+    }\n+\n+    Builder filterPartitions(Expression newPartitionFilter) {\n+      this.partitionFilter = Expressions.and(partitionFilter, newPartitionFilter);\n+      return this;\n+    }\n+\n+    Builder caseSensitive(boolean newCaseSensitive) {\n+      this.caseSensitive = newCaseSensitive;\n+      return this;\n+    }\n+\n+    Builder planWith(ExecutorService newExecutorService) {\n+      this.executorService = newExecutorService;\n+      return this;\n+    }\n+\n+    DeleteFileIndex build() {\n+      // read all of the matching delete manifests in parallel and accumulate the matching files in a queue\n+      Queue<Pair<Integer, ManifestEntry<DeleteFile>>> deleteEntries = new ConcurrentLinkedQueue<>();\n+      Tasks.foreach(deleteManifestReaders())\n+          .stopOnFailure().throwFailureWhenFinished()\n+          .executeWith(executorService)\n+          .run(specIdAndReader -> {\n+            try (CloseableIterable<ManifestEntry<DeleteFile>> reader = specIdAndReader.second()) {\n+              for (ManifestEntry<DeleteFile> entry : reader) {\n+                // copy with stats for better filtering against data file stats\n+                deleteEntries.add(Pair.of(specIdAndReader.first(), entry.copy()));\n+              }\n+            } catch (IOException e) {\n+              throw new RuntimeIOException(\"Failed to close\", e);\n+            }\n+          });\n+\n+      // build a map from (specId, partition) to delete file entries\n+      ListMultimap<Pair<Integer, StructLikeWrapper>, ManifestEntry<DeleteFile>> deleteFilesByPartition =\n+          Multimaps.newListMultimap(Maps.newHashMap(), Lists::newArrayList);\n+      for (Pair<Integer, ManifestEntry<DeleteFile>> specIdAndEntry : deleteEntries) {\n+        int specId = specIdAndEntry.first();\n+        ManifestEntry<DeleteFile> entry = specIdAndEntry.second();\n+        deleteFilesByPartition.put(Pair.of(specId, StructLikeWrapper.wrap(entry.file().partition())), entry);\n+      }\n+\n+      // sort the entries in each map value by sequence number and split into sequence numbers and delete files lists\n+      Map<Pair<Integer, StructLikeWrapper>, Pair<long[], DeleteFile[]>> sortedDeletesByPartition = Maps.newHashMap();\n+      // also, separate out equality deletes in an unpartitioned spec that should be applied globally\n+      long[] globalApplySeqs = null;\n+      DeleteFile[] globalDeletes = null;\n+      for (Pair<Integer, StructLikeWrapper> partition : deleteFilesByPartition.keySet()) {\n+        if (specsById.get(partition.first()).isUnpartitioned()) {\n+          Preconditions.checkState(globalDeletes == null, \"Detected multiple partition specs with no partitions\");\n+\n+          List<Pair<Long, DeleteFile>> eqFilesSortedBySeq = deleteFilesByPartition.get(partition).stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2dc29b5b899b6313956cbd2a4055a2cd0b84f0b8"}, "originalPosition": 200}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg4NDg1OQ==", "bodyText": "Why do we treat positional and equality deletes differently? Is it because the equality delete should not delete data in the snapshot it was added?", "url": "https://github.com/apache/iceberg/pull/1288#discussion_r465884859", "createdAt": "2020-08-05T17:22:35Z", "author": {"login": "aokolnychyi"}, "path": "core/src/main/java/org/apache/iceberg/DeleteFileIndex.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.LoadingCache;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ExecutorService;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.iceberg.exceptions.RuntimeIOException;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.expressions.ManifestEvaluator;\n+import org.apache.iceberg.expressions.Projections;\n+import org.apache.iceberg.io.CloseableIterable;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Iterables;\n+import org.apache.iceberg.relocated.com.google.common.collect.ListMultimap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.relocated.com.google.common.collect.Multimaps;\n+import org.apache.iceberg.relocated.com.google.common.collect.Sets;\n+import org.apache.iceberg.util.Pair;\n+import org.apache.iceberg.util.StructLikeWrapper;\n+import org.apache.iceberg.util.Tasks;\n+\n+/**\n+ * An index of {@link DeleteFile delete files} by sequence number.\n+ * <p>\n+ * Use {@link #builderFor(FileIO, Iterable)} to construct an index, and {@link #forDataFile(int, long, DataFile)} or\n+ * {@link #forEntry(int, ManifestEntry)} to get the the delete files to apply to a given data file.\n+ */\n+class DeleteFileIndex {\n+  private static final DeleteFile[] NO_DELETE_FILES = new DeleteFile[0];\n+\n+  private final long[] globalSeqs;\n+  private final DeleteFile[] globalDeletes;\n+  private final Map<Pair<Integer, StructLikeWrapper>, Pair<long[], DeleteFile[]>> sortedDeletesByPartition;\n+  private final ThreadLocal<StructLikeWrapper> lookupWrapper = ThreadLocal.withInitial(\n+      () -> StructLikeWrapper.wrap(null));\n+\n+  DeleteFileIndex(long[] globalSeqs, DeleteFile[] globalDeletes,\n+                  Map<Pair<Integer, StructLikeWrapper>, Pair<long[], DeleteFile[]>> sortedDeletesByPartition) {\n+    this.globalSeqs = globalSeqs;\n+    this.globalDeletes = globalDeletes;\n+    this.sortedDeletesByPartition = sortedDeletesByPartition;\n+  }\n+\n+  DeleteFile[] forEntry(int specId, ManifestEntry<DataFile> entry) {\n+    return forDataFile(specId, entry.sequenceNumber(), entry.file());\n+  }\n+\n+  DeleteFile[] forDataFile(int specId, long sequenceNumber, DataFile file) {\n+    Pair<long[], DeleteFile[]> partitionDeletes = sortedDeletesByPartition\n+        .get(Pair.of(specId, lookupWrapper.get().set(file.partition())));\n+\n+    if (partitionDeletes == null) {\n+      return limitBySequenceNumber(sequenceNumber, globalSeqs, globalDeletes);\n+    } else if (globalDeletes == null) {\n+      return limitBySequenceNumber(sequenceNumber, partitionDeletes.first(), partitionDeletes.second());\n+    } else {\n+      return Stream.concat(\n+          Stream.of(limitBySequenceNumber(sequenceNumber, globalSeqs, globalDeletes)),\n+          Stream.of(limitBySequenceNumber(sequenceNumber, partitionDeletes.first(), partitionDeletes.second()))\n+      ).toArray(DeleteFile[]::new);\n+    }\n+  }\n+\n+  private static DeleteFile[] limitBySequenceNumber(long sequenceNumber, long[] seqs, DeleteFile[] files) {\n+    if (files == null) {\n+      return NO_DELETE_FILES;\n+    }\n+\n+    int pos = Arrays.binarySearch(seqs, sequenceNumber);\n+    int start;\n+    if (pos < 0) {\n+      // the sequence number was not found, where it would be inserted is -(pos + 1)\n+      start = -(pos + 1);\n+    } else {\n+      // the sequence number was found, but may not be the first\n+      // find the first delete file with the given sequence number by decrementing the position\n+      start = pos;\n+      while (start > 0 && seqs[start - 1] >= sequenceNumber) {\n+        start -= 1;\n+      }\n+    }\n+\n+    return Arrays.copyOfRange(files, start, files.length);\n+  }\n+\n+  static Builder builderFor(FileIO io, Iterable<ManifestFile> deleteManifests) {\n+    return new Builder(io, Sets.newHashSet(deleteManifests));\n+  }\n+\n+  static class Builder {\n+    private final FileIO io;\n+    private final Set<ManifestFile> deleteManifests;\n+    private Map<Integer, PartitionSpec> specsById;\n+    private Expression dataFilter;\n+    private Expression partitionFilter;\n+    private boolean caseSensitive;\n+    private ExecutorService executorService;\n+\n+    Builder(FileIO io, Set<ManifestFile> deleteManifests) {\n+      this.io = io;\n+      this.deleteManifests = Sets.newHashSet(deleteManifests);\n+      this.specsById = null;\n+      this.dataFilter = Expressions.alwaysTrue();\n+      this.partitionFilter = Expressions.alwaysTrue();\n+      this.caseSensitive = true;\n+      this.executorService = null;\n+    }\n+\n+    Builder specsById(Map<Integer, PartitionSpec> newSpecsById) {\n+      this.specsById = newSpecsById;\n+      return this;\n+    }\n+\n+    Builder filterData(Expression newDataFilter) {\n+      this.dataFilter = Expressions.and(dataFilter, newDataFilter);\n+      return this;\n+    }\n+\n+    Builder filterPartitions(Expression newPartitionFilter) {\n+      this.partitionFilter = Expressions.and(partitionFilter, newPartitionFilter);\n+      return this;\n+    }\n+\n+    Builder caseSensitive(boolean newCaseSensitive) {\n+      this.caseSensitive = newCaseSensitive;\n+      return this;\n+    }\n+\n+    Builder planWith(ExecutorService newExecutorService) {\n+      this.executorService = newExecutorService;\n+      return this;\n+    }\n+\n+    DeleteFileIndex build() {\n+      // read all of the matching delete manifests in parallel and accumulate the matching files in a queue\n+      Queue<Pair<Integer, ManifestEntry<DeleteFile>>> deleteEntries = new ConcurrentLinkedQueue<>();\n+      Tasks.foreach(deleteManifestReaders())\n+          .stopOnFailure().throwFailureWhenFinished()\n+          .executeWith(executorService)\n+          .run(specIdAndReader -> {\n+            try (CloseableIterable<ManifestEntry<DeleteFile>> reader = specIdAndReader.second()) {\n+              for (ManifestEntry<DeleteFile> entry : reader) {\n+                // copy with stats for better filtering against data file stats\n+                deleteEntries.add(Pair.of(specIdAndReader.first(), entry.copy()));\n+              }\n+            } catch (IOException e) {\n+              throw new RuntimeIOException(\"Failed to close\", e);\n+            }\n+          });\n+\n+      // build a map from (specId, partition) to delete file entries\n+      ListMultimap<Pair<Integer, StructLikeWrapper>, ManifestEntry<DeleteFile>> deleteFilesByPartition =\n+          Multimaps.newListMultimap(Maps.newHashMap(), Lists::newArrayList);\n+      for (Pair<Integer, ManifestEntry<DeleteFile>> specIdAndEntry : deleteEntries) {\n+        int specId = specIdAndEntry.first();\n+        ManifestEntry<DeleteFile> entry = specIdAndEntry.second();\n+        deleteFilesByPartition.put(Pair.of(specId, StructLikeWrapper.wrap(entry.file().partition())), entry);\n+      }\n+\n+      // sort the entries in each map value by sequence number and split into sequence numbers and delete files lists\n+      Map<Pair<Integer, StructLikeWrapper>, Pair<long[], DeleteFile[]>> sortedDeletesByPartition = Maps.newHashMap();\n+      // also, separate out equality deletes in an unpartitioned spec that should be applied globally\n+      long[] globalApplySeqs = null;\n+      DeleteFile[] globalDeletes = null;\n+      for (Pair<Integer, StructLikeWrapper> partition : deleteFilesByPartition.keySet()) {\n+        if (specsById.get(partition.first()).isUnpartitioned()) {\n+          Preconditions.checkState(globalDeletes == null, \"Detected multiple partition specs with no partitions\");\n+\n+          List<Pair<Long, DeleteFile>> eqFilesSortedBySeq = deleteFilesByPartition.get(partition).stream()\n+              .filter(entry -> entry.file().content() == FileContent.EQUALITY_DELETES)\n+              .map(entry ->\n+                  // a delete file is indexed by the sequence number it should be applied to\n+                  Pair.of(entry.sequenceNumber() - 1, entry.file()))\n+              .sorted(Comparator.comparingLong(Pair::first))\n+              .collect(Collectors.toList());\n+\n+          globalApplySeqs = eqFilesSortedBySeq.stream().mapToLong(Pair::first).toArray();\n+          globalDeletes = eqFilesSortedBySeq.stream().map(Pair::second).toArray(DeleteFile[]::new);\n+\n+          List<Pair<Long, DeleteFile>> posFilesSortedBySeq = deleteFilesByPartition.get(partition).stream()\n+              .filter(entry -> entry.file().content() == FileContent.POSITION_DELETES)\n+              .map(entry -> Pair.of(entry.sequenceNumber(), entry.file()))\n+              .sorted(Comparator.comparingLong(Pair::first))\n+              .collect(Collectors.toList());\n+\n+          long[] seqs = posFilesSortedBySeq.stream().mapToLong(Pair::first).toArray();\n+          DeleteFile[] files = posFilesSortedBySeq.stream().map(Pair::second).toArray(DeleteFile[]::new);\n+\n+          sortedDeletesByPartition.put(partition, Pair.of(seqs, files));\n+\n+        } else {\n+          List<Pair<Long, DeleteFile>> filesSortedBySeq = deleteFilesByPartition.get(partition).stream()\n+              .map(entry -> {\n+                // a delete file is indexed by the sequence number it should be applied to\n+                long applySeq = entry.sequenceNumber() -\n+                    (entry.file().content() == FileContent.EQUALITY_DELETES ? 1 : 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2dc29b5b899b6313956cbd2a4055a2cd0b84f0b8"}, "originalPosition": 227}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg4OTc5Ng==", "bodyText": "Does this cover cases when all delete files or none match? I think Arrays.copyOfRange will throw an exception if from > original.length.", "url": "https://github.com/apache/iceberg/pull/1288#discussion_r465889796", "createdAt": "2020-08-05T17:31:11Z", "author": {"login": "aokolnychyi"}, "path": "core/src/main/java/org/apache/iceberg/DeleteFileIndex.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.LoadingCache;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ExecutorService;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.iceberg.exceptions.RuntimeIOException;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.expressions.ManifestEvaluator;\n+import org.apache.iceberg.expressions.Projections;\n+import org.apache.iceberg.io.CloseableIterable;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Iterables;\n+import org.apache.iceberg.relocated.com.google.common.collect.ListMultimap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.relocated.com.google.common.collect.Multimaps;\n+import org.apache.iceberg.relocated.com.google.common.collect.Sets;\n+import org.apache.iceberg.util.Pair;\n+import org.apache.iceberg.util.StructLikeWrapper;\n+import org.apache.iceberg.util.Tasks;\n+\n+/**\n+ * An index of {@link DeleteFile delete files} by sequence number.\n+ * <p>\n+ * Use {@link #builderFor(FileIO, Iterable)} to construct an index, and {@link #forDataFile(int, long, DataFile)} or\n+ * {@link #forEntry(int, ManifestEntry)} to get the the delete files to apply to a given data file.\n+ */\n+class DeleteFileIndex {\n+  private static final DeleteFile[] NO_DELETE_FILES = new DeleteFile[0];\n+\n+  private final long[] globalSeqs;\n+  private final DeleteFile[] globalDeletes;\n+  private final Map<Pair<Integer, StructLikeWrapper>, Pair<long[], DeleteFile[]>> sortedDeletesByPartition;\n+  private final ThreadLocal<StructLikeWrapper> lookupWrapper = ThreadLocal.withInitial(\n+      () -> StructLikeWrapper.wrap(null));\n+\n+  DeleteFileIndex(long[] globalSeqs, DeleteFile[] globalDeletes,\n+                  Map<Pair<Integer, StructLikeWrapper>, Pair<long[], DeleteFile[]>> sortedDeletesByPartition) {\n+    this.globalSeqs = globalSeqs;\n+    this.globalDeletes = globalDeletes;\n+    this.sortedDeletesByPartition = sortedDeletesByPartition;\n+  }\n+\n+  DeleteFile[] forEntry(int specId, ManifestEntry<DataFile> entry) {\n+    return forDataFile(specId, entry.sequenceNumber(), entry.file());\n+  }\n+\n+  DeleteFile[] forDataFile(int specId, long sequenceNumber, DataFile file) {\n+    Pair<long[], DeleteFile[]> partitionDeletes = sortedDeletesByPartition\n+        .get(Pair.of(specId, lookupWrapper.get().set(file.partition())));\n+\n+    if (partitionDeletes == null) {\n+      return limitBySequenceNumber(sequenceNumber, globalSeqs, globalDeletes);\n+    } else if (globalDeletes == null) {\n+      return limitBySequenceNumber(sequenceNumber, partitionDeletes.first(), partitionDeletes.second());\n+    } else {\n+      return Stream.concat(\n+          Stream.of(limitBySequenceNumber(sequenceNumber, globalSeqs, globalDeletes)),\n+          Stream.of(limitBySequenceNumber(sequenceNumber, partitionDeletes.first(), partitionDeletes.second()))\n+      ).toArray(DeleteFile[]::new);\n+    }\n+  }\n+\n+  private static DeleteFile[] limitBySequenceNumber(long sequenceNumber, long[] seqs, DeleteFile[] files) {\n+    if (files == null) {\n+      return NO_DELETE_FILES;\n+    }\n+\n+    int pos = Arrays.binarySearch(seqs, sequenceNumber);\n+    int start;\n+    if (pos < 0) {\n+      // the sequence number was not found, where it would be inserted is -(pos + 1)\n+      start = -(pos + 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2dc29b5b899b6313956cbd2a4055a2cd0b84f0b8"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg5MzE2MQ==", "bodyText": "To confirm: we will use partition predicates to prune delete manifests and data predicates to filter out delete files similarly to what we have for data file?", "url": "https://github.com/apache/iceberg/pull/1288#discussion_r465893161", "createdAt": "2020-08-05T17:37:17Z", "author": {"login": "aokolnychyi"}, "path": "core/src/main/java/org/apache/iceberg/DeleteFileIndex.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.LoadingCache;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ExecutorService;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.iceberg.exceptions.RuntimeIOException;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.expressions.ManifestEvaluator;\n+import org.apache.iceberg.expressions.Projections;\n+import org.apache.iceberg.io.CloseableIterable;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Iterables;\n+import org.apache.iceberg.relocated.com.google.common.collect.ListMultimap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.relocated.com.google.common.collect.Multimaps;\n+import org.apache.iceberg.relocated.com.google.common.collect.Sets;\n+import org.apache.iceberg.util.Pair;\n+import org.apache.iceberg.util.StructLikeWrapper;\n+import org.apache.iceberg.util.Tasks;\n+\n+/**\n+ * An index of {@link DeleteFile delete files} by sequence number.\n+ * <p>\n+ * Use {@link #builderFor(FileIO, Iterable)} to construct an index, and {@link #forDataFile(int, long, DataFile)} or\n+ * {@link #forEntry(int, ManifestEntry)} to get the the delete files to apply to a given data file.\n+ */\n+class DeleteFileIndex {\n+  private static final DeleteFile[] NO_DELETE_FILES = new DeleteFile[0];\n+\n+  private final long[] globalSeqs;\n+  private final DeleteFile[] globalDeletes;\n+  private final Map<Pair<Integer, StructLikeWrapper>, Pair<long[], DeleteFile[]>> sortedDeletesByPartition;\n+  private final ThreadLocal<StructLikeWrapper> lookupWrapper = ThreadLocal.withInitial(\n+      () -> StructLikeWrapper.wrap(null));\n+\n+  DeleteFileIndex(long[] globalSeqs, DeleteFile[] globalDeletes,\n+                  Map<Pair<Integer, StructLikeWrapper>, Pair<long[], DeleteFile[]>> sortedDeletesByPartition) {\n+    this.globalSeqs = globalSeqs;\n+    this.globalDeletes = globalDeletes;\n+    this.sortedDeletesByPartition = sortedDeletesByPartition;\n+  }\n+\n+  DeleteFile[] forEntry(int specId, ManifestEntry<DataFile> entry) {\n+    return forDataFile(specId, entry.sequenceNumber(), entry.file());\n+  }\n+\n+  DeleteFile[] forDataFile(int specId, long sequenceNumber, DataFile file) {\n+    Pair<long[], DeleteFile[]> partitionDeletes = sortedDeletesByPartition\n+        .get(Pair.of(specId, lookupWrapper.get().set(file.partition())));\n+\n+    if (partitionDeletes == null) {\n+      return limitBySequenceNumber(sequenceNumber, globalSeqs, globalDeletes);\n+    } else if (globalDeletes == null) {\n+      return limitBySequenceNumber(sequenceNumber, partitionDeletes.first(), partitionDeletes.second());\n+    } else {\n+      return Stream.concat(\n+          Stream.of(limitBySequenceNumber(sequenceNumber, globalSeqs, globalDeletes)),\n+          Stream.of(limitBySequenceNumber(sequenceNumber, partitionDeletes.first(), partitionDeletes.second()))\n+      ).toArray(DeleteFile[]::new);\n+    }\n+  }\n+\n+  private static DeleteFile[] limitBySequenceNumber(long sequenceNumber, long[] seqs, DeleteFile[] files) {\n+    if (files == null) {\n+      return NO_DELETE_FILES;\n+    }\n+\n+    int pos = Arrays.binarySearch(seqs, sequenceNumber);\n+    int start;\n+    if (pos < 0) {\n+      // the sequence number was not found, where it would be inserted is -(pos + 1)\n+      start = -(pos + 1);\n+    } else {\n+      // the sequence number was found, but may not be the first\n+      // find the first delete file with the given sequence number by decrementing the position\n+      start = pos;\n+      while (start > 0 && seqs[start - 1] >= sequenceNumber) {\n+        start -= 1;\n+      }\n+    }\n+\n+    return Arrays.copyOfRange(files, start, files.length);\n+  }\n+\n+  static Builder builderFor(FileIO io, Iterable<ManifestFile> deleteManifests) {\n+    return new Builder(io, Sets.newHashSet(deleteManifests));\n+  }\n+\n+  static class Builder {\n+    private final FileIO io;\n+    private final Set<ManifestFile> deleteManifests;\n+    private Map<Integer, PartitionSpec> specsById;\n+    private Expression dataFilter;\n+    private Expression partitionFilter;\n+    private boolean caseSensitive;\n+    private ExecutorService executorService;\n+\n+    Builder(FileIO io, Set<ManifestFile> deleteManifests) {\n+      this.io = io;\n+      this.deleteManifests = Sets.newHashSet(deleteManifests);\n+      this.specsById = null;\n+      this.dataFilter = Expressions.alwaysTrue();\n+      this.partitionFilter = Expressions.alwaysTrue();\n+      this.caseSensitive = true;\n+      this.executorService = null;\n+    }\n+\n+    Builder specsById(Map<Integer, PartitionSpec> newSpecsById) {\n+      this.specsById = newSpecsById;\n+      return this;\n+    }\n+\n+    Builder filterData(Expression newDataFilter) {\n+      this.dataFilter = Expressions.and(dataFilter, newDataFilter);\n+      return this;\n+    }\n+\n+    Builder filterPartitions(Expression newPartitionFilter) {\n+      this.partitionFilter = Expressions.and(partitionFilter, newPartitionFilter);\n+      return this;\n+    }\n+\n+    Builder caseSensitive(boolean newCaseSensitive) {\n+      this.caseSensitive = newCaseSensitive;\n+      return this;\n+    }\n+\n+    Builder planWith(ExecutorService newExecutorService) {\n+      this.executorService = newExecutorService;\n+      return this;\n+    }\n+\n+    DeleteFileIndex build() {\n+      // read all of the matching delete manifests in parallel and accumulate the matching files in a queue\n+      Queue<Pair<Integer, ManifestEntry<DeleteFile>>> deleteEntries = new ConcurrentLinkedQueue<>();\n+      Tasks.foreach(deleteManifestReaders())\n+          .stopOnFailure().throwFailureWhenFinished()\n+          .executeWith(executorService)\n+          .run(specIdAndReader -> {\n+            try (CloseableIterable<ManifestEntry<DeleteFile>> reader = specIdAndReader.second()) {\n+              for (ManifestEntry<DeleteFile> entry : reader) {\n+                // copy with stats for better filtering against data file stats\n+                deleteEntries.add(Pair.of(specIdAndReader.first(), entry.copy()));\n+              }\n+            } catch (IOException e) {\n+              throw new RuntimeIOException(\"Failed to close\", e);\n+            }\n+          });\n+\n+      // build a map from (specId, partition) to delete file entries\n+      ListMultimap<Pair<Integer, StructLikeWrapper>, ManifestEntry<DeleteFile>> deleteFilesByPartition =\n+          Multimaps.newListMultimap(Maps.newHashMap(), Lists::newArrayList);\n+      for (Pair<Integer, ManifestEntry<DeleteFile>> specIdAndEntry : deleteEntries) {\n+        int specId = specIdAndEntry.first();\n+        ManifestEntry<DeleteFile> entry = specIdAndEntry.second();\n+        deleteFilesByPartition.put(Pair.of(specId, StructLikeWrapper.wrap(entry.file().partition())), entry);\n+      }\n+\n+      // sort the entries in each map value by sequence number and split into sequence numbers and delete files lists\n+      Map<Pair<Integer, StructLikeWrapper>, Pair<long[], DeleteFile[]>> sortedDeletesByPartition = Maps.newHashMap();\n+      // also, separate out equality deletes in an unpartitioned spec that should be applied globally\n+      long[] globalApplySeqs = null;\n+      DeleteFile[] globalDeletes = null;\n+      for (Pair<Integer, StructLikeWrapper> partition : deleteFilesByPartition.keySet()) {\n+        if (specsById.get(partition.first()).isUnpartitioned()) {\n+          Preconditions.checkState(globalDeletes == null, \"Detected multiple partition specs with no partitions\");\n+\n+          List<Pair<Long, DeleteFile>> eqFilesSortedBySeq = deleteFilesByPartition.get(partition).stream()\n+              .filter(entry -> entry.file().content() == FileContent.EQUALITY_DELETES)\n+              .map(entry ->\n+                  // a delete file is indexed by the sequence number it should be applied to\n+                  Pair.of(entry.sequenceNumber() - 1, entry.file()))\n+              .sorted(Comparator.comparingLong(Pair::first))\n+              .collect(Collectors.toList());\n+\n+          globalApplySeqs = eqFilesSortedBySeq.stream().mapToLong(Pair::first).toArray();\n+          globalDeletes = eqFilesSortedBySeq.stream().map(Pair::second).toArray(DeleteFile[]::new);\n+\n+          List<Pair<Long, DeleteFile>> posFilesSortedBySeq = deleteFilesByPartition.get(partition).stream()\n+              .filter(entry -> entry.file().content() == FileContent.POSITION_DELETES)\n+              .map(entry -> Pair.of(entry.sequenceNumber(), entry.file()))\n+              .sorted(Comparator.comparingLong(Pair::first))\n+              .collect(Collectors.toList());\n+\n+          long[] seqs = posFilesSortedBySeq.stream().mapToLong(Pair::first).toArray();\n+          DeleteFile[] files = posFilesSortedBySeq.stream().map(Pair::second).toArray(DeleteFile[]::new);\n+\n+          sortedDeletesByPartition.put(partition, Pair.of(seqs, files));\n+\n+        } else {\n+          List<Pair<Long, DeleteFile>> filesSortedBySeq = deleteFilesByPartition.get(partition).stream()\n+              .map(entry -> {\n+                // a delete file is indexed by the sequence number it should be applied to\n+                long applySeq = entry.sequenceNumber() -\n+                    (entry.file().content() == FileContent.EQUALITY_DELETES ? 1 : 0);\n+                return Pair.of(applySeq, entry.file());\n+              })\n+              .sorted(Comparator.comparingLong(Pair::first))\n+              .collect(Collectors.toList());\n+\n+          long[] seqs = filesSortedBySeq.stream().mapToLong(Pair::first).toArray();\n+          DeleteFile[] files = filesSortedBySeq.stream().map(Pair::second).toArray(DeleteFile[]::new);\n+\n+          sortedDeletesByPartition.put(partition, Pair.of(seqs, files));\n+        }\n+      }\n+\n+      return new DeleteFileIndex(globalApplySeqs, globalDeletes, sortedDeletesByPartition);\n+    }\n+\n+    private Iterable<Pair<Integer, CloseableIterable<ManifestEntry<DeleteFile>>>> deleteManifestReaders() {\n+      LoadingCache<Integer, ManifestEvaluator> evalCache = specsById == null ? null :\n+          Caffeine.newBuilder().build(specId -> {\n+            PartitionSpec spec = specsById.get(specId);\n+            return ManifestEvaluator.forPartitionFilter(\n+                Expressions.and(partitionFilter, Projections.inclusive(spec, caseSensitive).project(dataFilter)),\n+                spec, caseSensitive);\n+          });\n+\n+      Iterable<ManifestFile> matchingManifests = evalCache == null ? deleteManifests :\n+          Iterables.filter(deleteManifests, manifest ->\n+              manifest.content() == ManifestContent.DELETES &&\n+                  (manifest.hasAddedFiles() || manifest.hasDeletedFiles()) &&\n+                  evalCache.get(manifest.partitionSpecId()).eval(manifest));\n+\n+      return Iterables.transform(\n+          matchingManifests,\n+          manifest -> Pair.of(\n+              manifest.partitionSpecId(),\n+              ManifestFiles.readDeleteManifest(manifest, io, specsById)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2dc29b5b899b6313956cbd2a4055a2cd0b84f0b8"}, "originalPosition": 262}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "557f899abcd07f26aa85213505f397521d3aa037", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/557f899abcd07f26aa85213505f397521d3aa037", "committedDate": "2020-08-05T18:36:46Z", "message": "Fix readability in DeleteFileIndex."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxOTk1MDg4", "url": "https://github.com/apache/iceberg/pull/1288#pullrequestreview-461995088", "createdAt": "2020-08-05T20:21:39Z", "commit": {"oid": "557f899abcd07f26aa85213505f397521d3aa037"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4387, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}