{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYyMjY5Nzk3", "number": 735, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QyMjoxMzo0NlrODY85WQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxODoxOTo0OVrODa-c5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NDkwMTM3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/iceberg/FilteredManifest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QyMjoxMzo0NlrOFfGl0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOVQwNDowMjowMlrOFfNDZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE1ODE2MQ==", "bodyText": "This is good, but can we make sure there is a row filter before adding these columns? Without the row filter they aren't needed.", "url": "https://github.com/apache/iceberg/pull/735#discussion_r368158161", "createdAt": "2020-01-17T22:13:46Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/FilteredManifest.java", "diffHunk": "@@ -95,60 +95,31 @@ public FilteredManifest caseSensitive(boolean isCaseSensitive) {\n       Evaluator evaluator = evaluator();\n       InclusiveMetricsEvaluator metricsEvaluator = metricsEvaluator();\n \n-      return CloseableIterable.filter(reader.entries(projection(fileSchema, columns, caseSensitive)),\n+      // ensure stats columns are present for metrics evaluation\n+      Collection<String> projectColumns = withStatsColumns(columns);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8627c9b218d03c728014efb6a00574676f0184d"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI2NDAzOA==", "bodyText": "Fixed", "url": "https://github.com/apache/iceberg/pull/735#discussion_r368264038", "createdAt": "2020-01-19T04:02:02Z", "author": {"login": "rdsr"}, "path": "core/src/main/java/org/apache/iceberg/FilteredManifest.java", "diffHunk": "@@ -95,60 +95,31 @@ public FilteredManifest caseSensitive(boolean isCaseSensitive) {\n       Evaluator evaluator = evaluator();\n       InclusiveMetricsEvaluator metricsEvaluator = metricsEvaluator();\n \n-      return CloseableIterable.filter(reader.entries(projection(fileSchema, columns, caseSensitive)),\n+      // ensure stats columns are present for metrics evaluation\n+      Collection<String> projectColumns = withStatsColumns(columns);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE1ODE2MQ=="}, "originalCommit": {"oid": "d8627c9b218d03c728014efb6a00574676f0184d"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NDkwNDQ4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/iceberg/FilteredManifest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QyMjoxNTo0M1rOFfGn1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QyMjoxNTo0M1rOFfGn1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE1ODY3Ng==", "bodyText": "Overall, I like the idea behind the changes to this file. It's a good idea to simply filter allEntries() to produce liveEntries(). But the change to copy ManifestEntries is going to hurt job planning performance. ManifestReader and FilteredManifest purposely do not copy entries to avoid the additional overhead while scanning. ManifestEntry is internal so anything that handles them should know when to make a defensive copy or not.\nThe public part of this class is the Iterable<DataFile>, which makes a defensive copy of all matching data files. That iterator should still make a copy, while the entries methods should not.", "url": "https://github.com/apache/iceberg/pull/735#discussion_r368158676", "createdAt": "2020-01-17T22:15:43Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/FilteredManifest.java", "diffHunk": "@@ -95,60 +95,31 @@ public FilteredManifest caseSensitive(boolean isCaseSensitive) {\n       Evaluator evaluator = evaluator();\n       InclusiveMetricsEvaluator metricsEvaluator = metricsEvaluator();\n \n-      return CloseableIterable.filter(reader.entries(projection(fileSchema, columns, caseSensitive)),\n+      // ensure stats columns are present for metrics evaluation\n+      Collection<String> projectColumns = withStatsColumns(columns);\n+\n+      CloseableIterable<ManifestEntry> entries = CloseableIterable.filter(\n+          reader.entries(projection(fileSchema, projectColumns, caseSensitive)),\n           entry -> entry != null &&\n               evaluator.eval(entry.file().partition()) &&\n               metricsEvaluator.eval(entry.file()));\n \n+      boolean dropStats = dropColumnStats(columns);\n+      return CloseableIterable.transform(entries, e -> dropStats ? e.copyWithoutStats() : e.copy());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8627c9b218d03c728014efb6a00574676f0184d"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NDkwNjkzOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/iceberg/FilteredManifest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QyMjoxNzowNFrOFfGpXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QyMjoxNzowNFrOFfGpXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE1OTA2OA==", "bodyText": "Can we replace \"*\" with a constant from somewhere?", "url": "https://github.com/apache/iceberg/pull/735#discussion_r368159068", "createdAt": "2020-01-17T22:17:04Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/FilteredManifest.java", "diffHunk": "@@ -193,4 +164,19 @@ private InclusiveMetricsEvaluator metricsEvaluator() {\n     }\n     return lazyMetricsEvaluator;\n   }\n+\n+  private static boolean dropColumnStats(Collection<String> columns) {\n+    return !columns.contains(\"*\") &&", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8627c9b218d03c728014efb6a00574676f0184d"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4ODc3MTc4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/iceberg/FilteredManifest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxODo0NjoxMFrOFhIyiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QyMDoyMzowNVrOFhLfxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI5MTMzNw==", "bodyText": "For performance, I think it is worse to copy here than to return the extra columns. We don't copy because we assume that the caller will use the row immediately -- e.g. to aggregate stats -- or will make a defensive copy. The caller is responsible to decide. That really cuts down on object allocation and helps performance. Copying just to get rid of stats columns forces a copy, when the caller may not need one.\nLet's just return what was read here. In iterator, where we are copying anyway we can do the copy with or without stats.", "url": "https://github.com/apache/iceberg/pull/735#discussion_r370291337", "createdAt": "2020-01-23T18:46:10Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/FilteredManifest.java", "diffHunk": "@@ -95,60 +94,38 @@ public FilteredManifest caseSensitive(boolean isCaseSensitive) {\n       Evaluator evaluator = evaluator();\n       InclusiveMetricsEvaluator metricsEvaluator = metricsEvaluator();\n \n-      return CloseableIterable.filter(reader.entries(projection(fileSchema, columns, caseSensitive)),\n+      // ensure stats columns are present for metrics evaluation\n+      boolean requireStatsProjection = requireStatsProjection();\n+      Collection<String> projectColumns = requireStatsProjection ? withStatsColumns(columns) : columns;\n+\n+      CloseableIterable<ManifestEntry> entries = CloseableIterable.filter(\n+          reader.entries(projection(fileSchema, projectColumns, caseSensitive)),\n           entry -> entry != null &&\n               evaluator.eval(entry.file().partition()) &&\n               metricsEvaluator.eval(entry.file()));\n \n+      // note that columns itself could have stats projected, that's ok.\n+      // We only drop stats if we have forced stats projection.\n+      return CloseableIterable.transform(entries, e -> requireStatsProjection ? e.copyWithoutStats() : e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f8d0176f179011b4d561576d15de1582ddc30d6"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMwNTc1OA==", "bodyText": "Do we need to think about the consequences of returning a different schema than what was projected?", "url": "https://github.com/apache/iceberg/pull/735#discussion_r370305758", "createdAt": "2020-01-23T19:16:44Z", "author": {"login": "rdsr"}, "path": "core/src/main/java/org/apache/iceberg/FilteredManifest.java", "diffHunk": "@@ -95,60 +94,38 @@ public FilteredManifest caseSensitive(boolean isCaseSensitive) {\n       Evaluator evaluator = evaluator();\n       InclusiveMetricsEvaluator metricsEvaluator = metricsEvaluator();\n \n-      return CloseableIterable.filter(reader.entries(projection(fileSchema, columns, caseSensitive)),\n+      // ensure stats columns are present for metrics evaluation\n+      boolean requireStatsProjection = requireStatsProjection();\n+      Collection<String> projectColumns = requireStatsProjection ? withStatsColumns(columns) : columns;\n+\n+      CloseableIterable<ManifestEntry> entries = CloseableIterable.filter(\n+          reader.entries(projection(fileSchema, projectColumns, caseSensitive)),\n           entry -> entry != null &&\n               evaluator.eval(entry.file().partition()) &&\n               metricsEvaluator.eval(entry.file()));\n \n+      // note that columns itself could have stats projected, that's ok.\n+      // We only drop stats if we have forced stats projection.\n+      return CloseableIterable.transform(entries, e -> requireStatsProjection ? e.copyWithoutStats() : e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI5MTMzNw=="}, "originalCommit": {"oid": "4f8d0176f179011b4d561576d15de1582ddc30d6"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMzNTY4NA==", "bodyText": "It's okay as long as we return more columns than the user asked for. There's an argument that you shouldn't return columns that weren't projected because of the extra memory required, but I think that's a minor concern.", "url": "https://github.com/apache/iceberg/pull/735#discussion_r370335684", "createdAt": "2020-01-23T20:23:05Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/FilteredManifest.java", "diffHunk": "@@ -95,60 +94,38 @@ public FilteredManifest caseSensitive(boolean isCaseSensitive) {\n       Evaluator evaluator = evaluator();\n       InclusiveMetricsEvaluator metricsEvaluator = metricsEvaluator();\n \n-      return CloseableIterable.filter(reader.entries(projection(fileSchema, columns, caseSensitive)),\n+      // ensure stats columns are present for metrics evaluation\n+      boolean requireStatsProjection = requireStatsProjection();\n+      Collection<String> projectColumns = requireStatsProjection ? withStatsColumns(columns) : columns;\n+\n+      CloseableIterable<ManifestEntry> entries = CloseableIterable.filter(\n+          reader.entries(projection(fileSchema, projectColumns, caseSensitive)),\n           entry -> entry != null &&\n               evaluator.eval(entry.file().partition()) &&\n               metricsEvaluator.eval(entry.file()));\n \n+      // note that columns itself could have stats projected, that's ok.\n+      // We only drop stats if we have forced stats projection.\n+      return CloseableIterable.transform(entries, e -> requireStatsProjection ? e.copyWithoutStats() : e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI5MTMzNw=="}, "originalCommit": {"oid": "4f8d0176f179011b4d561576d15de1582ddc30d6"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4ODc4MDczOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/iceberg/FilteredManifest.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxODo0ODo1OVrOFhI4HA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwNjoxMjowMlrOFhUr1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI5Mjc2NA==", "bodyText": "Doesn't this check need to be a little different?\nIf I project just one of the stats columns, then this will be true to pick up the column stats for filtering. But returning copyWithoutStats() in that case will drop a column that was projected. Instead, I think we need to check whether the intersection of stats columns and the requested projection is non-empty. If it is non-empty, then copy. If it is empty, copy without stats.", "url": "https://github.com/apache/iceberg/pull/735#discussion_r370292764", "createdAt": "2020-01-23T18:48:59Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/FilteredManifest.java", "diffHunk": "@@ -95,60 +94,38 @@ public FilteredManifest caseSensitive(boolean isCaseSensitive) {\n       Evaluator evaluator = evaluator();\n       InclusiveMetricsEvaluator metricsEvaluator = metricsEvaluator();\n \n-      return CloseableIterable.filter(reader.entries(projection(fileSchema, columns, caseSensitive)),\n+      // ensure stats columns are present for metrics evaluation\n+      boolean requireStatsProjection = requireStatsProjection();\n+      Collection<String> projectColumns = requireStatsProjection ? withStatsColumns(columns) : columns;\n+\n+      CloseableIterable<ManifestEntry> entries = CloseableIterable.filter(\n+          reader.entries(projection(fileSchema, projectColumns, caseSensitive)),\n           entry -> entry != null &&\n               evaluator.eval(entry.file().partition()) &&\n               metricsEvaluator.eval(entry.file()));\n \n+      // note that columns itself could have stats projected, that's ok.\n+      // We only drop stats if we have forced stats projection.\n+      return CloseableIterable.transform(entries, e -> requireStatsProjection ? e.copyWithoutStats() : e);\n     } else {\n       return reader.entries(projection(fileSchema, columns, caseSensitive));\n     }\n   }\n \n   CloseableIterable<ManifestEntry> liveEntries() {\n-    if ((rowFilter != null && rowFilter != Expressions.alwaysTrue()) ||\n-        (partFilter != null && partFilter != Expressions.alwaysTrue())) {\n-      Evaluator evaluator = evaluator();\n-      InclusiveMetricsEvaluator metricsEvaluator = metricsEvaluator();\n-\n-      return CloseableIterable.filter(reader.entries(projection(fileSchema, columns, caseSensitive)),\n-          entry -> entry != null &&\n-              entry.status() != Status.DELETED &&\n-              evaluator.eval(entry.file().partition()) &&\n-              metricsEvaluator.eval(entry.file()));\n-\n-    } else {\n-      return CloseableIterable.filter(reader.entries(projection(fileSchema, columns, caseSensitive)),\n-          entry -> entry != null && entry.status() != Status.DELETED);\n-    }\n+    return CloseableIterable.filter(allEntries(), entry -> entry != null && entry.status() != Status.DELETED);\n   }\n \n+  /**\n+   * @return an Iterator of DataFile. Makes defensive copies of files before returning\n+   */\n   @Override\n   public Iterator<DataFile> iterator() {\n-    if ((rowFilter != null && rowFilter != Expressions.alwaysTrue()) ||\n-        (partFilter != null && partFilter != Expressions.alwaysTrue())) {\n-      Evaluator evaluator = evaluator();\n-      InclusiveMetricsEvaluator metricsEvaluator = metricsEvaluator();\n-\n-      // ensure stats columns are present for metrics evaluation\n-      List<String> projectColumns = Lists.newArrayList(columns);\n-      projectColumns.addAll(STATS_COLUMNS); // order doesn't matter\n-\n-      // if no stats columns were projected, drop them\n-      boolean dropStats = Sets.intersection(Sets.newHashSet(columns), STATS_COLUMNS).isEmpty();\n-\n-      return Iterators.transform(\n-          Iterators.filter(reader.iterator(partFilter, projection(fileSchema, projectColumns, caseSensitive)),\n-              input -> input != null &&\n-                  evaluator.eval(input.partition()) &&\n-                  metricsEvaluator.eval(input)),\n-          dropStats ? DataFile::copyWithoutStats : DataFile::copy);\n-\n-    } else {\n-      return Iterators.transform(\n-          reader.iterator(partFilter, projection(fileSchema, columns, caseSensitive)),\n-          DataFile::copy);\n-    }\n+    // If requireStatsProjection is true, we don't create a defensive\n+    // copy of manifest entry as it was already done by allEntries()\n+    boolean requireStatsProjection = requireStatsProjection();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f8d0176f179011b4d561576d15de1582ddc30d6"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDM5OTQwMw==", "bodyText": "If I project just one of the stats columns, then this will be true to pick up the column stats for filtering\n\nIn this case, the requireStatsProjection() will return false. Since Sets.intersection(Sets.newHashSet(columns), STATS_COLUMNS).isEmpty() will be false", "url": "https://github.com/apache/iceberg/pull/735#discussion_r370399403", "createdAt": "2020-01-23T22:57:52Z", "author": {"login": "rdsr"}, "path": "core/src/main/java/org/apache/iceberg/FilteredManifest.java", "diffHunk": "@@ -95,60 +94,38 @@ public FilteredManifest caseSensitive(boolean isCaseSensitive) {\n       Evaluator evaluator = evaluator();\n       InclusiveMetricsEvaluator metricsEvaluator = metricsEvaluator();\n \n-      return CloseableIterable.filter(reader.entries(projection(fileSchema, columns, caseSensitive)),\n+      // ensure stats columns are present for metrics evaluation\n+      boolean requireStatsProjection = requireStatsProjection();\n+      Collection<String> projectColumns = requireStatsProjection ? withStatsColumns(columns) : columns;\n+\n+      CloseableIterable<ManifestEntry> entries = CloseableIterable.filter(\n+          reader.entries(projection(fileSchema, projectColumns, caseSensitive)),\n           entry -> entry != null &&\n               evaluator.eval(entry.file().partition()) &&\n               metricsEvaluator.eval(entry.file()));\n \n+      // note that columns itself could have stats projected, that's ok.\n+      // We only drop stats if we have forced stats projection.\n+      return CloseableIterable.transform(entries, e -> requireStatsProjection ? e.copyWithoutStats() : e);\n     } else {\n       return reader.entries(projection(fileSchema, columns, caseSensitive));\n     }\n   }\n \n   CloseableIterable<ManifestEntry> liveEntries() {\n-    if ((rowFilter != null && rowFilter != Expressions.alwaysTrue()) ||\n-        (partFilter != null && partFilter != Expressions.alwaysTrue())) {\n-      Evaluator evaluator = evaluator();\n-      InclusiveMetricsEvaluator metricsEvaluator = metricsEvaluator();\n-\n-      return CloseableIterable.filter(reader.entries(projection(fileSchema, columns, caseSensitive)),\n-          entry -> entry != null &&\n-              entry.status() != Status.DELETED &&\n-              evaluator.eval(entry.file().partition()) &&\n-              metricsEvaluator.eval(entry.file()));\n-\n-    } else {\n-      return CloseableIterable.filter(reader.entries(projection(fileSchema, columns, caseSensitive)),\n-          entry -> entry != null && entry.status() != Status.DELETED);\n-    }\n+    return CloseableIterable.filter(allEntries(), entry -> entry != null && entry.status() != Status.DELETED);\n   }\n \n+  /**\n+   * @return an Iterator of DataFile. Makes defensive copies of files before returning\n+   */\n   @Override\n   public Iterator<DataFile> iterator() {\n-    if ((rowFilter != null && rowFilter != Expressions.alwaysTrue()) ||\n-        (partFilter != null && partFilter != Expressions.alwaysTrue())) {\n-      Evaluator evaluator = evaluator();\n-      InclusiveMetricsEvaluator metricsEvaluator = metricsEvaluator();\n-\n-      // ensure stats columns are present for metrics evaluation\n-      List<String> projectColumns = Lists.newArrayList(columns);\n-      projectColumns.addAll(STATS_COLUMNS); // order doesn't matter\n-\n-      // if no stats columns were projected, drop them\n-      boolean dropStats = Sets.intersection(Sets.newHashSet(columns), STATS_COLUMNS).isEmpty();\n-\n-      return Iterators.transform(\n-          Iterators.filter(reader.iterator(partFilter, projection(fileSchema, projectColumns, caseSensitive)),\n-              input -> input != null &&\n-                  evaluator.eval(input.partition()) &&\n-                  metricsEvaluator.eval(input)),\n-          dropStats ? DataFile::copyWithoutStats : DataFile::copy);\n-\n-    } else {\n-      return Iterators.transform(\n-          reader.iterator(partFilter, projection(fileSchema, columns, caseSensitive)),\n-          DataFile::copy);\n-    }\n+    // If requireStatsProjection is true, we don't create a defensive\n+    // copy of manifest entry as it was already done by allEntries()\n+    boolean requireStatsProjection = requireStatsProjection();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI5Mjc2NA=="}, "originalCommit": {"oid": "4f8d0176f179011b4d561576d15de1582ddc30d6"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQzNDMxNA==", "bodyText": "Okay, I'm thinking of this in two ways: allStatsProjected(columns) and anyStatsProjected(columns).\nIn allEntries, we need to check whether we have allStatsProjcted. If not, then we need to add them. Here, we need anyStatsProjected: if any were requested then we return a copy and we can discard stats if not.\nLooks like requireStatsProjection implements anyStatsProjected because only one stats column is required to make isEmpty return false. So this method is correct, but the use above is not correct because it will not add stats columns when some, but not all, are missing.", "url": "https://github.com/apache/iceberg/pull/735#discussion_r370434314", "createdAt": "2020-01-24T01:10:07Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/FilteredManifest.java", "diffHunk": "@@ -95,60 +94,38 @@ public FilteredManifest caseSensitive(boolean isCaseSensitive) {\n       Evaluator evaluator = evaluator();\n       InclusiveMetricsEvaluator metricsEvaluator = metricsEvaluator();\n \n-      return CloseableIterable.filter(reader.entries(projection(fileSchema, columns, caseSensitive)),\n+      // ensure stats columns are present for metrics evaluation\n+      boolean requireStatsProjection = requireStatsProjection();\n+      Collection<String> projectColumns = requireStatsProjection ? withStatsColumns(columns) : columns;\n+\n+      CloseableIterable<ManifestEntry> entries = CloseableIterable.filter(\n+          reader.entries(projection(fileSchema, projectColumns, caseSensitive)),\n           entry -> entry != null &&\n               evaluator.eval(entry.file().partition()) &&\n               metricsEvaluator.eval(entry.file()));\n \n+      // note that columns itself could have stats projected, that's ok.\n+      // We only drop stats if we have forced stats projection.\n+      return CloseableIterable.transform(entries, e -> requireStatsProjection ? e.copyWithoutStats() : e);\n     } else {\n       return reader.entries(projection(fileSchema, columns, caseSensitive));\n     }\n   }\n \n   CloseableIterable<ManifestEntry> liveEntries() {\n-    if ((rowFilter != null && rowFilter != Expressions.alwaysTrue()) ||\n-        (partFilter != null && partFilter != Expressions.alwaysTrue())) {\n-      Evaluator evaluator = evaluator();\n-      InclusiveMetricsEvaluator metricsEvaluator = metricsEvaluator();\n-\n-      return CloseableIterable.filter(reader.entries(projection(fileSchema, columns, caseSensitive)),\n-          entry -> entry != null &&\n-              entry.status() != Status.DELETED &&\n-              evaluator.eval(entry.file().partition()) &&\n-              metricsEvaluator.eval(entry.file()));\n-\n-    } else {\n-      return CloseableIterable.filter(reader.entries(projection(fileSchema, columns, caseSensitive)),\n-          entry -> entry != null && entry.status() != Status.DELETED);\n-    }\n+    return CloseableIterable.filter(allEntries(), entry -> entry != null && entry.status() != Status.DELETED);\n   }\n \n+  /**\n+   * @return an Iterator of DataFile. Makes defensive copies of files before returning\n+   */\n   @Override\n   public Iterator<DataFile> iterator() {\n-    if ((rowFilter != null && rowFilter != Expressions.alwaysTrue()) ||\n-        (partFilter != null && partFilter != Expressions.alwaysTrue())) {\n-      Evaluator evaluator = evaluator();\n-      InclusiveMetricsEvaluator metricsEvaluator = metricsEvaluator();\n-\n-      // ensure stats columns are present for metrics evaluation\n-      List<String> projectColumns = Lists.newArrayList(columns);\n-      projectColumns.addAll(STATS_COLUMNS); // order doesn't matter\n-\n-      // if no stats columns were projected, drop them\n-      boolean dropStats = Sets.intersection(Sets.newHashSet(columns), STATS_COLUMNS).isEmpty();\n-\n-      return Iterators.transform(\n-          Iterators.filter(reader.iterator(partFilter, projection(fileSchema, projectColumns, caseSensitive)),\n-              input -> input != null &&\n-                  evaluator.eval(input.partition()) &&\n-                  metricsEvaluator.eval(input)),\n-          dropStats ? DataFile::copyWithoutStats : DataFile::copy);\n-\n-    } else {\n-      return Iterators.transform(\n-          reader.iterator(partFilter, projection(fileSchema, columns, caseSensitive)),\n-          DataFile::copy);\n-    }\n+    // If requireStatsProjection is true, we don't create a defensive\n+    // copy of manifest entry as it was already done by allEntries()\n+    boolean requireStatsProjection = requireStatsProjection();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI5Mjc2NA=="}, "originalCommit": {"oid": "4f8d0176f179011b4d561576d15de1582ddc30d6"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQzNTMwNA==", "bodyText": "Yes. I'll make those changes", "url": "https://github.com/apache/iceberg/pull/735#discussion_r370435304", "createdAt": "2020-01-24T01:14:36Z", "author": {"login": "rdsr"}, "path": "core/src/main/java/org/apache/iceberg/FilteredManifest.java", "diffHunk": "@@ -95,60 +94,38 @@ public FilteredManifest caseSensitive(boolean isCaseSensitive) {\n       Evaluator evaluator = evaluator();\n       InclusiveMetricsEvaluator metricsEvaluator = metricsEvaluator();\n \n-      return CloseableIterable.filter(reader.entries(projection(fileSchema, columns, caseSensitive)),\n+      // ensure stats columns are present for metrics evaluation\n+      boolean requireStatsProjection = requireStatsProjection();\n+      Collection<String> projectColumns = requireStatsProjection ? withStatsColumns(columns) : columns;\n+\n+      CloseableIterable<ManifestEntry> entries = CloseableIterable.filter(\n+          reader.entries(projection(fileSchema, projectColumns, caseSensitive)),\n           entry -> entry != null &&\n               evaluator.eval(entry.file().partition()) &&\n               metricsEvaluator.eval(entry.file()));\n \n+      // note that columns itself could have stats projected, that's ok.\n+      // We only drop stats if we have forced stats projection.\n+      return CloseableIterable.transform(entries, e -> requireStatsProjection ? e.copyWithoutStats() : e);\n     } else {\n       return reader.entries(projection(fileSchema, columns, caseSensitive));\n     }\n   }\n \n   CloseableIterable<ManifestEntry> liveEntries() {\n-    if ((rowFilter != null && rowFilter != Expressions.alwaysTrue()) ||\n-        (partFilter != null && partFilter != Expressions.alwaysTrue())) {\n-      Evaluator evaluator = evaluator();\n-      InclusiveMetricsEvaluator metricsEvaluator = metricsEvaluator();\n-\n-      return CloseableIterable.filter(reader.entries(projection(fileSchema, columns, caseSensitive)),\n-          entry -> entry != null &&\n-              entry.status() != Status.DELETED &&\n-              evaluator.eval(entry.file().partition()) &&\n-              metricsEvaluator.eval(entry.file()));\n-\n-    } else {\n-      return CloseableIterable.filter(reader.entries(projection(fileSchema, columns, caseSensitive)),\n-          entry -> entry != null && entry.status() != Status.DELETED);\n-    }\n+    return CloseableIterable.filter(allEntries(), entry -> entry != null && entry.status() != Status.DELETED);\n   }\n \n+  /**\n+   * @return an Iterator of DataFile. Makes defensive copies of files before returning\n+   */\n   @Override\n   public Iterator<DataFile> iterator() {\n-    if ((rowFilter != null && rowFilter != Expressions.alwaysTrue()) ||\n-        (partFilter != null && partFilter != Expressions.alwaysTrue())) {\n-      Evaluator evaluator = evaluator();\n-      InclusiveMetricsEvaluator metricsEvaluator = metricsEvaluator();\n-\n-      // ensure stats columns are present for metrics evaluation\n-      List<String> projectColumns = Lists.newArrayList(columns);\n-      projectColumns.addAll(STATS_COLUMNS); // order doesn't matter\n-\n-      // if no stats columns were projected, drop them\n-      boolean dropStats = Sets.intersection(Sets.newHashSet(columns), STATS_COLUMNS).isEmpty();\n-\n-      return Iterators.transform(\n-          Iterators.filter(reader.iterator(partFilter, projection(fileSchema, projectColumns, caseSensitive)),\n-              input -> input != null &&\n-                  evaluator.eval(input.partition()) &&\n-                  metricsEvaluator.eval(input)),\n-          dropStats ? DataFile::copyWithoutStats : DataFile::copy);\n-\n-    } else {\n-      return Iterators.transform(\n-          reader.iterator(partFilter, projection(fileSchema, columns, caseSensitive)),\n-          DataFile::copy);\n-    }\n+    // If requireStatsProjection is true, we don't create a defensive\n+    // copy of manifest entry as it was already done by allEntries()\n+    boolean requireStatsProjection = requireStatsProjection();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI5Mjc2NA=="}, "originalCommit": {"oid": "4f8d0176f179011b4d561576d15de1582ddc30d6"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ4NjIzMA==", "bodyText": "Thanks @rdblue ! Address your comments, but I named the methods slightly differently.  I do feel the code is slight harder to understand. Do let me know if there's a way to make it simpler, which we can take up in a follow up PR.", "url": "https://github.com/apache/iceberg/pull/735#discussion_r370486230", "createdAt": "2020-01-24T06:12:02Z", "author": {"login": "rdsr"}, "path": "core/src/main/java/org/apache/iceberg/FilteredManifest.java", "diffHunk": "@@ -95,60 +94,38 @@ public FilteredManifest caseSensitive(boolean isCaseSensitive) {\n       Evaluator evaluator = evaluator();\n       InclusiveMetricsEvaluator metricsEvaluator = metricsEvaluator();\n \n-      return CloseableIterable.filter(reader.entries(projection(fileSchema, columns, caseSensitive)),\n+      // ensure stats columns are present for metrics evaluation\n+      boolean requireStatsProjection = requireStatsProjection();\n+      Collection<String> projectColumns = requireStatsProjection ? withStatsColumns(columns) : columns;\n+\n+      CloseableIterable<ManifestEntry> entries = CloseableIterable.filter(\n+          reader.entries(projection(fileSchema, projectColumns, caseSensitive)),\n           entry -> entry != null &&\n               evaluator.eval(entry.file().partition()) &&\n               metricsEvaluator.eval(entry.file()));\n \n+      // note that columns itself could have stats projected, that's ok.\n+      // We only drop stats if we have forced stats projection.\n+      return CloseableIterable.transform(entries, e -> requireStatsProjection ? e.copyWithoutStats() : e);\n     } else {\n       return reader.entries(projection(fileSchema, columns, caseSensitive));\n     }\n   }\n \n   CloseableIterable<ManifestEntry> liveEntries() {\n-    if ((rowFilter != null && rowFilter != Expressions.alwaysTrue()) ||\n-        (partFilter != null && partFilter != Expressions.alwaysTrue())) {\n-      Evaluator evaluator = evaluator();\n-      InclusiveMetricsEvaluator metricsEvaluator = metricsEvaluator();\n-\n-      return CloseableIterable.filter(reader.entries(projection(fileSchema, columns, caseSensitive)),\n-          entry -> entry != null &&\n-              entry.status() != Status.DELETED &&\n-              evaluator.eval(entry.file().partition()) &&\n-              metricsEvaluator.eval(entry.file()));\n-\n-    } else {\n-      return CloseableIterable.filter(reader.entries(projection(fileSchema, columns, caseSensitive)),\n-          entry -> entry != null && entry.status() != Status.DELETED);\n-    }\n+    return CloseableIterable.filter(allEntries(), entry -> entry != null && entry.status() != Status.DELETED);\n   }\n \n+  /**\n+   * @return an Iterator of DataFile. Makes defensive copies of files before returning\n+   */\n   @Override\n   public Iterator<DataFile> iterator() {\n-    if ((rowFilter != null && rowFilter != Expressions.alwaysTrue()) ||\n-        (partFilter != null && partFilter != Expressions.alwaysTrue())) {\n-      Evaluator evaluator = evaluator();\n-      InclusiveMetricsEvaluator metricsEvaluator = metricsEvaluator();\n-\n-      // ensure stats columns are present for metrics evaluation\n-      List<String> projectColumns = Lists.newArrayList(columns);\n-      projectColumns.addAll(STATS_COLUMNS); // order doesn't matter\n-\n-      // if no stats columns were projected, drop them\n-      boolean dropStats = Sets.intersection(Sets.newHashSet(columns), STATS_COLUMNS).isEmpty();\n-\n-      return Iterators.transform(\n-          Iterators.filter(reader.iterator(partFilter, projection(fileSchema, projectColumns, caseSensitive)),\n-              input -> input != null &&\n-                  evaluator.eval(input.partition()) &&\n-                  metricsEvaluator.eval(input)),\n-          dropStats ? DataFile::copyWithoutStats : DataFile::copy);\n-\n-    } else {\n-      return Iterators.transform(\n-          reader.iterator(partFilter, projection(fileSchema, columns, caseSensitive)),\n-          DataFile::copy);\n-    }\n+    // If requireStatsProjection is true, we don't create a defensive\n+    // copy of manifest entry as it was already done by allEntries()\n+    boolean requireStatsProjection = requireStatsProjection();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI5Mjc2NA=="}, "originalCommit": {"oid": "4f8d0176f179011b4d561576d15de1582ddc30d6"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4ODc5MzQ3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/iceberg/ManifestGroup.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxODo1MzoyNVrOFhJAQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QyMDoyNTo1MVrOFhLkgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI5NDg1MQ==", "bodyText": "I'm undecided about the change to use a builder instead of a refinement API. The builder is simpler, but the implementation ends up doing very little and there is for some reason a build() call in the chain required just before entries().\nOn the other hand, the refinement API is a bit hard to maintain and is a little confusing. Its purpose is to make the ManifestGroup immutable so it can be shared, but that seems unlikely. We can wrap it in refinement APIs if we want to do this.\nHow about a third option: let's make ManifestGroup mutable. That way it is essentially a builder that you don't need to call build() on. You can just call entries() directly. The advantage is that the API remains the same (fewer changes everywhere) and we have a simpler class to maintain because it doesn't need to follow the refinement pattern.\nWhat do you think?", "url": "https://github.com/apache/iceberg/pull/735#discussion_r370294851", "createdAt": "2020-01-23T18:53:25Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/ManifestGroup.java", "diffHunk": "@@ -204,4 +141,78 @@ public ManifestGroup select(String... columnNames) {\n \n     return CloseableIterable.concat(readers);\n   }\n+\n+  static Builder builder(FileIO io, Iterable<ManifestFile> manifests) {\n+    return new Builder(io, manifests);\n+  }\n+\n+  static class Builder {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f8d0176f179011b4d561576d15de1582ddc30d6"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMwOTE2Mg==", "bodyText": "Yea, the refinement api was getting confusing for me. I'm ok with either builder vs mutable class. I'll change to a mutable version if that's easier.", "url": "https://github.com/apache/iceberg/pull/735#discussion_r370309162", "createdAt": "2020-01-23T19:23:47Z", "author": {"login": "rdsr"}, "path": "core/src/main/java/org/apache/iceberg/ManifestGroup.java", "diffHunk": "@@ -204,4 +141,78 @@ public ManifestGroup select(String... columnNames) {\n \n     return CloseableIterable.concat(readers);\n   }\n+\n+  static Builder builder(FileIO io, Iterable<ManifestFile> manifests) {\n+    return new Builder(io, manifests);\n+  }\n+\n+  static class Builder {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI5NDg1MQ=="}, "originalCommit": {"oid": "4f8d0176f179011b4d561576d15de1582ddc30d6"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMyOTE5NA==", "bodyText": "One problem with the mutable approach is now we have to be extra careful with the instantiation of  ManifestGroup. For instance, evalCache requires parameters partitionFilter,  dataFilter and specById.  When setting any one of these parameters we'd have to initialized evalCache again.\nI think I'd rather keep the builder here.", "url": "https://github.com/apache/iceberg/pull/735#discussion_r370329194", "createdAt": "2020-01-23T20:07:43Z", "author": {"login": "rdsr"}, "path": "core/src/main/java/org/apache/iceberg/ManifestGroup.java", "diffHunk": "@@ -204,4 +141,78 @@ public ManifestGroup select(String... columnNames) {\n \n     return CloseableIterable.concat(readers);\n   }\n+\n+  static Builder builder(FileIO io, Iterable<ManifestFile> manifests) {\n+    return new Builder(io, manifests);\n+  }\n+\n+  static class Builder {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI5NDg1MQ=="}, "originalCommit": {"oid": "4f8d0176f179011b4d561576d15de1582ddc30d6"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMzNjg5Ng==", "bodyText": "What if we make the cache a local variable instead of sharing it across invocations of entries? Since we don't expect multiple invocations, it should have identical performance. We don't really need to keep a cache around.", "url": "https://github.com/apache/iceberg/pull/735#discussion_r370336896", "createdAt": "2020-01-23T20:25:51Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/ManifestGroup.java", "diffHunk": "@@ -204,4 +141,78 @@ public ManifestGroup select(String... columnNames) {\n \n     return CloseableIterable.concat(readers);\n   }\n+\n+  static Builder builder(FileIO io, Iterable<ManifestFile> manifests) {\n+    return new Builder(io, manifests);\n+  }\n+\n+  static class Builder {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI5NDg1MQ=="}, "originalCommit": {"oid": "4f8d0176f179011b4d561576d15de1582ddc30d6"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4ODc5Njk1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/iceberg/ManifestReader.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxODo1NDo0M1rOFhJClQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxODo1NDo0M1rOFhJClQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI5NTQ0NQ==", "bodyText": "The purpose of this was to allow pushing filters into the manifest files if we ever use a format other than Parquet. I think overall this is a good change because we can add it back later. Just wanted to note why the unused argument was there.", "url": "https://github.com/apache/iceberg/pull/735#discussion_r370295445", "createdAt": "2020-01-23T18:54:43Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/ManifestReader.java", "diffHunk": "@@ -226,11 +226,11 @@ private void cacheChanges() {\n \n   @Override\n   public Iterator<DataFile> iterator() {\n-    return iterator(alwaysTrue(), fileSchema);\n+    return iterator(fileSchema);\n   }\n \n   // visible for use by PartialManifest\n-  Iterator<DataFile> iterator(Expression partFilter, Schema fileProjection) {\n+  Iterator<DataFile> iterator(Schema fileProjection) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f8d0176f179011b4d561576d15de1582ddc30d6"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5MjA3NzE2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/iceberg/FilteredManifest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQxOTozMjo0N1rOFhoNBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxODoyMToyOFrOFiMsLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgwNjAyMQ==", "bodyText": "Maybe it makes sense to remove duplicates here? There could be a scenario where a user projects stats columns partially and this ends up adding duplicate columns. Maybe just make projectColumns a set if order doesn't matter?", "url": "https://github.com/apache/iceberg/pull/735#discussion_r370806021", "createdAt": "2020-01-24T19:32:47Z", "author": {"login": "rdsr"}, "path": "core/src/main/java/org/apache/iceberg/FilteredManifest.java", "diffHunk": "@@ -193,4 +164,29 @@ private InclusiveMetricsEvaluator metricsEvaluator() {\n     }\n     return lazyMetricsEvaluator;\n   }\n+\n+  private boolean requireStatsProjection() {\n+    // Make sure we have all stats columns for metrics evaluator\n+    return rowFilter != Expressions.alwaysTrue() &&\n+        !columns.containsAll(ManifestReader.ALL_COLUMNS) &&\n+        !columns.containsAll(STATS_COLUMNS);\n+  }\n+\n+  private boolean dropStats() {\n+    // Make sure we only drop all stats if we had projected all stats\n+    // We do not drop stats even if we had partially added some stats columns\n+    return rowFilter != Expressions.alwaysTrue() &&\n+        !columns.containsAll(ManifestReader.ALL_COLUMNS) &&\n+        Sets.intersection(Sets.newHashSet(columns), STATS_COLUMNS).isEmpty();\n+  }\n+\n+  private static Collection<String> withStatsColumns(Collection<String> columns) {\n+    if (columns.containsAll(ManifestReader.ALL_COLUMNS)) {\n+      return columns;\n+    } else {\n+      List<String> projectColumns = Lists.newArrayList(columns);\n+      projectColumns.addAll(STATS_COLUMNS); // order doesn't matter", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a707de27a639e1fd6d3ea61fd23e89b6304f0c6"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQwMTc5NA==", "bodyText": "It doesn't matter because Schema.select ends up using a hash set of field IDs.", "url": "https://github.com/apache/iceberg/pull/735#discussion_r371401794", "createdAt": "2020-01-27T18:17:17Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/FilteredManifest.java", "diffHunk": "@@ -193,4 +164,29 @@ private InclusiveMetricsEvaluator metricsEvaluator() {\n     }\n     return lazyMetricsEvaluator;\n   }\n+\n+  private boolean requireStatsProjection() {\n+    // Make sure we have all stats columns for metrics evaluator\n+    return rowFilter != Expressions.alwaysTrue() &&\n+        !columns.containsAll(ManifestReader.ALL_COLUMNS) &&\n+        !columns.containsAll(STATS_COLUMNS);\n+  }\n+\n+  private boolean dropStats() {\n+    // Make sure we only drop all stats if we had projected all stats\n+    // We do not drop stats even if we had partially added some stats columns\n+    return rowFilter != Expressions.alwaysTrue() &&\n+        !columns.containsAll(ManifestReader.ALL_COLUMNS) &&\n+        Sets.intersection(Sets.newHashSet(columns), STATS_COLUMNS).isEmpty();\n+  }\n+\n+  private static Collection<String> withStatsColumns(Collection<String> columns) {\n+    if (columns.containsAll(ManifestReader.ALL_COLUMNS)) {\n+      return columns;\n+    } else {\n+      List<String> projectColumns = Lists.newArrayList(columns);\n+      projectColumns.addAll(STATS_COLUMNS); // order doesn't matter", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgwNjAyMQ=="}, "originalCommit": {"oid": "0a707de27a639e1fd6d3ea61fd23e89b6304f0c6"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQwMzgyMQ==", "bodyText": "Thks!  I'll leave it as it is then.", "url": "https://github.com/apache/iceberg/pull/735#discussion_r371403821", "createdAt": "2020-01-27T18:21:28Z", "author": {"login": "rdsr"}, "path": "core/src/main/java/org/apache/iceberg/FilteredManifest.java", "diffHunk": "@@ -193,4 +164,29 @@ private InclusiveMetricsEvaluator metricsEvaluator() {\n     }\n     return lazyMetricsEvaluator;\n   }\n+\n+  private boolean requireStatsProjection() {\n+    // Make sure we have all stats columns for metrics evaluator\n+    return rowFilter != Expressions.alwaysTrue() &&\n+        !columns.containsAll(ManifestReader.ALL_COLUMNS) &&\n+        !columns.containsAll(STATS_COLUMNS);\n+  }\n+\n+  private boolean dropStats() {\n+    // Make sure we only drop all stats if we had projected all stats\n+    // We do not drop stats even if we had partially added some stats columns\n+    return rowFilter != Expressions.alwaysTrue() &&\n+        !columns.containsAll(ManifestReader.ALL_COLUMNS) &&\n+        Sets.intersection(Sets.newHashSet(columns), STATS_COLUMNS).isEmpty();\n+  }\n+\n+  private static Collection<String> withStatsColumns(Collection<String> columns) {\n+    if (columns.containsAll(ManifestReader.ALL_COLUMNS)) {\n+      return columns;\n+    } else {\n+      List<String> projectColumns = Lists.newArrayList(columns);\n+      projectColumns.addAll(STATS_COLUMNS); // order doesn't matter", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgwNjAyMQ=="}, "originalCommit": {"oid": "0a707de27a639e1fd6d3ea61fd23e89b6304f0c6"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5NjEwNzQ4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/iceberg/FilteredManifest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxODoxMjo1MlrOFiMcZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxODoxMjo1MlrOFiMcZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTM5OTc4MQ==", "bodyText": "+1", "url": "https://github.com/apache/iceberg/pull/735#discussion_r371399781", "createdAt": "2020-01-27T18:12:52Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/FilteredManifest.java", "diffHunk": "@@ -95,60 +94,32 @@ public FilteredManifest caseSensitive(boolean isCaseSensitive) {\n       Evaluator evaluator = evaluator();\n       InclusiveMetricsEvaluator metricsEvaluator = metricsEvaluator();\n \n-      return CloseableIterable.filter(reader.entries(projection(fileSchema, columns, caseSensitive)),\n+      // ensure stats columns are present for metrics evaluation\n+      boolean requireStatsProjection = requireStatsProjection();\n+      Collection<String> projectColumns = requireStatsProjection ? withStatsColumns(columns) : columns;\n+\n+      return CloseableIterable.filter(\n+          reader.entries(projection(fileSchema, projectColumns, caseSensitive)),\n           entry -> entry != null &&\n               evaluator.eval(entry.file().partition()) &&\n               metricsEvaluator.eval(entry.file()));\n-\n     } else {\n       return reader.entries(projection(fileSchema, columns, caseSensitive));\n     }\n   }\n \n   CloseableIterable<ManifestEntry> liveEntries() {\n-    if ((rowFilter != null && rowFilter != Expressions.alwaysTrue()) ||\n-        (partFilter != null && partFilter != Expressions.alwaysTrue())) {\n-      Evaluator evaluator = evaluator();\n-      InclusiveMetricsEvaluator metricsEvaluator = metricsEvaluator();\n-\n-      return CloseableIterable.filter(reader.entries(projection(fileSchema, columns, caseSensitive)),\n-          entry -> entry != null &&\n-              entry.status() != Status.DELETED &&\n-              evaluator.eval(entry.file().partition()) &&\n-              metricsEvaluator.eval(entry.file()));\n-\n-    } else {\n-      return CloseableIterable.filter(reader.entries(projection(fileSchema, columns, caseSensitive)),\n-          entry -> entry != null && entry.status() != Status.DELETED);\n-    }\n+    return CloseableIterable.filter(allEntries(), entry -> entry != null && entry.status() != Status.DELETED);\n   }\n \n+  /**\n+   * @return an Iterator of DataFile. Makes defensive copies of files before returning", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a707de27a639e1fd6d3ea61fd23e89b6304f0c6"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5NjExNDkzOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/iceberg/FilteredManifest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxODoxNToyNVrOFiMhBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxODoxNjo1NFrOFiMjlg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQwMDk2NQ==", "bodyText": "Minor: It would be better to move the dropStats check outside of the lambda. There's no need to check it inside when we could just use a different lambda that doesn't put a conditional inside a tight loop:\n    if (dropStats()) {\n      return CloseableIterable.transform(liveEntries(), e -> e.file().copyWithoutStats()).iterator();\n    } else {\n      return CloseableIterable.transform(liveEntries(), e -> e.file().copy()).iterator();\n    }", "url": "https://github.com/apache/iceberg/pull/735#discussion_r371400965", "createdAt": "2020-01-27T18:15:25Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/FilteredManifest.java", "diffHunk": "@@ -95,60 +94,32 @@ public FilteredManifest caseSensitive(boolean isCaseSensitive) {\n       Evaluator evaluator = evaluator();\n       InclusiveMetricsEvaluator metricsEvaluator = metricsEvaluator();\n \n-      return CloseableIterable.filter(reader.entries(projection(fileSchema, columns, caseSensitive)),\n+      // ensure stats columns are present for metrics evaluation\n+      boolean requireStatsProjection = requireStatsProjection();\n+      Collection<String> projectColumns = requireStatsProjection ? withStatsColumns(columns) : columns;\n+\n+      return CloseableIterable.filter(\n+          reader.entries(projection(fileSchema, projectColumns, caseSensitive)),\n           entry -> entry != null &&\n               evaluator.eval(entry.file().partition()) &&\n               metricsEvaluator.eval(entry.file()));\n-\n     } else {\n       return reader.entries(projection(fileSchema, columns, caseSensitive));\n     }\n   }\n \n   CloseableIterable<ManifestEntry> liveEntries() {\n-    if ((rowFilter != null && rowFilter != Expressions.alwaysTrue()) ||\n-        (partFilter != null && partFilter != Expressions.alwaysTrue())) {\n-      Evaluator evaluator = evaluator();\n-      InclusiveMetricsEvaluator metricsEvaluator = metricsEvaluator();\n-\n-      return CloseableIterable.filter(reader.entries(projection(fileSchema, columns, caseSensitive)),\n-          entry -> entry != null &&\n-              entry.status() != Status.DELETED &&\n-              evaluator.eval(entry.file().partition()) &&\n-              metricsEvaluator.eval(entry.file()));\n-\n-    } else {\n-      return CloseableIterable.filter(reader.entries(projection(fileSchema, columns, caseSensitive)),\n-          entry -> entry != null && entry.status() != Status.DELETED);\n-    }\n+    return CloseableIterable.filter(allEntries(), entry -> entry != null && entry.status() != Status.DELETED);\n   }\n \n+  /**\n+   * @return an Iterator of DataFile. Makes defensive copies of files before returning\n+   */\n   @Override\n   public Iterator<DataFile> iterator() {\n-    if ((rowFilter != null && rowFilter != Expressions.alwaysTrue()) ||\n-        (partFilter != null && partFilter != Expressions.alwaysTrue())) {\n-      Evaluator evaluator = evaluator();\n-      InclusiveMetricsEvaluator metricsEvaluator = metricsEvaluator();\n-\n-      // ensure stats columns are present for metrics evaluation\n-      List<String> projectColumns = Lists.newArrayList(columns);\n-      projectColumns.addAll(STATS_COLUMNS); // order doesn't matter\n-\n-      // if no stats columns were projected, drop them\n-      boolean dropStats = Sets.intersection(Sets.newHashSet(columns), STATS_COLUMNS).isEmpty();\n-\n-      return Iterators.transform(\n-          Iterators.filter(reader.iterator(partFilter, projection(fileSchema, projectColumns, caseSensitive)),\n-              input -> input != null &&\n-                  evaluator.eval(input.partition()) &&\n-                  metricsEvaluator.eval(input)),\n-          dropStats ? DataFile::copyWithoutStats : DataFile::copy);\n-\n-    } else {\n-      return Iterators.transform(\n-          reader.iterator(partFilter, projection(fileSchema, columns, caseSensitive)),\n-          DataFile::copy);\n-    }\n+    boolean dropStats = dropStats();\n+    return CloseableIterable.transform(liveEntries(),\n+        e -> dropStats ? e.file().copyWithoutStats() : e.file().copy()).iterator();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a707de27a639e1fd6d3ea61fd23e89b6304f0c6"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQwMTYyMg==", "bodyText": "Makes sense", "url": "https://github.com/apache/iceberg/pull/735#discussion_r371401622", "createdAt": "2020-01-27T18:16:54Z", "author": {"login": "rdsr"}, "path": "core/src/main/java/org/apache/iceberg/FilteredManifest.java", "diffHunk": "@@ -95,60 +94,32 @@ public FilteredManifest caseSensitive(boolean isCaseSensitive) {\n       Evaluator evaluator = evaluator();\n       InclusiveMetricsEvaluator metricsEvaluator = metricsEvaluator();\n \n-      return CloseableIterable.filter(reader.entries(projection(fileSchema, columns, caseSensitive)),\n+      // ensure stats columns are present for metrics evaluation\n+      boolean requireStatsProjection = requireStatsProjection();\n+      Collection<String> projectColumns = requireStatsProjection ? withStatsColumns(columns) : columns;\n+\n+      return CloseableIterable.filter(\n+          reader.entries(projection(fileSchema, projectColumns, caseSensitive)),\n           entry -> entry != null &&\n               evaluator.eval(entry.file().partition()) &&\n               metricsEvaluator.eval(entry.file()));\n-\n     } else {\n       return reader.entries(projection(fileSchema, columns, caseSensitive));\n     }\n   }\n \n   CloseableIterable<ManifestEntry> liveEntries() {\n-    if ((rowFilter != null && rowFilter != Expressions.alwaysTrue()) ||\n-        (partFilter != null && partFilter != Expressions.alwaysTrue())) {\n-      Evaluator evaluator = evaluator();\n-      InclusiveMetricsEvaluator metricsEvaluator = metricsEvaluator();\n-\n-      return CloseableIterable.filter(reader.entries(projection(fileSchema, columns, caseSensitive)),\n-          entry -> entry != null &&\n-              entry.status() != Status.DELETED &&\n-              evaluator.eval(entry.file().partition()) &&\n-              metricsEvaluator.eval(entry.file()));\n-\n-    } else {\n-      return CloseableIterable.filter(reader.entries(projection(fileSchema, columns, caseSensitive)),\n-          entry -> entry != null && entry.status() != Status.DELETED);\n-    }\n+    return CloseableIterable.filter(allEntries(), entry -> entry != null && entry.status() != Status.DELETED);\n   }\n \n+  /**\n+   * @return an Iterator of DataFile. Makes defensive copies of files before returning\n+   */\n   @Override\n   public Iterator<DataFile> iterator() {\n-    if ((rowFilter != null && rowFilter != Expressions.alwaysTrue()) ||\n-        (partFilter != null && partFilter != Expressions.alwaysTrue())) {\n-      Evaluator evaluator = evaluator();\n-      InclusiveMetricsEvaluator metricsEvaluator = metricsEvaluator();\n-\n-      // ensure stats columns are present for metrics evaluation\n-      List<String> projectColumns = Lists.newArrayList(columns);\n-      projectColumns.addAll(STATS_COLUMNS); // order doesn't matter\n-\n-      // if no stats columns were projected, drop them\n-      boolean dropStats = Sets.intersection(Sets.newHashSet(columns), STATS_COLUMNS).isEmpty();\n-\n-      return Iterators.transform(\n-          Iterators.filter(reader.iterator(partFilter, projection(fileSchema, projectColumns, caseSensitive)),\n-              input -> input != null &&\n-                  evaluator.eval(input.partition()) &&\n-                  metricsEvaluator.eval(input)),\n-          dropStats ? DataFile::copyWithoutStats : DataFile::copy);\n-\n-    } else {\n-      return Iterators.transform(\n-          reader.iterator(partFilter, projection(fileSchema, columns, caseSensitive)),\n-          DataFile::copy);\n-    }\n+    boolean dropStats = dropStats();\n+    return CloseableIterable.transform(liveEntries(),\n+        e -> dropStats ? e.file().copyWithoutStats() : e.file().copy()).iterator();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQwMDk2NQ=="}, "originalCommit": {"oid": "0a707de27a639e1fd6d3ea61fd23e89b6304f0c6"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5NjEyNzc1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/iceberg/FilteredManifest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxODoxOTo0OVrOFiMo-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxODoxOTo0OVrOFiMo-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQwMzAwMg==", "bodyText": "I like how straight-forward this is now.", "url": "https://github.com/apache/iceberg/pull/735#discussion_r371403002", "createdAt": "2020-01-27T18:19:49Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/FilteredManifest.java", "diffHunk": "@@ -193,4 +164,29 @@ private InclusiveMetricsEvaluator metricsEvaluator() {\n     }\n     return lazyMetricsEvaluator;\n   }\n+\n+  private boolean requireStatsProjection() {\n+    // Make sure we have all stats columns for metrics evaluator\n+    return rowFilter != Expressions.alwaysTrue() &&\n+        !columns.containsAll(ManifestReader.ALL_COLUMNS) &&\n+        !columns.containsAll(STATS_COLUMNS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a707de27a639e1fd6d3ea61fd23e89b6304f0c6"}, "originalPosition": 91}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2979, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}