{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMwNjYxMzg5", "number": 1857, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMDo1Nzo1MVrOFA-ebA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwMDowMjo0MVrOFCqHVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NTY3OTE2OnYy", "diffSide": "RIGHT", "path": "spark2/src/main/java/org/apache/iceberg/spark/SparkFilters.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMDo1Nzo1MVrOH_hweQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNlQwMToxNzozMVrOIADdsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM3NTQxNw==", "bodyText": "why is this not directly inside Expressions.equal, so we can avoid duplication between spark 2 and 3?", "url": "https://github.com/apache/iceberg/pull/1857#discussion_r536375417", "createdAt": "2020-12-04T20:57:51Z", "author": {"login": "jackye1995"}, "path": "spark2/src/main/java/org/apache/iceberg/spark/SparkFilters.java", "diffHunk": "@@ -113,13 +115,13 @@ public static Expression convert(Filter filter) {\n             // comparison with null in normal equality is always null. this is probably a mistake.\n             Preconditions.checkNotNull(eq.value(),\n                 \"Expression is always false (eq is not null-safe): %s\", filter);\n-            return equal(eq.attribute(), convertLiteral(eq.value()));\n+            return handleEqual(eq.attribute(), eq.value());\n           } else {\n             EqualNullSafe eq = (EqualNullSafe) filter;\n             if (eq.value() == null) {\n               return isNull(eq.attribute());\n             } else {\n-              return equal(eq.attribute(), convertLiteral(eq.value()));\n+              return handleEqual(eq.attribute(), eq.value());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "445ee6db3bec3086a4bccf99de18b8bc79f246b7"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQyOTIyMw==", "bodyText": "I thought to reject NaN in any predicate and let SparkFilters to do rewrites was the conclusion we reached in this thread?", "url": "https://github.com/apache/iceberg/pull/1857#discussion_r536429223", "createdAt": "2020-12-04T22:48:21Z", "author": {"login": "yyanyy"}, "path": "spark2/src/main/java/org/apache/iceberg/spark/SparkFilters.java", "diffHunk": "@@ -113,13 +115,13 @@ public static Expression convert(Filter filter) {\n             // comparison with null in normal equality is always null. this is probably a mistake.\n             Preconditions.checkNotNull(eq.value(),\n                 \"Expression is always false (eq is not null-safe): %s\", filter);\n-            return equal(eq.attribute(), convertLiteral(eq.value()));\n+            return handleEqual(eq.attribute(), eq.value());\n           } else {\n             EqualNullSafe eq = (EqualNullSafe) filter;\n             if (eq.value() == null) {\n               return isNull(eq.attribute());\n             } else {\n-              return equal(eq.attribute(), convertLiteral(eq.value()));\n+              return handleEqual(eq.attribute(), eq.value());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM3NTQxNw=="}, "originalCommit": {"oid": "445ee6db3bec3086a4bccf99de18b8bc79f246b7"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjkyNzY2Ng==", "bodyText": "Yes, I agree. Rewriting filters should be done in translation to Iceberg so that we have simpler behavior and strong assumptions.", "url": "https://github.com/apache/iceberg/pull/1857#discussion_r536927666", "createdAt": "2020-12-06T01:17:31Z", "author": {"login": "rdblue"}, "path": "spark2/src/main/java/org/apache/iceberg/spark/SparkFilters.java", "diffHunk": "@@ -113,13 +115,13 @@ public static Expression convert(Filter filter) {\n             // comparison with null in normal equality is always null. this is probably a mistake.\n             Preconditions.checkNotNull(eq.value(),\n                 \"Expression is always false (eq is not null-safe): %s\", filter);\n-            return equal(eq.attribute(), convertLiteral(eq.value()));\n+            return handleEqual(eq.attribute(), eq.value());\n           } else {\n             EqualNullSafe eq = (EqualNullSafe) filter;\n             if (eq.value() == null) {\n               return isNull(eq.attribute());\n             } else {\n-              return equal(eq.attribute(), convertLiteral(eq.value()));\n+              return handleEqual(eq.attribute(), eq.value());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM3NTQxNw=="}, "originalCommit": {"oid": "445ee6db3bec3086a4bccf99de18b8bc79f246b7"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NTY5MzA5OnYy", "diffSide": "RIGHT", "path": "spark3/src/test/java/org/apache/iceberg/spark/sql/TestSelect.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMTowMTo1NVrOH_h4ZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwMjozMjo0M1rOIBEFKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM3NzQ0NQ==", "bodyText": "I think we should also try to test it for spark2, maybe update some tests in TestReadProjection?", "url": "https://github.com/apache/iceberg/pull/1857#discussion_r536377445", "createdAt": "2020-12-04T21:01:55Z", "author": {"login": "jackye1995"}, "path": "spark3/src/test/java/org/apache/iceberg/spark/sql/TestSelect.java", "diffHunk": "@@ -49,8 +49,8 @@ public TestSelect(String catalogName, String implementation, Map<String, String>\n ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "445ee6db3bec3086a4bccf99de18b8bc79f246b7"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQzMDI2Ng==", "bodyText": "Yeah I actually also spent some time on this but wasn't able to find a good place to add in spark2, and later gave up thinking that the added logic was relatively simple anyway. To me TestReadProjection is more about testing projection which is not what we are doing. I guess I'll create a TestSelect in spark3 test suite and duplicate this class then.", "url": "https://github.com/apache/iceberg/pull/1857#discussion_r536430266", "createdAt": "2020-12-04T22:51:04Z", "author": {"login": "yyanyy"}, "path": "spark3/src/test/java/org/apache/iceberg/spark/sql/TestSelect.java", "diffHunk": "@@ -49,8 +49,8 @@ public TestSelect(String catalogName, String implementation, Map<String, String>\n ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM3NzQ0NQ=="}, "originalCommit": {"oid": "445ee6db3bec3086a4bccf99de18b8bc79f246b7"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk4NjM0Nw==", "bodyText": "Added a TestSelect in spark2 by basically duplicating logic from the same class in spark3; although apart from basic sanity testing I'm not sure how helpful the tests are as some of the logic for examine pushed-down filters only exist in spark3...", "url": "https://github.com/apache/iceberg/pull/1857#discussion_r537986347", "createdAt": "2020-12-08T02:32:43Z", "author": {"login": "yyanyy"}, "path": "spark3/src/test/java/org/apache/iceberg/spark/sql/TestSelect.java", "diffHunk": "@@ -49,8 +49,8 @@ public TestSelect(String catalogName, String implementation, Map<String, String>\n ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM3NzQ0NQ=="}, "originalCommit": {"oid": "445ee6db3bec3086a4bccf99de18b8bc79f246b7"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2OTU5NzE1OnYy", "diffSide": "RIGHT", "path": "spark2/src/main/java/org/apache/iceberg/spark/SparkFilters.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNlQwMToxODowN1rOIADeCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNlQwMToxODowN1rOIADeCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjkyNzc1NA==", "bodyText": "This should be moved into the else block because literal should not allow creating a NaN literal.", "url": "https://github.com/apache/iceberg/pull/1857#discussion_r536927754", "createdAt": "2020-12-06T01:18:07Z", "author": {"login": "rdblue"}, "path": "spark2/src/main/java/org/apache/iceberg/spark/SparkFilters.java", "diffHunk": "@@ -177,4 +179,13 @@ private static Object convertLiteral(Object value) {\n     }\n     return value;\n   }\n+\n+  private static Expression handleEqual(String attribute, Object value) {\n+    Object literal = convertLiteral(value);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "445ee6db3bec3086a4bccf99de18b8bc79f246b7"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MzI5NzE5OnYy", "diffSide": "RIGHT", "path": "spark3/src/test/java/org/apache/iceberg/spark/sql/TestSelect.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQyMzo1NjozMVrOIB7z0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwMToxNToxMlrOICw4fw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg5OTQxMA==", "bodyText": "Shouldn't this be is_nan(float) instead of = NaN?", "url": "https://github.com/apache/iceberg/pull/1857#discussion_r538899410", "createdAt": "2020-12-08T23:56:31Z", "author": {"login": "rdblue"}, "path": "spark3/src/test/java/org/apache/iceberg/spark/sql/TestSelect.java", "diffHunk": "@@ -63,11 +63,25 @@ public void removeTables() {\n \n   @Test\n   public void testSelect() {\n-    List<Object[]> expected = ImmutableList.of(row(1L, \"a\"), row(2L, \"b\"), row(3L, \"c\"));\n+    List<Object[]> expected = ImmutableList.of(\n+        row(1L, \"a\", 1.0F), row(2L, \"b\", 2.0F), row(3L, \"c\", Float.NaN));\n \n     assertEquals(\"Should return all expected rows\", expected, sql(\"SELECT * FROM %s\", tableName));\n   }\n \n+  @Test\n+  public void testSelectRewrite() {\n+    List<Object[]> expected = ImmutableList.of(row(3L, \"c\", Float.NaN));\n+\n+    assertEquals(\"Should return all expected rows\", expected,\n+        sql(\"SELECT * FROM %s where float = float('NaN')\", tableName));\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should push down expected filter\",\n+        \"(float IS NOT NULL AND float = NaN)\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "730ce5b791ea775b04870189940e18014211fb59"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY5MDc5OA==", "bodyText": "This is because in DescribeExpressionVisitor  we translate is_nan to = NaN in here. Do you want me to change this to is_nan(float)?", "url": "https://github.com/apache/iceberg/pull/1857#discussion_r539690798", "createdAt": "2020-12-09T22:19:42Z", "author": {"login": "yyanyy"}, "path": "spark3/src/test/java/org/apache/iceberg/spark/sql/TestSelect.java", "diffHunk": "@@ -63,11 +63,25 @@ public void removeTables() {\n \n   @Test\n   public void testSelect() {\n-    List<Object[]> expected = ImmutableList.of(row(1L, \"a\"), row(2L, \"b\"), row(3L, \"c\"));\n+    List<Object[]> expected = ImmutableList.of(\n+        row(1L, \"a\", 1.0F), row(2L, \"b\", 2.0F), row(3L, \"c\", Float.NaN));\n \n     assertEquals(\"Should return all expected rows\", expected, sql(\"SELECT * FROM %s\", tableName));\n   }\n \n+  @Test\n+  public void testSelectRewrite() {\n+    List<Object[]> expected = ImmutableList.of(row(3L, \"c\", Float.NaN));\n+\n+    assertEquals(\"Should return all expected rows\", expected,\n+        sql(\"SELECT * FROM %s where float = float('NaN')\", tableName));\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should push down expected filter\",\n+        \"(float IS NOT NULL AND float = NaN)\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg5OTQxMA=="}, "originalCommit": {"oid": "730ce5b791ea775b04870189940e18014211fb59"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc2ODk1OQ==", "bodyText": "Yes, I think so. The description shouldn't produce a predicate that we don't support!", "url": "https://github.com/apache/iceberg/pull/1857#discussion_r539768959", "createdAt": "2020-12-10T01:15:12Z", "author": {"login": "rdblue"}, "path": "spark3/src/test/java/org/apache/iceberg/spark/sql/TestSelect.java", "diffHunk": "@@ -63,11 +63,25 @@ public void removeTables() {\n \n   @Test\n   public void testSelect() {\n-    List<Object[]> expected = ImmutableList.of(row(1L, \"a\"), row(2L, \"b\"), row(3L, \"c\"));\n+    List<Object[]> expected = ImmutableList.of(\n+        row(1L, \"a\", 1.0F), row(2L, \"b\", 2.0F), row(3L, \"c\", Float.NaN));\n \n     assertEquals(\"Should return all expected rows\", expected, sql(\"SELECT * FROM %s\", tableName));\n   }\n \n+  @Test\n+  public void testSelectRewrite() {\n+    List<Object[]> expected = ImmutableList.of(row(3L, \"c\", Float.NaN));\n+\n+    assertEquals(\"Should return all expected rows\", expected,\n+        sql(\"SELECT * FROM %s where float = float('NaN')\", tableName));\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should push down expected filter\",\n+        \"(float IS NOT NULL AND float = NaN)\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg5OTQxMA=="}, "originalCommit": {"oid": "730ce5b791ea775b04870189940e18014211fb59"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MzMwMzI4OnYy", "diffSide": "RIGHT", "path": "spark2/src/test/java/org/apache/iceberg/spark/source/TestSelect.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQyMzo1ODozOVrOIB73Hw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQyMzo1Mzo0N1rOIDi1Cw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkwMDI1NQ==", "bodyText": "Shouldn't this validate more than just the number of scans?", "url": "https://github.com/apache/iceberg/pull/1857#discussion_r538900255", "createdAt": "2020-12-08T23:58:39Z", "author": {"login": "rdblue"}, "path": "spark2/src/test/java/org/apache/iceberg/spark/source/TestSelect.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.source;\n+\n+import java.io.File;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.events.Listeners;\n+import org.apache.iceberg.events.ScanEvent;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.hadoop.HadoopTables;\n+import org.apache.iceberg.relocated.com.google.common.base.Objects;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableList;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.types.Types;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SparkSession;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import static org.apache.iceberg.types.Types.NestedField.optional;\n+\n+public class TestSelect {\n+  private static final HadoopTables TABLES = new HadoopTables(new Configuration());\n+  private static final Schema SCHEMA = new Schema(\n+      optional(1, \"id\", Types.IntegerType.get()),\n+      optional(2, \"data\", Types.StringType.get()),\n+      optional(3, \"doubleVal\", Types.DoubleType.get())\n+  );\n+\n+  private static SparkSession spark;\n+\n+  private static int scanEventCount = 0;\n+  private static ScanEvent lastScanEvent = null;\n+\n+  private Table table;\n+\n+  static {\n+    Listeners.register(event -> {\n+      scanEventCount += 1;\n+      lastScanEvent = event;\n+    }, ScanEvent.class);\n+  }\n+\n+  @BeforeClass\n+  public static void startSpark() {\n+    spark = SparkSession.builder()\n+        .master(\"local[2]\")\n+        .getOrCreate();\n+  }\n+\n+  @AfterClass\n+  public static void stopSpark() {\n+    SparkSession currentSpark = spark;\n+    spark = null;\n+    currentSpark.stop();\n+  }\n+\n+  @Rule\n+  public TemporaryFolder temp = new TemporaryFolder();\n+\n+  private String tableLocation = null;\n+\n+  @Before\n+  public void init() throws Exception {\n+    File tableDir = temp.newFolder();\n+    this.tableLocation = tableDir.toURI().toString();\n+\n+    table = TABLES.create(SCHEMA, tableLocation);\n+\n+    List<Record> rows = Lists.newArrayList(\n+        new Record(1, \"a\", 1.0),\n+        new Record(2, \"b\", 2.0),\n+        new Record(3, \"c\", Double.NaN)\n+    );\n+\n+    Dataset<Row> df = spark.createDataFrame(rows, Record.class);\n+\n+    df.select(\"id\", \"data\", \"doubleVal\").write()\n+        .format(\"iceberg\")\n+        .mode(\"append\")\n+        .save(tableLocation);\n+\n+    table.refresh();\n+\n+    Dataset<Row> results = spark.read()\n+        .format(\"iceberg\")\n+        .load(tableLocation);\n+    results.createOrReplaceTempView(\"table\");\n+\n+    scanEventCount = 0;\n+    lastScanEvent = null;\n+  }\n+\n+  @Test\n+  public void testSelect() {\n+    List<Record> expected = ImmutableList.of(\n+        new Record(1, \"a\", 1.0), new Record(2, \"b\", 2.0), new Record(3, \"c\", Double.NaN));\n+\n+    Assert.assertEquals(\"Should return all expected rows\", expected, sql(\"select * from table\"));\n+  }\n+\n+  @Test\n+  public void testSelectRewrite() {\n+    List<Record> expected = ImmutableList.of(new Record(3, \"c\", Double.NaN));\n+\n+    Assert.assertEquals(\"Should return all expected rows\", expected,\n+        sql(\"SELECT * FROM table where doubleVal = double('NaN')\"));\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "730ce5b791ea775b04870189940e18014211fb59"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY5MDg1NA==", "bodyText": "Yes, sorry I forgot to revisit this after cleaning up other changes. Since in spark2 we don't have Spark3Util.describe() I wasn't sure to which level we want to assert the expression, so that we can still have test coverage without being too coupled with internal implementation. Let me know how you think the updated test is!", "url": "https://github.com/apache/iceberg/pull/1857#discussion_r539690854", "createdAt": "2020-12-09T22:19:48Z", "author": {"login": "yyanyy"}, "path": "spark2/src/test/java/org/apache/iceberg/spark/source/TestSelect.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.source;\n+\n+import java.io.File;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.events.Listeners;\n+import org.apache.iceberg.events.ScanEvent;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.hadoop.HadoopTables;\n+import org.apache.iceberg.relocated.com.google.common.base.Objects;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableList;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.types.Types;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SparkSession;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import static org.apache.iceberg.types.Types.NestedField.optional;\n+\n+public class TestSelect {\n+  private static final HadoopTables TABLES = new HadoopTables(new Configuration());\n+  private static final Schema SCHEMA = new Schema(\n+      optional(1, \"id\", Types.IntegerType.get()),\n+      optional(2, \"data\", Types.StringType.get()),\n+      optional(3, \"doubleVal\", Types.DoubleType.get())\n+  );\n+\n+  private static SparkSession spark;\n+\n+  private static int scanEventCount = 0;\n+  private static ScanEvent lastScanEvent = null;\n+\n+  private Table table;\n+\n+  static {\n+    Listeners.register(event -> {\n+      scanEventCount += 1;\n+      lastScanEvent = event;\n+    }, ScanEvent.class);\n+  }\n+\n+  @BeforeClass\n+  public static void startSpark() {\n+    spark = SparkSession.builder()\n+        .master(\"local[2]\")\n+        .getOrCreate();\n+  }\n+\n+  @AfterClass\n+  public static void stopSpark() {\n+    SparkSession currentSpark = spark;\n+    spark = null;\n+    currentSpark.stop();\n+  }\n+\n+  @Rule\n+  public TemporaryFolder temp = new TemporaryFolder();\n+\n+  private String tableLocation = null;\n+\n+  @Before\n+  public void init() throws Exception {\n+    File tableDir = temp.newFolder();\n+    this.tableLocation = tableDir.toURI().toString();\n+\n+    table = TABLES.create(SCHEMA, tableLocation);\n+\n+    List<Record> rows = Lists.newArrayList(\n+        new Record(1, \"a\", 1.0),\n+        new Record(2, \"b\", 2.0),\n+        new Record(3, \"c\", Double.NaN)\n+    );\n+\n+    Dataset<Row> df = spark.createDataFrame(rows, Record.class);\n+\n+    df.select(\"id\", \"data\", \"doubleVal\").write()\n+        .format(\"iceberg\")\n+        .mode(\"append\")\n+        .save(tableLocation);\n+\n+    table.refresh();\n+\n+    Dataset<Row> results = spark.read()\n+        .format(\"iceberg\")\n+        .load(tableLocation);\n+    results.createOrReplaceTempView(\"table\");\n+\n+    scanEventCount = 0;\n+    lastScanEvent = null;\n+  }\n+\n+  @Test\n+  public void testSelect() {\n+    List<Record> expected = ImmutableList.of(\n+        new Record(1, \"a\", 1.0), new Record(2, \"b\", 2.0), new Record(3, \"c\", Double.NaN));\n+\n+    Assert.assertEquals(\"Should return all expected rows\", expected, sql(\"select * from table\"));\n+  }\n+\n+  @Test\n+  public void testSelectRewrite() {\n+    List<Record> expected = ImmutableList.of(new Record(3, \"c\", Double.NaN));\n+\n+    Assert.assertEquals(\"Should return all expected rows\", expected,\n+        sql(\"SELECT * FROM table where doubleVal = double('NaN')\"));\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkwMDI1NQ=="}, "originalCommit": {"oid": "730ce5b791ea775b04870189940e18014211fb59"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU4NzI3NQ==", "bodyText": "Looks good!", "url": "https://github.com/apache/iceberg/pull/1857#discussion_r540587275", "createdAt": "2020-12-10T23:53:47Z", "author": {"login": "rdblue"}, "path": "spark2/src/test/java/org/apache/iceberg/spark/source/TestSelect.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.source;\n+\n+import java.io.File;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.events.Listeners;\n+import org.apache.iceberg.events.ScanEvent;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.hadoop.HadoopTables;\n+import org.apache.iceberg.relocated.com.google.common.base.Objects;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableList;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.types.Types;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SparkSession;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import static org.apache.iceberg.types.Types.NestedField.optional;\n+\n+public class TestSelect {\n+  private static final HadoopTables TABLES = new HadoopTables(new Configuration());\n+  private static final Schema SCHEMA = new Schema(\n+      optional(1, \"id\", Types.IntegerType.get()),\n+      optional(2, \"data\", Types.StringType.get()),\n+      optional(3, \"doubleVal\", Types.DoubleType.get())\n+  );\n+\n+  private static SparkSession spark;\n+\n+  private static int scanEventCount = 0;\n+  private static ScanEvent lastScanEvent = null;\n+\n+  private Table table;\n+\n+  static {\n+    Listeners.register(event -> {\n+      scanEventCount += 1;\n+      lastScanEvent = event;\n+    }, ScanEvent.class);\n+  }\n+\n+  @BeforeClass\n+  public static void startSpark() {\n+    spark = SparkSession.builder()\n+        .master(\"local[2]\")\n+        .getOrCreate();\n+  }\n+\n+  @AfterClass\n+  public static void stopSpark() {\n+    SparkSession currentSpark = spark;\n+    spark = null;\n+    currentSpark.stop();\n+  }\n+\n+  @Rule\n+  public TemporaryFolder temp = new TemporaryFolder();\n+\n+  private String tableLocation = null;\n+\n+  @Before\n+  public void init() throws Exception {\n+    File tableDir = temp.newFolder();\n+    this.tableLocation = tableDir.toURI().toString();\n+\n+    table = TABLES.create(SCHEMA, tableLocation);\n+\n+    List<Record> rows = Lists.newArrayList(\n+        new Record(1, \"a\", 1.0),\n+        new Record(2, \"b\", 2.0),\n+        new Record(3, \"c\", Double.NaN)\n+    );\n+\n+    Dataset<Row> df = spark.createDataFrame(rows, Record.class);\n+\n+    df.select(\"id\", \"data\", \"doubleVal\").write()\n+        .format(\"iceberg\")\n+        .mode(\"append\")\n+        .save(tableLocation);\n+\n+    table.refresh();\n+\n+    Dataset<Row> results = spark.read()\n+        .format(\"iceberg\")\n+        .load(tableLocation);\n+    results.createOrReplaceTempView(\"table\");\n+\n+    scanEventCount = 0;\n+    lastScanEvent = null;\n+  }\n+\n+  @Test\n+  public void testSelect() {\n+    List<Record> expected = ImmutableList.of(\n+        new Record(1, \"a\", 1.0), new Record(2, \"b\", 2.0), new Record(3, \"c\", Double.NaN));\n+\n+    Assert.assertEquals(\"Should return all expected rows\", expected, sql(\"select * from table\"));\n+  }\n+\n+  @Test\n+  public void testSelectRewrite() {\n+    List<Record> expected = ImmutableList.of(new Record(3, \"c\", Double.NaN));\n+\n+    Assert.assertEquals(\"Should return all expected rows\", expected,\n+        sql(\"SELECT * FROM table where doubleVal = double('NaN')\"));\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkwMDI1NQ=="}, "originalCommit": {"oid": "730ce5b791ea775b04870189940e18014211fb59"}, "originalPosition": 135}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MzMxNDc5OnYy", "diffSide": "RIGHT", "path": "spark2/src/test/java/org/apache/iceberg/spark/source/TestSelect.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwMDowMjo0MVrOIB79Vg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQyMjoyMDowOVrOICsIYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkwMTg0Ng==", "bodyText": "This seems brittle because it uses types to place the results.\nOther tests use StructProjection and StructLikeSet for similar validations. The incoming row is wrapped to be a StructLike and added to a StructLikeSet based on the expected schema. Then another StructLikeSet is created with the expected rows, which are projected using StructProjection and the expected schema. That is a cleaner way to do this, I think.", "url": "https://github.com/apache/iceberg/pull/1857#discussion_r538901846", "createdAt": "2020-12-09T00:02:41Z", "author": {"login": "rdblue"}, "path": "spark2/src/test/java/org/apache/iceberg/spark/source/TestSelect.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.source;\n+\n+import java.io.File;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.events.Listeners;\n+import org.apache.iceberg.events.ScanEvent;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.hadoop.HadoopTables;\n+import org.apache.iceberg.relocated.com.google.common.base.Objects;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableList;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.types.Types;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SparkSession;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import static org.apache.iceberg.types.Types.NestedField.optional;\n+\n+public class TestSelect {\n+  private static final HadoopTables TABLES = new HadoopTables(new Configuration());\n+  private static final Schema SCHEMA = new Schema(\n+      optional(1, \"id\", Types.IntegerType.get()),\n+      optional(2, \"data\", Types.StringType.get()),\n+      optional(3, \"doubleVal\", Types.DoubleType.get())\n+  );\n+\n+  private static SparkSession spark;\n+\n+  private static int scanEventCount = 0;\n+  private static ScanEvent lastScanEvent = null;\n+\n+  private Table table;\n+\n+  static {\n+    Listeners.register(event -> {\n+      scanEventCount += 1;\n+      lastScanEvent = event;\n+    }, ScanEvent.class);\n+  }\n+\n+  @BeforeClass\n+  public static void startSpark() {\n+    spark = SparkSession.builder()\n+        .master(\"local[2]\")\n+        .getOrCreate();\n+  }\n+\n+  @AfterClass\n+  public static void stopSpark() {\n+    SparkSession currentSpark = spark;\n+    spark = null;\n+    currentSpark.stop();\n+  }\n+\n+  @Rule\n+  public TemporaryFolder temp = new TemporaryFolder();\n+\n+  private String tableLocation = null;\n+\n+  @Before\n+  public void init() throws Exception {\n+    File tableDir = temp.newFolder();\n+    this.tableLocation = tableDir.toURI().toString();\n+\n+    table = TABLES.create(SCHEMA, tableLocation);\n+\n+    List<Record> rows = Lists.newArrayList(\n+        new Record(1, \"a\", 1.0),\n+        new Record(2, \"b\", 2.0),\n+        new Record(3, \"c\", Double.NaN)\n+    );\n+\n+    Dataset<Row> df = spark.createDataFrame(rows, Record.class);\n+\n+    df.select(\"id\", \"data\", \"doubleVal\").write()\n+        .format(\"iceberg\")\n+        .mode(\"append\")\n+        .save(tableLocation);\n+\n+    table.refresh();\n+\n+    Dataset<Row> results = spark.read()\n+        .format(\"iceberg\")\n+        .load(tableLocation);\n+    results.createOrReplaceTempView(\"table\");\n+\n+    scanEventCount = 0;\n+    lastScanEvent = null;\n+  }\n+\n+  @Test\n+  public void testSelect() {\n+    List<Record> expected = ImmutableList.of(\n+        new Record(1, \"a\", 1.0), new Record(2, \"b\", 2.0), new Record(3, \"c\", Double.NaN));\n+\n+    Assert.assertEquals(\"Should return all expected rows\", expected, sql(\"select * from table\"));\n+  }\n+\n+  @Test\n+  public void testSelectRewrite() {\n+    List<Record> expected = ImmutableList.of(new Record(3, \"c\", Double.NaN));\n+\n+    Assert.assertEquals(\"Should return all expected rows\", expected,\n+        sql(\"SELECT * FROM table where doubleVal = double('NaN')\"));\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+  }\n+\n+  @Test\n+  public void testProjection() {\n+    List<Record> expected = ImmutableList.of(\n+        new Record(1, null, null), new Record(2, null, null), new Record(3, null, null));\n+\n+    Assert.assertEquals(\"Should return all expected rows\", expected, sql(\"SELECT id FROM table\"));\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should not push down a filter\", Expressions.alwaysTrue(), lastScanEvent.filter());\n+    Assert.assertEquals(\"Should project only the id column\",\n+        table.schema().select(\"id\").asStruct(),\n+        lastScanEvent.projection().asStruct());\n+  }\n+\n+  @Test\n+  public void testExpressionPushdown() {\n+    List<Record> expected = ImmutableList.of(new Record(null, \"b\", null));\n+\n+    Assert.assertEquals(\"Should return all expected rows\", expected, sql(\"SELECT data FROM table WHERE id = 2\"));\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should project only id and data columns\",\n+        table.schema().select(\"id\", \"data\").asStruct(),\n+        lastScanEvent.projection().asStruct());\n+  }\n+\n+  private List<Record> sql(String str) {\n+    List<Row> rows = spark.sql(str).collectAsList();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "730ce5b791ea775b04870189940e18014211fb59"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkwMjI3Ng==", "bodyText": "Looks like this uses a Java bean record class, so you could also rely on Spark to convert to your record class, and then use a special comparison function to only compare expected columns.", "url": "https://github.com/apache/iceberg/pull/1857#discussion_r538902276", "createdAt": "2020-12-09T00:03:54Z", "author": {"login": "rdblue"}, "path": "spark2/src/test/java/org/apache/iceberg/spark/source/TestSelect.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.source;\n+\n+import java.io.File;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.events.Listeners;\n+import org.apache.iceberg.events.ScanEvent;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.hadoop.HadoopTables;\n+import org.apache.iceberg.relocated.com.google.common.base.Objects;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableList;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.types.Types;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SparkSession;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import static org.apache.iceberg.types.Types.NestedField.optional;\n+\n+public class TestSelect {\n+  private static final HadoopTables TABLES = new HadoopTables(new Configuration());\n+  private static final Schema SCHEMA = new Schema(\n+      optional(1, \"id\", Types.IntegerType.get()),\n+      optional(2, \"data\", Types.StringType.get()),\n+      optional(3, \"doubleVal\", Types.DoubleType.get())\n+  );\n+\n+  private static SparkSession spark;\n+\n+  private static int scanEventCount = 0;\n+  private static ScanEvent lastScanEvent = null;\n+\n+  private Table table;\n+\n+  static {\n+    Listeners.register(event -> {\n+      scanEventCount += 1;\n+      lastScanEvent = event;\n+    }, ScanEvent.class);\n+  }\n+\n+  @BeforeClass\n+  public static void startSpark() {\n+    spark = SparkSession.builder()\n+        .master(\"local[2]\")\n+        .getOrCreate();\n+  }\n+\n+  @AfterClass\n+  public static void stopSpark() {\n+    SparkSession currentSpark = spark;\n+    spark = null;\n+    currentSpark.stop();\n+  }\n+\n+  @Rule\n+  public TemporaryFolder temp = new TemporaryFolder();\n+\n+  private String tableLocation = null;\n+\n+  @Before\n+  public void init() throws Exception {\n+    File tableDir = temp.newFolder();\n+    this.tableLocation = tableDir.toURI().toString();\n+\n+    table = TABLES.create(SCHEMA, tableLocation);\n+\n+    List<Record> rows = Lists.newArrayList(\n+        new Record(1, \"a\", 1.0),\n+        new Record(2, \"b\", 2.0),\n+        new Record(3, \"c\", Double.NaN)\n+    );\n+\n+    Dataset<Row> df = spark.createDataFrame(rows, Record.class);\n+\n+    df.select(\"id\", \"data\", \"doubleVal\").write()\n+        .format(\"iceberg\")\n+        .mode(\"append\")\n+        .save(tableLocation);\n+\n+    table.refresh();\n+\n+    Dataset<Row> results = spark.read()\n+        .format(\"iceberg\")\n+        .load(tableLocation);\n+    results.createOrReplaceTempView(\"table\");\n+\n+    scanEventCount = 0;\n+    lastScanEvent = null;\n+  }\n+\n+  @Test\n+  public void testSelect() {\n+    List<Record> expected = ImmutableList.of(\n+        new Record(1, \"a\", 1.0), new Record(2, \"b\", 2.0), new Record(3, \"c\", Double.NaN));\n+\n+    Assert.assertEquals(\"Should return all expected rows\", expected, sql(\"select * from table\"));\n+  }\n+\n+  @Test\n+  public void testSelectRewrite() {\n+    List<Record> expected = ImmutableList.of(new Record(3, \"c\", Double.NaN));\n+\n+    Assert.assertEquals(\"Should return all expected rows\", expected,\n+        sql(\"SELECT * FROM table where doubleVal = double('NaN')\"));\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+  }\n+\n+  @Test\n+  public void testProjection() {\n+    List<Record> expected = ImmutableList.of(\n+        new Record(1, null, null), new Record(2, null, null), new Record(3, null, null));\n+\n+    Assert.assertEquals(\"Should return all expected rows\", expected, sql(\"SELECT id FROM table\"));\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should not push down a filter\", Expressions.alwaysTrue(), lastScanEvent.filter());\n+    Assert.assertEquals(\"Should project only the id column\",\n+        table.schema().select(\"id\").asStruct(),\n+        lastScanEvent.projection().asStruct());\n+  }\n+\n+  @Test\n+  public void testExpressionPushdown() {\n+    List<Record> expected = ImmutableList.of(new Record(null, \"b\", null));\n+\n+    Assert.assertEquals(\"Should return all expected rows\", expected, sql(\"SELECT data FROM table WHERE id = 2\"));\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should project only id and data columns\",\n+        table.schema().select(\"id\", \"data\").asStruct(),\n+        lastScanEvent.projection().asStruct());\n+  }\n+\n+  private List<Record> sql(String str) {\n+    List<Row> rows = spark.sql(str).collectAsList();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkwMTg0Ng=="}, "originalCommit": {"oid": "730ce5b791ea775b04870189940e18014211fb59"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY5MTEwNQ==", "bodyText": "Sounds good, I wanted to scope this Record class to only be used for this class' use cases but this is definitely not clean. I changed this to use Spark for converting to Java bean, but encountered a similar issue as described in this post that when projecting a subset of columns, conversion doesn't work due to missing expected columns. Since in this class I'm just projecting one column with primitive type, I convert data frame into their specific classes instead. Please let me know if you know better ways of doing this!", "url": "https://github.com/apache/iceberg/pull/1857#discussion_r539691105", "createdAt": "2020-12-09T22:20:09Z", "author": {"login": "yyanyy"}, "path": "spark2/src/test/java/org/apache/iceberg/spark/source/TestSelect.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.source;\n+\n+import java.io.File;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.events.Listeners;\n+import org.apache.iceberg.events.ScanEvent;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.hadoop.HadoopTables;\n+import org.apache.iceberg.relocated.com.google.common.base.Objects;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableList;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.types.Types;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SparkSession;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import static org.apache.iceberg.types.Types.NestedField.optional;\n+\n+public class TestSelect {\n+  private static final HadoopTables TABLES = new HadoopTables(new Configuration());\n+  private static final Schema SCHEMA = new Schema(\n+      optional(1, \"id\", Types.IntegerType.get()),\n+      optional(2, \"data\", Types.StringType.get()),\n+      optional(3, \"doubleVal\", Types.DoubleType.get())\n+  );\n+\n+  private static SparkSession spark;\n+\n+  private static int scanEventCount = 0;\n+  private static ScanEvent lastScanEvent = null;\n+\n+  private Table table;\n+\n+  static {\n+    Listeners.register(event -> {\n+      scanEventCount += 1;\n+      lastScanEvent = event;\n+    }, ScanEvent.class);\n+  }\n+\n+  @BeforeClass\n+  public static void startSpark() {\n+    spark = SparkSession.builder()\n+        .master(\"local[2]\")\n+        .getOrCreate();\n+  }\n+\n+  @AfterClass\n+  public static void stopSpark() {\n+    SparkSession currentSpark = spark;\n+    spark = null;\n+    currentSpark.stop();\n+  }\n+\n+  @Rule\n+  public TemporaryFolder temp = new TemporaryFolder();\n+\n+  private String tableLocation = null;\n+\n+  @Before\n+  public void init() throws Exception {\n+    File tableDir = temp.newFolder();\n+    this.tableLocation = tableDir.toURI().toString();\n+\n+    table = TABLES.create(SCHEMA, tableLocation);\n+\n+    List<Record> rows = Lists.newArrayList(\n+        new Record(1, \"a\", 1.0),\n+        new Record(2, \"b\", 2.0),\n+        new Record(3, \"c\", Double.NaN)\n+    );\n+\n+    Dataset<Row> df = spark.createDataFrame(rows, Record.class);\n+\n+    df.select(\"id\", \"data\", \"doubleVal\").write()\n+        .format(\"iceberg\")\n+        .mode(\"append\")\n+        .save(tableLocation);\n+\n+    table.refresh();\n+\n+    Dataset<Row> results = spark.read()\n+        .format(\"iceberg\")\n+        .load(tableLocation);\n+    results.createOrReplaceTempView(\"table\");\n+\n+    scanEventCount = 0;\n+    lastScanEvent = null;\n+  }\n+\n+  @Test\n+  public void testSelect() {\n+    List<Record> expected = ImmutableList.of(\n+        new Record(1, \"a\", 1.0), new Record(2, \"b\", 2.0), new Record(3, \"c\", Double.NaN));\n+\n+    Assert.assertEquals(\"Should return all expected rows\", expected, sql(\"select * from table\"));\n+  }\n+\n+  @Test\n+  public void testSelectRewrite() {\n+    List<Record> expected = ImmutableList.of(new Record(3, \"c\", Double.NaN));\n+\n+    Assert.assertEquals(\"Should return all expected rows\", expected,\n+        sql(\"SELECT * FROM table where doubleVal = double('NaN')\"));\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+  }\n+\n+  @Test\n+  public void testProjection() {\n+    List<Record> expected = ImmutableList.of(\n+        new Record(1, null, null), new Record(2, null, null), new Record(3, null, null));\n+\n+    Assert.assertEquals(\"Should return all expected rows\", expected, sql(\"SELECT id FROM table\"));\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should not push down a filter\", Expressions.alwaysTrue(), lastScanEvent.filter());\n+    Assert.assertEquals(\"Should project only the id column\",\n+        table.schema().select(\"id\").asStruct(),\n+        lastScanEvent.projection().asStruct());\n+  }\n+\n+  @Test\n+  public void testExpressionPushdown() {\n+    List<Record> expected = ImmutableList.of(new Record(null, \"b\", null));\n+\n+    Assert.assertEquals(\"Should return all expected rows\", expected, sql(\"SELECT data FROM table WHERE id = 2\"));\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should project only id and data columns\",\n+        table.schema().select(\"id\", \"data\").asStruct(),\n+        lastScanEvent.projection().asStruct());\n+  }\n+\n+  private List<Record> sql(String str) {\n+    List<Row> rows = spark.sql(str).collectAsList();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkwMTg0Ng=="}, "originalCommit": {"oid": "730ce5b791ea775b04870189940e18014211fb59"}, "originalPosition": 165}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3208, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}