{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDcyODMxNDc1", "number": 1373, "title": "API: Implement SortOrder", "bodyText": "This PR extends Iceberg metadata with a sort order and is supposed to replace the work in #589.\nThe API currently looks like this:\nSortOrder.builderFor(schema)\n    .withOrderId(3)\n    .asc(\"y\", NullOrder.NULLS_FIRST)\n    .desc(Expressions.bucket(\"z\", 4), NullOrder.NULLS_LAST)\n    .build();\n\nThe underlying representation looks like this:\n   \"default-sort-order-id\": 3,\n   \"sort-orders\": [\n      {\n         \"order-id\": 3,\n         \"fields\": [\n            {\n               \"transform\": \"identity\",\n               \"source-id\": 2,\n               \"direction\": \"asc\",\n               \"null-order\": \"nulls-first\"\n            },\n            {\n               \"transform\": \"bucket[4]\",\n               \"source-id\": 3,\n               \"direction\": \"desc\",\n               \"null-order\": \"nulls-last\"\n            }\n         ]\n      }\n   ],\n\nOpen items\n\nConsider switching to a builder patter in Catalog.\nWhether to reserve id 0 for the unsorted order.\nCase sensitivity when binding Terms in Builder.\n\nFollow-up items\n\nAssociate data and delete files with sort order id.\nSpec update.\nAn API for updating the current sort order in a table.", "createdAt": "2020-08-24T23:06:36Z", "url": "https://github.com/apache/iceberg/pull/1373", "merged": true, "mergeCommit": {"oid": "454101c3573acb9cd94d6d9a306ed99a5a324ed9"}, "closed": true, "closedAt": "2020-09-04T05:48:02Z", "author": {"login": "aokolnychyi"}, "timelineItems": {"totalCount": 29, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdCK64fgFqTQ3Mzk4NzExMw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdFeF2gAH2gAyNDcyODMxNDc1OjQ0OWRkMjM4NjcyZTFjMzViMjdjOWQzZDc0ZDQ1MGQzNGIyN2U5NTk=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczOTg3MTEz", "url": "https://github.com/apache/iceberg/pull/1373#pullrequestreview-473987113", "createdAt": "2020-08-24T23:08:27Z", "commit": {"oid": "f7156637202b839243a6bddde9229ab8c7be93f7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQyMzowODoyN1rOHF5UHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQyMzowODoyN1rOHF5UHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTk0Mzk2NA==", "bodyText": "I think matching the behavior in PartitionSpec is the most reasonable way.", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r475943964", "createdAt": "2020-08-24T23:08:27Z", "author": {"login": "aokolnychyi"}, "path": "api/src/main/java/org/apache/iceberg/SortOrder.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+import org.apache.iceberg.exceptions.ValidationException;\n+import org.apache.iceberg.expressions.BoundReference;\n+import org.apache.iceberg.expressions.BoundTerm;\n+import org.apache.iceberg.expressions.BoundTransform;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.expressions.Term;\n+import org.apache.iceberg.expressions.UnboundTerm;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableList;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.transforms.Transform;\n+import org.apache.iceberg.transforms.Transforms;\n+import org.apache.iceberg.types.Types;\n+\n+public class SortOrder implements Serializable {\n+  // TODO: shall we reserve 0 for the unsorted order? PartitionSpec does not guarantee it?\n+  private static final SortOrder UNSORTED_ORDER = new SortOrder(new Schema(), 0, Collections.emptyList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7156637202b839243a6bddde9229ab8c7be93f7"}, "originalPosition": 43}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczOTg3MzU2", "url": "https://github.com/apache/iceberg/pull/1373#pullrequestreview-473987356", "createdAt": "2020-08-24T23:09:08Z", "commit": {"oid": "f7156637202b839243a6bddde9229ab8c7be93f7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQyMzowOTowOVrOHF5V9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQyMzowOTowOVrOHF5V9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTk0NDQzOQ==", "bodyText": "This seems to get out of hand. We may want to switch to a builder here.", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r475944439", "createdAt": "2020-08-24T23:09:09Z", "author": {"login": "aokolnychyi"}, "path": "api/src/main/java/org/apache/iceberg/catalog/Catalog.java", "diffHunk": "@@ -58,9 +60,50 @@ Table createTable(\n       TableIdentifier identifier,\n       Schema schema,\n       PartitionSpec spec,\n+      SortOrder sortOrder,\n       String location,\n       Map<String, String> properties);\n \n+  /**\n+   * Create a table.\n+   *\n+   * @param identifier a table identifier\n+   * @param schema a schema\n+   * @param spec a partition spec\n+   * @param location a location for the table; leave null if unspecified\n+   * @param properties a string map of table properties\n+   * @return a Table instance\n+   * @throws AlreadyExistsException if the table already exists\n+   */\n+  default Table createTable(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7156637202b839243a6bddde9229ab8c7be93f7"}, "originalPosition": 35}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczOTg3ODE2", "url": "https://github.com/apache/iceberg/pull/1373#pullrequestreview-473987816", "createdAt": "2020-08-24T23:10:23Z", "commit": {"oid": "f7156637202b839243a6bddde9229ab8c7be93f7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQyMzoxMDoyM1rOHF5Zjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQyMzoxMDoyM1rOHF5Zjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTk0NTM1OA==", "bodyText": "This problem is not specific to SortOrder but also applies to PartitionSpec.", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r475945358", "createdAt": "2020-08-24T23:10:23Z", "author": {"login": "aokolnychyi"}, "path": "core/src/main/java/org/apache/iceberg/TableMetadata.java", "diffHunk": "@@ -94,9 +105,15 @@ static TableMetadata newTableMetadata(Schema schema,\n     }\n     PartitionSpec freshSpec = specBuilder.build();\n \n+    // TODO: case sensitivity", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7156637202b839243a6bddde9229ab8c7be93f7"}, "originalPosition": 50}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczOTg5MTY4", "url": "https://github.com/apache/iceberg/pull/1373#pullrequestreview-473989168", "createdAt": "2020-08-24T23:14:06Z", "commit": {"oid": "f7156637202b839243a6bddde9229ab8c7be93f7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQyMzoxNDowNlrOHF5j1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQyMzoxNDowNlrOHF5j1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTk0Nzk5MQ==", "bodyText": "I did not default the null order as the SQL standard does not define this. Spark and Presto, as well as RDBMs, use different default null orderings.", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r475947991", "createdAt": "2020-08-24T23:14:06Z", "author": {"login": "aokolnychyi"}, "path": "api/src/main/java/org/apache/iceberg/SortOrder.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+import org.apache.iceberg.exceptions.ValidationException;\n+import org.apache.iceberg.expressions.BoundReference;\n+import org.apache.iceberg.expressions.BoundTerm;\n+import org.apache.iceberg.expressions.BoundTransform;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.expressions.Term;\n+import org.apache.iceberg.expressions.UnboundTerm;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableList;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.transforms.Transform;\n+import org.apache.iceberg.transforms.Transforms;\n+import org.apache.iceberg.types.Types;\n+\n+public class SortOrder implements Serializable {\n+  // TODO: shall we reserve 0 for the unsorted order? PartitionSpec does not guarantee it?\n+  private static final SortOrder UNSORTED_ORDER = new SortOrder(new Schema(), 0, Collections.emptyList());\n+\n+  private final Schema schema;\n+  private final int orderId;\n+  private final SortField[] fields;\n+\n+  private transient volatile List<SortField> fieldList;\n+\n+  private SortOrder(Schema schema, int orderId, List<SortField> fields) {\n+    this.schema = schema;\n+    this.orderId = orderId;\n+    this.fields = fields.toArray(new SortField[0]);\n+  }\n+\n+  public Schema schema() {\n+    return schema;\n+  }\n+\n+  public int orderId() {\n+    return orderId;\n+  }\n+\n+  public List<SortField> fields() {\n+    return lazyFieldList();\n+  }\n+\n+  public boolean isUnsorted() {\n+    return fields.length < 1;\n+  }\n+\n+  public boolean satisfies(SortOrder anotherSortOrder) {\n+    // any ordering satisfies an unsorted ordering\n+    if (anotherSortOrder.isUnsorted()) {\n+      return true;\n+    }\n+\n+    // this ordering cannot satisfy an ordering with more sort fields\n+    if (anotherSortOrder.fields.length > fields.length) {\n+      return false;\n+    }\n+\n+    // this ordering has either more or the same number of sort fields\n+    return IntStream.range(0, anotherSortOrder.fields.length)\n+        .allMatch(index -> fields[index].equals(anotherSortOrder.fields[index]));\n+  }\n+\n+  public boolean sameOrder(SortOrder anotherSortOrder) {\n+    return Arrays.equals(fields, anotherSortOrder.fields);\n+  }\n+\n+  private List<SortField> lazyFieldList() {\n+    if (fieldList == null) {\n+      synchronized (this) {\n+        if (fieldList == null) {\n+          this.fieldList = ImmutableList.copyOf(fields);\n+        }\n+      }\n+    }\n+    return fieldList;\n+  }\n+\n+  @Override\n+  public String toString() {\n+    StringBuilder sb = new StringBuilder();\n+    sb.append(\"[\");\n+    for (SortField field : fields) {\n+      sb.append(\"\\n\");\n+      sb.append(\"  \").append(field);\n+    }\n+    if (fields.length > 0) {\n+      sb.append(\"\\n\");\n+    }\n+    sb.append(\"]\");\n+    return sb.toString();\n+  }\n+\n+  @Override\n+  public boolean equals(Object other) {\n+    if (this == other) {\n+      return true;\n+    } else if (other == null || getClass() != other.getClass()) {\n+      return false;\n+    }\n+\n+    SortOrder that = (SortOrder) other;\n+    return orderId == that.orderId && Arrays.equals(fields, that.fields);\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return 31 * Integer.hashCode(orderId) + Arrays.hashCode(fields);\n+  }\n+\n+  public static SortOrder unsorted() {\n+    return UNSORTED_ORDER;\n+  }\n+\n+  public static Builder builderFor(Schema schema) {\n+    return new Builder(schema);\n+  }\n+\n+  public static class Builder {\n+    private final Schema schema;\n+    private final List<SortField> fields = Lists.newArrayList();\n+    private int orderId = 0;\n+    private boolean caseSensitive = true;\n+\n+    private Builder(Schema schema) {\n+      this.schema = schema;\n+    }\n+\n+    public Builder asc(String name, NullOrder nullOrder) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7156637202b839243a6bddde9229ab8c7be93f7"}, "originalPosition": 154}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0NTI2MzY2", "url": "https://github.com/apache/iceberg/pull/1373#pullrequestreview-474526366", "createdAt": "2020-08-25T14:16:02Z", "commit": {"oid": "f7156637202b839243a6bddde9229ab8c7be93f7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNDoxNjowM1rOHGaQIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNDoxNjowM1rOHGaQIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ4MzYxNw==", "bodyText": "I've usually seen this with \"Locale.ROOT\" to avoid the Turkish issues, I assume English works as well?", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r476483617", "createdAt": "2020-08-25T14:16:03Z", "author": {"login": "RussellSpitzer"}, "path": "api/src/main/java/org/apache/iceberg/NullOrder.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import java.util.Locale;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+\n+public enum NullOrder {\n+  NULLS_FIRST(\"first\"), NULLS_LAST(\"last\");\n+\n+  private final String jsonValue;\n+\n+  NullOrder(String jsonValue) {\n+    this.jsonValue = jsonValue;\n+  }\n+\n+  public static NullOrder fromJsonValue(String jsonValue) {\n+    Preconditions.checkArgument(jsonValue != null, \"json value is null\");\n+    return NullOrder.valueOf(\"NULLS_\" + jsonValue.toUpperCase(Locale.ENGLISH));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7156637202b839243a6bddde9229ab8c7be93f7"}, "originalPosition": 36}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0NTUzMTg4", "url": "https://github.com/apache/iceberg/pull/1373#pullrequestreview-474553188", "createdAt": "2020-08-25T14:43:02Z", "commit": {"oid": "f7156637202b839243a6bddde9229ab8c7be93f7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNDo0MzowMlrOHGbh3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNDo0MzowMlrOHGbh3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjUwNDU0MQ==", "bodyText": "Could use guava Streams.zip here, skip a little bit of direct indexing but that's personal preference", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r476504541", "createdAt": "2020-08-25T14:43:02Z", "author": {"login": "RussellSpitzer"}, "path": "api/src/main/java/org/apache/iceberg/SortOrder.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+import org.apache.iceberg.exceptions.ValidationException;\n+import org.apache.iceberg.expressions.BoundReference;\n+import org.apache.iceberg.expressions.BoundTerm;\n+import org.apache.iceberg.expressions.BoundTransform;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.expressions.Term;\n+import org.apache.iceberg.expressions.UnboundTerm;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableList;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.transforms.Transform;\n+import org.apache.iceberg.transforms.Transforms;\n+import org.apache.iceberg.types.Types;\n+\n+public class SortOrder implements Serializable {\n+  // TODO: shall we reserve 0 for the unsorted order? PartitionSpec does not guarantee it?\n+  private static final SortOrder UNSORTED_ORDER = new SortOrder(new Schema(), 0, Collections.emptyList());\n+\n+  private final Schema schema;\n+  private final int orderId;\n+  private final SortField[] fields;\n+\n+  private transient volatile List<SortField> fieldList;\n+\n+  private SortOrder(Schema schema, int orderId, List<SortField> fields) {\n+    this.schema = schema;\n+    this.orderId = orderId;\n+    this.fields = fields.toArray(new SortField[0]);\n+  }\n+\n+  public Schema schema() {\n+    return schema;\n+  }\n+\n+  public int orderId() {\n+    return orderId;\n+  }\n+\n+  public List<SortField> fields() {\n+    return lazyFieldList();\n+  }\n+\n+  public boolean isUnsorted() {\n+    return fields.length < 1;\n+  }\n+\n+  public boolean satisfies(SortOrder anotherSortOrder) {\n+    // any ordering satisfies an unsorted ordering\n+    if (anotherSortOrder.isUnsorted()) {\n+      return true;\n+    }\n+\n+    // this ordering cannot satisfy an ordering with more sort fields\n+    if (anotherSortOrder.fields.length > fields.length) {\n+      return false;\n+    }\n+\n+    // this ordering has either more or the same number of sort fields\n+    return IntStream.range(0, anotherSortOrder.fields.length)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7156637202b839243a6bddde9229ab8c7be93f7"}, "originalPosition": 85}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0NjIzMjQz", "url": "https://github.com/apache/iceberg/pull/1373#pullrequestreview-474623243", "createdAt": "2020-08-25T15:56:07Z", "commit": {"oid": "f7156637202b839243a6bddde9229ab8c7be93f7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNTo1NjowN1rOHGexYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNTo1NjowN1rOHGexYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU1NzY2NQ==", "bodyText": "I think when we return a Map of common classes we should describe what they represent, the Integer keys here I assume are Field numbers right?", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r476557665", "createdAt": "2020-08-25T15:56:07Z", "author": {"login": "RussellSpitzer"}, "path": "api/src/main/java/org/apache/iceberg/Table.java", "diffHunk": "@@ -65,6 +65,20 @@\n    */\n   Map<Integer, PartitionSpec> specs();\n \n+  /**\n+   * Return the {@link SortOrder sort order} for this table.\n+   *\n+   * @return this table's sort order\n+   */\n+  SortOrder sortOrder();\n+\n+  /**\n+   * Return a map of {@link SortOrder sort orders} for this table.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7156637202b839243a6bddde9229ab8c7be93f7"}, "originalPosition": 12}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0Njk5MDc1", "url": "https://github.com/apache/iceberg/pull/1373#pullrequestreview-474699075", "createdAt": "2020-08-25T17:24:19Z", "commit": {"oid": "f7156637202b839243a6bddde9229ab8c7be93f7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNzoyNDoyMFrOHGiPmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNzoyNDoyMFrOHGiPmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjYxNDU1Mg==", "bodyText": "This block of changes 652 -668 Is confusing to me, could add some more comments? I'm mostly confused about when we add \"freshSortOrder\" , it looks like we ignore it entirely if an equivalent SortOrder is there?", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r476614552", "createdAt": "2020-08-25T17:24:20Z", "author": {"login": "RussellSpitzer"}, "path": "core/src/main/java/org/apache/iceberg/TableMetadata.java", "diffHunk": "@@ -598,20 +649,38 @@ public TableMetadata buildReplacement(Schema updatedSchema, PartitionSpec update\n       builder.add(freshSpec);\n     }\n \n+    // determine the next order id\n+    int maxOrderId = sortOrders.stream().mapToInt(SortOrder::orderId).max().orElse(INITIAL_SORT_ORDER_ID);\n+    int nextOrderId = maxOrderId + 1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7156637202b839243a6bddde9229ab8c7be93f7"}, "originalPosition": 258}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0NzAyNzEx", "url": "https://github.com/apache/iceberg/pull/1373#pullrequestreview-474702711", "createdAt": "2020-08-25T17:29:10Z", "commit": {"oid": "f7156637202b839243a6bddde9229ab8c7be93f7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNzoyOToxMFrOHGijxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNzoyOToxMFrOHGijxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjYxOTcxOA==", "bodyText": "Does this include tests for the serde to/from json?", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r476619718", "createdAt": "2020-08-25T17:29:10Z", "author": {"login": "RussellSpitzer"}, "path": "core/src/test/java/org/apache/iceberg/TestTableMetadata.java", "diffHunk": "@@ -35,6 +35,7 @@\n import org.apache.iceberg.TableMetadata.MetadataLogEntry;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7156637202b839243a6bddde9229ab8c7be93f7"}, "originalPosition": 1}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2MTM0NjQ1", "url": "https://github.com/apache/iceberg/pull/1373#pullrequestreview-476134645", "createdAt": "2020-08-26T23:43:57Z", "commit": {"oid": "453f49fc3d6643e8cd2ea17badb5df851b67c7b2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQyMzo0Mzo1N1rOHHkL2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQyMzo0Mzo1N1rOHHkL2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzY5NDkzOA==", "bodyText": "We are using this in Builder.", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r477694938", "createdAt": "2020-08-26T23:43:57Z", "author": {"login": "aokolnychyi"}, "path": "api/src/main/java/org/apache/iceberg/expressions/Expressions.java", "diffHunk": "@@ -251,7 +251,7 @@ public static Expression rewriteNot(Expression expr) {\n     return ExpressionVisitors.visit(expr, RewriteNot.get());\n   }\n \n-  static <T> NamedReference<T> ref(String name) {\n+  public static <T> NamedReference<T> ref(String name) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "453f49fc3d6643e8cd2ea17badb5df851b67c7b2"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2MTM3NDI3", "url": "https://github.com/apache/iceberg/pull/1373#pullrequestreview-476137427", "createdAt": "2020-08-26T23:45:17Z", "commit": {"oid": "453f49fc3d6643e8cd2ea17badb5df851b67c7b2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQyMzo0NToxN1rOHHkTgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQyMzo0NToxN1rOHHkTgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzY5Njg5OA==", "bodyText": "This place, probably, requires additional attention. I've added a test to TestReplaceTransaction.", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r477696898", "createdAt": "2020-08-26T23:45:17Z", "author": {"login": "aokolnychyi"}, "path": "core/src/main/java/org/apache/iceberg/TableMetadata.java", "diffHunk": "@@ -598,20 +649,39 @@ public TableMetadata buildReplacement(Schema updatedSchema, PartitionSpec update\n       builder.add(freshSpec);\n     }\n \n+    // determine the next order id\n+    int maxOrderId = sortOrders.stream().mapToInt(SortOrder::orderId).max().orElse(INITIAL_SORT_ORDER_ID);\n+    int nextOrderId = maxOrderId + 1;\n+\n+    // rebuild the sort order using new column ids\n+    SortOrder freshSortOrder = freshSortOrder(nextOrderId, freshSchema, updatedSortOrder);\n+\n+    // if the order already exists, use the same ID. otherwise, use 1 more than the highest ID.\n+    Optional<SortOrder> sameSortOrder = sortOrders.stream()\n+        .filter(sortOrder -> sortOrder.sameOrder(freshSortOrder))\n+        .findAny();\n+    int orderId = sameSortOrder.map(SortOrder::orderId).orElse(nextOrderId);\n+\n+    ImmutableList.Builder<SortOrder> sortOrdersBuilder = ImmutableList.<SortOrder>builder().addAll(sortOrders);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "453f49fc3d6643e8cd2ea17badb5df851b67c7b2"}, "originalPosition": 269}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2MTQwNzE0", "url": "https://github.com/apache/iceberg/pull/1373#pullrequestreview-476140714", "createdAt": "2020-08-26T23:46:54Z", "commit": {"oid": "453f49fc3d6643e8cd2ea17badb5df851b67c7b2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQyMzo0Njo1NFrOHHkdJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQyMzo0Njo1NFrOHHkdJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzY5OTM2NA==", "bodyText": "I will add more tests here.", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r477699364", "createdAt": "2020-08-26T23:46:54Z", "author": {"login": "aokolnychyi"}, "path": "core/src/test/java/org/apache/iceberg/TestSortOrderParser.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import org.apache.iceberg.transforms.UnknownTransform;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import static org.apache.iceberg.NullOrder.NULLS_FIRST;\n+import static org.apache.iceberg.SortDirection.DESC;\n+\n+public class TestSortOrderParser extends TableTestBase {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "453f49fc3d6643e8cd2ea17badb5df851b67c7b2"}, "originalPosition": 29}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc4MDY3NDEz", "url": "https://github.com/apache/iceberg/pull/1373#pullrequestreview-478067413", "createdAt": "2020-08-28T23:12:22Z", "commit": {"oid": "de19ccbbc2146f78e355193bcb998029aedf4cd3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQyMzoxMjoyMlrOHJWowA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQyMzoxMjoyMlrOHJWowA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU3MDExMg==", "bodyText": "What about toString/fromString? Instead of using jsonValue? Since it is just a simple string, there is no need to call out that it is intended for JSON.", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r479570112", "createdAt": "2020-08-28T23:12:22Z", "author": {"login": "rdblue"}, "path": "api/src/main/java/org/apache/iceberg/NullOrder.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import java.util.Locale;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+\n+public enum NullOrder {\n+  NULLS_FIRST(\"first\"), NULLS_LAST(\"last\");\n+\n+  private final String jsonValue;\n+\n+  NullOrder(String jsonValue) {\n+    this.jsonValue = jsonValue;\n+  }\n+\n+  public static NullOrder fromJsonValue(String jsonValue) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de19ccbbc2146f78e355193bcb998029aedf4cd3"}, "originalPosition": 34}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc4MDY5MDkw", "url": "https://github.com/apache/iceberg/pull/1373#pullrequestreview-478069090", "createdAt": "2020-08-28T23:19:41Z", "commit": {"oid": "de19ccbbc2146f78e355193bcb998029aedf4cd3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQyMzoxOTo0MVrOHJWuIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQyMzoxOTo0MVrOHJWuIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU3MTQ4OQ==", "bodyText": "Nit: I find it a bit less awkward to use a stream for these cases because it accepts a factory method:\nthis.fields = fields.stream().toArray(SortField[]::new);", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r479571489", "createdAt": "2020-08-28T23:19:41Z", "author": {"login": "rdblue"}, "path": "api/src/main/java/org/apache/iceberg/SortOrder.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+import org.apache.iceberg.exceptions.ValidationException;\n+import org.apache.iceberg.expressions.BoundReference;\n+import org.apache.iceberg.expressions.BoundTerm;\n+import org.apache.iceberg.expressions.BoundTransform;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.expressions.Term;\n+import org.apache.iceberg.expressions.UnboundTerm;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableList;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.transforms.Transform;\n+import org.apache.iceberg.transforms.Transforms;\n+import org.apache.iceberg.types.Types;\n+\n+public class SortOrder implements Serializable {\n+  // TODO: shall we reserve 0 for the unsorted order? PartitionSpec does not guarantee it?\n+  private static final SortOrder UNSORTED_ORDER = new SortOrder(new Schema(), 0, Collections.emptyList());\n+\n+  private final Schema schema;\n+  private final int orderId;\n+  private final SortField[] fields;\n+\n+  private transient volatile List<SortField> fieldList;\n+\n+  private SortOrder(Schema schema, int orderId, List<SortField> fields) {\n+    this.schema = schema;\n+    this.orderId = orderId;\n+    this.fields = fields.toArray(new SortField[0]);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de19ccbbc2146f78e355193bcb998029aedf4cd3"}, "originalPosition": 54}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc4MDY5OTI0", "url": "https://github.com/apache/iceberg/pull/1373#pullrequestreview-478069924", "createdAt": "2020-08-28T23:23:30Z", "commit": {"oid": "de19ccbbc2146f78e355193bcb998029aedf4cd3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQyMzoyMzozMFrOHJWw4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQyMzoyMzozMFrOHJWw4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU3MjE5NQ==", "bodyText": "Should this delegate to sameOrder instead of checking fields directly?", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r479572195", "createdAt": "2020-08-28T23:23:30Z", "author": {"login": "rdblue"}, "path": "api/src/main/java/org/apache/iceberg/SortOrder.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+import org.apache.iceberg.exceptions.ValidationException;\n+import org.apache.iceberg.expressions.BoundReference;\n+import org.apache.iceberg.expressions.BoundTerm;\n+import org.apache.iceberg.expressions.BoundTransform;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.expressions.Term;\n+import org.apache.iceberg.expressions.UnboundTerm;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableList;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.transforms.Transform;\n+import org.apache.iceberg.transforms.Transforms;\n+import org.apache.iceberg.types.Types;\n+\n+public class SortOrder implements Serializable {\n+  // TODO: shall we reserve 0 for the unsorted order? PartitionSpec does not guarantee it?\n+  private static final SortOrder UNSORTED_ORDER = new SortOrder(new Schema(), 0, Collections.emptyList());\n+\n+  private final Schema schema;\n+  private final int orderId;\n+  private final SortField[] fields;\n+\n+  private transient volatile List<SortField> fieldList;\n+\n+  private SortOrder(Schema schema, int orderId, List<SortField> fields) {\n+    this.schema = schema;\n+    this.orderId = orderId;\n+    this.fields = fields.toArray(new SortField[0]);\n+  }\n+\n+  public Schema schema() {\n+    return schema;\n+  }\n+\n+  public int orderId() {\n+    return orderId;\n+  }\n+\n+  public List<SortField> fields() {\n+    return lazyFieldList();\n+  }\n+\n+  public boolean isUnsorted() {\n+    return fields.length < 1;\n+  }\n+\n+  public boolean satisfies(SortOrder anotherSortOrder) {\n+    // any ordering satisfies an unsorted ordering\n+    if (anotherSortOrder.isUnsorted()) {\n+      return true;\n+    }\n+\n+    // this ordering cannot satisfy an ordering with more sort fields\n+    if (anotherSortOrder.fields.length > fields.length) {\n+      return false;\n+    }\n+\n+    // this ordering has either more or the same number of sort fields\n+    return IntStream.range(0, anotherSortOrder.fields.length)\n+        .allMatch(index -> fields[index].equals(anotherSortOrder.fields[index]));\n+  }\n+\n+  public boolean sameOrder(SortOrder anotherSortOrder) {\n+    return Arrays.equals(fields, anotherSortOrder.fields);\n+  }\n+\n+  private List<SortField> lazyFieldList() {\n+    if (fieldList == null) {\n+      synchronized (this) {\n+        if (fieldList == null) {\n+          this.fieldList = ImmutableList.copyOf(fields);\n+        }\n+      }\n+    }\n+    return fieldList;\n+  }\n+\n+  @Override\n+  public String toString() {\n+    StringBuilder sb = new StringBuilder();\n+    sb.append(\"[\");\n+    for (SortField field : fields) {\n+      sb.append(\"\\n\");\n+      sb.append(\"  \").append(field);\n+    }\n+    if (fields.length > 0) {\n+      sb.append(\"\\n\");\n+    }\n+    sb.append(\"]\");\n+    return sb.toString();\n+  }\n+\n+  @Override\n+  public boolean equals(Object other) {\n+    if (this == other) {\n+      return true;\n+    } else if (other == null || getClass() != other.getClass()) {\n+      return false;\n+    }\n+\n+    SortOrder that = (SortOrder) other;\n+    return orderId == that.orderId && Arrays.equals(fields, that.fields);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de19ccbbc2146f78e355193bcb998029aedf4cd3"}, "originalPosition": 128}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc4MDcxNzUx", "url": "https://github.com/apache/iceberg/pull/1373#pullrequestreview-478071751", "createdAt": "2020-08-28T23:32:44Z", "commit": {"oid": "de19ccbbc2146f78e355193bcb998029aedf4cd3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQyMzozMjo0NFrOHJW31g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQyMzozMjo0NFrOHJW31g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU3Mzk3NA==", "bodyText": "Probably worth a comment that states ValidationException is thrown by bind if binding fails so we can assume that boundTerm is defined correctly. (I just checked to make sure)", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r479573974", "createdAt": "2020-08-28T23:32:44Z", "author": {"login": "rdblue"}, "path": "api/src/main/java/org/apache/iceberg/SortOrder.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+import org.apache.iceberg.exceptions.ValidationException;\n+import org.apache.iceberg.expressions.BoundReference;\n+import org.apache.iceberg.expressions.BoundTerm;\n+import org.apache.iceberg.expressions.BoundTransform;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.expressions.Term;\n+import org.apache.iceberg.expressions.UnboundTerm;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableList;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.transforms.Transform;\n+import org.apache.iceberg.transforms.Transforms;\n+import org.apache.iceberg.types.Types;\n+\n+public class SortOrder implements Serializable {\n+  // TODO: shall we reserve 0 for the unsorted order? PartitionSpec does not guarantee it?\n+  private static final SortOrder UNSORTED_ORDER = new SortOrder(new Schema(), 0, Collections.emptyList());\n+\n+  private final Schema schema;\n+  private final int orderId;\n+  private final SortField[] fields;\n+\n+  private transient volatile List<SortField> fieldList;\n+\n+  private SortOrder(Schema schema, int orderId, List<SortField> fields) {\n+    this.schema = schema;\n+    this.orderId = orderId;\n+    this.fields = fields.toArray(new SortField[0]);\n+  }\n+\n+  public Schema schema() {\n+    return schema;\n+  }\n+\n+  public int orderId() {\n+    return orderId;\n+  }\n+\n+  public List<SortField> fields() {\n+    return lazyFieldList();\n+  }\n+\n+  public boolean isUnsorted() {\n+    return fields.length < 1;\n+  }\n+\n+  public boolean satisfies(SortOrder anotherSortOrder) {\n+    // any ordering satisfies an unsorted ordering\n+    if (anotherSortOrder.isUnsorted()) {\n+      return true;\n+    }\n+\n+    // this ordering cannot satisfy an ordering with more sort fields\n+    if (anotherSortOrder.fields.length > fields.length) {\n+      return false;\n+    }\n+\n+    // this ordering has either more or the same number of sort fields\n+    return IntStream.range(0, anotherSortOrder.fields.length)\n+        .allMatch(index -> fields[index].equals(anotherSortOrder.fields[index]));\n+  }\n+\n+  public boolean sameOrder(SortOrder anotherSortOrder) {\n+    return Arrays.equals(fields, anotherSortOrder.fields);\n+  }\n+\n+  private List<SortField> lazyFieldList() {\n+    if (fieldList == null) {\n+      synchronized (this) {\n+        if (fieldList == null) {\n+          this.fieldList = ImmutableList.copyOf(fields);\n+        }\n+      }\n+    }\n+    return fieldList;\n+  }\n+\n+  @Override\n+  public String toString() {\n+    StringBuilder sb = new StringBuilder();\n+    sb.append(\"[\");\n+    for (SortField field : fields) {\n+      sb.append(\"\\n\");\n+      sb.append(\"  \").append(field);\n+    }\n+    if (fields.length > 0) {\n+      sb.append(\"\\n\");\n+    }\n+    sb.append(\"]\");\n+    return sb.toString();\n+  }\n+\n+  @Override\n+  public boolean equals(Object other) {\n+    if (this == other) {\n+      return true;\n+    } else if (other == null || getClass() != other.getClass()) {\n+      return false;\n+    }\n+\n+    SortOrder that = (SortOrder) other;\n+    return orderId == that.orderId && Arrays.equals(fields, that.fields);\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return 31 * Integer.hashCode(orderId) + Arrays.hashCode(fields);\n+  }\n+\n+  public static SortOrder unsorted() {\n+    return UNSORTED_ORDER;\n+  }\n+\n+  public static Builder builderFor(Schema schema) {\n+    return new Builder(schema);\n+  }\n+\n+  public static class Builder {\n+    private final Schema schema;\n+    private final List<SortField> fields = Lists.newArrayList();\n+    private int orderId = 0;\n+    private boolean caseSensitive = true;\n+\n+    private Builder(Schema schema) {\n+      this.schema = schema;\n+    }\n+\n+    public Builder asc(String name, NullOrder nullOrder) {\n+      return addSortField(Expressions.ref(name), SortDirection.ASC, nullOrder);\n+    }\n+\n+    public Builder asc(Term term, NullOrder nullOrder) {\n+      return addSortField(term, SortDirection.ASC, nullOrder);\n+    }\n+\n+    public Builder desc(String name, NullOrder nullOrder) {\n+      return addSortField(Expressions.ref(name), SortDirection.DESC, nullOrder);\n+    }\n+\n+    public Builder desc(Term term, NullOrder nullOrder) {\n+      return addSortField(term, SortDirection.DESC, nullOrder);\n+    }\n+\n+    public Builder withOrderId(int newOrderId) {\n+      this.orderId = newOrderId;\n+      return this;\n+    }\n+\n+    public Builder caseSensitive(boolean sortCaseSensitive) {\n+      this.caseSensitive = sortCaseSensitive;\n+      return this;\n+    }\n+\n+    Builder addSortField(Term term, SortDirection direction, NullOrder nullOrder) {\n+      Preconditions.checkArgument(term instanceof UnboundTerm, \"Term must be unbound\");\n+      BoundTerm<?> boundTerm = ((UnboundTerm<?>) term).bind(schema.asStruct(), caseSensitive);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de19ccbbc2146f78e355193bcb998029aedf4cd3"}, "originalPosition": 182}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc4MDczNDc2", "url": "https://github.com/apache/iceberg/pull/1373#pullrequestreview-478073476", "createdAt": "2020-08-28T23:42:06Z", "commit": {"oid": "de19ccbbc2146f78e355193bcb998029aedf4cd3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQyMzo0MjowNlrOHJW_Dw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQyMzo0MjowNlrOHJW_Dw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU3NTgyMw==", "bodyText": "Should we have defaults for sortOrder and spec as well? It seems strange that we do this for properties, but not the others.", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r479575823", "createdAt": "2020-08-28T23:42:06Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/BaseMetastoreCatalog.java", "diffHunk": "@@ -64,8 +65,8 @@ public Table createTable(\n       baseLocation = defaultWarehouseLocation(identifier);\n     }\n \n-    TableMetadata metadata = TableMetadata.newTableMetadata(\n-        schema, spec, baseLocation, properties == null ? Maps.newHashMap() : properties);\n+    Map<String, String> tableProps = properties != null ? properties : ImmutableMap.of();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de19ccbbc2146f78e355193bcb998029aedf4cd3"}, "originalPosition": 25}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc4MDc1NzYz", "url": "https://github.com/apache/iceberg/pull/1373#pullrequestreview-478075763", "createdAt": "2020-08-28T23:54:50Z", "commit": {"oid": "de19ccbbc2146f78e355193bcb998029aedf4cd3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQyMzo1NDo1MFrOHJXIVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQyMzo1NDo1MFrOHJXIVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU3ODE5OA==", "bodyText": "Do we need to write a transform if it is identity? It would be nice to omit this when it is identity.", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r479578198", "createdAt": "2020-08-28T23:54:50Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/SortOrderParser.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.Iterator;\n+import java.util.Locale;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.util.JsonUtil;\n+\n+public class SortOrderParser {\n+  private static final String ORDER_ID = \"order-id\";\n+  private static final String FIELDS = \"fields\";\n+  private static final String DIRECTION = \"direction\";\n+  private static final String NULL_ORDERING = \"null-order\";\n+  private static final String TRANSFORM = \"transform\";\n+  private static final String SOURCE_ID = \"source-id\";\n+\n+  private SortOrderParser() {\n+  }\n+\n+  public static void toJson(SortOrder sortOrder, JsonGenerator generator) throws IOException {\n+    generator.writeStartObject();\n+    generator.writeNumberField(ORDER_ID, sortOrder.orderId());\n+    generator.writeFieldName(FIELDS);\n+    toJsonFields(sortOrder, generator);\n+    generator.writeEndObject();\n+  }\n+\n+  private static void toJsonFields(SortOrder sortOrder, JsonGenerator generator) throws IOException {\n+    generator.writeStartArray();\n+    for (SortField field : sortOrder.fields()) {\n+      generator.writeStartObject();\n+      generator.writeStringField(TRANSFORM, field.transform().toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de19ccbbc2146f78e355193bcb998029aedf4cd3"}, "originalPosition": 54}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc4MDc2MzUz", "url": "https://github.com/apache/iceberg/pull/1373#pullrequestreview-478076353", "createdAt": "2020-08-28T23:58:14Z", "commit": {"oid": "de19ccbbc2146f78e355193bcb998029aedf4cd3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQyMzo1ODoxNVrOHJXKsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQyMzo1ODoxNVrOHJXKsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU3ODgwMQ==", "bodyText": "I think this needs to check whether json is null as well. That's a bug here and in PartitionSpecParser. If it is null because the field doesn't exist, then this will throw a NullPointerException instead of a good error message. I'm good with either checking here (json != null && json.isArray()) or in the method that calls this using json.has(FIELDS).", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r479578801", "createdAt": "2020-08-28T23:58:15Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/SortOrderParser.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.Iterator;\n+import java.util.Locale;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.util.JsonUtil;\n+\n+public class SortOrderParser {\n+  private static final String ORDER_ID = \"order-id\";\n+  private static final String FIELDS = \"fields\";\n+  private static final String DIRECTION = \"direction\";\n+  private static final String NULL_ORDERING = \"null-order\";\n+  private static final String TRANSFORM = \"transform\";\n+  private static final String SOURCE_ID = \"source-id\";\n+\n+  private SortOrderParser() {\n+  }\n+\n+  public static void toJson(SortOrder sortOrder, JsonGenerator generator) throws IOException {\n+    generator.writeStartObject();\n+    generator.writeNumberField(ORDER_ID, sortOrder.orderId());\n+    generator.writeFieldName(FIELDS);\n+    toJsonFields(sortOrder, generator);\n+    generator.writeEndObject();\n+  }\n+\n+  private static void toJsonFields(SortOrder sortOrder, JsonGenerator generator) throws IOException {\n+    generator.writeStartArray();\n+    for (SortField field : sortOrder.fields()) {\n+      generator.writeStartObject();\n+      generator.writeStringField(TRANSFORM, field.transform().toString());\n+      generator.writeNumberField(SOURCE_ID, field.sourceId());\n+      generator.writeStringField(DIRECTION, field.direction().toString().toLowerCase(Locale.ROOT));\n+      generator.writeStringField(NULL_ORDERING, field.nullOrder().jsonValue());\n+      generator.writeEndObject();\n+    }\n+    generator.writeEndArray();\n+  }\n+\n+  public static SortOrder fromJson(Schema schema, String json) {\n+    try {\n+      return fromJson(schema, JsonUtil.mapper().readValue(json, JsonNode.class));\n+    } catch (IOException e) {\n+      throw new UncheckedIOException(e);\n+    }\n+  }\n+\n+  public static SortOrder fromJson(Schema schema, JsonNode json) {\n+    Preconditions.checkArgument(json.isObject(), \"Cannot parse sort order from non-object: %s\", json);\n+    int orderId = JsonUtil.getInt(ORDER_ID, json);\n+    SortOrder.Builder builder = SortOrder.builderFor(schema).withOrderId(orderId);\n+    buildFromJsonFields(builder, json.get(FIELDS));\n+    return builder.build();\n+  }\n+\n+  private static void buildFromJsonFields(SortOrder.Builder builder, JsonNode json) {\n+    Preconditions.checkArgument(json.isArray(), \"Cannot parse partition order fields, not an array: %s\", json);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de19ccbbc2146f78e355193bcb998029aedf4cd3"}, "originalPosition": 80}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc4MDc2NjUx", "url": "https://github.com/apache/iceberg/pull/1373#pullrequestreview-478076651", "createdAt": "2020-08-29T00:00:03Z", "commit": {"oid": "de19ccbbc2146f78e355193bcb998029aedf4cd3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOVQwMDowMDowM1rOHJXL5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOVQwMDowMDowM1rOHJXL5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU3OTExMA==", "bodyText": "If we want to reserve unsorted, all we would do is change this to 1 and add checks for passing in an unsorted order.", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r479579110", "createdAt": "2020-08-29T00:00:03Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/TableMetadata.java", "diffHunk": "@@ -49,6 +50,7 @@\n   static final int DEFAULT_TABLE_FORMAT_VERSION = 1;\n   static final int SUPPORTED_TABLE_FORMAT_VERSION = 2;\n   static final int INITIAL_SPEC_ID = 0;\n+  static final int INITIAL_SORT_ORDER_ID = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de19ccbbc2146f78e355193bcb998029aedf4cd3"}, "originalPosition": 12}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc4MDc3NTE0", "url": "https://github.com/apache/iceberg/pull/1373#pullrequestreview-478077514", "createdAt": "2020-08-29T00:05:33Z", "commit": {"oid": "de19ccbbc2146f78e355193bcb998029aedf4cd3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOVQwMDowNTozM1rOHJXPjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOVQwMDowNTozM1rOHJXPjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU4MDA0NQ==", "bodyText": "Should we also expose defaultSpecId directly? Normally, we use spec().specId().", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r479580045", "createdAt": "2020-08-29T00:05:33Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/TableMetadata.java", "diffHunk": "@@ -348,6 +375,22 @@ public int defaultSpecId() {\n     return defaultSpecId;\n   }\n \n+  public int defaultSortOrderId() {\n+    return defaultSortOrderId;\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de19ccbbc2146f78e355193bcb998029aedf4cd3"}, "originalPosition": 120}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc4MDc5OTgz", "url": "https://github.com/apache/iceberg/pull/1373#pullrequestreview-478079983", "createdAt": "2020-08-29T00:22:50Z", "commit": {"oid": "de19ccbbc2146f78e355193bcb998029aedf4cd3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOVQwMDoyMjo1MFrOHJXZwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOVQwMDoyMjo1MFrOHJXZwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU4MjY1Ng==", "bodyText": "This class might be a good one for a builder as well...", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r479582656", "createdAt": "2020-08-29T00:22:50Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/TableMetadata.java", "diffHunk": "@@ -61,18 +63,27 @@ public static TableMetadata newTableMetadata(TableOperations ops,\n                                                PartitionSpec spec,\n                                                String location,\n                                                Map<String, String> properties) {\n-    return newTableMetadata(schema, spec, location, properties, DEFAULT_TABLE_FORMAT_VERSION);\n+    return newTableMetadata(schema, spec, SortOrder.unsorted(), location, properties, DEFAULT_TABLE_FORMAT_VERSION);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de19ccbbc2146f78e355193bcb998029aedf4cd3"}, "originalPosition": 21}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc4MDg0NDc1", "url": "https://github.com/apache/iceberg/pull/1373#pullrequestreview-478084475", "createdAt": "2020-08-29T01:01:28Z", "commit": {"oid": "de19ccbbc2146f78e355193bcb998029aedf4cd3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOVQwMTowMToyOFrOHJXtmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOVQwMTowMToyOFrOHJXtmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU4NzczOQ==", "bodyText": "Minor: This variable doesn't seem necessary.", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r479587739", "createdAt": "2020-08-29T01:01:28Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/TableMetadataParser.java", "diffHunk": "@@ -277,6 +286,22 @@ static TableMetadata fromJson(FileIO io, InputFile file, JsonNode node) {\n           schema, TableMetadata.INITIAL_SPEC_ID, node.get(PARTITION_SPEC)));\n     }\n \n+    JsonNode sortOrderArray = node.get(SORT_ORDERS);\n+    List<SortOrder> sortOrders;\n+    int defaultSortOrderId;\n+    if (sortOrderArray != null) {\n+      defaultSortOrderId = JsonUtil.getInt(DEFAULT_SORT_ORDER_ID, node);\n+      ImmutableList.Builder<SortOrder> sortOrdersBuilder = ImmutableList.builder();\n+      for (JsonNode sortOrder : sortOrderArray) {\n+        sortOrdersBuilder.add(SortOrderParser.fromJson(schema, sortOrder));\n+      }\n+      sortOrders = sortOrdersBuilder.build();\n+    } else {\n+      SortOrder defaultSortOrder = SortOrder.unsorted();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de19ccbbc2146f78e355193bcb998029aedf4cd3"}, "originalPosition": 38}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxNDA0Mjc5", "url": "https://github.com/apache/iceberg/pull/1373#pullrequestreview-481404279", "createdAt": "2020-09-03T00:35:21Z", "commit": {"oid": "de19ccbbc2146f78e355193bcb998029aedf4cd3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwMDozNToyMVrOHMQxFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwMDozNToyMVrOHMQxFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjYxOTY3MQ==", "bodyText": "If the SortOrder list is required by v2, then I think that we should add a check here that the table is v1. That way, we fail to read a table and force recovery if a v2 table doesn't have an order list.\nWe should probably also update the PartitionSpec logic above to do the same thing.", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r482619671", "createdAt": "2020-09-03T00:35:21Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/TableMetadataParser.java", "diffHunk": "@@ -277,6 +286,22 @@ static TableMetadata fromJson(FileIO io, InputFile file, JsonNode node) {\n           schema, TableMetadata.INITIAL_SPEC_ID, node.get(PARTITION_SPEC)));\n     }\n \n+    JsonNode sortOrderArray = node.get(SORT_ORDERS);\n+    List<SortOrder> sortOrders;\n+    int defaultSortOrderId;\n+    if (sortOrderArray != null) {\n+      defaultSortOrderId = JsonUtil.getInt(DEFAULT_SORT_ORDER_ID, node);\n+      ImmutableList.Builder<SortOrder> sortOrdersBuilder = ImmutableList.builder();\n+      for (JsonNode sortOrder : sortOrderArray) {\n+        sortOrdersBuilder.add(SortOrderParser.fromJson(schema, sortOrder));\n+      }\n+      sortOrders = sortOrdersBuilder.build();\n+    } else {\n+      SortOrder defaultSortOrder = SortOrder.unsorted();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de19ccbbc2146f78e355193bcb998029aedf4cd3"}, "originalPosition": 38}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxOTM4OTE1", "url": "https://github.com/apache/iceberg/pull/1373#pullrequestreview-481938915", "createdAt": "2020-09-03T15:10:18Z", "commit": {"oid": "de19ccbbc2146f78e355193bcb998029aedf4cd3"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "de19ccbbc2146f78e355193bcb998029aedf4cd3", "author": {"user": {"login": "aokolnychyi", "name": "Anton Okolnychyi"}}, "url": "https://github.com/apache/iceberg/commit/de19ccbbc2146f78e355193bcb998029aedf4cd3", "committedDate": "2020-08-27T00:17:53Z", "message": "Fix tests"}, "afterCommit": {"oid": "4e0501c1a9b8496c8f89df8eb5d2c5cb326ceea7", "author": {"user": {"login": "aokolnychyi", "name": "Anton Okolnychyi"}}, "url": "https://github.com/apache/iceberg/commit/4e0501c1a9b8496c8f89df8eb5d2c5cb326ceea7", "committedDate": "2020-09-03T18:38:41Z", "message": "API: Implement SortOrder"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "edbddb2fe791d363f1bd3dd1431dc9855c71806b", "author": {"user": {"login": "aokolnychyi", "name": "Anton Okolnychyi"}}, "url": "https://github.com/apache/iceberg/commit/edbddb2fe791d363f1bd3dd1431dc9855c71806b", "committedDate": "2020-09-03T18:41:08Z", "message": "API: Implement SortOrder"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4e0501c1a9b8496c8f89df8eb5d2c5cb326ceea7", "author": {"user": {"login": "aokolnychyi", "name": "Anton Okolnychyi"}}, "url": "https://github.com/apache/iceberg/commit/4e0501c1a9b8496c8f89df8eb5d2c5cb326ceea7", "committedDate": "2020-09-03T18:38:41Z", "message": "API: Implement SortOrder"}, "afterCommit": {"oid": "edbddb2fe791d363f1bd3dd1431dc9855c71806b", "author": {"user": {"login": "aokolnychyi", "name": "Anton Okolnychyi"}}, "url": "https://github.com/apache/iceberg/commit/edbddb2fe791d363f1bd3dd1431dc9855c71806b", "committedDate": "2020-09-03T18:41:08Z", "message": "API: Implement SortOrder"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "449dd238672e1c35b27c9d3d74d450d34b27e959", "author": {"user": {"login": "aokolnychyi", "name": "Anton Okolnychyi"}}, "url": "https://github.com/apache/iceberg/commit/449dd238672e1c35b27c9d3d74d450d34b27e959", "committedDate": "2020-09-04T05:10:24Z", "message": "Minor updates"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4094, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}