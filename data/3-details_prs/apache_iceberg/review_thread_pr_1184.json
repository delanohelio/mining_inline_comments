{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ2NDMyMjg3", "number": 1184, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQwMTowMTo1NFrOEOD1uA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQyMDowMToxM1rOER8yJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMTc4NDI0OnYy", "diffSide": "RIGHT", "path": "spark/src/test/java/org/apache/iceberg/spark/data/TestSparkParquetReader.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQwMTowMTo1NFrOGxAJXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMTowNzozN1rOG2bnmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDAzNTgwNQ==", "bodyText": "Is it possible to avoid creating a Spark session just to write a timestamp? What about calling Spark's FileFormat to write directly instead?\nWe wrap Spark's FileFormat in our DSv2 table implementation: https://github.com/Netflix/iceberg/blob/netflix-spark-2.4/metacat/src/main/java/com/netflix/iceberg/batch/BatchPatternWrite.java#L90\nThis test would run much faster by using that to create a file instead of creating a Spark context.", "url": "https://github.com/apache/iceberg/pull/1184#discussion_r454035805", "createdAt": "2020-07-14T01:01:54Z", "author": {"login": "rdblue"}, "path": "spark/src/test/java/org/apache/iceberg/spark/data/TestSparkParquetReader.java", "diffHunk": "@@ -67,4 +78,49 @@ protected void writeAndValidate(Schema schema) throws IOException {\n       Assert.assertFalse(\"Should not have extra rows\", rows.hasNext());\n     }\n   }\n+\n+  protected List<InternalRow> rowsFromFile(InputFile inputFile, Schema schema) throws IOException {\n+    try (CloseableIterable<InternalRow> reader =\n+        Parquet.read(inputFile)\n+            .project(schema)\n+            .createReaderFunc(type -> SparkParquetReaders.buildReader(schema, type))\n+            .build()) {\n+      return Lists.newArrayList(reader);\n+    }\n+  }\n+\n+  @Test\n+  public void testInt96TimestampProducedBySparkIsReadCorrectly() throws IOException {\n+    final SparkSession spark =\n+        SparkSession.builder()\n+            .master(\"local[2]\")\n+            .config(\"spark.sql.parquet.int96AsTimestamp\", \"false\")\n+            .getOrCreate();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cea839f58b8b0e3d73f415b2770913e1d0955f31"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU5NzI1Ng==", "bodyText": "Yes, I would much rather avoid creating a SparkSession here if possible. However, looking into ParquetFileFormat it seems like we would still need to pass a SparkSession to create the writer.\nI can look at ParquetOutputWriter but I might need to match the configuration there with what Spark uses to write int96.", "url": "https://github.com/apache/iceberg/pull/1184#discussion_r454597256", "createdAt": "2020-07-14T19:38:02Z", "author": {"login": "gustavoatt"}, "path": "spark/src/test/java/org/apache/iceberg/spark/data/TestSparkParquetReader.java", "diffHunk": "@@ -67,4 +78,49 @@ protected void writeAndValidate(Schema schema) throws IOException {\n       Assert.assertFalse(\"Should not have extra rows\", rows.hasNext());\n     }\n   }\n+\n+  protected List<InternalRow> rowsFromFile(InputFile inputFile, Schema schema) throws IOException {\n+    try (CloseableIterable<InternalRow> reader =\n+        Parquet.read(inputFile)\n+            .project(schema)\n+            .createReaderFunc(type -> SparkParquetReaders.buildReader(schema, type))\n+            .build()) {\n+      return Lists.newArrayList(reader);\n+    }\n+  }\n+\n+  @Test\n+  public void testInt96TimestampProducedBySparkIsReadCorrectly() throws IOException {\n+    final SparkSession spark =\n+        SparkSession.builder()\n+            .master(\"local[2]\")\n+            .config(\"spark.sql.parquet.int96AsTimestamp\", \"false\")\n+            .getOrCreate();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDAzNTgwNQ=="}, "originalCommit": {"oid": "cea839f58b8b0e3d73f415b2770913e1d0955f31"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTExMDcwMg==", "bodyText": "Another approach would be to check-in a parquet file written by a spark and have the test just read it?\nA drawback with that approach is that updating this file would be brittle, but I can check in the code that writes the file in an ignored test, but that should avoid us from creating a spark session during unit tests. What do you think @rdblue?", "url": "https://github.com/apache/iceberg/pull/1184#discussion_r459110702", "createdAt": "2020-07-22T22:05:53Z", "author": {"login": "gustavoatt"}, "path": "spark/src/test/java/org/apache/iceberg/spark/data/TestSparkParquetReader.java", "diffHunk": "@@ -67,4 +78,49 @@ protected void writeAndValidate(Schema schema) throws IOException {\n       Assert.assertFalse(\"Should not have extra rows\", rows.hasNext());\n     }\n   }\n+\n+  protected List<InternalRow> rowsFromFile(InputFile inputFile, Schema schema) throws IOException {\n+    try (CloseableIterable<InternalRow> reader =\n+        Parquet.read(inputFile)\n+            .project(schema)\n+            .createReaderFunc(type -> SparkParquetReaders.buildReader(schema, type))\n+            .build()) {\n+      return Lists.newArrayList(reader);\n+    }\n+  }\n+\n+  @Test\n+  public void testInt96TimestampProducedBySparkIsReadCorrectly() throws IOException {\n+    final SparkSession spark =\n+        SparkSession.builder()\n+            .master(\"local[2]\")\n+            .config(\"spark.sql.parquet.int96AsTimestamp\", \"false\")\n+            .getOrCreate();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDAzNTgwNQ=="}, "originalCommit": {"oid": "cea839f58b8b0e3d73f415b2770913e1d0955f31"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEzNjEyOQ==", "bodyText": "At one point, we supported writing to Parquet using Spark's built-in ReadSupport. I think we can probably get that working again to create the files.", "url": "https://github.com/apache/iceberg/pull/1184#discussion_r459136129", "createdAt": "2020-07-22T23:17:01Z", "author": {"login": "rdblue"}, "path": "spark/src/test/java/org/apache/iceberg/spark/data/TestSparkParquetReader.java", "diffHunk": "@@ -67,4 +78,49 @@ protected void writeAndValidate(Schema schema) throws IOException {\n       Assert.assertFalse(\"Should not have extra rows\", rows.hasNext());\n     }\n   }\n+\n+  protected List<InternalRow> rowsFromFile(InputFile inputFile, Schema schema) throws IOException {\n+    try (CloseableIterable<InternalRow> reader =\n+        Parquet.read(inputFile)\n+            .project(schema)\n+            .createReaderFunc(type -> SparkParquetReaders.buildReader(schema, type))\n+            .build()) {\n+      return Lists.newArrayList(reader);\n+    }\n+  }\n+\n+  @Test\n+  public void testInt96TimestampProducedBySparkIsReadCorrectly() throws IOException {\n+    final SparkSession spark =\n+        SparkSession.builder()\n+            .master(\"local[2]\")\n+            .config(\"spark.sql.parquet.int96AsTimestamp\", \"false\")\n+            .getOrCreate();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDAzNTgwNQ=="}, "originalCommit": {"oid": "cea839f58b8b0e3d73f415b2770913e1d0955f31"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcyODc5Mw==", "bodyText": "Yes, looking at one of the tests we do support writing parquet files using Spark's WriteSupport.\nTo be able to use a FileAppender I had to add a TimestampAsInt96 type (that can only be written using Spark's builtin WriteSupport) so that schema conversion within Iceberg's ParquetWriteSupport knows that this timestamps should be encoded as int96 in the  parquet  schema.", "url": "https://github.com/apache/iceberg/pull/1184#discussion_r459728793", "createdAt": "2020-07-23T21:07:37Z", "author": {"login": "gustavoatt"}, "path": "spark/src/test/java/org/apache/iceberg/spark/data/TestSparkParquetReader.java", "diffHunk": "@@ -67,4 +78,49 @@ protected void writeAndValidate(Schema schema) throws IOException {\n       Assert.assertFalse(\"Should not have extra rows\", rows.hasNext());\n     }\n   }\n+\n+  protected List<InternalRow> rowsFromFile(InputFile inputFile, Schema schema) throws IOException {\n+    try (CloseableIterable<InternalRow> reader =\n+        Parquet.read(inputFile)\n+            .project(schema)\n+            .createReaderFunc(type -> SparkParquetReaders.buildReader(schema, type))\n+            .build()) {\n+      return Lists.newArrayList(reader);\n+    }\n+  }\n+\n+  @Test\n+  public void testInt96TimestampProducedBySparkIsReadCorrectly() throws IOException {\n+    final SparkSession spark =\n+        SparkSession.builder()\n+            .master(\"local[2]\")\n+            .config(\"spark.sql.parquet.int96AsTimestamp\", \"false\")\n+            .getOrCreate();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDAzNTgwNQ=="}, "originalCommit": {"oid": "cea839f58b8b0e3d73f415b2770913e1d0955f31"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMTc4NjYwOnYy", "diffSide": "RIGHT", "path": "spark/src/test/java/org/apache/iceberg/spark/data/TestSparkParquetReader.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQwMTowMzoyMlrOGxAKuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQwMTowMzoyMlrOGxAKuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDAzNjE1Mg==", "bodyText": "Using Spark's FileFormat would also make this test easier. You'd be able to pass in a value in micros and validate that you get the same value back, unmodified. You'd also not need to locate the Parquet file using find.", "url": "https://github.com/apache/iceberg/pull/1184#discussion_r454036152", "createdAt": "2020-07-14T01:03:22Z", "author": {"login": "rdblue"}, "path": "spark/src/test/java/org/apache/iceberg/spark/data/TestSparkParquetReader.java", "diffHunk": "@@ -67,4 +78,49 @@ protected void writeAndValidate(Schema schema) throws IOException {\n       Assert.assertFalse(\"Should not have extra rows\", rows.hasNext());\n     }\n   }\n+\n+  protected List<InternalRow> rowsFromFile(InputFile inputFile, Schema schema) throws IOException {\n+    try (CloseableIterable<InternalRow> reader =\n+        Parquet.read(inputFile)\n+            .project(schema)\n+            .createReaderFunc(type -> SparkParquetReaders.buildReader(schema, type))\n+            .build()) {\n+      return Lists.newArrayList(reader);\n+    }\n+  }\n+\n+  @Test\n+  public void testInt96TimestampProducedBySparkIsReadCorrectly() throws IOException {\n+    final SparkSession spark =\n+        SparkSession.builder()\n+            .master(\"local[2]\")\n+            .config(\"spark.sql.parquet.int96AsTimestamp\", \"false\")\n+            .getOrCreate();\n+\n+    final String parquetPath = temp.getRoot().getAbsolutePath() + \"/parquet_int96\";\n+    final java.sql.Timestamp ts = java.sql.Timestamp.valueOf(\"2014-01-01 23:00:01\");\n+    spark.createDataset(ImmutableList.of(ts), Encoders.TIMESTAMP()).write().parquet(parquetPath);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cea839f58b8b0e3d73f415b2770913e1d0955f31"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2OTcyNzk1OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/apache/iceberg/types/Types.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQwMjozNjozM1rOG2hj_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxOTo0NToyN1rOG27uCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgyNjE3NQ==", "bodyText": "I don't think we should change the type system to support this. INT96 may be something that we can read, but Iceberg cannot write it, per the spec.\nWas this needed to build the tests?", "url": "https://github.com/apache/iceberg/pull/1184#discussion_r459826175", "createdAt": "2020-07-24T02:36:33Z", "author": {"login": "rdblue"}, "path": "api/src/main/java/org/apache/iceberg/types/Types.java", "diffHunk": "@@ -219,16 +220,30 @@ public static TimestampType withoutZone() {\n       return INSTANCE_WITHOUT_ZONE;\n     }\n \n+    /**\n+     * @return Timestamp type (with timezone) represented as INT96. This is only added for compatibility reasons\n+     * and can only be written using a Spark's ParquetWriteSupport. Writing this type should be avoided.\n+     */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b35027be3f3056b23a546f02ea9e4a1fcc91392c"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI1NDcyOQ==", "bodyText": "Agreed. I found a way to have tests running that doesn't add a new type, I had to create an implementation of ParquetWriter.Builder that uses Spark's ParquetWriteSupport and Iceberg's ParquetWriteAdapter to avoid creating a SparkSession.", "url": "https://github.com/apache/iceberg/pull/1184#discussion_r460254729", "createdAt": "2020-07-24T19:45:27Z", "author": {"login": "gustavoatt"}, "path": "api/src/main/java/org/apache/iceberg/types/Types.java", "diffHunk": "@@ -219,16 +220,30 @@ public static TimestampType withoutZone() {\n       return INSTANCE_WITHOUT_ZONE;\n     }\n \n+    /**\n+     * @return Timestamp type (with timezone) represented as INT96. This is only added for compatibility reasons\n+     * and can only be written using a Spark's ParquetWriteSupport. Writing this type should be avoided.\n+     */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgyNjE3NQ=="}, "originalCommit": {"oid": "b35027be3f3056b23a546f02ea9e4a1fcc91392c"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2OTcyOTg3OnYy", "diffSide": "RIGHT", "path": "spark/src/test/java/org/apache/iceberg/spark/data/TestSparkParquetReader.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQwMjozNzo1NlrOG2hlBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxNTozOToyN1rOG20OrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgyNjQzNg==", "bodyText": "Nit: we don't use final for local variables.", "url": "https://github.com/apache/iceberg/pull/1184#discussion_r459826436", "createdAt": "2020-07-24T02:37:56Z", "author": {"login": "rdblue"}, "path": "spark/src/test/java/org/apache/iceberg/spark/data/TestSparkParquetReader.java", "diffHunk": "@@ -67,4 +76,41 @@ protected void writeAndValidate(Schema schema) throws IOException {\n       Assert.assertFalse(\"Should not have extra rows\", rows.hasNext());\n     }\n   }\n+\n+  protected List<InternalRow> rowsFromFile(InputFile inputFile, Schema schema) throws IOException {\n+    try (CloseableIterable<InternalRow> reader =\n+        Parquet.read(inputFile)\n+            .project(schema)\n+            .createReaderFunc(type -> SparkParquetReaders.buildReader(schema, type))\n+            .build()) {\n+      return Lists.newArrayList(reader);\n+    }\n+  }\n+\n+  @Test\n+  public void testInt96TimestampProducedBySparkIsReadCorrectly() throws IOException {\n+    final Schema schema = new Schema(required(1, \"ts\", Types.TimestampType.asSparkInt96()));\n+    final StructType sparkSchema = SparkSchemaUtil.convert(schema);\n+    final Path parquetFile = Paths.get(temp.getRoot().getAbsolutePath(), \"parquet_int96.parquet\");\n+    final List<InternalRow> rows = Lists.newArrayList(RandomData.generateSpark(schema, 10, 0L));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b35027be3f3056b23a546f02ea9e4a1fcc91392c"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDEzMjAxMw==", "bodyText": "Done. Removed these final modifiers.", "url": "https://github.com/apache/iceberg/pull/1184#discussion_r460132013", "createdAt": "2020-07-24T15:39:27Z", "author": {"login": "gustavoatt"}, "path": "spark/src/test/java/org/apache/iceberg/spark/data/TestSparkParquetReader.java", "diffHunk": "@@ -67,4 +76,41 @@ protected void writeAndValidate(Schema schema) throws IOException {\n       Assert.assertFalse(\"Should not have extra rows\", rows.hasNext());\n     }\n   }\n+\n+  protected List<InternalRow> rowsFromFile(InputFile inputFile, Schema schema) throws IOException {\n+    try (CloseableIterable<InternalRow> reader =\n+        Parquet.read(inputFile)\n+            .project(schema)\n+            .createReaderFunc(type -> SparkParquetReaders.buildReader(schema, type))\n+            .build()) {\n+      return Lists.newArrayList(reader);\n+    }\n+  }\n+\n+  @Test\n+  public void testInt96TimestampProducedBySparkIsReadCorrectly() throws IOException {\n+    final Schema schema = new Schema(required(1, \"ts\", Types.TimestampType.asSparkInt96()));\n+    final StructType sparkSchema = SparkSchemaUtil.convert(schema);\n+    final Path parquetFile = Paths.get(temp.getRoot().getAbsolutePath(), \"parquet_int96.parquet\");\n+    final List<InternalRow> rows = Lists.newArrayList(RandomData.generateSpark(schema, 10, 0L));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgyNjQzNg=="}, "originalCommit": {"oid": "b35027be3f3056b23a546f02ea9e4a1fcc91392c"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2OTczMTMzOnYy", "diffSide": "RIGHT", "path": "spark/src/test/java/org/apache/iceberg/spark/data/TestSparkParquetReader.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQwMjozOTowOVrOG2hl2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxNTozODo1MlrOG20NVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgyNjY1MA==", "bodyText": "Why not use temp.newFile?", "url": "https://github.com/apache/iceberg/pull/1184#discussion_r459826650", "createdAt": "2020-07-24T02:39:09Z", "author": {"login": "rdblue"}, "path": "spark/src/test/java/org/apache/iceberg/spark/data/TestSparkParquetReader.java", "diffHunk": "@@ -67,4 +76,41 @@ protected void writeAndValidate(Schema schema) throws IOException {\n       Assert.assertFalse(\"Should not have extra rows\", rows.hasNext());\n     }\n   }\n+\n+  protected List<InternalRow> rowsFromFile(InputFile inputFile, Schema schema) throws IOException {\n+    try (CloseableIterable<InternalRow> reader =\n+        Parquet.read(inputFile)\n+            .project(schema)\n+            .createReaderFunc(type -> SparkParquetReaders.buildReader(schema, type))\n+            .build()) {\n+      return Lists.newArrayList(reader);\n+    }\n+  }\n+\n+  @Test\n+  public void testInt96TimestampProducedBySparkIsReadCorrectly() throws IOException {\n+    final Schema schema = new Schema(required(1, \"ts\", Types.TimestampType.asSparkInt96()));\n+    final StructType sparkSchema = SparkSchemaUtil.convert(schema);\n+    final Path parquetFile = Paths.get(temp.getRoot().getAbsolutePath(), \"parquet_int96.parquet\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b35027be3f3056b23a546f02ea9e4a1fcc91392c"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDEzMTY2OA==", "bodyText": "I initially tried that way but the writer fails because the file already exists.", "url": "https://github.com/apache/iceberg/pull/1184#discussion_r460131668", "createdAt": "2020-07-24T15:38:52Z", "author": {"login": "gustavoatt"}, "path": "spark/src/test/java/org/apache/iceberg/spark/data/TestSparkParquetReader.java", "diffHunk": "@@ -67,4 +76,41 @@ protected void writeAndValidate(Schema schema) throws IOException {\n       Assert.assertFalse(\"Should not have extra rows\", rows.hasNext());\n     }\n   }\n+\n+  protected List<InternalRow> rowsFromFile(InputFile inputFile, Schema schema) throws IOException {\n+    try (CloseableIterable<InternalRow> reader =\n+        Parquet.read(inputFile)\n+            .project(schema)\n+            .createReaderFunc(type -> SparkParquetReaders.buildReader(schema, type))\n+            .build()) {\n+      return Lists.newArrayList(reader);\n+    }\n+  }\n+\n+  @Test\n+  public void testInt96TimestampProducedBySparkIsReadCorrectly() throws IOException {\n+    final Schema schema = new Schema(required(1, \"ts\", Types.TimestampType.asSparkInt96()));\n+    final StructType sparkSchema = SparkSchemaUtil.convert(schema);\n+    final Path parquetFile = Paths.get(temp.getRoot().getAbsolutePath(), \"parquet_int96.parquet\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgyNjY1MA=="}, "originalCommit": {"oid": "b35027be3f3056b23a546f02ea9e4a1fcc91392c"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2OTczMjEyOnYy", "diffSide": "RIGHT", "path": "spark/src/test/java/org/apache/iceberg/spark/data/TestSparkParquetReader.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQwMjozOTo0NVrOG2hmRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxOTo0NzoyMVrOG27xSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgyNjc1OQ==", "bodyText": "I'd prefer to pass in a normal timestamp type and set a property, if needed, to enable INT96 support.", "url": "https://github.com/apache/iceberg/pull/1184#discussion_r459826759", "createdAt": "2020-07-24T02:39:45Z", "author": {"login": "rdblue"}, "path": "spark/src/test/java/org/apache/iceberg/spark/data/TestSparkParquetReader.java", "diffHunk": "@@ -67,4 +76,41 @@ protected void writeAndValidate(Schema schema) throws IOException {\n       Assert.assertFalse(\"Should not have extra rows\", rows.hasNext());\n     }\n   }\n+\n+  protected List<InternalRow> rowsFromFile(InputFile inputFile, Schema schema) throws IOException {\n+    try (CloseableIterable<InternalRow> reader =\n+        Parquet.read(inputFile)\n+            .project(schema)\n+            .createReaderFunc(type -> SparkParquetReaders.buildReader(schema, type))\n+            .build()) {\n+      return Lists.newArrayList(reader);\n+    }\n+  }\n+\n+  @Test\n+  public void testInt96TimestampProducedBySparkIsReadCorrectly() throws IOException {\n+    final Schema schema = new Schema(required(1, \"ts\", Types.TimestampType.asSparkInt96()));\n+    final StructType sparkSchema = SparkSchemaUtil.convert(schema);\n+    final Path parquetFile = Paths.get(temp.getRoot().getAbsolutePath(), \"parquet_int96.parquet\");\n+    final List<InternalRow> rows = Lists.newArrayList(RandomData.generateSpark(schema, 10, 0L));\n+\n+    try (FileAppender<InternalRow> writer =\n+        Parquet.write(Files.localOutput(parquetFile.toString()))\n+            .writeSupport(\n+                new org.apache.spark.sql.execution.datasources.parquet.ParquetWriteSupport())\n+            .set(\"org.apache.spark.sql.parquet.row.attributes\", sparkSchema.json())\n+            .set(\"org.apache.spark.legacyDateTime\", \"false\")\n+            .set(\"spark.sql.parquet.int96AsTimestamp\", \"true\")\n+            .set(\"spark.sql.parquet.writeLegacyFormat\", \"false\")\n+            .set(\"spark.sql.parquet.outputTimestampType\", \"INT96\")\n+            .schema(schema)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b35027be3f3056b23a546f02ea9e4a1fcc91392c"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI1NTU2Mw==", "bodyText": "I'm not sure I fully understand this comment.\nBut I did change my approach here, and while still writing InternalRow I removed most of these properties and left only the relevant ones to make sure that Spark writes these as int96.", "url": "https://github.com/apache/iceberg/pull/1184#discussion_r460255563", "createdAt": "2020-07-24T19:47:21Z", "author": {"login": "gustavoatt"}, "path": "spark/src/test/java/org/apache/iceberg/spark/data/TestSparkParquetReader.java", "diffHunk": "@@ -67,4 +76,41 @@ protected void writeAndValidate(Schema schema) throws IOException {\n       Assert.assertFalse(\"Should not have extra rows\", rows.hasNext());\n     }\n   }\n+\n+  protected List<InternalRow> rowsFromFile(InputFile inputFile, Schema schema) throws IOException {\n+    try (CloseableIterable<InternalRow> reader =\n+        Parquet.read(inputFile)\n+            .project(schema)\n+            .createReaderFunc(type -> SparkParquetReaders.buildReader(schema, type))\n+            .build()) {\n+      return Lists.newArrayList(reader);\n+    }\n+  }\n+\n+  @Test\n+  public void testInt96TimestampProducedBySparkIsReadCorrectly() throws IOException {\n+    final Schema schema = new Schema(required(1, \"ts\", Types.TimestampType.asSparkInt96()));\n+    final StructType sparkSchema = SparkSchemaUtil.convert(schema);\n+    final Path parquetFile = Paths.get(temp.getRoot().getAbsolutePath(), \"parquet_int96.parquet\");\n+    final List<InternalRow> rows = Lists.newArrayList(RandomData.generateSpark(schema, 10, 0L));\n+\n+    try (FileAppender<InternalRow> writer =\n+        Parquet.write(Files.localOutput(parquetFile.toString()))\n+            .writeSupport(\n+                new org.apache.spark.sql.execution.datasources.parquet.ParquetWriteSupport())\n+            .set(\"org.apache.spark.sql.parquet.row.attributes\", sparkSchema.json())\n+            .set(\"org.apache.spark.legacyDateTime\", \"false\")\n+            .set(\"spark.sql.parquet.int96AsTimestamp\", \"true\")\n+            .set(\"spark.sql.parquet.writeLegacyFormat\", \"false\")\n+            .set(\"spark.sql.parquet.outputTimestampType\", \"INT96\")\n+            .schema(schema)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgyNjc1OQ=="}, "originalCommit": {"oid": "b35027be3f3056b23a546f02ea9e4a1fcc91392c"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3MjU3MTI2OnYy", "diffSide": "RIGHT", "path": "data/src/main/java/org/apache/iceberg/data/parquet/BaseParquetReaders.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQyMDowMToxM1rOG28I_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQyMDowMToxM1rOG28I_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI2MTYyOA==", "bodyText": "Note for reviewers (and future me): toByteBuffer returns a duplicate of the internal buffer so that it is safe for uses of it to modify the buffer's position with methods like getLong.", "url": "https://github.com/apache/iceberg/pull/1184#discussion_r460261628", "createdAt": "2020-07-24T20:01:13Z", "author": {"login": "rdblue"}, "path": "data/src/main/java/org/apache/iceberg/data/parquet/BaseParquetReaders.java", "diffHunk": "@@ -345,6 +352,25 @@ public LocalDateTime read(LocalDateTime reuse) {\n     }\n   }\n \n+  private static class TimestampInt96Reader extends ParquetValueReaders.PrimitiveReader<LocalDateTime> {\n+    private static final long UNIX_EPOCH_JULIAN = 2_440_588L;\n+\n+    private TimestampInt96Reader(ColumnDescriptor desc) {\n+      super(desc);\n+    }\n+\n+    @Override\n+    public LocalDateTime read(LocalDateTime reuse) {\n+      final ByteBuffer byteBuffer = column.nextBinary().toByteBuffer().order(ByteOrder.LITTLE_ENDIAN);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e48187c68417a6c947480022dc8a6e6945ed5ca"}, "originalPosition": 41}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3747, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}