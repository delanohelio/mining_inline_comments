{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQwNzMwODI2", "number": 1140, "title": "ORC: skip non-iceberg columns when converting schema to Iceberg", "bodyText": "As mentioned in #989 (comment) and referenced in #1055 ORC previously assigned an ID based on an AtomicCounter to assign Iceberg IDs if they were not found in ORC type attributes.\nThis PR changes the implementation to use the ORC type visitor and skips types that do not have an Iceberg ID in the type attribute as follows:\n\nPrimitives: if the type does not have an Iceberg ID it is skipped\nLists: only included if element and the list type itself have an Iceberg ID, otherwise it is skipped\nMaps: only included if key, value and the map type itself have an Iceberg ID, otherwise it is skipped\nStructs: included as long as any of the fields in the struct has an Iceberg ID, otherwise it is skipped\n\nIf the schema as a whole does not have any Iceberg IDs, it fails with Exception.\nAdditional changes are:\n\nFixed NPE in ORC visitor when visiting lists\nAdded new generic OrcSchemaVisitor to traverse TypeDescription tree.\n\nPTAL @rdsr @rdblue - Thanks!", "createdAt": "2020-06-26T18:37:00Z", "url": "https://github.com/apache/iceberg/pull/1140", "merged": true, "mergeCommit": {"oid": "053bea6eaa705737aba9ef8961eefcaf509e107f"}, "closed": true, "closedAt": "2020-07-02T19:15:41Z", "author": {"login": "edgarRd"}, "timelineItems": {"totalCount": 23, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcuI10AgH2gAyNDQwNzMwODI2OjkxMDQ5NDllNmJkN2M2MmEzMjAzNTUwYjJkMDAzYzQ4NDlmYzI4NzU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcxCjfmgBqjM1MDgxNjI0OTk=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "9104949e6bd7c62a3203550b2d003c4849fc2875", "author": {"user": {"login": "edgarRd", "name": "Edgar Rodriguez"}}, "url": "https://github.com/apache/iceberg/commit/9104949e6bd7c62a3203550b2d003c4849fc2875", "committedDate": "2020-06-23T17:24:37Z", "message": "Skip columns without iceberg ids on schema conversion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2970838dbc70a2eec8ce454c435aacfa0ac4c82c", "author": {"user": {"login": "edgarRd", "name": "Edgar Rodriguez"}}, "url": "https://github.com/apache/iceberg/commit/2970838dbc70a2eec8ce454c435aacfa0ac4c82c", "committedDate": "2020-06-25T18:30:08Z", "message": "Fix NPE on null list in ORC type visitor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e74640c29b1dae917059e2cb201715c4344abce5", "author": {"user": {"login": "edgarRd", "name": "Edgar Rodriguez"}}, "url": "https://github.com/apache/iceberg/commit/e74640c29b1dae917059e2cb201715c4344abce5", "committedDate": "2020-06-25T22:07:27Z", "message": "Fix #1055 Use visitor to convert ORC schema to Iceberg\n\nThis change also skips columns that do not have an Iceberg ID attribute."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d66cb470ef45a25c2726bb1255fb3cf4bb981d2a", "author": {"user": {"login": "edgarRd", "name": "Edgar Rodriguez"}}, "url": "https://github.com/apache/iceberg/commit/d66cb470ef45a25c2726bb1255fb3cf4bb981d2a", "committedDate": "2020-06-26T18:33:55Z", "message": "Add test for skipping non-iceberg columns in ORC"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4NzA2MTY0", "url": "https://github.com/apache/iceberg/pull/1140#pullrequestreview-438706164", "createdAt": "2020-06-27T15:37:25Z", "commit": {"oid": "d66cb470ef45a25c2726bb1255fb3cf4bb981d2a"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QxNTozNzoyNVrOGp2iuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QxNTo1OTowM1rOGp2qOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjUzODQyNA==", "bodyText": "I think the javadoc on this method needs revision?", "url": "https://github.com/apache/iceberg/pull/1140#discussion_r446538424", "createdAt": "2020-06-27T15:37:25Z", "author": {"login": "rdsr"}, "path": "orc/src/main/java/org/apache/iceberg/orc/ORCSchemaUtil.java", "diffHunk": "@@ -214,10 +212,13 @@ public static Schema convert(TypeDescription orcSchema) {\n         \"Error in ORC file, children fields and names do not match.\");\n \n     List<Types.NestedField> icebergFields = Lists.newArrayListWithExpectedSize(children.size());\n-    AtomicInteger lastColumnId = new AtomicInteger(getMaxIcebergId(orcSchema));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d66cb470ef45a25c2726bb1255fb3cf4bb981d2a"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU0MDE1MQ==", "bodyText": "I wonder if this logic should be in the visitor impl, The visitor  superclass should only be concerned with traversal, IMO", "url": "https://github.com/apache/iceberg/pull/1140#discussion_r446540151", "createdAt": "2020-06-27T15:56:20Z", "author": {"login": "rdsr"}, "path": "orc/src/main/java/org/apache/iceberg/orc/OrcSchemaWithTypeVisitor.java", "diffHunk": "@@ -63,12 +68,20 @@\n     List<TypeDescription> fields = record.getChildren();\n     List<String> names = record.getFieldNames();\n     List<T> results = Lists.newArrayListWithExpectedSize(fields.size());\n-    for (TypeDescription field : fields) {\n-      int fieldId = ORCSchemaUtil.fieldId(field);\n-      Types.NestedField iField = struct != null ? struct.field(fieldId) : null;\n+    List<String> includedNames = Lists.newArrayListWithExpectedSize(names.size());\n+    for (int i = 0; i < fields.size(); ++i) {\n+      TypeDescription field = fields.get(i);\n+      String name = names.get(i);\n+      Optional<Integer> fieldId = ORCSchemaUtil.icebergID(field);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d66cb470ef45a25c2726bb1255fb3cf4bb981d2a"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU0MDM0Ng==", "bodyText": "Would it make sense to define an OrcSchemaVisitor visitor, similar to org.apache.iceberg.avro.AvroSchemaVisitor.  Here we are not making use of the Iceberg type parameter at all and that could be a little confusing.", "url": "https://github.com/apache/iceberg/pull/1140#discussion_r446540346", "createdAt": "2020-06-27T15:59:03Z", "author": {"login": "rdsr"}, "path": "orc/src/main/java/org/apache/iceberg/orc/ORCSchemaUtil.java", "diffHunk": "@@ -403,114 +398,150 @@ private static boolean isRequired(TypeDescription orcType) {\n         Types.NestedField.optional(icebergID, name, type);\n   }\n \n-  private static Types.NestedField convertOrcToIceberg(TypeDescription orcType, String name,\n-                                                       TypeUtil.NextID nextID) {\n+  private static class OrcToIcebergVisitor extends OrcSchemaWithTypeVisitor<Optional<Types.NestedField>> {\n \n-    final int icebergID = icebergID(orcType).orElseGet(nextID::get);\n-    final boolean isRequired = isRequired(orcType);\n+    private final Map<Integer, OrcField> icebergToOrcMapping;\n \n-    switch (orcType.getCategory()) {\n-      case BOOLEAN:\n-        return getIcebergType(icebergID, name, Types.BooleanType.get(), isRequired);\n-      case BYTE:\n-      case SHORT:\n-      case INT:\n-        return getIcebergType(icebergID, name, Types.IntegerType.get(), isRequired);\n-      case LONG:\n-        String longAttributeValue = orcType.getAttributeValue(ICEBERG_LONG_TYPE_ATTRIBUTE);\n-        LongType longType = longAttributeValue == null ? LongType.LONG : LongType.valueOf(longAttributeValue);\n-        switch (longType) {\n-          case TIME:\n-            return getIcebergType(icebergID, name, Types.TimeType.get(), isRequired);\n-          case LONG:\n-            return getIcebergType(icebergID, name, Types.LongType.get(), isRequired);\n-          default:\n-            throw new IllegalStateException(\"Invalid Long type found in ORC type attribute\");\n-        }\n-      case FLOAT:\n-        return getIcebergType(icebergID, name, Types.FloatType.get(), isRequired);\n-      case DOUBLE:\n-        return getIcebergType(icebergID, name, Types.DoubleType.get(), isRequired);\n-      case STRING:\n-      case CHAR:\n-      case VARCHAR:\n-        return getIcebergType(icebergID, name, Types.StringType.get(), isRequired);\n-      case BINARY:\n-        String binaryAttributeValue = orcType.getAttributeValue(ICEBERG_BINARY_TYPE_ATTRIBUTE);\n-        BinaryType binaryType = binaryAttributeValue == null ? BinaryType.BINARY :\n-            BinaryType.valueOf(binaryAttributeValue);\n-        switch (binaryType) {\n-          case UUID:\n-            return getIcebergType(icebergID, name, Types.UUIDType.get(), isRequired);\n-          case FIXED:\n-            int fixedLength = Integer.parseInt(orcType.getAttributeValue(ICEBERG_FIELD_LENGTH));\n-            return getIcebergType(icebergID, name, Types.FixedType.ofLength(fixedLength), isRequired);\n-          case BINARY:\n-            return getIcebergType(icebergID, name, Types.BinaryType.get(), isRequired);\n-          default:\n-            throw new IllegalStateException(\"Invalid Binary type found in ORC type attribute\");\n-        }\n-      case DATE:\n-        return getIcebergType(icebergID, name, Types.DateType.get(), isRequired);\n-      case TIMESTAMP:\n-        return getIcebergType(icebergID, name, Types.TimestampType.withoutZone(), isRequired);\n-      case TIMESTAMP_INSTANT:\n-        return getIcebergType(icebergID, name, Types.TimestampType.withZone(), isRequired);\n-      case DECIMAL:\n-        return getIcebergType(icebergID, name,\n-            Types.DecimalType.of(orcType.getPrecision(), orcType.getScale()),\n-            isRequired);\n-      case STRUCT: {\n-        List<String> fieldNames = orcType.getFieldNames();\n-        List<TypeDescription> fieldTypes = orcType.getChildren();\n-        List<Types.NestedField> fields = new ArrayList<>(fieldNames.size());\n-        for (int c = 0; c < fieldNames.size(); ++c) {\n-          String childName = fieldNames.get(c);\n-          TypeDescription type = fieldTypes.get(c);\n-          Types.NestedField field = convertOrcToIceberg(type, childName, nextID);\n-          fields.add(field);\n-        }\n+    OrcToIcebergVisitor(Map<Integer, OrcField> icebergToOrcMapping) {\n+      this.icebergToOrcMapping = icebergToOrcMapping;\n+    }\n \n-        return getIcebergType(icebergID, name, Types.StructType.of(fields), isRequired);\n+    @Override\n+    public Optional<Types.NestedField> record(Types.StructType iStruct, TypeDescription record, List<String> names,\n+                                              List<Optional<Types.NestedField>> fields) {\n+      boolean isRequired = isRequired(record);\n+      Optional<Integer> icebergIdOpt = icebergID(record);\n+      if (!icebergIdOpt.isPresent() || fields.size() == 0) {\n+        return Optional.empty();\n       }\n-      case LIST: {\n-        TypeDescription elementType = orcType.getChildren().get(0);\n-        Types.NestedField element = convertOrcToIceberg(elementType, \"element\", nextID);\n-\n-        Types.ListType listTypeWithElem = isRequired(elementType) ?\n-            Types.ListType.ofRequired(element.fieldId(), element.type()) :\n-            Types.ListType.ofOptional(element.fieldId(), element.type());\n-        return isRequired ?\n-            Types.NestedField.required(icebergID, name, listTypeWithElem) :\n-            Types.NestedField.optional(icebergID, name, listTypeWithElem);\n-      }\n-      case MAP: {\n-        TypeDescription keyType = orcType.getChildren().get(0);\n-        Types.NestedField key = convertOrcToIceberg(keyType, \"key\", nextID);\n-        TypeDescription valueType = orcType.getChildren().get(1);\n-        Types.NestedField value = convertOrcToIceberg(valueType, \"value\", nextID);\n \n-        Types.MapType mapTypeWithKV = isRequired(valueType) ?\n-            Types.MapType.ofRequired(key.fieldId(), value.fieldId(), key.type(), value.type()) :\n-            Types.MapType.ofOptional(key.fieldId(), value.fieldId(), key.type(), value.type());\n+      Types.StructType structType = Types.StructType.of(\n+          fields.stream().filter(Optional::isPresent).map(Optional::get).collect(Collectors.toList()));\n+      return Optional.of(getIcebergType(icebergIdOpt.get(), icebergToOrcMapping.get(icebergIdOpt.get()).name(),\n+          structType, isRequired));\n+    }\n \n-        return getIcebergType(icebergID, name, mapTypeWithKV, isRequired);\n+    @Override\n+    public Optional<Types.NestedField> list(Types.ListType iList, TypeDescription array,\n+                                            Optional<Types.NestedField> element) {\n+      boolean isRequired = isRequired(array);\n+      Optional<Integer> icebergIdOpt = icebergID(array);\n+\n+      if (!icebergIdOpt.isPresent() || !element.isPresent()) {\n+        return Optional.empty();\n       }\n-      default:\n-        // We don't have an answer for union types.\n-        throw new IllegalArgumentException(\"Can't handle \" + orcType);\n+\n+      Types.NestedField foundElement = element.get();\n+      Types.ListType listTypeWithElem = isRequired(array.getChildren().get(0)) ?\n+          Types.ListType.ofRequired(foundElement.fieldId(), foundElement.type()) :\n+          Types.ListType.ofOptional(foundElement.fieldId(), foundElement.type());\n+      return Optional.of(getIcebergType(icebergIdOpt.get(),\n+          icebergToOrcMapping.get(icebergIdOpt.get()).name(), listTypeWithElem, isRequired));\n     }\n-  }\n \n-  private static int getMaxIcebergId(TypeDescription originalOrcSchema) {\n-    int maxId = icebergID(originalOrcSchema).orElse(0);\n-    final List<TypeDescription> children = Optional.ofNullable(originalOrcSchema.getChildren())\n-        .orElse(Collections.emptyList());\n-    for (TypeDescription child : children) {\n-      maxId = Math.max(maxId, getMaxIcebergId(child));\n+    @Override\n+    public Optional<Types.NestedField> map(Types.MapType iMap, TypeDescription map, Optional<Types.NestedField> key,\n+                                           Optional<Types.NestedField> value) {\n+      boolean isRequired = isRequired(map);\n+      Optional<Integer> icebergIdOpt = icebergID(map);\n+\n+      if (!icebergIdOpt.isPresent() || !key.isPresent() || !value.isPresent()) {\n+        return Optional.empty();\n+      }\n+\n+      Types.NestedField foundKey = key.get();\n+      Types.NestedField foundValue = value.get();\n+      Types.MapType mapTypeWithKV = isRequired(map.getChildren().get(1)) ?\n+          Types.MapType.ofRequired(foundKey.fieldId(), foundValue.fieldId(), foundKey.type(), foundValue.type()) :\n+          Types.MapType.ofOptional(foundKey.fieldId(), foundValue.fieldId(), foundKey.type(), foundValue.type());\n+\n+      return Optional.of(getIcebergType(icebergIdOpt.get(), icebergToOrcMapping.get(icebergIdOpt.get()).name(),\n+          mapTypeWithKV, isRequired));\n     }\n \n-    return maxId;\n+    @Override\n+    public Optional<Types.NestedField> primitive(Type.PrimitiveType iPrimitive, TypeDescription primitive) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d66cb470ef45a25c2726bb1255fb3cf4bb981d2a"}, "originalPosition": 220}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "170551c045aee18d167f4cef0c71563ab5a21235", "author": {"user": {"login": "edgarRd", "name": "Edgar Rodriguez"}}, "url": "https://github.com/apache/iceberg/commit/170551c045aee18d167f4cef0c71563ab5a21235", "committedDate": "2020-06-29T16:47:01Z", "message": "Update javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "693a7faf2f754dd7c268901e4ff2d392df365c80", "author": {"user": {"login": "edgarRd", "name": "Edgar Rodriguez"}}, "url": "https://github.com/apache/iceberg/commit/693a7faf2f754dd7c268901e4ff2d392df365c80", "committedDate": "2020-06-29T17:49:19Z", "message": "Add OrcSchemaVisitor"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "59e1b50166772867dae58ac0537e1b364c8c0421", "author": {"user": {"login": "edgarRd", "name": "Edgar Rodriguez"}}, "url": "https://github.com/apache/iceberg/commit/59e1b50166772867dae58ac0537e1b364c8c0421", "committedDate": "2020-06-29T17:47:38Z", "message": "Add OrcSchemaVisitor"}, "afterCommit": {"oid": "693a7faf2f754dd7c268901e4ff2d392df365c80", "author": {"user": {"login": "edgarRd", "name": "Edgar Rodriguez"}}, "url": "https://github.com/apache/iceberg/commit/693a7faf2f754dd7c268901e4ff2d392df365c80", "committedDate": "2020-06-29T17:49:19Z", "message": "Add OrcSchemaVisitor"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwNDM3OTY1", "url": "https://github.com/apache/iceberg/pull/1140#pullrequestreview-440437965", "createdAt": "2020-06-30T22:49:51Z", "commit": {"oid": "693a7faf2f754dd7c268901e4ff2d392df365c80"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMjo0OTo1MVrOGrRFCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMjo0OTo1MVrOGrRFCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAyMTc3MQ==", "bodyText": "Looks like this map is only used to get the ORC field name. Could it be an idToName map instead?", "url": "https://github.com/apache/iceberg/pull/1140#discussion_r448021771", "createdAt": "2020-06-30T22:49:51Z", "author": {"login": "rdblue"}, "path": "orc/src/main/java/org/apache/iceberg/orc/ORCSchemaUtil.java", "diffHunk": "@@ -403,114 +405,150 @@ private static boolean isRequired(TypeDescription orcType) {\n         Types.NestedField.optional(icebergID, name, type);\n   }\n \n-  private static Types.NestedField convertOrcToIceberg(TypeDescription orcType, String name,\n-                                                       TypeUtil.NextID nextID) {\n+  private static class OrcToIcebergVisitor extends OrcSchemaVisitor<Optional<Types.NestedField>> {\n \n-    final int icebergID = icebergID(orcType).orElseGet(nextID::get);\n-    final boolean isRequired = isRequired(orcType);\n+    private final Map<Integer, OrcField> icebergToOrcMapping;\n \n-    switch (orcType.getCategory()) {\n-      case BOOLEAN:\n-        return getIcebergType(icebergID, name, Types.BooleanType.get(), isRequired);\n-      case BYTE:\n-      case SHORT:\n-      case INT:\n-        return getIcebergType(icebergID, name, Types.IntegerType.get(), isRequired);\n-      case LONG:\n-        String longAttributeValue = orcType.getAttributeValue(ICEBERG_LONG_TYPE_ATTRIBUTE);\n-        LongType longType = longAttributeValue == null ? LongType.LONG : LongType.valueOf(longAttributeValue);\n-        switch (longType) {\n-          case TIME:\n-            return getIcebergType(icebergID, name, Types.TimeType.get(), isRequired);\n-          case LONG:\n-            return getIcebergType(icebergID, name, Types.LongType.get(), isRequired);\n-          default:\n-            throw new IllegalStateException(\"Invalid Long type found in ORC type attribute\");\n-        }\n-      case FLOAT:\n-        return getIcebergType(icebergID, name, Types.FloatType.get(), isRequired);\n-      case DOUBLE:\n-        return getIcebergType(icebergID, name, Types.DoubleType.get(), isRequired);\n-      case STRING:\n-      case CHAR:\n-      case VARCHAR:\n-        return getIcebergType(icebergID, name, Types.StringType.get(), isRequired);\n-      case BINARY:\n-        String binaryAttributeValue = orcType.getAttributeValue(ICEBERG_BINARY_TYPE_ATTRIBUTE);\n-        BinaryType binaryType = binaryAttributeValue == null ? BinaryType.BINARY :\n-            BinaryType.valueOf(binaryAttributeValue);\n-        switch (binaryType) {\n-          case UUID:\n-            return getIcebergType(icebergID, name, Types.UUIDType.get(), isRequired);\n-          case FIXED:\n-            int fixedLength = Integer.parseInt(orcType.getAttributeValue(ICEBERG_FIELD_LENGTH));\n-            return getIcebergType(icebergID, name, Types.FixedType.ofLength(fixedLength), isRequired);\n-          case BINARY:\n-            return getIcebergType(icebergID, name, Types.BinaryType.get(), isRequired);\n-          default:\n-            throw new IllegalStateException(\"Invalid Binary type found in ORC type attribute\");\n-        }\n-      case DATE:\n-        return getIcebergType(icebergID, name, Types.DateType.get(), isRequired);\n-      case TIMESTAMP:\n-        return getIcebergType(icebergID, name, Types.TimestampType.withoutZone(), isRequired);\n-      case TIMESTAMP_INSTANT:\n-        return getIcebergType(icebergID, name, Types.TimestampType.withZone(), isRequired);\n-      case DECIMAL:\n-        return getIcebergType(icebergID, name,\n-            Types.DecimalType.of(orcType.getPrecision(), orcType.getScale()),\n-            isRequired);\n-      case STRUCT: {\n-        List<String> fieldNames = orcType.getFieldNames();\n-        List<TypeDescription> fieldTypes = orcType.getChildren();\n-        List<Types.NestedField> fields = new ArrayList<>(fieldNames.size());\n-        for (int c = 0; c < fieldNames.size(); ++c) {\n-          String childName = fieldNames.get(c);\n-          TypeDescription type = fieldTypes.get(c);\n-          Types.NestedField field = convertOrcToIceberg(type, childName, nextID);\n-          fields.add(field);\n-        }\n+    OrcToIcebergVisitor(Map<Integer, OrcField> icebergToOrcMapping) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "693a7faf2f754dd7c268901e4ff2d392df365c80"}, "originalPosition": 131}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwNDM4NzU3", "url": "https://github.com/apache/iceberg/pull/1140#pullrequestreview-440438757", "createdAt": "2020-06-30T22:51:50Z", "commit": {"oid": "693a7faf2f754dd7c268901e4ff2d392df365c80"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMjo1MTo1MVrOGrRH2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMjo1MTo1MVrOGrRH2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAyMjQ5MQ==", "bodyText": "I don't think it is necessary to call getIcebergType (which returns a NestedField?).\nIceberg added Types.NestedField.of() that accepts a boolean isOptional so you don't have to call just required or optional. That could be used in place of getIcebergType.", "url": "https://github.com/apache/iceberg/pull/1140#discussion_r448022491", "createdAt": "2020-06-30T22:51:51Z", "author": {"login": "rdblue"}, "path": "orc/src/main/java/org/apache/iceberg/orc/ORCSchemaUtil.java", "diffHunk": "@@ -403,114 +405,150 @@ private static boolean isRequired(TypeDescription orcType) {\n         Types.NestedField.optional(icebergID, name, type);\n   }\n \n-  private static Types.NestedField convertOrcToIceberg(TypeDescription orcType, String name,\n-                                                       TypeUtil.NextID nextID) {\n+  private static class OrcToIcebergVisitor extends OrcSchemaVisitor<Optional<Types.NestedField>> {\n \n-    final int icebergID = icebergID(orcType).orElseGet(nextID::get);\n-    final boolean isRequired = isRequired(orcType);\n+    private final Map<Integer, OrcField> icebergToOrcMapping;\n \n-    switch (orcType.getCategory()) {\n-      case BOOLEAN:\n-        return getIcebergType(icebergID, name, Types.BooleanType.get(), isRequired);\n-      case BYTE:\n-      case SHORT:\n-      case INT:\n-        return getIcebergType(icebergID, name, Types.IntegerType.get(), isRequired);\n-      case LONG:\n-        String longAttributeValue = orcType.getAttributeValue(ICEBERG_LONG_TYPE_ATTRIBUTE);\n-        LongType longType = longAttributeValue == null ? LongType.LONG : LongType.valueOf(longAttributeValue);\n-        switch (longType) {\n-          case TIME:\n-            return getIcebergType(icebergID, name, Types.TimeType.get(), isRequired);\n-          case LONG:\n-            return getIcebergType(icebergID, name, Types.LongType.get(), isRequired);\n-          default:\n-            throw new IllegalStateException(\"Invalid Long type found in ORC type attribute\");\n-        }\n-      case FLOAT:\n-        return getIcebergType(icebergID, name, Types.FloatType.get(), isRequired);\n-      case DOUBLE:\n-        return getIcebergType(icebergID, name, Types.DoubleType.get(), isRequired);\n-      case STRING:\n-      case CHAR:\n-      case VARCHAR:\n-        return getIcebergType(icebergID, name, Types.StringType.get(), isRequired);\n-      case BINARY:\n-        String binaryAttributeValue = orcType.getAttributeValue(ICEBERG_BINARY_TYPE_ATTRIBUTE);\n-        BinaryType binaryType = binaryAttributeValue == null ? BinaryType.BINARY :\n-            BinaryType.valueOf(binaryAttributeValue);\n-        switch (binaryType) {\n-          case UUID:\n-            return getIcebergType(icebergID, name, Types.UUIDType.get(), isRequired);\n-          case FIXED:\n-            int fixedLength = Integer.parseInt(orcType.getAttributeValue(ICEBERG_FIELD_LENGTH));\n-            return getIcebergType(icebergID, name, Types.FixedType.ofLength(fixedLength), isRequired);\n-          case BINARY:\n-            return getIcebergType(icebergID, name, Types.BinaryType.get(), isRequired);\n-          default:\n-            throw new IllegalStateException(\"Invalid Binary type found in ORC type attribute\");\n-        }\n-      case DATE:\n-        return getIcebergType(icebergID, name, Types.DateType.get(), isRequired);\n-      case TIMESTAMP:\n-        return getIcebergType(icebergID, name, Types.TimestampType.withoutZone(), isRequired);\n-      case TIMESTAMP_INSTANT:\n-        return getIcebergType(icebergID, name, Types.TimestampType.withZone(), isRequired);\n-      case DECIMAL:\n-        return getIcebergType(icebergID, name,\n-            Types.DecimalType.of(orcType.getPrecision(), orcType.getScale()),\n-            isRequired);\n-      case STRUCT: {\n-        List<String> fieldNames = orcType.getFieldNames();\n-        List<TypeDescription> fieldTypes = orcType.getChildren();\n-        List<Types.NestedField> fields = new ArrayList<>(fieldNames.size());\n-        for (int c = 0; c < fieldNames.size(); ++c) {\n-          String childName = fieldNames.get(c);\n-          TypeDescription type = fieldTypes.get(c);\n-          Types.NestedField field = convertOrcToIceberg(type, childName, nextID);\n-          fields.add(field);\n-        }\n+    OrcToIcebergVisitor(Map<Integer, OrcField> icebergToOrcMapping) {\n+      this.icebergToOrcMapping = icebergToOrcMapping;\n+    }\n \n-        return getIcebergType(icebergID, name, Types.StructType.of(fields), isRequired);\n-      }\n-      case LIST: {\n-        TypeDescription elementType = orcType.getChildren().get(0);\n-        Types.NestedField element = convertOrcToIceberg(elementType, \"element\", nextID);\n-\n-        Types.ListType listTypeWithElem = isRequired(elementType) ?\n-            Types.ListType.ofRequired(element.fieldId(), element.type()) :\n-            Types.ListType.ofOptional(element.fieldId(), element.type());\n-        return isRequired ?\n-            Types.NestedField.required(icebergID, name, listTypeWithElem) :\n-            Types.NestedField.optional(icebergID, name, listTypeWithElem);\n+    @Override\n+    public Optional<Types.NestedField> record(TypeDescription record, List<String> names,\n+                                              List<Optional<Types.NestedField>> fields) {\n+      boolean isRequired = isRequired(record);\n+      Optional<Integer> icebergIdOpt = icebergID(record);\n+      if (!icebergIdOpt.isPresent() || fields.size() == 0) {\n+        return Optional.empty();\n       }\n-      case MAP: {\n-        TypeDescription keyType = orcType.getChildren().get(0);\n-        Types.NestedField key = convertOrcToIceberg(keyType, \"key\", nextID);\n-        TypeDescription valueType = orcType.getChildren().get(1);\n-        Types.NestedField value = convertOrcToIceberg(valueType, \"value\", nextID);\n \n-        Types.MapType mapTypeWithKV = isRequired(valueType) ?\n-            Types.MapType.ofRequired(key.fieldId(), value.fieldId(), key.type(), value.type()) :\n-            Types.MapType.ofOptional(key.fieldId(), value.fieldId(), key.type(), value.type());\n+      Types.StructType structType = Types.StructType.of(\n+          fields.stream().filter(Optional::isPresent).map(Optional::get).collect(Collectors.toList()));\n+      return Optional.of(getIcebergType(icebergIdOpt.get(), icebergToOrcMapping.get(icebergIdOpt.get()).name(),\n+          structType, isRequired));\n+    }\n+\n+    @Override\n+    public Optional<Types.NestedField> list(TypeDescription array,\n+                                            Optional<Types.NestedField> element) {\n+      boolean isRequired = isRequired(array);\n+      Optional<Integer> icebergIdOpt = icebergID(array);\n \n-        return getIcebergType(icebergID, name, mapTypeWithKV, isRequired);\n+      if (!icebergIdOpt.isPresent() || !element.isPresent()) {\n+        return Optional.empty();\n       }\n-      default:\n-        // We don't have an answer for union types.\n-        throw new IllegalArgumentException(\"Can't handle \" + orcType);\n+\n+      Types.NestedField foundElement = element.get();\n+      Types.ListType listTypeWithElem = isRequired(array.getChildren().get(0)) ?\n+          Types.ListType.ofRequired(foundElement.fieldId(), foundElement.type()) :\n+          Types.ListType.ofOptional(foundElement.fieldId(), foundElement.type());\n+      return Optional.of(getIcebergType(icebergIdOpt.get(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "693a7faf2f754dd7c268901e4ff2d392df365c80"}, "originalPosition": 188}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwNDQwNjMx", "url": "https://github.com/apache/iceberg/pull/1140#pullrequestreview-440440631", "createdAt": "2020-06-30T22:56:38Z", "commit": {"oid": "693a7faf2f754dd7c268901e4ff2d392df365c80"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMjo1NjozOFrOGrROXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMjo1NjozOFrOGrROXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAyNDE1Ng==", "bodyText": "Should this also check that any of the fields are defined?\nif (!icebergIdOpt.isPresent() || !fields.stream().anyMatch(Optional::isPresent)) {\n  return Optional.empty();\n}", "url": "https://github.com/apache/iceberg/pull/1140#discussion_r448024156", "createdAt": "2020-06-30T22:56:38Z", "author": {"login": "rdblue"}, "path": "orc/src/main/java/org/apache/iceberg/orc/ORCSchemaUtil.java", "diffHunk": "@@ -403,114 +405,150 @@ private static boolean isRequired(TypeDescription orcType) {\n         Types.NestedField.optional(icebergID, name, type);\n   }\n \n-  private static Types.NestedField convertOrcToIceberg(TypeDescription orcType, String name,\n-                                                       TypeUtil.NextID nextID) {\n+  private static class OrcToIcebergVisitor extends OrcSchemaVisitor<Optional<Types.NestedField>> {\n \n-    final int icebergID = icebergID(orcType).orElseGet(nextID::get);\n-    final boolean isRequired = isRequired(orcType);\n+    private final Map<Integer, OrcField> icebergToOrcMapping;\n \n-    switch (orcType.getCategory()) {\n-      case BOOLEAN:\n-        return getIcebergType(icebergID, name, Types.BooleanType.get(), isRequired);\n-      case BYTE:\n-      case SHORT:\n-      case INT:\n-        return getIcebergType(icebergID, name, Types.IntegerType.get(), isRequired);\n-      case LONG:\n-        String longAttributeValue = orcType.getAttributeValue(ICEBERG_LONG_TYPE_ATTRIBUTE);\n-        LongType longType = longAttributeValue == null ? LongType.LONG : LongType.valueOf(longAttributeValue);\n-        switch (longType) {\n-          case TIME:\n-            return getIcebergType(icebergID, name, Types.TimeType.get(), isRequired);\n-          case LONG:\n-            return getIcebergType(icebergID, name, Types.LongType.get(), isRequired);\n-          default:\n-            throw new IllegalStateException(\"Invalid Long type found in ORC type attribute\");\n-        }\n-      case FLOAT:\n-        return getIcebergType(icebergID, name, Types.FloatType.get(), isRequired);\n-      case DOUBLE:\n-        return getIcebergType(icebergID, name, Types.DoubleType.get(), isRequired);\n-      case STRING:\n-      case CHAR:\n-      case VARCHAR:\n-        return getIcebergType(icebergID, name, Types.StringType.get(), isRequired);\n-      case BINARY:\n-        String binaryAttributeValue = orcType.getAttributeValue(ICEBERG_BINARY_TYPE_ATTRIBUTE);\n-        BinaryType binaryType = binaryAttributeValue == null ? BinaryType.BINARY :\n-            BinaryType.valueOf(binaryAttributeValue);\n-        switch (binaryType) {\n-          case UUID:\n-            return getIcebergType(icebergID, name, Types.UUIDType.get(), isRequired);\n-          case FIXED:\n-            int fixedLength = Integer.parseInt(orcType.getAttributeValue(ICEBERG_FIELD_LENGTH));\n-            return getIcebergType(icebergID, name, Types.FixedType.ofLength(fixedLength), isRequired);\n-          case BINARY:\n-            return getIcebergType(icebergID, name, Types.BinaryType.get(), isRequired);\n-          default:\n-            throw new IllegalStateException(\"Invalid Binary type found in ORC type attribute\");\n-        }\n-      case DATE:\n-        return getIcebergType(icebergID, name, Types.DateType.get(), isRequired);\n-      case TIMESTAMP:\n-        return getIcebergType(icebergID, name, Types.TimestampType.withoutZone(), isRequired);\n-      case TIMESTAMP_INSTANT:\n-        return getIcebergType(icebergID, name, Types.TimestampType.withZone(), isRequired);\n-      case DECIMAL:\n-        return getIcebergType(icebergID, name,\n-            Types.DecimalType.of(orcType.getPrecision(), orcType.getScale()),\n-            isRequired);\n-      case STRUCT: {\n-        List<String> fieldNames = orcType.getFieldNames();\n-        List<TypeDescription> fieldTypes = orcType.getChildren();\n-        List<Types.NestedField> fields = new ArrayList<>(fieldNames.size());\n-        for (int c = 0; c < fieldNames.size(); ++c) {\n-          String childName = fieldNames.get(c);\n-          TypeDescription type = fieldTypes.get(c);\n-          Types.NestedField field = convertOrcToIceberg(type, childName, nextID);\n-          fields.add(field);\n-        }\n+    OrcToIcebergVisitor(Map<Integer, OrcField> icebergToOrcMapping) {\n+      this.icebergToOrcMapping = icebergToOrcMapping;\n+    }\n \n-        return getIcebergType(icebergID, name, Types.StructType.of(fields), isRequired);\n-      }\n-      case LIST: {\n-        TypeDescription elementType = orcType.getChildren().get(0);\n-        Types.NestedField element = convertOrcToIceberg(elementType, \"element\", nextID);\n-\n-        Types.ListType listTypeWithElem = isRequired(elementType) ?\n-            Types.ListType.ofRequired(element.fieldId(), element.type()) :\n-            Types.ListType.ofOptional(element.fieldId(), element.type());\n-        return isRequired ?\n-            Types.NestedField.required(icebergID, name, listTypeWithElem) :\n-            Types.NestedField.optional(icebergID, name, listTypeWithElem);\n+    @Override\n+    public Optional<Types.NestedField> record(TypeDescription record, List<String> names,\n+                                              List<Optional<Types.NestedField>> fields) {\n+      boolean isRequired = isRequired(record);\n+      Optional<Integer> icebergIdOpt = icebergID(record);\n+      if (!icebergIdOpt.isPresent() || fields.size() == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "693a7faf2f754dd7c268901e4ff2d392df365c80"}, "originalPosition": 152}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwNDQwNzcy", "url": "https://github.com/apache/iceberg/pull/1140#pullrequestreview-440440772", "createdAt": "2020-06-30T22:57:01Z", "commit": {"oid": "693a7faf2f754dd7c268901e4ff2d392df365c80"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMjo1NzowMVrOGrRO0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMjo1NzowMVrOGrRO0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAyNDI3NQ==", "bodyText": "Instead of looping over children here, why not just call the visitor on the root orcSchema? Then you could check whether the record was present. If not, throw the exception.", "url": "https://github.com/apache/iceberg/pull/1140#discussion_r448024275", "createdAt": "2020-06-30T22:57:01Z", "author": {"login": "rdblue"}, "path": "orc/src/main/java/org/apache/iceberg/orc/ORCSchemaUtil.java", "diffHunk": "@@ -214,10 +213,13 @@ public static Schema convert(TypeDescription orcSchema) {\n         \"Error in ORC file, children fields and names do not match.\");\n \n     List<Types.NestedField> icebergFields = Lists.newArrayListWithExpectedSize(children.size());\n-    AtomicInteger lastColumnId = new AtomicInteger(getMaxIcebergId(orcSchema));\n-    for (int i = 0; i < children.size(); i++) {\n-      icebergFields.add(convertOrcToIceberg(children.get(i), childrenNames.get(i),\n-          lastColumnId::incrementAndGet));\n+    OrcToIcebergVisitor schemaConverter = new OrcToIcebergVisitor(icebergToOrcMapping(\"root\", orcSchema));\n+    for (TypeDescription child : orcSchema.getChildren()) {\n+      OrcToIcebergVisitor.visit(child, schemaConverter).ifPresent(icebergFields::add);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "693a7faf2f754dd7c268901e4ff2d392df365c80"}, "originalPosition": 50}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwNDQwOTg4", "url": "https://github.com/apache/iceberg/pull/1140#pullrequestreview-440440988", "createdAt": "2020-06-30T22:57:35Z", "commit": {"oid": "693a7faf2f754dd7c268901e4ff2d392df365c80"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMjo1NzozNVrOGrRPjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMjo1NzozNVrOGrRPjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAyNDQ2MA==", "bodyText": "I wouldn't refer to the ID annotations as mappings. How about \"ORC schema does not contain Iceberg IDs\"?", "url": "https://github.com/apache/iceberg/pull/1140#discussion_r448024460", "createdAt": "2020-06-30T22:57:35Z", "author": {"login": "rdblue"}, "path": "orc/src/main/java/org/apache/iceberg/orc/ORCSchemaUtil.java", "diffHunk": "@@ -214,10 +213,13 @@ public static Schema convert(TypeDescription orcSchema) {\n         \"Error in ORC file, children fields and names do not match.\");\n \n     List<Types.NestedField> icebergFields = Lists.newArrayListWithExpectedSize(children.size());\n-    AtomicInteger lastColumnId = new AtomicInteger(getMaxIcebergId(orcSchema));\n-    for (int i = 0; i < children.size(); i++) {\n-      icebergFields.add(convertOrcToIceberg(children.get(i), childrenNames.get(i),\n-          lastColumnId::incrementAndGet));\n+    OrcToIcebergVisitor schemaConverter = new OrcToIcebergVisitor(icebergToOrcMapping(\"root\", orcSchema));\n+    for (TypeDescription child : orcSchema.getChildren()) {\n+      OrcToIcebergVisitor.visit(child, schemaConverter).ifPresent(icebergFields::add);\n+    }\n+\n+    if (icebergFields.size() == 0) {\n+      throw new IllegalArgumentException(\"ORC schema has no Iceberg mappings\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "693a7faf2f754dd7c268901e4ff2d392df365c80"}, "originalPosition": 54}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwNDQxNDA1", "url": "https://github.com/apache/iceberg/pull/1140#pullrequestreview-440441405", "createdAt": "2020-06-30T22:58:40Z", "commit": {"oid": "693a7faf2f754dd7c268901e4ff2d392df365c80"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMjo1ODo0MFrOGrRQ5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMjo1ODo0MFrOGrRQ5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAyNDgwNA==", "bodyText": "Nit: does this need to be on a separate line?", "url": "https://github.com/apache/iceberg/pull/1140#discussion_r448024804", "createdAt": "2020-06-30T22:58:40Z", "author": {"login": "rdblue"}, "path": "orc/src/main/java/org/apache/iceberg/orc/OrcSchemaVisitor.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.orc;\n+\n+import java.util.List;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.orc.TypeDescription;\n+\n+/**\n+ * Generic visitor of an ORC Schema.\n+ */\n+public abstract class OrcSchemaVisitor<T> {\n+\n+  public static <T> T visit(TypeDescription schema, OrcSchemaVisitor<T> visitor) {\n+    switch (schema.getCategory()) {\n+      case STRUCT:\n+        return visitRecord(schema, visitor);\n+\n+      case UNION:\n+        throw new UnsupportedOperationException(\"Cannot handle \" + schema);\n+\n+      case LIST:\n+        return visitor.list(\n+            schema, visit(schema.getChildren().get(0), visitor));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "693a7faf2f754dd7c268901e4ff2d392df365c80"}, "originalPosition": 41}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "97c0fa447a8bd69eacd1e7883299973f07aa5351", "author": {"user": {"login": "edgarRd", "name": "Edgar Rodriguez"}}, "url": "https://github.com/apache/iceberg/commit/97c0fa447a8bd69eacd1e7883299973f07aa5351", "committedDate": "2020-07-01T00:39:27Z", "message": "Use Types.NestedField.of"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "79ca745da71444298bd2121affac7e01fecebef9", "author": {"user": {"login": "edgarRd", "name": "Edgar Rodriguez"}}, "url": "https://github.com/apache/iceberg/commit/79ca745da71444298bd2121affac7e01fecebef9", "committedDate": "2020-07-01T01:13:08Z", "message": "PR review"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cf39a31bcde820e21db1734ae8a80521a2ece37f", "author": {"user": {"login": "edgarRd", "name": "Edgar Rodriguez"}}, "url": "https://github.com/apache/iceberg/commit/cf39a31bcde820e21db1734ae8a80521a2ece37f", "committedDate": "2020-07-01T02:00:30Z", "message": "Create method to visit ORC schema in OrcSchemaVisitor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9a4f68aa7c5e877c85d17b62a3ca051a0a3d94f3", "author": {"user": {"login": "edgarRd", "name": "Edgar Rodriguez"}}, "url": "https://github.com/apache/iceberg/commit/9a4f68aa7c5e877c85d17b62a3ca051a0a3d94f3", "committedDate": "2020-07-02T00:42:56Z", "message": "Track field names in OrcSchemaVisitor"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0afccb24b77209b1493d8ce8f22eee944df4bede", "author": {"user": {"login": "edgarRd", "name": "Edgar Rodriguez"}}, "url": "https://github.com/apache/iceberg/commit/0afccb24b77209b1493d8ce8f22eee944df4bede", "committedDate": "2020-07-01T22:22:41Z", "message": "Track field names in OrcSchemaVisitor"}, "afterCommit": {"oid": "9a4f68aa7c5e877c85d17b62a3ca051a0a3d94f3", "author": {"user": {"login": "edgarRd", "name": "Edgar Rodriguez"}}, "url": "https://github.com/apache/iceberg/commit/9a4f68aa7c5e877c85d17b62a3ca051a0a3d94f3", "committedDate": "2020-07-02T00:42:56Z", "message": "Track field names in OrcSchemaVisitor"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxMjg1MzIz", "url": "https://github.com/apache/iceberg/pull/1140#pullrequestreview-441285323", "createdAt": "2020-07-02T01:05:59Z", "commit": {"oid": "9a4f68aa7c5e877c85d17b62a3ca051a0a3d94f3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQwMTowNTo1OVrOGr6Ccw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQwMTowNTo1OVrOGr6Ccw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY5Mjg1MQ==", "bodyText": "I think this should create an Iceberg schema and assert the two are equal (structs implement equals, so you have to check assertEquals(expected.asStruct(), converted.asStruct()).", "url": "https://github.com/apache/iceberg/pull/1140#discussion_r448692851", "createdAt": "2020-07-02T01:05:59Z", "author": {"login": "rdblue"}, "path": "orc/src/test/java/org/apache/iceberg/orc/TestORCSchemaUtil.java", "diffHunk": "@@ -209,4 +210,39 @@ public void testInvalidTypePromotions() {\n           ORCSchemaUtil.buildOrcProjection(evolveSchema, orcSchema);\n         });\n   }\n+\n+  @Test\n+  public void testSkipNonIcebergColumns() {\n+    TypeDescription schema = TypeDescription.createStruct();\n+    TypeDescription intCol = TypeDescription.createInt();\n+    intCol.setAttribute(ICEBERG_ID_ATTRIBUTE, \"1\");\n+    TypeDescription listCol = TypeDescription\n+        .createList(TypeDescription.createMap(TypeDescription.createString(), TypeDescription.createDate()));\n+    listCol.setAttribute(ICEBERG_ID_ATTRIBUTE, \"2\");\n+    schema.addField(\"intCol\", intCol);\n+    schema.addField(\"listCol\", listCol);\n+    TypeDescription stringKey = TypeDescription.createString();\n+    stringKey.setAttribute(ICEBERG_ID_ATTRIBUTE, \"3\");\n+    TypeDescription booleanVal = TypeDescription.createBoolean();\n+    booleanVal.setAttribute(ICEBERG_ID_ATTRIBUTE, \"4\");\n+    TypeDescription mapCol = TypeDescription.createMap(stringKey, booleanVal);\n+    mapCol.setAttribute(ICEBERG_ID_ATTRIBUTE, \"5\");\n+    schema.addField(\"mapCol\", mapCol);\n+\n+    Schema icebergSchema = ORCSchemaUtil.convert(schema);\n+    assertEquals(2, icebergSchema.asStruct().fields().size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a4f68aa7c5e877c85d17b62a3ca051a0a3d94f3"}, "originalPosition": 32}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eef07c6bc787ad6b9e8f20af4835f887063115f6", "author": {"user": {"login": "edgarRd", "name": "Edgar Rodriguez"}}, "url": "https://github.com/apache/iceberg/commit/eef07c6bc787ad6b9e8f20af4835f887063115f6", "committedDate": "2020-07-02T17:42:59Z", "message": "Compare schemas in test case"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ce01fe593b820bd045598391368cc9d8a4787bf2", "author": {"user": {"login": "edgarRd", "name": "Edgar Rodriguez"}}, "url": "https://github.com/apache/iceberg/commit/ce01fe593b820bd045598391368cc9d8a4787bf2", "committedDate": "2020-07-02T17:43:34Z", "message": "Move OrcToIcebergVisitor to separate file"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7c5d3d41abe9e66f667591c3a9fa762ce8a1076f", "author": {"user": {"login": "edgarRd", "name": "Edgar Rodriguez"}}, "url": "https://github.com/apache/iceberg/commit/7c5d3d41abe9e66f667591c3a9fa762ce8a1076f", "committedDate": "2020-07-02T17:31:57Z", "message": "Move OrcToIcebergVisitor to separate file"}, "afterCommit": {"oid": "ce01fe593b820bd045598391368cc9d8a4787bf2", "author": {"user": {"login": "edgarRd", "name": "Edgar Rodriguez"}}, "url": "https://github.com/apache/iceberg/commit/ce01fe593b820bd045598391368cc9d8a4787bf2", "committedDate": "2020-07-02T17:43:34Z", "message": "Move OrcToIcebergVisitor to separate file"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4565, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}