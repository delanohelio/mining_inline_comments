{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcxNjQzMzc3", "number": 782, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQwMDo1OTowMlrODeqOwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQwMDo1OTowMlrODeqOwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNDc1Nzc4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/iceberg/IncrementalDataTableScan.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQwMDo1OTowMlrOFn67bg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQwMToyNDozN1rOFn7TnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQwNDI3MA==", "bodyText": "I'd like to avoid using argument names in error messages. Argument names aren't very readable for end users because they are dense and this practice requires changing strings and test cases if arguments get renamed later.\nHow about \"From and to snapshot IDs cannot be the same: (%s, %s]\", \"From snapshot does not exist: %s\", etc.", "url": "https://github.com/apache/iceberg/pull/782#discussion_r377404270", "createdAt": "2020-02-11T00:59:02Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/IncrementalDataTableScan.java", "diffHunk": "@@ -137,4 +136,29 @@ protected TableScan newRefinedScan(\n     }\n     return snapshots;\n   }\n+\n+  private void validateSnapshotIdsRefinement(long newFromSnapshotId, long newToSnapshotId) {\n+    Set<Long> snapshotIdsRange = Sets.newHashSet(\n+        SnapshotUtil.snapshotIdsBetween(table(), fromSnapshotId, toSnapshotId));\n+    // since snapshotIdsBetween return ids in range (fromSnapshotId, toSnapshotId]\n+    snapshotIdsRange.add(fromSnapshotId);\n+    Preconditions.checkArgument(\n+        snapshotIdsRange.contains(newFromSnapshotId),\n+        \"newFromSnapshotId %s not in existing snapshot ids range (%s, %s]\",\n+        newFromSnapshotId, fromSnapshotId, newToSnapshotId);\n+    Preconditions.checkArgument(\n+        snapshotIdsRange.contains(newToSnapshotId),\n+        \"newToSnapshotId %s not in existing snapshot ids range (%s, %s]\",\n+        newToSnapshotId, fromSnapshotId, toSnapshotId);\n+  }\n+\n+  private static void validateSnapshotIds(Table table, long fromSnapshotId, long toSnapshotId) {\n+    Preconditions.checkArgument(fromSnapshotId != toSnapshotId, \"fromSnapshotId and toSnapshotId cannot be the same\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e5805b685d4e900e3ebd91a3220532b312a0f67"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQwODgyOA==", "bodyText": "Makes sense. Fixed", "url": "https://github.com/apache/iceberg/pull/782#discussion_r377408828", "createdAt": "2020-02-11T01:17:06Z", "author": {"login": "rdsr"}, "path": "core/src/main/java/org/apache/iceberg/IncrementalDataTableScan.java", "diffHunk": "@@ -137,4 +136,29 @@ protected TableScan newRefinedScan(\n     }\n     return snapshots;\n   }\n+\n+  private void validateSnapshotIdsRefinement(long newFromSnapshotId, long newToSnapshotId) {\n+    Set<Long> snapshotIdsRange = Sets.newHashSet(\n+        SnapshotUtil.snapshotIdsBetween(table(), fromSnapshotId, toSnapshotId));\n+    // since snapshotIdsBetween return ids in range (fromSnapshotId, toSnapshotId]\n+    snapshotIdsRange.add(fromSnapshotId);\n+    Preconditions.checkArgument(\n+        snapshotIdsRange.contains(newFromSnapshotId),\n+        \"newFromSnapshotId %s not in existing snapshot ids range (%s, %s]\",\n+        newFromSnapshotId, fromSnapshotId, newToSnapshotId);\n+    Preconditions.checkArgument(\n+        snapshotIdsRange.contains(newToSnapshotId),\n+        \"newToSnapshotId %s not in existing snapshot ids range (%s, %s]\",\n+        newToSnapshotId, fromSnapshotId, toSnapshotId);\n+  }\n+\n+  private static void validateSnapshotIds(Table table, long fromSnapshotId, long toSnapshotId) {\n+    Preconditions.checkArgument(fromSnapshotId != toSnapshotId, \"fromSnapshotId and toSnapshotId cannot be the same\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQwNDI3MA=="}, "originalCommit": {"oid": "4e5805b685d4e900e3ebd91a3220532b312a0f67"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQwOTcxNA==", "bodyText": "Looks like you missed the test assertions.", "url": "https://github.com/apache/iceberg/pull/782#discussion_r377409714", "createdAt": "2020-02-11T01:20:50Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/IncrementalDataTableScan.java", "diffHunk": "@@ -137,4 +136,29 @@ protected TableScan newRefinedScan(\n     }\n     return snapshots;\n   }\n+\n+  private void validateSnapshotIdsRefinement(long newFromSnapshotId, long newToSnapshotId) {\n+    Set<Long> snapshotIdsRange = Sets.newHashSet(\n+        SnapshotUtil.snapshotIdsBetween(table(), fromSnapshotId, toSnapshotId));\n+    // since snapshotIdsBetween return ids in range (fromSnapshotId, toSnapshotId]\n+    snapshotIdsRange.add(fromSnapshotId);\n+    Preconditions.checkArgument(\n+        snapshotIdsRange.contains(newFromSnapshotId),\n+        \"newFromSnapshotId %s not in existing snapshot ids range (%s, %s]\",\n+        newFromSnapshotId, fromSnapshotId, newToSnapshotId);\n+    Preconditions.checkArgument(\n+        snapshotIdsRange.contains(newToSnapshotId),\n+        \"newToSnapshotId %s not in existing snapshot ids range (%s, %s]\",\n+        newToSnapshotId, fromSnapshotId, toSnapshotId);\n+  }\n+\n+  private static void validateSnapshotIds(Table table, long fromSnapshotId, long toSnapshotId) {\n+    Preconditions.checkArgument(fromSnapshotId != toSnapshotId, \"fromSnapshotId and toSnapshotId cannot be the same\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQwNDI3MA=="}, "originalCommit": {"oid": "4e5805b685d4e900e3ebd91a3220532b312a0f67"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQxMDQ2MA==", "bodyText": "oops. I'll fix it", "url": "https://github.com/apache/iceberg/pull/782#discussion_r377410460", "createdAt": "2020-02-11T01:24:37Z", "author": {"login": "rdsr"}, "path": "core/src/main/java/org/apache/iceberg/IncrementalDataTableScan.java", "diffHunk": "@@ -137,4 +136,29 @@ protected TableScan newRefinedScan(\n     }\n     return snapshots;\n   }\n+\n+  private void validateSnapshotIdsRefinement(long newFromSnapshotId, long newToSnapshotId) {\n+    Set<Long> snapshotIdsRange = Sets.newHashSet(\n+        SnapshotUtil.snapshotIdsBetween(table(), fromSnapshotId, toSnapshotId));\n+    // since snapshotIdsBetween return ids in range (fromSnapshotId, toSnapshotId]\n+    snapshotIdsRange.add(fromSnapshotId);\n+    Preconditions.checkArgument(\n+        snapshotIdsRange.contains(newFromSnapshotId),\n+        \"newFromSnapshotId %s not in existing snapshot ids range (%s, %s]\",\n+        newFromSnapshotId, fromSnapshotId, newToSnapshotId);\n+    Preconditions.checkArgument(\n+        snapshotIdsRange.contains(newToSnapshotId),\n+        \"newToSnapshotId %s not in existing snapshot ids range (%s, %s]\",\n+        newToSnapshotId, fromSnapshotId, toSnapshotId);\n+  }\n+\n+  private static void validateSnapshotIds(Table table, long fromSnapshotId, long toSnapshotId) {\n+    Preconditions.checkArgument(fromSnapshotId != toSnapshotId, \"fromSnapshotId and toSnapshotId cannot be the same\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQwNDI3MA=="}, "originalCommit": {"oid": "4e5805b685d4e900e3ebd91a3220532b312a0f67"}, "originalPosition": 53}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3014, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}