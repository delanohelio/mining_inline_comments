{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE1MTEwNDY3", "number": 1716, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwMzozMDo0NVrOE1Dzyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxODoyNzozNVrOE2MXTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MDcyMzk1OnYy", "diffSide": "RIGHT", "path": "parquet/src/main/java/org/apache/iceberg/parquet/ParquetReader.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwMzozMDo0NVrOHtH_UA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxODoyNDoyM1rOHu40Sg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzA3ODg2NA==", "bodyText": "The rowPosition will be ignored if the position column is not projected.", "url": "https://github.com/apache/iceberg/pull/1716#discussion_r517078864", "createdAt": "2020-11-04T03:30:45Z", "author": {"login": "chenjunjiedada"}, "path": "parquet/src/main/java/org/apache/iceberg/parquet/ParquetReader.java", "diffHunk": "@@ -135,11 +135,9 @@ private void advance() {\n         throw new RuntimeIOException(e);\n       }\n \n-      long rowPosition = rowGroupsStartRowPos[nextRowGroup];\n+      model.setPageSource(pages, rowGroupsStartRowPos == null ? 0 : rowGroupsStartRowPos[nextRowGroup]);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0faa613ae4a6fbc08b9ed901f88a2ef85ffd079"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODkyNzQzNA==", "bodyText": "I don't think this file should change. If the determination not to use correct start positions in made in ReadConf, then it should just set the position to 0 there. This can use whatever rowGroupStartRowPos contains.", "url": "https://github.com/apache/iceberg/pull/1716#discussion_r518927434", "createdAt": "2020-11-06T18:24:23Z", "author": {"login": "rdblue"}, "path": "parquet/src/main/java/org/apache/iceberg/parquet/ParquetReader.java", "diffHunk": "@@ -135,11 +135,9 @@ private void advance() {\n         throw new RuntimeIOException(e);\n       }\n \n-      long rowPosition = rowGroupsStartRowPos[nextRowGroup];\n+      model.setPageSource(pages, rowGroupsStartRowPos == null ? 0 : rowGroupsStartRowPos[nextRowGroup]);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzA3ODg2NA=="}, "originalCommit": {"oid": "f0faa613ae4a6fbc08b9ed901f88a2ef85ffd079"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MjYwNjM4OnYy", "diffSide": "RIGHT", "path": "parquet/src/main/java/org/apache/iceberg/parquet/ReadConf.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxODoyNTo1OFrOHu43hg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxODoyNTo1OFrOHu43hg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODkyODI2Mg==", "bodyText": "I think this should use offsetToStartPos.getOrDefault(0L).", "url": "https://github.com/apache/iceberg/pull/1716#discussion_r518928262", "createdAt": "2020-11-06T18:25:58Z", "author": {"login": "rdblue"}, "path": "parquet/src/main/java/org/apache/iceberg/parquet/ReadConf.java", "diffHunk": "@@ -102,7 +107,9 @@\n     long computedTotalValues = 0L;\n     for (int i = 0; i < shouldSkip.length; i += 1) {\n       BlockMetaData rowGroup = rowGroups.get(i);\n-      startRowPositions[i] = offsetToStartPos.get(rowGroup.getStartingPos());\n+      if (offsetToStartPos != null) {\n+        startRowPositions[i] = offsetToStartPos.get(rowGroup.getStartingPos());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0faa613ae4a6fbc08b9ed901f88a2ef85ffd079"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MjYxMTM1OnYy", "diffSide": "RIGHT", "path": "parquet/src/main/java/org/apache/iceberg/parquet/ReadConf.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxODoyNzozNVrOHu46wQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wN1QwMDoxMjowMVrOHvBKRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODkyOTA4OQ==", "bodyText": "I think this should be defined for all cases so that ParquetReader doesn't need to check whether it is defined. In that case, it should still be a final variable.\nThe only change for this PR should be whether offsetToStartPos is an empty map or the result of generateOffsetToStartPos(). We may also want to do the ROW_POSITION check in that method instead of here, depending on what is cleaner.", "url": "https://github.com/apache/iceberg/pull/1716#discussion_r518929089", "createdAt": "2020-11-06T18:27:35Z", "author": {"login": "rdblue"}, "path": "parquet/src/main/java/org/apache/iceberg/parquet/ReadConf.java", "diffHunk": "@@ -89,8 +91,11 @@\n     this.shouldSkip = new boolean[rowGroups.size()];\n \n     // Fetch all row groups starting positions to compute the row offsets of the filtered row groups\n-    Map<Long, Long> offsetToStartPos = generateOffsetToStartPos();\n-    this.startRowPositions = new long[rowGroups.size()];\n+    Map<Long, Long> offsetToStartPos = null;\n+    if (expectedSchema.findField(MetadataColumns.ROW_POSITION.fieldId()) != null) {\n+      offsetToStartPos = generateOffsetToStartPos();\n+      this.startRowPositions = new long[rowGroups.size()];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0faa613ae4a6fbc08b9ed901f88a2ef85ffd079"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA2NDEzNQ==", "bodyText": "Make sense to me. Updated.", "url": "https://github.com/apache/iceberg/pull/1716#discussion_r519064135", "createdAt": "2020-11-07T00:12:01Z", "author": {"login": "chenjunjiedada"}, "path": "parquet/src/main/java/org/apache/iceberg/parquet/ReadConf.java", "diffHunk": "@@ -89,8 +91,11 @@\n     this.shouldSkip = new boolean[rowGroups.size()];\n \n     // Fetch all row groups starting positions to compute the row offsets of the filtered row groups\n-    Map<Long, Long> offsetToStartPos = generateOffsetToStartPos();\n-    this.startRowPositions = new long[rowGroups.size()];\n+    Map<Long, Long> offsetToStartPos = null;\n+    if (expectedSchema.findField(MetadataColumns.ROW_POSITION.fieldId()) != null) {\n+      offsetToStartPos = generateOffsetToStartPos();\n+      this.startRowPositions = new long[rowGroups.size()];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODkyOTA4OQ=="}, "originalCommit": {"oid": "f0faa613ae4a6fbc08b9ed901f88a2ef85ffd079"}, "originalPosition": 27}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3382, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}