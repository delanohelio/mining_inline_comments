{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ1NjMwOTk2", "number": 1177, "title": "Add schema upsert API for adding new fields and updating type (where applicable) using an input schema", "bodyText": "Continues on (most) the work done by @rdsr on #759", "createdAt": "2020-07-07T19:50:51Z", "url": "https://github.com/apache/iceberg/pull/1177", "merged": true, "mergeCommit": {"oid": "d91826490f3d38928bce38103305d21195945f96"}, "closed": true, "closedAt": "2020-09-08T17:20:27Z", "author": {"login": "fbocse"}, "timelineItems": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcyz5mTAFqTQ0NDQxMTg2Mw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdG67DzgFqTQ4NDM0NTE1Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0NDExODYz", "url": "https://github.com/apache/iceberg/pull/1177#pullrequestreview-444411863", "createdAt": "2020-07-08T04:53:44Z", "commit": {"oid": "e74bdbd696c508d30b0f1cff7d6e61c3ab51c931"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwNTo0Nzo1N1rOGuZASQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwNTo1MDowMlrOGuZC_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI5NzM1Mw==", "bodyText": "We may also need to handle renames and deletes. These can be detected if we do the updates [additions, type widening and renames and deletes] using field ids instead of names. This was one of the main comments by @rdblue  on #759", "url": "https://github.com/apache/iceberg/pull/1177#discussion_r451297353", "createdAt": "2020-07-08T05:47:57Z", "author": {"login": "rdsr"}, "path": "core/src/main/java/org/apache/iceberg/SchemaUpdate.java", "diffHunk": "@@ -308,6 +314,159 @@ public UpdateSchema moveAfter(String name, String afterName) {\n     return this;\n   }\n \n+  @Override\n+  public UpdateSchema upsertSchema(Schema newSchema) {\n+    TypeUtil.visit(newSchema, new ApplyUpdates(this, schema));\n+    return this;\n+  }\n+\n+  private static class ApplyUpdates extends TypeUtil.SchemaVisitor<Void> {\n+    private static final Joiner DOT = Joiner.on(\".\");\n+    private final Deque<String> fieldNames = Lists.newLinkedList();\n+    private NestedField currentField = null;\n+\n+    private final Schema baseSchema;\n+    private final UpdateSchema api;\n+    private final Map<String, Integer> indexByName;\n+\n+    private ApplyUpdates(UpdateSchema api, Schema baseSchema) {\n+      this.api = api;\n+      this.baseSchema = baseSchema;\n+      this.indexByName = TypeUtil.indexByName(baseSchema.asStruct());\n+    }\n+\n+    @Override\n+    public void beforeListElement(NestedField elementField) {\n+      beforeField(elementField);\n+    }\n+\n+    @Override\n+    public void afterListElement(NestedField elementField) {\n+      afterField(elementField);\n+    }\n+\n+    @Override\n+    public void beforeMapKey(Types.NestedField keyField) {\n+      beforeField(keyField);\n+    }\n+\n+    @Override\n+    public void afterMapKey(Types.NestedField keyField) {\n+      afterField(keyField);\n+    }\n+\n+    @Override\n+    public void beforeMapValue(Types.NestedField valueField) {\n+      beforeField(valueField);\n+    }\n+\n+    @Override\n+    public void afterMapValue(Types.NestedField valueField) {\n+      afterField(valueField);\n+    }\n+\n+    @Override\n+    public void beforeField(NestedField field) {\n+      fieldNames.push(field.name()); // we don't expect `element` to show up - it breaks\n+      currentField = field;\n+    }\n+\n+    @Override\n+    public void afterField(NestedField field) {\n+      fieldNames.pop();\n+    }\n+\n+    @Override\n+    public Void field(NestedField field, Void fieldResult) {\n+      return super.field(field, fieldResult);\n+    }\n+\n+    @Override\n+    public Void list(ListType list, Void elementResult) {\n+      String fullName = DOT.join(fieldNames.descendingIterator());\n+      Types.NestedField field = baseSchema.findField(fullName);\n+      if (field == null) {\n+        addColumn(fieldNames.peekFirst(), Types.ListType.ofOptional(0,   list.elementType()), ancestors());\n+      } else if (!field.type().isListType()) {\n+        throw new IllegalArgumentException(\n+            \"Cannot update existing field: \" + fullName + \" of type: \" + field\n+                .type() + \" to type list\");\n+      }\n+      return null;\n+    }\n+\n+    @Override\n+    public Void map(MapType map, Void keyResult, Void valueResult) {\n+      String fullName = DOT.join(fieldNames.descendingIterator());\n+      Types.NestedField field = baseSchema.findField(fullName);\n+      if (field == null) {\n+        addColumn(fieldNames.peekFirst(), Types.MapType.ofOptional(0, 1,   map.keyType(), map.valueType()), ancestors());\n+      } else if (!field.type().isMapType()) {\n+        throw new IllegalArgumentException(\n+            \"Cannot update existing field: \" + fullName + \" of type: \" + field\n+                .type() + \" to type map\");\n+      }\n+      return null;\n+    }\n+\n+    @Override\n+    public Void struct(Types.StructType struct, List<Void> fieldResults) {\n+      if(fieldNames.isEmpty()) return null; // this is the root struct\n+      String fullName = DOT.join(fieldNames.descendingIterator());\n+      Types.NestedField field = baseSchema.findField(fullName);\n+      if (field == null) {\n+        addColumn(fieldNames.peekFirst(), Types.StructType.of(struct.fields()), ancestors());\n+      } else if (!field.type().isStructType()) {\n+        throw new IllegalArgumentException(\n+            \"Cannot update existing field: \" + fullName + \" of type: \" + field.type()\n+                + \" to type struct\");\n+      }\n+      return null;\n+    }\n+\n+    @Override\n+    public Void primitive(PrimitiveType primitive) {\n+      String fullName = DOT.join(fieldNames.descendingIterator());\n+      Types.NestedField field = baseSchema.findField(fullName);\n+      PrimitiveType newFieldType = Types.fromPrimitiveString(primitive.toString());\n+      if (field == null) {\n+        addColumn(currentField.name(), Types.fromPrimitiveString(primitive.toString()), ancestors());\n+      } else if (!field.type().isPrimitiveType()) {\n+        throw new IllegalArgumentException(\n+            \"Cannot update existing field: \" + field.name() + \" of type: \"\n+                + field.type() + \" to primitive type: \" + primitive.typeId().name());\n+      } else if (!newFieldType.equals(field.type())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e74bdbd696c508d30b0f1cff7d6e61c3ab51c931"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI5ODA0NA==", "bodyText": "seems like \"value\" is missing from newSchema.  I think deletes are not handled that's why. We should consider adding deletes and renames too", "url": "https://github.com/apache/iceberg/pull/1177#discussion_r451298044", "createdAt": "2020-07-08T05:50:02Z", "author": {"login": "rdsr"}, "path": "core/src/test/java/org/apache/iceberg/TestSchemaUpdateSync.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import static org.apache.iceberg.types.Types.NestedField.optional;\n+import static org.apache.iceberg.types.Types.NestedField.required;\n+\n+import com.google.common.collect.Lists;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.apache.iceberg.types.Type.PrimitiveType;\n+import org.apache.iceberg.types.Types;\n+import org.apache.iceberg.types.Types.BinaryType;\n+import org.apache.iceberg.types.Types.BooleanType;\n+import org.apache.iceberg.types.Types.DateType;\n+import org.apache.iceberg.types.Types.DecimalType;\n+import org.apache.iceberg.types.Types.DoubleType;\n+import org.apache.iceberg.types.Types.FixedType;\n+import org.apache.iceberg.types.Types.FloatType;\n+import org.apache.iceberg.types.Types.IntegerType;\n+import org.apache.iceberg.types.Types.LongType;\n+import org.apache.iceberg.types.Types.NestedField;\n+import org.apache.iceberg.types.Types.StringType;\n+import org.apache.iceberg.types.Types.TimeType;\n+import org.apache.iceberg.types.Types.TimestampType;\n+import org.apache.iceberg.types.Types.UUIDType;\n+import org.junit.Assert;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+\n+public class TestSchemaUpdateSync {\n+\n+  @Rule\n+  public ExpectedException thrown = ExpectedException.none();\n+\n+  private static List<? extends PrimitiveType> primitiveTypes() {\n+    return Lists.newArrayList(StringType.get(),\n+        TimeType.get(),\n+        TimestampType.withoutZone(),\n+        TimestampType.withZone(),\n+        UUIDType.get(),\n+        DateType.get(),\n+        BooleanType.get(),\n+        BinaryType.get(),\n+        DoubleType.get(),\n+        IntegerType.get(),\n+        FixedType.ofLength(10),\n+        DecimalType.of(10, 2),\n+        LongType.get(),\n+        FloatType.get()\n+    );\n+  }\n+\n+  private static NestedField[] primitiveFields(Integer initialValue, List<? extends PrimitiveType> primitiveTypes) {\n+    AtomicInteger i = new AtomicInteger(initialValue);\n+    return primitiveTypes.stream()\n+        .map(type -> optional(i.incrementAndGet(), type.toString(),\n+            Types.fromPrimitiveString(type.toString()))).toArray(NestedField[]::new);\n+  }\n+\n+  @Test\n+  public void testAddTopLevelPrimitives() {\n+    Schema newSchema = new Schema(primitiveFields(0, primitiveTypes()));\n+    Schema applied = new SchemaUpdate(new Schema(), 0).upsertSchema(newSchema).apply();\n+    Assert.assertEquals(newSchema.asStruct(), applied.asStruct());\n+  }\n+\n+  @Test\n+  public void testAddTopLevelListOfPrimitives() {\n+    for(PrimitiveType primitiveType : primitiveTypes()) {\n+      Schema newSchema = new Schema(optional(1, \"aList\", Types.ListType.ofOptional(2, primitiveType)));\n+      Schema applied = new SchemaUpdate(new Schema(), 0).upsertSchema(newSchema).apply();\n+      Assert.assertEquals(newSchema.asStruct(), applied.asStruct());\n+    }\n+  }\n+\n+  @Test\n+  public void testAddTopLevelMapOfPrimitives() {\n+    for(PrimitiveType primitiveType : primitiveTypes()) {\n+      Schema newSchema = new Schema(optional(1, \"aMap\", Types.MapType.ofOptional(2, 3, primitiveType, primitiveType)));\n+      Schema applied = new SchemaUpdate(new Schema(), 0).upsertSchema(newSchema).apply();\n+      Assert.assertEquals(newSchema.asStruct(), applied.asStruct());\n+    }\n+  }\n+\n+  @Test\n+  public void testAddTopLevelStructOfPrimitives() {\n+    for(PrimitiveType primitiveType : primitiveTypes()) {\n+      Schema currentSchema = new Schema(optional(1, \"aStruct\", Types.StructType.of(\n+          optional(2, \"primitive\", primitiveType))));\n+      Schema applied = new SchemaUpdate(new Schema(), 0).upsertSchema(currentSchema).apply();\n+      Assert.assertEquals(currentSchema.asStruct(), applied.asStruct());\n+    }\n+  }\n+\n+  @Test\n+  public void testAddNestedPrimitive() {\n+    for(PrimitiveType primitiveType : primitiveTypes()) {\n+      Schema currentSchema = new Schema(optional(1, \"aStruct\", Types.StructType.of()));\n+      Schema newSchema = new Schema(optional(1, \"aStruct\", Types.StructType.of(\n+          optional(2, \"primitive\", primitiveType))));\n+      Schema applied = new SchemaUpdate(currentSchema, 1).upsertSchema(newSchema).apply();\n+      Assert.assertEquals(newSchema.asStruct(), applied.asStruct());\n+    }\n+  }\n+\n+  @Test\n+  public void testAddNestedPrimitives() {\n+    Schema currentSchema = new Schema(optional(1, \"aStruct\", Types.StructType.of()));\n+    Schema newSchema = new Schema(optional(1, \"aStruct\", Types.StructType.of(\n+        primitiveFields(1, primitiveTypes()))));\n+    Schema applied = new SchemaUpdate(currentSchema, 1).upsertSchema(newSchema).apply();\n+    Assert.assertEquals(newSchema.asStruct(), applied.asStruct());\n+  }\n+\n+  @Test\n+  public void testAddNestedLists() {\n+    Schema newSchema = new Schema(optional(1, \"aList\",\n+        Types.ListType.ofOptional(2,\n+            Types.ListType.ofOptional(3,\n+                Types.ListType.ofOptional(4,\n+                    Types.ListType.ofOptional(5,\n+                        Types.ListType.ofOptional(6,\n+                            Types.ListType.ofOptional(7,\n+                                Types.ListType.ofOptional(8,\n+                                    Types.ListType.ofOptional(9,\n+                                        Types.ListType.ofOptional(10,\n+                                            DecimalType.of(11, 20))))))))))));\n+    Schema applied = new SchemaUpdate(new Schema(), 0).upsertSchema(newSchema).apply();\n+    Assert.assertEquals(newSchema.asStruct(), applied.asStruct());\n+  }\n+\n+  @Test\n+  public void testAddNestedStruct() {\n+    Schema newSchema = new Schema(optional(1, \"struct1\", Types.StructType.of(\n+            optional(2, \"struct2\", Types.StructType.of(\n+                optional(3, \"struct3\", Types.StructType.of(\n+                    optional(4, \"struct4\", Types.StructType.of(\n+                        optional(5, \"struct5\", Types.StructType.of(\n+                            optional(6, \"struct6\", Types.StructType.of(\n+                                optional(7, \"aString\", StringType.get()))))))))))))));\n+    Schema applied = new SchemaUpdate(new Schema(), 0).upsertSchema(newSchema).apply();\n+    Assert.assertEquals(newSchema.asStruct(), applied.asStruct());\n+  }\n+\n+  @Test\n+  public void testAddNestedMaps() {\n+    Schema newSchema = new Schema(optional(1, \"struct\", Types.MapType.ofOptional(\n+        2, 3, StringType.get(), Types.MapType.ofOptional(\n+            4, 5, StringType.get(), Types.MapType.ofOptional(\n+                6, 7, StringType.get(), Types.MapType.ofOptional(\n+                    8 ,9, StringType.get(), Types.MapType.ofOptional(\n+                        10 ,11, StringType.get(), Types.MapType.ofOptional(\n+                            12, 13, StringType.get(), StringType.get()))))))));\n+    Schema applied = new SchemaUpdate(new Schema(), 0).upsertSchema(newSchema).apply();\n+    Assert.assertEquals(newSchema.asStruct(), applied.asStruct());\n+  }\n+\n+  @Test\n+  public void testDetectInvalidTopLevelList() {\n+    thrown.expect(IllegalArgumentException.class);\n+    thrown.expectMessage(\"Cannot change column type: aList.element: string -> long\");\n+\n+    Schema currentSchema = new Schema(optional(1, \"aList\",\n+        Types.ListType.ofOptional(2, StringType.get())));\n+    Schema newSchema = new Schema(optional(1, \"aList\",\n+        Types.ListType.ofOptional(2, LongType.get())));\n+    new SchemaUpdate(currentSchema, 2).upsertSchema(newSchema).apply();\n+  }\n+\n+  @Test\n+  public void testDetectInvalidTopLevelMapValue() {\n+    thrown.expect(IllegalArgumentException.class);\n+    thrown.expectMessage(\"Cannot change column type: aMap.value: string -> long\");\n+\n+    Schema currentSchema = new Schema(optional(1, \"aMap\",\n+        Types.MapType.ofOptional(2,3, StringType.get(), StringType.get())));\n+    Schema newSchema = new Schema(optional(1, \"aMap\",\n+        Types.MapType.ofOptional(2,3, StringType.get(), LongType.get())));\n+    Schema apply = new SchemaUpdate(currentSchema, 3).upsertSchema(newSchema).apply();\n+    System.out.println(apply.toString());\n+  }\n+\n+  @Test\n+  public void testDetectInvalidTopLevelMapKey() {\n+    thrown.expect(IllegalArgumentException.class);\n+    thrown.expectMessage(\"Cannot change column type: aMap.key: string -> uuid\");\n+\n+    Schema currentSchema = new Schema(optional(1, \"aMap\",\n+        Types.MapType.ofOptional(2,3 , StringType.get(), StringType.get())));\n+    Schema newSchema = new Schema(optional(1, \"aMap\",\n+        Types.MapType.ofOptional(2,3 , UUIDType.get(), StringType.get())));\n+    new SchemaUpdate(currentSchema, 3).upsertSchema(newSchema).apply();\n+  }\n+\n+  @Test\n+  // int\t32-bit signed integers -> Can promote to long\n+  public void testTypePromoteIntegerToLong() {\n+    Schema currentSchema = new Schema(required(1, \"aCol\", IntegerType.get()));\n+    Schema newSchema = new Schema(required(1, \"aCol\", LongType.get()));\n+\n+    Schema applied = new SchemaUpdate(currentSchema, 1).upsertSchema(newSchema).apply();\n+    Assert.assertEquals(1, applied.asStruct().fields().size());\n+    Assert.assertEquals(LongType.get(), applied.asStruct().fields().get(0).type());\n+  }\n+\n+  @Test\n+  // float\t32-bit IEEE 754 floating point -> Can promote to double\n+  public void testTypePromoteFloatToDouble() {\n+    Schema currentSchema = new Schema(required(1, \"aCol\", FloatType.get()));\n+    Schema newSchema = new Schema(required(1, \"aCol\", DoubleType.get()));\n+\n+    Schema applied = new SchemaUpdate(currentSchema, 1).upsertSchema(newSchema).apply();\n+    Assert.assertEquals(1, applied.asStruct().fields().size());\n+    Assert.assertEquals(DoubleType.get(), applied.asStruct().fields().get(0).type());\n+    // Doesn't work Assert.assertEquals(newSchema.asStruct(), applied.asStruct());\n+    // java.lang.AssertionError:\n+    // Expected :struct<1: aCol: required double>\n+    // Actual   :struct<1: aCol: required double ()>\n+  }\n+\n+  @Test\n+  public void testInvalidTypePromoteDoubleToFloat() {\n+    thrown.expect(IllegalArgumentException.class);\n+    thrown.expectMessage(\"Cannot change column type: aCol: double -> float\");\n+\n+    Schema currentSchema = new Schema(required(1, \"aCol\", DoubleType.get()));\n+    Schema newSchema = new Schema(required(1, \"aCol\", FloatType.get()));\n+\n+    new SchemaUpdate(currentSchema, 1).upsertSchema(newSchema).apply();\n+  }\n+\n+  @Test\n+  // decimal(P,S)\tFixed-point decimal; precision P, scale S\t-> Scale is fixed [1], precision must be 38 or less\n+  public void testTypePromoteDecimalToFixedScaleWithWiderPrecision() {\n+    Schema currentSchema = new Schema(required(1, \"aCol\", DecimalType.of(20, 1)));\n+    Schema newSchema = new Schema(required(1, \"aCol\", DecimalType.of(22, 1)));\n+\n+    Schema applied = new SchemaUpdate(currentSchema, 1).upsertSchema(newSchema).apply();\n+    Assert.assertEquals(newSchema.asStruct(), applied.asStruct());\n+  }\n+\n+  @Test\n+  public void testAddPrimitiveToNestedStruct() {\n+    Schema schema = new Schema(\n+        required(1, \"struct1\", Types.StructType.of(\n+          optional(2, \"struct2\", Types.StructType.of(\n+                  optional(3, \"list\", Types.ListType.ofOptional(\n+                      4, Types.StructType.of(\n+                          optional(5, \"value\", StringType.get())))))))));\n+\n+    Schema newSchema = new Schema(\n+        required(1, \"struct1\", Types.StructType.of(\n+            optional(2, \"struct2\", Types.StructType.of(\n+                optional(3, \"list\", Types.ListType.ofOptional(\n+                    4, Types.StructType.of(\n+                        optional(5, \"time\", TimeType.get())))))))));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e74bdbd696c508d30b0f1cff7d6e61c3ab51c931"}, "originalPosition": 275}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7d9fe329e8e698c9fc18635279a5e6dd94a68f71", "author": {"user": {"login": "fbocse", "name": "Filip Bocse"}}, "url": "https://github.com/apache/iceberg/commit/7d9fe329e8e698c9fc18635279a5e6dd94a68f71", "committedDate": "2020-07-09T12:47:51Z", "message": "Fix checkstyle errors"}, "afterCommit": {"oid": "aaca00e39df228145e20b497ed65787b4ee335c3", "author": {"user": {"login": "fbocse", "name": "Filip Bocse"}}, "url": "https://github.com/apache/iceberg/commit/aaca00e39df228145e20b497ed65787b4ee335c3", "committedDate": "2020-07-09T13:04:19Z", "message": "Add API for adding new fields and updating type (where applicable) and doc of existing fields by matching field names against a providede schema"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5NTI0Nzky", "url": "https://github.com/apache/iceberg/pull/1177#pullrequestreview-459524792", "createdAt": "2020-07-31T23:39:41Z", "commit": {"oid": "fc938ea8cd7595672d6d269991d1aed5536afc74"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQyMzozOTo0MlrOG6Zd7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQyMzozOTo0MlrOG6Zd7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg4Nzg1Mw==", "bodyText": "It seems odd to me that this is here. Does this support multiple calls to this method, or do we expect to mix this union operation with the others? If not, then I think we should consider how to separate the union logic from the API. We try to make sure that all of the configuration on table operations can be used at the same time, unless they logically conflict (like rename x -> y then delete y).\nIf this is going to be incompatible or even just not recommended with the other configuration methods, then we should consider moving it to either its own operation or a class that helps configure the normal UpdateSchema operation.", "url": "https://github.com/apache/iceberg/pull/1177#discussion_r463887853", "createdAt": "2020-07-31T23:39:42Z", "author": {"login": "rdblue"}, "path": "api/src/main/java/org/apache/iceberg/UpdateSchema.java", "diffHunk": "@@ -361,4 +361,14 @@ default UpdateSchema updateColumn(String name, Type.PrimitiveType newType, Strin\n    *                                  change conflicts with other changes.\n    */\n   UpdateSchema moveAfter(String name, String afterName);\n+\n+\n+  /**\n+   * Applies all the additions and updates [type widening, field documentation]\n+   * from the input schema\n+   *\n+   * @param newSchema - Input schema from which updates are applied\n+   * @return this for method chaining\n+   */\n+  UpdateSchema upsertSchema(Schema newSchema);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc938ea8cd7595672d6d269991d1aed5536afc74"}, "originalPosition": 13}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwMTY0NTUx", "url": "https://github.com/apache/iceberg/pull/1177#pullrequestreview-460164551", "createdAt": "2020-08-03T16:23:07Z", "commit": {"oid": "fc938ea8cd7595672d6d269991d1aed5536afc74"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxNjoyMzowN1rOG7AFzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxNjoyMzowN1rOG7AFzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDUyMDY1NQ==", "bodyText": "I had a hard time following the code and ended up using a debugger to figure out it wasn't trying to add columns in missing structs. It was good to see that there are test cases for this, but I think we can avoid the need for calling addColumn when it should not be added by using the visitor's return values.\nI prototyped a change that returns a Boolean that indicates whether a column is missing. That way, each method checks whether its equivalent is in the other struct. If it is not, the method simply returns true because the whole type should be added. If it is present, then containers may update the type, docs, and required boolean. I think that's easier to follow, so I'll post the changes for you.", "url": "https://github.com/apache/iceberg/pull/1177#discussion_r464520655", "createdAt": "2020-08-03T16:23:07Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/SchemaUpdate.java", "diffHunk": "@@ -308,6 +314,162 @@ public UpdateSchema moveAfter(String name, String afterName) {\n     return this;\n   }\n \n+  @Override\n+  public UpdateSchema upsertSchema(Schema newSchema) {\n+    TypeUtil.visit(newSchema, new ApplyUpdates(this, schema));\n+    return this;\n+  }\n+\n+  private static class ApplyUpdates extends TypeUtil.SchemaVisitor<Void> {\n+    private static final Joiner DOT = Joiner.on(\".\");\n+    private final Deque<String> fieldNames = Lists.newLinkedList();\n+    private NestedField currentField = null;\n+\n+    private final Schema baseSchema;\n+    private final UpdateSchema api;\n+    private final Map<String, Integer> indexByName;\n+\n+    private ApplyUpdates(UpdateSchema api, Schema baseSchema) {\n+      this.api = api;\n+      this.baseSchema = baseSchema;\n+      this.indexByName = TypeUtil.indexByName(baseSchema.asStruct());\n+    }\n+\n+    @Override\n+    public void beforeListElement(NestedField elementField) {\n+      beforeField(elementField);\n+    }\n+\n+    @Override\n+    public void afterListElement(NestedField elementField) {\n+      afterField(elementField);\n+    }\n+\n+    @Override\n+    public void beforeMapKey(Types.NestedField keyField) {\n+      beforeField(keyField);\n+    }\n+\n+    @Override\n+    public void afterMapKey(Types.NestedField keyField) {\n+      afterField(keyField);\n+    }\n+\n+    @Override\n+    public void beforeMapValue(Types.NestedField valueField) {\n+      beforeField(valueField);\n+    }\n+\n+    @Override\n+    public void afterMapValue(Types.NestedField valueField) {\n+      afterField(valueField);\n+    }\n+\n+    @Override\n+    public void beforeField(NestedField field) {\n+      fieldNames.push(field.name()); // we don't expect `element` to show up - it breaks\n+      currentField = field;\n+    }\n+\n+    @Override\n+    public void afterField(NestedField field) {\n+      fieldNames.pop();\n+    }\n+\n+    @Override\n+    public Void field(NestedField field, Void fieldResult) {\n+      return super.field(field, fieldResult);\n+    }\n+\n+    @Override\n+    public Void list(ListType list, Void elementResult) {\n+      String fullName = DOT.join(fieldNames.descendingIterator());\n+      Types.NestedField field = baseSchema.findField(fullName);\n+      if (field == null) {\n+        addColumn(fieldNames.peekFirst(), Types.ListType.ofOptional(0,   list.elementType()), ancestors());\n+      } else if (!field.type().isListType()) {\n+        throw new IllegalArgumentException(\n+            \"Cannot update existing field: \" + fullName + \" of type: \" + field\n+                .type() + \" to type list\");\n+      }\n+      return null;\n+    }\n+\n+    @Override\n+    public Void map(MapType map, Void keyResult, Void valueResult) {\n+      String fullName = DOT.join(fieldNames.descendingIterator());\n+      Types.NestedField field = baseSchema.findField(fullName);\n+      if (field == null) {\n+        addColumn(fieldNames.peekFirst(), Types.MapType.ofOptional(0, 1, map.keyType(), map.valueType()), ancestors());\n+      } else if (!field.type().isMapType()) {\n+        throw new IllegalArgumentException(\n+            \"Cannot update existing field: \" + fullName + \" of type: \" + field\n+                .type() + \" to type map\");\n+      }\n+      return null;\n+    }\n+\n+    @Override\n+    public Void struct(Types.StructType struct, List<Void> fieldResults) {\n+      if (fieldNames.isEmpty()) {\n+        return null; // this is the root struct\n+      }\n+      String fullName = DOT.join(fieldNames.descendingIterator());\n+      Types.NestedField field = baseSchema.findField(fullName);\n+      if (field == null) {\n+        addColumn(fieldNames.peekFirst(), Types.StructType.of(struct.fields()), ancestors());\n+      } else if (!field.type().isStructType()) {\n+        throw new IllegalArgumentException(\"Cannot update existing field: \" + fullName + \" of type: \" + field.type() +\n+                \" to type struct\");\n+      }\n+      return null;\n+    }\n+\n+    @Override\n+    public Void primitive(PrimitiveType primitive) {\n+      String fullName = DOT.join(fieldNames.descendingIterator());\n+      Types.NestedField field = baseSchema.findField(fullName);\n+      PrimitiveType newFieldType = Types.fromPrimitiveString(primitive.toString());\n+      if (field == null) {\n+        addColumn(currentField.name(), Types.fromPrimitiveString(primitive.toString()), ancestors());\n+      } else if (!field.type().isPrimitiveType()) {\n+        throw new IllegalArgumentException(\"Cannot update existing field: \" + field.name() + \" of type: \" +\n+                field.type() + \" to primitive type: \" + primitive.typeId().name());\n+      } else if (!newFieldType.equals(field.type())) {\n+        updateColumn(field.type().asPrimitiveType(), fullName, field.doc(), newFieldType, currentField.doc());\n+      }\n+      return null;\n+    }\n+\n+    private String ancestors() {\n+      if (fieldNames.isEmpty()) {\n+        return \"\";\n+      }\n+      String head = fieldNames.removeFirst();\n+      String join = DOT.join(fieldNames.descendingIterator());\n+      fieldNames.addFirst(head);\n+      return join;\n+    }\n+\n+    private void updateColumn(PrimitiveType fieldType, String fullName, String fieldDoc, PrimitiveType newFieldType,\n+                              String newDoc) {\n+      if (!fieldType.equals(newFieldType)) {\n+        api.updateColumn(fullName, newFieldType.asPrimitiveType());\n+      } else if (newDoc != null && !newDoc.equals(fieldDoc)) {\n+        api.updateColumnDoc(fullName, newDoc);\n+      }\n+    }\n+\n+    private void addColumn(String name, Type type, String ancestors) {\n+      if (ancestors.isEmpty()) {\n+        api.addColumn(null, name, type);\n+      } else if (indexByName.containsKey(ancestors)) {\n+        api.addColumn(ancestors, name, type);\n+      }\n+      // At this point the parent of this column hasn't been added to the schema, not yet visited", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc938ea8cd7595672d6d269991d1aed5536afc74"}, "originalPosition": 185}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwMTcwMzIz", "url": "https://github.com/apache/iceberg/pull/1177#pullrequestreview-460170323", "createdAt": "2020-08-03T16:31:27Z", "commit": {"oid": "fc938ea8cd7595672d6d269991d1aed5536afc74"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxNjozMToyN1rOG7AXqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxNjozMToyN1rOG7AXqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDUyNTIyNA==", "bodyText": "This visitor includes quite a bit of logic for traversing two schemas at once, by keeping track of the current name and looking up the equivalent in the existing/base schema. This check is also primarily to validate structure.\nI think it would be good to separate the logic to traverse schemas into a different visitor class, like we've done with the other \"partner\" visitors. That way, the union visitor would just be handed two types at the same place in a schema and can decide whether the observed type needs to be added, used to update, or if no action is needed.\nIn addition, we should be able to construct that visitor so that it keeps track of the place in the existing schema, so that we don't need to keep track of ancestors.", "url": "https://github.com/apache/iceberg/pull/1177#discussion_r464525224", "createdAt": "2020-08-03T16:31:27Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/SchemaUpdate.java", "diffHunk": "@@ -308,6 +314,162 @@ public UpdateSchema moveAfter(String name, String afterName) {\n     return this;\n   }\n \n+  @Override\n+  public UpdateSchema upsertSchema(Schema newSchema) {\n+    TypeUtil.visit(newSchema, new ApplyUpdates(this, schema));\n+    return this;\n+  }\n+\n+  private static class ApplyUpdates extends TypeUtil.SchemaVisitor<Void> {\n+    private static final Joiner DOT = Joiner.on(\".\");\n+    private final Deque<String> fieldNames = Lists.newLinkedList();\n+    private NestedField currentField = null;\n+\n+    private final Schema baseSchema;\n+    private final UpdateSchema api;\n+    private final Map<String, Integer> indexByName;\n+\n+    private ApplyUpdates(UpdateSchema api, Schema baseSchema) {\n+      this.api = api;\n+      this.baseSchema = baseSchema;\n+      this.indexByName = TypeUtil.indexByName(baseSchema.asStruct());\n+    }\n+\n+    @Override\n+    public void beforeListElement(NestedField elementField) {\n+      beforeField(elementField);\n+    }\n+\n+    @Override\n+    public void afterListElement(NestedField elementField) {\n+      afterField(elementField);\n+    }\n+\n+    @Override\n+    public void beforeMapKey(Types.NestedField keyField) {\n+      beforeField(keyField);\n+    }\n+\n+    @Override\n+    public void afterMapKey(Types.NestedField keyField) {\n+      afterField(keyField);\n+    }\n+\n+    @Override\n+    public void beforeMapValue(Types.NestedField valueField) {\n+      beforeField(valueField);\n+    }\n+\n+    @Override\n+    public void afterMapValue(Types.NestedField valueField) {\n+      afterField(valueField);\n+    }\n+\n+    @Override\n+    public void beforeField(NestedField field) {\n+      fieldNames.push(field.name()); // we don't expect `element` to show up - it breaks\n+      currentField = field;\n+    }\n+\n+    @Override\n+    public void afterField(NestedField field) {\n+      fieldNames.pop();\n+    }\n+\n+    @Override\n+    public Void field(NestedField field, Void fieldResult) {\n+      return super.field(field, fieldResult);\n+    }\n+\n+    @Override\n+    public Void list(ListType list, Void elementResult) {\n+      String fullName = DOT.join(fieldNames.descendingIterator());\n+      Types.NestedField field = baseSchema.findField(fullName);\n+      if (field == null) {\n+        addColumn(fieldNames.peekFirst(), Types.ListType.ofOptional(0,   list.elementType()), ancestors());\n+      } else if (!field.type().isListType()) {\n+        throw new IllegalArgumentException(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc938ea8cd7595672d6d269991d1aed5536afc74"}, "originalPosition": 107}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fc938ea8cd7595672d6d269991d1aed5536afc74", "author": {"user": {"login": "fbocse", "name": "Filip Bocse"}}, "url": "https://github.com/apache/iceberg/commit/fc938ea8cd7595672d6d269991d1aed5536afc74", "committedDate": "2020-07-09T14:33:30Z", "message": "Fix check style error"}, "afterCommit": {"oid": "55a74e540658ef3e197fd9f945b21195e9399cb3", "author": {"user": {"login": "fbocse", "name": "Filip Bocse"}}, "url": "https://github.com/apache/iceberg/commit/55a74e540658ef3e197fd9f945b21195e9399cb3", "committedDate": "2020-09-02T13:09:50Z", "message": "Update implementation using visitor pattern provided by @rdblue"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgwODE2NDMy", "url": "https://github.com/apache/iceberg/pull/1177#pullrequestreview-480816432", "createdAt": "2020-09-02T13:26:06Z", "commit": {"oid": "55a74e540658ef3e197fd9f945b21195e9399cb3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMzoyNjowNlrOHLvAew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMzoyNjowNlrOHLvAew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA2NjU1NQ==", "bodyText": "@rdblue @rdsr pls weigh in on the naming of this new API - I went for something that's as accurate as possible but pls drop a note in case you have a better suggestion for it", "url": "https://github.com/apache/iceberg/pull/1177#discussion_r482066555", "createdAt": "2020-09-02T13:26:06Z", "author": {"login": "fbocse"}, "path": "api/src/main/java/org/apache/iceberg/UpdateSchema.java", "diffHunk": "@@ -361,4 +361,14 @@ default UpdateSchema updateColumn(String name, Type.PrimitiveType newType, Strin\n    *                                  change conflicts with other changes.\n    */\n   UpdateSchema moveAfter(String name, String afterName);\n+\n+\n+  /**\n+   * Applies all the additions and updates [type widening, field documentation]\n+   * from the provided new schema\n+   *\n+   * @param newSchema - Input schema from which updates are applied\n+   * @return this for method chaining\n+   */\n+  UpdateSchema unionWithByFieldName(Schema newSchema);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55a74e540658ef3e197fd9f945b21195e9399cb3"}, "originalPosition": 13}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgwODE4OTQ0", "url": "https://github.com/apache/iceberg/pull/1177#pullrequestreview-480818944", "createdAt": "2020-09-02T13:28:45Z", "commit": {"oid": "55a74e540658ef3e197fd9f945b21195e9399cb3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMzoyODo0NVrOHLvH2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMzoyODo0NVrOHLvH2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA2ODQ0Mw==", "bodyText": "@rdblue I think this conditional here is pretty much the only change I've made to your poc code - tests are passing just fine - will add some more from past use-cases - I realise that an exhaustive test suite is pretty much impossible for this feature but I'll try to cover both basic and complex use-cases", "url": "https://github.com/apache/iceberg/pull/1177#discussion_r482068443", "createdAt": "2020-09-02T13:28:45Z", "author": {"login": "fbocse"}, "path": "core/src/main/java/org/apache/iceberg/schema/UnionByNameVisitor.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.schema;\n+\n+import java.util.List;\n+import java.util.stream.IntStream;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.UpdateSchema;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.types.Type;\n+import org.apache.iceberg.types.Types;\n+\n+/**\n+ * Visitor class that accumulates the set of changes needed to evolve an existing schema into the union of the\n+ * existing and a new schema. Changes are added to an {@link UpdateSchema} operation.\n+ */\n+public class UnionByNameVisitor extends SchemaWithPartnerVisitor<Integer, Boolean> {\n+\n+  private final UpdateSchema api;\n+  private final Schema partnerSchema;\n+\n+  private UnionByNameVisitor(UpdateSchema api, Schema partnerSchema) {\n+    this.api = api;\n+    this.partnerSchema = partnerSchema;\n+  }\n+\n+  /**\n+   * Adds changes needed to produce a union of two schemas to an {@link UpdateSchema} operation.\n+   * <p>\n+   * Changes are accumulated to evolve the existingSchema into a union with newSchema.\n+   *\n+   * @param api an UpdateSchema for adding changes\n+   * @param existingSchema an existing schema\n+   * @param newSchema a new schema to compare with the existing\n+   */\n+  public static void visit(UpdateSchema api, Schema existingSchema, Schema newSchema) {\n+    visit(newSchema, -1, new UnionByNameVisitor(api, existingSchema), new PartnerIdByNameAccessors(existingSchema));\n+  }\n+\n+  @Override\n+  public Boolean struct(Types.StructType struct, Integer partnerId, List<Boolean> missingPositions) {\n+    if (partnerId == null) {\n+      return true;\n+    }\n+\n+    List<Types.NestedField> fields = struct.fields();\n+    Types.StructType partnerStruct = findFieldType(partnerId).asStructType();\n+    IntStream.range(0, missingPositions.size())\n+        .forEach(pos -> {\n+          Boolean isMissing = missingPositions.get(pos);\n+          Types.NestedField field = fields.get(pos);\n+          if (isMissing) {\n+            addColumn(partnerId, field);\n+          } else {\n+            updateColumn(field, partnerStruct.field(field.name()));\n+          }\n+        });\n+\n+    return false;\n+  }\n+\n+  @Override\n+  public Boolean field(Types.NestedField field, Integer partnerId, Boolean isFieldMissing) {\n+    return partnerId == null;\n+  }\n+\n+  @Override\n+  public Boolean list(Types.ListType list, Integer partnerId, Boolean isElementMissing) {\n+    if (partnerId == null) {\n+      return true;\n+    }\n+\n+    Preconditions.checkState(!isElementMissing, \"Error traversing schemas: element is missing, but list is present\");\n+\n+    Types.ListType partnerList = findFieldType(partnerId).asListType();\n+    updateColumn(list.fields().get(0), partnerList.fields().get(0));\n+\n+    return false;\n+  }\n+\n+  @Override\n+  public Boolean map(Types.MapType map, Integer partnerId, Boolean isKeyMissing, Boolean isValueMissing) {\n+    if (partnerId == null) {\n+      return true;\n+    }\n+\n+    Preconditions.checkState(!isKeyMissing, \"Error traversing schemas: key is missing, but map is present\");\n+    Preconditions.checkState(!isValueMissing, \"Error traversing schemas: value is missing, but map is present\");\n+\n+    Types.MapType partnerMap = findFieldType(partnerId).asMapType();\n+    updateColumn(map.fields().get(0), partnerMap.fields().get(0));\n+    updateColumn(map.fields().get(1), partnerMap.fields().get(1));\n+\n+    return false;\n+  }\n+\n+  @Override\n+  public Boolean primitive(Type.PrimitiveType primitive, Integer partnerId) {\n+    return partnerId == null;\n+  }\n+\n+  private Type findFieldType(int fieldId) {\n+    if (fieldId == -1) {\n+      return partnerSchema.asStruct();\n+    } else {\n+      return partnerSchema.findField(fieldId).type();\n+    }\n+  }\n+\n+  private void addColumn(int parentId, Types.NestedField field) {\n+    String parentName = partnerSchema.findColumnName(parentId);\n+    api.addColumn(parentName, field.name(), field.type(), field.doc());\n+  }\n+\n+  private void updateColumn(Types.NestedField field, Types.NestedField existingField) {\n+    String fullName = partnerSchema.findColumnName(existingField.fieldId());\n+\n+    boolean needsOptionalUpdate = field.isOptional() && existingField.isRequired();\n+    boolean needsTypeUpdate = field.type().isPrimitiveType() && !field.type().equals(existingField.type());\n+    boolean needsDocUpdate = field.doc() != null && !field.doc().equals(existingField.doc());\n+\n+    if (needsOptionalUpdate) {\n+      api.makeColumnOptional(fullName);\n+    }\n+\n+    if (needsTypeUpdate) {\n+      api.updateColumn(fullName, field.type().asPrimitiveType());\n+    }\n+\n+    if (needsDocUpdate) {\n+      api.updateColumnDoc(fullName, field.doc());\n+    }\n+  }\n+\n+  private static class PartnerIdByNameAccessors implements PartnerAccessors<Integer> {\n+    private final Schema partnerSchema;\n+\n+    private PartnerIdByNameAccessors(Schema partnerSchema) {\n+      this.partnerSchema = partnerSchema;\n+    }\n+\n+    @Override\n+    public Integer fieldPartner(Integer partnerFieldId, int fieldId, String name) {\n+      Types.StructType struct;\n+      if (partnerFieldId == -1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55a74e540658ef3e197fd9f945b21195e9399cb3"}, "originalPosition": 162}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgwODIwNDg5", "url": "https://github.com/apache/iceberg/pull/1177#pullrequestreview-480820489", "createdAt": "2020-09-02T13:30:20Z", "commit": {"oid": "55a74e540658ef3e197fd9f945b21195e9399cb3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMzozMDoyMFrOHLvMig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMzozMDoyMFrOHLvMig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA2OTY0Mg==", "bodyText": "@rdblue you're right, the implementation, while a bit more complex than the previous one, feels less complicated.", "url": "https://github.com/apache/iceberg/pull/1177#discussion_r482069642", "createdAt": "2020-09-02T13:30:20Z", "author": {"login": "fbocse"}, "path": "core/src/main/java/org/apache/iceberg/SchemaUpdate.java", "diffHunk": "@@ -308,6 +309,12 @@ public UpdateSchema moveAfter(String name, String afterName) {\n     return this;\n   }\n \n+  @Override\n+  public UpdateSchema unionWithByFieldName(Schema newSchema) {\n+    UnionByNameVisitor.visit(this, schema, newSchema);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55a74e540658ef3e197fd9f945b21195e9399cb3"}, "originalPosition": 14}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxMzE4OTg2", "url": "https://github.com/apache/iceberg/pull/1177#pullrequestreview-481318986", "createdAt": "2020-09-02T21:37:33Z", "commit": {"oid": "55a74e540658ef3e197fd9f945b21195e9399cb3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQyMTozNzozM1rOHMJWWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQyMTozNzozM1rOHMJWWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQ5ODEzOA==", "bodyText": "Why extract TypeVisitor<P, R> from this? It isn't obvious to me how that's useful.", "url": "https://github.com/apache/iceberg/pull/1177#discussion_r482498138", "createdAt": "2020-09-02T21:37:33Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/schema/SchemaWithPartnerVisitor.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.schema;\n+\n+import java.util.List;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.types.Type;\n+import org.apache.iceberg.types.Types;\n+\n+public abstract class SchemaWithPartnerVisitor<P, R> implements TypeVisitor<P, R> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55a74e540658ef3e197fd9f945b21195e9399cb3"}, "originalPosition": 28}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "72c43f5ee96772b142854c496e2734808c9413bb", "author": {"user": {"login": "fbocse", "name": "Filip Bocse"}}, "url": "https://github.com/apache/iceberg/commit/72c43f5ee96772b142854c496e2734808c9413bb", "committedDate": "2020-09-03T13:58:42Z", "message": "Add API for adding new fields and updating type (where applicable) and doc of existing fields by matching field names against a providede schema (uses a new implementation of visitor pattern for schema w/ partner)"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "55a74e540658ef3e197fd9f945b21195e9399cb3", "author": {"user": {"login": "fbocse", "name": "Filip Bocse"}}, "url": "https://github.com/apache/iceberg/commit/55a74e540658ef3e197fd9f945b21195e9399cb3", "committedDate": "2020-09-02T13:09:50Z", "message": "Update implementation using visitor pattern provided by @rdblue"}, "afterCommit": {"oid": "72c43f5ee96772b142854c496e2734808c9413bb", "author": {"user": {"login": "fbocse", "name": "Filip Bocse"}}, "url": "https://github.com/apache/iceberg/commit/72c43f5ee96772b142854c496e2734808c9413bb", "committedDate": "2020-09-03T13:58:42Z", "message": "Add API for adding new fields and updating type (where applicable) and doc of existing fields by matching field names against a providede schema (uses a new implementation of visitor pattern for schema w/ partner)"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyMTMwNjU4", "url": "https://github.com/apache/iceberg/pull/1177#pullrequestreview-482130658", "createdAt": "2020-09-03T19:14:08Z", "commit": {"oid": "72c43f5ee96772b142854c496e2734808c9413bb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxOToxNDowOVrOHM0KAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxOToxNDowOVrOHM0KAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE5OTQ5MA==", "bodyText": "@rdblue is this javadoc overdoing it a bit?", "url": "https://github.com/apache/iceberg/pull/1177#discussion_r483199490", "createdAt": "2020-09-03T19:14:09Z", "author": {"login": "fbocse"}, "path": "api/src/main/java/org/apache/iceberg/UpdateSchema.java", "diffHunk": "@@ -361,4 +361,27 @@ default UpdateSchema updateColumn(String name, Type.PrimitiveType newType, Strin\n    *                                  change conflicts with other changes.\n    */\n   UpdateSchema moveAfter(String name, String afterName);\n+\n+\n+  /**\n+   * Applies all field additions and updates from the provided new schema to the existing schema so", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72c43f5ee96772b142854c496e2734808c9413bb"}, "originalPosition": 7}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0MzQ1MTUz", "url": "https://github.com/apache/iceberg/pull/1177#pullrequestreview-484345153", "createdAt": "2020-09-08T17:19:47Z", "commit": {"oid": "72c43f5ee96772b142854c496e2734808c9413bb"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4624, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}