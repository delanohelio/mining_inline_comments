{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ1MTI4MDAy", "number": 1173, "title": "FlinkTypeVisitor: Use LogicalTypeVisitor and supports MultisetType", "bodyText": "This PR wants to improve #1096\nUse LogicalTypeVisitor\nFlink has LogicalTypeVisitor and DataTypeVisitor, they are very useful for visiting types. We don't implement a custom visitor based on instanceOf, it's error prone and not very elegant.\nAnd for FieldsDataType, it not has a good design in 1.9 and 1.10, so in Flink 1.11, it has been refactored to be removed getFieldDataTypes. So I think maybe a LogicalTypeVisitor is enough, since we never touch the physical information in the DataTypes.\nSupport MultisetType\nA CollectionDataType may be MultisetType too. We can map it to Map<T, Integer>.", "createdAt": "2020-07-07T03:41:37Z", "url": "https://github.com/apache/iceberg/pull/1173", "merged": true, "mergeCommit": {"oid": "dfc8ec34f88a9e8470d6447113530312cb52cfc0"}, "closed": true, "closedAt": "2020-07-14T16:59:48Z", "author": {"login": "JingsongLi"}, "timelineItems": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcydY4PgH2gAyNDQ1MTI4MDAyOjRhZjViZjRiY2RmZDQzYWE0ZGM0MmQ3MDY0NzAyOTM2OTE4ZmQ4ZGI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc05DZzgFqTQ0ODI5MzYxMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "4af5bf4bcdfd43aa4dc42d7064702936918fd8db", "author": {"user": {"login": "JingsongLi", "name": "Jingsong Lee"}}, "url": "https://github.com/apache/iceberg/commit/4af5bf4bcdfd43aa4dc42d7064702936918fd8db", "committedDate": "2020-07-07T03:36:43Z", "message": "FlinkTypeVisitor: Use LogicalTypeVisitor and supports MultisetType"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzNjk3NjYz", "url": "https://github.com/apache/iceberg/pull/1173#pullrequestreview-443697663", "createdAt": "2020-07-07T09:00:00Z", "commit": {"oid": "4af5bf4bcdfd43aa4dc42d7064702936918fd8db"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwOTowMDowMFrOGt1b8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwOToxMDoyNVrOGt1z6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDcxNDYxMQ==", "bodyText": "@JingsongLi I'm curious that what's the difference between the  flink style LogicalTypeVisitor  and iceberg style visitor... Currently, all of the visitor are iceberg style,  I'm not quite sure that what's the benifits to convert it to flink style visitor ...\nUpdate:  OK, I read the background in this issues here (#1173 (comment)), sounds reasonable.", "url": "https://github.com/apache/iceberg/pull/1173#discussion_r450714611", "createdAt": "2020-07-07T09:00:00Z", "author": {"login": "openinx"}, "path": "flink/src/main/java/org/apache/iceberg/flink/FlinkTypeVisitor.java", "diffHunk": "@@ -19,65 +19,63 @@\n \n package org.apache.iceberg.flink;\n \n-import java.util.List;\n-import java.util.Map;\n-import org.apache.flink.table.types.AtomicDataType;\n-import org.apache.flink.table.types.CollectionDataType;\n-import org.apache.flink.table.types.DataType;\n-import org.apache.flink.table.types.FieldsDataType;\n-import org.apache.flink.table.types.KeyValueDataType;\n-import org.apache.flink.table.types.logical.RowType;\n-import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n-import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.flink.table.types.logical.DayTimeIntervalType;\n+import org.apache.flink.table.types.logical.DistinctType;\n+import org.apache.flink.table.types.logical.LogicalType;\n+import org.apache.flink.table.types.logical.LogicalTypeVisitor;\n+import org.apache.flink.table.types.logical.NullType;\n+import org.apache.flink.table.types.logical.RawType;\n+import org.apache.flink.table.types.logical.StructuredType;\n+import org.apache.flink.table.types.logical.SymbolType;\n+import org.apache.flink.table.types.logical.YearMonthIntervalType;\n+import org.apache.flink.table.types.logical.ZonedTimestampType;\n \n-public class FlinkTypeVisitor<T> {\n+public abstract class FlinkTypeVisitor<T> implements LogicalTypeVisitor<T> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4af5bf4bcdfd43aa4dc42d7064702936918fd8db"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDcxNTU5OA==", "bodyText": "BTW, seems this FlinkTypeVisitor can be package access (I forget to check the access before).", "url": "https://github.com/apache/iceberg/pull/1173#discussion_r450715598", "createdAt": "2020-07-07T09:01:40Z", "author": {"login": "openinx"}, "path": "flink/src/main/java/org/apache/iceberg/flink/FlinkTypeVisitor.java", "diffHunk": "@@ -19,65 +19,63 @@\n \n package org.apache.iceberg.flink;\n \n-import java.util.List;\n-import java.util.Map;\n-import org.apache.flink.table.types.AtomicDataType;\n-import org.apache.flink.table.types.CollectionDataType;\n-import org.apache.flink.table.types.DataType;\n-import org.apache.flink.table.types.FieldsDataType;\n-import org.apache.flink.table.types.KeyValueDataType;\n-import org.apache.flink.table.types.logical.RowType;\n-import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n-import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.flink.table.types.logical.DayTimeIntervalType;\n+import org.apache.flink.table.types.logical.DistinctType;\n+import org.apache.flink.table.types.logical.LogicalType;\n+import org.apache.flink.table.types.logical.LogicalTypeVisitor;\n+import org.apache.flink.table.types.logical.NullType;\n+import org.apache.flink.table.types.logical.RawType;\n+import org.apache.flink.table.types.logical.StructuredType;\n+import org.apache.flink.table.types.logical.SymbolType;\n+import org.apache.flink.table.types.logical.YearMonthIntervalType;\n+import org.apache.flink.table.types.logical.ZonedTimestampType;\n \n-public class FlinkTypeVisitor<T> {\n+public abstract class FlinkTypeVisitor<T> implements LogicalTypeVisitor<T> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDcxNDYxMQ=="}, "originalCommit": {"oid": "4af5bf4bcdfd43aa4dc42d7064702936918fd8db"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDcyMDc0NQ==", "bodyText": "Sounds good that we've extended support the flink multiset data type .", "url": "https://github.com/apache/iceberg/pull/1173#discussion_r450720745", "createdAt": "2020-07-07T09:10:25Z", "author": {"login": "openinx"}, "path": "flink/src/main/java/org/apache/iceberg/flink/FlinkTypeToType.java", "diffHunk": "@@ -64,86 +63,136 @@ private int getNextId() {\n   }\n \n   @Override\n-  public Type fields(FieldsDataType fields, List<Type> types) {\n-    List<Types.NestedField> newFields = Lists.newArrayListWithExpectedSize(types.size());\n-    boolean isRoot = root == fields;\n+  public Type visit(CharType charType) {\n+    return Types.StringType.get();\n+  }\n \n-    List<RowType.RowField> rowFields = ((RowType) fields.getLogicalType()).getFields();\n-    Preconditions.checkArgument(rowFields.size() == types.size(), \"fields list and types list should have same size.\");\n+  @Override\n+  public Type visit(VarCharType varCharType) {\n+    return Types.StringType.get();\n+  }\n \n-    for (int i = 0; i < rowFields.size(); i++) {\n-      int id = isRoot ? i : getNextId();\n+  @Override\n+  public Type visit(BooleanType booleanType) {\n+    return Types.BooleanType.get();\n+  }\n \n-      RowType.RowField field = rowFields.get(i);\n-      String name = field.getName();\n-      String comment = field.getDescription().orElse(null);\n+  @Override\n+  public Type visit(BinaryType binaryType) {\n+    return Types.FixedType.ofLength(binaryType.getLength());\n+  }\n \n-      if (field.getType().isNullable()) {\n-        newFields.add(Types.NestedField.optional(id, name, types.get(i), comment));\n-      } else {\n-        newFields.add(Types.NestedField.required(id, name, types.get(i), comment));\n-      }\n-    }\n+  @Override\n+  public Type visit(VarBinaryType varBinaryType) {\n+    return Types.BinaryType.get();\n+  }\n \n-    return Types.StructType.of(newFields);\n+  @Override\n+  public Type visit(DecimalType decimalType) {\n+    return Types.DecimalType.of(decimalType.getPrecision(), decimalType.getScale());\n+  }\n+\n+  @Override\n+  public Type visit(TinyIntType tinyIntType) {\n+    return Types.IntegerType.get();\n+  }\n+\n+  @Override\n+  public Type visit(SmallIntType smallIntType) {\n+    return Types.IntegerType.get();\n+  }\n+\n+  @Override\n+  public Type visit(IntType intType) {\n+    return Types.IntegerType.get();\n+  }\n+\n+  @Override\n+  public Type visit(BigIntType bigIntType) {\n+    return Types.LongType.get();\n+  }\n+\n+  @Override\n+  public Type visit(FloatType floatType) {\n+    return Types.FloatType.get();\n+  }\n+\n+  @Override\n+  public Type visit(DoubleType doubleType) {\n+    return Types.DoubleType.get();\n+  }\n+\n+  @Override\n+  public Type visit(DateType dateType) {\n+    return Types.DateType.get();\n+  }\n+\n+  @Override\n+  public Type visit(TimeType timeType) {\n+    return Types.TimeType.get();\n   }\n \n   @Override\n-  public Type collection(CollectionDataType collection, Type elementType) {\n-    if (collection.getElementDataType().getLogicalType().isNullable()) {\n+  public Type visit(TimestampType timestampType) {\n+    return Types.TimestampType.withoutZone();\n+  }\n+\n+  @Override\n+  public Type visit(LocalZonedTimestampType localZonedTimestampType) {\n+    return Types.TimestampType.withZone();\n+  }\n+\n+  @Override\n+  public Type visit(ArrayType arrayType) {\n+    Type elementType = arrayType.getElementType().accept(this);\n+    if (arrayType.getElementType().isNullable()) {\n       return Types.ListType.ofOptional(getNextId(), elementType);\n     } else {\n       return Types.ListType.ofRequired(getNextId(), elementType);\n     }\n   }\n \n   @Override\n-  public Type map(KeyValueDataType map, Type keyType, Type valueType) {\n+  public Type visit(MultisetType multisetType) {\n+    Type elementType = multisetType.getElementType().accept(this);\n+    return Types.MapType.ofRequired(getNextId(), getNextId(), elementType, Types.IntegerType.get());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4af5bf4bcdfd43aa4dc42d7064702936918fd8db"}, "originalPosition": 164}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "47beb33eda1b024280129f2422a9f32d6a0d79e9", "author": {"user": {"login": "JingsongLi", "name": "Jingsong Lee"}}, "url": "https://github.com/apache/iceberg/commit/47beb33eda1b024280129f2422a9f32d6a0d79e9", "committedDate": "2020-07-07T09:32:16Z", "message": "Public to package"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1NDQ3MzMy", "url": "https://github.com/apache/iceberg/pull/1173#pullrequestreview-445447332", "createdAt": "2020-07-09T09:32:12Z", "commit": {"oid": "47beb33eda1b024280129f2422a9f32d6a0d79e9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwOTozMjoxM1rOGvJU2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwOTozMjoxM1rOGvJU2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjA4OTA1MA==", "bodyText": "Seems here we don't need to loop twice ( the first loop to get List<Type> and the next loop to get List<Types.NestedField> ). Could be simplified like the following:\n  @Override\n  public Type visit(RowType rowType) {\n    List<Types.NestedField> newFields = Lists.newArrayListWithExpectedSize(rowType.getFieldCount());\n    boolean isRoot = root == rowType;\n\n    for (int i = 0; i < rowType.getFieldCount(); i++) {\n      int id = isRoot ? i : getNextId();\n\n      RowType.RowField field = rowType.getFields().get(i);\n      String name = field.getName();\n      String comment = field.getDescription().orElse(null);\n      Type type = field.getType().accept(this);\n\n      if (field.getType().isNullable()) {\n        newFields.add(Types.NestedField.optional(id, name, type, comment));\n      } else {\n        newFields.add(Types.NestedField.required(id, name, type, comment));\n      }\n    }\n\n    return Types.StructType.of(newFields);\n  }", "url": "https://github.com/apache/iceberg/pull/1173#discussion_r452089050", "createdAt": "2020-07-09T09:32:13Z", "author": {"login": "openinx"}, "path": "flink/src/main/java/org/apache/iceberg/flink/FlinkTypeToType.java", "diffHunk": "@@ -64,86 +63,136 @@ private int getNextId() {\n   }\n \n   @Override\n-  public Type fields(FieldsDataType fields, List<Type> types) {\n-    List<Types.NestedField> newFields = Lists.newArrayListWithExpectedSize(types.size());\n-    boolean isRoot = root == fields;\n+  public Type visit(CharType charType) {\n+    return Types.StringType.get();\n+  }\n \n-    List<RowType.RowField> rowFields = ((RowType) fields.getLogicalType()).getFields();\n-    Preconditions.checkArgument(rowFields.size() == types.size(), \"fields list and types list should have same size.\");\n+  @Override\n+  public Type visit(VarCharType varCharType) {\n+    return Types.StringType.get();\n+  }\n \n-    for (int i = 0; i < rowFields.size(); i++) {\n-      int id = isRoot ? i : getNextId();\n+  @Override\n+  public Type visit(BooleanType booleanType) {\n+    return Types.BooleanType.get();\n+  }\n \n-      RowType.RowField field = rowFields.get(i);\n-      String name = field.getName();\n-      String comment = field.getDescription().orElse(null);\n+  @Override\n+  public Type visit(BinaryType binaryType) {\n+    return Types.FixedType.ofLength(binaryType.getLength());\n+  }\n \n-      if (field.getType().isNullable()) {\n-        newFields.add(Types.NestedField.optional(id, name, types.get(i), comment));\n-      } else {\n-        newFields.add(Types.NestedField.required(id, name, types.get(i), comment));\n-      }\n-    }\n+  @Override\n+  public Type visit(VarBinaryType varBinaryType) {\n+    return Types.BinaryType.get();\n+  }\n \n-    return Types.StructType.of(newFields);\n+  @Override\n+  public Type visit(DecimalType decimalType) {\n+    return Types.DecimalType.of(decimalType.getPrecision(), decimalType.getScale());\n+  }\n+\n+  @Override\n+  public Type visit(TinyIntType tinyIntType) {\n+    return Types.IntegerType.get();\n+  }\n+\n+  @Override\n+  public Type visit(SmallIntType smallIntType) {\n+    return Types.IntegerType.get();\n+  }\n+\n+  @Override\n+  public Type visit(IntType intType) {\n+    return Types.IntegerType.get();\n+  }\n+\n+  @Override\n+  public Type visit(BigIntType bigIntType) {\n+    return Types.LongType.get();\n+  }\n+\n+  @Override\n+  public Type visit(FloatType floatType) {\n+    return Types.FloatType.get();\n+  }\n+\n+  @Override\n+  public Type visit(DoubleType doubleType) {\n+    return Types.DoubleType.get();\n+  }\n+\n+  @Override\n+  public Type visit(DateType dateType) {\n+    return Types.DateType.get();\n+  }\n+\n+  @Override\n+  public Type visit(TimeType timeType) {\n+    return Types.TimeType.get();\n   }\n \n   @Override\n-  public Type collection(CollectionDataType collection, Type elementType) {\n-    if (collection.getElementDataType().getLogicalType().isNullable()) {\n+  public Type visit(TimestampType timestampType) {\n+    return Types.TimestampType.withoutZone();\n+  }\n+\n+  @Override\n+  public Type visit(LocalZonedTimestampType localZonedTimestampType) {\n+    return Types.TimestampType.withZone();\n+  }\n+\n+  @Override\n+  public Type visit(ArrayType arrayType) {\n+    Type elementType = arrayType.getElementType().accept(this);\n+    if (arrayType.getElementType().isNullable()) {\n       return Types.ListType.ofOptional(getNextId(), elementType);\n     } else {\n       return Types.ListType.ofRequired(getNextId(), elementType);\n     }\n   }\n \n   @Override\n-  public Type map(KeyValueDataType map, Type keyType, Type valueType) {\n+  public Type visit(MultisetType multisetType) {\n+    Type elementType = multisetType.getElementType().accept(this);\n+    return Types.MapType.ofRequired(getNextId(), getNextId(), elementType, Types.IntegerType.get());\n+  }\n+\n+  @Override\n+  public Type visit(MapType mapType) {\n     // keys in map are not allowed to be null.\n-    if (map.getValueDataType().getLogicalType().isNullable()) {\n+    Type keyType = mapType.getKeyType().accept(this);\n+    Type valueType = mapType.getValueType().accept(this);\n+    if (mapType.getValueType().isNullable()) {\n       return Types.MapType.ofOptional(getNextId(), getNextId(), keyType, valueType);\n     } else {\n       return Types.MapType.ofRequired(getNextId(), getNextId(), keyType, valueType);\n     }\n   }\n \n-  @SuppressWarnings(\"checkstyle:CyclomaticComplexity\")\n-  @Override\n-  public Type atomic(AtomicDataType type) {\n-    LogicalType inner = type.getLogicalType();\n-    if (inner instanceof VarCharType ||\n-        inner instanceof CharType) {\n-      return Types.StringType.get();\n-    } else if (inner instanceof BooleanType) {\n-      return Types.BooleanType.get();\n-    } else if (inner instanceof IntType ||\n-        inner instanceof SmallIntType ||\n-        inner instanceof TinyIntType) {\n-      return Types.IntegerType.get();\n-    } else if (inner instanceof BigIntType) {\n-      return Types.LongType.get();\n-    } else if (inner instanceof VarBinaryType) {\n-      return Types.BinaryType.get();\n-    } else if (inner instanceof BinaryType) {\n-      BinaryType binaryType = (BinaryType) inner;\n-      return Types.FixedType.ofLength(binaryType.getLength());\n-    } else if (inner instanceof FloatType) {\n-      return Types.FloatType.get();\n-    } else if (inner instanceof DoubleType) {\n-      return Types.DoubleType.get();\n-    } else if (inner instanceof DateType) {\n-      return Types.DateType.get();\n-    } else if (inner instanceof TimeType) {\n-      return Types.TimeType.get();\n-    } else if (inner instanceof TimestampType) {\n-      return Types.TimestampType.withoutZone();\n-    } else if (inner instanceof LocalZonedTimestampType) {\n-      return Types.TimestampType.withZone();\n-    } else if (inner instanceof DecimalType) {\n-      DecimalType decimalType = (DecimalType) inner;\n-      return Types.DecimalType.of(decimalType.getPrecision(), decimalType.getScale());\n-    } else {\n-      throw new UnsupportedOperationException(\"Not a supported type: \" + type.toString());\n+  @Override\n+  public Type visit(RowType rowType) {\n+    List<Types.NestedField> newFields = Lists.newArrayListWithExpectedSize(rowType.getFieldCount());\n+    boolean isRoot = root == rowType;\n+\n+    List<Type> types = rowType.getFields().stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47beb33eda1b024280129f2422a9f32d6a0d79e9"}, "originalPosition": 223}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ4MjkyMzQz", "url": "https://github.com/apache/iceberg/pull/1173#pullrequestreview-448292343", "createdAt": "2020-07-14T16:56:43Z", "commit": {"oid": "47beb33eda1b024280129f2422a9f32d6a0d79e9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxNjo1Njo0NFrOGxcqXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxNjo1Njo0NFrOGxcqXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDUwMzAwNg==", "bodyText": "There is also a factory method that accepts a nullability boolean, NestedField.of.", "url": "https://github.com/apache/iceberg/pull/1173#discussion_r454503006", "createdAt": "2020-07-14T16:56:44Z", "author": {"login": "rdblue"}, "path": "flink/src/main/java/org/apache/iceberg/flink/FlinkTypeToType.java", "diffHunk": "@@ -64,86 +63,136 @@ private int getNextId() {\n   }\n \n   @Override\n-  public Type fields(FieldsDataType fields, List<Type> types) {\n-    List<Types.NestedField> newFields = Lists.newArrayListWithExpectedSize(types.size());\n-    boolean isRoot = root == fields;\n+  public Type visit(CharType charType) {\n+    return Types.StringType.get();\n+  }\n \n-    List<RowType.RowField> rowFields = ((RowType) fields.getLogicalType()).getFields();\n-    Preconditions.checkArgument(rowFields.size() == types.size(), \"fields list and types list should have same size.\");\n+  @Override\n+  public Type visit(VarCharType varCharType) {\n+    return Types.StringType.get();\n+  }\n \n-    for (int i = 0; i < rowFields.size(); i++) {\n-      int id = isRoot ? i : getNextId();\n+  @Override\n+  public Type visit(BooleanType booleanType) {\n+    return Types.BooleanType.get();\n+  }\n \n-      RowType.RowField field = rowFields.get(i);\n-      String name = field.getName();\n-      String comment = field.getDescription().orElse(null);\n+  @Override\n+  public Type visit(BinaryType binaryType) {\n+    return Types.FixedType.ofLength(binaryType.getLength());\n+  }\n \n-      if (field.getType().isNullable()) {\n-        newFields.add(Types.NestedField.optional(id, name, types.get(i), comment));\n-      } else {\n-        newFields.add(Types.NestedField.required(id, name, types.get(i), comment));\n-      }\n-    }\n+  @Override\n+  public Type visit(VarBinaryType varBinaryType) {\n+    return Types.BinaryType.get();\n+  }\n \n-    return Types.StructType.of(newFields);\n+  @Override\n+  public Type visit(DecimalType decimalType) {\n+    return Types.DecimalType.of(decimalType.getPrecision(), decimalType.getScale());\n+  }\n+\n+  @Override\n+  public Type visit(TinyIntType tinyIntType) {\n+    return Types.IntegerType.get();\n+  }\n+\n+  @Override\n+  public Type visit(SmallIntType smallIntType) {\n+    return Types.IntegerType.get();\n+  }\n+\n+  @Override\n+  public Type visit(IntType intType) {\n+    return Types.IntegerType.get();\n+  }\n+\n+  @Override\n+  public Type visit(BigIntType bigIntType) {\n+    return Types.LongType.get();\n+  }\n+\n+  @Override\n+  public Type visit(FloatType floatType) {\n+    return Types.FloatType.get();\n+  }\n+\n+  @Override\n+  public Type visit(DoubleType doubleType) {\n+    return Types.DoubleType.get();\n+  }\n+\n+  @Override\n+  public Type visit(DateType dateType) {\n+    return Types.DateType.get();\n+  }\n+\n+  @Override\n+  public Type visit(TimeType timeType) {\n+    return Types.TimeType.get();\n   }\n \n   @Override\n-  public Type collection(CollectionDataType collection, Type elementType) {\n-    if (collection.getElementDataType().getLogicalType().isNullable()) {\n+  public Type visit(TimestampType timestampType) {\n+    return Types.TimestampType.withoutZone();\n+  }\n+\n+  @Override\n+  public Type visit(LocalZonedTimestampType localZonedTimestampType) {\n+    return Types.TimestampType.withZone();\n+  }\n+\n+  @Override\n+  public Type visit(ArrayType arrayType) {\n+    Type elementType = arrayType.getElementType().accept(this);\n+    if (arrayType.getElementType().isNullable()) {\n       return Types.ListType.ofOptional(getNextId(), elementType);\n     } else {\n       return Types.ListType.ofRequired(getNextId(), elementType);\n     }\n   }\n \n   @Override\n-  public Type map(KeyValueDataType map, Type keyType, Type valueType) {\n+  public Type visit(MultisetType multisetType) {\n+    Type elementType = multisetType.getElementType().accept(this);\n+    return Types.MapType.ofRequired(getNextId(), getNextId(), elementType, Types.IntegerType.get());\n+  }\n+\n+  @Override\n+  public Type visit(MapType mapType) {\n     // keys in map are not allowed to be null.\n-    if (map.getValueDataType().getLogicalType().isNullable()) {\n+    Type keyType = mapType.getKeyType().accept(this);\n+    Type valueType = mapType.getValueType().accept(this);\n+    if (mapType.getValueType().isNullable()) {\n       return Types.MapType.ofOptional(getNextId(), getNextId(), keyType, valueType);\n     } else {\n       return Types.MapType.ofRequired(getNextId(), getNextId(), keyType, valueType);\n     }\n   }\n \n-  @SuppressWarnings(\"checkstyle:CyclomaticComplexity\")\n-  @Override\n-  public Type atomic(AtomicDataType type) {\n-    LogicalType inner = type.getLogicalType();\n-    if (inner instanceof VarCharType ||\n-        inner instanceof CharType) {\n-      return Types.StringType.get();\n-    } else if (inner instanceof BooleanType) {\n-      return Types.BooleanType.get();\n-    } else if (inner instanceof IntType ||\n-        inner instanceof SmallIntType ||\n-        inner instanceof TinyIntType) {\n-      return Types.IntegerType.get();\n-    } else if (inner instanceof BigIntType) {\n-      return Types.LongType.get();\n-    } else if (inner instanceof VarBinaryType) {\n-      return Types.BinaryType.get();\n-    } else if (inner instanceof BinaryType) {\n-      BinaryType binaryType = (BinaryType) inner;\n-      return Types.FixedType.ofLength(binaryType.getLength());\n-    } else if (inner instanceof FloatType) {\n-      return Types.FloatType.get();\n-    } else if (inner instanceof DoubleType) {\n-      return Types.DoubleType.get();\n-    } else if (inner instanceof DateType) {\n-      return Types.DateType.get();\n-    } else if (inner instanceof TimeType) {\n-      return Types.TimeType.get();\n-    } else if (inner instanceof TimestampType) {\n-      return Types.TimestampType.withoutZone();\n-    } else if (inner instanceof LocalZonedTimestampType) {\n-      return Types.TimestampType.withZone();\n-    } else if (inner instanceof DecimalType) {\n-      DecimalType decimalType = (DecimalType) inner;\n-      return Types.DecimalType.of(decimalType.getPrecision(), decimalType.getScale());\n-    } else {\n-      throw new UnsupportedOperationException(\"Not a supported type: \" + type.toString());\n+  @Override\n+  public Type visit(RowType rowType) {\n+    List<Types.NestedField> newFields = Lists.newArrayListWithExpectedSize(rowType.getFieldCount());\n+    boolean isRoot = root == rowType;\n+\n+    List<Type> types = rowType.getFields().stream()\n+        .map(f -> f.getType().accept(this))\n+        .collect(Collectors.toList());\n+\n+    for (int i = 0; i < rowType.getFieldCount(); i++) {\n+      int id = isRoot ? i : getNextId();\n+\n+      RowType.RowField field = rowType.getFields().get(i);\n+      String name = field.getName();\n+      String comment = field.getDescription().orElse(null);\n+\n+      if (field.getType().isNullable()) {\n+        newFields.add(Types.NestedField.optional(id, name, types.get(i), comment));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47beb33eda1b024280129f2422a9f32d6a0d79e9"}, "originalPosition": 235}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ4MjkzNjEz", "url": "https://github.com/apache/iceberg/pull/1173#pullrequestreview-448293613", "createdAt": "2020-07-14T16:58:27Z", "commit": {"oid": "47beb33eda1b024280129f2422a9f32d6a0d79e9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxNjo1ODoyN1rOGxcubg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxNjo1ODoyN1rOGxcubg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDUwNDA0Ng==", "bodyText": "What happens for a multiset of nullable items?", "url": "https://github.com/apache/iceberg/pull/1173#discussion_r454504046", "createdAt": "2020-07-14T16:58:27Z", "author": {"login": "rdblue"}, "path": "flink/src/test/java/org/apache/iceberg/flink/TestFlinkSchemaUtil.java", "diffHunk": "@@ -54,21 +54,22 @@ public void testConvertFlinkSchemaToIcebergSchema() {\n         .field(\"decimal\", DataTypes.DECIMAL(2, 2))\n         .field(\"decimal2\", DataTypes.DECIMAL(38, 2))\n         .field(\"decimal3\", DataTypes.DECIMAL(10, 1))\n+        .field(\"multiset\", DataTypes.MULTISET(DataTypes.STRING().notNull()))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47beb33eda1b024280129f2422a9f32d6a0d79e9"}, "originalPosition": 4}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4609, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}