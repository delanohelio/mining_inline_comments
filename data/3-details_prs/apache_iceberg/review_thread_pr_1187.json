{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ2Nzg0NDAx", "number": 1187, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMTowMDoxMVrOEN_TJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxNjo0ODoyMFrOEOV7yw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMTA0MDM4OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/apache/iceberg/ExpireSnapshots.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMTowMDoxMVrOGw5rBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMTowMDoxMVrOGw5rBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzkyOTczNA==", "bodyText": "Because there is already a deleteWith method that controls an option that is substantially different, I don't think it is a good idea to name the deleteWith. It seems odd to pass a callback to one and an executor service to another. What about naming this executeWith instead?", "url": "https://github.com/apache/iceberg/pull/1187#discussion_r453929734", "createdAt": "2020-07-13T21:00:11Z", "author": {"login": "rdblue"}, "path": "api/src/main/java/org/apache/iceberg/ExpireSnapshots.java", "diffHunk": "@@ -82,4 +83,18 @@\n    * @return this for method chaining\n    */\n   ExpireSnapshots deleteWith(Consumer<String> deleteFunc);\n+\n+  /**\n+   * Passes an alternative executor service that will be used for manifests and data files deletion.\n+   * <p>\n+   * Manifest files that are no longer used by valid snapshots will be deleted. Data files that were\n+   * deleted by snapshots that are expired will be deleted.\n+   * <p>\n+   * If this method is not called, unnecessary manifests and data files will still be deleted using a single threaded\n+   * executor service.\n+   *\n+   * @param executorService an executor service to parallelize tasks to delete manifests and data files\n+   * @return this for method chaining\n+   */\n+  ExpireSnapshots deleteWith(ExecutorService executorService);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5d47fb5d81a41468f9f7e539d87ece8fd2eb192e"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMTA1MTYwOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/iceberg/RemoveSnapshots.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMTowMzozM1rOGw5xyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMDoyNToxMlrOGxNqKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzkzMTQ2Ng==", "bodyText": "I think the default should be the current behavior, which is to run immediately in the current thread. You can get that behavior by using MoreExecutors.directExecutor() as the default.", "url": "https://github.com/apache/iceberg/pull/1187#discussion_r453931466", "createdAt": "2020-07-13T21:03:33Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/RemoveSnapshots.java", "diffHunk": "@@ -60,12 +62,19 @@ public void accept(String file) {\n     }\n   };\n \n+  private final ExecutorService defaultDeleteExecutorService = Executors.newSingleThreadExecutor(runnable -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5d47fb5d81a41468f9f7e539d87ece8fd2eb192e"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzkzMTgyNA==", "bodyText": "If you use directExecutor() then this can be static.", "url": "https://github.com/apache/iceberg/pull/1187#discussion_r453931824", "createdAt": "2020-07-13T21:04:18Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/RemoveSnapshots.java", "diffHunk": "@@ -60,12 +62,19 @@ public void accept(String file) {\n     }\n   };\n \n+  private final ExecutorService defaultDeleteExecutorService = Executors.newSingleThreadExecutor(runnable -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzkzMTQ2Ng=="}, "originalCommit": {"oid": "5d47fb5d81a41468f9f7e539d87ece8fd2eb192e"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI1NzE5Mw==", "bodyText": "Using MoreExecutors.newDirectExecutorService() to keep it consistent with the expected type java.util.concurrent.ExecutorService to pass to org.apache.iceberg.util.Tasks.Builder#executeWith", "url": "https://github.com/apache/iceberg/pull/1187#discussion_r454257193", "createdAt": "2020-07-14T10:25:12Z", "author": {"login": "fbocse"}, "path": "core/src/main/java/org/apache/iceberg/RemoveSnapshots.java", "diffHunk": "@@ -60,12 +62,19 @@ public void accept(String file) {\n     }\n   };\n \n+  private final ExecutorService defaultDeleteExecutorService = Executors.newSingleThreadExecutor(runnable -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzkzMTQ2Ng=="}, "originalCommit": {"oid": "5d47fb5d81a41468f9f7e539d87ece8fd2eb192e"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMTA2NjI5OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMTowODoxOVrOGw57CQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMDo1Mzo1MVrOGxOi9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzkzMzgzMw==", "bodyText": "This doesn't actually test that the thread pool is used, does it? What adding the thread ID to a concurrent set in deleteWith? Then you could assert that the threads you created were actually used.", "url": "https://github.com/apache/iceberg/pull/1187#discussion_r453933833", "createdAt": "2020-07-13T21:08:19Z", "author": {"login": "rdblue"}, "path": "core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java", "diffHunk": "@@ -404,6 +405,59 @@ public void dataFilesCleanup() throws IOException {\n     Assert.assertTrue(\"FILE_B should be deleted\", deletedFiles.contains(FILE_B.path().toString()));\n   }\n \n+  @Test\n+  public void dataFilesCleanupWithParallelTasks() throws IOException {\n+    table.newFastAppend()\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    table.newFastAppend()\n+        .appendFile(FILE_B)\n+        .commit();\n+\n+    table.newRewrite()\n+        .rewriteFiles(ImmutableSet.of(FILE_B), ImmutableSet.of(FILE_D))\n+        .commit();\n+    long thirdSnapshotId = table.currentSnapshot().snapshotId();\n+\n+    table.newRewrite()\n+        .rewriteFiles(ImmutableSet.of(FILE_A), ImmutableSet.of(FILE_C))\n+        .commit();\n+    long fourthSnapshotId = table.currentSnapshot().snapshotId();\n+\n+    long t4 = System.currentTimeMillis();\n+    while (t4 <= table.currentSnapshot().timestampMillis()) {\n+      t4 = System.currentTimeMillis();\n+    }\n+\n+    List<ManifestFile> manifests = table.currentSnapshot().dataManifests();\n+\n+    ManifestFile newManifest = writeManifest(\n+        \"manifest-file-1.avro\",\n+        manifestEntry(Status.EXISTING, thirdSnapshotId, FILE_C),\n+        manifestEntry(Status.EXISTING, fourthSnapshotId, FILE_D));\n+\n+    RewriteManifests rewriteManifests = table.rewriteManifests();\n+    manifests.forEach(rewriteManifests::deleteManifest);\n+    rewriteManifests.addManifest(newManifest);\n+    rewriteManifests.commit();\n+\n+    Set<String> deletedFiles = Sets.newHashSet();\n+\n+    table.expireSnapshots()\n+        .deleteWith(Executors.newFixedThreadPool(8, runnable -> {\n+          Thread thread = new Thread(runnable);\n+          thread.setDaemon(true);\n+          return thread;\n+        }))\n+        .expireOlderThan(t4)\n+        .deleteWith(deletedFiles::add)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5d47fb5d81a41468f9f7e539d87ece8fd2eb192e"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI3MTczMg==", "bodyText": "You're right, it doesn't verify that the provided executor services was used to submit the tasks.\nI was looking through the test suites for a pattern on unit testing usage of executor service for tasks parallel execution, didn't find one though.\nI'll follow up on your proposal to making this test more relevant.", "url": "https://github.com/apache/iceberg/pull/1187#discussion_r454271732", "createdAt": "2020-07-14T10:53:51Z", "author": {"login": "fbocse"}, "path": "core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java", "diffHunk": "@@ -404,6 +405,59 @@ public void dataFilesCleanup() throws IOException {\n     Assert.assertTrue(\"FILE_B should be deleted\", deletedFiles.contains(FILE_B.path().toString()));\n   }\n \n+  @Test\n+  public void dataFilesCleanupWithParallelTasks() throws IOException {\n+    table.newFastAppend()\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    table.newFastAppend()\n+        .appendFile(FILE_B)\n+        .commit();\n+\n+    table.newRewrite()\n+        .rewriteFiles(ImmutableSet.of(FILE_B), ImmutableSet.of(FILE_D))\n+        .commit();\n+    long thirdSnapshotId = table.currentSnapshot().snapshotId();\n+\n+    table.newRewrite()\n+        .rewriteFiles(ImmutableSet.of(FILE_A), ImmutableSet.of(FILE_C))\n+        .commit();\n+    long fourthSnapshotId = table.currentSnapshot().snapshotId();\n+\n+    long t4 = System.currentTimeMillis();\n+    while (t4 <= table.currentSnapshot().timestampMillis()) {\n+      t4 = System.currentTimeMillis();\n+    }\n+\n+    List<ManifestFile> manifests = table.currentSnapshot().dataManifests();\n+\n+    ManifestFile newManifest = writeManifest(\n+        \"manifest-file-1.avro\",\n+        manifestEntry(Status.EXISTING, thirdSnapshotId, FILE_C),\n+        manifestEntry(Status.EXISTING, fourthSnapshotId, FILE_D));\n+\n+    RewriteManifests rewriteManifests = table.rewriteManifests();\n+    manifests.forEach(rewriteManifests::deleteManifest);\n+    rewriteManifests.addManifest(newManifest);\n+    rewriteManifests.commit();\n+\n+    Set<String> deletedFiles = Sets.newHashSet();\n+\n+    table.expireSnapshots()\n+        .deleteWith(Executors.newFixedThreadPool(8, runnable -> {\n+          Thread thread = new Thread(runnable);\n+          thread.setDaemon(true);\n+          return thread;\n+        }))\n+        .expireOlderThan(t4)\n+        .deleteWith(deletedFiles::add)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzkzMzgzMw=="}, "originalCommit": {"oid": "5d47fb5d81a41468f9f7e539d87ece8fd2eb192e"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNDc0MDUzOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/iceberg/RemoveSnapshots.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxNjo0NjoyOFrOGxcPmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwNzozMDowNlrOGxxxgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ5NjE1Mw==", "bodyText": "Nit: Static final names should be ALL_CAPS.", "url": "https://github.com/apache/iceberg/pull/1187#discussion_r454496153", "createdAt": "2020-07-14T16:46:28Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/RemoveSnapshots.java", "diffHunk": "@@ -60,12 +62,16 @@ public void accept(String file) {\n     }\n   };\n \n+  // Creates an executor service that runs each task in the thread that invokes execute/submit.\n+  private static final ExecutorService defaultDeleteExecutorService = MoreExecutors.newDirectExecutorService();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5657c3eb38f936217a961d412d6aa72029168027"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ5NjY5Mg==", "bodyText": "And can you move this near the logger instead of here? That will keep all the static final fields together.", "url": "https://github.com/apache/iceberg/pull/1187#discussion_r454496692", "createdAt": "2020-07-14T16:47:14Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/RemoveSnapshots.java", "diffHunk": "@@ -60,12 +62,16 @@ public void accept(String file) {\n     }\n   };\n \n+  // Creates an executor service that runs each task in the thread that invokes execute/submit.\n+  private static final ExecutorService defaultDeleteExecutorService = MoreExecutors.newDirectExecutorService();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ5NjE1Mw=="}, "originalCommit": {"oid": "5657c3eb38f936217a961d412d6aa72029168027"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg0ODg5OQ==", "bodyText": "Right, didn't run the checks, I'll run the gradle checks before submitting the changes.", "url": "https://github.com/apache/iceberg/pull/1187#discussion_r454848899", "createdAt": "2020-07-15T07:30:06Z", "author": {"login": "fbocse"}, "path": "core/src/main/java/org/apache/iceberg/RemoveSnapshots.java", "diffHunk": "@@ -60,12 +62,16 @@ public void accept(String file) {\n     }\n   };\n \n+  // Creates an executor service that runs each task in the thread that invokes execute/submit.\n+  private static final ExecutorService defaultDeleteExecutorService = MoreExecutors.newDirectExecutorService();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ5NjE1Mw=="}, "originalCommit": {"oid": "5657c3eb38f936217a961d412d6aa72029168027"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNDc0ODkxOnYy", "diffSide": "RIGHT", "path": "core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxNjo0ODoyMFrOGxcUyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxNjo0ODoyMFrOGxcUyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ5NzQ4Mg==", "bodyText": "Unfinished comment?", "url": "https://github.com/apache/iceberg/pull/1187#discussion_r454497482", "createdAt": "2020-07-14T16:48:20Z", "author": {"login": "rdblue"}, "path": "core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java", "diffHunk": "@@ -404,6 +407,69 @@ public void dataFilesCleanup() throws IOException {\n     Assert.assertTrue(\"FILE_B should be deleted\", deletedFiles.contains(FILE_B.path().toString()));\n   }\n \n+  @Test\n+  public void dataFilesCleanupWithParallelTasks() throws IOException {\n+    table.newFastAppend()\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    table.newFastAppend()\n+        .appendFile(FILE_B)\n+        .commit();\n+\n+    table.newRewrite()\n+        .rewriteFiles(ImmutableSet.of(FILE_B), ImmutableSet.of(FILE_D))\n+        .commit();\n+    long thirdSnapshotId = table.currentSnapshot().snapshotId();\n+\n+    table.newRewrite()\n+        .rewriteFiles(ImmutableSet.of(FILE_A), ImmutableSet.of(FILE_C))\n+        .commit();\n+    long fourthSnapshotId = table.currentSnapshot().snapshotId();\n+\n+    long t4 = System.currentTimeMillis();\n+    while (t4 <= table.currentSnapshot().timestampMillis()) {\n+      t4 = System.currentTimeMillis();\n+    }\n+\n+    List<ManifestFile> manifests = table.currentSnapshot().dataManifests();\n+\n+    ManifestFile newManifest = writeManifest(\n+        \"manifest-file-1.avro\",\n+        manifestEntry(Status.EXISTING, thirdSnapshotId, FILE_C),\n+        manifestEntry(Status.EXISTING, fourthSnapshotId, FILE_D));\n+\n+    RewriteManifests rewriteManifests = table.rewriteManifests();\n+    manifests.forEach(rewriteManifests::deleteManifest);\n+    rewriteManifests.addManifest(newManifest);\n+    rewriteManifests.commit();\n+\n+    Set<String> deletedFiles = Sets.newHashSet();\n+    Set<String> deleteThreads = ConcurrentHashMap.newKeySet();\n+    AtomicInteger deleteThreadsIndex = new AtomicInteger(0);\n+\n+    table.expireSnapshots()\n+        .executeWith(Executors.newFixedThreadPool(4, runnable -> {\n+          Thread thread = new Thread(runnable);\n+          thread.setName(\"remove-snapshot-\" + deleteThreadsIndex.getAndIncrement());\n+          thread.setDaemon(true); // daemon threads will be terminated abruptly when the JVM exits\n+          return thread;\n+        }))\n+        .expireOlderThan(t4)\n+        .deleteWith(s -> {\n+          deleteThreads.add(Thread.currentThread().getName());\n+          deletedFiles.add(s);\n+        })\n+        .commit();\n+\n+    // Verifies the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5657c3eb38f936217a961d412d6aa72029168027"}, "originalPosition": 69}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3753, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}