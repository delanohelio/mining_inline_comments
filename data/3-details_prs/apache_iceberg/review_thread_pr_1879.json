{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMzMTIyNzIx", "number": 1879, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNlQwMTozODoyMFrOFBWjEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxMDozOTowOFrOFBth4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2OTYyMzIzOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/iceberg/CachingCatalog.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNlQwMTozODoyMFrOIADo7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNlQwMTozODoyMFrOIADo7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjkzMDU0MQ==", "bodyText": "We should consider moving these to be default implementations in the interface.", "url": "https://github.com/apache/iceberg/pull/1879#discussion_r536930541", "createdAt": "2020-12-06T01:38:20Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/CachingCatalog.java", "diffHunk": "@@ -99,36 +99,35 @@ public Table loadTable(TableIdentifier ident) {\n   @Override\n   public Table createTable(TableIdentifier ident, Schema schema, PartitionSpec spec, String location,\n                            Map<String, String> properties) {\n-    AtomicBoolean created = new AtomicBoolean(false);\n-    Table table = tableCache.get(canonicalizeIdentifier(ident), identifier -> {\n-      created.set(true);\n-      return catalog.createTable(identifier, schema, spec, location, properties);\n-    });\n-\n-    if (!created.get()) {\n-      throw new AlreadyExistsException(\"Table already exists: %s\", ident);\n-    }\n-\n-    return table;\n+    return buildTable(ident, schema)\n+        .withPartitionSpec(spec)\n+        .withLocation(location)\n+        .withProperties(properties)\n+        .create();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90ebeb7715a363a2bc7216ea2a58d6d0186613b7"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3MzM4ODQ5OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/iceberg/CachingCatalog.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxMDozOTowOFrOIAgZDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxNzoyNTo1NlrOIAx4Lg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQwMTYxNQ==", "bodyText": "We are calling invalidate on tableCache directly instead of the dedicated method in CachingCatalog that also invalidates metadata tables. I think we should keep the old logic.", "url": "https://github.com/apache/iceberg/pull/1879#discussion_r537401615", "createdAt": "2020-12-07T10:39:08Z", "author": {"login": "aokolnychyi"}, "path": "core/src/main/java/org/apache/iceberg/CachingCatalog.java", "diffHunk": "@@ -160,4 +159,90 @@ private void invalidate(TableIdentifier ident) {\n \n     return builder.build();\n   }\n+\n+  @Override\n+  public TableBuilder buildTable(TableIdentifier identifier, Schema schema) {\n+    return new CachingTableBuilder(identifier, schema);\n+  }\n+\n+  private class CachingTableBuilder implements TableBuilder {\n+    private final TableIdentifier ident;\n+    private final TableBuilder innerBuilder;\n+\n+    private CachingTableBuilder(TableIdentifier identifier, Schema schema) {\n+      this.innerBuilder = catalog.buildTable(identifier, schema);\n+      this.ident = identifier;\n+    }\n+\n+    @Override\n+    public TableBuilder withPartitionSpec(PartitionSpec spec) {\n+      innerBuilder.withPartitionSpec(spec);\n+      return this;\n+    }\n+\n+    @Override\n+    public TableBuilder withSortOrder(SortOrder sortOrder) {\n+      innerBuilder.withSortOrder(sortOrder);\n+      return this;\n+    }\n+\n+    @Override\n+    public TableBuilder withLocation(String location) {\n+      innerBuilder.withLocation(location);\n+      return this;\n+    }\n+\n+    @Override\n+    public TableBuilder withProperties(Map<String, String> properties) {\n+      innerBuilder.withProperties(properties);\n+      return this;\n+    }\n+\n+    @Override\n+    public TableBuilder withProperty(String key, String value) {\n+      innerBuilder.withProperty(key, value);\n+      return this;\n+    }\n+\n+    @Override\n+    public Table create() {\n+      AtomicBoolean created = new AtomicBoolean(false);\n+      Table table = tableCache.get(canonicalizeIdentifier(ident), identifier -> {\n+        created.set(true);\n+        return innerBuilder.create();\n+      });\n+\n+      if (!created.get()) {\n+        throw new AlreadyExistsException(\"Table already exists: %s\", ident);\n+      }\n+\n+      return table;\n+    }\n+\n+    @Override\n+    public Transaction createTransaction() {\n+      // create a new transaction without altering the cache. the table doesn't exist until the transaction is\n+      // committed. if the table is created before the transaction commits, any cached version is correct and the\n+      // transaction create will fail. if the transaction commits before another create, then the cache will be empty.\n+      return innerBuilder.createTransaction();\n+    }\n+\n+    @Override\n+    public Transaction replaceTransaction() {\n+      // create a new transaction without altering the cache. the table doesn't change until the transaction is\n+      // committed. when the transaction commits, invalidate the table in the cache if it is present.\n+      return CommitCallbackTransaction.addCallback(\n+          innerBuilder.replaceTransaction(),\n+          () -> tableCache.invalidate(canonicalizeIdentifier(ident)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90ebeb7715a363a2bc7216ea2a58d6d0186613b7"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzY4NzA4MA==", "bodyText": "Good catch. I hit this on Thursday in our branch based on 0.9.0 and backported it here, which is why I missed it. Thanks!", "url": "https://github.com/apache/iceberg/pull/1879#discussion_r537687080", "createdAt": "2020-12-07T17:24:28Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/CachingCatalog.java", "diffHunk": "@@ -160,4 +159,90 @@ private void invalidate(TableIdentifier ident) {\n \n     return builder.build();\n   }\n+\n+  @Override\n+  public TableBuilder buildTable(TableIdentifier identifier, Schema schema) {\n+    return new CachingTableBuilder(identifier, schema);\n+  }\n+\n+  private class CachingTableBuilder implements TableBuilder {\n+    private final TableIdentifier ident;\n+    private final TableBuilder innerBuilder;\n+\n+    private CachingTableBuilder(TableIdentifier identifier, Schema schema) {\n+      this.innerBuilder = catalog.buildTable(identifier, schema);\n+      this.ident = identifier;\n+    }\n+\n+    @Override\n+    public TableBuilder withPartitionSpec(PartitionSpec spec) {\n+      innerBuilder.withPartitionSpec(spec);\n+      return this;\n+    }\n+\n+    @Override\n+    public TableBuilder withSortOrder(SortOrder sortOrder) {\n+      innerBuilder.withSortOrder(sortOrder);\n+      return this;\n+    }\n+\n+    @Override\n+    public TableBuilder withLocation(String location) {\n+      innerBuilder.withLocation(location);\n+      return this;\n+    }\n+\n+    @Override\n+    public TableBuilder withProperties(Map<String, String> properties) {\n+      innerBuilder.withProperties(properties);\n+      return this;\n+    }\n+\n+    @Override\n+    public TableBuilder withProperty(String key, String value) {\n+      innerBuilder.withProperty(key, value);\n+      return this;\n+    }\n+\n+    @Override\n+    public Table create() {\n+      AtomicBoolean created = new AtomicBoolean(false);\n+      Table table = tableCache.get(canonicalizeIdentifier(ident), identifier -> {\n+        created.set(true);\n+        return innerBuilder.create();\n+      });\n+\n+      if (!created.get()) {\n+        throw new AlreadyExistsException(\"Table already exists: %s\", ident);\n+      }\n+\n+      return table;\n+    }\n+\n+    @Override\n+    public Transaction createTransaction() {\n+      // create a new transaction without altering the cache. the table doesn't exist until the transaction is\n+      // committed. if the table is created before the transaction commits, any cached version is correct and the\n+      // transaction create will fail. if the transaction commits before another create, then the cache will be empty.\n+      return innerBuilder.createTransaction();\n+    }\n+\n+    @Override\n+    public Transaction replaceTransaction() {\n+      // create a new transaction without altering the cache. the table doesn't change until the transaction is\n+      // committed. when the transaction commits, invalidate the table in the cache if it is present.\n+      return CommitCallbackTransaction.addCallback(\n+          innerBuilder.replaceTransaction(),\n+          () -> tableCache.invalidate(canonicalizeIdentifier(ident)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQwMTYxNQ=="}, "originalCommit": {"oid": "90ebeb7715a363a2bc7216ea2a58d6d0186613b7"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzY4ODExMA==", "bodyText": "Fixed.", "url": "https://github.com/apache/iceberg/pull/1879#discussion_r537688110", "createdAt": "2020-12-07T17:25:56Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/CachingCatalog.java", "diffHunk": "@@ -160,4 +159,90 @@ private void invalidate(TableIdentifier ident) {\n \n     return builder.build();\n   }\n+\n+  @Override\n+  public TableBuilder buildTable(TableIdentifier identifier, Schema schema) {\n+    return new CachingTableBuilder(identifier, schema);\n+  }\n+\n+  private class CachingTableBuilder implements TableBuilder {\n+    private final TableIdentifier ident;\n+    private final TableBuilder innerBuilder;\n+\n+    private CachingTableBuilder(TableIdentifier identifier, Schema schema) {\n+      this.innerBuilder = catalog.buildTable(identifier, schema);\n+      this.ident = identifier;\n+    }\n+\n+    @Override\n+    public TableBuilder withPartitionSpec(PartitionSpec spec) {\n+      innerBuilder.withPartitionSpec(spec);\n+      return this;\n+    }\n+\n+    @Override\n+    public TableBuilder withSortOrder(SortOrder sortOrder) {\n+      innerBuilder.withSortOrder(sortOrder);\n+      return this;\n+    }\n+\n+    @Override\n+    public TableBuilder withLocation(String location) {\n+      innerBuilder.withLocation(location);\n+      return this;\n+    }\n+\n+    @Override\n+    public TableBuilder withProperties(Map<String, String> properties) {\n+      innerBuilder.withProperties(properties);\n+      return this;\n+    }\n+\n+    @Override\n+    public TableBuilder withProperty(String key, String value) {\n+      innerBuilder.withProperty(key, value);\n+      return this;\n+    }\n+\n+    @Override\n+    public Table create() {\n+      AtomicBoolean created = new AtomicBoolean(false);\n+      Table table = tableCache.get(canonicalizeIdentifier(ident), identifier -> {\n+        created.set(true);\n+        return innerBuilder.create();\n+      });\n+\n+      if (!created.get()) {\n+        throw new AlreadyExistsException(\"Table already exists: %s\", ident);\n+      }\n+\n+      return table;\n+    }\n+\n+    @Override\n+    public Transaction createTransaction() {\n+      // create a new transaction without altering the cache. the table doesn't exist until the transaction is\n+      // committed. if the table is created before the transaction commits, any cached version is correct and the\n+      // transaction create will fail. if the transaction commits before another create, then the cache will be empty.\n+      return innerBuilder.createTransaction();\n+    }\n+\n+    @Override\n+    public Transaction replaceTransaction() {\n+      // create a new transaction without altering the cache. the table doesn't change until the transaction is\n+      // committed. when the transaction commits, invalidate the table in the cache if it is present.\n+      return CommitCallbackTransaction.addCallback(\n+          innerBuilder.replaceTransaction(),\n+          () -> tableCache.invalidate(canonicalizeIdentifier(ident)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQwMTYxNQ=="}, "originalCommit": {"oid": "90ebeb7715a363a2bc7216ea2a58d6d0186613b7"}, "originalPosition": 134}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3271, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}