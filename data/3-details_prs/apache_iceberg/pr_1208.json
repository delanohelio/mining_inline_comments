{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ5NjI5NDk0", "number": 1208, "title": "ORC: Add name mapping support", "bodyText": "This PR fixes #1204 implementing name mapping for ORC.", "createdAt": "2020-07-15T17:31:41Z", "url": "https://github.com/apache/iceberg/pull/1208", "merged": true, "mergeCommit": {"oid": "131c9c0eebf55d02ab88dc62677e46f2d9501048"}, "closed": true, "closedAt": "2020-08-18T20:36:14Z", "author": {"login": "edgarRd"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc1QETbgBqjM1NTAwNzYzMzE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc-Tl_qgH2gAyNDQ5NjI5NDk0OjkxYjZhMGUwNTE4NDBkMjI1YmY1ZjkwMTg2ZjViZWY4OGJmMTIwOTU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a7c50680207bd62254ae41f2479aa61e32360458", "author": {"user": {"login": "edgarRd", "name": "Edgar Rodriguez"}}, "url": "https://github.com/apache/iceberg/commit/a7c50680207bd62254ae41f2479aa61e32360458", "committedDate": "2020-07-15T17:26:25Z", "message": "Minor changes"}, "afterCommit": {"oid": "106795db2ddfbb0ed82154e219fd5315da66e245", "author": {"user": {"login": "edgarRd", "name": "Edgar Rodriguez"}}, "url": "https://github.com/apache/iceberg/commit/106795db2ddfbb0ed82154e219fd5315da66e245", "committedDate": "2020-07-15T19:47:01Z", "message": "Minor changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f340ce0f22a22594b543a1d0bfd8a411f2e0ef68", "author": {"user": {"login": "edgarRd", "name": "Edgar Rodriguez"}}, "url": "https://github.com/apache/iceberg/commit/f340ce0f22a22594b543a1d0bfd8a411f2e0ef68", "committedDate": "2020-07-22T17:26:38Z", "message": "ORC: Implement name mapping strategy"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4796b2b1c9bdefc5344966be76f4503e9a263706", "author": {"user": {"login": "edgarRd", "name": "Edgar Rodriguez"}}, "url": "https://github.com/apache/iceberg/commit/4796b2b1c9bdefc5344966be76f4503e9a263706", "committedDate": "2020-07-22T17:26:46Z", "message": "Add tests for ORC name mapping"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4e49814bdf457ec357f33014eedb25cb4a1dac7d", "author": {"user": {"login": "edgarRd", "name": "Edgar Rodriguez"}}, "url": "https://github.com/apache/iceberg/commit/4e49814bdf457ec357f33014eedb25cb4a1dac7d", "committedDate": "2020-07-22T17:26:47Z", "message": "Reuse field name tracking in OrcSchemaVisitor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2b365e8b4a88e82705f543f72d04a8f9dc7df4b4", "author": {"user": {"login": "edgarRd", "name": "Edgar Rodriguez"}}, "url": "https://github.com/apache/iceberg/commit/2b365e8b4a88e82705f543f72d04a8f9dc7df4b4", "committedDate": "2020-07-22T17:26:48Z", "message": "Minor changes"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "106795db2ddfbb0ed82154e219fd5315da66e245", "author": {"user": {"login": "edgarRd", "name": "Edgar Rodriguez"}}, "url": "https://github.com/apache/iceberg/commit/106795db2ddfbb0ed82154e219fd5315da66e245", "committedDate": "2020-07-15T19:47:01Z", "message": "Minor changes"}, "afterCommit": {"oid": "2b365e8b4a88e82705f543f72d04a8f9dc7df4b4", "author": {"user": {"login": "edgarRd", "name": "Edgar Rodriguez"}}, "url": "https://github.com/apache/iceberg/commit/2b365e8b4a88e82705f543f72d04a8f9dc7df4b4", "committedDate": "2020-07-22T17:26:48Z", "message": "Minor changes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUzODEyNTk3", "url": "https://github.com/apache/iceberg/pull/1208#pullrequestreview-453812597", "createdAt": "2020-07-23T03:11:48Z", "commit": {"oid": "2b365e8b4a88e82705f543f72d04a8f9dc7df4b4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QwMzoxMTo0OFrOG1664Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QwMzoxMTo0OFrOG1664Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE5MzA1Nw==", "bodyText": "If we are not comparing the attributes here, is there any value to adding this assert? Seems like name mapping's effect (assigning ids) is not actually being tested in this case.", "url": "https://github.com/apache/iceberg/pull/1208#discussion_r459193057", "createdAt": "2020-07-23T03:11:48Z", "author": {"login": "shardulm94"}, "path": "orc/src/test/java/org/apache/iceberg/orc/TestORCSchemaUtil.java", "diffHunk": "@@ -269,4 +278,68 @@ public void testSkipNonIcebergColumns() {\n     );\n     assertEquals(\"Schemas must match.\", expectedSchema2.asStruct(), icebergSchema2.asStruct());\n   }\n+\n+  @Test\n+  public void testHasIds() {\n+    Schema schema = new Schema(\n+        optional(1, \"data\", Types.StructType.of(\n+            optional(10, \"entries\", Types.MapType.ofOptional(11, 12, Types.StringType.get(), Types.DateType.get()))\n+        )),\n+        optional(2, \"intCol\", Types.IntegerType.get()),\n+        optional(3, \"longCol\", Types.LongType.get()),\n+        optional(4, \"listCol\", Types.ListType.ofOptional(40, Types.DoubleType.get()))\n+    );\n+\n+    TypeDescription orcSchema = ORCSchemaUtil.removeIds(ORCSchemaUtil.convert(schema));\n+    assertFalse(\"Should not have Ids\", ORCSchemaUtil.hasIds(orcSchema));\n+\n+    TypeDescription map2Col = TypeDescription.createMap(TypeDescription.createString(), TypeDescription.createBinary());\n+    map2Col.setAttribute(ICEBERG_ID_ATTRIBUTE, \"4\");\n+    orcSchema.addField(\"map2Col\", map2Col);\n+    assertTrue(\"Should have Ids after adding one type with Id\", ORCSchemaUtil.hasIds(orcSchema));\n+  }\n+\n+  @Test\n+  public void tetsAssignIdsByNameMapping() {\n+    Types.StructType structType = Types.StructType.of(\n+        required(0, \"id\", Types.LongType.get()),\n+        optional(1, \"list_of_maps\",\n+            Types.ListType.ofOptional(2, Types.MapType.ofOptional(3, 4,\n+                Types.StringType.get(),\n+                SUPPORTED_PRIMITIVES))),\n+        optional(5, \"map_of_lists\",\n+            Types.MapType.ofOptional(6, 7,\n+                Types.StringType.get(),\n+                Types.ListType.ofOptional(8, SUPPORTED_PRIMITIVES))),\n+        required(9, \"list_of_lists\",\n+            Types.ListType.ofOptional(10, Types.ListType.ofOptional(11, SUPPORTED_PRIMITIVES))),\n+        required(12, \"map_of_maps\",\n+            Types.MapType.ofOptional(13, 14,\n+                Types.StringType.get(),\n+                Types.MapType.ofOptional(15, 16,\n+                    Types.StringType.get(),\n+                    SUPPORTED_PRIMITIVES))),\n+        required(17, \"list_of_struct_of_nested_types\", Types.ListType.ofOptional(19, Types.StructType.of(\n+            Types.NestedField.required(20, \"m1\", Types.MapType.ofOptional(21, 22,\n+                Types.StringType.get(),\n+                SUPPORTED_PRIMITIVES)),\n+            Types.NestedField.optional(23, \"l1\", Types.ListType.ofRequired(24, SUPPORTED_PRIMITIVES)),\n+            Types.NestedField.required(25, \"l2\", Types.ListType.ofRequired(26, SUPPORTED_PRIMITIVES)),\n+            Types.NestedField.optional(27, \"m2\", Types.MapType.ofOptional(28, 29,\n+                Types.StringType.get(),\n+                SUPPORTED_PRIMITIVES))\n+        )))\n+    );\n+\n+    Schema schema = new Schema(TypeUtil.assignFreshIds(structType, new AtomicInteger(0)::incrementAndGet)\n+        .asStructType().fields());\n+\n+    NameMapping nameMapping = MappingUtil.create(schema);\n+    TypeDescription typeDescriptionWithIds = ORCSchemaUtil.convert(schema);\n+    TypeDescription typeDescriptionWithIdsFromNameMapping = ORCSchemaUtil\n+        .applyNameMapping(ORCSchemaUtil.removeIds(typeDescriptionWithIds), nameMapping);\n+\n+    assertTrue(\"TypeDescription schemas should be equal, not comparing Attributes\",\n+        typeDescriptionWithIds.equals(typeDescriptionWithIdsFromNameMapping, false /* checkAttributes */));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b365e8b4a88e82705f543f72d04a8f9dc7df4b4"}, "originalPosition": 133}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c0c4eb569de8e340803ae01a6e3367e8d1e37145", "author": {"user": {"login": "edgarRd", "name": "Edgar Rodriguez"}}, "url": "https://github.com/apache/iceberg/commit/c0c4eb569de8e340803ae01a6e3367e8d1e37145", "committedDate": "2020-07-24T00:54:04Z", "message": "Check mapped IDs in test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU1MjU1OTI2", "url": "https://github.com/apache/iceberg/pull/1208#pullrequestreview-455255926", "createdAt": "2020-07-25T03:02:43Z", "commit": {"oid": "c0c4eb569de8e340803ae01a6e3367e8d1e37145"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNVQwMzowMjo0M1rOG3B5_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNVQwMzowMjo0M1rOG3B5_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM1NjA5NA==", "bodyText": "Should we also check if the file schema does not have ids before initializing nameMapping?", "url": "https://github.com/apache/iceberg/pull/1208#discussion_r460356094", "createdAt": "2020-07-25T03:02:43Z", "author": {"login": "rdsr"}, "path": "orc/src/main/java/org/apache/iceberg/orc/OrcIterable.java", "diffHunk": "@@ -51,14 +54,16 @@\n   private final boolean caseSensitive;\n   private final Function<TypeDescription, OrcBatchReader<?>> batchReaderFunction;\n   private final int recordsPerBatch;\n+  private final NameMapping nameMapping;\n \n   OrcIterable(InputFile file, Configuration config, Schema schema,\n-              Long start, Long length,\n+              NameMapping nameMapping, Long start, Long length,\n               Function<TypeDescription, OrcRowReader<?>> readerFunction, boolean caseSensitive, Expression filter,\n               Function<TypeDescription, OrcBatchReader<?>> batchReaderFunction, int recordsPerBatch) {\n     this.schema = schema;\n     this.readerFunction = readerFunction;\n     this.file = file;\n+    this.nameMapping = Optional.ofNullable(nameMapping).orElse(MappingUtil.create(schema));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0c4eb569de8e340803ae01a6e3367e8d1e37145"}, "originalPosition": 31}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU1MjU4ODEy", "url": "https://github.com/apache/iceberg/pull/1208#pullrequestreview-455258812", "createdAt": "2020-07-25T03:58:20Z", "commit": {"oid": "c0c4eb569de8e340803ae01a6e3367e8d1e37145"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNVQwMzo1ODoyMFrOG3CMCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNVQwNDo0Njo1OVrOG3CblA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM2MDcxNQ==", "bodyText": "shouldn't a 'type' be pruned if a mappedField is missing or null?", "url": "https://github.com/apache/iceberg/pull/1208#discussion_r460360715", "createdAt": "2020-07-25T03:58:20Z", "author": {"login": "rdsr"}, "path": "orc/src/main/java/org/apache/iceberg/orc/ApplyNameMapping.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.orc;\n+\n+import java.util.List;\n+import org.apache.iceberg.mapping.MappedField;\n+import org.apache.iceberg.mapping.NameMapping;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.orc.TypeDescription;\n+\n+class ApplyNameMapping extends OrcSchemaVisitor<TypeDescription> {\n+  private final NameMapping nameMapping;\n+\n+  ApplyNameMapping(NameMapping nameMapping) {\n+    this.nameMapping = nameMapping;\n+  }\n+\n+  @Override\n+  public String elementName() {\n+    return \"element\";\n+  }\n+\n+  @Override\n+  public String keyName() {\n+    return \"key\";\n+  }\n+\n+  @Override\n+  public String valueName() {\n+    return \"value\";\n+  }\n+\n+  TypeDescription setId(TypeDescription type, MappedField mappedField) {\n+    if (mappedField != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0c4eb569de8e340803ae01a6e3367e8d1e37145"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM2MDkyNQ==", "bodyText": "Why do we need to call clone here?", "url": "https://github.com/apache/iceberg/pull/1208#discussion_r460360925", "createdAt": "2020-07-25T04:00:44Z", "author": {"login": "rdsr"}, "path": "orc/src/main/java/org/apache/iceberg/orc/ApplyNameMapping.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.orc;\n+\n+import java.util.List;\n+import org.apache.iceberg.mapping.MappedField;\n+import org.apache.iceberg.mapping.NameMapping;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.orc.TypeDescription;\n+\n+class ApplyNameMapping extends OrcSchemaVisitor<TypeDescription> {\n+  private final NameMapping nameMapping;\n+\n+  ApplyNameMapping(NameMapping nameMapping) {\n+    this.nameMapping = nameMapping;\n+  }\n+\n+  @Override\n+  public String elementName() {\n+    return \"element\";\n+  }\n+\n+  @Override\n+  public String keyName() {\n+    return \"key\";\n+  }\n+\n+  @Override\n+  public String valueName() {\n+    return \"value\";\n+  }\n+\n+  TypeDescription setId(TypeDescription type, MappedField mappedField) {\n+    if (mappedField != null) {\n+      type.setAttribute(ORCSchemaUtil.ICEBERG_ID_ATTRIBUTE, mappedField.id().toString());\n+    }\n+    return type;\n+  }\n+\n+  @Override\n+  public TypeDescription record(TypeDescription record, List<String> names, List<TypeDescription> fields) {\n+    Preconditions.checkArgument(names.size() == fields.size(), \"All fields must have names\");\n+    MappedField field = nameMapping.find(currentPath());\n+    TypeDescription structType = TypeDescription.createStruct();\n+\n+    for (int i = 0; i < fields.size(); i++) {\n+      String fieldName = names.get(i);\n+      TypeDescription fieldType = fields.get(i);\n+      if (fieldType != null) {\n+        structType.addField(fieldName, fieldType);\n+      }\n+    }\n+    return setId(structType, field);\n+  }\n+\n+  @Override\n+  public TypeDescription list(TypeDescription array, TypeDescription element) {\n+    Preconditions.checkArgument(element != null, \"List type must have element type\");\n+\n+    MappedField field = nameMapping.find(currentPath());\n+    TypeDescription listType = TypeDescription.createList(element);\n+    return setId(listType, field);\n+  }\n+\n+  @Override\n+  public TypeDescription map(TypeDescription map, TypeDescription key, TypeDescription value) {\n+    Preconditions.checkArgument(key != null && value != null, \"Map type must have both key and value types\");\n+\n+    MappedField field = nameMapping.find(currentPath());\n+    TypeDescription mapType = TypeDescription.createMap(key, value);\n+    return setId(mapType, field);\n+  }\n+\n+  @Override\n+  public TypeDescription primitive(TypeDescription primitive) {\n+    MappedField field = nameMapping.find(currentPath());\n+    return setId(primitive.clone(), field);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0c4eb569de8e340803ae01a6e3367e8d1e37145"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM2MTEyNg==", "bodyText": "Why underscores?", "url": "https://github.com/apache/iceberg/pull/1208#discussion_r460361126", "createdAt": "2020-07-25T04:03:45Z", "author": {"login": "rdsr"}, "path": "orc/src/main/java/org/apache/iceberg/orc/OrcSchemaVisitor.java", "diffHunk": "@@ -83,9 +112,53 @@\n     return visitor.record(record, names, visitFields(fields, names, visitor));\n   }\n \n-  public void beforeField(String name, TypeDescription type) {}\n+  public String elementName() {\n+    return \"_elem\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0c4eb569de8e340803ae01a6e3367e8d1e37145"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM2MTU0MQ==", "bodyText": "Why don't we only remove the ID attribute?", "url": "https://github.com/apache/iceberg/pull/1208#discussion_r460361541", "createdAt": "2020-07-25T04:08:27Z", "author": {"login": "rdsr"}, "path": "orc/src/main/java/org/apache/iceberg/orc/RemoveIds.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.orc;\n+\n+import java.util.List;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.orc.TypeDescription;\n+\n+class RemoveIds extends OrcSchemaVisitor<TypeDescription> {\n+\n+  @Override\n+  public TypeDescription record(TypeDescription record, List<String> names, List<TypeDescription> fields) {\n+    Preconditions.checkArgument(names.size() == fields.size(), \"All fields must have names.\");\n+    TypeDescription struct = TypeDescription.createStruct();\n+\n+    for (int i = 0; i < fields.size(); i++) {\n+      struct.addField(names.get(i), fields.get(i));\n+    }\n+    return struct;\n+  }\n+\n+  @Override\n+  public TypeDescription list(TypeDescription array, TypeDescription element) {\n+    return TypeDescription.createList(element);\n+  }\n+\n+  @Override\n+  public TypeDescription map(TypeDescription map, TypeDescription key, TypeDescription value) {\n+    return TypeDescription.createMap(key, value);\n+  }\n+\n+  @Override\n+  public TypeDescription primitive(TypeDescription primitive) {\n+    return removeIcebergAttributes(primitive.clone());\n+  }\n+\n+  private static TypeDescription removeIcebergAttributes(TypeDescription orcType) {\n+    orcType.removeAttribute(ORCSchemaUtil.ICEBERG_ID_ATTRIBUTE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0c4eb569de8e340803ae01a6e3367e8d1e37145"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM2MjUwMg==", "bodyText": "IIRC, nameMapping may not have all the fields which maybe present in the file schema. I think we need a way to prune columns which does not have an associated mapping defined. I can't say whether buildOrcProjection is handling that case or not.", "url": "https://github.com/apache/iceberg/pull/1208#discussion_r460362502", "createdAt": "2020-07-25T04:19:00Z", "author": {"login": "rdsr"}, "path": "orc/src/main/java/org/apache/iceberg/orc/OrcIterable.java", "diffHunk": "@@ -73,7 +78,15 @@\n   public CloseableIterator<T> iterator() {\n     Reader orcFileReader = ORC.newFileReader(file, config);\n     addCloseable(orcFileReader);\n-    TypeDescription readOrcSchema = ORCSchemaUtil.buildOrcProjection(schema, orcFileReader.getSchema());\n+\n+    TypeDescription fileSchema = orcFileReader.getSchema();\n+    final TypeDescription readOrcSchema;\n+    if (ORCSchemaUtil.hasIds(fileSchema)) {\n+      readOrcSchema = ORCSchemaUtil.buildOrcProjection(schema, fileSchema);\n+    } else {\n+      TypeDescription typeWithIds = ORCSchemaUtil.applyNameMapping(fileSchema, nameMapping);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0c4eb569de8e340803ae01a6e3367e8d1e37145"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM2NDY5Mg==", "bodyText": "can we have a test case for where complex fields are also pruned? For instance if all fields of a struct are pruned, the struct is pruned. Similarly for maps and lists?", "url": "https://github.com/apache/iceberg/pull/1208#discussion_r460364692", "createdAt": "2020-07-25T04:46:59Z", "author": {"login": "rdsr"}, "path": "orc/src/test/java/org/apache/iceberg/orc/TestExpressionToSearchArgument.java", "diffHunk": "@@ -262,4 +264,65 @@ public void testEvolvedSchema() {\n     actual = ExpressionToSearchArgument.convert(boundFilter, readSchema);\n     Assert.assertEquals(expected.toString(), actual.toString());\n   }\n+\n+  @Test\n+  public void testOriginalSchemaNameMapping() {\n+    Schema originalSchema = new Schema(\n+        required(1, \"int\", Types.IntegerType.get()),\n+        optional(2, \"long\", Types.LongType.get())\n+    );\n+\n+    TypeDescription orcSchemaWithoutIds = ORCSchemaUtil.removeIds(ORCSchemaUtil.convert(originalSchema));\n+    NameMapping nameMapping = MappingUtil.create(originalSchema);\n+\n+    TypeDescription readSchema = ORCSchemaUtil.buildOrcProjection(originalSchema,\n+        ORCSchemaUtil.applyNameMapping(orcSchemaWithoutIds, nameMapping));\n+\n+    Expression expr = and(equal(\"int\", 1), equal(\"long\", 1));\n+    Expression boundFilter = Binder.bind(originalSchema.asStruct(), expr, true);\n+    SearchArgument expected = SearchArgumentFactory.newBuilder()\n+        .equals(\"`int`\", Type.LONG, 1L)\n+        .equals(\"`long`\", Type.LONG, 1L)\n+        .build();\n+\n+    SearchArgument actual = ExpressionToSearchArgument.convert(boundFilter, readSchema);\n+    Assert.assertEquals(expected.toString(), actual.toString());\n+  }\n+\n+  @Test\n+  public void testModifiedSchemaNameMapping() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0c4eb569de8e340803ae01a6e3367e8d1e37145"}, "originalPosition": 39}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "75fc9fdafee3ed34e99000344b719da3691ff5cb", "author": {"user": {"login": "edgarRd", "name": "Edgar Rodriguez"}}, "url": "https://github.com/apache/iceberg/commit/75fc9fdafee3ed34e99000344b719da3691ff5cb", "committedDate": "2020-07-27T23:24:38Z", "message": "Compute name mapping if no ids are found"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ff01d48b9db2237b8f5822ee33a56a3f76a689a5", "author": {"user": {"login": "edgarRd", "name": "Edgar Rodriguez"}}, "url": "https://github.com/apache/iceberg/commit/ff01d48b9db2237b8f5822ee33a56a3f76a689a5", "committedDate": "2020-07-28T03:45:13Z", "message": "Add more tests\n\n- Projection on complex types: maps, lists, structs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b74abd8cdb25a94c3033404b324e95575216b493", "author": {"user": {"login": "edgarRd", "name": "Edgar Rodriguez"}}, "url": "https://github.com/apache/iceberg/commit/b74abd8cdb25a94c3033404b324e95575216b493", "committedDate": "2020-07-28T03:47:36Z", "message": "Remove Ids only"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzOTQxOTQx", "url": "https://github.com/apache/iceberg/pull/1208#pullrequestreview-463941941", "createdAt": "2020-08-10T03:29:25Z", "commit": {"oid": "b74abd8cdb25a94c3033404b324e95575216b493"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQwMzoyOToyNlrOG-Ag1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQwMzoyOToyNlrOG-Ag1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY3MzMwMQ==", "bodyText": "Nit: Typo struct.long", "url": "https://github.com/apache/iceberg/pull/1208#discussion_r467673301", "createdAt": "2020-08-10T03:29:26Z", "author": {"login": "shardulm94"}, "path": "orc/src/test/java/org/apache/iceberg/orc/TestExpressionToSearchArgument.java", "diffHunk": "@@ -262,4 +264,132 @@ public void testEvolvedSchema() {\n     actual = ExpressionToSearchArgument.convert(boundFilter, readSchema);\n     Assert.assertEquals(expected.toString(), actual.toString());\n   }\n+\n+  @Test\n+  public void testOriginalSchemaNameMapping() {\n+    Schema originalSchema = new Schema(\n+        required(1, \"int\", Types.IntegerType.get()),\n+        optional(2, \"long\", Types.LongType.get())\n+    );\n+\n+    TypeDescription orcSchemaWithoutIds = ORCSchemaUtil.removeIds(ORCSchemaUtil.convert(originalSchema));\n+    NameMapping nameMapping = MappingUtil.create(originalSchema);\n+\n+    TypeDescription readSchema = ORCSchemaUtil.buildOrcProjection(originalSchema,\n+        ORCSchemaUtil.applyNameMapping(orcSchemaWithoutIds, nameMapping));\n+\n+    Expression expr = and(equal(\"int\", 1), equal(\"long\", 1));\n+    Expression boundFilter = Binder.bind(originalSchema.asStruct(), expr, true);\n+    SearchArgument expected = SearchArgumentFactory.newBuilder()\n+        .equals(\"`int`\", Type.LONG, 1L)\n+        .equals(\"`long`\", Type.LONG, 1L)\n+        .build();\n+\n+    SearchArgument actual = ExpressionToSearchArgument.convert(boundFilter, readSchema);\n+    Assert.assertEquals(expected.toString(), actual.toString());\n+  }\n+\n+  @Test\n+  public void testModifiedSimpleSchemaNameMapping() {\n+    Schema originalSchema = new Schema(\n+        required(1, \"int\", Types.IntegerType.get()),\n+        optional(2, \"long_to_be_dropped\", Types.LongType.get())\n+    );\n+    Schema mappingSchema = new Schema(\n+        required(1, \"int\", Types.IntegerType.get()),\n+        optional(3, \"new_float_field\", Types.FloatType.get())\n+    );\n+    TypeDescription orcSchemaWithoutIds = ORCSchemaUtil.removeIds(ORCSchemaUtil.convert(originalSchema));\n+    NameMapping nameMapping = MappingUtil.create(mappingSchema);\n+\n+    TypeDescription readSchema = ORCSchemaUtil.buildOrcProjection(mappingSchema,\n+        ORCSchemaUtil.applyNameMapping(orcSchemaWithoutIds, nameMapping));\n+\n+    Expression expr = equal(\"int\", 1);\n+    Expression boundFilter = Binder.bind(mappingSchema.asStruct(), expr, true);\n+    SearchArgument expected = SearchArgumentFactory.newBuilder()\n+        .equals(\"`int`\", Type.LONG, 1L)\n+        .build();\n+\n+    SearchArgument actual = ExpressionToSearchArgument.convert(boundFilter, readSchema);\n+    Assert.assertEquals(expected.toString(), actual.toString());\n+\n+    // for columns not in the file, buildOrcProjection will append field names with _r<ID>\n+    // this will be passed down to ORC, but ORC will handle such cases and return a TruthValue during evaluation\n+    expr = equal(\"new_float_field\", 1);\n+    boundFilter = Binder.bind(mappingSchema.asStruct(), expr, true);\n+    expected = SearchArgumentFactory.newBuilder()\n+        .equals(\"`new_float_field_r3`\", Type.FLOAT, 1.0)\n+        .build();\n+\n+    actual = ExpressionToSearchArgument.convert(boundFilter, readSchema);\n+    Assert.assertEquals(expected.toString(), actual.toString());\n+  }\n+\n+  @Test\n+  public void testModifiedComplexSchemaNameMapping() {\n+    Schema originalSchema = new Schema(\n+        optional(1, \"struct\", Types.StructType.of(\n+            required(2, \"long\", Types.LongType.get())\n+        )),\n+        optional(3, \"list\", Types.ListType.ofRequired(4, Types.LongType.get())),\n+        optional(5, \"map\", Types.MapType.ofRequired(6, 7, Types.LongType.get(), Types.LongType.get())),\n+        optional(8, \"listOfStruct\", Types.ListType.ofRequired(9, Types.StructType.of(\n+            required(10, \"long\", Types.LongType.get())))),\n+        optional(11, \"listOfPeople\", Types.ListType.ofRequired(12, Types.StructType.of(\n+            required(13, \"name\", Types.StringType.get()),\n+            required(14, \"birth_date\", Types.DateType.get()))))\n+    );\n+    Schema mappingSchema = new Schema(\n+        optional(1, \"struct\", Types.StructType.of(\n+            required(2, \"int\", Types.LongType.get())\n+        )),\n+        optional(3, \"list\", Types.ListType.ofRequired(4, Types.LongType.get())),\n+        optional(5, \"newMap\", Types.MapType.ofRequired(6, 7, Types.StringType.get(), Types.LongType.get())),\n+        optional(8, \"listOfStruct\", Types.ListType.ofRequired(9, Types.StructType.of(\n+            required(10, \"newLong\", Types.LongType.get())))),\n+        optional(11, \"listOfPeople\", Types.ListType.ofRequired(12, Types.StructType.of(\n+            required(13, \"name\", Types.StringType.get()),\n+            required(14, \"age\", Types.IntegerType.get()))))\n+    );\n+    TypeDescription orcSchemaWithoutIds = ORCSchemaUtil.removeIds(ORCSchemaUtil.convert(originalSchema));\n+    NameMapping nameMapping = MappingUtil.create(mappingSchema);\n+\n+    TypeDescription readSchema = ORCSchemaUtil.buildOrcProjection(mappingSchema,\n+        ORCSchemaUtil.applyNameMapping(orcSchemaWithoutIds, nameMapping));\n+\n+    Expression expr = and(\n+        and(\n+            equal(\"struct.int\", 1), and(\n+                lessThanOrEqual(\"list.element\", 5),\n+                equal(\"newMap.key\", \"country\")\n+            ),\n+            and(\n+                equal(\"listOfStruct.newLong\", 100L),\n+                notEqual(\"listOfPeople.name\", \"Bob\")\n+            )\n+\n+        ),\n+        lessThan(\"listOfPeople.age\", 30)\n+    );\n+    Expression boundFilter = Binder.bind(mappingSchema.asStruct(), expr, true);\n+    SearchArgument expected = SearchArgumentFactory.newBuilder()\n+        .startAnd()\n+        // Drops strict.long", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b74abd8cdb25a94c3033404b324e95575216b493"}, "originalPosition": 124}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NzU4NDE0", "url": "https://github.com/apache/iceberg/pull/1208#pullrequestreview-464758414", "createdAt": "2020-08-11T05:30:28Z", "commit": {"oid": "b74abd8cdb25a94c3033404b324e95575216b493"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "91b6a0e051840d225bf5f90186f5bef88bf12095", "author": {"user": {"login": "edgarRd", "name": "Edgar Rodriguez"}}, "url": "https://github.com/apache/iceberg/commit/91b6a0e051840d225bf5f90186f5bef88bf12095", "committedDate": "2020-08-12T22:59:05Z", "message": "Fix typo"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4267, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}