{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc1ODg4NjUw", "number": 805, "title": "Add all_data_files, all_manifests, and all_entries metadata tables", "bodyText": "This adds 3 new metadata tables and tests:\n\nall_data_files lists all data files in a table that are accessible from any valid (not expired) snapshot\nall_entries lists all manifest entries in a table that are accessible from any valid snapshot\nall_manifests lists all manifest files in a table that are accessible from any valid snapshot\n\nThese tables may contain duplicate rows. Deduplication can't be done through the current scan interface unless all of the work is done during scan planning on a single node. Duplicates are the trade-off for being able to process the metadata in parallel for large tables.\nUse cases\nWe recently added the all_data_files and all_manifests tables to enable building services that manage data files. For example, a janitor service that cleans up orphaned or dangling data files needs to be able to list all valid files in a table. Along with the snapshots table that has manifest list locations, all_manifests and all_data_files enable listing all data and metadata files referenced by a table.\nWe use the all_entries table to detect the last modified time of partitions. This requires knowing when a file was appended or overwritten and requires ignoring later rewrites:\nSELECT\n    max(s.committed_at) as last_updated_at,\n    e.data_file.partition.*\nFROM db.table.all_entries e\nJOIN db.table.snapshots s\n  ON e.snapshot_id = s.snapshot_id\nWHERE e.status = 1 AND s.operation IN ('append', 'overwrite')\nGROUP BY e.data_file.partition", "createdAt": "2020-02-16T23:39:49Z", "url": "https://github.com/apache/iceberg/pull/805", "merged": true, "mergeCommit": {"oid": "65095c149c2489ac3230d0d20328e492919d9d4f"}, "closed": true, "closedAt": "2020-02-17T21:52:42Z", "author": {"login": "rdblue"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcFCom0AH2gAyMzc1ODg4NjUwOmI0NDZkZTllZmE0Y2EzN2U4NTFjNWEzOTY4YjAzZWM0OWNlNTRlYWE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcGjOz8gFqTM2Mjc5NjMwOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "b446de9efa4ca37e851c5a3968b03ec49ce54eaa", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/b446de9efa4ca37e851c5a3968b03ec49ce54eaa", "committedDate": "2020-02-17T00:59:52Z", "message": "Add all_data_files, all_manifests, and all_entries metadata tables."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "843e3d8a8c04bbce8d6bdab7b75d57e7bd093b71", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/843e3d8a8c04bbce8d6bdab7b75d57e7bd093b71", "committedDate": "2020-02-16T23:27:46Z", "message": "Add all_data_files, all_manifests, and all_entries metadata tables."}, "afterCommit": {"oid": "b446de9efa4ca37e851c5a3968b03ec49ce54eaa", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/b446de9efa4ca37e851c5a3968b03ec49ce54eaa", "committedDate": "2020-02-17T00:59:52Z", "message": "Add all_data_files, all_manifests, and all_entries metadata tables."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU5OTI4Mzk3", "url": "https://github.com/apache/iceberg/pull/805#pullrequestreview-359928397", "createdAt": "2020-02-17T19:15:40Z", "commit": {"oid": "b446de9efa4ca37e851c5a3968b03ec49ce54eaa"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxOToxNTo0MFrOFqt4cQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxOToxODowOVrOFqt7Vg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDMzNjI0MQ==", "bodyText": "This may be a bit out of scope, but shouldn't we have a better way to represent reserved field ids than magic numbers?", "url": "https://github.com/apache/iceberg/pull/805#discussion_r380336241", "createdAt": "2020-02-17T19:15:40Z", "author": {"login": "danielcweeks"}, "path": "core/src/main/java/org/apache/iceberg/AllDataFilesTable.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Sets;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.List;\n+import org.apache.iceberg.exceptions.RuntimeIOException;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.ResidualEvaluator;\n+import org.apache.iceberg.io.CloseableIterable;\n+import org.apache.iceberg.types.TypeUtil;\n+import org.apache.iceberg.util.ParallelIterable;\n+import org.apache.iceberg.util.ThreadPools;\n+\n+/**\n+ * A {@link Table} implementation that exposes a table's valid data files as rows.\n+ * <p>\n+ * A valid data file is one that is readable from any snapshot currently tracked by the table.\n+ * <p>\n+ * This table may return duplicate rows.\n+ */\n+public class AllDataFilesTable extends BaseMetadataTable {\n+  private final TableOperations ops;\n+  private final Table table;\n+\n+  public AllDataFilesTable(TableOperations ops, Table table) {\n+    this.ops = ops;\n+    this.table = table;\n+  }\n+\n+  @Override\n+  Table table() {\n+    return table;\n+  }\n+\n+  @Override\n+  String metadataTableName() {\n+    return \"all_data_files\";\n+  }\n+\n+  @Override\n+  public TableScan newScan() {\n+    return new AllDataFilesTableScan(ops, table, schema());\n+  }\n+\n+  @Override\n+  public Schema schema() {\n+    Schema schema = new Schema(DataFile.getType(table.spec().partitionType()).fields());\n+    if (table.spec().fields().size() < 1) {\n+      // avoid returning an empty struct, which is not always supported. instead, drop the partition field (id 102)\n+      return TypeUtil.selectNot(schema, Sets.newHashSet(102));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b446de9efa4ca37e851c5a3968b03ec49ce54eaa"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDMzNjQzMw==", "bodyText": "Assumes manifest list location?", "url": "https://github.com/apache/iceberg/pull/805#discussion_r380336433", "createdAt": "2020-02-17T19:16:17Z", "author": {"login": "danielcweeks"}, "path": "core/src/main/java/org/apache/iceberg/AllDataFilesTable.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Sets;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.List;\n+import org.apache.iceberg.exceptions.RuntimeIOException;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.ResidualEvaluator;\n+import org.apache.iceberg.io.CloseableIterable;\n+import org.apache.iceberg.types.TypeUtil;\n+import org.apache.iceberg.util.ParallelIterable;\n+import org.apache.iceberg.util.ThreadPools;\n+\n+/**\n+ * A {@link Table} implementation that exposes a table's valid data files as rows.\n+ * <p>\n+ * A valid data file is one that is readable from any snapshot currently tracked by the table.\n+ * <p>\n+ * This table may return duplicate rows.\n+ */\n+public class AllDataFilesTable extends BaseMetadataTable {\n+  private final TableOperations ops;\n+  private final Table table;\n+\n+  public AllDataFilesTable(TableOperations ops, Table table) {\n+    this.ops = ops;\n+    this.table = table;\n+  }\n+\n+  @Override\n+  Table table() {\n+    return table;\n+  }\n+\n+  @Override\n+  String metadataTableName() {\n+    return \"all_data_files\";\n+  }\n+\n+  @Override\n+  public TableScan newScan() {\n+    return new AllDataFilesTableScan(ops, table, schema());\n+  }\n+\n+  @Override\n+  public Schema schema() {\n+    Schema schema = new Schema(DataFile.getType(table.spec().partitionType()).fields());\n+    if (table.spec().fields().size() < 1) {\n+      // avoid returning an empty struct, which is not always supported. instead, drop the partition field (id 102)\n+      return TypeUtil.selectNot(schema, Sets.newHashSet(102));\n+    } else {\n+      return schema;\n+    }\n+  }\n+\n+  @Override\n+  public String location() {\n+    return table.currentSnapshot().manifestListLocation();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b446de9efa4ca37e851c5a3968b03ec49ce54eaa"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDMzNjk4Mg==", "bodyText": "Seems like something we should map to a table/read property \\w default as opposed to hard coded.", "url": "https://github.com/apache/iceberg/pull/805#discussion_r380336982", "createdAt": "2020-02-17T19:18:09Z", "author": {"login": "danielcweeks"}, "path": "core/src/main/java/org/apache/iceberg/AllDataFilesTable.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Sets;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.List;\n+import org.apache.iceberg.exceptions.RuntimeIOException;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.ResidualEvaluator;\n+import org.apache.iceberg.io.CloseableIterable;\n+import org.apache.iceberg.types.TypeUtil;\n+import org.apache.iceberg.util.ParallelIterable;\n+import org.apache.iceberg.util.ThreadPools;\n+\n+/**\n+ * A {@link Table} implementation that exposes a table's valid data files as rows.\n+ * <p>\n+ * A valid data file is one that is readable from any snapshot currently tracked by the table.\n+ * <p>\n+ * This table may return duplicate rows.\n+ */\n+public class AllDataFilesTable extends BaseMetadataTable {\n+  private final TableOperations ops;\n+  private final Table table;\n+\n+  public AllDataFilesTable(TableOperations ops, Table table) {\n+    this.ops = ops;\n+    this.table = table;\n+  }\n+\n+  @Override\n+  Table table() {\n+    return table;\n+  }\n+\n+  @Override\n+  String metadataTableName() {\n+    return \"all_data_files\";\n+  }\n+\n+  @Override\n+  public TableScan newScan() {\n+    return new AllDataFilesTableScan(ops, table, schema());\n+  }\n+\n+  @Override\n+  public Schema schema() {\n+    Schema schema = new Schema(DataFile.getType(table.spec().partitionType()).fields());\n+    if (table.spec().fields().size() < 1) {\n+      // avoid returning an empty struct, which is not always supported. instead, drop the partition field (id 102)\n+      return TypeUtil.selectNot(schema, Sets.newHashSet(102));\n+    } else {\n+      return schema;\n+    }\n+  }\n+\n+  @Override\n+  public String location() {\n+    return table.currentSnapshot().manifestListLocation();\n+  }\n+\n+  public static class AllDataFilesTableScan extends BaseTableScan {\n+    private static final long TARGET_SPLIT_SIZE = 32 * 1024 * 1024; // 32 MB\n+    private final Schema fileSchema;\n+\n+    AllDataFilesTableScan(TableOperations ops, Table table, Schema fileSchema) {\n+      super(ops, table, fileSchema);\n+      this.fileSchema = fileSchema;\n+    }\n+\n+    private AllDataFilesTableScan(\n+        TableOperations ops, Table table, Long snapshotId, Schema schema, Expression rowFilter,\n+        boolean caseSensitive, boolean colStats, Collection<String> selectedColumns, Schema fileSchema,\n+        ImmutableMap<String, String> options) {\n+      super(ops, table, snapshotId, schema, rowFilter, caseSensitive, colStats, selectedColumns, options);\n+      this.fileSchema = fileSchema;\n+    }\n+\n+    @Override\n+    protected TableScan newRefinedScan(\n+        TableOperations ops, Table table, Long snapshotId, Schema schema, Expression rowFilter,\n+        boolean caseSensitive, boolean colStats, Collection<String> selectedColumns,\n+        ImmutableMap<String, String> options) {\n+      return new AllDataFilesTableScan(\n+          ops, table, snapshotId, schema, rowFilter, caseSensitive, colStats, selectedColumns, fileSchema, options);\n+    }\n+\n+    @Override\n+    public TableScan useSnapshot(long scanSnapshotId) {\n+      throw new UnsupportedOperationException(\"Cannot select snapshot: all_data_files is for all snapshots\");\n+    }\n+\n+    @Override\n+    public TableScan asOfTime(long timestampMillis) {\n+      throw new UnsupportedOperationException(\"Cannot select snapshot: all_data_files is for all snapshots\");\n+    }\n+\n+    @Override\n+    protected long targetSplitSize(TableOperations ops) {\n+      return TARGET_SPLIT_SIZE;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b446de9efa4ca37e851c5a3968b03ec49ce54eaa"}, "originalPosition": 121}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "452082c9f05ba15f17dc394c4453a7a539d70d45", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/452082c9f05ba15f17dc394c4453a7a539d70d45", "committedDate": "2020-02-17T21:13:22Z", "message": "Merge branch 'master' into add-new-metadata-tables"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyNzk2MzA5", "url": "https://github.com/apache/iceberg/pull/805#pullrequestreview-362796309", "createdAt": "2020-02-21T17:32:29Z", "commit": {"oid": "452082c9f05ba15f17dc394c4453a7a539d70d45"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQxNzozMjoyOVrOFs-3tg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQxNzozMjoyOVrOFs-3tg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcxMTczNA==", "bodyText": "There are a couple of places when we define static methods in one metadata table class and call them in others. It seems we can put some of those in the parent BaseMetadataTable.", "url": "https://github.com/apache/iceberg/pull/805#discussion_r382711734", "createdAt": "2020-02-21T17:32:29Z", "author": {"login": "aokolnychyi"}, "path": "core/src/main/java/org/apache/iceberg/AllDataFilesTable.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Sets;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.List;\n+import org.apache.iceberg.exceptions.RuntimeIOException;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.ResidualEvaluator;\n+import org.apache.iceberg.io.CloseableIterable;\n+import org.apache.iceberg.types.TypeUtil;\n+import org.apache.iceberg.util.ParallelIterable;\n+import org.apache.iceberg.util.ThreadPools;\n+\n+/**\n+ * A {@link Table} implementation that exposes a table's valid data files as rows.\n+ * <p>\n+ * A valid data file is one that is readable from any snapshot currently tracked by the table.\n+ * <p>\n+ * This table may return duplicate rows.\n+ */\n+public class AllDataFilesTable extends BaseMetadataTable {\n+  private final TableOperations ops;\n+  private final Table table;\n+\n+  public AllDataFilesTable(TableOperations ops, Table table) {\n+    this.ops = ops;\n+    this.table = table;\n+  }\n+\n+  @Override\n+  Table table() {\n+    return table;\n+  }\n+\n+  @Override\n+  String metadataTableName() {\n+    return \"all_data_files\";\n+  }\n+\n+  @Override\n+  public TableScan newScan() {\n+    return new AllDataFilesTableScan(ops, table, schema());\n+  }\n+\n+  @Override\n+  public Schema schema() {\n+    Schema schema = new Schema(DataFile.getType(table.spec().partitionType()).fields());\n+    if (table.spec().fields().size() < 1) {\n+      // avoid returning an empty struct, which is not always supported. instead, drop the partition field (id 102)\n+      return TypeUtil.selectNot(schema, Sets.newHashSet(102));\n+    } else {\n+      return schema;\n+    }\n+  }\n+\n+  @Override\n+  public String location() {\n+    return table.currentSnapshot().manifestListLocation();\n+  }\n+\n+  public static class AllDataFilesTableScan extends BaseTableScan {\n+    private static final long TARGET_SPLIT_SIZE = 32 * 1024 * 1024; // 32 MB\n+    private final Schema fileSchema;\n+\n+    AllDataFilesTableScan(TableOperations ops, Table table, Schema fileSchema) {\n+      super(ops, table, fileSchema);\n+      this.fileSchema = fileSchema;\n+    }\n+\n+    private AllDataFilesTableScan(\n+        TableOperations ops, Table table, Long snapshotId, Schema schema, Expression rowFilter,\n+        boolean caseSensitive, boolean colStats, Collection<String> selectedColumns, Schema fileSchema,\n+        ImmutableMap<String, String> options) {\n+      super(ops, table, snapshotId, schema, rowFilter, caseSensitive, colStats, selectedColumns, options);\n+      this.fileSchema = fileSchema;\n+    }\n+\n+    @Override\n+    protected TableScan newRefinedScan(\n+        TableOperations ops, Table table, Long snapshotId, Schema schema, Expression rowFilter,\n+        boolean caseSensitive, boolean colStats, Collection<String> selectedColumns,\n+        ImmutableMap<String, String> options) {\n+      return new AllDataFilesTableScan(\n+          ops, table, snapshotId, schema, rowFilter, caseSensitive, colStats, selectedColumns, fileSchema, options);\n+    }\n+\n+    @Override\n+    public TableScan useSnapshot(long scanSnapshotId) {\n+      throw new UnsupportedOperationException(\"Cannot select snapshot: all_data_files is for all snapshots\");\n+    }\n+\n+    @Override\n+    public TableScan asOfTime(long timestampMillis) {\n+      throw new UnsupportedOperationException(\"Cannot select snapshot: all_data_files is for all snapshots\");\n+    }\n+\n+    @Override\n+    protected long targetSplitSize(TableOperations ops) {\n+      return TARGET_SPLIT_SIZE;\n+    }\n+\n+    @Override\n+    protected CloseableIterable<FileScanTask> planFiles(\n+        TableOperations ops, Snapshot snapshot, Expression rowFilter, boolean caseSensitive, boolean colStats) {\n+      CloseableIterable<ManifestFile> manifests = allManifestFiles(ops.current().snapshots());\n+      String schemaString = SchemaParser.toJson(schema());\n+      String specString = PartitionSpecParser.toJson(PartitionSpec.unpartitioned());\n+      ResidualEvaluator residuals = ResidualEvaluator.unpartitioned(rowFilter);\n+\n+      // Data tasks produce the table schema, not the projection schema and projection is done by processing engines.\n+      // This data task needs to use the table schema, which may not include a partition schema to avoid having an\n+      // empty struct in the schema for unpartitioned tables. Some engines, like Spark, can't handle empty structs in\n+      // all cases.\n+      return CloseableIterable.transform(manifests, manifest ->\n+          new DataFilesTable.ManifestReadTask(ops.io(), manifest, fileSchema, schemaString, specString, residuals));\n+    }\n+  }\n+\n+  static CloseableIterable<ManifestFile> allManifestFiles(List<Snapshot> snapshots) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "452082c9f05ba15f17dc394c4453a7a539d70d45"}, "originalPosition": 141}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4944, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}