{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ0MzM5NTcx", "number": 1167, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwMzoyNDoyOFrOELhxmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwMzoyNDoyOFrOELhxmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwNTIzMTYzOnYy", "diffSide": "RIGHT", "path": "orc/src/main/java/org/apache/iceberg/orc/OrcMetrics.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwMzoyNDoyOFrOGtHuHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQyMzozMTowNlrOHF6TCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk2NTU5OA==", "bodyText": "Just to verify, this would fail if there's any column that does not have an Iceberg ID. Is that preferred to skipping the metrics instead?", "url": "https://github.com/apache/iceberg/pull/1167#discussion_r449965598", "createdAt": "2020-07-06T03:24:28Z", "author": {"login": "edgarRd"}, "path": "orc/src/main/java/org/apache/iceberg/orc/OrcMetrics.java", "diffHunk": "@@ -209,64 +206,17 @@ private static Metrics buildOrcMetrics(final long numOfRows, final TypeDescripti\n     return Optional.ofNullable(Conversions.toByteBuffer(column.type(), max));\n   }\n \n-  private static Set<TypeDescription> findColumnsInContainers(Schema schema,\n-                                                              TypeDescription orcSchema) {\n-    ColumnsInContainersVisitor visitor = new ColumnsInContainersVisitor();\n-    OrcSchemaWithTypeVisitor.visit(schema, orcSchema, visitor);\n-    return visitor.getColumnsInContainers();\n+  private static Set<Integer> statsColumns(TypeDescription schema) {\n+    return OrcSchemaVisitor.visit(schema, new StatsColumnsVisitor());\n   }\n \n-  private static class ColumnsInContainersVisitor extends OrcSchemaWithTypeVisitor<TypeDescription> {\n-\n-    private final Set<TypeDescription> columnsInContainers;\n-\n-    private ColumnsInContainersVisitor() {\n-      columnsInContainers = Sets.newHashSet();\n-    }\n-\n-    public Set<TypeDescription> getColumnsInContainers() {\n-      return columnsInContainers;\n-    }\n-\n-    private Set<TypeDescription> flatten(TypeDescription rootType) {\n-      if (rootType == null) {\n-        return ImmutableSet.of();\n-      }\n-\n-      final Set<TypeDescription> flatTypes = Sets.newHashSetWithExpectedSize(rootType.getMaximumId());\n-      final Queue<TypeDescription> queue = Queues.newLinkedBlockingQueue();\n-      queue.add(rootType);\n-      while (!queue.isEmpty()) {\n-        TypeDescription type = queue.remove();\n-        flatTypes.add(type);\n-        queue.addAll(Optional.ofNullable(type.getChildren()).orElse(ImmutableList.of()));\n-      }\n-      return flatTypes;\n-    }\n-\n-    @Override\n-    public TypeDescription record(Types.StructType iStruct, TypeDescription record,\n-                                  List<String> names, List<TypeDescription> fields) {\n-      return record;\n-    }\n-\n-    @Override\n-    public TypeDescription list(Types.ListType iList, TypeDescription array, TypeDescription element) {\n-      columnsInContainers.addAll(flatten(element));\n-      return array;\n-    }\n-\n-    @Override\n-    public TypeDescription map(Types.MapType iMap, TypeDescription map,\n-                    TypeDescription key, TypeDescription value) {\n-      columnsInContainers.addAll(flatten(key));\n-      columnsInContainers.addAll(flatten(value));\n-      return map;\n-    }\n-\n+  private static class StatsColumnsVisitor extends OrcSchemaVisitor<Set<Integer>> {\n     @Override\n-    public TypeDescription primitive(Type.PrimitiveType iPrimitive, TypeDescription primitive) {\n-      return primitive;\n+    public Set<Integer> record(TypeDescription record, List<String> names, List<Set<Integer>> fields) {\n+      ImmutableSet.Builder<Integer> result = ImmutableSet.builder();\n+      fields.stream().filter(Objects::nonNull).forEach(result::addAll);\n+      record.getChildren().stream().map(ORCSchemaUtil::fieldId).forEach(result::add);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eadac8d5da4f7911e4734f101c8756ee12f2aea9"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ0ODg0NQ==", "bodyText": "I think so. This is called when Iceberg wrote the file, so we should be able to assume the IDs are present, right?", "url": "https://github.com/apache/iceberg/pull/1167#discussion_r450448845", "createdAt": "2020-07-06T19:59:16Z", "author": {"login": "rdblue"}, "path": "orc/src/main/java/org/apache/iceberg/orc/OrcMetrics.java", "diffHunk": "@@ -209,64 +206,17 @@ private static Metrics buildOrcMetrics(final long numOfRows, final TypeDescripti\n     return Optional.ofNullable(Conversions.toByteBuffer(column.type(), max));\n   }\n \n-  private static Set<TypeDescription> findColumnsInContainers(Schema schema,\n-                                                              TypeDescription orcSchema) {\n-    ColumnsInContainersVisitor visitor = new ColumnsInContainersVisitor();\n-    OrcSchemaWithTypeVisitor.visit(schema, orcSchema, visitor);\n-    return visitor.getColumnsInContainers();\n+  private static Set<Integer> statsColumns(TypeDescription schema) {\n+    return OrcSchemaVisitor.visit(schema, new StatsColumnsVisitor());\n   }\n \n-  private static class ColumnsInContainersVisitor extends OrcSchemaWithTypeVisitor<TypeDescription> {\n-\n-    private final Set<TypeDescription> columnsInContainers;\n-\n-    private ColumnsInContainersVisitor() {\n-      columnsInContainers = Sets.newHashSet();\n-    }\n-\n-    public Set<TypeDescription> getColumnsInContainers() {\n-      return columnsInContainers;\n-    }\n-\n-    private Set<TypeDescription> flatten(TypeDescription rootType) {\n-      if (rootType == null) {\n-        return ImmutableSet.of();\n-      }\n-\n-      final Set<TypeDescription> flatTypes = Sets.newHashSetWithExpectedSize(rootType.getMaximumId());\n-      final Queue<TypeDescription> queue = Queues.newLinkedBlockingQueue();\n-      queue.add(rootType);\n-      while (!queue.isEmpty()) {\n-        TypeDescription type = queue.remove();\n-        flatTypes.add(type);\n-        queue.addAll(Optional.ofNullable(type.getChildren()).orElse(ImmutableList.of()));\n-      }\n-      return flatTypes;\n-    }\n-\n-    @Override\n-    public TypeDescription record(Types.StructType iStruct, TypeDescription record,\n-                                  List<String> names, List<TypeDescription> fields) {\n-      return record;\n-    }\n-\n-    @Override\n-    public TypeDescription list(Types.ListType iList, TypeDescription array, TypeDescription element) {\n-      columnsInContainers.addAll(flatten(element));\n-      return array;\n-    }\n-\n-    @Override\n-    public TypeDescription map(Types.MapType iMap, TypeDescription map,\n-                    TypeDescription key, TypeDescription value) {\n-      columnsInContainers.addAll(flatten(key));\n-      columnsInContainers.addAll(flatten(value));\n-      return map;\n-    }\n-\n+  private static class StatsColumnsVisitor extends OrcSchemaVisitor<Set<Integer>> {\n     @Override\n-    public TypeDescription primitive(Type.PrimitiveType iPrimitive, TypeDescription primitive) {\n-      return primitive;\n+    public Set<Integer> record(TypeDescription record, List<String> names, List<Set<Integer>> fields) {\n+      ImmutableSet.Builder<Integer> result = ImmutableSet.builder();\n+      fields.stream().filter(Objects::nonNull).forEach(result::addAll);\n+      record.getChildren().stream().map(ORCSchemaUtil::fieldId).forEach(result::add);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk2NTU5OA=="}, "originalCommit": {"oid": "eadac8d5da4f7911e4734f101c8756ee12f2aea9"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ2MDQyOQ==", "bodyText": "If the ORC files are written by Iceberg it should be fine. I was thinking for the case of importing existing ORC files although we'd need to implement name mapping fallback strategy.", "url": "https://github.com/apache/iceberg/pull/1167#discussion_r450460429", "createdAt": "2020-07-06T20:24:37Z", "author": {"login": "edgarRd"}, "path": "orc/src/main/java/org/apache/iceberg/orc/OrcMetrics.java", "diffHunk": "@@ -209,64 +206,17 @@ private static Metrics buildOrcMetrics(final long numOfRows, final TypeDescripti\n     return Optional.ofNullable(Conversions.toByteBuffer(column.type(), max));\n   }\n \n-  private static Set<TypeDescription> findColumnsInContainers(Schema schema,\n-                                                              TypeDescription orcSchema) {\n-    ColumnsInContainersVisitor visitor = new ColumnsInContainersVisitor();\n-    OrcSchemaWithTypeVisitor.visit(schema, orcSchema, visitor);\n-    return visitor.getColumnsInContainers();\n+  private static Set<Integer> statsColumns(TypeDescription schema) {\n+    return OrcSchemaVisitor.visit(schema, new StatsColumnsVisitor());\n   }\n \n-  private static class ColumnsInContainersVisitor extends OrcSchemaWithTypeVisitor<TypeDescription> {\n-\n-    private final Set<TypeDescription> columnsInContainers;\n-\n-    private ColumnsInContainersVisitor() {\n-      columnsInContainers = Sets.newHashSet();\n-    }\n-\n-    public Set<TypeDescription> getColumnsInContainers() {\n-      return columnsInContainers;\n-    }\n-\n-    private Set<TypeDescription> flatten(TypeDescription rootType) {\n-      if (rootType == null) {\n-        return ImmutableSet.of();\n-      }\n-\n-      final Set<TypeDescription> flatTypes = Sets.newHashSetWithExpectedSize(rootType.getMaximumId());\n-      final Queue<TypeDescription> queue = Queues.newLinkedBlockingQueue();\n-      queue.add(rootType);\n-      while (!queue.isEmpty()) {\n-        TypeDescription type = queue.remove();\n-        flatTypes.add(type);\n-        queue.addAll(Optional.ofNullable(type.getChildren()).orElse(ImmutableList.of()));\n-      }\n-      return flatTypes;\n-    }\n-\n-    @Override\n-    public TypeDescription record(Types.StructType iStruct, TypeDescription record,\n-                                  List<String> names, List<TypeDescription> fields) {\n-      return record;\n-    }\n-\n-    @Override\n-    public TypeDescription list(Types.ListType iList, TypeDescription array, TypeDescription element) {\n-      columnsInContainers.addAll(flatten(element));\n-      return array;\n-    }\n-\n-    @Override\n-    public TypeDescription map(Types.MapType iMap, TypeDescription map,\n-                    TypeDescription key, TypeDescription value) {\n-      columnsInContainers.addAll(flatten(key));\n-      columnsInContainers.addAll(flatten(value));\n-      return map;\n-    }\n-\n+  private static class StatsColumnsVisitor extends OrcSchemaVisitor<Set<Integer>> {\n     @Override\n-    public TypeDescription primitive(Type.PrimitiveType iPrimitive, TypeDescription primitive) {\n-      return primitive;\n+    public Set<Integer> record(TypeDescription record, List<String> names, List<Set<Integer>> fields) {\n+      ImmutableSet.Builder<Integer> result = ImmutableSet.builder();\n+      fields.stream().filter(Objects::nonNull).forEach(result::addAll);\n+      record.getChildren().stream().map(ORCSchemaUtil::fieldId).forEach(result::add);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk2NTU5OA=="}, "originalCommit": {"oid": "eadac8d5da4f7911e4734f101c8756ee12f2aea9"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTk2MDA3Mw==", "bodyText": "I think this breaks pretty much any import of non-Iceberg ORC tables via SparkTableUtil.", "url": "https://github.com/apache/iceberg/pull/1167#discussion_r475960073", "createdAt": "2020-08-24T23:31:06Z", "author": {"login": "edgarRd"}, "path": "orc/src/main/java/org/apache/iceberg/orc/OrcMetrics.java", "diffHunk": "@@ -209,64 +206,17 @@ private static Metrics buildOrcMetrics(final long numOfRows, final TypeDescripti\n     return Optional.ofNullable(Conversions.toByteBuffer(column.type(), max));\n   }\n \n-  private static Set<TypeDescription> findColumnsInContainers(Schema schema,\n-                                                              TypeDescription orcSchema) {\n-    ColumnsInContainersVisitor visitor = new ColumnsInContainersVisitor();\n-    OrcSchemaWithTypeVisitor.visit(schema, orcSchema, visitor);\n-    return visitor.getColumnsInContainers();\n+  private static Set<Integer> statsColumns(TypeDescription schema) {\n+    return OrcSchemaVisitor.visit(schema, new StatsColumnsVisitor());\n   }\n \n-  private static class ColumnsInContainersVisitor extends OrcSchemaWithTypeVisitor<TypeDescription> {\n-\n-    private final Set<TypeDescription> columnsInContainers;\n-\n-    private ColumnsInContainersVisitor() {\n-      columnsInContainers = Sets.newHashSet();\n-    }\n-\n-    public Set<TypeDescription> getColumnsInContainers() {\n-      return columnsInContainers;\n-    }\n-\n-    private Set<TypeDescription> flatten(TypeDescription rootType) {\n-      if (rootType == null) {\n-        return ImmutableSet.of();\n-      }\n-\n-      final Set<TypeDescription> flatTypes = Sets.newHashSetWithExpectedSize(rootType.getMaximumId());\n-      final Queue<TypeDescription> queue = Queues.newLinkedBlockingQueue();\n-      queue.add(rootType);\n-      while (!queue.isEmpty()) {\n-        TypeDescription type = queue.remove();\n-        flatTypes.add(type);\n-        queue.addAll(Optional.ofNullable(type.getChildren()).orElse(ImmutableList.of()));\n-      }\n-      return flatTypes;\n-    }\n-\n-    @Override\n-    public TypeDescription record(Types.StructType iStruct, TypeDescription record,\n-                                  List<String> names, List<TypeDescription> fields) {\n-      return record;\n-    }\n-\n-    @Override\n-    public TypeDescription list(Types.ListType iList, TypeDescription array, TypeDescription element) {\n-      columnsInContainers.addAll(flatten(element));\n-      return array;\n-    }\n-\n-    @Override\n-    public TypeDescription map(Types.MapType iMap, TypeDescription map,\n-                    TypeDescription key, TypeDescription value) {\n-      columnsInContainers.addAll(flatten(key));\n-      columnsInContainers.addAll(flatten(value));\n-      return map;\n-    }\n-\n+  private static class StatsColumnsVisitor extends OrcSchemaVisitor<Set<Integer>> {\n     @Override\n-    public TypeDescription primitive(Type.PrimitiveType iPrimitive, TypeDescription primitive) {\n-      return primitive;\n+    public Set<Integer> record(TypeDescription record, List<String> names, List<Set<Integer>> fields) {\n+      ImmutableSet.Builder<Integer> result = ImmutableSet.builder();\n+      fields.stream().filter(Objects::nonNull).forEach(result::addAll);\n+      record.getChildren().stream().map(ORCSchemaUtil::fieldId).forEach(result::add);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk2NTU5OA=="}, "originalCommit": {"oid": "eadac8d5da4f7911e4734f101c8756ee12f2aea9"}, "originalPosition": 108}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3943, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}