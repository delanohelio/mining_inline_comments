{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQyMjI4MjA3", "number": 1955, "reviewThreads": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQwMToxNzozNFrOFG-eIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQxMDo0NToxOFrOFHvvBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyODU5Mjk2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/iceberg/avro/BuildAvroProjection.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQwMToxNzozNVrOIIPTWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxOTowNTozNFrOIIvOhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTUxMDIzNA==", "bodyText": "Needed to allow projecting _file even though it isn't in the data file.", "url": "https://github.com/apache/iceberg/pull/1955#discussion_r545510234", "createdAt": "2020-12-18T01:17:35Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/avro/BuildAvroProjection.java", "diffHunk": "@@ -96,7 +96,7 @@ public Schema record(Schema record, List<String> names, Iterable<Schema.Field> s\n \n       } else {\n         Preconditions.checkArgument(\n-            field.isOptional() || field.fieldId() == MetadataColumns.ROW_POSITION.fieldId(),\n+            field.isOptional() || MetadataColumns.metadataFieldIds().contains(field.fieldId()),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "934a375adbf9efca155936d63f4003f94adb070b"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAzMzI4NA==", "bodyText": "This reminds me we need to fix that projection bug / selection bug", "url": "https://github.com/apache/iceberg/pull/1955#discussion_r546033284", "createdAt": "2020-12-18T19:05:34Z", "author": {"login": "RussellSpitzer"}, "path": "core/src/main/java/org/apache/iceberg/avro/BuildAvroProjection.java", "diffHunk": "@@ -96,7 +96,7 @@ public Schema record(Schema record, List<String> names, Iterable<Schema.Field> s\n \n       } else {\n         Preconditions.checkArgument(\n-            field.isOptional() || field.fieldId() == MetadataColumns.ROW_POSITION.fieldId(),\n+            field.isOptional() || MetadataColumns.metadataFieldIds().contains(field.fieldId()),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTUxMDIzNA=="}, "originalCommit": {"oid": "934a375adbf9efca155936d63f4003f94adb070b"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyODU5Mzk1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/iceberg/util/PartitionUtil.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQwMToxODowMlrOIIPT6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQwMToxODowMlrOIIPT6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTUxMDM3Ng==", "bodyText": "This adds _file to the constants map so it is set in records like a partition value.", "url": "https://github.com/apache/iceberg/pull/1955#discussion_r545510376", "createdAt": "2020-12-18T01:18:02Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/util/PartitionUtil.java", "diffHunk": "@@ -39,13 +40,17 @@ private PartitionUtil() {\n   }\n \n   public static Map<Integer, ?> constantsMap(FileScanTask task, BiFunction<Type, Object, Object> convertConstant) {\n-    return constantsMap(task.spec(), task.file().partition(), convertConstant);\n-  }\n+    PartitionSpec spec = task.spec();\n+    StructLike partitionData = task.file().partition();\n \n-  private static Map<Integer, ?> constantsMap(PartitionSpec spec, StructLike partitionData,\n-                                              BiFunction<Type, Object, Object> convertConstant) {\n     // use java.util.HashMap because partition data may contain null values\n     Map<Integer, Object> idToConstant = new HashMap<>();\n+\n+    // add _file\n+    idToConstant.put(\n+        MetadataColumns.FILE_PATH.fieldId(),\n+        convertConstant.apply(Types.StringType.get(), task.file().path()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "934a375adbf9efca155936d63f4003f94adb070b"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyODU5ODgxOnYy", "diffSide": "RIGHT", "path": "spark3-extensions/src/main/scala/org/apache/spark/sql/catalyst/optimizer/RewriteDelete.scala", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQwMToyMDowOFrOIIPWlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQwMToyMDowOFrOIIPWlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTUxMTA2MA==", "bodyText": "Spark's contract is that the scan's schema is the one that should be used, not the original table schema. This allows the merge scan to return the extra _file and _pos columns and matches the behavior of normal scans that are configured with PushDownUtils.pruneColumns.", "url": "https://github.com/apache/iceberg/pull/1955#discussion_r545511060", "createdAt": "2020-12-18T01:20:08Z", "author": {"login": "rdblue"}, "path": "spark3-extensions/src/main/scala/org/apache/spark/sql/catalyst/optimizer/RewriteDelete.scala", "diffHunk": "@@ -77,33 +101,30 @@ object RewriteDelete extends Rule[LogicalPlan] with PredicateHelper with Logging\n     PushDownUtils.pushFilters(scanBuilder, normalizedPredicates)\n \n     val scan = scanBuilder.build()\n-    val scanRelation = DataSourceV2ScanRelation(table, scan, output)\n+    val scanRelation = DataSourceV2ScanRelation(table, scan, toOutputAttrs(scan.readSchema(), output))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "934a375adbf9efca155936d63f4003f94adb070b"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyOTg2MTE1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/iceberg/MetadataColumns.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQwOToxNTo1N1rOIIajhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQwOTo1NjoxM1rOIJShwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTY5NDU5OQ==", "bodyText": "nit: should it be isNonMetadataColumn to indicate it is a boolean flag?", "url": "https://github.com/apache/iceberg/pull/1955#discussion_r545694599", "createdAt": "2020-12-18T09:15:57Z", "author": {"login": "aokolnychyi"}, "path": "core/src/main/java/org/apache/iceberg/MetadataColumns.java", "diffHunk": "@@ -55,4 +55,16 @@ private MetadataColumns() {\n   public static Set<Integer> metadataFieldIds() {\n     return META_IDS;\n   }\n+\n+  public static NestedField get(String name) {\n+    return META_COLUMNS.get(name);\n+  }\n+\n+  public static boolean isMetadataColumn(String name) {\n+    return META_COLUMNS.containsKey(name);\n+  }\n+\n+  public static boolean nonMetadataColumn(String name) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "934a375adbf9efca155936d63f4003f94adb070b"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTk4NTQ4Ng==", "bodyText": "Yeah, we could do that. I was following the slightly shorter Scala convention, where there are methods like nonEmpty. I prefer this way, but if others agree I'm happy to change it.", "url": "https://github.com/apache/iceberg/pull/1955#discussion_r545985486", "createdAt": "2020-12-18T17:38:29Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/MetadataColumns.java", "diffHunk": "@@ -55,4 +55,16 @@ private MetadataColumns() {\n   public static Set<Integer> metadataFieldIds() {\n     return META_IDS;\n   }\n+\n+  public static NestedField get(String name) {\n+    return META_COLUMNS.get(name);\n+  }\n+\n+  public static boolean isMetadataColumn(String name) {\n+    return META_COLUMNS.containsKey(name);\n+  }\n+\n+  public static boolean nonMetadataColumn(String name) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTY5NDU5OQ=="}, "originalCommit": {"oid": "934a375adbf9efca155936d63f4003f94adb070b"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjYxMTY0OA==", "bodyText": "Let's leave it, I don't mind as long as it wasn't an oversight and there is an idea/convention being followed.", "url": "https://github.com/apache/iceberg/pull/1955#discussion_r546611648", "createdAt": "2020-12-21T09:56:13Z", "author": {"login": "aokolnychyi"}, "path": "core/src/main/java/org/apache/iceberg/MetadataColumns.java", "diffHunk": "@@ -55,4 +55,16 @@ private MetadataColumns() {\n   public static Set<Integer> metadataFieldIds() {\n     return META_IDS;\n   }\n+\n+  public static NestedField get(String name) {\n+    return META_COLUMNS.get(name);\n+  }\n+\n+  public static boolean isMetadataColumn(String name) {\n+    return META_COLUMNS.containsKey(name);\n+  }\n+\n+  public static boolean nonMetadataColumn(String name) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTY5NDU5OQ=="}, "originalCommit": {"oid": "934a375adbf9efca155936d63f4003f94adb070b"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyOTkxMDY3OnYy", "diffSide": "RIGHT", "path": "spark3-extensions/src/main/scala/org/apache/spark/sql/catalyst/optimizer/RewriteDelete.scala", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQwOToyNDoxNFrOIIbB7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQwOToyNDoxNFrOIIbB7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTcwMjM4Mg==", "bodyText": "+1", "url": "https://github.com/apache/iceberg/pull/1955#discussion_r545702382", "createdAt": "2020-12-18T09:24:14Z", "author": {"login": "aokolnychyi"}, "path": "spark3-extensions/src/main/scala/org/apache/spark/sql/catalyst/optimizer/RewriteDelete.scala", "diffHunk": "@@ -77,33 +101,30 @@ object RewriteDelete extends Rule[LogicalPlan] with PredicateHelper with Logging\n     PushDownUtils.pushFilters(scanBuilder, normalizedPredicates)\n \n     val scan = scanBuilder.build()\n-    val scanRelation = DataSourceV2ScanRelation(table, scan, output)\n+    val scanRelation = DataSourceV2ScanRelation(table, scan, toOutputAttrs(scan.readSchema(), output))\n \n     val scanPlan = scan match {\n-      case _: SupportsFileFilter =>\n+      case filterable: SupportsFileFilter =>\n         val matchingFilePlan = buildFileFilterPlan(cond, scanRelation)\n-        val dynamicFileFilter = DynamicFileFilter(scanRelation, matchingFilePlan)\n+        val dynamicFileFilter = DynamicFileFilter(ExtendedScanRelation(scanRelation), matchingFilePlan, filterable)\n         dynamicFileFilter\n       case _ =>\n         scanRelation\n     }\n \n-    // include file name so that we can group data back\n-    val fileNameExpr = Alias(InputFileName(), FILE_NAME_COL)()\n-    Project(scanPlan.output :+ fileNameExpr, scanPlan)\n+    scanPlan\n   }\n \n   private def buildWritePlan(\n       remainingRowsPlan: LogicalPlan,\n       output: Seq[AttributeReference]): LogicalPlan = {\n \n-    // TODO: sort by _pos to keep the original ordering of rows\n-    // TODO: consider setting a file size limit\n-\n     val fileNameCol = findOutputAttr(remainingRowsPlan, FILE_NAME_COL)\n+    val rowPosCol = findOutputAttr(remainingRowsPlan, ROW_POS_COL)\n+    val order = Seq(SortOrder(fileNameCol, Ascending), SortOrder(rowPosCol, Ascending))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "934a375adbf9efca155936d63f4003f94adb070b"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyOTk1NjIwOnYy", "diffSide": "RIGHT", "path": "spark3/src/main/java/org/apache/iceberg/spark/source/SparkScanBuilder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQwOTozMTowNlrOIIbc3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQwOTozMTozNVrOIIbefw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTcwOTI3OQ==", "bodyText": "Are there any cases when pruneColumns is going to be called multiple times? Should we worry about it at all?", "url": "https://github.com/apache/iceberg/pull/1955#discussion_r545709279", "createdAt": "2020-12-18T09:31:06Z", "author": {"login": "aokolnychyi"}, "path": "spark3/src/main/java/org/apache/iceberg/spark/source/SparkScanBuilder.java", "diffHunk": "@@ -131,28 +138,52 @@ public SparkScanBuilder caseSensitive(boolean isCaseSensitive) {\n \n   @Override\n   public void pruneColumns(StructType requestedSchema) {\n-    this.requestedProjection = requestedSchema;\n+    this.requestedProjection = new StructType(Stream.of(requestedSchema.fields())\n+        .filter(field -> MetadataColumns.nonMetadataColumn(field.name()))\n+        .toArray(StructField[]::new));\n+\n+    Stream.of(requestedSchema.fields())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "934a375adbf9efca155936d63f4003f94adb070b"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTcwOTY5NQ==", "bodyText": "I see we call distinct in schemaWithMetadataColumns, never mind.", "url": "https://github.com/apache/iceberg/pull/1955#discussion_r545709695", "createdAt": "2020-12-18T09:31:35Z", "author": {"login": "aokolnychyi"}, "path": "spark3/src/main/java/org/apache/iceberg/spark/source/SparkScanBuilder.java", "diffHunk": "@@ -131,28 +138,52 @@ public SparkScanBuilder caseSensitive(boolean isCaseSensitive) {\n \n   @Override\n   public void pruneColumns(StructType requestedSchema) {\n-    this.requestedProjection = requestedSchema;\n+    this.requestedProjection = new StructType(Stream.of(requestedSchema.fields())\n+        .filter(field -> MetadataColumns.nonMetadataColumn(field.name()))\n+        .toArray(StructField[]::new));\n+\n+    Stream.of(requestedSchema.fields())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTcwOTI3OQ=="}, "originalCommit": {"oid": "934a375adbf9efca155936d63f4003f94adb070b"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMDYzMzA2OnYy", "diffSide": "RIGHT", "path": "spark3-extensions/src/main/scala/org/apache/spark/sql/catalyst/plans/logical/ExtendedScanRelation.scala", "isResolved": true, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMjo0OTowNFrOIIhnEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQxOTozNToxMVrOIJjnuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTgxMDE5NQ==", "bodyText": "I am a bit worried about adding this class as I am not sure we want to maintain it in Spark later. There is another idea how to solve the rewrite rule: we can simply disable column pruning for DynamicFileFilter nodes. I think it should be sufficient to extend the node references to also cover all output attributes of the scan.\nAttributeSet(scanRelation.output ++ fileFilterPlan.output)\n\nI've submitted a PR with this idea to your branch, @rdblue. Feel free to discard/modify as needed.", "url": "https://github.com/apache/iceberg/pull/1955#discussion_r545810195", "createdAt": "2020-12-18T12:49:04Z", "author": {"login": "aokolnychyi"}, "path": "spark3-extensions/src/main/scala/org/apache/spark/sql/catalyst/plans/logical/ExtendedScanRelation.scala", "diffHunk": "@@ -0,0 +1,29 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.plans.logical\n+\n+import org.apache.spark.sql.catalyst.expressions.Attribute\n+import org.apache.spark.sql.execution.datasources.v2.DataSourceV2ScanRelation\n+\n+case class ExtendedScanRelation(relation: DataSourceV2ScanRelation) extends LogicalPlan {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "934a375adbf9efca155936d63f4003f94adb070b"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTk4NjgxNQ==", "bodyText": "I think the more general problem is that Spark couldn't rewrite DynamicFileFilter node at all, which led to some situations where the plan worked fine and some where it would fail. I think we should generally fit the pattern of being able to rewrite nodes.", "url": "https://github.com/apache/iceberg/pull/1955#discussion_r545986815", "createdAt": "2020-12-18T17:40:58Z", "author": {"login": "rdblue"}, "path": "spark3-extensions/src/main/scala/org/apache/spark/sql/catalyst/plans/logical/ExtendedScanRelation.scala", "diffHunk": "@@ -0,0 +1,29 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.plans.logical\n+\n+import org.apache.spark.sql.catalyst.expressions.Attribute\n+import org.apache.spark.sql.execution.datasources.v2.DataSourceV2ScanRelation\n+\n+case class ExtendedScanRelation(relation: DataSourceV2ScanRelation) extends LogicalPlan {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTgxMDE5NQ=="}, "originalCommit": {"oid": "934a375adbf9efca155936d63f4003f94adb070b"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjYzMzE5NA==", "bodyText": "I get the intention here now. I did a quick look and see that Spark injects the extended planner strategies before the data source V2 strategy. That got me thinking that we can get rid of this extra logical plan and just use the scan node directly and apply the new logic only if we have a scan that supports file filtering.\ncase PhysicalOperation(project, filters, DataSourceV2ScanRelation(_, scan: SupportsFileFilter, output)) =>\n  // projection and filters were already pushed down in the optimizer.\n  // this uses PhysicalOperation to get the projection and ensure that if the batch scan does\n  // not support columnar, a projection is added to convert the rows to UnsafeRow.\n  val batchExec = ExtendedBatchScanExec(output, scan)\n  withProjectAndFilter(project, filters, batchExec, !batchExec.supportsColumnar) :: Nil\n\n  ....\n\nprivate def withProjectAndFilter(\n    project: Seq[NamedExpression],\n    filters: Seq[Expression],\n    scan: LeafExecNode,\n    needsUnsafeConversion: Boolean): SparkPlan = {\n  val filterCondition = filters.reduceLeftOption(And)\n  val withFilter = filterCondition.map(FilterExec(_, scan)).getOrElse(scan)\n\n  if (withFilter.output != project || needsUnsafeConversion) {\n    ProjectExec(project, withFilter)\n  } else {\n    withFilter\n  }\n}\n\nThis also takes care of adding a projection if needed.", "url": "https://github.com/apache/iceberg/pull/1955#discussion_r546633194", "createdAt": "2020-12-21T10:40:30Z", "author": {"login": "aokolnychyi"}, "path": "spark3-extensions/src/main/scala/org/apache/spark/sql/catalyst/plans/logical/ExtendedScanRelation.scala", "diffHunk": "@@ -0,0 +1,29 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.plans.logical\n+\n+import org.apache.spark.sql.catalyst.expressions.Attribute\n+import org.apache.spark.sql.execution.datasources.v2.DataSourceV2ScanRelation\n+\n+case class ExtendedScanRelation(relation: DataSourceV2ScanRelation) extends LogicalPlan {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTgxMDE5NQ=="}, "originalCommit": {"oid": "934a375adbf9efca155936d63f4003f94adb070b"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjYzNDI2Mg==", "bodyText": "I think that's close how a native Spark solution would work.", "url": "https://github.com/apache/iceberg/pull/1955#discussion_r546634262", "createdAt": "2020-12-21T10:43:00Z", "author": {"login": "aokolnychyi"}, "path": "spark3-extensions/src/main/scala/org/apache/spark/sql/catalyst/plans/logical/ExtendedScanRelation.scala", "diffHunk": "@@ -0,0 +1,29 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.plans.logical\n+\n+import org.apache.spark.sql.catalyst.expressions.Attribute\n+import org.apache.spark.sql.execution.datasources.v2.DataSourceV2ScanRelation\n+\n+case class ExtendedScanRelation(relation: DataSourceV2ScanRelation) extends LogicalPlan {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTgxMDE5NQ=="}, "originalCommit": {"oid": "934a375adbf9efca155936d63f4003f94adb070b"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjYzNDgzMQ==", "bodyText": "There are no issues we use the same scan node in multiple places given the new logic and allowing rewrites, right?", "url": "https://github.com/apache/iceberg/pull/1955#discussion_r546634831", "createdAt": "2020-12-21T10:44:06Z", "author": {"login": "aokolnychyi"}, "path": "spark3-extensions/src/main/scala/org/apache/spark/sql/catalyst/plans/logical/ExtendedScanRelation.scala", "diffHunk": "@@ -0,0 +1,29 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.plans.logical\n+\n+import org.apache.spark.sql.catalyst.expressions.Attribute\n+import org.apache.spark.sql.execution.datasources.v2.DataSourceV2ScanRelation\n+\n+case class ExtendedScanRelation(relation: DataSourceV2ScanRelation) extends LogicalPlan {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTgxMDE5NQ=="}, "originalCommit": {"oid": "934a375adbf9efca155936d63f4003f94adb070b"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njg3MDE3NQ==", "bodyText": "Scan nodes shouldn't be reused in general, but it is usually okay if there is not a join. The problem is reused attribute IDs.", "url": "https://github.com/apache/iceberg/pull/1955#discussion_r546870175", "createdAt": "2020-12-21T18:47:19Z", "author": {"login": "rdblue"}, "path": "spark3-extensions/src/main/scala/org/apache/spark/sql/catalyst/plans/logical/ExtendedScanRelation.scala", "diffHunk": "@@ -0,0 +1,29 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.plans.logical\n+\n+import org.apache.spark.sql.catalyst.expressions.Attribute\n+import org.apache.spark.sql.execution.datasources.v2.DataSourceV2ScanRelation\n+\n+case class ExtendedScanRelation(relation: DataSourceV2ScanRelation) extends LogicalPlan {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTgxMDE5NQ=="}, "originalCommit": {"oid": "934a375adbf9efca155936d63f4003f94adb070b"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njg5MTcwNA==", "bodyText": "+1 to using this rule that gets rid of the extra node.", "url": "https://github.com/apache/iceberg/pull/1955#discussion_r546891704", "createdAt": "2020-12-21T19:35:11Z", "author": {"login": "rdblue"}, "path": "spark3-extensions/src/main/scala/org/apache/spark/sql/catalyst/plans/logical/ExtendedScanRelation.scala", "diffHunk": "@@ -0,0 +1,29 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.plans.logical\n+\n+import org.apache.spark.sql.catalyst.expressions.Attribute\n+import org.apache.spark.sql.execution.datasources.v2.DataSourceV2ScanRelation\n+\n+case class ExtendedScanRelation(relation: DataSourceV2ScanRelation) extends LogicalPlan {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTgxMDE5NQ=="}, "originalCommit": {"oid": "934a375adbf9efca155936d63f4003f94adb070b"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMjkxMjE4OnYy", "diffSide": "RIGHT", "path": "arrow/src/main/java/org/apache/iceberg/arrow/vectorized/VectorizedArrowReader.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwMDoxNDo1NVrOII20Hw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwMDoxNDo1NVrOII20Hw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE1NzU5OQ==", "bodyText": "This is needed for cases where Arrow checks the validity buffer.", "url": "https://github.com/apache/iceberg/pull/1955#discussion_r546157599", "createdAt": "2020-12-19T00:14:55Z", "author": {"login": "rdblue"}, "path": "arrow/src/main/java/org/apache/iceberg/arrow/vectorized/VectorizedArrowReader.java", "diffHunk": "@@ -381,9 +382,13 @@ public VectorHolder read(VectorHolder reuse, int numValsToRead) {\n         for (int i = 0; i < numValsToRead; i += 1) {\n           vec.getDataBuffer().setLong(i * Long.BYTES, rowStart + i);\n         }\n+        for (int i = 0; i < numValsToRead; i += 1) {\n+          BitVectorHelper.setValidityBitToOne(vec.getValidityBuffer(), i);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a87a438309f57eb83ee21178c01f8bae336b89f"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMjkxMjY0OnYy", "diffSide": "RIGHT", "path": "arrow/src/main/java/org/apache/iceberg/arrow/vectorized/VectorizedArrowReader.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwMDoxNToxNFrOII20YA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwMzozOTowNlrOII4fJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE1NzY2NA==", "bodyText": "Looks like this was an oversight in the original PR. FYI @chenjunjiedada.", "url": "https://github.com/apache/iceberg/pull/1955#discussion_r546157664", "createdAt": "2020-12-19T00:15:14Z", "author": {"login": "rdblue"}, "path": "arrow/src/main/java/org/apache/iceberg/arrow/vectorized/VectorizedArrowReader.java", "diffHunk": "@@ -381,9 +382,13 @@ public VectorHolder read(VectorHolder reuse, int numValsToRead) {\n         for (int i = 0; i < numValsToRead; i += 1) {\n           vec.getDataBuffer().setLong(i * Long.BYTES, rowStart + i);\n         }\n+        for (int i = 0; i < numValsToRead; i += 1) {\n+          BitVectorHelper.setValidityBitToOne(vec.getValidityBuffer(), i);\n+        }\n         nulls = new NullabilityHolder(numValsToRead);\n       }\n \n+      rowStart += numValsToRead;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a87a438309f57eb83ee21178c01f8bae336b89f"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE4NDk5OQ==", "bodyText": "Great catch! Let me update the unit test as well.", "url": "https://github.com/apache/iceberg/pull/1955#discussion_r546184999", "createdAt": "2020-12-19T03:39:06Z", "author": {"login": "chenjunjiedada"}, "path": "arrow/src/main/java/org/apache/iceberg/arrow/vectorized/VectorizedArrowReader.java", "diffHunk": "@@ -381,9 +382,13 @@ public VectorHolder read(VectorHolder reuse, int numValsToRead) {\n         for (int i = 0; i < numValsToRead; i += 1) {\n           vec.getDataBuffer().setLong(i * Long.BYTES, rowStart + i);\n         }\n+        for (int i = 0; i < numValsToRead; i += 1) {\n+          BitVectorHelper.setValidityBitToOne(vec.getValidityBuffer(), i);\n+        }\n         nulls = new NullabilityHolder(numValsToRead);\n       }\n \n+      rowStart += numValsToRead;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE1NzY2NA=="}, "originalCommit": {"oid": "7a87a438309f57eb83ee21178c01f8bae336b89f"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMjkxNTI3OnYy", "diffSide": "RIGHT", "path": "spark/src/main/java/org/apache/iceberg/spark/source/BatchDataReader.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwMDoxNjo1MFrOII21xw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwMDoxNjo1MFrOII21xw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE1ODAyMw==", "bodyText": "It isn't necessary to check whether there are projected ID columns. The code is shorter if the values are available by default, even if they aren't used. This fixes the problem where there are constants to add (like _file) but no identity partition values are projected.", "url": "https://github.com/apache/iceberg/pull/1955#discussion_r546158023", "createdAt": "2020-12-19T00:16:50Z", "author": {"login": "rdblue"}, "path": "spark/src/main/java/org/apache/iceberg/spark/source/BatchDataReader.java", "diffHunk": "@@ -68,18 +68,7 @@\n     // update the current file for Spark's filename() function\n     InputFileBlockHolder.set(file.path().toString(), task.start(), task.length());\n \n-    // schema or rows returned by readers\n-    PartitionSpec spec = task.spec();\n-    Set<Integer> idColumns = spec.identitySourceIds();\n-    Schema partitionSchema = TypeUtil.select(expectedSchema, idColumns);\n-    boolean projectsIdentityPartitionColumns = !partitionSchema.columns().isEmpty();\n-\n-    Map<Integer, ?> idToConstant;\n-    if (projectsIdentityPartitionColumns) {\n-      idToConstant = PartitionUtil.constantsMap(task, BatchDataReader::convertConstant);\n-    } else {\n-      idToConstant = ImmutableMap.of();\n-    }\n+    Map<Integer, ?> idToConstant = PartitionUtil.constantsMap(task, BatchDataReader::convertConstant);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a87a438309f57eb83ee21178c01f8bae336b89f"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzNjY1MzkxOnYy", "diffSide": "RIGHT", "path": "spark3-extensions/src/main/scala/org/apache/spark/sql/catalyst/optimizer/RewriteDelete.scala", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQxMDo0MjoxMFrOIJT4vQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQxODowOToxMVrOIJhR-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjYzMzkxNw==", "bodyText": "I think this block can be simplified a bit.\n    scan match {\n      case filterable: SupportsFileFilter =>\n        val matchingFilePlan = buildFileFilterPlan(cond, scanRelation)\n        DynamicFileFilter(scanRelation, matchingFilePlan, filterable)\n      case _ =>\n        scanRelation\n    }", "url": "https://github.com/apache/iceberg/pull/1955#discussion_r546633917", "createdAt": "2020-12-21T10:42:10Z", "author": {"login": "aokolnychyi"}, "path": "spark3-extensions/src/main/scala/org/apache/spark/sql/catalyst/optimizer/RewriteDelete.scala", "diffHunk": "@@ -77,33 +101,30 @@ object RewriteDelete extends Rule[LogicalPlan] with PredicateHelper with Logging\n     PushDownUtils.pushFilters(scanBuilder, normalizedPredicates)\n \n     val scan = scanBuilder.build()\n-    val scanRelation = DataSourceV2ScanRelation(table, scan, output)\n+    val scanRelation = DataSourceV2ScanRelation(table, scan, toOutputAttrs(scan.readSchema(), output))\n \n     val scanPlan = scan match {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9213621701f7061dde785e821d588f0ab9020c9"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njg1MzM3MA==", "bodyText": "Good catch. Updated.", "url": "https://github.com/apache/iceberg/pull/1955#discussion_r546853370", "createdAt": "2020-12-21T18:09:11Z", "author": {"login": "rdblue"}, "path": "spark3-extensions/src/main/scala/org/apache/spark/sql/catalyst/optimizer/RewriteDelete.scala", "diffHunk": "@@ -77,33 +101,30 @@ object RewriteDelete extends Rule[LogicalPlan] with PredicateHelper with Logging\n     PushDownUtils.pushFilters(scanBuilder, normalizedPredicates)\n \n     val scan = scanBuilder.build()\n-    val scanRelation = DataSourceV2ScanRelation(table, scan, output)\n+    val scanRelation = DataSourceV2ScanRelation(table, scan, toOutputAttrs(scan.readSchema(), output))\n \n     val scanPlan = scan match {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjYzMzkxNw=="}, "originalCommit": {"oid": "d9213621701f7061dde785e821d588f0ab9020c9"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzNjY2NDM2OnYy", "diffSide": "RIGHT", "path": "spark3-extensions/src/test/java/org/apache/iceberg/spark/extensions/SparkRowLevelOperationsTestBase.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQxMDo0NToxOFrOIJT-tg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQxNzozNzo0N1rOIJgZJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjYzNTQ0Ng==", "bodyText": "Used for local testing?", "url": "https://github.com/apache/iceberg/pull/1955#discussion_r546635446", "createdAt": "2020-12-21T10:45:18Z", "author": {"login": "aokolnychyi"}, "path": "spark3-extensions/src/test/java/org/apache/iceberg/spark/extensions/SparkRowLevelOperationsTestBase.java", "diffHunk": "@@ -48,32 +48,32 @@ public SparkRowLevelOperationsTestBase(String catalogName, String implementation\n   @Parameters(name = \"catalogName = {0}, implementation = {1}, config = {2}, format = {3}, vectorized = {4}\")\n   public static Object[][] parameters() {\n     return new Object[][] {\n-        { \"testhive\", SparkCatalog.class.getName(),\n-            ImmutableMap.of(\n-                \"type\", \"hive\",\n-                \"default-namespace\", \"default\"\n-            ),\n-            \"orc\",\n-            true\n-        },\n+//        { \"testhive\", SparkCatalog.class.getName(),\n+//            ImmutableMap.of(\n+//                \"type\", \"hive\",\n+//                \"default-namespace\", \"default\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9213621701f7061dde785e821d588f0ab9020c9"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjgzODgyMw==", "bodyText": "Yes, will remove. Sorry about that, I usually look through the PR to catch these before review!", "url": "https://github.com/apache/iceberg/pull/1955#discussion_r546838823", "createdAt": "2020-12-21T17:37:47Z", "author": {"login": "rdblue"}, "path": "spark3-extensions/src/test/java/org/apache/iceberg/spark/extensions/SparkRowLevelOperationsTestBase.java", "diffHunk": "@@ -48,32 +48,32 @@ public SparkRowLevelOperationsTestBase(String catalogName, String implementation\n   @Parameters(name = \"catalogName = {0}, implementation = {1}, config = {2}, format = {3}, vectorized = {4}\")\n   public static Object[][] parameters() {\n     return new Object[][] {\n-        { \"testhive\", SparkCatalog.class.getName(),\n-            ImmutableMap.of(\n-                \"type\", \"hive\",\n-                \"default-namespace\", \"default\"\n-            ),\n-            \"orc\",\n-            true\n-        },\n+//        { \"testhive\", SparkCatalog.class.getName(),\n+//            ImmutableMap.of(\n+//                \"type\", \"hive\",\n+//                \"default-namespace\", \"default\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjYzNTQ0Ng=="}, "originalCommit": {"oid": "d9213621701f7061dde785e821d588f0ab9020c9"}, "originalPosition": 15}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3066, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}