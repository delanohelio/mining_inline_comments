{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg4MzM5NTE5", "number": 1469, "title": "Add position delete validation that data files have not been deleted", "bodyText": "This adds a new validations to the RowDelta operation.\nThis includes some small cleanup by adding a validate method to SnapshotProducer to run validations and updating existing operations to use it.\nOne new validation for RowDelta finds data files that have been deleted since a starting \"from\" snapshot and validates that the set of referenced data files does not intersect the deleted data file set. Configuration uses 3 methods:\n\nRowDelta.validateFromSnapshot(id) to set the starting snapshot ID for accumulating deleted files\nRowDelta.validateDataFilesExist(Iterable) to add required data files to the validation\nRowDelta.validateDeletedFiles() to validate data files were not deleted by concurrent deletes (rewrite/overwrite is the default)\n\nThe second new validation tests that no new files have been added since a starting \"from\" snapshot that match a data filter. This is the same validation that is already in BaseOverwriteFiles. Configuration uses 2 methods:\n\nRowDelta.validateFromSnapshot(id) to set the starting snapshot ID for accumulating deleted files\nRowDelta.validateNoConflictingAppends(Expression, boolean caseSensitive) to set a conflict detection filter\n\nBaseOverwriteFiles has been updated to match the configuration used here: the caseSensitive flag has been added and the \"from\" snapshot setting has been moved to use validateFromSnapshot(id). The older version of validateNoConflictingAppends shows how to use the new configuration and is now deprecated.\nThis also adds PositionDeleteWriter.referencedDataFiles to return data files that should be validated.", "createdAt": "2020-09-17T01:02:32Z", "url": "https://github.com/apache/iceberg/pull/1469", "merged": true, "mergeCommit": {"oid": "d4dcadb3a74d4552f85fa6c99637f86a0b763426"}, "closed": true, "closedAt": "2020-10-07T16:35:44Z", "author": {"login": "rdblue"}, "timelineItems": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdKA9e5AFqTQ5MTIzODE2NA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdQDLSWAFqTUwMzQ3NDc4NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkxMjM4MTY0", "url": "https://github.com/apache/iceberg/pull/1469#pullrequestreview-491238164", "createdAt": "2020-09-18T08:03:38Z", "commit": {"oid": "7d456a3466a818f1331884ee602b5166f6dd47bf"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fd29c76217c15a36f3260faed9f8c6163dea3295", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/fd29c76217c15a36f3260faed9f8c6163dea3295", "committedDate": "2020-09-19T01:32:28Z", "message": "Fix checkstyle."}, "afterCommit": {"oid": "d1a5890eca9515d35087ea3588738ddbd2174010", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/d1a5890eca9515d35087ea3588738ddbd2174010", "committedDate": "2020-10-02T20:31:32Z", "message": "Fix Spark tests."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyMTg1OTY5", "url": "https://github.com/apache/iceberg/pull/1469#pullrequestreview-502185969", "createdAt": "2020-10-05T15:41:59Z", "commit": {"oid": "7a6c371b00fa8661cc4f268090f9ef690b12db4f"}, "state": "COMMENTED", "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNTo0MTo1OVrOHci8WA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNjoyNToxN1rOHckqWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY5NDY4MA==", "bodyText": "What should be our long-term strategy for handling case sensitivity in APIs like this? The current way is not consistent and we use default values in a lot of cases. There are two methods in this API that accept expressions. Does it mean that each of them will have an extra parameter? Will it make sense to expose a method in a parent class/interface that would configure case sensitivity for all methods?", "url": "https://github.com/apache/iceberg/pull/1469#discussion_r499694680", "createdAt": "2020-10-05T15:41:59Z", "author": {"login": "aokolnychyi"}, "path": "api/src/main/java/org/apache/iceberg/OverwriteFiles.java", "diffHunk": "@@ -87,6 +87,36 @@\n    */\n   OverwriteFiles validateAddedFilesMatchOverwriteFilter();\n \n+  /**\n+   * Set the snapshot ID used in any reads for this operation.\n+   * <p>\n+   * Validations will check changes after this snapshot ID.\n+   *\n+   * @param snapshotId a snapshot ID\n+   * @return this for method chaining\n+   */\n+  OverwriteFiles validateFromSnapshot(long snapshotId);\n+\n+  /**\n+   * Enables validation that files added concurrently do not conflict with this commit's operation.\n+   * <p>\n+   * This method should be called when the table is queried to determine which files to delete/append.\n+   * If a concurrent operation commits a new file after the data was read and that file might\n+   * contain rows matching the specified conflict detection filter, the overwrite operation\n+   * will detect this during retries and fail.\n+   * <p>\n+   * Calling this method with a correct conflict detection filter is required to maintain\n+   * serializable isolation for eager update/delete operations. Otherwise, the isolation level\n+   * will be snapshot isolation.\n+   * <p>\n+   * Validation applies to files added to the table since the snapshot passed to {@link #validateFromSnapshot(long)}.\n+   *\n+   * @param conflictDetectionFilter an expression on rows in the table\n+   * @param isCaseSensitive whether conflict detection filter evaluation should be case sensitive\n+   * @return this for method chaining\n+   */\n+  OverwriteFiles validateNoConflictingAppends(Expression conflictDetectionFilter, boolean isCaseSensitive);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a6c371b00fa8661cc4f268090f9ef690b12db4f"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY5Nzc2Mw==", "bodyText": "Should we document what happens if the user calls validateNoConflictingAppends without this one? Will we validate each snapshot in the table?", "url": "https://github.com/apache/iceberg/pull/1469#discussion_r499697763", "createdAt": "2020-10-05T15:46:36Z", "author": {"login": "aokolnychyi"}, "path": "api/src/main/java/org/apache/iceberg/OverwriteFiles.java", "diffHunk": "@@ -87,6 +87,36 @@\n    */\n   OverwriteFiles validateAddedFilesMatchOverwriteFilter();\n \n+  /**\n+   * Set the snapshot ID used in any reads for this operation.\n+   * <p>\n+   * Validations will check changes after this snapshot ID.\n+   *\n+   * @param snapshotId a snapshot ID\n+   * @return this for method chaining\n+   */\n+  OverwriteFiles validateFromSnapshot(long snapshotId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a6c371b00fa8661cc4f268090f9ef690b12db4f"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY5ODQwMA==", "bodyText": "Here as well.", "url": "https://github.com/apache/iceberg/pull/1469#discussion_r499698400", "createdAt": "2020-10-05T15:47:34Z", "author": {"login": "aokolnychyi"}, "path": "api/src/main/java/org/apache/iceberg/RowDelta.java", "diffHunk": "@@ -44,4 +46,61 @@\n    * @return this for method chaining\n    */\n   RowDelta addDeletes(DeleteFile deletes);\n+\n+  /**\n+   * Set the snapshot ID used in any reads for this operation.\n+   * <p>\n+   * Validations will check changes after this snapshot ID.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a6c371b00fa8661cc4f268090f9ef690b12db4f"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcwMTIzNQ==", "bodyText": "Can currentSnapshot be null if we start on an empty table?", "url": "https://github.com/apache/iceberg/pull/1469#discussion_r499701235", "createdAt": "2020-10-05T15:51:43Z", "author": {"login": "aokolnychyi"}, "path": "core/src/main/java/org/apache/iceberg/MergingSnapshotProducer.java", "diffHunk": "@@ -202,6 +207,58 @@ private ManifestFile copyManifest(ManifestFile manifest) {\n         current.formatVersion(), toCopy, current.specsById(), newManifestPath, snapshotId(), appendedManifestsSummary);\n   }\n \n+  /**\n+   * Validates that no files matching a filter have been added to the table since a starting snapshot.\n+   *\n+   * @param base table metadata to validate\n+   * @param startingSnapshotId id of the snapshot current at the start of the operation\n+   * @param conflictDetectionFilter an expression used to find new conflicting data files\n+   * @param caseSensitive whether expression evaluation should be case sensitive\n+   */\n+  protected void validateAddedDataFiles(TableMetadata base, Long startingSnapshotId,\n+                                        Expression conflictDetectionFilter, boolean caseSensitive) {\n+    List<ManifestFile> manifests = Lists.newArrayList();\n+    Set<Long> newSnapshots = Sets.newHashSet();\n+\n+    Long currentSnapshotId = base.currentSnapshot().snapshotId();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a6c371b00fa8661cc4f268090f9ef690b12db4f"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcwMjY5OQ==", "bodyText": "Not something we have to address in this PR but I've created #1547 recently. I think we should ignore rewrite snapshots during this validation.", "url": "https://github.com/apache/iceberg/pull/1469#discussion_r499702699", "createdAt": "2020-10-05T15:53:57Z", "author": {"login": "aokolnychyi"}, "path": "core/src/main/java/org/apache/iceberg/MergingSnapshotProducer.java", "diffHunk": "@@ -202,6 +207,58 @@ private ManifestFile copyManifest(ManifestFile manifest) {\n         current.formatVersion(), toCopy, current.specsById(), newManifestPath, snapshotId(), appendedManifestsSummary);\n   }\n \n+  /**\n+   * Validates that no files matching a filter have been added to the table since a starting snapshot.\n+   *\n+   * @param base table metadata to validate\n+   * @param startingSnapshotId id of the snapshot current at the start of the operation\n+   * @param conflictDetectionFilter an expression used to find new conflicting data files\n+   * @param caseSensitive whether expression evaluation should be case sensitive\n+   */\n+  protected void validateAddedDataFiles(TableMetadata base, Long startingSnapshotId,\n+                                        Expression conflictDetectionFilter, boolean caseSensitive) {\n+    List<ManifestFile> manifests = Lists.newArrayList();\n+    Set<Long> newSnapshots = Sets.newHashSet();\n+\n+    Long currentSnapshotId = base.currentSnapshot().snapshotId();\n+    while (currentSnapshotId != null && !currentSnapshotId.equals(startingSnapshotId)) {\n+      Snapshot currentSnapshot = ops.current().snapshot(currentSnapshotId);\n+\n+      ValidationException.check(currentSnapshot != null,\n+          \"Cannot determine history between starting snapshot %s and current %s\",\n+          startingSnapshotId, currentSnapshotId);\n+\n+      newSnapshots.add(currentSnapshotId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a6c371b00fa8661cc4f268090f9ef690b12db4f"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcwNjg4Mw==", "bodyText": "Do we switch to ManifestGroup instead of Snapshot$addedFiles to avoid caching added files in memory?", "url": "https://github.com/apache/iceberg/pull/1469#discussion_r499706883", "createdAt": "2020-10-05T16:00:04Z", "author": {"login": "aokolnychyi"}, "path": "core/src/main/java/org/apache/iceberg/MergingSnapshotProducer.java", "diffHunk": "@@ -202,6 +207,58 @@ private ManifestFile copyManifest(ManifestFile manifest) {\n         current.formatVersion(), toCopy, current.specsById(), newManifestPath, snapshotId(), appendedManifestsSummary);\n   }\n \n+  /**\n+   * Validates that no files matching a filter have been added to the table since a starting snapshot.\n+   *\n+   * @param base table metadata to validate\n+   * @param startingSnapshotId id of the snapshot current at the start of the operation\n+   * @param conflictDetectionFilter an expression used to find new conflicting data files\n+   * @param caseSensitive whether expression evaluation should be case sensitive\n+   */\n+  protected void validateAddedDataFiles(TableMetadata base, Long startingSnapshotId,\n+                                        Expression conflictDetectionFilter, boolean caseSensitive) {\n+    List<ManifestFile> manifests = Lists.newArrayList();\n+    Set<Long> newSnapshots = Sets.newHashSet();\n+\n+    Long currentSnapshotId = base.currentSnapshot().snapshotId();\n+    while (currentSnapshotId != null && !currentSnapshotId.equals(startingSnapshotId)) {\n+      Snapshot currentSnapshot = ops.current().snapshot(currentSnapshotId);\n+\n+      ValidationException.check(currentSnapshot != null,\n+          \"Cannot determine history between starting snapshot %s and current %s\",\n+          startingSnapshotId, currentSnapshotId);\n+\n+      newSnapshots.add(currentSnapshotId);\n+      for (ManifestFile manifest : currentSnapshot.dataManifests()) {\n+        if (manifest.snapshotId() == (long) currentSnapshotId) {\n+          manifests.add(manifest);\n+        }\n+      }\n+\n+      currentSnapshotId = currentSnapshot.parentId();\n+    }\n+\n+    ManifestGroup conflictGroup = new ManifestGroup(ops.io(), manifests, ImmutableList.of())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a6c371b00fa8661cc4f268090f9ef690b12db4f"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcwODI5Mw==", "bodyText": "Do we expect the number of manifests to be small enough so that we won't have to parallelize this?", "url": "https://github.com/apache/iceberg/pull/1469#discussion_r499708293", "createdAt": "2020-10-05T16:02:03Z", "author": {"login": "aokolnychyi"}, "path": "core/src/main/java/org/apache/iceberg/MergingSnapshotProducer.java", "diffHunk": "@@ -202,6 +207,58 @@ private ManifestFile copyManifest(ManifestFile manifest) {\n         current.formatVersion(), toCopy, current.specsById(), newManifestPath, snapshotId(), appendedManifestsSummary);\n   }\n \n+  /**\n+   * Validates that no files matching a filter have been added to the table since a starting snapshot.\n+   *\n+   * @param base table metadata to validate\n+   * @param startingSnapshotId id of the snapshot current at the start of the operation\n+   * @param conflictDetectionFilter an expression used to find new conflicting data files\n+   * @param caseSensitive whether expression evaluation should be case sensitive\n+   */\n+  protected void validateAddedDataFiles(TableMetadata base, Long startingSnapshotId,\n+                                        Expression conflictDetectionFilter, boolean caseSensitive) {\n+    List<ManifestFile> manifests = Lists.newArrayList();\n+    Set<Long> newSnapshots = Sets.newHashSet();\n+\n+    Long currentSnapshotId = base.currentSnapshot().snapshotId();\n+    while (currentSnapshotId != null && !currentSnapshotId.equals(startingSnapshotId)) {\n+      Snapshot currentSnapshot = ops.current().snapshot(currentSnapshotId);\n+\n+      ValidationException.check(currentSnapshot != null,\n+          \"Cannot determine history between starting snapshot %s and current %s\",\n+          startingSnapshotId, currentSnapshotId);\n+\n+      newSnapshots.add(currentSnapshotId);\n+      for (ManifestFile manifest : currentSnapshot.dataManifests()) {\n+        if (manifest.snapshotId() == (long) currentSnapshotId) {\n+          manifests.add(manifest);\n+        }\n+      }\n+\n+      currentSnapshotId = currentSnapshot.parentId();\n+    }\n+\n+    ManifestGroup conflictGroup = new ManifestGroup(ops.io(), manifests, ImmutableList.of())\n+        .caseSensitive(caseSensitive)\n+        .filterManifestEntries(entry -> newSnapshots.contains(entry.snapshotId()))\n+        .filterData(conflictDetectionFilter)\n+        .specsById(base.specsById())\n+        .ignoreDeleted()\n+        .ignoreExisting();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a6c371b00fa8661cc4f268090f9ef690b12db4f"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcwOTIzMw==", "bodyText": "It probably should be small if we ignore rewrite snapshots that may include metadata rewrites.", "url": "https://github.com/apache/iceberg/pull/1469#discussion_r499709233", "createdAt": "2020-10-05T16:03:34Z", "author": {"login": "aokolnychyi"}, "path": "core/src/main/java/org/apache/iceberg/MergingSnapshotProducer.java", "diffHunk": "@@ -202,6 +207,58 @@ private ManifestFile copyManifest(ManifestFile manifest) {\n         current.formatVersion(), toCopy, current.specsById(), newManifestPath, snapshotId(), appendedManifestsSummary);\n   }\n \n+  /**\n+   * Validates that no files matching a filter have been added to the table since a starting snapshot.\n+   *\n+   * @param base table metadata to validate\n+   * @param startingSnapshotId id of the snapshot current at the start of the operation\n+   * @param conflictDetectionFilter an expression used to find new conflicting data files\n+   * @param caseSensitive whether expression evaluation should be case sensitive\n+   */\n+  protected void validateAddedDataFiles(TableMetadata base, Long startingSnapshotId,\n+                                        Expression conflictDetectionFilter, boolean caseSensitive) {\n+    List<ManifestFile> manifests = Lists.newArrayList();\n+    Set<Long> newSnapshots = Sets.newHashSet();\n+\n+    Long currentSnapshotId = base.currentSnapshot().snapshotId();\n+    while (currentSnapshotId != null && !currentSnapshotId.equals(startingSnapshotId)) {\n+      Snapshot currentSnapshot = ops.current().snapshot(currentSnapshotId);\n+\n+      ValidationException.check(currentSnapshot != null,\n+          \"Cannot determine history between starting snapshot %s and current %s\",\n+          startingSnapshotId, currentSnapshotId);\n+\n+      newSnapshots.add(currentSnapshotId);\n+      for (ManifestFile manifest : currentSnapshot.dataManifests()) {\n+        if (manifest.snapshotId() == (long) currentSnapshotId) {\n+          manifests.add(manifest);\n+        }\n+      }\n+\n+      currentSnapshotId = currentSnapshot.parentId();\n+    }\n+\n+    ManifestGroup conflictGroup = new ManifestGroup(ops.io(), manifests, ImmutableList.of())\n+        .caseSensitive(caseSensitive)\n+        .filterManifestEntries(entry -> newSnapshots.contains(entry.snapshotId()))\n+        .filterData(conflictDetectionFilter)\n+        .specsById(base.specsById())\n+        .ignoreDeleted()\n+        .ignoreExisting();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcwODI5Mw=="}, "originalCommit": {"oid": "7a6c371b00fa8661cc4f268090f9ef690b12db4f"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcxMjExMw==", "bodyText": "We mean Transaction in Iceberg here?", "url": "https://github.com/apache/iceberg/pull/1469#discussion_r499712113", "createdAt": "2020-10-05T16:08:09Z", "author": {"login": "aokolnychyi"}, "path": "api/src/main/java/org/apache/iceberg/RowDelta.java", "diffHunk": "@@ -44,4 +46,61 @@\n    * @return this for method chaining\n    */\n   RowDelta addDeletes(DeleteFile deletes);\n+\n+  /**\n+   * Set the snapshot ID used in any reads for this operation.\n+   * <p>\n+   * Validations will check changes after this snapshot ID.\n+   *\n+   * @param snapshotId a snapshot ID\n+   * @return this for method chaining\n+   */\n+  RowDelta validateFromSnapshot(long snapshotId);\n+\n+  /**\n+   * Add data file paths that must not be removed by conflicting commits for this RowDelta to succeed.\n+   * <p>\n+   * If any path has been removed by a conflicting commit in the table since the snapshot passed to\n+   * {@link #validateFromSnapshot(long)}, the operation will fail with a\n+   * {@link org.apache.iceberg.exceptions.ValidationException}.\n+   * <p>\n+   * By default, this validation checks only rewrite and overwrite commits. To apply validation to delete commits, call\n+   * {@link #validateDeletedFiles()}.\n+   *\n+   * @param referencedFiles file paths that are referenced by a position delete file\n+   * @return this for method chaining\n+   */\n+  RowDelta validateDataFilesExist(Iterable<? extends CharSequence> referencedFiles);\n+\n+  /**\n+   * Enable validation that referenced data files passed to {@link #validateDataFilesExist(Iterable)} have not been\n+   * removed by a delete operation.\n+   * <p>\n+   * If a data file has a row deleted using a position delete file, rewriting or overwriting the data file concurrently", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a6c371b00fa8661cc4f268090f9ef690b12db4f"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcxMjkzMQ==", "bodyText": "eager?", "url": "https://github.com/apache/iceberg/pull/1469#discussion_r499712931", "createdAt": "2020-10-05T16:09:27Z", "author": {"login": "aokolnychyi"}, "path": "api/src/main/java/org/apache/iceberg/RowDelta.java", "diffHunk": "@@ -44,4 +46,61 @@\n    * @return this for method chaining\n    */\n   RowDelta addDeletes(DeleteFile deletes);\n+\n+  /**\n+   * Set the snapshot ID used in any reads for this operation.\n+   * <p>\n+   * Validations will check changes after this snapshot ID.\n+   *\n+   * @param snapshotId a snapshot ID\n+   * @return this for method chaining\n+   */\n+  RowDelta validateFromSnapshot(long snapshotId);\n+\n+  /**\n+   * Add data file paths that must not be removed by conflicting commits for this RowDelta to succeed.\n+   * <p>\n+   * If any path has been removed by a conflicting commit in the table since the snapshot passed to\n+   * {@link #validateFromSnapshot(long)}, the operation will fail with a\n+   * {@link org.apache.iceberg.exceptions.ValidationException}.\n+   * <p>\n+   * By default, this validation checks only rewrite and overwrite commits. To apply validation to delete commits, call\n+   * {@link #validateDeletedFiles()}.\n+   *\n+   * @param referencedFiles file paths that are referenced by a position delete file\n+   * @return this for method chaining\n+   */\n+  RowDelta validateDataFilesExist(Iterable<? extends CharSequence> referencedFiles);\n+\n+  /**\n+   * Enable validation that referenced data files passed to {@link #validateDataFilesExist(Iterable)} have not been\n+   * removed by a delete operation.\n+   * <p>\n+   * If a data file has a row deleted using a position delete file, rewriting or overwriting the data file concurrently\n+   * would un-delete the row. Deleting the data file is normally allowed, but a delete may be part of a transaction\n+   * that reads and re-appends a row. This method is used to validate deletes for the transaction case.\n+   *\n+   * @return this for method chaining\n+   */\n+  RowDelta validateDeletedFiles();\n+\n+  /**\n+   * Enables validation that files added concurrently do not conflict with this commit's operation.\n+   * <p>\n+   * This method should be called when the table is queried to determine which files to delete/append.\n+   * If a concurrent operation commits a new file after the data was read and that file might\n+   * contain rows matching the specified conflict detection filter, the overwrite operation\n+   * will detect this during retries and fail.\n+   * <p>\n+   * Calling this method with a correct conflict detection filter is required to maintain\n+   * serializable isolation for eager update/delete operations. Otherwise, the isolation level", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a6c371b00fa8661cc4f268090f9ef690b12db4f"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcxMzYyMw==", "bodyText": "I think we validate this one level above.", "url": "https://github.com/apache/iceberg/pull/1469#discussion_r499713623", "createdAt": "2020-10-05T16:10:35Z", "author": {"login": "aokolnychyi"}, "path": "core/src/main/java/org/apache/iceberg/MergingSnapshotProducer.java", "diffHunk": "@@ -202,6 +207,58 @@ private ManifestFile copyManifest(ManifestFile manifest) {\n         current.formatVersion(), toCopy, current.specsById(), newManifestPath, snapshotId(), appendedManifestsSummary);\n   }\n \n+  /**\n+   * Validates that no files matching a filter have been added to the table since a starting snapshot.\n+   *\n+   * @param base table metadata to validate\n+   * @param startingSnapshotId id of the snapshot current at the start of the operation\n+   * @param conflictDetectionFilter an expression used to find new conflicting data files\n+   * @param caseSensitive whether expression evaluation should be case sensitive\n+   */\n+  protected void validateAddedDataFiles(TableMetadata base, Long startingSnapshotId,\n+                                        Expression conflictDetectionFilter, boolean caseSensitive) {\n+    List<ManifestFile> manifests = Lists.newArrayList();\n+    Set<Long> newSnapshots = Sets.newHashSet();\n+\n+    Long currentSnapshotId = base.currentSnapshot().snapshotId();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcwMTIzNQ=="}, "originalCommit": {"oid": "7a6c371b00fa8661cc4f268090f9ef690b12db4f"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcxNDIzNg==", "bodyText": "Is this public on purpose?", "url": "https://github.com/apache/iceberg/pull/1469#discussion_r499714236", "createdAt": "2020-10-05T16:11:32Z", "author": {"login": "aokolnychyi"}, "path": "core/src/main/java/org/apache/iceberg/BaseRowDelta.java", "diffHunk": "@@ -45,4 +62,80 @@ public RowDelta addDeletes(DeleteFile deletes) {\n     add(deletes);\n     return this;\n   }\n+\n+  @Override\n+  public RowDelta validateFromSnapshot(long snapshotId) {\n+    this.startingSnapshotId = snapshotId;\n+    return this;\n+  }\n+\n+  @Override\n+  public RowDelta validateDeletedFiles() {\n+    return validateDeletedFiles(true);\n+  }\n+\n+  public RowDelta validateDeletedFiles(boolean shouldValidate) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a6c371b00fa8661cc4f268090f9ef690b12db4f"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcxOTM0MA==", "bodyText": "Do we expect only file names in this API? Would it make sense to accept DataFIles in the future? So that we can filter out manifests based on the partition info as we do in ManifestFilterManager?", "url": "https://github.com/apache/iceberg/pull/1469#discussion_r499719340", "createdAt": "2020-10-05T16:19:35Z", "author": {"login": "aokolnychyi"}, "path": "core/src/main/java/org/apache/iceberg/BaseRowDelta.java", "diffHunk": "@@ -45,4 +62,80 @@ public RowDelta addDeletes(DeleteFile deletes) {\n     add(deletes);\n     return this;\n   }\n+\n+  @Override\n+  public RowDelta validateFromSnapshot(long snapshotId) {\n+    this.startingSnapshotId = snapshotId;\n+    return this;\n+  }\n+\n+  @Override\n+  public RowDelta validateDeletedFiles() {\n+    return validateDeletedFiles(true);\n+  }\n+\n+  public RowDelta validateDeletedFiles(boolean shouldValidate) {\n+    this.validateDeletes = shouldValidate;\n+    return this;\n+  }\n+\n+  @Override\n+  public RowDelta validateDataFilesExist(Iterable<? extends CharSequence> referencedFiles) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a6c371b00fa8661cc4f268090f9ef690b12db4f"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcyMjg0Mw==", "bodyText": "I see that we use Snapshot$deletedFiles for row deltas. Why?", "url": "https://github.com/apache/iceberg/pull/1469#discussion_r499722843", "createdAt": "2020-10-05T16:25:17Z", "author": {"login": "aokolnychyi"}, "path": "core/src/main/java/org/apache/iceberg/MergingSnapshotProducer.java", "diffHunk": "@@ -202,6 +207,58 @@ private ManifestFile copyManifest(ManifestFile manifest) {\n         current.formatVersion(), toCopy, current.specsById(), newManifestPath, snapshotId(), appendedManifestsSummary);\n   }\n \n+  /**\n+   * Validates that no files matching a filter have been added to the table since a starting snapshot.\n+   *\n+   * @param base table metadata to validate\n+   * @param startingSnapshotId id of the snapshot current at the start of the operation\n+   * @param conflictDetectionFilter an expression used to find new conflicting data files\n+   * @param caseSensitive whether expression evaluation should be case sensitive\n+   */\n+  protected void validateAddedDataFiles(TableMetadata base, Long startingSnapshotId,\n+                                        Expression conflictDetectionFilter, boolean caseSensitive) {\n+    List<ManifestFile> manifests = Lists.newArrayList();\n+    Set<Long> newSnapshots = Sets.newHashSet();\n+\n+    Long currentSnapshotId = base.currentSnapshot().snapshotId();\n+    while (currentSnapshotId != null && !currentSnapshotId.equals(startingSnapshotId)) {\n+      Snapshot currentSnapshot = ops.current().snapshot(currentSnapshotId);\n+\n+      ValidationException.check(currentSnapshot != null,\n+          \"Cannot determine history between starting snapshot %s and current %s\",\n+          startingSnapshotId, currentSnapshotId);\n+\n+      newSnapshots.add(currentSnapshotId);\n+      for (ManifestFile manifest : currentSnapshot.dataManifests()) {\n+        if (manifest.snapshotId() == (long) currentSnapshotId) {\n+          manifests.add(manifest);\n+        }\n+      }\n+\n+      currentSnapshotId = currentSnapshot.parentId();\n+    }\n+\n+    ManifestGroup conflictGroup = new ManifestGroup(ops.io(), manifests, ImmutableList.of())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcwNjg4Mw=="}, "originalCommit": {"oid": "7a6c371b00fa8661cc4f268090f9ef690b12db4f"}, "originalPosition": 61}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "19e66f23bfff839f4b5b447057c50eb0b5737b92", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/19e66f23bfff839f4b5b447057c50eb0b5737b92", "committedDate": "2020-10-06T01:04:24Z", "message": "Add position delete validation that data files have not been deleted."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c4c04c7c4ca7ed51dae87541c7a59bd352e550b5", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/c4c04c7c4ca7ed51dae87541c7a59bd352e550b5", "committedDate": "2020-10-06T01:04:24Z", "message": "Fix checkstyle."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "feda7fa43ae96391ba7cd965539d88c162277771", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/feda7fa43ae96391ba7cd965539d88c162277771", "committedDate": "2020-10-06T01:04:24Z", "message": "Current work."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2d375c03058667ae60b91f70f20c8ad893694e75", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/2d375c03058667ae60b91f70f20c8ad893694e75", "committedDate": "2020-10-06T01:04:53Z", "message": "Fix Spark tests."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "77afad94c8f555295b66ccf06785efdeefe185f1", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/77afad94c8f555295b66ccf06785efdeefe185f1", "committedDate": "2020-10-06T01:04:53Z", "message": "Fix checkstyle."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "037ad66fa39d938367245207a91daf1f8f817c1d", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/037ad66fa39d938367245207a91daf1f8f817c1d", "committedDate": "2020-10-06T01:04:53Z", "message": "Add validateDeletedFiles to check delete operations."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d87e1d7dbca904bb03d48ededbcebcc83a3c77c9", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/d87e1d7dbca904bb03d48ededbcebcc83a3c77c9", "committedDate": "2020-10-06T01:04:53Z", "message": "Implement added file conflict validation."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1e8efdaec1c3a95fa223027f925d868cafa3fdd7", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/1e8efdaec1c3a95fa223027f925d868cafa3fdd7", "committedDate": "2020-10-06T01:04:53Z", "message": "Remove unused io."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bc74cf73014399bcf9857aa21fb4a9fed4867404", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/bc74cf73014399bcf9857aa21fb4a9fed4867404", "committedDate": "2020-10-06T01:04:53Z", "message": "Fix issues caught by the review."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7a6c371b00fa8661cc4f268090f9ef690b12db4f", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/7a6c371b00fa8661cc4f268090f9ef690b12db4f", "committedDate": "2020-10-03T01:01:04Z", "message": "Remove unused io."}, "afterCommit": {"oid": "bc74cf73014399bcf9857aa21fb4a9fed4867404", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/bc74cf73014399bcf9857aa21fb4a9fed4867404", "committedDate": "2020-10-06T01:04:53Z", "message": "Fix issues caught by the review."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ef5941004118d2caac865d381069b681afb365e4", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/ef5941004118d2caac865d381069b681afb365e4", "committedDate": "2020-10-06T01:28:56Z", "message": "Use ManifestGroup to validate required data files."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "97c52221d735e218356745f3f9d86a4b708245eb", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/97c52221d735e218356745f3f9d86a4b708245eb", "committedDate": "2020-10-06T02:40:24Z", "message": "Fix unused imports."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d552ce4d88fbef8348e9e9d78714aec436b4056e", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/d552ce4d88fbef8348e9e9d78714aec436b4056e", "committedDate": "2020-10-06T16:37:35Z", "message": "Fix Guava import in TestRowDelta."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAzNDc0Nzg0", "url": "https://github.com/apache/iceberg/pull/1469#pullrequestreview-503474784", "createdAt": "2020-10-07T02:02:04Z", "commit": {"oid": "d552ce4d88fbef8348e9e9d78714aec436b4056e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4216, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}