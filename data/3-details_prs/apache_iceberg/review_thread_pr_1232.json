{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU1NDY3NDUw", "number": 1232, "reviewThreads": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQwMTowMjoxOFrOETDhRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMDo0NDozNlrOEVkg8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4NDE2MDcwOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/iceberg/avro/AvroWithPartnerByStructureVisitor.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQwMTowMjoxOFrOG4k5Cw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQwMTowMjoxOFrOG4k5Cw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk3Nzg2Nw==", "bodyText": "I think this PR needs to be rebased now that #1235 is in, right?", "url": "https://github.com/apache/iceberg/pull/1232#discussion_r461977867", "createdAt": "2020-07-29T01:02:18Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/avro/AvroWithPartnerByStructureVisitor.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.avro;\n+\n+import java.util.Deque;\n+import java.util.List;\n+import org.apache.avro.Schema;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.util.Pair;\n+\n+/**\n+ * A abstract avro schema visitor with partner type. The visitor rely on the structure matching exactly and are\n+ * guaranteed that because both schemas are derived from the same Iceberg schema.\n+ *\n+ * @param <P> Partner type.\n+ * @param <T> Return T.\n+ */\n+public abstract class AvroWithPartnerByStructureVisitor<P, T> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50d3b8881f3330775510e1131830071480e9a710"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4NDE2ODA4OnYy", "diffSide": "RIGHT", "path": "flink/src/main/java/org/apache/iceberg/flink/data/FlinkValueReaders.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQwMTowNjozOVrOG4k9Wg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQwMTowNjozOVrOG4k9Wg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk3ODk3MA==", "bodyText": "Nit: indentation is off.", "url": "https://github.com/apache/iceberg/pull/1232#discussion_r461978970", "createdAt": "2020-07-29T01:06:39Z", "author": {"login": "rdblue"}, "path": "flink/src/main/java/org/apache/iceberg/flink/data/FlinkValueReaders.java", "diffHunk": "@@ -0,0 +1,314 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink.data;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.avro.io.Decoder;\n+import org.apache.avro.util.Utf8;\n+import org.apache.flink.table.data.ArrayData;\n+import org.apache.flink.table.data.DecimalData;\n+import org.apache.flink.table.data.GenericArrayData;\n+import org.apache.flink.table.data.GenericMapData;\n+import org.apache.flink.table.data.GenericRowData;\n+import org.apache.flink.table.data.MapData;\n+import org.apache.flink.table.data.RowData;\n+import org.apache.flink.table.data.StringData;\n+import org.apache.flink.table.data.TimestampData;\n+import org.apache.iceberg.avro.ValueReader;\n+import org.apache.iceberg.avro.ValueReaders;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.types.Types;\n+\n+public class FlinkValueReaders {\n+\n+  private FlinkValueReaders() {}\n+\n+  static ValueReader<StringData> strings() {\n+    return StringReader.INSTANCE;\n+  }\n+\n+  static ValueReader<StringData> enums(List<String> symbols) {\n+    return new EnumReader(symbols);\n+  }\n+\n+  static ValueReader<byte[]> uuids() {\n+    return ValueReaders.fixed(16);\n+  }\n+\n+  static ValueReader<Integer> timeMicros() {\n+    return TimeMicrosReader.INSTANCE;\n+  }\n+\n+  static ValueReader<TimestampData> timestampMills() {\n+    return TimestampMillsReader.INSTANCE;\n+  }\n+\n+  static ValueReader<TimestampData> timestampMicros() {\n+    return TimestampMicrosReader.INSTANCE;\n+  }\n+\n+  static ValueReader<DecimalData> decimal(ValueReader<byte[]> unscaledReader, int precision, int scale) {\n+    return new DecimalReader(unscaledReader, precision, scale);\n+  }\n+\n+  static ValueReader<ArrayData> array(ValueReader<?> elementReader) {\n+    return new ArrayReader(elementReader);\n+  }\n+\n+  static ValueReader<MapData> arrayMap(ValueReader<?> keyReader,\n+                                                 ValueReader<?> valueReader) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50d3b8881f3330775510e1131830071480e9a710"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4NDE3NTc5OnYy", "diffSide": "RIGHT", "path": "flink/src/main/java/org/apache/iceberg/flink/data/FlinkValueReaders.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQwMToxMTowMVrOG4lB0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQwMToxMTowMVrOG4lB0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk4MDExNQ==", "bodyText": "Time zones are left to the processing engine. It is up to the engine to convert times to concrete values for storage and from concrete values for display. Iceberg's responsibility is to return the value without modification.", "url": "https://github.com/apache/iceberg/pull/1232#discussion_r461980115", "createdAt": "2020-07-29T01:11:01Z", "author": {"login": "rdblue"}, "path": "flink/src/main/java/org/apache/iceberg/flink/data/FlinkValueReaders.java", "diffHunk": "@@ -0,0 +1,314 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink.data;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.avro.io.Decoder;\n+import org.apache.avro.util.Utf8;\n+import org.apache.flink.table.data.ArrayData;\n+import org.apache.flink.table.data.DecimalData;\n+import org.apache.flink.table.data.GenericArrayData;\n+import org.apache.flink.table.data.GenericMapData;\n+import org.apache.flink.table.data.GenericRowData;\n+import org.apache.flink.table.data.MapData;\n+import org.apache.flink.table.data.RowData;\n+import org.apache.flink.table.data.StringData;\n+import org.apache.flink.table.data.TimestampData;\n+import org.apache.iceberg.avro.ValueReader;\n+import org.apache.iceberg.avro.ValueReaders;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.types.Types;\n+\n+public class FlinkValueReaders {\n+\n+  private FlinkValueReaders() {}\n+\n+  static ValueReader<StringData> strings() {\n+    return StringReader.INSTANCE;\n+  }\n+\n+  static ValueReader<StringData> enums(List<String> symbols) {\n+    return new EnumReader(symbols);\n+  }\n+\n+  static ValueReader<byte[]> uuids() {\n+    return ValueReaders.fixed(16);\n+  }\n+\n+  static ValueReader<Integer> timeMicros() {\n+    return TimeMicrosReader.INSTANCE;\n+  }\n+\n+  static ValueReader<TimestampData> timestampMills() {\n+    return TimestampMillsReader.INSTANCE;\n+  }\n+\n+  static ValueReader<TimestampData> timestampMicros() {\n+    return TimestampMicrosReader.INSTANCE;\n+  }\n+\n+  static ValueReader<DecimalData> decimal(ValueReader<byte[]> unscaledReader, int precision, int scale) {\n+    return new DecimalReader(unscaledReader, precision, scale);\n+  }\n+\n+  static ValueReader<ArrayData> array(ValueReader<?> elementReader) {\n+    return new ArrayReader(elementReader);\n+  }\n+\n+  static ValueReader<MapData> arrayMap(ValueReader<?> keyReader,\n+                                                 ValueReader<?> valueReader) {\n+    return new ArrayMapReader(keyReader, valueReader);\n+  }\n+\n+  static ValueReader<MapData> map(ValueReader<?> keyReader, ValueReader<?> valueReader) {\n+    return new MapReader(keyReader, valueReader);\n+  }\n+\n+  static ValueReader<RowData> struct(List<ValueReader<?>> readers, Types.StructType struct,\n+                                         Map<Integer, ?> idToConstant) {\n+    return new StructReader(readers, struct, idToConstant);\n+  }\n+\n+  private static class StringReader implements ValueReader<StringData> {\n+    private static final StringReader INSTANCE = new StringReader();\n+\n+    private StringReader() {\n+    }\n+\n+    @Override\n+    public StringData read(Decoder decoder, Object reuse) throws IOException {\n+      // use the decoder's readString(Utf8) method because it may be a resolving decoder\n+      Utf8 utf8 = null;\n+      if (reuse instanceof StringData) {\n+        utf8 = new Utf8(((StringData) reuse).toBytes());\n+      }\n+\n+      Utf8 string = decoder.readString(utf8);\n+      return StringData.fromBytes(string.getBytes(), 0, string.getByteLength());\n+    }\n+  }\n+\n+  private static class EnumReader implements ValueReader<StringData> {\n+    private final StringData[] symbols;\n+\n+    private EnumReader(List<String> symbols) {\n+      this.symbols = new StringData[symbols.size()];\n+      for (int i = 0; i < this.symbols.length; i += 1) {\n+        this.symbols[i] = StringData.fromBytes(symbols.get(i).getBytes(StandardCharsets.UTF_8));\n+      }\n+    }\n+\n+    @Override\n+    public StringData read(Decoder decoder, Object ignore) throws IOException {\n+      int index = decoder.readEnum();\n+      return symbols[index];\n+    }\n+  }\n+\n+  private static class DecimalReader implements ValueReader<DecimalData> {\n+    private final ValueReader<byte[]> bytesReader;\n+    private final int precision;\n+    private final int scale;\n+\n+    private DecimalReader(ValueReader<byte[]> bytesReader, int precision, int scale) {\n+      this.bytesReader = bytesReader;\n+      this.precision = precision;\n+      this.scale = scale;\n+    }\n+\n+    @Override\n+    public DecimalData read(Decoder decoder, Object reuse) throws IOException {\n+      byte[] bytes = bytesReader.read(decoder, null);\n+      return DecimalData.fromBigDecimal(new BigDecimal(new BigInteger(bytes), scale), precision, scale);\n+    }\n+  }\n+\n+  private static class TimeMicrosReader implements ValueReader<Integer> {\n+    private static final TimeMicrosReader INSTANCE = new TimeMicrosReader();\n+\n+    @Override\n+    public Integer read(Decoder decoder, Object reuse) throws IOException {\n+      long micros = decoder.readLong();\n+      // Flink only support time mills, just erase micros.\n+      return (int) (micros / 1000);\n+    }\n+  }\n+\n+  private static class TimestampMillsReader implements ValueReader<TimestampData> {\n+    private static final TimestampMillsReader INSTANCE = new TimestampMillsReader();\n+\n+    @Override\n+    public TimestampData read(Decoder decoder, Object reuse) throws IOException {\n+      // TODO Do we need to consider time zones.\n+      return TimestampData.fromEpochMillis(decoder.readLong());\n+    }\n+  }\n+\n+  private static class TimestampMicrosReader implements ValueReader<TimestampData> {\n+    private static final TimestampMicrosReader INSTANCE = new TimestampMicrosReader();\n+\n+    @Override\n+    public TimestampData read(Decoder decoder, Object reuse) throws IOException {\n+      // TODO Do we need to consider time zones.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50d3b8881f3330775510e1131830071480e9a710"}, "originalPosition": 175}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4NDE3OTU3OnYy", "diffSide": "RIGHT", "path": "flink/src/main/java/org/apache/iceberg/flink/data/FlinkValueWriters.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQwMToxMzoxMFrOG4lD-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQwMzowODo0NVrOG4m7gQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk4MDY2NQ==", "bodyText": "Can we move this logic into a common DecimalUtil method? I think we have quite a few copies of it.", "url": "https://github.com/apache/iceberg/pull/1232#discussion_r461980665", "createdAt": "2020-07-29T01:13:10Z", "author": {"login": "rdblue"}, "path": "flink/src/main/java/org/apache/iceberg/flink/data/FlinkValueWriters.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink.data;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Array;\n+import java.math.BigDecimal;\n+import java.util.List;\n+import org.apache.avro.io.Encoder;\n+import org.apache.avro.util.Utf8;\n+import org.apache.flink.table.data.ArrayData;\n+import org.apache.flink.table.data.DecimalData;\n+import org.apache.flink.table.data.MapData;\n+import org.apache.flink.table.data.RowData;\n+import org.apache.flink.table.data.StringData;\n+import org.apache.flink.table.data.TimestampData;\n+import org.apache.flink.table.types.logical.LogicalType;\n+import org.apache.iceberg.avro.ValueWriter;\n+import org.apache.iceberg.avro.ValueWriters;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.types.TypeUtil;\n+\n+public class FlinkValueWriters {\n+\n+  private FlinkValueWriters() {}\n+\n+  static ValueWriter<StringData> strings() {\n+    return StringWriter.INSTANCE;\n+  }\n+\n+  static ValueWriter<byte[]> uuids() {\n+    return ValueWriters.fixed(16);\n+  }\n+\n+  static ValueWriter<Integer> timeMicros() {\n+    return TimeMicrosWriter.INSTANCE;\n+  }\n+\n+  static ValueWriter<TimestampData> timestampMicros() {\n+    return TimestampMicrosWriter.INSTANCE;\n+  }\n+\n+  static ValueWriter<DecimalData> decimal(int precision, int scale) {\n+    return new DecimalWriter(precision, scale);\n+  }\n+\n+  static <T> ValueWriter<ArrayData> array(ValueWriter<T> elementWriter, LogicalType elementType) {\n+    return new ArrayWriter<>(elementWriter, elementType);\n+  }\n+\n+  static <K, V> ValueWriter<MapData> arrayMap(\n+      ValueWriter<K> keyWriter, LogicalType keyType, ValueWriter<V> valueWriter, LogicalType valueType) {\n+    return new ArrayMapWriter<>(keyWriter, keyType, valueWriter, valueType);\n+  }\n+\n+  static <K, V> ValueWriter<MapData> map(\n+      ValueWriter<K> keyWriter, LogicalType keyType, ValueWriter<V> valueWriter, LogicalType valueType) {\n+    return new MapWriter<>(keyWriter, keyType, valueWriter, valueType);\n+  }\n+\n+  static ValueWriter<RowData> row(List<ValueWriter<?>> writers, List<LogicalType> types) {\n+    return new RowWriter(writers, types);\n+  }\n+\n+  private static class StringWriter implements ValueWriter<StringData> {\n+    private static final StringWriter INSTANCE = new StringWriter();\n+\n+    private StringWriter() {\n+    }\n+\n+    @Override\n+    public void write(StringData s, Encoder encoder) throws IOException {\n+      // toBytes is cheaper than Avro calling toString, which incurs encoding costs\n+      encoder.writeString(new Utf8(s.toBytes()));\n+    }\n+  }\n+\n+  private static class DecimalWriter implements ValueWriter<DecimalData> {\n+    private final int precision;\n+    private final int scale;\n+    private final int length;\n+    private final ThreadLocal<byte[]> bytes;\n+\n+    private DecimalWriter(int precision, int scale) {\n+      this.precision = precision;\n+      this.scale = scale;\n+      this.length = TypeUtil.decimalRequiredBytes(precision);\n+      this.bytes = ThreadLocal.withInitial(() -> new byte[length]);\n+    }\n+\n+    @Override\n+    public void write(DecimalData d, Encoder encoder) throws IOException {\n+      Preconditions.checkArgument(d.scale() == scale,\n+          \"Cannot write value as decimal(%s,%s), wrong scale: %s\", precision, scale, d);\n+      Preconditions.checkArgument(d.precision() <= precision,\n+          \"Cannot write value as decimal(%s,%s), too large: %s\", precision, scale, d);\n+\n+      BigDecimal decimal = d.toBigDecimal();\n+\n+      byte fillByte = (byte) (decimal.signum() < 0 ? 0xFF : 0x00);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50d3b8881f3330775510e1131830071480e9a710"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAxMTI2NQ==", "bodyText": "Created #1265 for this.", "url": "https://github.com/apache/iceberg/pull/1232#discussion_r462011265", "createdAt": "2020-07-29T03:08:45Z", "author": {"login": "JingsongLi"}, "path": "flink/src/main/java/org/apache/iceberg/flink/data/FlinkValueWriters.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink.data;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Array;\n+import java.math.BigDecimal;\n+import java.util.List;\n+import org.apache.avro.io.Encoder;\n+import org.apache.avro.util.Utf8;\n+import org.apache.flink.table.data.ArrayData;\n+import org.apache.flink.table.data.DecimalData;\n+import org.apache.flink.table.data.MapData;\n+import org.apache.flink.table.data.RowData;\n+import org.apache.flink.table.data.StringData;\n+import org.apache.flink.table.data.TimestampData;\n+import org.apache.flink.table.types.logical.LogicalType;\n+import org.apache.iceberg.avro.ValueWriter;\n+import org.apache.iceberg.avro.ValueWriters;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.types.TypeUtil;\n+\n+public class FlinkValueWriters {\n+\n+  private FlinkValueWriters() {}\n+\n+  static ValueWriter<StringData> strings() {\n+    return StringWriter.INSTANCE;\n+  }\n+\n+  static ValueWriter<byte[]> uuids() {\n+    return ValueWriters.fixed(16);\n+  }\n+\n+  static ValueWriter<Integer> timeMicros() {\n+    return TimeMicrosWriter.INSTANCE;\n+  }\n+\n+  static ValueWriter<TimestampData> timestampMicros() {\n+    return TimestampMicrosWriter.INSTANCE;\n+  }\n+\n+  static ValueWriter<DecimalData> decimal(int precision, int scale) {\n+    return new DecimalWriter(precision, scale);\n+  }\n+\n+  static <T> ValueWriter<ArrayData> array(ValueWriter<T> elementWriter, LogicalType elementType) {\n+    return new ArrayWriter<>(elementWriter, elementType);\n+  }\n+\n+  static <K, V> ValueWriter<MapData> arrayMap(\n+      ValueWriter<K> keyWriter, LogicalType keyType, ValueWriter<V> valueWriter, LogicalType valueType) {\n+    return new ArrayMapWriter<>(keyWriter, keyType, valueWriter, valueType);\n+  }\n+\n+  static <K, V> ValueWriter<MapData> map(\n+      ValueWriter<K> keyWriter, LogicalType keyType, ValueWriter<V> valueWriter, LogicalType valueType) {\n+    return new MapWriter<>(keyWriter, keyType, valueWriter, valueType);\n+  }\n+\n+  static ValueWriter<RowData> row(List<ValueWriter<?>> writers, List<LogicalType> types) {\n+    return new RowWriter(writers, types);\n+  }\n+\n+  private static class StringWriter implements ValueWriter<StringData> {\n+    private static final StringWriter INSTANCE = new StringWriter();\n+\n+    private StringWriter() {\n+    }\n+\n+    @Override\n+    public void write(StringData s, Encoder encoder) throws IOException {\n+      // toBytes is cheaper than Avro calling toString, which incurs encoding costs\n+      encoder.writeString(new Utf8(s.toBytes()));\n+    }\n+  }\n+\n+  private static class DecimalWriter implements ValueWriter<DecimalData> {\n+    private final int precision;\n+    private final int scale;\n+    private final int length;\n+    private final ThreadLocal<byte[]> bytes;\n+\n+    private DecimalWriter(int precision, int scale) {\n+      this.precision = precision;\n+      this.scale = scale;\n+      this.length = TypeUtil.decimalRequiredBytes(precision);\n+      this.bytes = ThreadLocal.withInitial(() -> new byte[length]);\n+    }\n+\n+    @Override\n+    public void write(DecimalData d, Encoder encoder) throws IOException {\n+      Preconditions.checkArgument(d.scale() == scale,\n+          \"Cannot write value as decimal(%s,%s), wrong scale: %s\", precision, scale, d);\n+      Preconditions.checkArgument(d.precision() <= precision,\n+          \"Cannot write value as decimal(%s,%s), too large: %s\", precision, scale, d);\n+\n+      BigDecimal decimal = d.toBigDecimal();\n+\n+      byte fillByte = (byte) (decimal.signum() < 0 ? 0xFF : 0x00);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk4MDY2NQ=="}, "originalCommit": {"oid": "50d3b8881f3330775510e1131830071480e9a710"}, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4NDI5ODY0OnYy", "diffSide": "RIGHT", "path": "flink/src/test/java/org/apache/iceberg/flink/data/TestFlinkAvroReaderWriter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQwMjoxNzowNVrOG4mHLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQwMzoyMDowN1rOG4nGvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk5Nzg2OQ==", "bodyText": "I see you will generate the List<Record> firstly, then write to the file appender, and finally read them into List<RowData>,   could we just use the RandomData#generateRowData  to produce those RowData ?", "url": "https://github.com/apache/iceberg/pull/1232#discussion_r461997869", "createdAt": "2020-07-29T02:17:05Z", "author": {"login": "openinx"}, "path": "flink/src/test/java/org/apache/iceberg/flink/data/TestFlinkAvroReaderWriter.java", "diffHunk": "@@ -22,52 +22,76 @@\n import java.io.File;\n import java.io.IOException;\n import java.util.Iterator;\n-import org.apache.flink.types.Row;\n+import java.util.List;\n+import org.apache.flink.table.data.RowData;\n import org.apache.iceberg.Files;\n import org.apache.iceberg.Schema;\n import org.apache.iceberg.avro.Avro;\n+import org.apache.iceberg.data.DataTest;\n+import org.apache.iceberg.data.RandomGenericData;\n+import org.apache.iceberg.data.Record;\n+import org.apache.iceberg.data.avro.DataWriter;\n+import org.apache.iceberg.flink.FlinkSchemaUtil;\n import org.apache.iceberg.io.CloseableIterable;\n import org.apache.iceberg.io.FileAppender;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n import org.junit.Assert;\n-import org.junit.Rule;\n-import org.junit.Test;\n-import org.junit.rules.TemporaryFolder;\n \n-import static org.apache.iceberg.flink.data.RandomData.COMPLEX_SCHEMA;\n+public class TestFlinkAvroReaderWriter extends DataTest {\n \n-public class TestFlinkAvroReaderWriter {\n-  private static final int NUM_RECORDS = 20_000;\n+  private static final int NUM_RECORDS = 100;\n \n-  @Rule\n-  public TemporaryFolder temp = new TemporaryFolder();\n+  @Override\n+  protected void writeAndValidate(Schema schema) throws IOException {\n+    List<RowData> inputs = generateDataFromAvroFile(schema);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50d3b8881f3330775510e1131830071480e9a710"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAxNDE0MA==", "bodyText": "First, RandomData now is incorrect, like array, like timestamp with zone, and etc..\nSecond, using Iceberg avro writer can test format compatible better.", "url": "https://github.com/apache/iceberg/pull/1232#discussion_r462014140", "createdAt": "2020-07-29T03:20:07Z", "author": {"login": "JingsongLi"}, "path": "flink/src/test/java/org/apache/iceberg/flink/data/TestFlinkAvroReaderWriter.java", "diffHunk": "@@ -22,52 +22,76 @@\n import java.io.File;\n import java.io.IOException;\n import java.util.Iterator;\n-import org.apache.flink.types.Row;\n+import java.util.List;\n+import org.apache.flink.table.data.RowData;\n import org.apache.iceberg.Files;\n import org.apache.iceberg.Schema;\n import org.apache.iceberg.avro.Avro;\n+import org.apache.iceberg.data.DataTest;\n+import org.apache.iceberg.data.RandomGenericData;\n+import org.apache.iceberg.data.Record;\n+import org.apache.iceberg.data.avro.DataWriter;\n+import org.apache.iceberg.flink.FlinkSchemaUtil;\n import org.apache.iceberg.io.CloseableIterable;\n import org.apache.iceberg.io.FileAppender;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n import org.junit.Assert;\n-import org.junit.Rule;\n-import org.junit.Test;\n-import org.junit.rules.TemporaryFolder;\n \n-import static org.apache.iceberg.flink.data.RandomData.COMPLEX_SCHEMA;\n+public class TestFlinkAvroReaderWriter extends DataTest {\n \n-public class TestFlinkAvroReaderWriter {\n-  private static final int NUM_RECORDS = 20_000;\n+  private static final int NUM_RECORDS = 100;\n \n-  @Rule\n-  public TemporaryFolder temp = new TemporaryFolder();\n+  @Override\n+  protected void writeAndValidate(Schema schema) throws IOException {\n+    List<RowData> inputs = generateDataFromAvroFile(schema);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk5Nzg2OQ=="}, "originalCommit": {"oid": "50d3b8881f3330775510e1131830071480e9a710"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4NDMyMDcyOnYy", "diffSide": "RIGHT", "path": "flink/src/test/java/org/apache/iceberg/flink/data/RandomData.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQwMjoyOTo1N1rOG4mUAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQwMzoxNDowOVrOG4nAoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwMTE1Mg==", "bodyText": "Here  we may need to call converter.open(RandomData.class.getClassLoader()) to initialize the converter ?", "url": "https://github.com/apache/iceberg/pull/1232#discussion_r462001152", "createdAt": "2020-07-29T02:29:57Z", "author": {"login": "openinx"}, "path": "flink/src/test/java/org/apache/iceberg/flink/data/RandomData.java", "diffHunk": "@@ -88,6 +93,34 @@ public Row next() {\n     };\n   }\n \n+  private static Iterable<RowData> generateRowData(Schema schema, int numRecords,\n+      Supplier<RandomRowGenerator> supplier) {\n+    DataStructureConverter<Object, Object> converter =\n+        DataStructureConverters.getConverter(TypeConversions.fromLogicalToDataType(FlinkSchemaUtil.convert(schema)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50d3b8881f3330775510e1131830071480e9a710"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAxMjU3Ng==", "bodyText": "Yes, we can, only StructuredObjectConverter implements open, but now, Flink not support structure type. (It is not RowType).\nI'll revert this method in RandomData, it is not be used.", "url": "https://github.com/apache/iceberg/pull/1232#discussion_r462012576", "createdAt": "2020-07-29T03:14:09Z", "author": {"login": "JingsongLi"}, "path": "flink/src/test/java/org/apache/iceberg/flink/data/RandomData.java", "diffHunk": "@@ -88,6 +93,34 @@ public Row next() {\n     };\n   }\n \n+  private static Iterable<RowData> generateRowData(Schema schema, int numRecords,\n+      Supplier<RandomRowGenerator> supplier) {\n+    DataStructureConverter<Object, Object> converter =\n+        DataStructureConverters.getConverter(TypeConversions.fromLogicalToDataType(FlinkSchemaUtil.convert(schema)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwMTE1Mg=="}, "originalCommit": {"oid": "50d3b8881f3330775510e1131830071480e9a710"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMzgwNDA0OnYy", "diffSide": "RIGHT", "path": "flink/src/main/java/org/apache/iceberg/flink/TaskWriterFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQwOTo1MDozN1rOG7ZXFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwNDoyMjo1OVrOG75o4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkzNDY3OA==", "bodyText": "nit: this should not work,  because the FlinkAvroWriter is a writer with RowData parameter type,  while we need a Row type FileAppender.   we may could remove this avro write building.  Once the RowDataWrapper is ready,  we would rewrite this part.", "url": "https://github.com/apache/iceberg/pull/1232#discussion_r464934678", "createdAt": "2020-08-04T09:50:37Z", "author": {"login": "openinx"}, "path": "flink/src/main/java/org/apache/iceberg/flink/TaskWriterFactory.java", "diffHunk": "@@ -103,7 +103,7 @@ protected PartitionKey partition(Row row) {\n \n           case AVRO:\n             return Avro.write(outputFile)\n-                .createWriterFunc(FlinkAvroWriter::new)\n+                .createWriterFunc(ignore -> new FlinkAvroWriter(FlinkSchemaUtil.convert(schema)))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dad83fcbea5253ce11eb23caa8f6f04f5fcd8c36"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2MzUyMg==", "bodyText": "Removed this and add comment:\nTODO add AVRO once the RowDataWrapper are ready.", "url": "https://github.com/apache/iceberg/pull/1232#discussion_r465463522", "createdAt": "2020-08-05T04:22:59Z", "author": {"login": "JingsongLi"}, "path": "flink/src/main/java/org/apache/iceberg/flink/TaskWriterFactory.java", "diffHunk": "@@ -103,7 +103,7 @@ protected PartitionKey partition(Row row) {\n \n           case AVRO:\n             return Avro.write(outputFile)\n-                .createWriterFunc(FlinkAvroWriter::new)\n+                .createWriterFunc(ignore -> new FlinkAvroWriter(FlinkSchemaUtil.convert(schema)))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkzNDY3OA=="}, "originalCommit": {"oid": "dad83fcbea5253ce11eb23caa8f6f04f5fcd8c36"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMzk2MTA4OnYy", "diffSide": "RIGHT", "path": "flink/src/main/java/org/apache/iceberg/flink/data/FlinkValueReaders.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxMDozOToyMlrOG7a3dA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMDoyMzoxOFrOG8ZSMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDk1OTM0OA==", "bodyText": "Here it's simple to use floorDiv and floorMod :\nlong mills = Math.floorDiv(micros, 1000);\nint nanos = Math.floorMod(micros, 1000)*1000;", "url": "https://github.com/apache/iceberg/pull/1232#discussion_r464959348", "createdAt": "2020-08-04T10:39:22Z", "author": {"login": "openinx"}, "path": "flink/src/main/java/org/apache/iceberg/flink/data/FlinkValueReaders.java", "diffHunk": "@@ -0,0 +1,312 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink.data;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.nio.charset.StandardCharsets;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.avro.io.Decoder;\n+import org.apache.avro.util.Utf8;\n+import org.apache.flink.table.data.ArrayData;\n+import org.apache.flink.table.data.DecimalData;\n+import org.apache.flink.table.data.GenericArrayData;\n+import org.apache.flink.table.data.GenericMapData;\n+import org.apache.flink.table.data.GenericRowData;\n+import org.apache.flink.table.data.MapData;\n+import org.apache.flink.table.data.RowData;\n+import org.apache.flink.table.data.StringData;\n+import org.apache.flink.table.data.TimestampData;\n+import org.apache.iceberg.avro.ValueReader;\n+import org.apache.iceberg.avro.ValueReaders;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.types.Types;\n+\n+public class FlinkValueReaders {\n+\n+  private FlinkValueReaders() {}\n+\n+  static ValueReader<StringData> strings() {\n+    return StringReader.INSTANCE;\n+  }\n+\n+  static ValueReader<StringData> enums(List<String> symbols) {\n+    return new EnumReader(symbols);\n+  }\n+\n+  static ValueReader<byte[]> uuids() {\n+    return ValueReaders.fixed(16);\n+  }\n+\n+  static ValueReader<Integer> timeMicros() {\n+    return TimeMicrosReader.INSTANCE;\n+  }\n+\n+  static ValueReader<TimestampData> timestampMills() {\n+    return TimestampMillsReader.INSTANCE;\n+  }\n+\n+  static ValueReader<TimestampData> timestampMicros() {\n+    return TimestampMicrosReader.INSTANCE;\n+  }\n+\n+  static ValueReader<DecimalData> decimal(ValueReader<byte[]> unscaledReader, int precision, int scale) {\n+    return new DecimalReader(unscaledReader, precision, scale);\n+  }\n+\n+  static ValueReader<ArrayData> array(ValueReader<?> elementReader) {\n+    return new ArrayReader(elementReader);\n+  }\n+\n+  static ValueReader<MapData> arrayMap(ValueReader<?> keyReader,\n+                                       ValueReader<?> valueReader) {\n+    return new ArrayMapReader(keyReader, valueReader);\n+  }\n+\n+  static ValueReader<MapData> map(ValueReader<?> keyReader, ValueReader<?> valueReader) {\n+    return new MapReader(keyReader, valueReader);\n+  }\n+\n+  static ValueReader<RowData> struct(List<ValueReader<?>> readers, Types.StructType struct,\n+                                     Map<Integer, ?> idToConstant) {\n+    return new StructReader(readers, struct, idToConstant);\n+  }\n+\n+  private static class StringReader implements ValueReader<StringData> {\n+    private static final StringReader INSTANCE = new StringReader();\n+\n+    private StringReader() {\n+    }\n+\n+    @Override\n+    public StringData read(Decoder decoder, Object reuse) throws IOException {\n+      // use the decoder's readString(Utf8) method because it may be a resolving decoder\n+      Utf8 utf8 = null;\n+      if (reuse instanceof StringData) {\n+        utf8 = new Utf8(((StringData) reuse).toBytes());\n+      }\n+\n+      Utf8 string = decoder.readString(utf8);\n+      return StringData.fromBytes(string.getBytes(), 0, string.getByteLength());\n+    }\n+  }\n+\n+  private static class EnumReader implements ValueReader<StringData> {\n+    private final StringData[] symbols;\n+\n+    private EnumReader(List<String> symbols) {\n+      this.symbols = new StringData[symbols.size()];\n+      for (int i = 0; i < this.symbols.length; i += 1) {\n+        this.symbols[i] = StringData.fromBytes(symbols.get(i).getBytes(StandardCharsets.UTF_8));\n+      }\n+    }\n+\n+    @Override\n+    public StringData read(Decoder decoder, Object ignore) throws IOException {\n+      int index = decoder.readEnum();\n+      return symbols[index];\n+    }\n+  }\n+\n+  private static class DecimalReader implements ValueReader<DecimalData> {\n+    private final ValueReader<byte[]> bytesReader;\n+    private final int precision;\n+    private final int scale;\n+\n+    private DecimalReader(ValueReader<byte[]> bytesReader, int precision, int scale) {\n+      this.bytesReader = bytesReader;\n+      this.precision = precision;\n+      this.scale = scale;\n+    }\n+\n+    @Override\n+    public DecimalData read(Decoder decoder, Object reuse) throws IOException {\n+      byte[] bytes = bytesReader.read(decoder, null);\n+      return DecimalData.fromBigDecimal(new BigDecimal(new BigInteger(bytes), scale), precision, scale);\n+    }\n+  }\n+\n+  private static class TimeMicrosReader implements ValueReader<Integer> {\n+    private static final TimeMicrosReader INSTANCE = new TimeMicrosReader();\n+\n+    @Override\n+    public Integer read(Decoder decoder, Object reuse) throws IOException {\n+      long micros = decoder.readLong();\n+      // Flink only support time mills, just erase micros.\n+      return (int) (micros / 1000);\n+    }\n+  }\n+\n+  private static class TimestampMillsReader implements ValueReader<TimestampData> {\n+    private static final TimestampMillsReader INSTANCE = new TimestampMillsReader();\n+\n+    @Override\n+    public TimestampData read(Decoder decoder, Object reuse) throws IOException {\n+      return TimestampData.fromEpochMillis(decoder.readLong());\n+    }\n+  }\n+\n+  private static class TimestampMicrosReader implements ValueReader<TimestampData> {\n+    private static final TimestampMicrosReader INSTANCE = new TimestampMicrosReader();\n+\n+    @Override\n+    public TimestampData read(Decoder decoder, Object reuse) throws IOException {\n+      long micros = decoder.readLong();\n+      long mills = micros / 1000;\n+      int nanos = ((int) (micros % 1000)) * 1000;\n+      if (nanos < 0) {\n+        nanos += 1_000_000;\n+        mills -= 1;\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dad83fcbea5253ce11eb23caa8f6f04f5fcd8c36"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2ODAwNA==", "bodyText": "I wrote a simple benchmark, Math.floor** will be 10% slower.", "url": "https://github.com/apache/iceberg/pull/1232#discussion_r465468004", "createdAt": "2020-08-05T04:40:12Z", "author": {"login": "JingsongLi"}, "path": "flink/src/main/java/org/apache/iceberg/flink/data/FlinkValueReaders.java", "diffHunk": "@@ -0,0 +1,312 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink.data;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.nio.charset.StandardCharsets;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.avro.io.Decoder;\n+import org.apache.avro.util.Utf8;\n+import org.apache.flink.table.data.ArrayData;\n+import org.apache.flink.table.data.DecimalData;\n+import org.apache.flink.table.data.GenericArrayData;\n+import org.apache.flink.table.data.GenericMapData;\n+import org.apache.flink.table.data.GenericRowData;\n+import org.apache.flink.table.data.MapData;\n+import org.apache.flink.table.data.RowData;\n+import org.apache.flink.table.data.StringData;\n+import org.apache.flink.table.data.TimestampData;\n+import org.apache.iceberg.avro.ValueReader;\n+import org.apache.iceberg.avro.ValueReaders;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.types.Types;\n+\n+public class FlinkValueReaders {\n+\n+  private FlinkValueReaders() {}\n+\n+  static ValueReader<StringData> strings() {\n+    return StringReader.INSTANCE;\n+  }\n+\n+  static ValueReader<StringData> enums(List<String> symbols) {\n+    return new EnumReader(symbols);\n+  }\n+\n+  static ValueReader<byte[]> uuids() {\n+    return ValueReaders.fixed(16);\n+  }\n+\n+  static ValueReader<Integer> timeMicros() {\n+    return TimeMicrosReader.INSTANCE;\n+  }\n+\n+  static ValueReader<TimestampData> timestampMills() {\n+    return TimestampMillsReader.INSTANCE;\n+  }\n+\n+  static ValueReader<TimestampData> timestampMicros() {\n+    return TimestampMicrosReader.INSTANCE;\n+  }\n+\n+  static ValueReader<DecimalData> decimal(ValueReader<byte[]> unscaledReader, int precision, int scale) {\n+    return new DecimalReader(unscaledReader, precision, scale);\n+  }\n+\n+  static ValueReader<ArrayData> array(ValueReader<?> elementReader) {\n+    return new ArrayReader(elementReader);\n+  }\n+\n+  static ValueReader<MapData> arrayMap(ValueReader<?> keyReader,\n+                                       ValueReader<?> valueReader) {\n+    return new ArrayMapReader(keyReader, valueReader);\n+  }\n+\n+  static ValueReader<MapData> map(ValueReader<?> keyReader, ValueReader<?> valueReader) {\n+    return new MapReader(keyReader, valueReader);\n+  }\n+\n+  static ValueReader<RowData> struct(List<ValueReader<?>> readers, Types.StructType struct,\n+                                     Map<Integer, ?> idToConstant) {\n+    return new StructReader(readers, struct, idToConstant);\n+  }\n+\n+  private static class StringReader implements ValueReader<StringData> {\n+    private static final StringReader INSTANCE = new StringReader();\n+\n+    private StringReader() {\n+    }\n+\n+    @Override\n+    public StringData read(Decoder decoder, Object reuse) throws IOException {\n+      // use the decoder's readString(Utf8) method because it may be a resolving decoder\n+      Utf8 utf8 = null;\n+      if (reuse instanceof StringData) {\n+        utf8 = new Utf8(((StringData) reuse).toBytes());\n+      }\n+\n+      Utf8 string = decoder.readString(utf8);\n+      return StringData.fromBytes(string.getBytes(), 0, string.getByteLength());\n+    }\n+  }\n+\n+  private static class EnumReader implements ValueReader<StringData> {\n+    private final StringData[] symbols;\n+\n+    private EnumReader(List<String> symbols) {\n+      this.symbols = new StringData[symbols.size()];\n+      for (int i = 0; i < this.symbols.length; i += 1) {\n+        this.symbols[i] = StringData.fromBytes(symbols.get(i).getBytes(StandardCharsets.UTF_8));\n+      }\n+    }\n+\n+    @Override\n+    public StringData read(Decoder decoder, Object ignore) throws IOException {\n+      int index = decoder.readEnum();\n+      return symbols[index];\n+    }\n+  }\n+\n+  private static class DecimalReader implements ValueReader<DecimalData> {\n+    private final ValueReader<byte[]> bytesReader;\n+    private final int precision;\n+    private final int scale;\n+\n+    private DecimalReader(ValueReader<byte[]> bytesReader, int precision, int scale) {\n+      this.bytesReader = bytesReader;\n+      this.precision = precision;\n+      this.scale = scale;\n+    }\n+\n+    @Override\n+    public DecimalData read(Decoder decoder, Object reuse) throws IOException {\n+      byte[] bytes = bytesReader.read(decoder, null);\n+      return DecimalData.fromBigDecimal(new BigDecimal(new BigInteger(bytes), scale), precision, scale);\n+    }\n+  }\n+\n+  private static class TimeMicrosReader implements ValueReader<Integer> {\n+    private static final TimeMicrosReader INSTANCE = new TimeMicrosReader();\n+\n+    @Override\n+    public Integer read(Decoder decoder, Object reuse) throws IOException {\n+      long micros = decoder.readLong();\n+      // Flink only support time mills, just erase micros.\n+      return (int) (micros / 1000);\n+    }\n+  }\n+\n+  private static class TimestampMillsReader implements ValueReader<TimestampData> {\n+    private static final TimestampMillsReader INSTANCE = new TimestampMillsReader();\n+\n+    @Override\n+    public TimestampData read(Decoder decoder, Object reuse) throws IOException {\n+      return TimestampData.fromEpochMillis(decoder.readLong());\n+    }\n+  }\n+\n+  private static class TimestampMicrosReader implements ValueReader<TimestampData> {\n+    private static final TimestampMicrosReader INSTANCE = new TimestampMicrosReader();\n+\n+    @Override\n+    public TimestampData read(Decoder decoder, Object reuse) throws IOException {\n+      long micros = decoder.readLong();\n+      long mills = micros / 1000;\n+      int nanos = ((int) (micros % 1000)) * 1000;\n+      if (nanos < 0) {\n+        nanos += 1_000_000;\n+        mills -= 1;\n+      }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDk1OTM0OA=="}, "originalCommit": {"oid": "dad83fcbea5253ce11eb23caa8f6f04f5fcd8c36"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk4MjAwMg==", "bodyText": "@openinx, that might influence fixing the timestamp types in ORC!", "url": "https://github.com/apache/iceberg/pull/1232#discussion_r465982002", "createdAt": "2020-08-05T20:23:18Z", "author": {"login": "rdblue"}, "path": "flink/src/main/java/org/apache/iceberg/flink/data/FlinkValueReaders.java", "diffHunk": "@@ -0,0 +1,312 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink.data;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.nio.charset.StandardCharsets;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.avro.io.Decoder;\n+import org.apache.avro.util.Utf8;\n+import org.apache.flink.table.data.ArrayData;\n+import org.apache.flink.table.data.DecimalData;\n+import org.apache.flink.table.data.GenericArrayData;\n+import org.apache.flink.table.data.GenericMapData;\n+import org.apache.flink.table.data.GenericRowData;\n+import org.apache.flink.table.data.MapData;\n+import org.apache.flink.table.data.RowData;\n+import org.apache.flink.table.data.StringData;\n+import org.apache.flink.table.data.TimestampData;\n+import org.apache.iceberg.avro.ValueReader;\n+import org.apache.iceberg.avro.ValueReaders;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.types.Types;\n+\n+public class FlinkValueReaders {\n+\n+  private FlinkValueReaders() {}\n+\n+  static ValueReader<StringData> strings() {\n+    return StringReader.INSTANCE;\n+  }\n+\n+  static ValueReader<StringData> enums(List<String> symbols) {\n+    return new EnumReader(symbols);\n+  }\n+\n+  static ValueReader<byte[]> uuids() {\n+    return ValueReaders.fixed(16);\n+  }\n+\n+  static ValueReader<Integer> timeMicros() {\n+    return TimeMicrosReader.INSTANCE;\n+  }\n+\n+  static ValueReader<TimestampData> timestampMills() {\n+    return TimestampMillsReader.INSTANCE;\n+  }\n+\n+  static ValueReader<TimestampData> timestampMicros() {\n+    return TimestampMicrosReader.INSTANCE;\n+  }\n+\n+  static ValueReader<DecimalData> decimal(ValueReader<byte[]> unscaledReader, int precision, int scale) {\n+    return new DecimalReader(unscaledReader, precision, scale);\n+  }\n+\n+  static ValueReader<ArrayData> array(ValueReader<?> elementReader) {\n+    return new ArrayReader(elementReader);\n+  }\n+\n+  static ValueReader<MapData> arrayMap(ValueReader<?> keyReader,\n+                                       ValueReader<?> valueReader) {\n+    return new ArrayMapReader(keyReader, valueReader);\n+  }\n+\n+  static ValueReader<MapData> map(ValueReader<?> keyReader, ValueReader<?> valueReader) {\n+    return new MapReader(keyReader, valueReader);\n+  }\n+\n+  static ValueReader<RowData> struct(List<ValueReader<?>> readers, Types.StructType struct,\n+                                     Map<Integer, ?> idToConstant) {\n+    return new StructReader(readers, struct, idToConstant);\n+  }\n+\n+  private static class StringReader implements ValueReader<StringData> {\n+    private static final StringReader INSTANCE = new StringReader();\n+\n+    private StringReader() {\n+    }\n+\n+    @Override\n+    public StringData read(Decoder decoder, Object reuse) throws IOException {\n+      // use the decoder's readString(Utf8) method because it may be a resolving decoder\n+      Utf8 utf8 = null;\n+      if (reuse instanceof StringData) {\n+        utf8 = new Utf8(((StringData) reuse).toBytes());\n+      }\n+\n+      Utf8 string = decoder.readString(utf8);\n+      return StringData.fromBytes(string.getBytes(), 0, string.getByteLength());\n+    }\n+  }\n+\n+  private static class EnumReader implements ValueReader<StringData> {\n+    private final StringData[] symbols;\n+\n+    private EnumReader(List<String> symbols) {\n+      this.symbols = new StringData[symbols.size()];\n+      for (int i = 0; i < this.symbols.length; i += 1) {\n+        this.symbols[i] = StringData.fromBytes(symbols.get(i).getBytes(StandardCharsets.UTF_8));\n+      }\n+    }\n+\n+    @Override\n+    public StringData read(Decoder decoder, Object ignore) throws IOException {\n+      int index = decoder.readEnum();\n+      return symbols[index];\n+    }\n+  }\n+\n+  private static class DecimalReader implements ValueReader<DecimalData> {\n+    private final ValueReader<byte[]> bytesReader;\n+    private final int precision;\n+    private final int scale;\n+\n+    private DecimalReader(ValueReader<byte[]> bytesReader, int precision, int scale) {\n+      this.bytesReader = bytesReader;\n+      this.precision = precision;\n+      this.scale = scale;\n+    }\n+\n+    @Override\n+    public DecimalData read(Decoder decoder, Object reuse) throws IOException {\n+      byte[] bytes = bytesReader.read(decoder, null);\n+      return DecimalData.fromBigDecimal(new BigDecimal(new BigInteger(bytes), scale), precision, scale);\n+    }\n+  }\n+\n+  private static class TimeMicrosReader implements ValueReader<Integer> {\n+    private static final TimeMicrosReader INSTANCE = new TimeMicrosReader();\n+\n+    @Override\n+    public Integer read(Decoder decoder, Object reuse) throws IOException {\n+      long micros = decoder.readLong();\n+      // Flink only support time mills, just erase micros.\n+      return (int) (micros / 1000);\n+    }\n+  }\n+\n+  private static class TimestampMillsReader implements ValueReader<TimestampData> {\n+    private static final TimestampMillsReader INSTANCE = new TimestampMillsReader();\n+\n+    @Override\n+    public TimestampData read(Decoder decoder, Object reuse) throws IOException {\n+      return TimestampData.fromEpochMillis(decoder.readLong());\n+    }\n+  }\n+\n+  private static class TimestampMicrosReader implements ValueReader<TimestampData> {\n+    private static final TimestampMicrosReader INSTANCE = new TimestampMicrosReader();\n+\n+    @Override\n+    public TimestampData read(Decoder decoder, Object reuse) throws IOException {\n+      long micros = decoder.readLong();\n+      long mills = micros / 1000;\n+      int nanos = ((int) (micros % 1000)) * 1000;\n+      if (nanos < 0) {\n+        nanos += 1_000_000;\n+        mills -= 1;\n+      }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDk1OTM0OA=="}, "originalCommit": {"oid": "dad83fcbea5253ce11eb23caa8f6f04f5fcd8c36"}, "originalPosition": 180}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMzk2NTQ0OnYy", "diffSide": "RIGHT", "path": "flink/src/main/java/org/apache/iceberg/flink/data/FlinkValueReaders.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxMDo0MDozOFrOG7a59A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxMDo0MDozOFrOG7a59A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDk1OTk4OA==", "bodyText": "No need to be protected.", "url": "https://github.com/apache/iceberg/pull/1232#discussion_r464959988", "createdAt": "2020-08-04T10:40:38Z", "author": {"login": "openinx"}, "path": "flink/src/main/java/org/apache/iceberg/flink/data/FlinkValueReaders.java", "diffHunk": "@@ -0,0 +1,312 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink.data;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.nio.charset.StandardCharsets;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.avro.io.Decoder;\n+import org.apache.avro.util.Utf8;\n+import org.apache.flink.table.data.ArrayData;\n+import org.apache.flink.table.data.DecimalData;\n+import org.apache.flink.table.data.GenericArrayData;\n+import org.apache.flink.table.data.GenericMapData;\n+import org.apache.flink.table.data.GenericRowData;\n+import org.apache.flink.table.data.MapData;\n+import org.apache.flink.table.data.RowData;\n+import org.apache.flink.table.data.StringData;\n+import org.apache.flink.table.data.TimestampData;\n+import org.apache.iceberg.avro.ValueReader;\n+import org.apache.iceberg.avro.ValueReaders;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.types.Types;\n+\n+public class FlinkValueReaders {\n+\n+  private FlinkValueReaders() {}\n+\n+  static ValueReader<StringData> strings() {\n+    return StringReader.INSTANCE;\n+  }\n+\n+  static ValueReader<StringData> enums(List<String> symbols) {\n+    return new EnumReader(symbols);\n+  }\n+\n+  static ValueReader<byte[]> uuids() {\n+    return ValueReaders.fixed(16);\n+  }\n+\n+  static ValueReader<Integer> timeMicros() {\n+    return TimeMicrosReader.INSTANCE;\n+  }\n+\n+  static ValueReader<TimestampData> timestampMills() {\n+    return TimestampMillsReader.INSTANCE;\n+  }\n+\n+  static ValueReader<TimestampData> timestampMicros() {\n+    return TimestampMicrosReader.INSTANCE;\n+  }\n+\n+  static ValueReader<DecimalData> decimal(ValueReader<byte[]> unscaledReader, int precision, int scale) {\n+    return new DecimalReader(unscaledReader, precision, scale);\n+  }\n+\n+  static ValueReader<ArrayData> array(ValueReader<?> elementReader) {\n+    return new ArrayReader(elementReader);\n+  }\n+\n+  static ValueReader<MapData> arrayMap(ValueReader<?> keyReader,\n+                                       ValueReader<?> valueReader) {\n+    return new ArrayMapReader(keyReader, valueReader);\n+  }\n+\n+  static ValueReader<MapData> map(ValueReader<?> keyReader, ValueReader<?> valueReader) {\n+    return new MapReader(keyReader, valueReader);\n+  }\n+\n+  static ValueReader<RowData> struct(List<ValueReader<?>> readers, Types.StructType struct,\n+                                     Map<Integer, ?> idToConstant) {\n+    return new StructReader(readers, struct, idToConstant);\n+  }\n+\n+  private static class StringReader implements ValueReader<StringData> {\n+    private static final StringReader INSTANCE = new StringReader();\n+\n+    private StringReader() {\n+    }\n+\n+    @Override\n+    public StringData read(Decoder decoder, Object reuse) throws IOException {\n+      // use the decoder's readString(Utf8) method because it may be a resolving decoder\n+      Utf8 utf8 = null;\n+      if (reuse instanceof StringData) {\n+        utf8 = new Utf8(((StringData) reuse).toBytes());\n+      }\n+\n+      Utf8 string = decoder.readString(utf8);\n+      return StringData.fromBytes(string.getBytes(), 0, string.getByteLength());\n+    }\n+  }\n+\n+  private static class EnumReader implements ValueReader<StringData> {\n+    private final StringData[] symbols;\n+\n+    private EnumReader(List<String> symbols) {\n+      this.symbols = new StringData[symbols.size()];\n+      for (int i = 0; i < this.symbols.length; i += 1) {\n+        this.symbols[i] = StringData.fromBytes(symbols.get(i).getBytes(StandardCharsets.UTF_8));\n+      }\n+    }\n+\n+    @Override\n+    public StringData read(Decoder decoder, Object ignore) throws IOException {\n+      int index = decoder.readEnum();\n+      return symbols[index];\n+    }\n+  }\n+\n+  private static class DecimalReader implements ValueReader<DecimalData> {\n+    private final ValueReader<byte[]> bytesReader;\n+    private final int precision;\n+    private final int scale;\n+\n+    private DecimalReader(ValueReader<byte[]> bytesReader, int precision, int scale) {\n+      this.bytesReader = bytesReader;\n+      this.precision = precision;\n+      this.scale = scale;\n+    }\n+\n+    @Override\n+    public DecimalData read(Decoder decoder, Object reuse) throws IOException {\n+      byte[] bytes = bytesReader.read(decoder, null);\n+      return DecimalData.fromBigDecimal(new BigDecimal(new BigInteger(bytes), scale), precision, scale);\n+    }\n+  }\n+\n+  private static class TimeMicrosReader implements ValueReader<Integer> {\n+    private static final TimeMicrosReader INSTANCE = new TimeMicrosReader();\n+\n+    @Override\n+    public Integer read(Decoder decoder, Object reuse) throws IOException {\n+      long micros = decoder.readLong();\n+      // Flink only support time mills, just erase micros.\n+      return (int) (micros / 1000);\n+    }\n+  }\n+\n+  private static class TimestampMillsReader implements ValueReader<TimestampData> {\n+    private static final TimestampMillsReader INSTANCE = new TimestampMillsReader();\n+\n+    @Override\n+    public TimestampData read(Decoder decoder, Object reuse) throws IOException {\n+      return TimestampData.fromEpochMillis(decoder.readLong());\n+    }\n+  }\n+\n+  private static class TimestampMicrosReader implements ValueReader<TimestampData> {\n+    private static final TimestampMicrosReader INSTANCE = new TimestampMicrosReader();\n+\n+    @Override\n+    public TimestampData read(Decoder decoder, Object reuse) throws IOException {\n+      long micros = decoder.readLong();\n+      long mills = micros / 1000;\n+      int nanos = ((int) (micros % 1000)) * 1000;\n+      if (nanos < 0) {\n+        nanos += 1_000_000;\n+        mills -= 1;\n+      }\n+      return TimestampData.fromEpochMillis(mills, nanos);\n+    }\n+  }\n+\n+  private static class ArrayReader implements ValueReader<ArrayData> {\n+    private final ValueReader<?> elementReader;\n+    private final List<Object> reusedList = Lists.newArrayList();\n+\n+    private ArrayReader(ValueReader<?> elementReader) {\n+      this.elementReader = elementReader;\n+    }\n+\n+    @Override\n+    public GenericArrayData read(Decoder decoder, Object reuse) throws IOException {\n+      reusedList.clear();\n+      long chunkLength = decoder.readArrayStart();\n+\n+      while (chunkLength > 0) {\n+        for (int i = 0; i < chunkLength; i += 1) {\n+          reusedList.add(elementReader.read(decoder, null));\n+        }\n+\n+        chunkLength = decoder.arrayNext();\n+      }\n+\n+      // this will convert the list to an array so it is okay to reuse the list\n+      return new GenericArrayData(reusedList.toArray());\n+    }\n+  }\n+\n+  private static MapData kvArrayToMap(List<Object> keyList, List<Object> valueList) {\n+    Map<Object, Object> map = Maps.newHashMap();\n+    Object[] keys = keyList.toArray();\n+    Object[] values = valueList.toArray();\n+    for (int i = 0; i < keys.length; i++) {\n+      map.put(keys[i], values[i]);\n+    }\n+\n+    return new GenericMapData(map);\n+  }\n+\n+  private static class ArrayMapReader implements ValueReader<MapData> {\n+    private final ValueReader<?> keyReader;\n+    private final ValueReader<?> valueReader;\n+\n+    private final List<Object> reusedKeyList = Lists.newArrayList();\n+    private final List<Object> reusedValueList = Lists.newArrayList();\n+\n+    private ArrayMapReader(ValueReader<?> keyReader, ValueReader<?> valueReader) {\n+      this.keyReader = keyReader;\n+      this.valueReader = valueReader;\n+    }\n+\n+    @Override\n+    public MapData read(Decoder decoder, Object reuse) throws IOException {\n+      reusedKeyList.clear();\n+      reusedValueList.clear();\n+\n+      long chunkLength = decoder.readArrayStart();\n+\n+      while (chunkLength > 0) {\n+        for (int i = 0; i < chunkLength; i += 1) {\n+          reusedKeyList.add(keyReader.read(decoder, null));\n+          reusedValueList.add(valueReader.read(decoder, null));\n+        }\n+\n+        chunkLength = decoder.arrayNext();\n+      }\n+\n+      return kvArrayToMap(reusedKeyList, reusedValueList);\n+    }\n+  }\n+\n+  private static class MapReader implements ValueReader<MapData> {\n+    private final ValueReader<?> keyReader;\n+    private final ValueReader<?> valueReader;\n+\n+    private final List<Object> reusedKeyList = Lists.newArrayList();\n+    private final List<Object> reusedValueList = Lists.newArrayList();\n+\n+    private MapReader(ValueReader<?> keyReader, ValueReader<?> valueReader) {\n+      this.keyReader = keyReader;\n+      this.valueReader = valueReader;\n+    }\n+\n+    @Override\n+    public MapData read(Decoder decoder, Object reuse) throws IOException {\n+      reusedKeyList.clear();\n+      reusedValueList.clear();\n+\n+      long chunkLength = decoder.readMapStart();\n+\n+      while (chunkLength > 0) {\n+        for (int i = 0; i < chunkLength; i += 1) {\n+          reusedKeyList.add(keyReader.read(decoder, null));\n+          reusedValueList.add(valueReader.read(decoder, null));\n+        }\n+\n+        chunkLength = decoder.mapNext();\n+      }\n+\n+      return kvArrayToMap(reusedKeyList, reusedValueList);\n+    }\n+  }\n+\n+  static class StructReader extends ValueReaders.StructReader<RowData> {\n+    private final int numFields;\n+\n+    protected StructReader(List<ValueReader<?>> readers, Types.StructType struct, Map<Integer, ?> idToConstant) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dad83fcbea5253ce11eb23caa8f6f04f5fcd8c36"}, "originalPosition": 289}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMDQ0NTI0OnYy", "diffSide": "RIGHT", "path": "flink/src/main/java/org/apache/iceberg/flink/FlinkTypeVisitor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMDoxNToxNlrOG8ZB4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQwMjoyODo0N1rOG8hBAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk3NzgyNA==", "bodyText": "Does this need to be public? The only reference to FlinkTypeVisitor that I see in this PR is here, so I'm not sure why this is needed.", "url": "https://github.com/apache/iceberg/pull/1232#discussion_r465977824", "createdAt": "2020-08-05T20:15:16Z", "author": {"login": "rdblue"}, "path": "flink/src/main/java/org/apache/iceberg/flink/FlinkTypeVisitor.java", "diffHunk": "@@ -30,7 +30,7 @@\n import org.apache.flink.table.types.logical.YearMonthIntervalType;\n import org.apache.flink.table.types.logical.ZonedTimestampType;\n \n-abstract class FlinkTypeVisitor<T> implements LogicalTypeVisitor<T> {\n+public abstract class FlinkTypeVisitor<T> implements LogicalTypeVisitor<T> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a86efd9f48c0e630c8a5767d127a5aa0f02a309d"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjEwODY3NQ==", "bodyText": "No need, I used to think the reading and writing will rely on FlinkTypeVisitor.", "url": "https://github.com/apache/iceberg/pull/1232#discussion_r466108675", "createdAt": "2020-08-06T02:28:47Z", "author": {"login": "JingsongLi"}, "path": "flink/src/main/java/org/apache/iceberg/flink/FlinkTypeVisitor.java", "diffHunk": "@@ -30,7 +30,7 @@\n import org.apache.flink.table.types.logical.YearMonthIntervalType;\n import org.apache.flink.table.types.logical.ZonedTimestampType;\n \n-abstract class FlinkTypeVisitor<T> implements LogicalTypeVisitor<T> {\n+public abstract class FlinkTypeVisitor<T> implements LogicalTypeVisitor<T> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk3NzgyNA=="}, "originalCommit": {"oid": "a86efd9f48c0e630c8a5767d127a5aa0f02a309d"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMDUxNzI4OnYy", "diffSide": "RIGHT", "path": "flink/src/main/java/org/apache/iceberg/flink/data/FlinkValueWriters.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMDozODoxM1rOG8Zviw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMDozODoxM1rOG8Zviw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk4OTUxNQ==", "bodyText": "Eventually, we should refactor this into a base class for array data, so that the encoder parts are shared between Flink and Spark. Not something we should do right now, though.", "url": "https://github.com/apache/iceberg/pull/1232#discussion_r465989515", "createdAt": "2020-08-05T20:38:13Z", "author": {"login": "rdblue"}, "path": "flink/src/main/java/org/apache/iceberg/flink/data/FlinkValueWriters.java", "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink.data;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Array;\n+import java.util.List;\n+import org.apache.avro.io.Encoder;\n+import org.apache.avro.util.Utf8;\n+import org.apache.flink.table.data.ArrayData;\n+import org.apache.flink.table.data.DecimalData;\n+import org.apache.flink.table.data.MapData;\n+import org.apache.flink.table.data.RowData;\n+import org.apache.flink.table.data.StringData;\n+import org.apache.flink.table.data.TimestampData;\n+import org.apache.flink.table.types.logical.LogicalType;\n+import org.apache.iceberg.avro.ValueWriter;\n+import org.apache.iceberg.types.TypeUtil;\n+import org.apache.iceberg.util.DecimalUtil;\n+\n+public class FlinkValueWriters {\n+\n+  private FlinkValueWriters() {}\n+\n+  static ValueWriter<StringData> strings() {\n+    return StringWriter.INSTANCE;\n+  }\n+\n+  static ValueWriter<Integer> timeMicros() {\n+    return TimeMicrosWriter.INSTANCE;\n+  }\n+\n+  static ValueWriter<TimestampData> timestampMicros() {\n+    return TimestampMicrosWriter.INSTANCE;\n+  }\n+\n+  static ValueWriter<DecimalData> decimal(int precision, int scale) {\n+    return new DecimalWriter(precision, scale);\n+  }\n+\n+  static <T> ValueWriter<ArrayData> array(ValueWriter<T> elementWriter, LogicalType elementType) {\n+    return new ArrayWriter<>(elementWriter, elementType);\n+  }\n+\n+  static <K, V> ValueWriter<MapData> arrayMap(ValueWriter<K> keyWriter, LogicalType keyType,\n+                                              ValueWriter<V> valueWriter, LogicalType valueType) {\n+    return new ArrayMapWriter<>(keyWriter, keyType, valueWriter, valueType);\n+  }\n+\n+  static <K, V> ValueWriter<MapData> map(ValueWriter<K> keyWriter, LogicalType keyType,\n+                                         ValueWriter<V> valueWriter, LogicalType valueType) {\n+    return new MapWriter<>(keyWriter, keyType, valueWriter, valueType);\n+  }\n+\n+  static ValueWriter<RowData> row(List<ValueWriter<?>> writers, List<LogicalType> types) {\n+    return new RowWriter(writers, types);\n+  }\n+\n+  private static class StringWriter implements ValueWriter<StringData> {\n+    private static final StringWriter INSTANCE = new StringWriter();\n+\n+    private StringWriter() {\n+    }\n+\n+    @Override\n+    public void write(StringData s, Encoder encoder) throws IOException {\n+      // toBytes is cheaper than Avro calling toString, which incurs encoding costs\n+      encoder.writeString(new Utf8(s.toBytes()));\n+    }\n+  }\n+\n+  private static class DecimalWriter implements ValueWriter<DecimalData> {\n+    private final int precision;\n+    private final int scale;\n+    private final ThreadLocal<byte[]> bytes;\n+\n+    private DecimalWriter(int precision, int scale) {\n+      this.precision = precision;\n+      this.scale = scale;\n+      this.bytes = ThreadLocal.withInitial(() -> new byte[TypeUtil.decimalRequiredBytes(precision)]);\n+    }\n+\n+    @Override\n+    public void write(DecimalData d, Encoder encoder) throws IOException {\n+      encoder.writeFixed(DecimalUtil.toReusedFixLengthBytes(precision, scale, d.toBigDecimal(), bytes.get()));\n+    }\n+  }\n+\n+  private static class TimeMicrosWriter implements ValueWriter<Integer> {\n+    private static final TimeMicrosWriter INSTANCE = new TimeMicrosWriter();\n+\n+    @Override\n+    public void write(Integer timeMills, Encoder encoder) throws IOException {\n+      encoder.writeLong(timeMills * 1000);\n+    }\n+  }\n+\n+  private static class TimestampMicrosWriter implements ValueWriter<TimestampData> {\n+    private static final TimestampMicrosWriter INSTANCE = new TimestampMicrosWriter();\n+\n+    @Override\n+    public void write(TimestampData timestampData, Encoder encoder) throws IOException {\n+      long micros = timestampData.getMillisecond() * 1000 + timestampData.getNanoOfMillisecond() / 1000;\n+      encoder.writeLong(micros);\n+    }\n+  }\n+\n+  private static class ArrayWriter<T> implements ValueWriter<ArrayData> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a86efd9f48c0e630c8a5767d127a5aa0f02a309d"}, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMDUzODA5OnYy", "diffSide": "RIGHT", "path": "flink/src/test/java/org/apache/iceberg/flink/data/TestFlinkAvroReaderWriter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMDo0NDozNlrOG8Z8Tw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQwMjoyNjozOVrOG8g-xA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk5Mjc4Mw==", "bodyText": "I think it would be better to validate Flink RowData against generic Record. That's what we do in Spark tests, where we first write using generics (or Avro in older tests) and then validate that the records we read using the Spark object model are equivalent. By doing that, you not only test that RowData to disk and back to RowData works, but that the records are actually equivalent to another read format.", "url": "https://github.com/apache/iceberg/pull/1232#discussion_r465992783", "createdAt": "2020-08-05T20:44:36Z", "author": {"login": "rdblue"}, "path": "flink/src/test/java/org/apache/iceberg/flink/data/TestFlinkAvroReaderWriter.java", "diffHunk": "@@ -22,52 +22,76 @@\n import java.io.File;\n import java.io.IOException;\n import java.util.Iterator;\n-import org.apache.flink.types.Row;\n+import java.util.List;\n+import org.apache.flink.table.data.RowData;\n import org.apache.iceberg.Files;\n import org.apache.iceberg.Schema;\n import org.apache.iceberg.avro.Avro;\n+import org.apache.iceberg.data.DataTest;\n+import org.apache.iceberg.data.RandomGenericData;\n+import org.apache.iceberg.data.Record;\n+import org.apache.iceberg.data.avro.DataWriter;\n+import org.apache.iceberg.flink.FlinkSchemaUtil;\n import org.apache.iceberg.io.CloseableIterable;\n import org.apache.iceberg.io.FileAppender;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n import org.junit.Assert;\n-import org.junit.Rule;\n-import org.junit.Test;\n-import org.junit.rules.TemporaryFolder;\n \n-import static org.apache.iceberg.flink.data.RandomData.COMPLEX_SCHEMA;\n+public class TestFlinkAvroReaderWriter extends DataTest {\n \n-public class TestFlinkAvroReaderWriter {\n-  private static final int NUM_RECORDS = 20_000;\n+  private static final int NUM_RECORDS = 100;\n \n-  @Rule\n-  public TemporaryFolder temp = new TemporaryFolder();\n+  @Override\n+  protected void writeAndValidate(Schema schema) throws IOException {\n+    List<RowData> inputs = generateDataFromAvroFile(schema);\n \n-  private void testCorrectness(Schema schema, int numRecords, Iterable<Row> iterable) throws IOException {\n     File testFile = temp.newFile();\n     Assert.assertTrue(\"Delete should succeed\", testFile.delete());\n \n-    try (FileAppender<Row> writer = Avro.write(Files.localOutput(testFile))\n+    try (FileAppender<RowData> writer = Avro.write(Files.localOutput(testFile))\n         .schema(schema)\n-        .createWriterFunc(FlinkAvroWriter::new)\n+        .createWriterFunc(ignore -> new FlinkAvroWriter(FlinkSchemaUtil.convert(schema)))\n         .build()) {\n-      writer.addAll(iterable);\n+      writer.addAll(inputs);\n     }\n \n-    try (CloseableIterable<Row> reader = Avro.read(Files.localInput(testFile))\n+    try (CloseableIterable<RowData> reader = Avro.read(Files.localInput(testFile))\n         .project(schema)\n         .createReaderFunc(FlinkAvroReader::new)\n         .build()) {\n-      Iterator<Row> expected = iterable.iterator();\n-      Iterator<Row> rows = reader.iterator();\n-      for (int i = 0; i < numRecords; i += 1) {\n+      Iterator<RowData> expected = inputs.iterator();\n+      Iterator<RowData> rows = reader.iterator();\n+      for (int i = 0; i < NUM_RECORDS; i += 1) {\n         Assert.assertTrue(\"Should have expected number of rows\", rows.hasNext());\n         Assert.assertEquals(expected.next(), rows.next());\n       }\n       Assert.assertFalse(\"Should not have extra rows\", rows.hasNext());\n     }\n   }\n \n-  @Test\n-  public void testNormalData() throws IOException {\n-    testCorrectness(COMPLEX_SCHEMA, NUM_RECORDS, RandomData.generate(COMPLEX_SCHEMA, NUM_RECORDS, 19982));\n+  private List<RowData> generateDataFromAvroFile(Schema schema) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a86efd9f48c0e630c8a5767d127a5aa0f02a309d"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjEwODEwMA==", "bodyText": "You are right, we should have a asserter for RowData and Record.", "url": "https://github.com/apache/iceberg/pull/1232#discussion_r466108100", "createdAt": "2020-08-06T02:26:39Z", "author": {"login": "JingsongLi"}, "path": "flink/src/test/java/org/apache/iceberg/flink/data/TestFlinkAvroReaderWriter.java", "diffHunk": "@@ -22,52 +22,76 @@\n import java.io.File;\n import java.io.IOException;\n import java.util.Iterator;\n-import org.apache.flink.types.Row;\n+import java.util.List;\n+import org.apache.flink.table.data.RowData;\n import org.apache.iceberg.Files;\n import org.apache.iceberg.Schema;\n import org.apache.iceberg.avro.Avro;\n+import org.apache.iceberg.data.DataTest;\n+import org.apache.iceberg.data.RandomGenericData;\n+import org.apache.iceberg.data.Record;\n+import org.apache.iceberg.data.avro.DataWriter;\n+import org.apache.iceberg.flink.FlinkSchemaUtil;\n import org.apache.iceberg.io.CloseableIterable;\n import org.apache.iceberg.io.FileAppender;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n import org.junit.Assert;\n-import org.junit.Rule;\n-import org.junit.Test;\n-import org.junit.rules.TemporaryFolder;\n \n-import static org.apache.iceberg.flink.data.RandomData.COMPLEX_SCHEMA;\n+public class TestFlinkAvroReaderWriter extends DataTest {\n \n-public class TestFlinkAvroReaderWriter {\n-  private static final int NUM_RECORDS = 20_000;\n+  private static final int NUM_RECORDS = 100;\n \n-  @Rule\n-  public TemporaryFolder temp = new TemporaryFolder();\n+  @Override\n+  protected void writeAndValidate(Schema schema) throws IOException {\n+    List<RowData> inputs = generateDataFromAvroFile(schema);\n \n-  private void testCorrectness(Schema schema, int numRecords, Iterable<Row> iterable) throws IOException {\n     File testFile = temp.newFile();\n     Assert.assertTrue(\"Delete should succeed\", testFile.delete());\n \n-    try (FileAppender<Row> writer = Avro.write(Files.localOutput(testFile))\n+    try (FileAppender<RowData> writer = Avro.write(Files.localOutput(testFile))\n         .schema(schema)\n-        .createWriterFunc(FlinkAvroWriter::new)\n+        .createWriterFunc(ignore -> new FlinkAvroWriter(FlinkSchemaUtil.convert(schema)))\n         .build()) {\n-      writer.addAll(iterable);\n+      writer.addAll(inputs);\n     }\n \n-    try (CloseableIterable<Row> reader = Avro.read(Files.localInput(testFile))\n+    try (CloseableIterable<RowData> reader = Avro.read(Files.localInput(testFile))\n         .project(schema)\n         .createReaderFunc(FlinkAvroReader::new)\n         .build()) {\n-      Iterator<Row> expected = iterable.iterator();\n-      Iterator<Row> rows = reader.iterator();\n-      for (int i = 0; i < numRecords; i += 1) {\n+      Iterator<RowData> expected = inputs.iterator();\n+      Iterator<RowData> rows = reader.iterator();\n+      for (int i = 0; i < NUM_RECORDS; i += 1) {\n         Assert.assertTrue(\"Should have expected number of rows\", rows.hasNext());\n         Assert.assertEquals(expected.next(), rows.next());\n       }\n       Assert.assertFalse(\"Should not have extra rows\", rows.hasNext());\n     }\n   }\n \n-  @Test\n-  public void testNormalData() throws IOException {\n-    testCorrectness(COMPLEX_SCHEMA, NUM_RECORDS, RandomData.generate(COMPLEX_SCHEMA, NUM_RECORDS, 19982));\n+  private List<RowData> generateDataFromAvroFile(Schema schema) throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk5Mjc4Mw=="}, "originalCommit": {"oid": "a86efd9f48c0e630c8a5767d127a5aa0f02a309d"}, "originalPosition": 71}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3787, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}