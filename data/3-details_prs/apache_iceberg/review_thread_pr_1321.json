{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY1ODc5NjIw", "number": 1321, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwNDowODoxOVrOEXdoOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxNjozNDo0MFrOEYiV6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMDM4MTM5OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/iceberg/avro/PruneColumns.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwNDowODoxOVrOG_REvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwNToxMDoyMVrOG_R_7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODk5MzIxMw==", "bodyText": "I wonder if we should solve this in a different way. The issue is that when complex value types are involved for logical maps the key is not projected. Then why don't we project the key field if the map's  value field is projected?\nWould it be better to change the map method in GetProjectedIds to always project the keyField if valueResult is not null instead of changing PruneColumns?\nWhat do you guys think @rdblue, @lxynov ?", "url": "https://github.com/apache/iceberg/pull/1321#discussion_r468993213", "createdAt": "2020-08-12T04:08:19Z", "author": {"login": "rdsr"}, "path": "core/src/main/java/org/apache/iceberg/avro/PruneColumns.java", "diffHunk": "@@ -144,16 +144,18 @@ public Schema array(Schema array, Schema element) {\n       if (selectedIds.contains(keyId) || selectedIds.contains(valueId)) {\n         return complexMapWithIds(array, keyId, valueId);\n       } else if (element != null) {\n-        Schema keyProjection = element.getField(\"key\").schema();\n+        Schema.Field keyProjectionField = element.getField(\"key\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66d42076801b26f2965959f8786938a2ee4121c4"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAwMTgzMQ==", "bodyText": "Discussing with @rdsr offline, also posting here for @rdblue 's visibility\nI tried to always project the keyField but encountered two issues:\n\nTestGenericReadProjection in Parquet fails somehow. (I haven't spent time looking into how to resolve it)\nWe'll still need to change PruneColumns because its current logic is // if either key or value is selected, the whole map must be projected.\n\n@rdsr @rdblue what are your thoughts? I think we can make it to always project keyField but it may need some efforts", "url": "https://github.com/apache/iceberg/pull/1321#discussion_r469001831", "createdAt": "2020-08-12T04:43:50Z", "author": {"login": "lxynov"}, "path": "core/src/main/java/org/apache/iceberg/avro/PruneColumns.java", "diffHunk": "@@ -144,16 +144,18 @@ public Schema array(Schema array, Schema element) {\n       if (selectedIds.contains(keyId) || selectedIds.contains(valueId)) {\n         return complexMapWithIds(array, keyId, valueId);\n       } else if (element != null) {\n-        Schema keyProjection = element.getField(\"key\").schema();\n+        Schema.Field keyProjectionField = element.getField(\"key\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODk5MzIxMw=="}, "originalCommit": {"oid": "66d42076801b26f2965959f8786938a2ee4121c4"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAwODM2Nw==", "bodyText": "I understand now, specially bullet item 2 makes sense to me.", "url": "https://github.com/apache/iceberg/pull/1321#discussion_r469008367", "createdAt": "2020-08-12T05:10:21Z", "author": {"login": "rdsr"}, "path": "core/src/main/java/org/apache/iceberg/avro/PruneColumns.java", "diffHunk": "@@ -144,16 +144,18 @@ public Schema array(Schema array, Schema element) {\n       if (selectedIds.contains(keyId) || selectedIds.contains(valueId)) {\n         return complexMapWithIds(array, keyId, valueId);\n       } else if (element != null) {\n-        Schema keyProjection = element.getField(\"key\").schema();\n+        Schema.Field keyProjectionField = element.getField(\"key\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODk5MzIxMw=="}, "originalCommit": {"oid": "66d42076801b26f2965959f8786938a2ee4121c4"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzODkzNDY1OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/org/apache/iceberg/avro/TestAvroReadProjection.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQwMDowOToxOFrOHAh0Rw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQwMjo1NDo0OVrOHAl00g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDMxNjEwMw==", "bodyText": "Looks like indentation is off here. The project uses 2 spaces per indent, and 2 indents for continuation lines like this. Could you fix this method please?", "url": "https://github.com/apache/iceberg/pull/1321#discussion_r470316103", "createdAt": "2020-08-14T00:09:18Z", "author": {"login": "rdblue"}, "path": "core/src/test/java/org/apache/iceberg/avro/TestAvroReadProjection.java", "diffHunk": "@@ -49,4 +56,27 @@\n \n     return Iterables.getOnlyElement(records);\n   }\n+\n+  @Test\n+  public void testAvroArrayAsLogicalMap() throws IOException {\n+    Schema writeSchema = new Schema(\n+            Types.NestedField.optional(0, \"map\", Types.MapType.ofOptional(2, 3,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66d42076801b26f2965959f8786938a2ee4121c4"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM4MTc3OA==", "bodyText": "Oh right, just updated it.", "url": "https://github.com/apache/iceberg/pull/1321#discussion_r470381778", "createdAt": "2020-08-14T02:54:49Z", "author": {"login": "lxynov"}, "path": "core/src/test/java/org/apache/iceberg/avro/TestAvroReadProjection.java", "diffHunk": "@@ -49,4 +56,27 @@\n \n     return Iterables.getOnlyElement(records);\n   }\n+\n+  @Test\n+  public void testAvroArrayAsLogicalMap() throws IOException {\n+    Schema writeSchema = new Schema(\n+            Types.NestedField.optional(0, \"map\", Types.MapType.ofOptional(2, 3,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDMxNjEwMw=="}, "originalCommit": {"oid": "66d42076801b26f2965959f8786938a2ee4121c4"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0MTYzOTQ2OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/org/apache/iceberg/avro/TestAvroReadProjection.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxNjozNDo0MFrOHA7LeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxOTo1NjozOVrOHBBqvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDczMTY0MQ==", "bodyText": "Looks like this wasn't updated.", "url": "https://github.com/apache/iceberg/pull/1321#discussion_r470731641", "createdAt": "2020-08-14T16:34:40Z", "author": {"login": "rdblue"}, "path": "core/src/test/java/org/apache/iceberg/avro/TestAvroReadProjection.java", "diffHunk": "@@ -49,4 +56,27 @@\n \n     return Iterables.getOnlyElement(records);\n   }\n+\n+  @Test\n+  public void testAvroArrayAsLogicalMap() throws IOException {\n+    Schema writeSchema = new Schema(\n+        Types.NestedField.optional(0, \"map\", Types.MapType.ofOptional(2, 3,\n+            Types.LongType.get(),\n+            Types.ListType.ofRequired(1, Types.LongType.get())\n+        ))\n+    );\n+\n+    List<Long> values1 = ImmutableList.of(101L, 102L);\n+    List<Long> values2 = ImmutableList.of(201L, 202L, 203L);\n+    GenericData.Record record = new GenericData.Record(AvroSchemaUtil.convert(writeSchema, \"table\"));\n+    record.put(\"map\", ImmutableMap.of(100L, values1, 200L, values2));\n+\n+    GenericData.Record projected = writeAndRead(\"full_projection\", writeSchema, writeSchema, record);\n+    Assert.assertEquals(\"Should contain correct value list\",\n+            values1,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "792050544be872c79a27ca0f1fabbe254cd22e73"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDgwOTMzMg==", "bodyText": "Oh my bad, just updated.", "url": "https://github.com/apache/iceberg/pull/1321#discussion_r470809332", "createdAt": "2020-08-14T18:49:40Z", "author": {"login": "lxynov"}, "path": "core/src/test/java/org/apache/iceberg/avro/TestAvroReadProjection.java", "diffHunk": "@@ -49,4 +56,27 @@\n \n     return Iterables.getOnlyElement(records);\n   }\n+\n+  @Test\n+  public void testAvroArrayAsLogicalMap() throws IOException {\n+    Schema writeSchema = new Schema(\n+        Types.NestedField.optional(0, \"map\", Types.MapType.ofOptional(2, 3,\n+            Types.LongType.get(),\n+            Types.ListType.ofRequired(1, Types.LongType.get())\n+        ))\n+    );\n+\n+    List<Long> values1 = ImmutableList.of(101L, 102L);\n+    List<Long> values2 = ImmutableList.of(201L, 202L, 203L);\n+    GenericData.Record record = new GenericData.Record(AvroSchemaUtil.convert(writeSchema, \"table\"));\n+    record.put(\"map\", ImmutableMap.of(100L, values1, 200L, values2));\n+\n+    GenericData.Record projected = writeAndRead(\"full_projection\", writeSchema, writeSchema, record);\n+    Assert.assertEquals(\"Should contain correct value list\",\n+            values1,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDczMTY0MQ=="}, "originalCommit": {"oid": "792050544be872c79a27ca0f1fabbe254cd22e73"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDgzNzk0OA==", "bodyText": "Thanks! I'll commit this when tests pass.", "url": "https://github.com/apache/iceberg/pull/1321#discussion_r470837948", "createdAt": "2020-08-14T19:56:39Z", "author": {"login": "rdblue"}, "path": "core/src/test/java/org/apache/iceberg/avro/TestAvroReadProjection.java", "diffHunk": "@@ -49,4 +56,27 @@\n \n     return Iterables.getOnlyElement(records);\n   }\n+\n+  @Test\n+  public void testAvroArrayAsLogicalMap() throws IOException {\n+    Schema writeSchema = new Schema(\n+        Types.NestedField.optional(0, \"map\", Types.MapType.ofOptional(2, 3,\n+            Types.LongType.get(),\n+            Types.ListType.ofRequired(1, Types.LongType.get())\n+        ))\n+    );\n+\n+    List<Long> values1 = ImmutableList.of(101L, 102L);\n+    List<Long> values2 = ImmutableList.of(201L, 202L, 203L);\n+    GenericData.Record record = new GenericData.Record(AvroSchemaUtil.convert(writeSchema, \"table\"));\n+    record.put(\"map\", ImmutableMap.of(100L, values1, 200L, values2));\n+\n+    GenericData.Record projected = writeAndRead(\"full_projection\", writeSchema, writeSchema, record);\n+    Assert.assertEquals(\"Should contain correct value list\",\n+            values1,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDczMTY0MQ=="}, "originalCommit": {"oid": "792050544be872c79a27ca0f1fabbe254cd22e73"}, "originalPosition": 40}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3628, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}