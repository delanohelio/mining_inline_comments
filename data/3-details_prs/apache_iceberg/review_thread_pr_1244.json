{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU2NTA5MTY4", "number": 1244, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQyMzowMjoyOFrOER_Osg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxNjo0MDo0OVrOES5Ztg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3Mjk3MjAyOnYy", "diffSide": "RIGHT", "path": "core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQyMzowMjoyOVrOG2_4fg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQyMzoyMjoxN1rOG3AKYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDMyMjk0Mg==", "bodyText": "It seems kind of counterintuitive to pass a deleteWith but still expect that the files won't be deleted?\nWhat about defining a default method instead which does nothing eg: doNothing, and make it available as a handy reference which people could use instead? So it would look something like table.expireSnapshots().deleteWith(doNothing)", "url": "https://github.com/apache/iceberg/pull/1244#discussion_r460322942", "createdAt": "2020-07-24T23:02:29Z", "author": {"login": "moulimukherjee"}, "path": "core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java", "diffHunk": "@@ -472,6 +472,55 @@ public void dataFilesCleanup() throws IOException {\n     Assert.assertTrue(\"FILE_B should be deleted\", deletedFiles.contains(FILE_B.path().toString()));\n   }\n \n+  @Test\n+  public void noDataFileCleanup() throws IOException {\n+    table.newFastAppend()\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    table.newFastAppend()\n+        .appendFile(FILE_B)\n+        .commit();\n+\n+    table.newRewrite()\n+        .rewriteFiles(ImmutableSet.of(FILE_B), ImmutableSet.of(FILE_D))\n+        .commit();\n+    long thirdSnapshotId = table.currentSnapshot().snapshotId();\n+\n+    table.newRewrite()\n+        .rewriteFiles(ImmutableSet.of(FILE_A), ImmutableSet.of(FILE_C))\n+        .commit();\n+    long fourthSnapshotId = table.currentSnapshot().snapshotId();\n+\n+    long t4 = System.currentTimeMillis();\n+    while (t4 <= table.currentSnapshot().timestampMillis()) {\n+      t4 = System.currentTimeMillis();\n+    }\n+\n+    List<ManifestFile> manifests = table.currentSnapshot().dataManifests();\n+\n+    ManifestFile newManifest = writeManifest(\n+        \"manifest-file-1.avro\",\n+        manifestEntry(Status.EXISTING, thirdSnapshotId, FILE_C),\n+        manifestEntry(Status.EXISTING, fourthSnapshotId, FILE_D));\n+\n+    RewriteManifests rewriteManifests = table.rewriteManifests();\n+    manifests.forEach(rewriteManifests::deleteManifest);\n+    rewriteManifests.addManifest(newManifest);\n+    rewriteManifests.commit();\n+\n+    Set<String> deletedFiles = Sets.newHashSet();\n+\n+    table.expireSnapshots()\n+        .deleteExpiredFiles(false)\n+        .expireOlderThan(t4)\n+        .deleteWith(deletedFiles::add)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7af6a37446c054d8983aae5db91350dd9c70e56b"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDMyNDUyMQ==", "bodyText": "Oh, is it to prevent iteration through callback for each deleted file? Actually that makes sense. If so, please ignore ^.", "url": "https://github.com/apache/iceberg/pull/1244#discussion_r460324521", "createdAt": "2020-07-24T23:08:52Z", "author": {"login": "moulimukherjee"}, "path": "core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java", "diffHunk": "@@ -472,6 +472,55 @@ public void dataFilesCleanup() throws IOException {\n     Assert.assertTrue(\"FILE_B should be deleted\", deletedFiles.contains(FILE_B.path().toString()));\n   }\n \n+  @Test\n+  public void noDataFileCleanup() throws IOException {\n+    table.newFastAppend()\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    table.newFastAppend()\n+        .appendFile(FILE_B)\n+        .commit();\n+\n+    table.newRewrite()\n+        .rewriteFiles(ImmutableSet.of(FILE_B), ImmutableSet.of(FILE_D))\n+        .commit();\n+    long thirdSnapshotId = table.currentSnapshot().snapshotId();\n+\n+    table.newRewrite()\n+        .rewriteFiles(ImmutableSet.of(FILE_A), ImmutableSet.of(FILE_C))\n+        .commit();\n+    long fourthSnapshotId = table.currentSnapshot().snapshotId();\n+\n+    long t4 = System.currentTimeMillis();\n+    while (t4 <= table.currentSnapshot().timestampMillis()) {\n+      t4 = System.currentTimeMillis();\n+    }\n+\n+    List<ManifestFile> manifests = table.currentSnapshot().dataManifests();\n+\n+    ManifestFile newManifest = writeManifest(\n+        \"manifest-file-1.avro\",\n+        manifestEntry(Status.EXISTING, thirdSnapshotId, FILE_C),\n+        manifestEntry(Status.EXISTING, fourthSnapshotId, FILE_D));\n+\n+    RewriteManifests rewriteManifests = table.rewriteManifests();\n+    manifests.forEach(rewriteManifests::deleteManifest);\n+    rewriteManifests.addManifest(newManifest);\n+    rewriteManifests.commit();\n+\n+    Set<String> deletedFiles = Sets.newHashSet();\n+\n+    table.expireSnapshots()\n+        .deleteExpiredFiles(false)\n+        .expireOlderThan(t4)\n+        .deleteWith(deletedFiles::add)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDMyMjk0Mg=="}, "originalCommit": {"oid": "7af6a37446c054d8983aae5db91350dd9c70e56b"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDMyNjY4OQ==", "bodyText": "Yeah, this is how all the tests in this class function. They use the \"add\" to set delete action to see whether the delete action gets triggered and on what files.", "url": "https://github.com/apache/iceberg/pull/1244#discussion_r460326689", "createdAt": "2020-07-24T23:18:29Z", "author": {"login": "RussellSpitzer"}, "path": "core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java", "diffHunk": "@@ -472,6 +472,55 @@ public void dataFilesCleanup() throws IOException {\n     Assert.assertTrue(\"FILE_B should be deleted\", deletedFiles.contains(FILE_B.path().toString()));\n   }\n \n+  @Test\n+  public void noDataFileCleanup() throws IOException {\n+    table.newFastAppend()\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    table.newFastAppend()\n+        .appendFile(FILE_B)\n+        .commit();\n+\n+    table.newRewrite()\n+        .rewriteFiles(ImmutableSet.of(FILE_B), ImmutableSet.of(FILE_D))\n+        .commit();\n+    long thirdSnapshotId = table.currentSnapshot().snapshotId();\n+\n+    table.newRewrite()\n+        .rewriteFiles(ImmutableSet.of(FILE_A), ImmutableSet.of(FILE_C))\n+        .commit();\n+    long fourthSnapshotId = table.currentSnapshot().snapshotId();\n+\n+    long t4 = System.currentTimeMillis();\n+    while (t4 <= table.currentSnapshot().timestampMillis()) {\n+      t4 = System.currentTimeMillis();\n+    }\n+\n+    List<ManifestFile> manifests = table.currentSnapshot().dataManifests();\n+\n+    ManifestFile newManifest = writeManifest(\n+        \"manifest-file-1.avro\",\n+        manifestEntry(Status.EXISTING, thirdSnapshotId, FILE_C),\n+        manifestEntry(Status.EXISTING, fourthSnapshotId, FILE_D));\n+\n+    RewriteManifests rewriteManifests = table.rewriteManifests();\n+    manifests.forEach(rewriteManifests::deleteManifest);\n+    rewriteManifests.addManifest(newManifest);\n+    rewriteManifests.commit();\n+\n+    Set<String> deletedFiles = Sets.newHashSet();\n+\n+    table.expireSnapshots()\n+        .deleteExpiredFiles(false)\n+        .expireOlderThan(t4)\n+        .deleteWith(deletedFiles::add)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDMyMjk0Mg=="}, "originalCommit": {"oid": "7af6a37446c054d8983aae5db91350dd9c70e56b"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDMyNzUyMg==", "bodyText": "Ack. (To clarify, was not commenting on the test per se, I should have made it a general comment rather than on this particular line)", "url": "https://github.com/apache/iceberg/pull/1244#discussion_r460327522", "createdAt": "2020-07-24T23:22:17Z", "author": {"login": "moulimukherjee"}, "path": "core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java", "diffHunk": "@@ -472,6 +472,55 @@ public void dataFilesCleanup() throws IOException {\n     Assert.assertTrue(\"FILE_B should be deleted\", deletedFiles.contains(FILE_B.path().toString()));\n   }\n \n+  @Test\n+  public void noDataFileCleanup() throws IOException {\n+    table.newFastAppend()\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    table.newFastAppend()\n+        .appendFile(FILE_B)\n+        .commit();\n+\n+    table.newRewrite()\n+        .rewriteFiles(ImmutableSet.of(FILE_B), ImmutableSet.of(FILE_D))\n+        .commit();\n+    long thirdSnapshotId = table.currentSnapshot().snapshotId();\n+\n+    table.newRewrite()\n+        .rewriteFiles(ImmutableSet.of(FILE_A), ImmutableSet.of(FILE_C))\n+        .commit();\n+    long fourthSnapshotId = table.currentSnapshot().snapshotId();\n+\n+    long t4 = System.currentTimeMillis();\n+    while (t4 <= table.currentSnapshot().timestampMillis()) {\n+      t4 = System.currentTimeMillis();\n+    }\n+\n+    List<ManifestFile> manifests = table.currentSnapshot().dataManifests();\n+\n+    ManifestFile newManifest = writeManifest(\n+        \"manifest-file-1.avro\",\n+        manifestEntry(Status.EXISTING, thirdSnapshotId, FILE_C),\n+        manifestEntry(Status.EXISTING, fourthSnapshotId, FILE_D));\n+\n+    RewriteManifests rewriteManifests = table.rewriteManifests();\n+    manifests.forEach(rewriteManifests::deleteManifest);\n+    rewriteManifests.addManifest(newManifest);\n+    rewriteManifests.commit();\n+\n+    Set<String> deletedFiles = Sets.newHashSet();\n+\n+    table.expireSnapshots()\n+        .deleteExpiredFiles(false)\n+        .expireOlderThan(t4)\n+        .deleteWith(deletedFiles::add)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDMyMjk0Mg=="}, "originalCommit": {"oid": "7af6a37446c054d8983aae5db91350dd9c70e56b"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3Nzk4Mjc2OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/apache/iceberg/ExpireSnapshots.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxNjozMzo1NVrOG3qWbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxNjozMzo1NVrOG3qWbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTAxODczMg==", "bodyText": "Nit: No need for </p> in Javadoc.", "url": "https://github.com/apache/iceberg/pull/1244#discussion_r461018732", "createdAt": "2020-07-27T16:33:55Z", "author": {"login": "rdblue"}, "path": "api/src/main/java/org/apache/iceberg/ExpireSnapshots.java", "diffHunk": "@@ -82,4 +82,16 @@\n    * @return this for method chaining\n    */\n   ExpireSnapshots deleteWith(Consumer<String> deleteFunc);\n+\n+  /**\n+   * Allows expiration of snapshots without any cleanup of underlying manifest or data files.\n+   * <p>\n+   * Allows control in removing data and manifest files which may be more efficiently removed using\n+   * a distributed framework through the actions API.\n+   * </p>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7af6a37446c054d8983aae5db91350dd9c70e56b"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3Nzk4NTgzOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/apache/iceberg/ExpireSnapshots.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxNjozNDo1MFrOG3qYew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxNjo0MjoxNlrOG3qqLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTAxOTI1OQ==", "bodyText": "Should this be cleanExpiredFiles instead? I think that makes more sense because this actually avoids the work of finding the files that have expired, not calling delete for them. And that's what you call it elsewhere, so it makes sense to me.", "url": "https://github.com/apache/iceberg/pull/1244#discussion_r461019259", "createdAt": "2020-07-27T16:34:50Z", "author": {"login": "rdblue"}, "path": "api/src/main/java/org/apache/iceberg/ExpireSnapshots.java", "diffHunk": "@@ -82,4 +82,16 @@\n    * @return this for method chaining\n    */\n   ExpireSnapshots deleteWith(Consumer<String> deleteFunc);\n+\n+  /**\n+   * Allows expiration of snapshots without any cleanup of underlying manifest or data files.\n+   * <p>\n+   * Allows control in removing data and manifest files which may be more efficiently removed using\n+   * a distributed framework through the actions API.\n+   * </p>\n+   *\n+   * @param clean setting this to false will skip deleting expired manifests and files\n+   * @return this for method chaining\n+   */\n+  ExpireSnapshots deleteExpiredFiles(boolean clean);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7af6a37446c054d8983aae5db91350dd9c70e56b"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTAyMzc5MQ==", "bodyText": "sgtm", "url": "https://github.com/apache/iceberg/pull/1244#discussion_r461023791", "createdAt": "2020-07-27T16:42:16Z", "author": {"login": "RussellSpitzer"}, "path": "api/src/main/java/org/apache/iceberg/ExpireSnapshots.java", "diffHunk": "@@ -82,4 +82,16 @@\n    * @return this for method chaining\n    */\n   ExpireSnapshots deleteWith(Consumer<String> deleteFunc);\n+\n+  /**\n+   * Allows expiration of snapshots without any cleanup of underlying manifest or data files.\n+   * <p>\n+   * Allows control in removing data and manifest files which may be more efficiently removed using\n+   * a distributed framework through the actions API.\n+   * </p>\n+   *\n+   * @param clean setting this to false will skip deleting expired manifests and files\n+   * @return this for method chaining\n+   */\n+  ExpireSnapshots deleteExpiredFiles(boolean clean);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTAxOTI1OQ=="}, "originalCommit": {"oid": "7af6a37446c054d8983aae5db91350dd9c70e56b"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3Nzk5Njg1OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxNjozNzo1OFrOG3qflQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxNjo0MTo1N1rOG3qpXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTAyMTA3Nw==", "bodyText": "Why rewrite manifests? It seems like the intent was to rewrite manifests so that the manifests from the third and fourth snapshots can be deleted, then to add assertions that the metadata files are also not cleaned.", "url": "https://github.com/apache/iceberg/pull/1244#discussion_r461021077", "createdAt": "2020-07-27T16:37:58Z", "author": {"login": "rdblue"}, "path": "core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java", "diffHunk": "@@ -472,6 +472,55 @@ public void dataFilesCleanup() throws IOException {\n     Assert.assertTrue(\"FILE_B should be deleted\", deletedFiles.contains(FILE_B.path().toString()));\n   }\n \n+  @Test\n+  public void noDataFileCleanup() throws IOException {\n+    table.newFastAppend()\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    table.newFastAppend()\n+        .appendFile(FILE_B)\n+        .commit();\n+\n+    table.newRewrite()\n+        .rewriteFiles(ImmutableSet.of(FILE_B), ImmutableSet.of(FILE_D))\n+        .commit();\n+    long thirdSnapshotId = table.currentSnapshot().snapshotId();\n+\n+    table.newRewrite()\n+        .rewriteFiles(ImmutableSet.of(FILE_A), ImmutableSet.of(FILE_C))\n+        .commit();\n+    long fourthSnapshotId = table.currentSnapshot().snapshotId();\n+\n+    long t4 = System.currentTimeMillis();\n+    while (t4 <= table.currentSnapshot().timestampMillis()) {\n+      t4 = System.currentTimeMillis();\n+    }\n+\n+    List<ManifestFile> manifests = table.currentSnapshot().dataManifests();\n+\n+    ManifestFile newManifest = writeManifest(\n+        \"manifest-file-1.avro\",\n+        manifestEntry(Status.EXISTING, thirdSnapshotId, FILE_C),\n+        manifestEntry(Status.EXISTING, fourthSnapshotId, FILE_D));\n+\n+    RewriteManifests rewriteManifests = table.rewriteManifests();\n+    manifests.forEach(rewriteManifests::deleteManifest);\n+    rewriteManifests.addManifest(newManifest);\n+    rewriteManifests.commit();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7af6a37446c054d8983aae5db91350dd9c70e56b"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTAyMzU4Mw==", "bodyText": "Ah I just copied the other test without actually reading through it :)", "url": "https://github.com/apache/iceberg/pull/1244#discussion_r461023583", "createdAt": "2020-07-27T16:41:57Z", "author": {"login": "RussellSpitzer"}, "path": "core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java", "diffHunk": "@@ -472,6 +472,55 @@ public void dataFilesCleanup() throws IOException {\n     Assert.assertTrue(\"FILE_B should be deleted\", deletedFiles.contains(FILE_B.path().toString()));\n   }\n \n+  @Test\n+  public void noDataFileCleanup() throws IOException {\n+    table.newFastAppend()\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    table.newFastAppend()\n+        .appendFile(FILE_B)\n+        .commit();\n+\n+    table.newRewrite()\n+        .rewriteFiles(ImmutableSet.of(FILE_B), ImmutableSet.of(FILE_D))\n+        .commit();\n+    long thirdSnapshotId = table.currentSnapshot().snapshotId();\n+\n+    table.newRewrite()\n+        .rewriteFiles(ImmutableSet.of(FILE_A), ImmutableSet.of(FILE_C))\n+        .commit();\n+    long fourthSnapshotId = table.currentSnapshot().snapshotId();\n+\n+    long t4 = System.currentTimeMillis();\n+    while (t4 <= table.currentSnapshot().timestampMillis()) {\n+      t4 = System.currentTimeMillis();\n+    }\n+\n+    List<ManifestFile> manifests = table.currentSnapshot().dataManifests();\n+\n+    ManifestFile newManifest = writeManifest(\n+        \"manifest-file-1.avro\",\n+        manifestEntry(Status.EXISTING, thirdSnapshotId, FILE_C),\n+        manifestEntry(Status.EXISTING, fourthSnapshotId, FILE_D));\n+\n+    RewriteManifests rewriteManifests = table.rewriteManifests();\n+    manifests.forEach(rewriteManifests::deleteManifest);\n+    rewriteManifests.addManifest(newManifest);\n+    rewriteManifests.commit();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTAyMTA3Nw=="}, "originalCommit": {"oid": "7af6a37446c054d8983aae5db91350dd9c70e56b"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3Nzk5ODc2OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxNjozODozMVrOG3qgvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxNjozODozMVrOG3qgvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTAyMTM3NQ==", "bodyText": "It would be good to have an assertion for at least one of the manifests that isn't deleted as well.\nAlternatively, you could just assert that deletedFiles.isEmpty()", "url": "https://github.com/apache/iceberg/pull/1244#discussion_r461021375", "createdAt": "2020-07-27T16:38:31Z", "author": {"login": "rdblue"}, "path": "core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java", "diffHunk": "@@ -472,6 +472,55 @@ public void dataFilesCleanup() throws IOException {\n     Assert.assertTrue(\"FILE_B should be deleted\", deletedFiles.contains(FILE_B.path().toString()));\n   }\n \n+  @Test\n+  public void noDataFileCleanup() throws IOException {\n+    table.newFastAppend()\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    table.newFastAppend()\n+        .appendFile(FILE_B)\n+        .commit();\n+\n+    table.newRewrite()\n+        .rewriteFiles(ImmutableSet.of(FILE_B), ImmutableSet.of(FILE_D))\n+        .commit();\n+    long thirdSnapshotId = table.currentSnapshot().snapshotId();\n+\n+    table.newRewrite()\n+        .rewriteFiles(ImmutableSet.of(FILE_A), ImmutableSet.of(FILE_C))\n+        .commit();\n+    long fourthSnapshotId = table.currentSnapshot().snapshotId();\n+\n+    long t4 = System.currentTimeMillis();\n+    while (t4 <= table.currentSnapshot().timestampMillis()) {\n+      t4 = System.currentTimeMillis();\n+    }\n+\n+    List<ManifestFile> manifests = table.currentSnapshot().dataManifests();\n+\n+    ManifestFile newManifest = writeManifest(\n+        \"manifest-file-1.avro\",\n+        manifestEntry(Status.EXISTING, thirdSnapshotId, FILE_C),\n+        manifestEntry(Status.EXISTING, fourthSnapshotId, FILE_D));\n+\n+    RewriteManifests rewriteManifests = table.rewriteManifests();\n+    manifests.forEach(rewriteManifests::deleteManifest);\n+    rewriteManifests.addManifest(newManifest);\n+    rewriteManifests.commit();\n+\n+    Set<String> deletedFiles = Sets.newHashSet();\n+\n+    table.expireSnapshots()\n+        .deleteExpiredFiles(false)\n+        .expireOlderThan(t4)\n+        .deleteWith(deletedFiles::add)\n+        .commit();\n+\n+    Assert.assertFalse(\"FILE_A should not be deleted\", deletedFiles.contains(FILE_A.path().toString()));\n+    Assert.assertFalse(\"FILE_B should not be deleted\", deletedFiles.contains(FILE_B.path().toString()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7af6a37446c054d8983aae5db91350dd9c70e56b"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MjUwMjk0OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/apache/iceberg/ExpireSnapshots.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxNjo0MDo0OVrOG4VPtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxNjo1NDoyNVrOG4VwvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTcyMTUyNw==", "bodyText": "nit: is this added deliberately?", "url": "https://github.com/apache/iceberg/pull/1244#discussion_r461721527", "createdAt": "2020-07-28T16:40:49Z", "author": {"login": "aokolnychyi"}, "path": "api/src/main/java/org/apache/iceberg/ExpireSnapshots.java", "diffHunk": "@@ -97,4 +97,16 @@\n    * @return this for method chaining\n    */\n   ExpireSnapshots executeWith(ExecutorService executorService);\n+\n+  /**\n+   * Allows expiration of snapshots without any cleanup of underlying manifest or data files.\n+   * <p>\n+   * Allows control in removing data and manifest files which may be more efficiently removed using\n+   * a distributed framework through the actions API.\n+   * <p>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16db43aac5cc80a4991b9597f99638d8809b1dad"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTcyMzk4NQ==", "bodyText": "What is this?", "url": "https://github.com/apache/iceberg/pull/1244#discussion_r461723985", "createdAt": "2020-07-28T16:44:52Z", "author": {"login": "RussellSpitzer"}, "path": "api/src/main/java/org/apache/iceberg/ExpireSnapshots.java", "diffHunk": "@@ -97,4 +97,16 @@\n    * @return this for method chaining\n    */\n   ExpireSnapshots executeWith(ExecutorService executorService);\n+\n+  /**\n+   * Allows expiration of snapshots without any cleanup of underlying manifest or data files.\n+   * <p>\n+   * Allows control in removing data and manifest files which may be more efficiently removed using\n+   * a distributed framework through the actions API.\n+   * <p>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTcyMTUyNw=="}, "originalCommit": {"oid": "16db43aac5cc80a4991b9597f99638d8809b1dad"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTcyNTUwMA==", "bodyText": "I mean an extra <p> at the end.", "url": "https://github.com/apache/iceberg/pull/1244#discussion_r461725500", "createdAt": "2020-07-28T16:47:16Z", "author": {"login": "aokolnychyi"}, "path": "api/src/main/java/org/apache/iceberg/ExpireSnapshots.java", "diffHunk": "@@ -97,4 +97,16 @@\n    * @return this for method chaining\n    */\n   ExpireSnapshots executeWith(ExecutorService executorService);\n+\n+  /**\n+   * Allows expiration of snapshots without any cleanup of underlying manifest or data files.\n+   * <p>\n+   * Allows control in removing data and manifest files which may be more efficiently removed using\n+   * a distributed framework through the actions API.\n+   * <p>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTcyMTUyNw=="}, "originalCommit": {"oid": "16db43aac5cc80a4991b9597f99638d8809b1dad"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTcyOTk4MQ==", "bodyText": "Ah I can remove that.", "url": "https://github.com/apache/iceberg/pull/1244#discussion_r461729981", "createdAt": "2020-07-28T16:54:25Z", "author": {"login": "RussellSpitzer"}, "path": "api/src/main/java/org/apache/iceberg/ExpireSnapshots.java", "diffHunk": "@@ -97,4 +97,16 @@\n    * @return this for method chaining\n    */\n   ExpireSnapshots executeWith(ExecutorService executorService);\n+\n+  /**\n+   * Allows expiration of snapshots without any cleanup of underlying manifest or data files.\n+   * <p>\n+   * Allows control in removing data and manifest files which may be more efficiently removed using\n+   * a distributed framework through the actions API.\n+   * <p>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTcyMTUyNw=="}, "originalCommit": {"oid": "16db43aac5cc80a4991b9597f99638d8809b1dad"}, "originalPosition": 10}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3803, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}