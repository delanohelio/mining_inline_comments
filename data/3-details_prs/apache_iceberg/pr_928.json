{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA0MDEyMDQw", "number": 928, "title": "Add failure handling in cleanup while reading snapshot manifest-list files", "bodyText": "#822 reported a gap in failure handling during Snapshot expiry cleanup. If any snapshot's manifest-list file is unreadable/has temporary io issues none of the  snapshots from then would be cleaned up. This adds Tasks based handling where even if one of them fails the rest are still tried.\nMore context: the try-with-resource block doesn't handle it coz AvroIterable throws a RuntimeIOException which bypasses any IOException handling up the trace. Taskshandles this and lets other snapshots have a chance of cleanup.\ncc @mehtaashish23", "createdAt": "2020-04-15T22:04:29Z", "url": "https://github.com/apache/iceberg/pull/928", "merged": true, "mergeCommit": {"oid": "e30e304bcf78f4451fbb7febe16cb56c68531404"}, "closed": true, "closedAt": "2020-04-16T19:27:06Z", "author": {"login": "prodeezy"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcX_VK6gH2gAyNDA0MDEyMDQwOjdkNmU5OGNmOGFkYTFkZWNlZGQ2M2NjOTU0MDNkNzlkNjUzODkyM2I=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcYQpEMAH2gAyNDA0MDEyMDQwOmUyNGU1ZjJjZTM5M2IyYWY0NTdjYmNjNTdjNDY2Nzk1YmViOGQ2ZTU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "7d6e98cf8ada1decedd63cc95403d79d6538923b", "author": {"user": {"login": "prodeezy", "name": "Gautam"}}, "url": "https://github.com/apache/iceberg/commit/7d6e98cf8ada1decedd63cc95403d79d6538923b", "committedDate": "2020-04-15T21:53:29Z", "message": "Add failure handling in cleanup while reading snapshot manifest-list files"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0MTk3NTA1", "url": "https://github.com/apache/iceberg/pull/928#pullrequestreview-394197505", "createdAt": "2020-04-15T23:14:30Z", "commit": {"oid": "7d6e98cf8ada1decedd63cc95403d79d6538923b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQyMzoxNDozMVrOGGO1yQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQyMzoxNDozMVrOGGO1yQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE4Nzc4NQ==", "bodyText": "Why no retry? Because this adds to a set, it could retry without negative consequences.", "url": "https://github.com/apache/iceberg/pull/928#discussion_r409187785", "createdAt": "2020-04-15T23:14:31Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/RemoveSnapshots.java", "diffHunk": "@@ -201,112 +201,121 @@ private void cleanExpiredFiles(List<Snapshot> snapshots, Set<Long> validIds, Set\n     // find manifests to clean up that are still referenced by a valid snapshot, but written by an expired snapshot\n     Set<String> validManifests = Sets.newHashSet();\n     Set<ManifestFile> manifestsToScan = Sets.newHashSet();\n-    for (Snapshot snapshot : snapshots) {\n-      try (CloseableIterable<ManifestFile> manifests = readManifestFiles(snapshot)) {\n-        for (ManifestFile manifest : manifests) {\n-          validManifests.add(manifest.path());\n-\n-          long snapshotId = manifest.snapshotId();\n-          // whether the manifest was created by a valid snapshot (true) or an expired snapshot (false)\n-          boolean fromValidSnapshots = validIds.contains(snapshotId);\n-          // whether the snapshot that created the manifest was an ancestor of the table state\n-          boolean isFromAncestor = ancestorIds.contains(snapshotId);\n-          // whether the changes in this snapshot have been picked into the current table state\n-          boolean isPicked = pickedAncestorSnapshotIds.contains(snapshotId);\n-          // if the snapshot that wrote this manifest is no longer valid (has expired), then delete its deleted files.\n-          // note that this is only for expired snapshots that are in the current table state\n-          if (!fromValidSnapshots && (isFromAncestor || isPicked) && manifest.hasDeletedFiles()) {\n-            manifestsToScan.add(manifest.copy());\n-          }\n-        }\n-\n-      } catch (IOException e) {\n-        throw new RuntimeIOException(e,\n-            \"Failed to close manifest list: %s\", snapshot.manifestListLocation());\n-      }\n-    }\n+    Tasks.foreach(snapshots).noRetry().suppressFailureWhenFinished()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d6e98cf8ada1decedd63cc95403d79d6538923b"}, "originalPosition": 28}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0MTk3ODQy", "url": "https://github.com/apache/iceberg/pull/928#pullrequestreview-394197842", "createdAt": "2020-04-15T23:15:29Z", "commit": {"oid": "7d6e98cf8ada1decedd63cc95403d79d6538923b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQyMzoxNToyOVrOGGO29w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQyMzoxNToyOVrOGGO29w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE4ODA4Nw==", "bodyText": "This indentation seems a bit awkward to me because the arguments are indented so much less than the LOG.warn call. What about moving LOG.warn to the next line and indenting its arguments to make it obvious what the args are passed to?", "url": "https://github.com/apache/iceberg/pull/928#discussion_r409188087", "createdAt": "2020-04-15T23:15:29Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/RemoveSnapshots.java", "diffHunk": "@@ -201,112 +201,121 @@ private void cleanExpiredFiles(List<Snapshot> snapshots, Set<Long> validIds, Set\n     // find manifests to clean up that are still referenced by a valid snapshot, but written by an expired snapshot\n     Set<String> validManifests = Sets.newHashSet();\n     Set<ManifestFile> manifestsToScan = Sets.newHashSet();\n-    for (Snapshot snapshot : snapshots) {\n-      try (CloseableIterable<ManifestFile> manifests = readManifestFiles(snapshot)) {\n-        for (ManifestFile manifest : manifests) {\n-          validManifests.add(manifest.path());\n-\n-          long snapshotId = manifest.snapshotId();\n-          // whether the manifest was created by a valid snapshot (true) or an expired snapshot (false)\n-          boolean fromValidSnapshots = validIds.contains(snapshotId);\n-          // whether the snapshot that created the manifest was an ancestor of the table state\n-          boolean isFromAncestor = ancestorIds.contains(snapshotId);\n-          // whether the changes in this snapshot have been picked into the current table state\n-          boolean isPicked = pickedAncestorSnapshotIds.contains(snapshotId);\n-          // if the snapshot that wrote this manifest is no longer valid (has expired), then delete its deleted files.\n-          // note that this is only for expired snapshots that are in the current table state\n-          if (!fromValidSnapshots && (isFromAncestor || isPicked) && manifest.hasDeletedFiles()) {\n-            manifestsToScan.add(manifest.copy());\n-          }\n-        }\n-\n-      } catch (IOException e) {\n-        throw new RuntimeIOException(e,\n-            \"Failed to close manifest list: %s\", snapshot.manifestListLocation());\n-      }\n-    }\n+    Tasks.foreach(snapshots).noRetry().suppressFailureWhenFinished()\n+        .onFailure((snapshot, exc) -> LOG.warn(\"Failed on snapshot {} while reading manifest list: {}\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d6e98cf8ada1decedd63cc95403d79d6538923b"}, "originalPosition": 29}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0MTk4MzY2", "url": "https://github.com/apache/iceberg/pull/928#pullrequestreview-394198366", "createdAt": "2020-04-15T23:16:59Z", "commit": {"oid": "7d6e98cf8ada1decedd63cc95403d79d6538923b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQyMzoxNjo1OVrOGGO47A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQyMzoxNjo1OVrOGGO47A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE4ODU4OA==", "bodyText": "Same here. Wouldn't it be better to retry?", "url": "https://github.com/apache/iceberg/pull/928#discussion_r409188588", "createdAt": "2020-04-15T23:16:59Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/RemoveSnapshots.java", "diffHunk": "@@ -201,112 +201,121 @@ private void cleanExpiredFiles(List<Snapshot> snapshots, Set<Long> validIds, Set\n     // find manifests to clean up that are still referenced by a valid snapshot, but written by an expired snapshot\n     Set<String> validManifests = Sets.newHashSet();\n     Set<ManifestFile> manifestsToScan = Sets.newHashSet();\n-    for (Snapshot snapshot : snapshots) {\n-      try (CloseableIterable<ManifestFile> manifests = readManifestFiles(snapshot)) {\n-        for (ManifestFile manifest : manifests) {\n-          validManifests.add(manifest.path());\n-\n-          long snapshotId = manifest.snapshotId();\n-          // whether the manifest was created by a valid snapshot (true) or an expired snapshot (false)\n-          boolean fromValidSnapshots = validIds.contains(snapshotId);\n-          // whether the snapshot that created the manifest was an ancestor of the table state\n-          boolean isFromAncestor = ancestorIds.contains(snapshotId);\n-          // whether the changes in this snapshot have been picked into the current table state\n-          boolean isPicked = pickedAncestorSnapshotIds.contains(snapshotId);\n-          // if the snapshot that wrote this manifest is no longer valid (has expired), then delete its deleted files.\n-          // note that this is only for expired snapshots that are in the current table state\n-          if (!fromValidSnapshots && (isFromAncestor || isPicked) && manifest.hasDeletedFiles()) {\n-            manifestsToScan.add(manifest.copy());\n-          }\n-        }\n-\n-      } catch (IOException e) {\n-        throw new RuntimeIOException(e,\n-            \"Failed to close manifest list: %s\", snapshot.manifestListLocation());\n-      }\n-    }\n+    Tasks.foreach(snapshots).noRetry().suppressFailureWhenFinished()\n+        .onFailure((snapshot, exc) -> LOG.warn(\"Failed on snapshot {} while reading manifest list: {}\",\n+            snapshot.snapshotId(), snapshot.manifestListLocation(), exc))\n+        .run(\n+            snapshot -> {\n+              try (CloseableIterable<ManifestFile> manifests = readManifestFiles(snapshot)) {\n+                for (ManifestFile manifest : manifests) {\n+                  validManifests.add(manifest.path());\n+\n+                  long snapshotId = manifest.snapshotId();\n+                  // whether the manifest was created by a valid snapshot (true) or an expired snapshot (false)\n+                  boolean fromValidSnapshots = validIds.contains(snapshotId);\n+                  // whether the snapshot that created the manifest was an ancestor of the table state\n+                  boolean isFromAncestor = ancestorIds.contains(snapshotId);\n+                  // whether the changes in this snapshot have been picked into the current table state\n+                  boolean isPicked = pickedAncestorSnapshotIds.contains(snapshotId);\n+                  // if the snapshot that wrote this manifest is no longer valid (has expired),\n+                  // then delete its deleted files. note that this is only for expired snapshots that are in the\n+                  // current table state\n+                  if (!fromValidSnapshots && (isFromAncestor || isPicked) && manifest.hasDeletedFiles()) {\n+                    manifestsToScan.add(manifest.copy());\n+                  }\n+                }\n+\n+              } catch (IOException e) {\n+                throw new RuntimeIOException(e,\n+                    \"Failed to close manifest list: %s\", snapshot.manifestListLocation());\n+              }\n+            });\n \n     // find manifests to clean up that were only referenced by snapshots that have expired\n     Set<String> manifestListsToDelete = Sets.newHashSet();\n     Set<String> manifestsToDelete = Sets.newHashSet();\n     Set<ManifestFile> manifestsToRevert = Sets.newHashSet();\n-    for (Snapshot snapshot : base.snapshots()) {\n-      long snapshotId = snapshot.snapshotId();\n-      if (!validIds.contains(snapshotId)) {\n-        // determine whether the changes in this snapshot are in the current table state\n-        if (pickedAncestorSnapshotIds.contains(snapshotId)) {\n-          // this snapshot was cherry-picked into the current table state, so skip cleaning it up. its changes will\n-          // expire when the picked snapshot expires.\n-          // A -- C -- D (source=B)\n-          //  `- B <-- this commit\n-          continue;\n-        }\n-\n-        long sourceSnapshotId = PropertyUtil.propertyAsLong(\n-            snapshot.summary(), SnapshotSummary.SOURCE_SNAPSHOT_ID_PROP, -1);\n-        if (ancestorIds.contains(sourceSnapshotId)) {\n-          // this commit was cherry-picked from a commit that is in the current table state. do not clean up its\n-          // changes because it would revert data file additions that are in the current table.\n-          // A -- B -- C\n-          //  `- D (source=B) <-- this commit\n-          continue;\n-        }\n-\n-        if (pickedAncestorSnapshotIds.contains(sourceSnapshotId)) {\n-          // this commit was cherry-picked from a commit that is in the current table state. do not clean up its\n-          // changes because it would revert data file additions that are in the current table.\n-          // A -- C -- E (source=B)\n-          //  `- B `- D (source=B) <-- this commit\n-          continue;\n-        }\n-\n-        // find any manifests that are no longer needed\n-        try (CloseableIterable<ManifestFile> manifests = readManifestFiles(snapshot)) {\n-          for (ManifestFile manifest : manifests) {\n-            if (!validManifests.contains(manifest.path())) {\n-              manifestsToDelete.add(manifest.path());\n-\n-              boolean isFromAncestor = ancestorIds.contains(manifest.snapshotId());\n-              boolean isFromExpiringSnapshot = expiredIds.contains(manifest.snapshotId());\n-\n-              if (isFromAncestor && manifest.hasDeletedFiles()) {\n-                // Only delete data files that were deleted in by an expired snapshot if that\n-                // snapshot is an ancestor of the current table state. Otherwise, a snapshot that\n-                // deleted files and was rolled back will delete files that could be in the current\n-                // table state.\n-                manifestsToScan.add(manifest.copy());\n+    Tasks.foreach(base.snapshots()).noRetry().suppressFailureWhenFinished()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d6e98cf8ada1decedd63cc95403d79d6538923b"}, "originalPosition": 107}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0MTk4NDUx", "url": "https://github.com/apache/iceberg/pull/928#pullrequestreview-394198451", "createdAt": "2020-04-15T23:17:13Z", "commit": {"oid": "7d6e98cf8ada1decedd63cc95403d79d6538923b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQyMzoxNzoxM1rOGGO5LQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQyMzoxNzoxM1rOGGO5LQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE4ODY1Mw==", "bodyText": "+1", "url": "https://github.com/apache/iceberg/pull/928#discussion_r409188653", "createdAt": "2020-04-15T23:17:13Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/RemoveSnapshots.java", "diffHunk": "@@ -201,112 +201,121 @@ private void cleanExpiredFiles(List<Snapshot> snapshots, Set<Long> validIds, Set\n     // find manifests to clean up that are still referenced by a valid snapshot, but written by an expired snapshot\n     Set<String> validManifests = Sets.newHashSet();\n     Set<ManifestFile> manifestsToScan = Sets.newHashSet();\n-    for (Snapshot snapshot : snapshots) {\n-      try (CloseableIterable<ManifestFile> manifests = readManifestFiles(snapshot)) {\n-        for (ManifestFile manifest : manifests) {\n-          validManifests.add(manifest.path());\n-\n-          long snapshotId = manifest.snapshotId();\n-          // whether the manifest was created by a valid snapshot (true) or an expired snapshot (false)\n-          boolean fromValidSnapshots = validIds.contains(snapshotId);\n-          // whether the snapshot that created the manifest was an ancestor of the table state\n-          boolean isFromAncestor = ancestorIds.contains(snapshotId);\n-          // whether the changes in this snapshot have been picked into the current table state\n-          boolean isPicked = pickedAncestorSnapshotIds.contains(snapshotId);\n-          // if the snapshot that wrote this manifest is no longer valid (has expired), then delete its deleted files.\n-          // note that this is only for expired snapshots that are in the current table state\n-          if (!fromValidSnapshots && (isFromAncestor || isPicked) && manifest.hasDeletedFiles()) {\n-            manifestsToScan.add(manifest.copy());\n-          }\n-        }\n-\n-      } catch (IOException e) {\n-        throw new RuntimeIOException(e,\n-            \"Failed to close manifest list: %s\", snapshot.manifestListLocation());\n-      }\n-    }\n+    Tasks.foreach(snapshots).noRetry().suppressFailureWhenFinished()\n+        .onFailure((snapshot, exc) -> LOG.warn(\"Failed on snapshot {} while reading manifest list: {}\",\n+            snapshot.snapshotId(), snapshot.manifestListLocation(), exc))\n+        .run(\n+            snapshot -> {\n+              try (CloseableIterable<ManifestFile> manifests = readManifestFiles(snapshot)) {\n+                for (ManifestFile manifest : manifests) {\n+                  validManifests.add(manifest.path());\n+\n+                  long snapshotId = manifest.snapshotId();\n+                  // whether the manifest was created by a valid snapshot (true) or an expired snapshot (false)\n+                  boolean fromValidSnapshots = validIds.contains(snapshotId);\n+                  // whether the snapshot that created the manifest was an ancestor of the table state\n+                  boolean isFromAncestor = ancestorIds.contains(snapshotId);\n+                  // whether the changes in this snapshot have been picked into the current table state\n+                  boolean isPicked = pickedAncestorSnapshotIds.contains(snapshotId);\n+                  // if the snapshot that wrote this manifest is no longer valid (has expired),\n+                  // then delete its deleted files. note that this is only for expired snapshots that are in the\n+                  // current table state\n+                  if (!fromValidSnapshots && (isFromAncestor || isPicked) && manifest.hasDeletedFiles()) {\n+                    manifestsToScan.add(manifest.copy());\n+                  }\n+                }\n+\n+              } catch (IOException e) {\n+                throw new RuntimeIOException(e,\n+                    \"Failed to close manifest list: %s\", snapshot.manifestListLocation());\n+              }\n+            });\n \n     // find manifests to clean up that were only referenced by snapshots that have expired\n     Set<String> manifestListsToDelete = Sets.newHashSet();\n     Set<String> manifestsToDelete = Sets.newHashSet();\n     Set<ManifestFile> manifestsToRevert = Sets.newHashSet();\n-    for (Snapshot snapshot : base.snapshots()) {\n-      long snapshotId = snapshot.snapshotId();\n-      if (!validIds.contains(snapshotId)) {\n-        // determine whether the changes in this snapshot are in the current table state\n-        if (pickedAncestorSnapshotIds.contains(snapshotId)) {\n-          // this snapshot was cherry-picked into the current table state, so skip cleaning it up. its changes will\n-          // expire when the picked snapshot expires.\n-          // A -- C -- D (source=B)\n-          //  `- B <-- this commit\n-          continue;\n-        }\n-\n-        long sourceSnapshotId = PropertyUtil.propertyAsLong(\n-            snapshot.summary(), SnapshotSummary.SOURCE_SNAPSHOT_ID_PROP, -1);\n-        if (ancestorIds.contains(sourceSnapshotId)) {\n-          // this commit was cherry-picked from a commit that is in the current table state. do not clean up its\n-          // changes because it would revert data file additions that are in the current table.\n-          // A -- B -- C\n-          //  `- D (source=B) <-- this commit\n-          continue;\n-        }\n-\n-        if (pickedAncestorSnapshotIds.contains(sourceSnapshotId)) {\n-          // this commit was cherry-picked from a commit that is in the current table state. do not clean up its\n-          // changes because it would revert data file additions that are in the current table.\n-          // A -- C -- E (source=B)\n-          //  `- B `- D (source=B) <-- this commit\n-          continue;\n-        }\n-\n-        // find any manifests that are no longer needed\n-        try (CloseableIterable<ManifestFile> manifests = readManifestFiles(snapshot)) {\n-          for (ManifestFile manifest : manifests) {\n-            if (!validManifests.contains(manifest.path())) {\n-              manifestsToDelete.add(manifest.path());\n-\n-              boolean isFromAncestor = ancestorIds.contains(manifest.snapshotId());\n-              boolean isFromExpiringSnapshot = expiredIds.contains(manifest.snapshotId());\n-\n-              if (isFromAncestor && manifest.hasDeletedFiles()) {\n-                // Only delete data files that were deleted in by an expired snapshot if that\n-                // snapshot is an ancestor of the current table state. Otherwise, a snapshot that\n-                // deleted files and was rolled back will delete files that could be in the current\n-                // table state.\n-                manifestsToScan.add(manifest.copy());\n+    Tasks.foreach(base.snapshots()).noRetry().suppressFailureWhenFinished()\n+        .onFailure((snapshot, exc) -> LOG.warn(\"Failed on snapshot {} while reading manifest list: {}\",\n+            snapshot.snapshotId(), snapshot.manifestListLocation(), exc))\n+        .run(\n+            snapshot -> {\n+              long snapshotId = snapshot.snapshotId();\n+              if (!validIds.contains(snapshotId)) {\n+                // determine whether the changes in this snapshot are in the current table state\n+                if (pickedAncestorSnapshotIds.contains(snapshotId)) {\n+                  // this snapshot was cherry-picked into the current table state, so skip cleaning it up.\n+                  // its changes will expire when the picked snapshot expires.\n+                  // A -- C -- D (source=B)\n+                  //  `- B <-- this commit\n+                  return;\n+                }\n+\n+                long sourceSnapshotId = PropertyUtil.propertyAsLong(\n+                    snapshot.summary(), SnapshotSummary.SOURCE_SNAPSHOT_ID_PROP, -1);\n+                if (ancestorIds.contains(sourceSnapshotId)) {\n+                  // this commit was cherry-picked from a commit that is in the current table state. do not clean up its\n+                  // changes because it would revert data file additions that are in the current table.\n+                  // A -- B -- C\n+                  //  `- D (source=B) <-- this commit\n+                  return;\n+                }\n+\n+                if (pickedAncestorSnapshotIds.contains(sourceSnapshotId)) {\n+                  // this commit was cherry-picked from a commit that is in the current table state. do not clean up its\n+                  // changes because it would revert data file additions that are in the current table.\n+                  // A -- C -- E (source=B)\n+                  //  `- B `- D (source=B) <-- this commit\n+                  return;\n+                }\n+\n+                // find any manifests that are no longer needed\n+                try (CloseableIterable<ManifestFile> manifests = readManifestFiles(snapshot)) {\n+                  for (ManifestFile manifest : manifests) {\n+                    if (!validManifests.contains(manifest.path())) {\n+                      manifestsToDelete.add(manifest.path());\n+\n+                      boolean isFromAncestor = ancestorIds.contains(manifest.snapshotId());\n+                      boolean isFromExpiringSnapshot = expiredIds.contains(manifest.snapshotId());\n+\n+                      if (isFromAncestor && manifest.hasDeletedFiles()) {\n+                        // Only delete data files that were deleted in by an expired snapshot if that\n+                        // snapshot is an ancestor of the current table state. Otherwise, a snapshot that\n+                        // deleted files and was rolled back will delete files that could be in the current\n+                        // table state.\n+                        manifestsToScan.add(manifest.copy());\n+                      }\n+\n+                      if (!isFromAncestor && isFromExpiringSnapshot && manifest.hasAddedFiles()) {\n+                        // Because the manifest was written by a snapshot that is not an ancestor of the\n+                        // current table state, the files added in this manifest can be removed. The extra\n+                        // check whether the manifest was written by a known snapshot that was expired in\n+                        // this commit ensures that the full ancestor list between when the snapshot was\n+                        // written and this expiration is known and there is no missing history. If history\n+                        // were missing, then the snapshot could be an ancestor of the table state but the\n+                        // ancestor ID set would not contain it and this would be unsafe.\n+                        manifestsToRevert.add(manifest.copy());\n+                      }\n+                    }\n+                  }\n+                } catch (IOException e) {\n+                  throw new RuntimeIOException(e,\n+                      \"Failed to close manifest list: %s\", snapshot.manifestListLocation());\n+                }\n+\n+                // add the manifest list to the delete set, if present\n+                if (snapshot.manifestListLocation() != null) {\n+                  manifestListsToDelete.add(snapshot.manifestListLocation());\n+                }\n               }\n-\n-              if (!isFromAncestor && isFromExpiringSnapshot && manifest.hasAddedFiles()) {\n-                // Because the manifest was written by a snapshot that is not an ancestor of the\n-                // current table state, the files added in this manifest can be removed. The extra\n-                // check whether the manifest was written by a known snapshot that was expired in\n-                // this commit ensures that the full ancestor list between when the snapshot was\n-                // written and this expiration is known and there is no missing history. If history\n-                // were missing, then the snapshot could be an ancestor of the table state but the\n-                // ancestor ID set would not contain it and this would be unsafe.\n-                manifestsToRevert.add(manifest.copy());\n-              }\n-            }\n-          }\n-        } catch (IOException e) {\n-          throw new RuntimeIOException(e,\n-              \"Failed to close manifest list: %s\", snapshot.manifestListLocation());\n-        }\n-\n-        // add the manifest list to the delete set, if present\n-        if (snapshot.manifestListLocation() != null) {\n-          manifestListsToDelete.add(snapshot.manifestListLocation());\n-        }\n-      }\n-    }\n-\n+            });\n     deleteDataFiles(manifestsToScan, manifestsToRevert, validIds);\n     deleteMetadataFiles(manifestsToDelete, manifestListsToDelete);\n   }\n \n   private void deleteMetadataFiles(Set<String> manifestsToDelete, Set<String> manifestListsToDelete) {\n     LOG.warn(\"Manifests to delete: {}\", Joiner.on(\", \").join(manifestsToDelete));\n+    LOG.warn(\"Manifests Lists to delete: {}\", Joiner.on(\", \").join(manifestListsToDelete));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d6e98cf8ada1decedd63cc95403d79d6538923b"}, "originalPosition": 212}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d1d6581e09f3448c789238feb5aec1189f3bb206", "author": {"user": {"login": "prodeezy", "name": "Gautam"}}, "url": "https://github.com/apache/iceberg/commit/d1d6581e09f3448c789238feb5aec1189f3bb206", "committedDate": "2020-04-16T16:48:53Z", "message": "Fixed Log indent and added retries when reading manifest-lists"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0ODIxOTUy", "url": "https://github.com/apache/iceberg/pull/928#pullrequestreview-394821952", "createdAt": "2020-04-16T16:52:34Z", "commit": {"oid": "d1d6581e09f3448c789238feb5aec1189f3bb206"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e24e5f2ce393b2af457cbcc57c466795beb8d6e5", "author": {"user": {"login": "prodeezy", "name": "Gautam"}}, "url": "https://github.com/apache/iceberg/commit/e24e5f2ce393b2af457cbcc57c466795beb8d6e5", "committedDate": "2020-04-16T18:03:36Z", "message": "Add retries when finding datafiles/manifests to delete, when deleting\ndatafiles/manifests. Do not retry delete if file wasn't found."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4808, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}