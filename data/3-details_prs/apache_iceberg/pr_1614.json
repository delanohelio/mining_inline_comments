{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAzNjk2MTM3", "number": 1614, "title": "Core: ensure sort order and specs exist in v2 when parsing table metadata", "bodyText": "For tests, created a new folder testfiles to store json strings used for testing TableMetadataParser.fromJson.\nThis should fix #1419", "createdAt": "2020-10-14T22:46:08Z", "url": "https://github.com/apache/iceberg/pull/1614", "merged": true, "mergeCommit": {"oid": "330f1520ce497153f7a6e9a80a22035ff9f6aa32"}, "closed": true, "closedAt": "2020-11-01T20:19:42Z", "author": {"login": "yyanyy"}, "timelineItems": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdSlAU7gH2gAyNTAzNjk2MTM3OjZlN2Y4YWE3OTJkYTlmMzRhNzU4NGNkNDMyODRjYzBmOWNlMzEwZDY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdXF8wjgH2gAyNTAzNjk2MTM3OjhjOWFjMDY2ZjBiNWVhZTFlYjVjMjVmNzBkZWYzMDJmYzJkN2UzOTE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "6e7f8aa792da9f34a7584cd43284cc0f9ce310d6", "author": {"user": {"login": "yyanyy", "name": null}}, "url": "https://github.com/apache/iceberg/commit/6e7f8aa792da9f34a7584cd43284cc0f9ce310d6", "committedDate": "2020-10-14T22:34:43Z", "message": "Core: ensure sort order and specs exist in v2 when parsing table metadata (#1419)"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE4OTM2MzU5", "url": "https://github.com/apache/iceberg/pull/1614#pullrequestreview-518936359", "createdAt": "2020-10-28T17:51:03Z", "commit": {"oid": "6e7f8aa792da9f34a7584cd43284cc0f9ce310d6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNzo1MTowNFrOHp2jEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNzo1MTowNFrOHp2jEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY0NzM3OA==", "bodyText": "I think the test files should be in src/test/resources so that ClassLoader.getResource can be used to read. That is usually a better way to find fixtures because it avoids assuming the current working directory of the build.", "url": "https://github.com/apache/iceberg/pull/1614#discussion_r513647378", "createdAt": "2020-10-28T17:51:04Z", "author": {"login": "rdblue"}, "path": "core/src/test/java/org/apache/iceberg/TestTableMetadata.java", "diffHunk": "@@ -446,68 +448,48 @@ public void testVersionValidation() {\n \n   @Test\n   public void testParserVersionValidation() throws Exception {\n-    String supportedVersion = toJsonWithVersion(\n-        TableMetadata.newTableMetadata(TEST_SCHEMA, SPEC_5, TEST_LOCATION, ImmutableMap.of()),\n-        TableMetadata.SUPPORTED_TABLE_FORMAT_VERSION);\n-    TableMetadata parsed = TableMetadataParser.fromJson(\n-        ops.io(), null, JsonUtil.mapper().readValue(supportedVersion, JsonNode.class));\n-    Assert.assertNotNull(\"Should successfully read supported metadata version\", parsed);\n-\n-    String unsupportedVersion = toJsonWithVersion(\n-        TableMetadata.newTableMetadata(TEST_SCHEMA, SPEC_5, TEST_LOCATION, ImmutableMap.of()),\n-        TableMetadata.SUPPORTED_TABLE_FORMAT_VERSION + 1);\n+    String supportedVersion1 = readTableMetadataInputFile(\"TableMetadataV1Valid.json\");\n+    TableMetadata parsed1 = TableMetadataParser.fromJson(\n+        ops.io(), null, JsonUtil.mapper().readValue(supportedVersion1, JsonNode.class));\n+    Assert.assertNotNull(\"Should successfully read supported metadata version\", parsed1);\n+\n+    String supportedVersion2 = readTableMetadataInputFile(\"TableMetadataV2Valid.json\");\n+    TableMetadata parsed2 = TableMetadataParser.fromJson(\n+        ops.io(), null, JsonUtil.mapper().readValue(supportedVersion2, JsonNode.class));\n+    Assert.assertNotNull(\"Should successfully read supported metadata version\", parsed2);\n+\n+    String unsupportedVersion = readTableMetadataInputFile(\"TableMetadataUnsupportedVersion.json\");\n     AssertHelpers.assertThrows(\"Should not read unsupported metadata\",\n         IllegalArgumentException.class, \"Cannot read unsupported version\",\n         () -> TableMetadataParser.fromJson(\n-            ops.io(), null, JsonUtil.mapper().readValue(unsupportedVersion, JsonNode.class)));\n+            ops.io(), null, JsonUtil.mapper().readValue(unsupportedVersion, JsonNode.class))\n+    );\n   }\n \n-  public static String toJsonWithVersion(TableMetadata metadata, int version) {\n-    StringWriter writer = new StringWriter();\n-    try {\n-      JsonGenerator generator = JsonUtil.factory().createGenerator(writer);\n-\n-      generator.writeStartObject(); // start table metadata object\n-\n-      generator.writeNumberField(FORMAT_VERSION, version);\n-      generator.writeStringField(TABLE_UUID, metadata.uuid());\n-      generator.writeStringField(LOCATION, metadata.location());\n-      generator.writeNumberField(LAST_UPDATED_MILLIS, metadata.lastUpdatedMillis());\n-      if (version > 1) {\n-        generator.writeNumberField(TableMetadataParser.LAST_SEQUENCE_NUMBER, metadata.lastSequenceNumber());\n-      }\n-      generator.writeNumberField(LAST_COLUMN_ID, metadata.lastColumnId());\n \n-      generator.writeFieldName(SCHEMA);\n-      SchemaParser.toJson(metadata.schema(), generator);\n-\n-      // mimic an old writer by writing only partition-spec and not the default ID or spec list\n-      generator.writeFieldName(PARTITION_SPEC);\n-      PartitionSpecParser.toJsonFields(metadata.spec(), generator);\n-\n-      generator.writeObjectFieldStart(PROPERTIES);\n-      for (Map.Entry<String, String> keyValue : metadata.properties().entrySet()) {\n-        generator.writeStringField(keyValue.getKey(), keyValue.getValue());\n-      }\n-      generator.writeEndObject();\n-\n-      generator.writeNumberField(CURRENT_SNAPSHOT_ID,\n-          metadata.currentSnapshot() != null ? metadata.currentSnapshot().snapshotId() : -1);\n-\n-      generator.writeArrayFieldStart(SNAPSHOTS);\n-      for (Snapshot snapshot : metadata.snapshots()) {\n-        SnapshotParser.toJson(snapshot, generator);\n-      }\n-      generator.writeEndArray();\n-      // skip the snapshot log\n+  @Test\n+  public void testParserV2PartitionSpecsValidation() throws Exception {\n+    String unsupportedVersion = readTableMetadataInputFile(\"TableMetadataV2MissingPartitionSpecs.json\");\n+    AssertHelpers.assertThrows(\"Should reject v2 metadata without partition specs\",\n+        IllegalArgumentException.class, \"partition-specs must exist in format v2\",\n+        () -> TableMetadataParser.fromJson(\n+            ops.io(), null, JsonUtil.mapper().readValue(unsupportedVersion, JsonNode.class))\n+    );\n+  }\n \n-      generator.writeEndObject(); // end table metadata object\n+  @Test\n+  public void testParserV2SortOrderValidation() throws Exception {\n+    String unsupportedVersion = readTableMetadataInputFile(\"TableMetadataV2MissingSortOrder.json\");\n+    AssertHelpers.assertThrows(\"Should reject v2 metadata without sort order\",\n+        IllegalArgumentException.class, \"sort-orders must exist in format v2\",\n+        () -> TableMetadataParser.fromJson(\n+            ops.io(), null, JsonUtil.mapper().readValue(unsupportedVersion, JsonNode.class))\n+    );\n+  }\n \n-      generator.flush();\n-    } catch (IOException e) {\n-      throw new UncheckedIOException(String.format(\"Failed to write json for: %s\", metadata), e);\n-    }\n-    return writer.toString();\n+  private String readTableMetadataInputFile(String fileName) throws IOException {\n+    Path path = Paths.get(new File(\"\").getAbsolutePath(), \"src/test/testfiles\", fileName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e7f8aa792da9f34a7584cd43284cc0f9ce310d6"}, "originalPosition": 119}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8c9ac066f0b5eae1eb5c25f70def302fc2d7e391", "author": {"user": {"login": "yyanyy", "name": null}}, "url": "https://github.com/apache/iceberg/commit/8c9ac066f0b5eae1eb5c25f70def302fc2d7e391", "committedDate": "2020-10-28T23:13:23Z", "message": "use resources folder for test files instead"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3964, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}