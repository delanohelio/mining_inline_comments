{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc3NjU2MTM5", "number": 814, "reviewThreads": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxNzoxNzo1NVrODhnE-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQyMzoxMjozMVrODmfkpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NTY5ODQ5OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/org/apache/iceberg/TestTables.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxNzoxNzo1NVrOFscGtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxODoyOTozNVrOFseZdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE0MjEzNQ==", "bodyText": "Instead of updating a static variable that we need to clean up between test cases, how about using the delete callback? I think that's going to be a better way to test.", "url": "https://github.com/apache/iceberg/pull/814#discussion_r382142135", "createdAt": "2020-02-20T17:17:55Z", "author": {"login": "rdblue"}, "path": "core/src/test/java/org/apache/iceberg/TestTables.java", "diffHunk": "@@ -218,9 +222,7 @@ public OutputFile newOutputFile(String path) {\n \n     @Override\n     public void deleteFile(String path) {\n-      if (!new File(path).delete()) {\n-        throw new RuntimeIOException(\"Failed to delete file: \" + path);\n-      }\n+      DELETED_FILE_PATHS.add(path);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c6cd676461069265ac2665781a08f34dd631b98"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE3OTcwMA==", "bodyText": "+1", "url": "https://github.com/apache/iceberg/pull/814#discussion_r382179700", "createdAt": "2020-02-20T18:29:35Z", "author": {"login": "rominparekh"}, "path": "core/src/test/java/org/apache/iceberg/TestTables.java", "diffHunk": "@@ -218,9 +222,7 @@ public OutputFile newOutputFile(String path) {\n \n     @Override\n     public void deleteFile(String path) {\n-      if (!new File(path).delete()) {\n-        throw new RuntimeIOException(\"Failed to delete file: \" + path);\n-      }\n+      DELETED_FILE_PATHS.add(path);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE0MjEzNQ=="}, "originalCommit": {"oid": "4c6cd676461069265ac2665781a08f34dd631b98"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NTcwMjUwOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/apache/iceberg/ExpireSnapshots.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxNzoxOTowNlrOFscJWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxODoyOTowN1rOFseYkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE0MjgxMQ==", "bodyText": "Can you move this to a separate PR? I don't think we need to update RemoveSnapshots and deprecate a method at the same time.", "url": "https://github.com/apache/iceberg/pull/814#discussion_r382142811", "createdAt": "2020-02-20T17:19:06Z", "author": {"login": "rdblue"}, "path": "api/src/main/java/org/apache/iceberg/ExpireSnapshots.java", "diffHunk": "@@ -40,11 +40,13 @@\n public interface ExpireSnapshots extends PendingUpdate<List<Snapshot>> {\n \n   /**\n-   * Expires a specific {@link Snapshot} identified by id.\n+   * Expires a specific {@link Snapshot} identified by id. This API isn't compatible with\n+   * cherry-pick functionality (issue #744), and hence marked Deprecated.\n    *\n    * @param snapshotId long id of the snapshot to expire\n    * @return this for method chaining\n    */\n+  @Deprecated", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c6cd676461069265ac2665781a08f34dd631b98"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE3OTQ3Mg==", "bodyText": "Also can we possibly provide a message to use an alternate API for deprecation. Something like -\n@Deprecate(\"Use `expireOlderThan()` method instead\")", "url": "https://github.com/apache/iceberg/pull/814#discussion_r382179472", "createdAt": "2020-02-20T18:29:07Z", "author": {"login": "rominparekh"}, "path": "api/src/main/java/org/apache/iceberg/ExpireSnapshots.java", "diffHunk": "@@ -40,11 +40,13 @@\n public interface ExpireSnapshots extends PendingUpdate<List<Snapshot>> {\n \n   /**\n-   * Expires a specific {@link Snapshot} identified by id.\n+   * Expires a specific {@link Snapshot} identified by id. This API isn't compatible with\n+   * cherry-pick functionality (issue #744), and hence marked Deprecated.\n    *\n    * @param snapshotId long id of the snapshot to expire\n    * @return this for method chaining\n    */\n+  @Deprecated", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE0MjgxMQ=="}, "originalCommit": {"oid": "4c6cd676461069265ac2665781a08f34dd631b98"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NTcxMDE0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/iceberg/RemoveSnapshots.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxNzoyMToyMVrOFscOTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwMDo0MDo0MVrOFsoHGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE0NDA3Ng==", "bodyText": "Quick note: this case needs a follow-up because we could expire A and B, then later expire C (not in the current table state) and not be able to detect that we should not delete its files. Expiring B means that we need to also expire C.", "url": "https://github.com/apache/iceberg/pull/814#discussion_r382144076", "createdAt": "2020-02-20T17:21:21Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/RemoveSnapshots.java", "diffHunk": "@@ -208,12 +226,40 @@ private void cleanExpiredFiles(List<Snapshot> snapshots, Set<Long> validIds, Set\n       }\n     }\n \n+    // find manifests to clean up that were only referenced by snapshots that have expired\n     Set<String> manifestListsToDelete = Sets.newHashSet();\n     Set<String> manifestsToDelete = Sets.newHashSet();\n     Set<ManifestFile> manifestsToRevert = Sets.newHashSet();\n     for (Snapshot snapshot : base.snapshots()) {\n       long snapshotId = snapshot.snapshotId();\n       if (!validIds.contains(snapshotId)) {\n+        // determine whether the changes in this snapshot are in the current table state\n+        if (pickedAncestorSnapshotIds.contains(snapshotId)) {\n+          // this snapshot was cherry-picked into the current table state, so skip cleaning it up. its changes will\n+          // expire when the picked snapshot expires.\n+          // A -- C (source=B)\n+          //  `- B <-- this commit\n+          continue;\n+        }\n+\n+        long sourceSnapshotId = PropertyUtil.propertyAsLong(\n+            snapshot.summary(), SnapshotSummary.SOURCE_SNAPSHOT_ID_PROP, -1);\n+        if (ancestorIds.contains(sourceSnapshotId)) {\n+          // this commit was cherry-picked from a commit that is in the current table state. do not clean up its\n+          // changes because it would revert data file additions that are in the current table.\n+          // A -- B\n+          //  `- C (source=B) <-- this commit", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c6cd676461069265ac2665781a08f34dd631b98"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMzODg0MQ==", "bodyText": "NOTE: I think we can handle this case, i.e. when picking a snapshot for expiration, we should also pick its source snapshot, but considering the gotchas, I would recommend to keep the API simple with expireOlderThan. Also our use case is to use expireOlderThan API for now.\nI will log a ticket for this.", "url": "https://github.com/apache/iceberg/pull/814#discussion_r382338841", "createdAt": "2020-02-21T00:40:41Z", "author": {"login": "mehtaashish23"}, "path": "core/src/main/java/org/apache/iceberg/RemoveSnapshots.java", "diffHunk": "@@ -208,12 +226,40 @@ private void cleanExpiredFiles(List<Snapshot> snapshots, Set<Long> validIds, Set\n       }\n     }\n \n+    // find manifests to clean up that were only referenced by snapshots that have expired\n     Set<String> manifestListsToDelete = Sets.newHashSet();\n     Set<String> manifestsToDelete = Sets.newHashSet();\n     Set<ManifestFile> manifestsToRevert = Sets.newHashSet();\n     for (Snapshot snapshot : base.snapshots()) {\n       long snapshotId = snapshot.snapshotId();\n       if (!validIds.contains(snapshotId)) {\n+        // determine whether the changes in this snapshot are in the current table state\n+        if (pickedAncestorSnapshotIds.contains(snapshotId)) {\n+          // this snapshot was cherry-picked into the current table state, so skip cleaning it up. its changes will\n+          // expire when the picked snapshot expires.\n+          // A -- C (source=B)\n+          //  `- B <-- this commit\n+          continue;\n+        }\n+\n+        long sourceSnapshotId = PropertyUtil.propertyAsLong(\n+            snapshot.summary(), SnapshotSummary.SOURCE_SNAPSHOT_ID_PROP, -1);\n+        if (ancestorIds.contains(sourceSnapshotId)) {\n+          // this commit was cherry-picked from a commit that is in the current table state. do not clean up its\n+          // changes because it would revert data file additions that are in the current table.\n+          // A -- B\n+          //  `- C (source=B) <-- this commit", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE0NDA3Ng=="}, "originalCommit": {"oid": "4c6cd676461069265ac2665781a08f34dd631b98"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NTc0MjU5OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/org/apache/iceberg/TestWapWorkflow.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxNzozMTowOVrOFscjGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxNzozMTowOVrOFscjGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE0OTQwMQ==", "bodyText": "I think these tests should be in the suite for snapshot expiration, not the suite for WAP. Can you move them?", "url": "https://github.com/apache/iceberg/pull/814#discussion_r382149401", "createdAt": "2020-02-20T17:31:09Z", "author": {"login": "rdblue"}, "path": "core/src/test/java/org/apache/iceberg/TestWapWorkflow.java", "diffHunk": "@@ -684,4 +685,87 @@ public void testNonWapCherrypick() {\n           table.manageSnapshots().cherrypick(firstSnapshotId).commit();\n         });\n   }\n+\n+  @Test\n+  public void testWithExpiringWapThenCherrypick() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c6cd676461069265ac2665781a08f34dd631b98"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NTc0NzYzOnYy", "diffSide": "RIGHT", "path": "core/src/test/java/org/apache/iceberg/TestWapWorkflow.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxNzozMjo0OVrOFscmXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxODozMTo0OFrOFsed5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE1MDIzOQ==", "bodyText": "The tests shouldn't use WAP properties at all. Correctness depends on where commits were picked and should ignore the WAP ID. The reason is that two commits with the same WAP id don't contain the same files. They are logically the same data, not physically the same files. The only equivalence that matters is when a snapshot itself has been picked because the files are physically the same.", "url": "https://github.com/apache/iceberg/pull/814#discussion_r382150239", "createdAt": "2020-02-20T17:32:49Z", "author": {"login": "rdblue"}, "path": "core/src/test/java/org/apache/iceberg/TestWapWorkflow.java", "diffHunk": "@@ -684,4 +685,87 @@ public void testNonWapCherrypick() {\n           table.manageSnapshots().cherrypick(firstSnapshotId).commit();\n         });\n   }\n+\n+  @Test\n+  public void testWithExpiringWapThenCherrypick() {\n+    table.newAppend()\n+            .appendFile(FILE_A)\n+            .commit();\n+    // first WAP commit\n+    table.newAppend()\n+            .appendFile(FILE_B)\n+            .set(SnapshotSummary.STAGED_WAP_ID_PROP, \"123456789\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c6cd676461069265ac2665781a08f34dd631b98"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE4MDgzOA==", "bodyText": "@mehtaashish23 - Can you add a UT for each scenario we are trying to handle? It might help debug in case we see rogue behavior. Thanks.", "url": "https://github.com/apache/iceberg/pull/814#discussion_r382180838", "createdAt": "2020-02-20T18:31:48Z", "author": {"login": "rominparekh"}, "path": "core/src/test/java/org/apache/iceberg/TestWapWorkflow.java", "diffHunk": "@@ -684,4 +685,87 @@ public void testNonWapCherrypick() {\n           table.manageSnapshots().cherrypick(firstSnapshotId).commit();\n         });\n   }\n+\n+  @Test\n+  public void testWithExpiringWapThenCherrypick() {\n+    table.newAppend()\n+            .appendFile(FILE_A)\n+            .commit();\n+    // first WAP commit\n+    table.newAppend()\n+            .appendFile(FILE_B)\n+            .set(SnapshotSummary.STAGED_WAP_ID_PROP, \"123456789\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE1MDIzOQ=="}, "originalCommit": {"oid": "4c6cd676461069265ac2665781a08f34dd631b98"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2OTMxODUzOnYy", "diffSide": "RIGHT", "path": "core/src/test/java/org/apache/iceberg/TableTestBase.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQxNzozMDowOVrOFs-zcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQyMTozNDo0M1rOFtFQiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcxMDY0Mg==", "bodyText": "This class doesn't need to change at all because you can use ExpireSnapshots.deleteWith and pass a callback. In each test case, you'd do this to get the list of deletes:\n  List<String> deletedFiles = Lists.newArrayList();\n  table.expireSnapshots()\n      .deleteWith(deletedFiles::add)\n      .expireOlderThan(t)\n      .commit();", "url": "https://github.com/apache/iceberg/pull/814#discussion_r382710642", "createdAt": "2020-02-21T17:30:09Z", "author": {"login": "rdblue"}, "path": "core/src/test/java/org/apache/iceberg/TableTestBase.java", "diffHunk": "@@ -109,8 +113,8 @@ public void cleanupTables() {\n         !name.startsWith(\"snap\") && Files.getFileExtension(name).equalsIgnoreCase(\"avro\")));\n   }\n \n-  private TestTables.TestTable create(Schema schema, PartitionSpec spec) {\n-    return TestTables.create(tableDir, \"test\", schema, spec);\n+  private TestTables.TestTable create(Schema schema, PartitionSpec spec, Boolean accumulateDeletedFiles) {\n+    return TestTables.create(tableDir, \"test\", schema, spec, accumulateDeletedFiles);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b69fdca2d4b97196b933c5677e6b11c0f93a2d8"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjgxNjM5Mg==", "bodyText": "ohh really. Thanks, nice API!", "url": "https://github.com/apache/iceberg/pull/814#discussion_r382816392", "createdAt": "2020-02-21T21:34:43Z", "author": {"login": "mehtaashish23"}, "path": "core/src/test/java/org/apache/iceberg/TableTestBase.java", "diffHunk": "@@ -109,8 +113,8 @@ public void cleanupTables() {\n         !name.startsWith(\"snap\") && Files.getFileExtension(name).equalsIgnoreCase(\"avro\")));\n   }\n \n-  private TestTables.TestTable create(Schema schema, PartitionSpec spec) {\n-    return TestTables.create(tableDir, \"test\", schema, spec);\n+  private TestTables.TestTable create(Schema schema, PartitionSpec spec, Boolean accumulateDeletedFiles) {\n+    return TestTables.create(tableDir, \"test\", schema, spec, accumulateDeletedFiles);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcxMDY0Mg=="}, "originalCommit": {"oid": "7b69fdca2d4b97196b933c5677e6b11c0f93a2d8"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2OTMyMDg2OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQxNzozMDo1NFrOFs-02w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQxNzozMDo1NFrOFs-02w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcxMTAwMw==", "bodyText": "This shouldn't use the name wap, since this is independent of the WAP pattern.", "url": "https://github.com/apache/iceberg/pull/814#discussion_r382711003", "createdAt": "2020-02-21T17:30:54Z", "author": {"login": "rdblue"}, "path": "core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java", "diffHunk": "@@ -387,4 +393,55 @@ public void dataFilesCleanup() throws IOException {\n     Assert.assertTrue(\"FILE_A should be deleted\", deletedFiles.contains(FILE_A.path().toString()));\n     Assert.assertTrue(\"FILE_B should be deleted\", deletedFiles.contains(FILE_B.path().toString()));\n   }\n+  @Test\n+  public void testWithExpiringWapThenCherrypick() {\n+    // first WAP commit\n+    table.newAppend()\n+            .appendFile(FILE_B)\n+            .stageOnly()\n+            .commit();\n+\n+    TableMetadata base = readMetadata();\n+    // pick the snapshot that's staged but not committed\n+    Snapshot wap1Snapshot = base.snapshots().get(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b69fdca2d4b97196b933c5677e6b11c0f93a2d8"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2OTMyMTk2OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQxNzozMToxOFrOFs-1gw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQxNzozMToxOFrOFs-1gw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcxMTE3MQ==", "bodyText": "Continuing indentation should be 4 spaces from the start of the previous line, not 8.", "url": "https://github.com/apache/iceberg/pull/814#discussion_r382711171", "createdAt": "2020-02-21T17:31:18Z", "author": {"login": "rdblue"}, "path": "core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java", "diffHunk": "@@ -387,4 +393,55 @@ public void dataFilesCleanup() throws IOException {\n     Assert.assertTrue(\"FILE_A should be deleted\", deletedFiles.contains(FILE_A.path().toString()));\n     Assert.assertTrue(\"FILE_B should be deleted\", deletedFiles.contains(FILE_B.path().toString()));\n   }\n+  @Test\n+  public void testWithExpiringWapThenCherrypick() {\n+    // first WAP commit\n+    table.newAppend()\n+            .appendFile(FILE_B)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b69fdca2d4b97196b933c5677e6b11c0f93a2d8"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3MDAyOTc4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/iceberg/RemoveSnapshots.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQyMTo1NTo1N1rOFtFv4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQyMjowNDozM1rOFww_4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjgyNDQxOA==", "bodyText": "Having D (cherry pick of B) isn't possible, if B is already an ancestor, encountered this while writing UTs.", "url": "https://github.com/apache/iceberg/pull/814#discussion_r382824418", "createdAt": "2020-02-21T21:55:57Z", "author": {"login": "mehtaashish23"}, "path": "core/src/main/java/org/apache/iceberg/RemoveSnapshots.java", "diffHunk": "@@ -208,12 +226,40 @@ private void cleanExpiredFiles(List<Snapshot> snapshots, Set<Long> validIds, Set\n       }\n     }\n \n+    // find manifests to clean up that were only referenced by snapshots that have expired\n     Set<String> manifestListsToDelete = Sets.newHashSet();\n     Set<String> manifestsToDelete = Sets.newHashSet();\n     Set<ManifestFile> manifestsToRevert = Sets.newHashSet();\n     for (Snapshot snapshot : base.snapshots()) {\n       long snapshotId = snapshot.snapshotId();\n       if (!validIds.contains(snapshotId)) {\n+        // determine whether the changes in this snapshot are in the current table state\n+        if (pickedAncestorSnapshotIds.contains(snapshotId)) {\n+          // this snapshot was cherry-picked into the current table state, so skip cleaning it up. its changes will\n+          // expire when the picked snapshot expires.\n+          // A -- C (source=B)\n+          //  `- B <-- this commit\n+          continue;\n+        }\n+\n+        long sourceSnapshotId = PropertyUtil.propertyAsLong(\n+            snapshot.summary(), SnapshotSummary.SOURCE_SNAPSHOT_ID_PROP, -1);\n+        if (ancestorIds.contains(sourceSnapshotId)) {\n+          // this commit was cherry-picked from a commit that is in the current table state. do not clean up its\n+          // changes because it would revert data file additions that are in the current table.\n+          // A -- B\n+          //  `- C (source=B) <-- this commit\n+          continue;\n+        }\n+\n+        if (pickedAncestorSnapshotIds.contains(sourceSnapshotId)) {\n+          // this commit was cherry-picked from a commit that is in the current table state. do not clean up its\n+          // changes because it would revert data file additions that are in the current table.\n+          // A -- C -- E (source=B)\n+          //  `- B `- D (source=B) <-- this commit", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8be7fcf76ecd1546f699e2d5b4f4562452f08c5b"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjY3ODc1NQ==", "bodyText": "The case that would cause this is:\n\nA is committed\nB is staged\nC is committed\nB is picked to create D\nThe table is rolled back to C\nB is picked to create E\n\nThe main thing is the rollback, which can cause alternate branches with the same commit picked. I would expect in practice to have other commits (like one between C and D that is removed by the rollback) but we don't need those to test this case.", "url": "https://github.com/apache/iceberg/pull/814#discussion_r386678755", "createdAt": "2020-03-02T22:04:33Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/RemoveSnapshots.java", "diffHunk": "@@ -208,12 +226,40 @@ private void cleanExpiredFiles(List<Snapshot> snapshots, Set<Long> validIds, Set\n       }\n     }\n \n+    // find manifests to clean up that were only referenced by snapshots that have expired\n     Set<String> manifestListsToDelete = Sets.newHashSet();\n     Set<String> manifestsToDelete = Sets.newHashSet();\n     Set<ManifestFile> manifestsToRevert = Sets.newHashSet();\n     for (Snapshot snapshot : base.snapshots()) {\n       long snapshotId = snapshot.snapshotId();\n       if (!validIds.contains(snapshotId)) {\n+        // determine whether the changes in this snapshot are in the current table state\n+        if (pickedAncestorSnapshotIds.contains(snapshotId)) {\n+          // this snapshot was cherry-picked into the current table state, so skip cleaning it up. its changes will\n+          // expire when the picked snapshot expires.\n+          // A -- C (source=B)\n+          //  `- B <-- this commit\n+          continue;\n+        }\n+\n+        long sourceSnapshotId = PropertyUtil.propertyAsLong(\n+            snapshot.summary(), SnapshotSummary.SOURCE_SNAPSHOT_ID_PROP, -1);\n+        if (ancestorIds.contains(sourceSnapshotId)) {\n+          // this commit was cherry-picked from a commit that is in the current table state. do not clean up its\n+          // changes because it would revert data file additions that are in the current table.\n+          // A -- B\n+          //  `- C (source=B) <-- this commit\n+          continue;\n+        }\n+\n+        if (pickedAncestorSnapshotIds.contains(sourceSnapshotId)) {\n+          // this commit was cherry-picked from a commit that is in the current table state. do not clean up its\n+          // changes because it would revert data file additions that are in the current table.\n+          // A -- C -- E (source=B)\n+          //  `- B `- D (source=B) <-- this commit", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjgyNDQxOA=="}, "originalCommit": {"oid": "8be7fcf76ecd1546f699e2d5b4f4562452f08c5b"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5NTM3OTkwOnYy", "diffSide": "RIGHT", "path": "core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQyMjowNjo1NFrOFwxEHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQyMjoxMToyM1rOFwxMXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjY3OTgzOQ==", "bodyText": "The label \"this commit\" makes sense in context for RemoveSnapshots because it is iterating through snapshots/commits. It makes less sense here. Instead, I would use \"current\" and note which commits are expiring (e.g., \"expiring A and B\").", "url": "https://github.com/apache/iceberg/pull/814#discussion_r386679839", "createdAt": "2020-03-02T22:06:54Z", "author": {"login": "rdblue"}, "path": "core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java", "diffHunk": "@@ -387,4 +388,163 @@ public void dataFilesCleanup() throws IOException {\n     Assert.assertTrue(\"FILE_A should be deleted\", deletedFiles.contains(FILE_A.path().toString()));\n     Assert.assertTrue(\"FILE_B should be deleted\", deletedFiles.contains(FILE_B.path().toString()));\n   }\n+\n+  /**\n+   * Test on table below, and expiring the staged commit `B` using `expireOlderThan` API.\n+   * Table: A - C\n+   *          ` B (staged)\n+   */\n+  @Test\n+  public void testWithExpiringDanglingStageCommit() {\n+    // `A` commit\n+    table.newAppend()\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    // `B` staged commit\n+    table.newAppend()\n+        .appendFile(FILE_B)\n+        .stageOnly()\n+        .commit();\n+\n+    TableMetadata base = readMetadata();\n+    Snapshot snapshotB = base.snapshots().get(1);\n+\n+    // `C` commit\n+    table.newAppend()\n+        .appendFile(FILE_C)\n+        .commit();\n+\n+    List<String> deletedFiles = new ArrayList<>();\n+\n+    // Expire all commits including dangling staged snapshot.\n+    table.expireSnapshots()\n+        .deleteWith(deletedFiles::add)\n+        .expireOlderThan(snapshotB.timestampMillis() + 1)\n+        .commit();\n+\n+    // Files should be deleted of dangling staged snapshot\n+    snapshotB.addedFiles().forEach(item -> {\n+      Assert.assertTrue(deletedFiles.contains(item.path().toString()));\n+    });\n+  }\n+\n+  /**\n+   * Expire cherry-pick the commit as shown below, when `B` is in table's current state\n+   *  Table:\n+   *  A - B\n+   *   `- C (B) <--this commit", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8be7fcf76ecd1546f699e2d5b4f4562452f08c5b"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjY4MTk0OQ==", "bodyText": "I think it would also be easier to understand if this explicitly labeled the source with (source=B) instead of just (B).", "url": "https://github.com/apache/iceberg/pull/814#discussion_r386681949", "createdAt": "2020-03-02T22:11:23Z", "author": {"login": "rdblue"}, "path": "core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java", "diffHunk": "@@ -387,4 +388,163 @@ public void dataFilesCleanup() throws IOException {\n     Assert.assertTrue(\"FILE_A should be deleted\", deletedFiles.contains(FILE_A.path().toString()));\n     Assert.assertTrue(\"FILE_B should be deleted\", deletedFiles.contains(FILE_B.path().toString()));\n   }\n+\n+  /**\n+   * Test on table below, and expiring the staged commit `B` using `expireOlderThan` API.\n+   * Table: A - C\n+   *          ` B (staged)\n+   */\n+  @Test\n+  public void testWithExpiringDanglingStageCommit() {\n+    // `A` commit\n+    table.newAppend()\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    // `B` staged commit\n+    table.newAppend()\n+        .appendFile(FILE_B)\n+        .stageOnly()\n+        .commit();\n+\n+    TableMetadata base = readMetadata();\n+    Snapshot snapshotB = base.snapshots().get(1);\n+\n+    // `C` commit\n+    table.newAppend()\n+        .appendFile(FILE_C)\n+        .commit();\n+\n+    List<String> deletedFiles = new ArrayList<>();\n+\n+    // Expire all commits including dangling staged snapshot.\n+    table.expireSnapshots()\n+        .deleteWith(deletedFiles::add)\n+        .expireOlderThan(snapshotB.timestampMillis() + 1)\n+        .commit();\n+\n+    // Files should be deleted of dangling staged snapshot\n+    snapshotB.addedFiles().forEach(item -> {\n+      Assert.assertTrue(deletedFiles.contains(item.path().toString()));\n+    });\n+  }\n+\n+  /**\n+   * Expire cherry-pick the commit as shown below, when `B` is in table's current state\n+   *  Table:\n+   *  A - B\n+   *   `- C (B) <--this commit", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjY3OTgzOQ=="}, "originalCommit": {"oid": "8be7fcf76ecd1546f699e2d5b4f4562452f08c5b"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5NTM4MzA0OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQyMjowODowN1rOFwxGMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQyMjowODowN1rOFwxGMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjY4MDM2OQ==", "bodyText": "Can you change this to an overwrite and also delete FILE_A? We should also test that deleted files are not physically deleted.", "url": "https://github.com/apache/iceberg/pull/814#discussion_r386680369", "createdAt": "2020-03-02T22:08:07Z", "author": {"login": "rdblue"}, "path": "core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java", "diffHunk": "@@ -387,4 +388,163 @@ public void dataFilesCleanup() throws IOException {\n     Assert.assertTrue(\"FILE_A should be deleted\", deletedFiles.contains(FILE_A.path().toString()));\n     Assert.assertTrue(\"FILE_B should be deleted\", deletedFiles.contains(FILE_B.path().toString()));\n   }\n+\n+  /**\n+   * Test on table below, and expiring the staged commit `B` using `expireOlderThan` API.\n+   * Table: A - C\n+   *          ` B (staged)\n+   */\n+  @Test\n+  public void testWithExpiringDanglingStageCommit() {\n+    // `A` commit\n+    table.newAppend()\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    // `B` staged commit\n+    table.newAppend()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8be7fcf76ecd1546f699e2d5b4f4562452f08c5b"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5NTM4OTQ2OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQyMjoxMDoxNFrOFwxKKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wN1QyMDo0NTo0NFrOFzRqGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjY4MTM4Ng==", "bodyText": "I think it would be more clear to use a Set<String> and validate using assertEquals. That way it verifies no additional files were deleted.\nSet<String> expectedDeletes = snapshotB.addedFiles().stream()\n    .map(added -> added.path().toString())\n    .collect(Collectors.toSet());\nAssert.assertEquals(\"Should delete only files added in snapshot B\", expectedDeletes, deletedFiles);", "url": "https://github.com/apache/iceberg/pull/814#discussion_r386681386", "createdAt": "2020-03-02T22:10:14Z", "author": {"login": "rdblue"}, "path": "core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java", "diffHunk": "@@ -387,4 +388,163 @@ public void dataFilesCleanup() throws IOException {\n     Assert.assertTrue(\"FILE_A should be deleted\", deletedFiles.contains(FILE_A.path().toString()));\n     Assert.assertTrue(\"FILE_B should be deleted\", deletedFiles.contains(FILE_B.path().toString()));\n   }\n+\n+  /**\n+   * Test on table below, and expiring the staged commit `B` using `expireOlderThan` API.\n+   * Table: A - C\n+   *          ` B (staged)\n+   */\n+  @Test\n+  public void testWithExpiringDanglingStageCommit() {\n+    // `A` commit\n+    table.newAppend()\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    // `B` staged commit\n+    table.newAppend()\n+        .appendFile(FILE_B)\n+        .stageOnly()\n+        .commit();\n+\n+    TableMetadata base = readMetadata();\n+    Snapshot snapshotB = base.snapshots().get(1);\n+\n+    // `C` commit\n+    table.newAppend()\n+        .appendFile(FILE_C)\n+        .commit();\n+\n+    List<String> deletedFiles = new ArrayList<>();\n+\n+    // Expire all commits including dangling staged snapshot.\n+    table.expireSnapshots()\n+        .deleteWith(deletedFiles::add)\n+        .expireOlderThan(snapshotB.timestampMillis() + 1)\n+        .commit();\n+\n+    // Files should be deleted of dangling staged snapshot\n+    snapshotB.addedFiles().forEach(item -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8be7fcf76ecd1546f699e2d5b4f4562452f08c5b"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxMTAwMg==", "bodyText": "+1, it would be good to add exact files, after considering following.\n\nApart from dataFile, we do delete manifests as well for dangling snapshots\nThe order in which the files are deleted, shouldn't matter, so I have handling that as well.\n\nI think, we should have couple of test to check manifest deletes in case of normal remove snapshots API. Let me know, I can log a ticket explicitly for that, if you agree.", "url": "https://github.com/apache/iceberg/pull/814#discussion_r389311002", "createdAt": "2020-03-07T20:45:44Z", "author": {"login": "mehtaashish23"}, "path": "core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java", "diffHunk": "@@ -387,4 +388,163 @@ public void dataFilesCleanup() throws IOException {\n     Assert.assertTrue(\"FILE_A should be deleted\", deletedFiles.contains(FILE_A.path().toString()));\n     Assert.assertTrue(\"FILE_B should be deleted\", deletedFiles.contains(FILE_B.path().toString()));\n   }\n+\n+  /**\n+   * Test on table below, and expiring the staged commit `B` using `expireOlderThan` API.\n+   * Table: A - C\n+   *          ` B (staged)\n+   */\n+  @Test\n+  public void testWithExpiringDanglingStageCommit() {\n+    // `A` commit\n+    table.newAppend()\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    // `B` staged commit\n+    table.newAppend()\n+        .appendFile(FILE_B)\n+        .stageOnly()\n+        .commit();\n+\n+    TableMetadata base = readMetadata();\n+    Snapshot snapshotB = base.snapshots().get(1);\n+\n+    // `C` commit\n+    table.newAppend()\n+        .appendFile(FILE_C)\n+        .commit();\n+\n+    List<String> deletedFiles = new ArrayList<>();\n+\n+    // Expire all commits including dangling staged snapshot.\n+    table.expireSnapshots()\n+        .deleteWith(deletedFiles::add)\n+        .expireOlderThan(snapshotB.timestampMillis() + 1)\n+        .commit();\n+\n+    // Files should be deleted of dangling staged snapshot\n+    snapshotB.addedFiles().forEach(item -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjY4MTM4Ng=="}, "originalCommit": {"oid": "8be7fcf76ecd1546f699e2d5b4f4562452f08c5b"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5NTQwMjcxOnYy", "diffSide": "RIGHT", "path": "core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQyMjoxNDoyNVrOFwxR5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQyMjoxNDoyNVrOFwxR5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjY4MzM2Nw==", "bodyText": "Nit: should have a newline before this comment.", "url": "https://github.com/apache/iceberg/pull/814#discussion_r386683367", "createdAt": "2020-03-02T22:14:25Z", "author": {"login": "rdblue"}, "path": "core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java", "diffHunk": "@@ -387,4 +388,163 @@ public void dataFilesCleanup() throws IOException {\n     Assert.assertTrue(\"FILE_A should be deleted\", deletedFiles.contains(FILE_A.path().toString()));\n     Assert.assertTrue(\"FILE_B should be deleted\", deletedFiles.contains(FILE_B.path().toString()));\n   }\n+\n+  /**\n+   * Test on table below, and expiring the staged commit `B` using `expireOlderThan` API.\n+   * Table: A - C\n+   *          ` B (staged)\n+   */\n+  @Test\n+  public void testWithExpiringDanglingStageCommit() {\n+    // `A` commit\n+    table.newAppend()\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    // `B` staged commit\n+    table.newAppend()\n+        .appendFile(FILE_B)\n+        .stageOnly()\n+        .commit();\n+\n+    TableMetadata base = readMetadata();\n+    Snapshot snapshotB = base.snapshots().get(1);\n+\n+    // `C` commit\n+    table.newAppend()\n+        .appendFile(FILE_C)\n+        .commit();\n+\n+    List<String> deletedFiles = new ArrayList<>();\n+\n+    // Expire all commits including dangling staged snapshot.\n+    table.expireSnapshots()\n+        .deleteWith(deletedFiles::add)\n+        .expireOlderThan(snapshotB.timestampMillis() + 1)\n+        .commit();\n+\n+    // Files should be deleted of dangling staged snapshot\n+    snapshotB.addedFiles().forEach(item -> {\n+      Assert.assertTrue(deletedFiles.contains(item.path().toString()));\n+    });\n+  }\n+\n+  /**\n+   * Expire cherry-pick the commit as shown below, when `B` is in table's current state\n+   *  Table:\n+   *  A - B\n+   *   `- C (B) <--this commit\n+   */\n+  @Test\n+  public void testWithCherryPickTableSnapshot() {\n+    // `A` commit\n+    table.newAppend()\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    // `B` commit\n+    table.newAppend()\n+        .appendFile(FILE_B)\n+        .commit();\n+    // pick the snapshot 'B`", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8be7fcf76ecd1546f699e2d5b4f4562452f08c5b"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5NTQxMDMxOnYy", "diffSide": "RIGHT", "path": "core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQyMjoxNzowNlrOFwxWig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQyMjoxNzowNlrOFwxWig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjY4NDU1NA==", "bodyText": "You can simplify this and avoid using expireSnapshotId by using expireOlderThan a future time (like you do in the next test). Snapshot B won't expire because it is the current snapshot.", "url": "https://github.com/apache/iceberg/pull/814#discussion_r386684554", "createdAt": "2020-03-02T22:17:06Z", "author": {"login": "rdblue"}, "path": "core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java", "diffHunk": "@@ -387,4 +388,163 @@ public void dataFilesCleanup() throws IOException {\n     Assert.assertTrue(\"FILE_A should be deleted\", deletedFiles.contains(FILE_A.path().toString()));\n     Assert.assertTrue(\"FILE_B should be deleted\", deletedFiles.contains(FILE_B.path().toString()));\n   }\n+\n+  /**\n+   * Test on table below, and expiring the staged commit `B` using `expireOlderThan` API.\n+   * Table: A - C\n+   *          ` B (staged)\n+   */\n+  @Test\n+  public void testWithExpiringDanglingStageCommit() {\n+    // `A` commit\n+    table.newAppend()\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    // `B` staged commit\n+    table.newAppend()\n+        .appendFile(FILE_B)\n+        .stageOnly()\n+        .commit();\n+\n+    TableMetadata base = readMetadata();\n+    Snapshot snapshotB = base.snapshots().get(1);\n+\n+    // `C` commit\n+    table.newAppend()\n+        .appendFile(FILE_C)\n+        .commit();\n+\n+    List<String> deletedFiles = new ArrayList<>();\n+\n+    // Expire all commits including dangling staged snapshot.\n+    table.expireSnapshots()\n+        .deleteWith(deletedFiles::add)\n+        .expireOlderThan(snapshotB.timestampMillis() + 1)\n+        .commit();\n+\n+    // Files should be deleted of dangling staged snapshot\n+    snapshotB.addedFiles().forEach(item -> {\n+      Assert.assertTrue(deletedFiles.contains(item.path().toString()));\n+    });\n+  }\n+\n+  /**\n+   * Expire cherry-pick the commit as shown below, when `B` is in table's current state\n+   *  Table:\n+   *  A - B\n+   *   `- C (B) <--this commit\n+   */\n+  @Test\n+  public void testWithCherryPickTableSnapshot() {\n+    // `A` commit\n+    table.newAppend()\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    // `B` commit\n+    table.newAppend()\n+        .appendFile(FILE_B)\n+        .commit();\n+    // pick the snapshot 'B`\n+    TableMetadata base = readMetadata();\n+    Snapshot snapshotA = base.snapshots().get(0);\n+    Snapshot snapshotB = base.snapshots().get(1);\n+\n+    // Move the table back to `A`\n+    table.manageSnapshots()\n+        .setCurrentSnapshot(snapshotA.snapshotId())\n+        .commit();\n+\n+    // Generate A -> `C (B)`\n+    table.manageSnapshots()\n+        .cherrypick(snapshotB.snapshotId())\n+        .commit();\n+    Snapshot snapshotC = readMetadata().currentSnapshot();\n+\n+    // Move the table back to `B`\n+    table.manageSnapshots()\n+        .setCurrentSnapshot(snapshotB.snapshotId())\n+        .commit();\n+    List<String> deletedFiles = new ArrayList<>();\n+\n+    // Expire `C`\n+    table.expireSnapshots()\n+        .deleteWith(deletedFiles::add)\n+        .expireSnapshotId(snapshotC.snapshotId())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8be7fcf76ecd1546f699e2d5b4f4562452f08c5b"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5NTQyMTMxOnYy", "diffSide": "RIGHT", "path": "core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQyMjoyMDo0MFrOFwxdIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wN1QyMjoyMDo1M1rOFzR_ZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjY4NjI0MQ==", "bodyText": "It wasn't clear at first why this was needed, but it is to avoid using a fast-forward commit instead of a cherry-pick. Can you update the comment in RemoveSnapshots since the case there isn't possible?", "url": "https://github.com/apache/iceberg/pull/814#discussion_r386686241", "createdAt": "2020-03-02T22:20:40Z", "author": {"login": "rdblue"}, "path": "core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java", "diffHunk": "@@ -387,4 +388,163 @@ public void dataFilesCleanup() throws IOException {\n     Assert.assertTrue(\"FILE_A should be deleted\", deletedFiles.contains(FILE_A.path().toString()));\n     Assert.assertTrue(\"FILE_B should be deleted\", deletedFiles.contains(FILE_B.path().toString()));\n   }\n+\n+  /**\n+   * Test on table below, and expiring the staged commit `B` using `expireOlderThan` API.\n+   * Table: A - C\n+   *          ` B (staged)\n+   */\n+  @Test\n+  public void testWithExpiringDanglingStageCommit() {\n+    // `A` commit\n+    table.newAppend()\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    // `B` staged commit\n+    table.newAppend()\n+        .appendFile(FILE_B)\n+        .stageOnly()\n+        .commit();\n+\n+    TableMetadata base = readMetadata();\n+    Snapshot snapshotB = base.snapshots().get(1);\n+\n+    // `C` commit\n+    table.newAppend()\n+        .appendFile(FILE_C)\n+        .commit();\n+\n+    List<String> deletedFiles = new ArrayList<>();\n+\n+    // Expire all commits including dangling staged snapshot.\n+    table.expireSnapshots()\n+        .deleteWith(deletedFiles::add)\n+        .expireOlderThan(snapshotB.timestampMillis() + 1)\n+        .commit();\n+\n+    // Files should be deleted of dangling staged snapshot\n+    snapshotB.addedFiles().forEach(item -> {\n+      Assert.assertTrue(deletedFiles.contains(item.path().toString()));\n+    });\n+  }\n+\n+  /**\n+   * Expire cherry-pick the commit as shown below, when `B` is in table's current state\n+   *  Table:\n+   *  A - B\n+   *   `- C (B) <--this commit\n+   */\n+  @Test\n+  public void testWithCherryPickTableSnapshot() {\n+    // `A` commit\n+    table.newAppend()\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    // `B` commit\n+    table.newAppend()\n+        .appendFile(FILE_B)\n+        .commit();\n+    // pick the snapshot 'B`\n+    TableMetadata base = readMetadata();\n+    Snapshot snapshotA = base.snapshots().get(0);\n+    Snapshot snapshotB = base.snapshots().get(1);\n+\n+    // Move the table back to `A`\n+    table.manageSnapshots()\n+        .setCurrentSnapshot(snapshotA.snapshotId())\n+        .commit();\n+\n+    // Generate A -> `C (B)`\n+    table.manageSnapshots()\n+        .cherrypick(snapshotB.snapshotId())\n+        .commit();\n+    Snapshot snapshotC = readMetadata().currentSnapshot();\n+\n+    // Move the table back to `B`\n+    table.manageSnapshots()\n+        .setCurrentSnapshot(snapshotB.snapshotId())\n+        .commit();\n+    List<String> deletedFiles = new ArrayList<>();\n+\n+    // Expire `C`\n+    table.expireSnapshots()\n+        .deleteWith(deletedFiles::add)\n+        .expireSnapshotId(snapshotC.snapshotId())\n+        .commit();\n+\n+    // Make sure no dataFiles are deleted for the B and C snapshot\n+    Lists.newArrayList(snapshotB, snapshotC).forEach(i -> {\n+      i.addedFiles().forEach(item -> {\n+        Assert.assertFalse(deletedFiles.contains(item.path().toString()));\n+      });\n+    });\n+  }\n+\n+  /**\n+   * Test on table below, and expiring\n+   *  1) Expire `B`\n+   *  2) All commit\n+   * Table: A - C - D (B)\n+   *          ` B (staged)\n+   */\n+  @Test\n+  public void testWithExpiringStagedThenCherrypick() {\n+    // `A` commit\n+    table.newAppend()\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    // `B` commit\n+    table.newAppend()\n+        .appendFile(FILE_B)\n+        .stageOnly()\n+        .commit();\n+\n+    // pick the snapshot that's staged but not committed\n+    TableMetadata base = readMetadata();\n+    Snapshot snapshotB = base.snapshots().get(1);\n+\n+    // `C` commit to let cherry-pick take effect", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8be7fcf76ecd1546f699e2d5b4f4562452f08c5b"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNjQ1Mg==", "bodyText": "Yeah, I have also changed another UT, which was not taking care of fast forward.", "url": "https://github.com/apache/iceberg/pull/814#discussion_r389316452", "createdAt": "2020-03-07T22:20:53Z", "author": {"login": "mehtaashish23"}, "path": "core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java", "diffHunk": "@@ -387,4 +388,163 @@ public void dataFilesCleanup() throws IOException {\n     Assert.assertTrue(\"FILE_A should be deleted\", deletedFiles.contains(FILE_A.path().toString()));\n     Assert.assertTrue(\"FILE_B should be deleted\", deletedFiles.contains(FILE_B.path().toString()));\n   }\n+\n+  /**\n+   * Test on table below, and expiring the staged commit `B` using `expireOlderThan` API.\n+   * Table: A - C\n+   *          ` B (staged)\n+   */\n+  @Test\n+  public void testWithExpiringDanglingStageCommit() {\n+    // `A` commit\n+    table.newAppend()\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    // `B` staged commit\n+    table.newAppend()\n+        .appendFile(FILE_B)\n+        .stageOnly()\n+        .commit();\n+\n+    TableMetadata base = readMetadata();\n+    Snapshot snapshotB = base.snapshots().get(1);\n+\n+    // `C` commit\n+    table.newAppend()\n+        .appendFile(FILE_C)\n+        .commit();\n+\n+    List<String> deletedFiles = new ArrayList<>();\n+\n+    // Expire all commits including dangling staged snapshot.\n+    table.expireSnapshots()\n+        .deleteWith(deletedFiles::add)\n+        .expireOlderThan(snapshotB.timestampMillis() + 1)\n+        .commit();\n+\n+    // Files should be deleted of dangling staged snapshot\n+    snapshotB.addedFiles().forEach(item -> {\n+      Assert.assertTrue(deletedFiles.contains(item.path().toString()));\n+    });\n+  }\n+\n+  /**\n+   * Expire cherry-pick the commit as shown below, when `B` is in table's current state\n+   *  Table:\n+   *  A - B\n+   *   `- C (B) <--this commit\n+   */\n+  @Test\n+  public void testWithCherryPickTableSnapshot() {\n+    // `A` commit\n+    table.newAppend()\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    // `B` commit\n+    table.newAppend()\n+        .appendFile(FILE_B)\n+        .commit();\n+    // pick the snapshot 'B`\n+    TableMetadata base = readMetadata();\n+    Snapshot snapshotA = base.snapshots().get(0);\n+    Snapshot snapshotB = base.snapshots().get(1);\n+\n+    // Move the table back to `A`\n+    table.manageSnapshots()\n+        .setCurrentSnapshot(snapshotA.snapshotId())\n+        .commit();\n+\n+    // Generate A -> `C (B)`\n+    table.manageSnapshots()\n+        .cherrypick(snapshotB.snapshotId())\n+        .commit();\n+    Snapshot snapshotC = readMetadata().currentSnapshot();\n+\n+    // Move the table back to `B`\n+    table.manageSnapshots()\n+        .setCurrentSnapshot(snapshotB.snapshotId())\n+        .commit();\n+    List<String> deletedFiles = new ArrayList<>();\n+\n+    // Expire `C`\n+    table.expireSnapshots()\n+        .deleteWith(deletedFiles::add)\n+        .expireSnapshotId(snapshotC.snapshotId())\n+        .commit();\n+\n+    // Make sure no dataFiles are deleted for the B and C snapshot\n+    Lists.newArrayList(snapshotB, snapshotC).forEach(i -> {\n+      i.addedFiles().forEach(item -> {\n+        Assert.assertFalse(deletedFiles.contains(item.path().toString()));\n+      });\n+    });\n+  }\n+\n+  /**\n+   * Test on table below, and expiring\n+   *  1) Expire `B`\n+   *  2) All commit\n+   * Table: A - C - D (B)\n+   *          ` B (staged)\n+   */\n+  @Test\n+  public void testWithExpiringStagedThenCherrypick() {\n+    // `A` commit\n+    table.newAppend()\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    // `B` commit\n+    table.newAppend()\n+        .appendFile(FILE_B)\n+        .stageOnly()\n+        .commit();\n+\n+    // pick the snapshot that's staged but not committed\n+    TableMetadata base = readMetadata();\n+    Snapshot snapshotB = base.snapshots().get(1);\n+\n+    // `C` commit to let cherry-pick take effect", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjY4NjI0MQ=="}, "originalCommit": {"oid": "8be7fcf76ecd1546f699e2d5b4f4562452f08c5b"}, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNjg5NzY0OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQyMzoxMjozMVrOFz8YnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxNzoxNDo1NlrOF0Y3VQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxMTAzNw==", "bodyText": "Why does this remove files from the set instead of using assertEqual?", "url": "https://github.com/apache/iceberg/pull/814#discussion_r390011037", "createdAt": "2020-03-09T23:12:31Z", "author": {"login": "rdblue"}, "path": "core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java", "diffHunk": "@@ -387,4 +389,190 @@ public void dataFilesCleanup() throws IOException {\n     Assert.assertTrue(\"FILE_A should be deleted\", deletedFiles.contains(FILE_A.path().toString()));\n     Assert.assertTrue(\"FILE_B should be deleted\", deletedFiles.contains(FILE_B.path().toString()));\n   }\n+\n+  /**\n+   * Test on table below, and expiring the staged commit `B` using `expireOlderThan` API.\n+   * Table: A - C\n+   *          ` B (staged)\n+   */\n+  @Test\n+  public void testWithExpiringDanglingStageCommit() {\n+    // `A` commit\n+    table.newAppend()\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    // `B` staged commit\n+    table.newAppend()\n+        .appendFile(FILE_B)\n+        .stageOnly()\n+        .commit();\n+\n+    TableMetadata base = readMetadata();\n+    Snapshot snapshotA = base.snapshots().get(0);\n+    Snapshot snapshotB = base.snapshots().get(1);\n+\n+    // `C` commit\n+    table.newAppend()\n+        .appendFile(FILE_C)\n+        .commit();\n+\n+    Set<String> deletedFiles = new HashSet<>();\n+\n+    // Expire all commits including dangling staged snapshot.\n+    table.expireSnapshots()\n+        .deleteWith(deletedFiles::add)\n+        .expireOlderThan(snapshotB.timestampMillis() + 1)\n+        .commit();\n+\n+    Set<String> expectedDeletes = new HashSet<>();\n+    expectedDeletes.add(snapshotA.manifestListLocation());\n+\n+    // Files should be deleted of dangling staged snapshot\n+    snapshotB.addedFiles().forEach(i -> {\n+      expectedDeletes.add(i.path().toString());\n+    });\n+\n+    // ManifestList should be deleted too\n+    expectedDeletes.add(snapshotB.manifestListLocation());\n+    snapshotB.manifests().forEach(file -> {\n+      //Only the manifest of B should be deleted.\n+      if (file.snapshotId() == snapshotB.snapshotId()) {\n+        expectedDeletes.add(file.path());\n+      }\n+    });\n+    Assert.assertSame(\"Files deleted count should be expected\", expectedDeletes.size(), deletedFiles.size());\n+    //Take the diff\n+    expectedDeletes.removeAll(deletedFiles);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6a3b3db2728f32dad6db5ef8f9c701a1f7793af7"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA0Mjk2Ng==", "bodyText": "The order was coming to be different, and I didn't wanted to rely on order.", "url": "https://github.com/apache/iceberg/pull/814#discussion_r390042966", "createdAt": "2020-03-10T01:09:37Z", "author": {"login": "mehtaashish23"}, "path": "core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java", "diffHunk": "@@ -387,4 +389,190 @@ public void dataFilesCleanup() throws IOException {\n     Assert.assertTrue(\"FILE_A should be deleted\", deletedFiles.contains(FILE_A.path().toString()));\n     Assert.assertTrue(\"FILE_B should be deleted\", deletedFiles.contains(FILE_B.path().toString()));\n   }\n+\n+  /**\n+   * Test on table below, and expiring the staged commit `B` using `expireOlderThan` API.\n+   * Table: A - C\n+   *          ` B (staged)\n+   */\n+  @Test\n+  public void testWithExpiringDanglingStageCommit() {\n+    // `A` commit\n+    table.newAppend()\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    // `B` staged commit\n+    table.newAppend()\n+        .appendFile(FILE_B)\n+        .stageOnly()\n+        .commit();\n+\n+    TableMetadata base = readMetadata();\n+    Snapshot snapshotA = base.snapshots().get(0);\n+    Snapshot snapshotB = base.snapshots().get(1);\n+\n+    // `C` commit\n+    table.newAppend()\n+        .appendFile(FILE_C)\n+        .commit();\n+\n+    Set<String> deletedFiles = new HashSet<>();\n+\n+    // Expire all commits including dangling staged snapshot.\n+    table.expireSnapshots()\n+        .deleteWith(deletedFiles::add)\n+        .expireOlderThan(snapshotB.timestampMillis() + 1)\n+        .commit();\n+\n+    Set<String> expectedDeletes = new HashSet<>();\n+    expectedDeletes.add(snapshotA.manifestListLocation());\n+\n+    // Files should be deleted of dangling staged snapshot\n+    snapshotB.addedFiles().forEach(i -> {\n+      expectedDeletes.add(i.path().toString());\n+    });\n+\n+    // ManifestList should be deleted too\n+    expectedDeletes.add(snapshotB.manifestListLocation());\n+    snapshotB.manifests().forEach(file -> {\n+      //Only the manifest of B should be deleted.\n+      if (file.snapshotId() == snapshotB.snapshotId()) {\n+        expectedDeletes.add(file.path());\n+      }\n+    });\n+    Assert.assertSame(\"Files deleted count should be expected\", expectedDeletes.size(), deletedFiles.size());\n+    //Take the diff\n+    expectedDeletes.removeAll(deletedFiles);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxMTAzNw=="}, "originalCommit": {"oid": "6a3b3db2728f32dad6db5ef8f9c701a1f7793af7"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQ3NzY1Mw==", "bodyText": "Comparing two sets would not rely on order.", "url": "https://github.com/apache/iceberg/pull/814#discussion_r390477653", "createdAt": "2020-03-10T17:14:56Z", "author": {"login": "rdblue"}, "path": "core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java", "diffHunk": "@@ -387,4 +389,190 @@ public void dataFilesCleanup() throws IOException {\n     Assert.assertTrue(\"FILE_A should be deleted\", deletedFiles.contains(FILE_A.path().toString()));\n     Assert.assertTrue(\"FILE_B should be deleted\", deletedFiles.contains(FILE_B.path().toString()));\n   }\n+\n+  /**\n+   * Test on table below, and expiring the staged commit `B` using `expireOlderThan` API.\n+   * Table: A - C\n+   *          ` B (staged)\n+   */\n+  @Test\n+  public void testWithExpiringDanglingStageCommit() {\n+    // `A` commit\n+    table.newAppend()\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    // `B` staged commit\n+    table.newAppend()\n+        .appendFile(FILE_B)\n+        .stageOnly()\n+        .commit();\n+\n+    TableMetadata base = readMetadata();\n+    Snapshot snapshotA = base.snapshots().get(0);\n+    Snapshot snapshotB = base.snapshots().get(1);\n+\n+    // `C` commit\n+    table.newAppend()\n+        .appendFile(FILE_C)\n+        .commit();\n+\n+    Set<String> deletedFiles = new HashSet<>();\n+\n+    // Expire all commits including dangling staged snapshot.\n+    table.expireSnapshots()\n+        .deleteWith(deletedFiles::add)\n+        .expireOlderThan(snapshotB.timestampMillis() + 1)\n+        .commit();\n+\n+    Set<String> expectedDeletes = new HashSet<>();\n+    expectedDeletes.add(snapshotA.manifestListLocation());\n+\n+    // Files should be deleted of dangling staged snapshot\n+    snapshotB.addedFiles().forEach(i -> {\n+      expectedDeletes.add(i.path().toString());\n+    });\n+\n+    // ManifestList should be deleted too\n+    expectedDeletes.add(snapshotB.manifestListLocation());\n+    snapshotB.manifests().forEach(file -> {\n+      //Only the manifest of B should be deleted.\n+      if (file.snapshotId() == snapshotB.snapshotId()) {\n+        expectedDeletes.add(file.path());\n+      }\n+    });\n+    Assert.assertSame(\"Files deleted count should be expected\", expectedDeletes.size(), deletedFiles.size());\n+    //Take the diff\n+    expectedDeletes.removeAll(deletedFiles);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxMTAzNw=="}, "originalCommit": {"oid": "6a3b3db2728f32dad6db5ef8f9c701a1f7793af7"}, "originalPosition": 67}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3037, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}