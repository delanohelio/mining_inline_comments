{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDUyNjk4OTc4", "number": 1216, "reviewThreads": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOFQwMDozNDoyOFrOEWZXmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNzoyODoyMFrOEcLClQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxOTE5NzcxOnYy", "diffSide": "RIGHT", "path": "python/iceberg/core/base_metastore_tables.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOFQwMDozNDoyOFrOG9sCLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yM1QxMTo0ODozMlrOHFMgMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzNzc3NA==", "bodyText": "In load, the number of items returned is checked. Should that be done here as well?", "url": "https://github.com/apache/iceberg/pull/1216#discussion_r467337774", "createdAt": "2020-08-08T00:34:28Z", "author": {"login": "rdblue"}, "path": "python/iceberg/core/base_metastore_tables.py", "diffHunk": "@@ -16,28 +16,51 @@\n # under the License.\n \n from iceberg.api import Tables\n-from iceberg.exceptions import NoSuchTableException\n+from iceberg.exceptions import AlreadyExistsException, CommitFailedException, NoSuchTableException\n \n from .base_table import BaseTable\n+from .table_metadata import TableMetadata\n \n \n class BaseMetastoreTables(Tables):\n+    DOT = '.'\n \n     def __init__(self, conf):\n         self.conf = conf\n \n     def new_table_ops(self, conf, database, table):\n         raise RuntimeError(\"Abstract Implementation\")\n \n-    def load(self, database, table):\n+    def load(self, table_identifier):\n+        parts = table_identifier.rsplit(BaseMetastoreTables.DOT, 1)\n+        if len(parts) > 1:\n+            database = parts[0]\n+            table = parts[1]\n+        else:\n+            database = \"default\"\n+            table = parts[0]\n         ops = self.new_table_ops(self.conf, database, table)\n         if ops.current() is None:\n             raise NoSuchTableException(\"Table does not exist: {}.{}\".format(database, table))\n \n         return BaseTable(ops, \"{}.{}\".format(database, table))\n \n-    def create(self, schema, spec, table_identifier=None, database=None, table=None):\n-        raise RuntimeError(\"Not Yet Implemented\")\n+    def create(self, schema, table_identifier=None, spec=None, properties=None):\n+        database, table = table_identifier.rsplit(BaseMetastoreTables.DOT, 1)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8aff14ff2ecab4a94d721b4ffe70885b90fec329"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTIwOTc3OA==", "bodyText": "yes, fixed", "url": "https://github.com/apache/iceberg/pull/1216#discussion_r475209778", "createdAt": "2020-08-23T11:48:32Z", "author": {"login": "rymurr"}, "path": "python/iceberg/core/base_metastore_tables.py", "diffHunk": "@@ -16,28 +16,51 @@\n # under the License.\n \n from iceberg.api import Tables\n-from iceberg.exceptions import NoSuchTableException\n+from iceberg.exceptions import AlreadyExistsException, CommitFailedException, NoSuchTableException\n \n from .base_table import BaseTable\n+from .table_metadata import TableMetadata\n \n \n class BaseMetastoreTables(Tables):\n+    DOT = '.'\n \n     def __init__(self, conf):\n         self.conf = conf\n \n     def new_table_ops(self, conf, database, table):\n         raise RuntimeError(\"Abstract Implementation\")\n \n-    def load(self, database, table):\n+    def load(self, table_identifier):\n+        parts = table_identifier.rsplit(BaseMetastoreTables.DOT, 1)\n+        if len(parts) > 1:\n+            database = parts[0]\n+            table = parts[1]\n+        else:\n+            database = \"default\"\n+            table = parts[0]\n         ops = self.new_table_ops(self.conf, database, table)\n         if ops.current() is None:\n             raise NoSuchTableException(\"Table does not exist: {}.{}\".format(database, table))\n \n         return BaseTable(ops, \"{}.{}\".format(database, table))\n \n-    def create(self, schema, spec, table_identifier=None, database=None, table=None):\n-        raise RuntimeError(\"Not Yet Implemented\")\n+    def create(self, schema, table_identifier=None, spec=None, properties=None):\n+        database, table = table_identifier.rsplit(BaseMetastoreTables.DOT, 1)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzNzc3NA=="}, "originalCommit": {"oid": "8aff14ff2ecab4a94d721b4ffe70885b90fec329"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxOTE5OTM2OnYy", "diffSide": "RIGHT", "path": "python/iceberg/core/base_metastore_tables.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOFQwMDozNTo0NlrOG9sDCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yM1QxMTo0ODo1NVrOHFMgUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzNzk5NQ==", "bodyText": "I'm getting a warning about PEP 8 and limiting lines to 120 chars. Is that something we want to do in Python?\nSeems to make sense to me to limit lines to 120.", "url": "https://github.com/apache/iceberg/pull/1216#discussion_r467337995", "createdAt": "2020-08-08T00:35:46Z", "author": {"login": "rdblue"}, "path": "python/iceberg/core/base_metastore_tables.py", "diffHunk": "@@ -16,28 +16,51 @@\n # under the License.\n \n from iceberg.api import Tables\n-from iceberg.exceptions import NoSuchTableException\n+from iceberg.exceptions import AlreadyExistsException, CommitFailedException, NoSuchTableException\n \n from .base_table import BaseTable\n+from .table_metadata import TableMetadata\n \n \n class BaseMetastoreTables(Tables):\n+    DOT = '.'\n \n     def __init__(self, conf):\n         self.conf = conf\n \n     def new_table_ops(self, conf, database, table):\n         raise RuntimeError(\"Abstract Implementation\")\n \n-    def load(self, database, table):\n+    def load(self, table_identifier):\n+        parts = table_identifier.rsplit(BaseMetastoreTables.DOT, 1)\n+        if len(parts) > 1:\n+            database = parts[0]\n+            table = parts[1]\n+        else:\n+            database = \"default\"\n+            table = parts[0]\n         ops = self.new_table_ops(self.conf, database, table)\n         if ops.current() is None:\n             raise NoSuchTableException(\"Table does not exist: {}.{}\".format(database, table))\n \n         return BaseTable(ops, \"{}.{}\".format(database, table))\n \n-    def create(self, schema, spec, table_identifier=None, database=None, table=None):\n-        raise RuntimeError(\"Not Yet Implemented\")\n+    def create(self, schema, table_identifier=None, spec=None, properties=None):\n+        database, table = table_identifier.rsplit(BaseMetastoreTables.DOT, 1)\n+        ops = self.new_table_ops(self.conf, database, table)\n+        if ops.current() is not None:\n+            raise AlreadyExistsException(\"Table already exists: \" + table_identifier)\n+\n+        base_location = self.default_warehouse_location(self.conf, database, table)\n+\n+        metadata = TableMetadata.new_table_metadata(ops, schema, spec, base_location, dict() if properties is None else properties)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8aff14ff2ecab4a94d721b4ffe70885b90fec329"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTIwOTgxMQ==", "bodyText": "yeah, its strange it wasn't caught by flake8. Fixed now", "url": "https://github.com/apache/iceberg/pull/1216#discussion_r475209811", "createdAt": "2020-08-23T11:48:55Z", "author": {"login": "rymurr"}, "path": "python/iceberg/core/base_metastore_tables.py", "diffHunk": "@@ -16,28 +16,51 @@\n # under the License.\n \n from iceberg.api import Tables\n-from iceberg.exceptions import NoSuchTableException\n+from iceberg.exceptions import AlreadyExistsException, CommitFailedException, NoSuchTableException\n \n from .base_table import BaseTable\n+from .table_metadata import TableMetadata\n \n \n class BaseMetastoreTables(Tables):\n+    DOT = '.'\n \n     def __init__(self, conf):\n         self.conf = conf\n \n     def new_table_ops(self, conf, database, table):\n         raise RuntimeError(\"Abstract Implementation\")\n \n-    def load(self, database, table):\n+    def load(self, table_identifier):\n+        parts = table_identifier.rsplit(BaseMetastoreTables.DOT, 1)\n+        if len(parts) > 1:\n+            database = parts[0]\n+            table = parts[1]\n+        else:\n+            database = \"default\"\n+            table = parts[0]\n         ops = self.new_table_ops(self.conf, database, table)\n         if ops.current() is None:\n             raise NoSuchTableException(\"Table does not exist: {}.{}\".format(database, table))\n \n         return BaseTable(ops, \"{}.{}\".format(database, table))\n \n-    def create(self, schema, spec, table_identifier=None, database=None, table=None):\n-        raise RuntimeError(\"Not Yet Implemented\")\n+    def create(self, schema, table_identifier=None, spec=None, properties=None):\n+        database, table = table_identifier.rsplit(BaseMetastoreTables.DOT, 1)\n+        ops = self.new_table_ops(self.conf, database, table)\n+        if ops.current() is not None:\n+            raise AlreadyExistsException(\"Table already exists: \" + table_identifier)\n+\n+        base_location = self.default_warehouse_location(self.conf, database, table)\n+\n+        metadata = TableMetadata.new_table_metadata(ops, schema, spec, base_location, dict() if properties is None else properties)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzNzk5NQ=="}, "originalCommit": {"oid": "8aff14ff2ecab4a94d721b4ffe70885b90fec329"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxOTIwMzg1OnYy", "diffSide": "RIGHT", "path": "python/iceberg/core/base_metastore_tables.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOFQwMDo0MDoyMlrOG9sFaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yM1QxMTo0MTo1M1rOHFMdtw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzODYwMQ==", "bodyText": "Minor: if we add types, the docs are better. For example, changing this to table_identifier: str made it so that documentation for str.rsplit is found, at least in PyCharm. We should probably start adding types where it makes sense, like in the base class Tables.\nNot something we need to do in this commit, but it really helps reviewing.", "url": "https://github.com/apache/iceberg/pull/1216#discussion_r467338601", "createdAt": "2020-08-08T00:40:22Z", "author": {"login": "rdblue"}, "path": "python/iceberg/core/base_metastore_tables.py", "diffHunk": "@@ -16,28 +16,51 @@\n # under the License.\n \n from iceberg.api import Tables\n-from iceberg.exceptions import NoSuchTableException\n+from iceberg.exceptions import AlreadyExistsException, CommitFailedException, NoSuchTableException\n \n from .base_table import BaseTable\n+from .table_metadata import TableMetadata\n \n \n class BaseMetastoreTables(Tables):\n+    DOT = '.'\n \n     def __init__(self, conf):\n         self.conf = conf\n \n     def new_table_ops(self, conf, database, table):\n         raise RuntimeError(\"Abstract Implementation\")\n \n-    def load(self, database, table):\n+    def load(self, table_identifier):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8aff14ff2ecab4a94d721b4ffe70885b90fec329"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTIwOTE0Mw==", "bodyText": "I agree, I have added types in places where this PR has made changes. Hopefully we can build full type coverage over time rather than having someone slog through the code base and add them individually", "url": "https://github.com/apache/iceberg/pull/1216#discussion_r475209143", "createdAt": "2020-08-23T11:41:53Z", "author": {"login": "rymurr"}, "path": "python/iceberg/core/base_metastore_tables.py", "diffHunk": "@@ -16,28 +16,51 @@\n # under the License.\n \n from iceberg.api import Tables\n-from iceberg.exceptions import NoSuchTableException\n+from iceberg.exceptions import AlreadyExistsException, CommitFailedException, NoSuchTableException\n \n from .base_table import BaseTable\n+from .table_metadata import TableMetadata\n \n \n class BaseMetastoreTables(Tables):\n+    DOT = '.'\n \n     def __init__(self, conf):\n         self.conf = conf\n \n     def new_table_ops(self, conf, database, table):\n         raise RuntimeError(\"Abstract Implementation\")\n \n-    def load(self, database, table):\n+    def load(self, table_identifier):", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzODYwMQ=="}, "originalCommit": {"oid": "8aff14ff2ecab4a94d721b4ffe70885b90fec329"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxOTIwNjAwOnYy", "diffSide": "RIGHT", "path": "python/iceberg/core/filesystem/filesystem_tables.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOFQwMDo0MjoxOVrOG9sGhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yM1QxMTozNTowNVrOHFMbEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzODg4NQ==", "bodyText": "I agree with using table_identifier here. Should we also rename it in load since the location is the table identifier for FS tables?", "url": "https://github.com/apache/iceberg/pull/1216#discussion_r467338885", "createdAt": "2020-08-08T00:42:19Z", "author": {"login": "rdblue"}, "path": "python/iceberg/core/filesystem/filesystem_tables.py", "diffHunk": "@@ -36,15 +35,15 @@ def load(self, location):\n \n         return BaseTable(ops, location)\n \n-    def create(self, schema, table_identifier=None, spec=None, properties=None, location=None):\n+    def create(self, schema, table_identifier=None, spec=None, properties=None):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8aff14ff2ecab4a94d721b4ffe70885b90fec329"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTIwODQ2Nw==", "bodyText": "agreed, fixed", "url": "https://github.com/apache/iceberg/pull/1216#discussion_r475208467", "createdAt": "2020-08-23T11:35:05Z", "author": {"login": "rymurr"}, "path": "python/iceberg/core/filesystem/filesystem_tables.py", "diffHunk": "@@ -36,15 +35,15 @@ def load(self, location):\n \n         return BaseTable(ops, location)\n \n-    def create(self, schema, table_identifier=None, spec=None, properties=None, location=None):\n+    def create(self, schema, table_identifier=None, spec=None, properties=None):", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzODg4NQ=="}, "originalCommit": {"oid": "8aff14ff2ecab4a94d721b4ffe70885b90fec329"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxOTIzMTQ1OnYy", "diffSide": "RIGHT", "path": "python/iceberg/hive/hive_table_operations.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOFQwMTowNjo1OVrOG9sTZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yM1QxMjoyNjowOFrOHFMt1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzM0MjE4Mw==", "bodyText": "Couldn't this just be if self.current_metadata_location? I think both None and \"\" evaluate to False in python if statements.", "url": "https://github.com/apache/iceberg/pull/1216#discussion_r467342183", "createdAt": "2020-08-08T01:06:59Z", "author": {"login": "rdblue"}, "path": "python/iceberg/hive/hive_table_operations.py", "diffHunk": "@@ -50,10 +63,146 @@ def refresh(self):\n         return self.current()\n \n     def commit(self, base, metadata):\n-        raise NotImplementedError()\n+        new_metadata_location = self.write_new_metadata(metadata, self.version + 1)\n+\n+        threw = True\n+        lock_id = None\n+        try:\n+            lock_id = self.acquire_lock()\n+            if base is not None:\n+                with self._client as open_client:\n+                    tbl = open_client.get_table(self.database, self.table)\n+            else:\n+                current_time_millis = int(time.time())\n+                tbl = Table(self.table,\n+                            self.database,\n+                            getpass.getuser(),\n+                            current_time_millis // 1000,\n+                            current_time_millis // 1000,\n+                            sd=storage_descriptor(metadata),\n+                            tableType=\"EXTERNAL_TABLE\",\n+                            parameters={'EXTERNAL': 'TRUE'})\n+\n+            tbl.sd = storage_descriptor(metadata)\n+            metadata_location = tbl.parameters.get(BaseMetastoreTableOperations.METADATA_LOCATION_PROP, None)\n+            base_metadata_location = base.metadataFileLocation() if base is not None else None\n+            if base_metadata_location != metadata_location:\n+                raise CommitFailedException(\n+                    \"Base metadata location '%s' is not same as the current table metadata location '%s' for %s.%s\",\n+                    base_metadata_location, metadata_location, self.database, self.table)\n+\n+            self.set_parameters(new_metadata_location, tbl)\n+\n+            if base is not None:\n+                with self._client as open_client:\n+                    env_context = EnvironmentContext(\n+                        {\"DO_NOT_UPDATE_STATS\": \"true\"}\n+                    )\n+                    open_client.alter_table(self.database, self.table, tbl, env_context)\n+\n+            else:\n+                with self._client as open_client:\n+                    open_client.create_table(tbl)\n+            threw = False\n+        except AlreadyExistsException:\n+            raise IcebergAlreadyExistsException(\"Table already exists: {}.{}\".format(self.database, self.table))\n+        except TException as e:\n+            if e is not None and \"Table/View 'HIVE_LOCKS' does not exist\" in str(e):\n+                raise Exception(\"\"\"Failed to acquire locks from metastore because 'HIVE_LOCKS' doesn't\n+                                exist, this probably happened when using embedded metastore or doesn't create a\n+                                transactional meta table. To fix this, use an alternative metastore\"\"\", e)\n+\n+            raise Exception(\"Metastore operation failed for {}.{}\".format(self.database, self.table), e)\n+        finally:\n+            if threw:\n+                self.io().delete(new_metadata_location)\n+            self.unlock(lock_id)\n+\n+    def set_parameters(self, new_metadata_location, tbl):\n+        parameters = tbl.parameters\n+\n+        if not parameters:\n+            parameters = dict()\n+\n+        parameters[BaseMetastoreTableOperations.TABLE_TYPE_PROP] = \\\n+            BaseMetastoreTableOperations.ICEBERG_TABLE_TYPE_VALUE.upper()\n+        parameters[BaseMetastoreTableOperations.METADATA_LOCATION_PROP] = new_metadata_location\n+\n+        if self.current_metadata_location is not None and len(self.current_metadata_location) > 0:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8aff14ff2ecab4a94d721b4ffe70885b90fec329"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTIxMzI3MA==", "bodyText": "correct, fixed", "url": "https://github.com/apache/iceberg/pull/1216#discussion_r475213270", "createdAt": "2020-08-23T12:26:08Z", "author": {"login": "rymurr"}, "path": "python/iceberg/hive/hive_table_operations.py", "diffHunk": "@@ -50,10 +63,146 @@ def refresh(self):\n         return self.current()\n \n     def commit(self, base, metadata):\n-        raise NotImplementedError()\n+        new_metadata_location = self.write_new_metadata(metadata, self.version + 1)\n+\n+        threw = True\n+        lock_id = None\n+        try:\n+            lock_id = self.acquire_lock()\n+            if base is not None:\n+                with self._client as open_client:\n+                    tbl = open_client.get_table(self.database, self.table)\n+            else:\n+                current_time_millis = int(time.time())\n+                tbl = Table(self.table,\n+                            self.database,\n+                            getpass.getuser(),\n+                            current_time_millis // 1000,\n+                            current_time_millis // 1000,\n+                            sd=storage_descriptor(metadata),\n+                            tableType=\"EXTERNAL_TABLE\",\n+                            parameters={'EXTERNAL': 'TRUE'})\n+\n+            tbl.sd = storage_descriptor(metadata)\n+            metadata_location = tbl.parameters.get(BaseMetastoreTableOperations.METADATA_LOCATION_PROP, None)\n+            base_metadata_location = base.metadataFileLocation() if base is not None else None\n+            if base_metadata_location != metadata_location:\n+                raise CommitFailedException(\n+                    \"Base metadata location '%s' is not same as the current table metadata location '%s' for %s.%s\",\n+                    base_metadata_location, metadata_location, self.database, self.table)\n+\n+            self.set_parameters(new_metadata_location, tbl)\n+\n+            if base is not None:\n+                with self._client as open_client:\n+                    env_context = EnvironmentContext(\n+                        {\"DO_NOT_UPDATE_STATS\": \"true\"}\n+                    )\n+                    open_client.alter_table(self.database, self.table, tbl, env_context)\n+\n+            else:\n+                with self._client as open_client:\n+                    open_client.create_table(tbl)\n+            threw = False\n+        except AlreadyExistsException:\n+            raise IcebergAlreadyExistsException(\"Table already exists: {}.{}\".format(self.database, self.table))\n+        except TException as e:\n+            if e is not None and \"Table/View 'HIVE_LOCKS' does not exist\" in str(e):\n+                raise Exception(\"\"\"Failed to acquire locks from metastore because 'HIVE_LOCKS' doesn't\n+                                exist, this probably happened when using embedded metastore or doesn't create a\n+                                transactional meta table. To fix this, use an alternative metastore\"\"\", e)\n+\n+            raise Exception(\"Metastore operation failed for {}.{}\".format(self.database, self.table), e)\n+        finally:\n+            if threw:\n+                self.io().delete(new_metadata_location)\n+            self.unlock(lock_id)\n+\n+    def set_parameters(self, new_metadata_location, tbl):\n+        parameters = tbl.parameters\n+\n+        if not parameters:\n+            parameters = dict()\n+\n+        parameters[BaseMetastoreTableOperations.TABLE_TYPE_PROP] = \\\n+            BaseMetastoreTableOperations.ICEBERG_TABLE_TYPE_VALUE.upper()\n+        parameters[BaseMetastoreTableOperations.METADATA_LOCATION_PROP] = new_metadata_location\n+\n+        if self.current_metadata_location is not None and len(self.current_metadata_location) > 0:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzM0MjE4Mw=="}, "originalCommit": {"oid": "8aff14ff2ecab4a94d721b4ffe70885b90fec329"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxOTIzMzQ5OnYy", "diffSide": "RIGHT", "path": "python/iceberg/hive/hive_table_operations.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOFQwMTowOToyMFrOG9sUcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yM1QxMjoyNzoyMVrOHFMuNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzM0MjQ0OQ==", "bodyText": "I think you can probably embed this method in unlock. I think the doUnlock method in Java is only there because of the use of Optional for a lock id.", "url": "https://github.com/apache/iceberg/pull/1216#discussion_r467342449", "createdAt": "2020-08-08T01:09:20Z", "author": {"login": "rdblue"}, "path": "python/iceberg/hive/hive_table_operations.py", "diffHunk": "@@ -50,10 +63,146 @@ def refresh(self):\n         return self.current()\n \n     def commit(self, base, metadata):\n-        raise NotImplementedError()\n+        new_metadata_location = self.write_new_metadata(metadata, self.version + 1)\n+\n+        threw = True\n+        lock_id = None\n+        try:\n+            lock_id = self.acquire_lock()\n+            if base is not None:\n+                with self._client as open_client:\n+                    tbl = open_client.get_table(self.database, self.table)\n+            else:\n+                current_time_millis = int(time.time())\n+                tbl = Table(self.table,\n+                            self.database,\n+                            getpass.getuser(),\n+                            current_time_millis // 1000,\n+                            current_time_millis // 1000,\n+                            sd=storage_descriptor(metadata),\n+                            tableType=\"EXTERNAL_TABLE\",\n+                            parameters={'EXTERNAL': 'TRUE'})\n+\n+            tbl.sd = storage_descriptor(metadata)\n+            metadata_location = tbl.parameters.get(BaseMetastoreTableOperations.METADATA_LOCATION_PROP, None)\n+            base_metadata_location = base.metadataFileLocation() if base is not None else None\n+            if base_metadata_location != metadata_location:\n+                raise CommitFailedException(\n+                    \"Base metadata location '%s' is not same as the current table metadata location '%s' for %s.%s\",\n+                    base_metadata_location, metadata_location, self.database, self.table)\n+\n+            self.set_parameters(new_metadata_location, tbl)\n+\n+            if base is not None:\n+                with self._client as open_client:\n+                    env_context = EnvironmentContext(\n+                        {\"DO_NOT_UPDATE_STATS\": \"true\"}\n+                    )\n+                    open_client.alter_table(self.database, self.table, tbl, env_context)\n+\n+            else:\n+                with self._client as open_client:\n+                    open_client.create_table(tbl)\n+            threw = False\n+        except AlreadyExistsException:\n+            raise IcebergAlreadyExistsException(\"Table already exists: {}.{}\".format(self.database, self.table))\n+        except TException as e:\n+            if e is not None and \"Table/View 'HIVE_LOCKS' does not exist\" in str(e):\n+                raise Exception(\"\"\"Failed to acquire locks from metastore because 'HIVE_LOCKS' doesn't\n+                                exist, this probably happened when using embedded metastore or doesn't create a\n+                                transactional meta table. To fix this, use an alternative metastore\"\"\", e)\n+\n+            raise Exception(\"Metastore operation failed for {}.{}\".format(self.database, self.table), e)\n+        finally:\n+            if threw:\n+                self.io().delete(new_metadata_location)\n+            self.unlock(lock_id)\n+\n+    def set_parameters(self, new_metadata_location, tbl):\n+        parameters = tbl.parameters\n+\n+        if not parameters:\n+            parameters = dict()\n+\n+        parameters[BaseMetastoreTableOperations.TABLE_TYPE_PROP] = \\\n+            BaseMetastoreTableOperations.ICEBERG_TABLE_TYPE_VALUE.upper()\n+        parameters[BaseMetastoreTableOperations.METADATA_LOCATION_PROP] = new_metadata_location\n+\n+        if self.current_metadata_location is not None and len(self.current_metadata_location) > 0:\n+            parameters[BaseMetastoreTableOperations.PREVIOUS_METADATA_LOCATION_PROP] = self.current_metadata_location\n+\n+        tbl.parameters = parameters\n+\n+    def unlock(self, lock_id):\n+        if lock_id:\n+            try:\n+                self.do_unlock(LockResponse(lock_id))\n+            except Exception as e:\n+                logging.warning(\"Failed to unlock {}.{}\".format(self.database, self.table), e)\n+\n+    def do_unlock(self, lock_id):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8aff14ff2ecab4a94d721b4ffe70885b90fec329"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTIxMzM2NQ==", "bodyText": "yup, fixed", "url": "https://github.com/apache/iceberg/pull/1216#discussion_r475213365", "createdAt": "2020-08-23T12:27:21Z", "author": {"login": "rymurr"}, "path": "python/iceberg/hive/hive_table_operations.py", "diffHunk": "@@ -50,10 +63,146 @@ def refresh(self):\n         return self.current()\n \n     def commit(self, base, metadata):\n-        raise NotImplementedError()\n+        new_metadata_location = self.write_new_metadata(metadata, self.version + 1)\n+\n+        threw = True\n+        lock_id = None\n+        try:\n+            lock_id = self.acquire_lock()\n+            if base is not None:\n+                with self._client as open_client:\n+                    tbl = open_client.get_table(self.database, self.table)\n+            else:\n+                current_time_millis = int(time.time())\n+                tbl = Table(self.table,\n+                            self.database,\n+                            getpass.getuser(),\n+                            current_time_millis // 1000,\n+                            current_time_millis // 1000,\n+                            sd=storage_descriptor(metadata),\n+                            tableType=\"EXTERNAL_TABLE\",\n+                            parameters={'EXTERNAL': 'TRUE'})\n+\n+            tbl.sd = storage_descriptor(metadata)\n+            metadata_location = tbl.parameters.get(BaseMetastoreTableOperations.METADATA_LOCATION_PROP, None)\n+            base_metadata_location = base.metadataFileLocation() if base is not None else None\n+            if base_metadata_location != metadata_location:\n+                raise CommitFailedException(\n+                    \"Base metadata location '%s' is not same as the current table metadata location '%s' for %s.%s\",\n+                    base_metadata_location, metadata_location, self.database, self.table)\n+\n+            self.set_parameters(new_metadata_location, tbl)\n+\n+            if base is not None:\n+                with self._client as open_client:\n+                    env_context = EnvironmentContext(\n+                        {\"DO_NOT_UPDATE_STATS\": \"true\"}\n+                    )\n+                    open_client.alter_table(self.database, self.table, tbl, env_context)\n+\n+            else:\n+                with self._client as open_client:\n+                    open_client.create_table(tbl)\n+            threw = False\n+        except AlreadyExistsException:\n+            raise IcebergAlreadyExistsException(\"Table already exists: {}.{}\".format(self.database, self.table))\n+        except TException as e:\n+            if e is not None and \"Table/View 'HIVE_LOCKS' does not exist\" in str(e):\n+                raise Exception(\"\"\"Failed to acquire locks from metastore because 'HIVE_LOCKS' doesn't\n+                                exist, this probably happened when using embedded metastore or doesn't create a\n+                                transactional meta table. To fix this, use an alternative metastore\"\"\", e)\n+\n+            raise Exception(\"Metastore operation failed for {}.{}\".format(self.database, self.table), e)\n+        finally:\n+            if threw:\n+                self.io().delete(new_metadata_location)\n+            self.unlock(lock_id)\n+\n+    def set_parameters(self, new_metadata_location, tbl):\n+        parameters = tbl.parameters\n+\n+        if not parameters:\n+            parameters = dict()\n+\n+        parameters[BaseMetastoreTableOperations.TABLE_TYPE_PROP] = \\\n+            BaseMetastoreTableOperations.ICEBERG_TABLE_TYPE_VALUE.upper()\n+        parameters[BaseMetastoreTableOperations.METADATA_LOCATION_PROP] = new_metadata_location\n+\n+        if self.current_metadata_location is not None and len(self.current_metadata_location) > 0:\n+            parameters[BaseMetastoreTableOperations.PREVIOUS_METADATA_LOCATION_PROP] = self.current_metadata_location\n+\n+        tbl.parameters = parameters\n+\n+    def unlock(self, lock_id):\n+        if lock_id:\n+            try:\n+                self.do_unlock(LockResponse(lock_id))\n+            except Exception as e:\n+                logging.warning(\"Failed to unlock {}.{}\".format(self.database, self.table), e)\n+\n+    def do_unlock(self, lock_id):", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzM0MjQ0OQ=="}, "originalCommit": {"oid": "8aff14ff2ecab4a94d721b4ffe70885b90fec329"}, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxOTIzNjQwOnYy", "diffSide": "RIGHT", "path": "python/iceberg/hive/hive_table_operations.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOFQwMToxMTo0N1rOG9sV1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yM1QxMjoyNzoyOVrOHFMuPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzM0MjgwNA==", "bodyText": "Nit: I think timedOut would be a better name?", "url": "https://github.com/apache/iceberg/pull/1216#discussion_r467342804", "createdAt": "2020-08-08T01:11:47Z", "author": {"login": "rdblue"}, "path": "python/iceberg/hive/hive_table_operations.py", "diffHunk": "@@ -50,10 +63,146 @@ def refresh(self):\n         return self.current()\n \n     def commit(self, base, metadata):\n-        raise NotImplementedError()\n+        new_metadata_location = self.write_new_metadata(metadata, self.version + 1)\n+\n+        threw = True\n+        lock_id = None\n+        try:\n+            lock_id = self.acquire_lock()\n+            if base is not None:\n+                with self._client as open_client:\n+                    tbl = open_client.get_table(self.database, self.table)\n+            else:\n+                current_time_millis = int(time.time())\n+                tbl = Table(self.table,\n+                            self.database,\n+                            getpass.getuser(),\n+                            current_time_millis // 1000,\n+                            current_time_millis // 1000,\n+                            sd=storage_descriptor(metadata),\n+                            tableType=\"EXTERNAL_TABLE\",\n+                            parameters={'EXTERNAL': 'TRUE'})\n+\n+            tbl.sd = storage_descriptor(metadata)\n+            metadata_location = tbl.parameters.get(BaseMetastoreTableOperations.METADATA_LOCATION_PROP, None)\n+            base_metadata_location = base.metadataFileLocation() if base is not None else None\n+            if base_metadata_location != metadata_location:\n+                raise CommitFailedException(\n+                    \"Base metadata location '%s' is not same as the current table metadata location '%s' for %s.%s\",\n+                    base_metadata_location, metadata_location, self.database, self.table)\n+\n+            self.set_parameters(new_metadata_location, tbl)\n+\n+            if base is not None:\n+                with self._client as open_client:\n+                    env_context = EnvironmentContext(\n+                        {\"DO_NOT_UPDATE_STATS\": \"true\"}\n+                    )\n+                    open_client.alter_table(self.database, self.table, tbl, env_context)\n+\n+            else:\n+                with self._client as open_client:\n+                    open_client.create_table(tbl)\n+            threw = False\n+        except AlreadyExistsException:\n+            raise IcebergAlreadyExistsException(\"Table already exists: {}.{}\".format(self.database, self.table))\n+        except TException as e:\n+            if e is not None and \"Table/View 'HIVE_LOCKS' does not exist\" in str(e):\n+                raise Exception(\"\"\"Failed to acquire locks from metastore because 'HIVE_LOCKS' doesn't\n+                                exist, this probably happened when using embedded metastore or doesn't create a\n+                                transactional meta table. To fix this, use an alternative metastore\"\"\", e)\n+\n+            raise Exception(\"Metastore operation failed for {}.{}\".format(self.database, self.table), e)\n+        finally:\n+            if threw:\n+                self.io().delete(new_metadata_location)\n+            self.unlock(lock_id)\n+\n+    def set_parameters(self, new_metadata_location, tbl):\n+        parameters = tbl.parameters\n+\n+        if not parameters:\n+            parameters = dict()\n+\n+        parameters[BaseMetastoreTableOperations.TABLE_TYPE_PROP] = \\\n+            BaseMetastoreTableOperations.ICEBERG_TABLE_TYPE_VALUE.upper()\n+        parameters[BaseMetastoreTableOperations.METADATA_LOCATION_PROP] = new_metadata_location\n+\n+        if self.current_metadata_location is not None and len(self.current_metadata_location) > 0:\n+            parameters[BaseMetastoreTableOperations.PREVIOUS_METADATA_LOCATION_PROP] = self.current_metadata_location\n+\n+        tbl.parameters = parameters\n+\n+    def unlock(self, lock_id):\n+        if lock_id:\n+            try:\n+                self.do_unlock(LockResponse(lock_id))\n+            except Exception as e:\n+                logging.warning(\"Failed to unlock {}.{}\".format(self.database, self.table), e)\n+\n+    def do_unlock(self, lock_id):\n+        with self._client as open_client:\n+            open_client.unlock(lock_id)\n+\n+    def acquire_lock(self):\n+        lock_component = LockComponent(LockType.EXCLUSIVE, LockLevel.TABLE, self.database, self.table)\n+\n+        lock_request = LockRequest([lock_component], user=getpass.getuser(), hostname=socket.gethostname())\n+        with self._client as open_client:\n+            lock_response = open_client.lock(lock_request)\n+\n+        state = lock_response.state\n+        lock_id = lock_response.lockid\n+        start = int(time.time())\n+        duration = 0\n+        timeout = False", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8aff14ff2ecab4a94d721b4ffe70885b90fec329"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTIxMzM3NQ==", "bodyText": "agreed, fixed", "url": "https://github.com/apache/iceberg/pull/1216#discussion_r475213375", "createdAt": "2020-08-23T12:27:29Z", "author": {"login": "rymurr"}, "path": "python/iceberg/hive/hive_table_operations.py", "diffHunk": "@@ -50,10 +63,146 @@ def refresh(self):\n         return self.current()\n \n     def commit(self, base, metadata):\n-        raise NotImplementedError()\n+        new_metadata_location = self.write_new_metadata(metadata, self.version + 1)\n+\n+        threw = True\n+        lock_id = None\n+        try:\n+            lock_id = self.acquire_lock()\n+            if base is not None:\n+                with self._client as open_client:\n+                    tbl = open_client.get_table(self.database, self.table)\n+            else:\n+                current_time_millis = int(time.time())\n+                tbl = Table(self.table,\n+                            self.database,\n+                            getpass.getuser(),\n+                            current_time_millis // 1000,\n+                            current_time_millis // 1000,\n+                            sd=storage_descriptor(metadata),\n+                            tableType=\"EXTERNAL_TABLE\",\n+                            parameters={'EXTERNAL': 'TRUE'})\n+\n+            tbl.sd = storage_descriptor(metadata)\n+            metadata_location = tbl.parameters.get(BaseMetastoreTableOperations.METADATA_LOCATION_PROP, None)\n+            base_metadata_location = base.metadataFileLocation() if base is not None else None\n+            if base_metadata_location != metadata_location:\n+                raise CommitFailedException(\n+                    \"Base metadata location '%s' is not same as the current table metadata location '%s' for %s.%s\",\n+                    base_metadata_location, metadata_location, self.database, self.table)\n+\n+            self.set_parameters(new_metadata_location, tbl)\n+\n+            if base is not None:\n+                with self._client as open_client:\n+                    env_context = EnvironmentContext(\n+                        {\"DO_NOT_UPDATE_STATS\": \"true\"}\n+                    )\n+                    open_client.alter_table(self.database, self.table, tbl, env_context)\n+\n+            else:\n+                with self._client as open_client:\n+                    open_client.create_table(tbl)\n+            threw = False\n+        except AlreadyExistsException:\n+            raise IcebergAlreadyExistsException(\"Table already exists: {}.{}\".format(self.database, self.table))\n+        except TException as e:\n+            if e is not None and \"Table/View 'HIVE_LOCKS' does not exist\" in str(e):\n+                raise Exception(\"\"\"Failed to acquire locks from metastore because 'HIVE_LOCKS' doesn't\n+                                exist, this probably happened when using embedded metastore or doesn't create a\n+                                transactional meta table. To fix this, use an alternative metastore\"\"\", e)\n+\n+            raise Exception(\"Metastore operation failed for {}.{}\".format(self.database, self.table), e)\n+        finally:\n+            if threw:\n+                self.io().delete(new_metadata_location)\n+            self.unlock(lock_id)\n+\n+    def set_parameters(self, new_metadata_location, tbl):\n+        parameters = tbl.parameters\n+\n+        if not parameters:\n+            parameters = dict()\n+\n+        parameters[BaseMetastoreTableOperations.TABLE_TYPE_PROP] = \\\n+            BaseMetastoreTableOperations.ICEBERG_TABLE_TYPE_VALUE.upper()\n+        parameters[BaseMetastoreTableOperations.METADATA_LOCATION_PROP] = new_metadata_location\n+\n+        if self.current_metadata_location is not None and len(self.current_metadata_location) > 0:\n+            parameters[BaseMetastoreTableOperations.PREVIOUS_METADATA_LOCATION_PROP] = self.current_metadata_location\n+\n+        tbl.parameters = parameters\n+\n+    def unlock(self, lock_id):\n+        if lock_id:\n+            try:\n+                self.do_unlock(LockResponse(lock_id))\n+            except Exception as e:\n+                logging.warning(\"Failed to unlock {}.{}\".format(self.database, self.table), e)\n+\n+    def do_unlock(self, lock_id):\n+        with self._client as open_client:\n+            open_client.unlock(lock_id)\n+\n+    def acquire_lock(self):\n+        lock_component = LockComponent(LockType.EXCLUSIVE, LockLevel.TABLE, self.database, self.table)\n+\n+        lock_request = LockRequest([lock_component], user=getpass.getuser(), hostname=socket.gethostname())\n+        with self._client as open_client:\n+            lock_response = open_client.lock(lock_request)\n+\n+        state = lock_response.state\n+        lock_id = lock_response.lockid\n+        start = int(time.time())\n+        duration = 0\n+        timeout = False", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzM0MjgwNA=="}, "originalCommit": {"oid": "8aff14ff2ecab4a94d721b4ffe70885b90fec329"}, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxOTI0NTY2OnYy", "diffSide": "RIGHT", "path": "python/iceberg/hive/hive_table_operations.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOFQwMToyMTo0M1rOG9saXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yM1QxMjoyODoxNlrOHFMumA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzM0Mzk2Nw==", "bodyText": "Since this is identical to the fall through case, can this be pass instead?", "url": "https://github.com/apache/iceberg/pull/1216#discussion_r467343967", "createdAt": "2020-08-08T01:21:43Z", "author": {"login": "rdblue"}, "path": "python/iceberg/hive/hive_table_operations.py", "diffHunk": "@@ -50,10 +63,146 @@ def refresh(self):\n         return self.current()\n \n     def commit(self, base, metadata):\n-        raise NotImplementedError()\n+        new_metadata_location = self.write_new_metadata(metadata, self.version + 1)\n+\n+        threw = True\n+        lock_id = None\n+        try:\n+            lock_id = self.acquire_lock()\n+            if base is not None:\n+                with self._client as open_client:\n+                    tbl = open_client.get_table(self.database, self.table)\n+            else:\n+                current_time_millis = int(time.time())\n+                tbl = Table(self.table,\n+                            self.database,\n+                            getpass.getuser(),\n+                            current_time_millis // 1000,\n+                            current_time_millis // 1000,\n+                            sd=storage_descriptor(metadata),\n+                            tableType=\"EXTERNAL_TABLE\",\n+                            parameters={'EXTERNAL': 'TRUE'})\n+\n+            tbl.sd = storage_descriptor(metadata)\n+            metadata_location = tbl.parameters.get(BaseMetastoreTableOperations.METADATA_LOCATION_PROP, None)\n+            base_metadata_location = base.metadataFileLocation() if base is not None else None\n+            if base_metadata_location != metadata_location:\n+                raise CommitFailedException(\n+                    \"Base metadata location '%s' is not same as the current table metadata location '%s' for %s.%s\",\n+                    base_metadata_location, metadata_location, self.database, self.table)\n+\n+            self.set_parameters(new_metadata_location, tbl)\n+\n+            if base is not None:\n+                with self._client as open_client:\n+                    env_context = EnvironmentContext(\n+                        {\"DO_NOT_UPDATE_STATS\": \"true\"}\n+                    )\n+                    open_client.alter_table(self.database, self.table, tbl, env_context)\n+\n+            else:\n+                with self._client as open_client:\n+                    open_client.create_table(tbl)\n+            threw = False\n+        except AlreadyExistsException:\n+            raise IcebergAlreadyExistsException(\"Table already exists: {}.{}\".format(self.database, self.table))\n+        except TException as e:\n+            if e is not None and \"Table/View 'HIVE_LOCKS' does not exist\" in str(e):\n+                raise Exception(\"\"\"Failed to acquire locks from metastore because 'HIVE_LOCKS' doesn't\n+                                exist, this probably happened when using embedded metastore or doesn't create a\n+                                transactional meta table. To fix this, use an alternative metastore\"\"\", e)\n+\n+            raise Exception(\"Metastore operation failed for {}.{}\".format(self.database, self.table), e)\n+        finally:\n+            if threw:\n+                self.io().delete(new_metadata_location)\n+            self.unlock(lock_id)\n+\n+    def set_parameters(self, new_metadata_location, tbl):\n+        parameters = tbl.parameters\n+\n+        if not parameters:\n+            parameters = dict()\n+\n+        parameters[BaseMetastoreTableOperations.TABLE_TYPE_PROP] = \\\n+            BaseMetastoreTableOperations.ICEBERG_TABLE_TYPE_VALUE.upper()\n+        parameters[BaseMetastoreTableOperations.METADATA_LOCATION_PROP] = new_metadata_location\n+\n+        if self.current_metadata_location is not None and len(self.current_metadata_location) > 0:\n+            parameters[BaseMetastoreTableOperations.PREVIOUS_METADATA_LOCATION_PROP] = self.current_metadata_location\n+\n+        tbl.parameters = parameters\n+\n+    def unlock(self, lock_id):\n+        if lock_id:\n+            try:\n+                self.do_unlock(LockResponse(lock_id))\n+            except Exception as e:\n+                logging.warning(\"Failed to unlock {}.{}\".format(self.database, self.table), e)\n+\n+    def do_unlock(self, lock_id):\n+        with self._client as open_client:\n+            open_client.unlock(lock_id)\n+\n+    def acquire_lock(self):\n+        lock_component = LockComponent(LockType.EXCLUSIVE, LockLevel.TABLE, self.database, self.table)\n+\n+        lock_request = LockRequest([lock_component], user=getpass.getuser(), hostname=socket.gethostname())\n+        with self._client as open_client:\n+            lock_response = open_client.lock(lock_request)\n+\n+        state = lock_response.state\n+        lock_id = lock_response.lockid\n+        start = int(time.time())\n+        duration = 0\n+        timeout = False\n+        while not timeout and state == LockState.WAITING:\n+            with self._client as open_client:\n+                lock_response = open_client.check_lock(lock_response)\n+            state = lock_response.state\n+\n+            duration = int(time.time()) - start\n+            if duration > 3 * 60 * 1000:\n+                timeout = True\n+            else:\n+                time.sleep(0.05)\n+\n+        if timeout and state != LockState.ACQUIRED:\n+            raise CommitFailedException(\"Timed out after {} ms waiting for lock on {}.{}\".format(duration,\n+                                                                                                 self.database,\n+                                                                                                 self.table))\n+\n+        if state != LockState.ACQUIRED:\n+            raise CommitFailedException(\n+                \"Could not acquire the lock on {}.{}, lock request ended in state {}\".format(self.database, self.table,\n+                                                                                             state))\n+        return lock_id\n \n     def io(self):\n-        raise NotImplementedError()\n+        return get_fs(self.base_location, self.conf)\n \n     def close(self):\n         self._client.close()\n+\n+\n+def storage_descriptor(metadata):\n+    ser_de_info = SerDeInfo(serializationLib=\"org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\")\n+    return StorageDescriptor(columns(metadata.schema),\n+                             metadata.location,\n+                             \"org.apache.hadoop.mapred.FileInputFormat\",\n+                             \"org.apache.hadoop.mapred.FileOutputFormat\",\n+                             serdeInfo=ser_de_info)\n+\n+\n+def columns(schema):\n+    return [FieldSchema(col.name, convert_hive_type(col.type), \"\") for col in schema.columns()]\n+\n+\n+def convert_hive_type(col_type):\n+    try:\n+        type_id = col_type.type_id.value['hive_name']\n+        if type_id is not None:\n+            return type_id\n+    except:  # NOQA\n+        raise NotImplementedError(\"Not yet implemented column type \" + col_type)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8aff14ff2ecab4a94d721b4ffe70885b90fec329"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTIxMzQ2NA==", "bodyText": "agreed", "url": "https://github.com/apache/iceberg/pull/1216#discussion_r475213464", "createdAt": "2020-08-23T12:28:16Z", "author": {"login": "rymurr"}, "path": "python/iceberg/hive/hive_table_operations.py", "diffHunk": "@@ -50,10 +63,146 @@ def refresh(self):\n         return self.current()\n \n     def commit(self, base, metadata):\n-        raise NotImplementedError()\n+        new_metadata_location = self.write_new_metadata(metadata, self.version + 1)\n+\n+        threw = True\n+        lock_id = None\n+        try:\n+            lock_id = self.acquire_lock()\n+            if base is not None:\n+                with self._client as open_client:\n+                    tbl = open_client.get_table(self.database, self.table)\n+            else:\n+                current_time_millis = int(time.time())\n+                tbl = Table(self.table,\n+                            self.database,\n+                            getpass.getuser(),\n+                            current_time_millis // 1000,\n+                            current_time_millis // 1000,\n+                            sd=storage_descriptor(metadata),\n+                            tableType=\"EXTERNAL_TABLE\",\n+                            parameters={'EXTERNAL': 'TRUE'})\n+\n+            tbl.sd = storage_descriptor(metadata)\n+            metadata_location = tbl.parameters.get(BaseMetastoreTableOperations.METADATA_LOCATION_PROP, None)\n+            base_metadata_location = base.metadataFileLocation() if base is not None else None\n+            if base_metadata_location != metadata_location:\n+                raise CommitFailedException(\n+                    \"Base metadata location '%s' is not same as the current table metadata location '%s' for %s.%s\",\n+                    base_metadata_location, metadata_location, self.database, self.table)\n+\n+            self.set_parameters(new_metadata_location, tbl)\n+\n+            if base is not None:\n+                with self._client as open_client:\n+                    env_context = EnvironmentContext(\n+                        {\"DO_NOT_UPDATE_STATS\": \"true\"}\n+                    )\n+                    open_client.alter_table(self.database, self.table, tbl, env_context)\n+\n+            else:\n+                with self._client as open_client:\n+                    open_client.create_table(tbl)\n+            threw = False\n+        except AlreadyExistsException:\n+            raise IcebergAlreadyExistsException(\"Table already exists: {}.{}\".format(self.database, self.table))\n+        except TException as e:\n+            if e is not None and \"Table/View 'HIVE_LOCKS' does not exist\" in str(e):\n+                raise Exception(\"\"\"Failed to acquire locks from metastore because 'HIVE_LOCKS' doesn't\n+                                exist, this probably happened when using embedded metastore or doesn't create a\n+                                transactional meta table. To fix this, use an alternative metastore\"\"\", e)\n+\n+            raise Exception(\"Metastore operation failed for {}.{}\".format(self.database, self.table), e)\n+        finally:\n+            if threw:\n+                self.io().delete(new_metadata_location)\n+            self.unlock(lock_id)\n+\n+    def set_parameters(self, new_metadata_location, tbl):\n+        parameters = tbl.parameters\n+\n+        if not parameters:\n+            parameters = dict()\n+\n+        parameters[BaseMetastoreTableOperations.TABLE_TYPE_PROP] = \\\n+            BaseMetastoreTableOperations.ICEBERG_TABLE_TYPE_VALUE.upper()\n+        parameters[BaseMetastoreTableOperations.METADATA_LOCATION_PROP] = new_metadata_location\n+\n+        if self.current_metadata_location is not None and len(self.current_metadata_location) > 0:\n+            parameters[BaseMetastoreTableOperations.PREVIOUS_METADATA_LOCATION_PROP] = self.current_metadata_location\n+\n+        tbl.parameters = parameters\n+\n+    def unlock(self, lock_id):\n+        if lock_id:\n+            try:\n+                self.do_unlock(LockResponse(lock_id))\n+            except Exception as e:\n+                logging.warning(\"Failed to unlock {}.{}\".format(self.database, self.table), e)\n+\n+    def do_unlock(self, lock_id):\n+        with self._client as open_client:\n+            open_client.unlock(lock_id)\n+\n+    def acquire_lock(self):\n+        lock_component = LockComponent(LockType.EXCLUSIVE, LockLevel.TABLE, self.database, self.table)\n+\n+        lock_request = LockRequest([lock_component], user=getpass.getuser(), hostname=socket.gethostname())\n+        with self._client as open_client:\n+            lock_response = open_client.lock(lock_request)\n+\n+        state = lock_response.state\n+        lock_id = lock_response.lockid\n+        start = int(time.time())\n+        duration = 0\n+        timeout = False\n+        while not timeout and state == LockState.WAITING:\n+            with self._client as open_client:\n+                lock_response = open_client.check_lock(lock_response)\n+            state = lock_response.state\n+\n+            duration = int(time.time()) - start\n+            if duration > 3 * 60 * 1000:\n+                timeout = True\n+            else:\n+                time.sleep(0.05)\n+\n+        if timeout and state != LockState.ACQUIRED:\n+            raise CommitFailedException(\"Timed out after {} ms waiting for lock on {}.{}\".format(duration,\n+                                                                                                 self.database,\n+                                                                                                 self.table))\n+\n+        if state != LockState.ACQUIRED:\n+            raise CommitFailedException(\n+                \"Could not acquire the lock on {}.{}, lock request ended in state {}\".format(self.database, self.table,\n+                                                                                             state))\n+        return lock_id\n \n     def io(self):\n-        raise NotImplementedError()\n+        return get_fs(self.base_location, self.conf)\n \n     def close(self):\n         self._client.close()\n+\n+\n+def storage_descriptor(metadata):\n+    ser_de_info = SerDeInfo(serializationLib=\"org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\")\n+    return StorageDescriptor(columns(metadata.schema),\n+                             metadata.location,\n+                             \"org.apache.hadoop.mapred.FileInputFormat\",\n+                             \"org.apache.hadoop.mapred.FileOutputFormat\",\n+                             serdeInfo=ser_de_info)\n+\n+\n+def columns(schema):\n+    return [FieldSchema(col.name, convert_hive_type(col.type), \"\") for col in schema.columns()]\n+\n+\n+def convert_hive_type(col_type):\n+    try:\n+        type_id = col_type.type_id.value['hive_name']\n+        if type_id is not None:\n+            return type_id\n+    except:  # NOQA\n+        raise NotImplementedError(\"Not yet implemented column type \" + col_type)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzM0Mzk2Nw=="}, "originalCommit": {"oid": "8aff14ff2ecab4a94d721b4ffe70885b90fec329"}, "originalPosition": 180}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3NDM4NDMyOnYy", "diffSide": "RIGHT", "path": "python/iceberg/core/base_metastore_tables.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNjo1NToxN1rOHFt9Yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNzozMTowOVrOHFvWew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc1NzkyMw==", "bodyText": "I'm not sure I understand this comment. Will a mock object evaluate to False in an if?", "url": "https://github.com/apache/iceberg/pull/1216#discussion_r475757923", "createdAt": "2020-08-24T16:55:17Z", "author": {"login": "rdblue"}, "path": "python/iceberg/core/base_metastore_tables.py", "diffHunk": "@@ -14,46 +14,40 @@\n # KIND, either express or implied.  See the License for the\n # specific language governing permissions and limitations\n # under the License.\n+from typing import Tuple\n \n-from iceberg.api import Tables\n-from iceberg.exceptions import AlreadyExistsException, CommitFailedException, NoSuchTableException\n-\n+from . import TableOperations\n from .base_table import BaseTable\n from .table_metadata import TableMetadata\n+from ..api import PartitionSpec, Schema, Table, Tables\n+from ..exceptions import AlreadyExistsException, CommitFailedException, NoSuchTableException\n \n \n class BaseMetastoreTables(Tables):\n-    DOT = '.'\n \n-    def __init__(self, conf):\n+    def __init__(self: \"BaseMetastoreTables\", conf: dict) -> None:\n         self.conf = conf\n \n-    def new_table_ops(self, conf, database, table):\n+    def new_table_ops(self: \"BaseMetastoreTables\", conf: dict, database: str, table: str) -> \"TableOperations\":\n         raise RuntimeError(\"Abstract Implementation\")\n \n-    def load(self, table_identifier):\n-        parts = table_identifier.rsplit(BaseMetastoreTables.DOT, 1)\n-        if len(parts) > 1:\n-            database = parts[0]\n-            table = parts[1]\n-        else:\n-            database = \"default\"\n-            table = parts[0]\n+    def load(self: \"BaseMetastoreTables\", table_identifier: str) -> Table:\n+        database, table = _parse_table_identifier(table_identifier)\n         ops = self.new_table_ops(self.conf, database, table)\n-        if ops.current() is None:\n-            raise NoSuchTableException(\"Table does not exist: {}.{}\".format(database, table))\n-\n-        return BaseTable(ops, \"{}.{}\".format(database, table))\n+        if ops.current():\n+            return BaseTable(ops, \"{}.{}\".format(database, table))\n+        raise NoSuchTableException(\"Table does not exist: {}.{}\".format(database, table))\n \n-    def create(self, schema, table_identifier=None, spec=None, properties=None):\n-        database, table = table_identifier.rsplit(BaseMetastoreTables.DOT, 1)\n+    def create(self: \"BaseMetastoreTables\", schema: Schema, table_identifier: str, spec: PartitionSpec = None,\n+               properties: dict = None) -> Table:\n+        database, table = _parse_table_identifier(table_identifier)\n         ops = self.new_table_ops(self.conf, database, table)\n-        if ops.current() is not None:\n+        if ops.current() is not None:  # not None check here to ensure MagicMocks aren't treated as None", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "616187d6de0a8c4485b4cf31d19932ac80278200"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc4MDczMQ==", "bodyText": "just wasn't mocked correctly, fixed now and removed the is not None check", "url": "https://github.com/apache/iceberg/pull/1216#discussion_r475780731", "createdAt": "2020-08-24T17:31:09Z", "author": {"login": "rymurr"}, "path": "python/iceberg/core/base_metastore_tables.py", "diffHunk": "@@ -14,46 +14,40 @@\n # KIND, either express or implied.  See the License for the\n # specific language governing permissions and limitations\n # under the License.\n+from typing import Tuple\n \n-from iceberg.api import Tables\n-from iceberg.exceptions import AlreadyExistsException, CommitFailedException, NoSuchTableException\n-\n+from . import TableOperations\n from .base_table import BaseTable\n from .table_metadata import TableMetadata\n+from ..api import PartitionSpec, Schema, Table, Tables\n+from ..exceptions import AlreadyExistsException, CommitFailedException, NoSuchTableException\n \n \n class BaseMetastoreTables(Tables):\n-    DOT = '.'\n \n-    def __init__(self, conf):\n+    def __init__(self: \"BaseMetastoreTables\", conf: dict) -> None:\n         self.conf = conf\n \n-    def new_table_ops(self, conf, database, table):\n+    def new_table_ops(self: \"BaseMetastoreTables\", conf: dict, database: str, table: str) -> \"TableOperations\":\n         raise RuntimeError(\"Abstract Implementation\")\n \n-    def load(self, table_identifier):\n-        parts = table_identifier.rsplit(BaseMetastoreTables.DOT, 1)\n-        if len(parts) > 1:\n-            database = parts[0]\n-            table = parts[1]\n-        else:\n-            database = \"default\"\n-            table = parts[0]\n+    def load(self: \"BaseMetastoreTables\", table_identifier: str) -> Table:\n+        database, table = _parse_table_identifier(table_identifier)\n         ops = self.new_table_ops(self.conf, database, table)\n-        if ops.current() is None:\n-            raise NoSuchTableException(\"Table does not exist: {}.{}\".format(database, table))\n-\n-        return BaseTable(ops, \"{}.{}\".format(database, table))\n+        if ops.current():\n+            return BaseTable(ops, \"{}.{}\".format(database, table))\n+        raise NoSuchTableException(\"Table does not exist: {}.{}\".format(database, table))\n \n-    def create(self, schema, table_identifier=None, spec=None, properties=None):\n-        database, table = table_identifier.rsplit(BaseMetastoreTables.DOT, 1)\n+    def create(self: \"BaseMetastoreTables\", schema: Schema, table_identifier: str, spec: PartitionSpec = None,\n+               properties: dict = None) -> Table:\n+        database, table = _parse_table_identifier(table_identifier)\n         ops = self.new_table_ops(self.conf, database, table)\n-        if ops.current() is not None:\n+        if ops.current() is not None:  # not None check here to ensure MagicMocks aren't treated as None", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc1NzkyMw=="}, "originalCommit": {"oid": "616187d6de0a8c4485b4cf31d19932ac80278200"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3NDM5NTcyOnYy", "diffSide": "RIGHT", "path": "python/iceberg/hive/hive_table_operations.py", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNjo1Nzo1OFrOHFuEOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQwODozMzo0MFrOHGNfxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc1OTY3NQ==", "bodyText": "I think this does need to be the metadata file location and not the table location.", "url": "https://github.com/apache/iceberg/pull/1216#discussion_r475759675", "createdAt": "2020-08-24T16:57:58Z", "author": {"login": "rdblue"}, "path": "python/iceberg/hive/hive_table_operations.py", "diffHunk": "@@ -85,20 +89,20 @@ def commit(self, base, metadata):\n \n             tbl.sd = storage_descriptor(metadata)\n             metadata_location = tbl.parameters.get(BaseMetastoreTableOperations.METADATA_LOCATION_PROP, None)\n-            base_metadata_location = base.metadataFileLocation() if base is not None else None\n+            base_metadata_location = base.location if base else None", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "616187d6de0a8c4485b4cf31d19932ac80278200"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc4MzMxNg==", "bodyText": "metadataFileLocation is the Java name, location is the Python name. Same value though.", "url": "https://github.com/apache/iceberg/pull/1216#discussion_r475783316", "createdAt": "2020-08-24T17:35:59Z", "author": {"login": "rymurr"}, "path": "python/iceberg/hive/hive_table_operations.py", "diffHunk": "@@ -85,20 +89,20 @@ def commit(self, base, metadata):\n \n             tbl.sd = storage_descriptor(metadata)\n             metadata_location = tbl.parameters.get(BaseMetastoreTableOperations.METADATA_LOCATION_PROP, None)\n-            base_metadata_location = base.metadataFileLocation() if base is not None else None\n+            base_metadata_location = base.location if base else None", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc1OTY3NQ=="}, "originalCommit": {"oid": "616187d6de0a8c4485b4cf31d19932ac80278200"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc4NjIxNw==", "bodyText": "That seems confusing to me. How do you get the table's base location in Python?", "url": "https://github.com/apache/iceberg/pull/1216#discussion_r475786217", "createdAt": "2020-08-24T17:41:33Z", "author": {"login": "rdblue"}, "path": "python/iceberg/hive/hive_table_operations.py", "diffHunk": "@@ -85,20 +89,20 @@ def commit(self, base, metadata):\n \n             tbl.sd = storage_descriptor(metadata)\n             metadata_location = tbl.parameters.get(BaseMetastoreTableOperations.METADATA_LOCATION_PROP, None)\n-            base_metadata_location = base.metadataFileLocation() if base is not None else None\n+            base_metadata_location = base.location if base else None", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc1OTY3NQ=="}, "originalCommit": {"oid": "616187d6de0a8c4485b4cf31d19932ac80278200"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc5ODIzOQ==", "bodyText": "ahh, i see now. It appears that the Java and Python impls are a bit out of sync. Python doesn't use file at all, which is where java takes its location from. Will look at figuring out what happened there and update the PR this eve or tomorrow", "url": "https://github.com/apache/iceberg/pull/1216#discussion_r475798239", "createdAt": "2020-08-24T18:03:07Z", "author": {"login": "rymurr"}, "path": "python/iceberg/hive/hive_table_operations.py", "diffHunk": "@@ -85,20 +89,20 @@ def commit(self, base, metadata):\n \n             tbl.sd = storage_descriptor(metadata)\n             metadata_location = tbl.parameters.get(BaseMetastoreTableOperations.METADATA_LOCATION_PROP, None)\n-            base_metadata_location = base.metadataFileLocation() if base is not None else None\n+            base_metadata_location = base.location if base else None", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc1OTY3NQ=="}, "originalCommit": {"oid": "616187d6de0a8c4485b4cf31d19932ac80278200"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjI3NDYyOQ==", "bodyText": "should be good to go now @rdblue, we had missed a property in TableMetadata in python", "url": "https://github.com/apache/iceberg/pull/1216#discussion_r476274629", "createdAt": "2020-08-25T08:33:40Z", "author": {"login": "rymurr"}, "path": "python/iceberg/hive/hive_table_operations.py", "diffHunk": "@@ -85,20 +89,20 @@ def commit(self, base, metadata):\n \n             tbl.sd = storage_descriptor(metadata)\n             metadata_location = tbl.parameters.get(BaseMetastoreTableOperations.METADATA_LOCATION_PROP, None)\n-            base_metadata_location = base.metadataFileLocation() if base is not None else None\n+            base_metadata_location = base.location if base else None", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc1OTY3NQ=="}, "originalCommit": {"oid": "616187d6de0a8c4485b4cf31d19932ac80278200"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3NDUzMTA4OnYy", "diffSide": "RIGHT", "path": "python/iceberg/api/types/type.py", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNzozMTozOFrOHFvXgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNjoyMDoyNVrOHGfyDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc4MDk5Mw==", "bodyText": "I don't really like the idea of exposing hive types through Iceberg types natively.  Seems like we should externalize this and have a separate hive<->iceberg type mapping utility class/function.", "url": "https://github.com/apache/iceberg/pull/1216#discussion_r475780993", "createdAt": "2020-08-24T17:31:38Z", "author": {"login": "danielcweeks"}, "path": "python/iceberg/api/types/type.py", "diffHunk": "@@ -22,22 +22,22 @@\n \n @unique\n class TypeID(Enum):\n-    BOOLEAN = {\"java_class\": \"Boolean.class\", \"python_class\": bool, \"id\": 1}\n-    INTEGER = {\"java_class\": \"Integer.class\", \"python_class\": int, \"id\": 2}\n-    LONG = {\"java_class\": \"Long.class\", \"python_class\": int, \"id\": 3}\n-    FLOAT = {\"java_class\": \"Float.class\", \"python_class\": float, \"id\": 4}\n-    DOUBLE = {\"java_class\": \"Double.class\", \"python_class\": float, \"id\": 5}\n-    DATE = {\"java_class\": \"Integer.class\", \"python_class\": int, \"id\": 6}\n-    TIME = {\"java_class\": \"Long.class\", \"python_class\": int, \"id\": 7}\n-    TIMESTAMP = {\"java_class\": \"Long.class\", \"python_class\": int, \"id\": 8}\n-    STRING = {\"java_class\": \"CharSequence.class\", \"python_class\": str, \"id\": 9}\n-    UUID = {\"java_class\": \"java.util.UUID.class\", \"python_class\": uuid.UUID, \"id\": 10}\n-    FIXED = {\"java_class\": \"ByteBuffer.class\", \"python_class\": bytes, \"id\": 11}\n-    BINARY = {\"java_class\": \"ByteBuffer.class\", \"python_class\": bytearray, \"id\": 12}\n-    DECIMAL = {\"java_class\": \"BigDecimal.class\", \"python_class\": Decimal, \"id\": 13}\n-    STRUCT = {\"java_class\": \"Void.class\", \"python_class\": None, \"id\": 14}\n-    LIST = {\"java_class\": \"Void.class\", \"python_class\": None, \"id\": 15}\n-    MAP = {\"java_class\": \"Void.class\", \"python_class\": None, \"id\": 16}\n+    BOOLEAN = {\"java_class\": \"Boolean.class\", \"python_class\": bool, \"id\": 1, \"hive_name\": 'boolean'}\n+    INTEGER = {\"java_class\": \"Integer.class\", \"python_class\": int, \"id\": 2, \"hive_name\": 'int'}\n+    LONG = {\"java_class\": \"Long.class\", \"python_class\": int, \"id\": 3, \"hive_name\": 'bigint'}\n+    FLOAT = {\"java_class\": \"Float.class\", \"python_class\": float, \"id\": 4, \"hive_name\": 'float'}\n+    DOUBLE = {\"java_class\": \"Double.class\", \"python_class\": float, \"id\": 5, \"hive_name\": 'double'}\n+    DATE = {\"java_class\": \"Integer.class\", \"python_class\": int, \"id\": 6, \"hive_name\": 'date'}\n+    TIME = {\"java_class\": \"Long.class\", \"python_class\": int, \"id\": 7, \"hive_name\": 'string'}\n+    TIMESTAMP = {\"java_class\": \"Long.class\", \"python_class\": int, \"id\": 8, \"hive_name\": 'timestamp'}\n+    STRING = {\"java_class\": \"CharSequence.class\", \"python_class\": str, \"id\": 9, \"hive_name\": 'string'}\n+    UUID = {\"java_class\": \"java.util.UUID.class\", \"python_class\": uuid.UUID, \"id\": 10, \"hive_name\": 'string'}\n+    FIXED = {\"java_class\": \"ByteBuffer.class\", \"python_class\": bytes, \"id\": 11, \"hive_name\": 'binary'}\n+    BINARY = {\"java_class\": \"ByteBuffer.class\", \"python_class\": bytearray, \"id\": 12, \"hive_name\": \"binary\"}\n+    DECIMAL = {\"java_class\": \"BigDecimal.class\", \"python_class\": Decimal, \"id\": 13, \"hive_name\": None}\n+    STRUCT = {\"java_class\": \"Void.class\", \"python_class\": None, \"id\": 14, \"hive_name\": None}\n+    LIST = {\"java_class\": \"Void.class\", \"python_class\": None, \"id\": 15, \"hive_name\": None}\n+    MAP = {\"java_class\": \"Void.class\", \"python_class\": None, \"id\": 16, \"hive_name\": None}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "616187d6de0a8c4485b4cf31d19932ac80278200"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc4OTczMg==", "bodyText": "agreed. thats a good point. Thats fixed.", "url": "https://github.com/apache/iceberg/pull/1216#discussion_r475789732", "createdAt": "2020-08-24T17:48:08Z", "author": {"login": "rymurr"}, "path": "python/iceberg/api/types/type.py", "diffHunk": "@@ -22,22 +22,22 @@\n \n @unique\n class TypeID(Enum):\n-    BOOLEAN = {\"java_class\": \"Boolean.class\", \"python_class\": bool, \"id\": 1}\n-    INTEGER = {\"java_class\": \"Integer.class\", \"python_class\": int, \"id\": 2}\n-    LONG = {\"java_class\": \"Long.class\", \"python_class\": int, \"id\": 3}\n-    FLOAT = {\"java_class\": \"Float.class\", \"python_class\": float, \"id\": 4}\n-    DOUBLE = {\"java_class\": \"Double.class\", \"python_class\": float, \"id\": 5}\n-    DATE = {\"java_class\": \"Integer.class\", \"python_class\": int, \"id\": 6}\n-    TIME = {\"java_class\": \"Long.class\", \"python_class\": int, \"id\": 7}\n-    TIMESTAMP = {\"java_class\": \"Long.class\", \"python_class\": int, \"id\": 8}\n-    STRING = {\"java_class\": \"CharSequence.class\", \"python_class\": str, \"id\": 9}\n-    UUID = {\"java_class\": \"java.util.UUID.class\", \"python_class\": uuid.UUID, \"id\": 10}\n-    FIXED = {\"java_class\": \"ByteBuffer.class\", \"python_class\": bytes, \"id\": 11}\n-    BINARY = {\"java_class\": \"ByteBuffer.class\", \"python_class\": bytearray, \"id\": 12}\n-    DECIMAL = {\"java_class\": \"BigDecimal.class\", \"python_class\": Decimal, \"id\": 13}\n-    STRUCT = {\"java_class\": \"Void.class\", \"python_class\": None, \"id\": 14}\n-    LIST = {\"java_class\": \"Void.class\", \"python_class\": None, \"id\": 15}\n-    MAP = {\"java_class\": \"Void.class\", \"python_class\": None, \"id\": 16}\n+    BOOLEAN = {\"java_class\": \"Boolean.class\", \"python_class\": bool, \"id\": 1, \"hive_name\": 'boolean'}\n+    INTEGER = {\"java_class\": \"Integer.class\", \"python_class\": int, \"id\": 2, \"hive_name\": 'int'}\n+    LONG = {\"java_class\": \"Long.class\", \"python_class\": int, \"id\": 3, \"hive_name\": 'bigint'}\n+    FLOAT = {\"java_class\": \"Float.class\", \"python_class\": float, \"id\": 4, \"hive_name\": 'float'}\n+    DOUBLE = {\"java_class\": \"Double.class\", \"python_class\": float, \"id\": 5, \"hive_name\": 'double'}\n+    DATE = {\"java_class\": \"Integer.class\", \"python_class\": int, \"id\": 6, \"hive_name\": 'date'}\n+    TIME = {\"java_class\": \"Long.class\", \"python_class\": int, \"id\": 7, \"hive_name\": 'string'}\n+    TIMESTAMP = {\"java_class\": \"Long.class\", \"python_class\": int, \"id\": 8, \"hive_name\": 'timestamp'}\n+    STRING = {\"java_class\": \"CharSequence.class\", \"python_class\": str, \"id\": 9, \"hive_name\": 'string'}\n+    UUID = {\"java_class\": \"java.util.UUID.class\", \"python_class\": uuid.UUID, \"id\": 10, \"hive_name\": 'string'}\n+    FIXED = {\"java_class\": \"ByteBuffer.class\", \"python_class\": bytes, \"id\": 11, \"hive_name\": 'binary'}\n+    BINARY = {\"java_class\": \"ByteBuffer.class\", \"python_class\": bytearray, \"id\": 12, \"hive_name\": \"binary\"}\n+    DECIMAL = {\"java_class\": \"BigDecimal.class\", \"python_class\": Decimal, \"id\": 13, \"hive_name\": None}\n+    STRUCT = {\"java_class\": \"Void.class\", \"python_class\": None, \"id\": 14, \"hive_name\": None}\n+    LIST = {\"java_class\": \"Void.class\", \"python_class\": None, \"id\": 15, \"hive_name\": None}\n+    MAP = {\"java_class\": \"Void.class\", \"python_class\": None, \"id\": 16, \"hive_name\": None}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc4MDk5Mw=="}, "originalCommit": {"oid": "616187d6de0a8c4485b4cf31d19932ac80278200"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU3NDIyMw==", "bodyText": "I don't see this hive_name property used anywhere. Did you mean to remove these changes from types?", "url": "https://github.com/apache/iceberg/pull/1216#discussion_r476574223", "createdAt": "2020-08-25T16:20:25Z", "author": {"login": "rdblue"}, "path": "python/iceberg/api/types/type.py", "diffHunk": "@@ -22,22 +22,22 @@\n \n @unique\n class TypeID(Enum):\n-    BOOLEAN = {\"java_class\": \"Boolean.class\", \"python_class\": bool, \"id\": 1}\n-    INTEGER = {\"java_class\": \"Integer.class\", \"python_class\": int, \"id\": 2}\n-    LONG = {\"java_class\": \"Long.class\", \"python_class\": int, \"id\": 3}\n-    FLOAT = {\"java_class\": \"Float.class\", \"python_class\": float, \"id\": 4}\n-    DOUBLE = {\"java_class\": \"Double.class\", \"python_class\": float, \"id\": 5}\n-    DATE = {\"java_class\": \"Integer.class\", \"python_class\": int, \"id\": 6}\n-    TIME = {\"java_class\": \"Long.class\", \"python_class\": int, \"id\": 7}\n-    TIMESTAMP = {\"java_class\": \"Long.class\", \"python_class\": int, \"id\": 8}\n-    STRING = {\"java_class\": \"CharSequence.class\", \"python_class\": str, \"id\": 9}\n-    UUID = {\"java_class\": \"java.util.UUID.class\", \"python_class\": uuid.UUID, \"id\": 10}\n-    FIXED = {\"java_class\": \"ByteBuffer.class\", \"python_class\": bytes, \"id\": 11}\n-    BINARY = {\"java_class\": \"ByteBuffer.class\", \"python_class\": bytearray, \"id\": 12}\n-    DECIMAL = {\"java_class\": \"BigDecimal.class\", \"python_class\": Decimal, \"id\": 13}\n-    STRUCT = {\"java_class\": \"Void.class\", \"python_class\": None, \"id\": 14}\n-    LIST = {\"java_class\": \"Void.class\", \"python_class\": None, \"id\": 15}\n-    MAP = {\"java_class\": \"Void.class\", \"python_class\": None, \"id\": 16}\n+    BOOLEAN = {\"java_class\": \"Boolean.class\", \"python_class\": bool, \"id\": 1, \"hive_name\": 'boolean'}\n+    INTEGER = {\"java_class\": \"Integer.class\", \"python_class\": int, \"id\": 2, \"hive_name\": 'int'}\n+    LONG = {\"java_class\": \"Long.class\", \"python_class\": int, \"id\": 3, \"hive_name\": 'bigint'}\n+    FLOAT = {\"java_class\": \"Float.class\", \"python_class\": float, \"id\": 4, \"hive_name\": 'float'}\n+    DOUBLE = {\"java_class\": \"Double.class\", \"python_class\": float, \"id\": 5, \"hive_name\": 'double'}\n+    DATE = {\"java_class\": \"Integer.class\", \"python_class\": int, \"id\": 6, \"hive_name\": 'date'}\n+    TIME = {\"java_class\": \"Long.class\", \"python_class\": int, \"id\": 7, \"hive_name\": 'string'}\n+    TIMESTAMP = {\"java_class\": \"Long.class\", \"python_class\": int, \"id\": 8, \"hive_name\": 'timestamp'}\n+    STRING = {\"java_class\": \"CharSequence.class\", \"python_class\": str, \"id\": 9, \"hive_name\": 'string'}\n+    UUID = {\"java_class\": \"java.util.UUID.class\", \"python_class\": uuid.UUID, \"id\": 10, \"hive_name\": 'string'}\n+    FIXED = {\"java_class\": \"ByteBuffer.class\", \"python_class\": bytes, \"id\": 11, \"hive_name\": 'binary'}\n+    BINARY = {\"java_class\": \"ByteBuffer.class\", \"python_class\": bytearray, \"id\": 12, \"hive_name\": \"binary\"}\n+    DECIMAL = {\"java_class\": \"BigDecimal.class\", \"python_class\": Decimal, \"id\": 13, \"hive_name\": None}\n+    STRUCT = {\"java_class\": \"Void.class\", \"python_class\": None, \"id\": 14, \"hive_name\": None}\n+    LIST = {\"java_class\": \"Void.class\", \"python_class\": None, \"id\": 15, \"hive_name\": None}\n+    MAP = {\"java_class\": \"Void.class\", \"python_class\": None, \"id\": 16, \"hive_name\": None}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc4MDk5Mw=="}, "originalCommit": {"oid": "616187d6de0a8c4485b4cf31d19932ac80278200"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3OTQ3ODA2OnYy", "diffSide": "RIGHT", "path": "python/iceberg/core/filesystem/filesystem_tables.py", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNjoyMTowNlrOHGfzxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNjoyMTowNlrOHGfzxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU3NDY2MA==", "bodyText": "Should we check that location is None to ensure that a user doesn't pass both a table identifier (location) and a different location?", "url": "https://github.com/apache/iceberg/pull/1216#discussion_r476574660", "createdAt": "2020-08-25T16:21:06Z", "author": {"login": "rdblue"}, "path": "python/iceberg/core/filesystem/filesystem_tables.py", "diffHunk": "@@ -15,39 +15,39 @@\n # specific language governing permissions and limitations\n # under the License.\n \n-\n-from iceberg.api import Tables\n-from iceberg.exceptions import NoSuchTableException\n-\n from .filesystem_table_operations import FilesystemTableOperations\n+from .. import TableOperations\n from ..table_metadata import TableMetadata\n+from ...api import PartitionSpec, Schema, Table, Tables\n+from ...exceptions import NoSuchTableException\n \n \n class FilesystemTables(Tables):\n \n-    def __init__(self, conf=None):\n+    def __init__(self: \"FilesystemTables\", conf: dict = None) -> None:\n         self.conf = conf if conf is not None else dict()\n \n-    def load(self, location):\n+    def load(self: \"FilesystemTables\", table_identifier: str) -> Table:\n         from ..base_table import BaseTable\n-        ops = self.new_table_ops(location)\n+        ops = self.new_table_ops(table_identifier)\n         if ops.current() is None:\n-            raise NoSuchTableException(\"Table does not exist at location: %s\" % location)\n+            raise NoSuchTableException(\"Table does not exist at location: %s\" % table_identifier)\n \n-        return BaseTable(ops, location)\n+        return BaseTable(ops, table_identifier)\n \n-    def create(self, schema, table_identifier=None, spec=None, properties=None, location=None):\n+    def create(self: \"FilesystemTables\", schema: Schema, table_identifier: str, spec: PartitionSpec = None,\n+               properties: dict = None, location: str = None) -> Table:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ed48377a3a324902c80f121b408f772df38bda4"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3OTc2NDY5OnYy", "diffSide": "RIGHT", "path": "python/iceberg/core/filesystem/filesystem_tables.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNzoyODoyMFrOHGih1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNzozMzozMVrOHGittA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjYxOTIyMQ==", "bodyText": "This doesn't agree with what is enforced. I like that location must always be None in the code so it would be good to state that here. It would also be easier to read since it avoids \"should be not None\".", "url": "https://github.com/apache/iceberg/pull/1216#discussion_r476619221", "createdAt": "2020-08-25T17:28:20Z", "author": {"login": "rdblue"}, "path": "python/iceberg/core/filesystem/filesystem_tables.py", "diffHunk": "@@ -37,7 +37,19 @@ def load(self: \"FilesystemTables\", table_identifier: str) -> Table:\n \n     def create(self: \"FilesystemTables\", schema: Schema, table_identifier: str, spec: PartitionSpec = None,\n                properties: dict = None, location: str = None) -> Table:\n+        \"\"\"\n+        Create a new table on the filesystem.\n+\n+        Note: it is expected that the filesystem has atomic operations to ensure consistency for metadata updates.\n+        Filesystems that don't have this guarantee could lead to data loss.\n+\n+        Only table_identifier or location should be not None. Will throw an error if both are not None.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c3dae0c3fe8b18139a6d5e6597fade0773f4983"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjYyMjI2MA==", "bodyText": "yup, apologies. Changed my mind halfway through impl. Fixed now", "url": "https://github.com/apache/iceberg/pull/1216#discussion_r476622260", "createdAt": "2020-08-25T17:33:31Z", "author": {"login": "rymurr"}, "path": "python/iceberg/core/filesystem/filesystem_tables.py", "diffHunk": "@@ -37,7 +37,19 @@ def load(self: \"FilesystemTables\", table_identifier: str) -> Table:\n \n     def create(self: \"FilesystemTables\", schema: Schema, table_identifier: str, spec: PartitionSpec = None,\n                properties: dict = None, location: str = None) -> Table:\n+        \"\"\"\n+        Create a new table on the filesystem.\n+\n+        Note: it is expected that the filesystem has atomic operations to ensure consistency for metadata updates.\n+        Filesystems that don't have this guarantee could lead to data loss.\n+\n+        Only table_identifier or location should be not None. Will throw an error if both are not None.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjYxOTIyMQ=="}, "originalCommit": {"oid": "4c3dae0c3fe8b18139a6d5e6597fade0773f4983"}, "originalPosition": 10}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3775, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}