{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEzMjQ3ODU4", "number": 1002, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNToxMToxNFrOD5csKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNToxMToxNFrOD5csKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNTY1NDgzOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/apache/iceberg/types/IndexByName.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNToxMToxNFrOGQuIYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNjowMzozNlrOGQwgpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE4NjIwOA==", "bodyText": "Do we need to add some description of why return directly when isStructType() is true? IIRC, that could lead to duplicate names.", "url": "https://github.com/apache/iceberg/pull/1002#discussion_r420186208", "createdAt": "2020-05-05T15:11:14Z", "author": {"login": "chenjunjiedada"}, "path": "api/src/main/java/org/apache/iceberg/types/IndexByName.java", "diffHunk": "@@ -23,84 +23,97 @@\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import java.util.Deque;\n+import java.util.List;\n import java.util.Map;\n-import java.util.concurrent.Callable;\n-import java.util.function.Supplier;\n import org.apache.iceberg.Schema;\n import org.apache.iceberg.exceptions.ValidationException;\n \n-public class IndexByName extends TypeUtil.CustomOrderSchemaVisitor<Map<String, Integer>> {\n+public class IndexByName extends TypeUtil.SchemaVisitor<Map<String, Integer>> {\n   private static final Joiner DOT = Joiner.on(\".\");\n \n   private final Deque<String> fieldNames = Lists.newLinkedList();\n   private final Map<String, Integer> nameToId = Maps.newHashMap();\n \n   @Override\n-  public Map<String, Integer> schema(Schema schema, Supplier<Map<String, Integer>> structResult) {\n-    return structResult.get();\n+  public void beforeField(Types.NestedField field) {\n+    fieldNames.push(field.name());\n   }\n \n   @Override\n-  public Map<String, Integer> struct(Types.StructType struct, Iterable<Map<String, Integer>> fieldResults) {\n-    // iterate through the fields to update the index for each one, use size to avoid errorprone failure\n-    Lists.newArrayList(fieldResults).size();\n-    return nameToId;\n+  public void afterField(Types.NestedField field) {\n+    fieldNames.pop();\n   }\n \n   @Override\n-  public Map<String, Integer> field(Types.NestedField field, Supplier<Map<String, Integer>> fieldResult) {\n-    withName(field.name(), fieldResult::get);\n-    addField(field.name(), field.fieldId());\n-    return null;\n+  public void beforeListElement(Types.NestedField elementField) {\n+    if (!elementField.type().isStructType()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3bb2f8c16018b9fb3fe23e502b46b31710c71daa"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDIyNTE5MA==", "bodyText": "Yeah, I'll add a comment. The reason is to make the names more natural. If you have a list called locations that has latitude and longitude fields, it would be strange to reference locations.element.latitude instead of locations.latitude. But if the element is not a struct, that doesn't apply.", "url": "https://github.com/apache/iceberg/pull/1002#discussion_r420225190", "createdAt": "2020-05-05T16:03:36Z", "author": {"login": "rdblue"}, "path": "api/src/main/java/org/apache/iceberg/types/IndexByName.java", "diffHunk": "@@ -23,84 +23,97 @@\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import java.util.Deque;\n+import java.util.List;\n import java.util.Map;\n-import java.util.concurrent.Callable;\n-import java.util.function.Supplier;\n import org.apache.iceberg.Schema;\n import org.apache.iceberg.exceptions.ValidationException;\n \n-public class IndexByName extends TypeUtil.CustomOrderSchemaVisitor<Map<String, Integer>> {\n+public class IndexByName extends TypeUtil.SchemaVisitor<Map<String, Integer>> {\n   private static final Joiner DOT = Joiner.on(\".\");\n \n   private final Deque<String> fieldNames = Lists.newLinkedList();\n   private final Map<String, Integer> nameToId = Maps.newHashMap();\n \n   @Override\n-  public Map<String, Integer> schema(Schema schema, Supplier<Map<String, Integer>> structResult) {\n-    return structResult.get();\n+  public void beforeField(Types.NestedField field) {\n+    fieldNames.push(field.name());\n   }\n \n   @Override\n-  public Map<String, Integer> struct(Types.StructType struct, Iterable<Map<String, Integer>> fieldResults) {\n-    // iterate through the fields to update the index for each one, use size to avoid errorprone failure\n-    Lists.newArrayList(fieldResults).size();\n-    return nameToId;\n+  public void afterField(Types.NestedField field) {\n+    fieldNames.pop();\n   }\n \n   @Override\n-  public Map<String, Integer> field(Types.NestedField field, Supplier<Map<String, Integer>> fieldResult) {\n-    withName(field.name(), fieldResult::get);\n-    addField(field.name(), field.fieldId());\n-    return null;\n+  public void beforeListElement(Types.NestedField elementField) {\n+    if (!elementField.type().isStructType()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE4NjIwOA=="}, "originalCommit": {"oid": "3bb2f8c16018b9fb3fe23e502b46b31710c71daa"}, "originalPosition": 40}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3984, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}