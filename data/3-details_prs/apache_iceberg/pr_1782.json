{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIzMzkxOTk4", "number": 1782, "title": "Spark: Add SparkMergeScan", "bodyText": "This PR adds a Spark scan for DELETE/UPDATE/MERGE operations.", "createdAt": "2020-11-18T18:35:01Z", "url": "https://github.com/apache/iceberg/pull/1782", "merged": true, "mergeCommit": {"oid": "1e52c817d05add2f3106e6e6767bb06f566b1c04"}, "closed": true, "closedAt": "2020-11-20T22:37:58Z", "author": {"login": "aokolnychyi"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABddykO0AFqTUzMzc2MTU4MA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdmfVNjgFqTU1Mjc4ODI5Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzNzYxNTgw", "url": "https://github.com/apache/iceberg/pull/1782#pullrequestreview-533761580", "createdAt": "2020-11-18T18:35:52Z", "commit": {"oid": "0037930bf5541face88e99eb5493fc987bcaf6a0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxODozNTo1MlrOH18orA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxODozNTo1MlrOH18orA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjMzMDAyOA==", "bodyText": "I removed the not null check as filterExpressions() cannot be null now.", "url": "https://github.com/apache/iceberg/pull/1782#discussion_r526330028", "createdAt": "2020-11-18T18:35:52Z", "author": {"login": "aokolnychyi"}, "path": "spark3/src/main/java/org/apache/iceberg/spark/source/SparkBatchQueryScan.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.source;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+import org.apache.iceberg.CombinedScanTask;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableProperties;\n+import org.apache.iceberg.TableScan;\n+import org.apache.iceberg.encryption.EncryptionManager;\n+import org.apache.iceberg.exceptions.RuntimeIOException;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.io.CloseableIterable;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.spark.Spark3Util;\n+import org.apache.spark.broadcast.Broadcast;\n+import org.apache.spark.sql.connector.read.SupportsReportStatistics;\n+import org.apache.spark.sql.util.CaseInsensitiveStringMap;\n+\n+class SparkBatchQueryScan extends SparkBatchScan implements SupportsReportStatistics {\n+\n+  private final Long snapshotId;\n+  private final Long startSnapshotId;\n+  private final Long endSnapshotId;\n+  private final Long asOfTimestamp;\n+  private final Long splitSize;\n+  private final Integer splitLookback;\n+  private final Long splitOpenFileCost;\n+\n+  private List<CombinedScanTask> tasks = null; // lazy cache of tasks\n+\n+  SparkBatchQueryScan(Table table, Broadcast<FileIO> io, Broadcast<EncryptionManager> encryption,\n+                      boolean caseSensitive, Schema expectedSchema, List<Expression> filters,\n+                      CaseInsensitiveStringMap options) {\n+\n+    super(table, io, encryption, caseSensitive, expectedSchema, filters, options);\n+\n+    this.snapshotId = Spark3Util.propertyAsLong(options, \"snapshot-id\", null);\n+    this.asOfTimestamp = Spark3Util.propertyAsLong(options, \"as-of-timestamp\", null);\n+\n+    if (snapshotId != null && asOfTimestamp != null) {\n+      throw new IllegalArgumentException(\n+          \"Cannot scan using both snapshot-id and as-of-timestamp to select the table snapshot\");\n+    }\n+\n+    this.startSnapshotId = Spark3Util.propertyAsLong(options, \"start-snapshot-id\", null);\n+    this.endSnapshotId = Spark3Util.propertyAsLong(options, \"end-snapshot-id\", null);\n+    if (snapshotId != null || asOfTimestamp != null) {\n+      if (startSnapshotId != null || endSnapshotId != null) {\n+        throw new IllegalArgumentException(\n+            \"Cannot specify start-snapshot-id and end-snapshot-id to do incremental scan when either snapshot-id or \" +\n+                \"as-of-timestamp is specified\");\n+      }\n+    } else if (startSnapshotId == null && endSnapshotId != null) {\n+      throw new IllegalArgumentException(\"Cannot only specify option end-snapshot-id to do incremental scan\");\n+    }\n+\n+    // look for split behavior overrides in options\n+    this.splitSize = Spark3Util.propertyAsLong(options, \"split-size\", null);\n+    this.splitLookback = Spark3Util.propertyAsInt(options, \"lookback\", null);\n+    this.splitOpenFileCost = Spark3Util.propertyAsLong(options, \"file-open-cost\", null);\n+  }\n+\n+  @Override\n+  protected List<CombinedScanTask> tasks() {\n+    if (tasks == null) {\n+      TableScan scan = table()\n+          .newScan()\n+          .caseSensitive(caseSensitive())\n+          .project(expectedSchema());\n+\n+      if (snapshotId != null) {\n+        scan = scan.useSnapshot(snapshotId);\n+      }\n+\n+      if (asOfTimestamp != null) {\n+        scan = scan.asOfTime(asOfTimestamp);\n+      }\n+\n+      if (startSnapshotId != null) {\n+        if (endSnapshotId != null) {\n+          scan = scan.appendsBetween(startSnapshotId, endSnapshotId);\n+        } else {\n+          scan = scan.appendsAfter(startSnapshotId);\n+        }\n+      }\n+\n+      if (splitSize != null) {\n+        scan = scan.option(TableProperties.SPLIT_SIZE, splitSize.toString());\n+      }\n+\n+      if (splitLookback != null) {\n+        scan = scan.option(TableProperties.SPLIT_LOOKBACK, splitLookback.toString());\n+      }\n+\n+      if (splitOpenFileCost != null) {\n+        scan = scan.option(TableProperties.SPLIT_OPEN_FILE_COST, splitOpenFileCost.toString());\n+      }\n+\n+      for (Expression filter : filterExpressions()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0037930bf5541face88e99eb5493fc987bcaf6a0"}, "originalPosition": 121}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzNzYyMDA4", "url": "https://github.com/apache/iceberg/pull/1782#pullrequestreview-533762008", "createdAt": "2020-11-18T18:36:24Z", "commit": {"oid": "0037930bf5541face88e99eb5493fc987bcaf6a0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxODozNjoyNFrOH18p8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxODozNjoyNFrOH18p8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjMzMDM1NA==", "bodyText": "Previously, we used filterExpressions.toString which could fail with NPE.", "url": "https://github.com/apache/iceberg/pull/1782#discussion_r526330354", "createdAt": "2020-11-18T18:36:24Z", "author": {"login": "aokolnychyi"}, "path": "spark3/src/main/java/org/apache/iceberg/spark/source/SparkBatchQueryScan.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.source;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+import org.apache.iceberg.CombinedScanTask;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableProperties;\n+import org.apache.iceberg.TableScan;\n+import org.apache.iceberg.encryption.EncryptionManager;\n+import org.apache.iceberg.exceptions.RuntimeIOException;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.io.CloseableIterable;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.spark.Spark3Util;\n+import org.apache.spark.broadcast.Broadcast;\n+import org.apache.spark.sql.connector.read.SupportsReportStatistics;\n+import org.apache.spark.sql.util.CaseInsensitiveStringMap;\n+\n+class SparkBatchQueryScan extends SparkBatchScan implements SupportsReportStatistics {\n+\n+  private final Long snapshotId;\n+  private final Long startSnapshotId;\n+  private final Long endSnapshotId;\n+  private final Long asOfTimestamp;\n+  private final Long splitSize;\n+  private final Integer splitLookback;\n+  private final Long splitOpenFileCost;\n+\n+  private List<CombinedScanTask> tasks = null; // lazy cache of tasks\n+\n+  SparkBatchQueryScan(Table table, Broadcast<FileIO> io, Broadcast<EncryptionManager> encryption,\n+                      boolean caseSensitive, Schema expectedSchema, List<Expression> filters,\n+                      CaseInsensitiveStringMap options) {\n+\n+    super(table, io, encryption, caseSensitive, expectedSchema, filters, options);\n+\n+    this.snapshotId = Spark3Util.propertyAsLong(options, \"snapshot-id\", null);\n+    this.asOfTimestamp = Spark3Util.propertyAsLong(options, \"as-of-timestamp\", null);\n+\n+    if (snapshotId != null && asOfTimestamp != null) {\n+      throw new IllegalArgumentException(\n+          \"Cannot scan using both snapshot-id and as-of-timestamp to select the table snapshot\");\n+    }\n+\n+    this.startSnapshotId = Spark3Util.propertyAsLong(options, \"start-snapshot-id\", null);\n+    this.endSnapshotId = Spark3Util.propertyAsLong(options, \"end-snapshot-id\", null);\n+    if (snapshotId != null || asOfTimestamp != null) {\n+      if (startSnapshotId != null || endSnapshotId != null) {\n+        throw new IllegalArgumentException(\n+            \"Cannot specify start-snapshot-id and end-snapshot-id to do incremental scan when either snapshot-id or \" +\n+                \"as-of-timestamp is specified\");\n+      }\n+    } else if (startSnapshotId == null && endSnapshotId != null) {\n+      throw new IllegalArgumentException(\"Cannot only specify option end-snapshot-id to do incremental scan\");\n+    }\n+\n+    // look for split behavior overrides in options\n+    this.splitSize = Spark3Util.propertyAsLong(options, \"split-size\", null);\n+    this.splitLookback = Spark3Util.propertyAsInt(options, \"lookback\", null);\n+    this.splitOpenFileCost = Spark3Util.propertyAsLong(options, \"file-open-cost\", null);\n+  }\n+\n+  @Override\n+  protected List<CombinedScanTask> tasks() {\n+    if (tasks == null) {\n+      TableScan scan = table()\n+          .newScan()\n+          .caseSensitive(caseSensitive())\n+          .project(expectedSchema());\n+\n+      if (snapshotId != null) {\n+        scan = scan.useSnapshot(snapshotId);\n+      }\n+\n+      if (asOfTimestamp != null) {\n+        scan = scan.asOfTime(asOfTimestamp);\n+      }\n+\n+      if (startSnapshotId != null) {\n+        if (endSnapshotId != null) {\n+          scan = scan.appendsBetween(startSnapshotId, endSnapshotId);\n+        } else {\n+          scan = scan.appendsAfter(startSnapshotId);\n+        }\n+      }\n+\n+      if (splitSize != null) {\n+        scan = scan.option(TableProperties.SPLIT_SIZE, splitSize.toString());\n+      }\n+\n+      if (splitLookback != null) {\n+        scan = scan.option(TableProperties.SPLIT_LOOKBACK, splitLookback.toString());\n+      }\n+\n+      if (splitOpenFileCost != null) {\n+        scan = scan.option(TableProperties.SPLIT_OPEN_FILE_COST, splitOpenFileCost.toString());\n+      }\n+\n+      for (Expression filter : filterExpressions()) {\n+        scan = scan.filter(filter);\n+      }\n+\n+      try (CloseableIterable<CombinedScanTask> tasksIterable = scan.planTasks()) {\n+        this.tasks = Lists.newArrayList(tasksIterable);\n+      }  catch (IOException e) {\n+        throw new RuntimeIOException(e, \"Failed to close table scan: %s\", scan);\n+      }\n+    }\n+\n+    return tasks;\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) {\n+      return true;\n+    }\n+\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+\n+    SparkBatchQueryScan that = (SparkBatchQueryScan) o;\n+    return table().name().equals(that.table().name()) &&\n+        readSchema().equals(that.readSchema()) && // compare Spark schemas to ignore field ids\n+        filterExpressions().toString().equals(that.filterExpressions().toString()) &&", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0037930bf5541face88e99eb5493fc987bcaf6a0"}, "originalPosition": 148}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzNzYyODY2", "url": "https://github.com/apache/iceberg/pull/1782#pullrequestreview-533762866", "createdAt": "2020-11-18T18:37:29Z", "commit": {"oid": "0037930bf5541face88e99eb5493fc987bcaf6a0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxODozNzozMFrOH18slQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxODozNzozMFrOH18slQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjMzMTAyOQ==", "bodyText": "I decided to make it configurable so that we can reuse it for merge-on-read too.", "url": "https://github.com/apache/iceberg/pull/1782#discussion_r526331029", "createdAt": "2020-11-18T18:37:30Z", "author": {"login": "aokolnychyi"}, "path": "spark3/src/main/java/org/apache/iceberg/spark/source/SparkScanBuilder.java", "diffHunk": "@@ -133,12 +134,25 @@ public void pruneColumns(StructType requestedSchema) {\n     this.requestedProjection = requestedSchema;\n   }\n \n+  public SparkScanBuilder ignoreResiduals() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0037930bf5541face88e99eb5493fc987bcaf6a0"}, "originalPosition": 12}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM1NjcwNzI5", "url": "https://github.com/apache/iceberg/pull/1782#pullrequestreview-535670729", "createdAt": "2020-11-20T18:15:48Z", "commit": {"oid": "0037930bf5541face88e99eb5493fc987bcaf6a0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxODoxNTo0OFrOH3busw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxODoxNTo0OFrOH3busw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzg4ODA1MQ==", "bodyText": "Would it make sense to use a context object to hold all of these for all scan types?", "url": "https://github.com/apache/iceberg/pull/1782#discussion_r527888051", "createdAt": "2020-11-20T18:15:48Z", "author": {"login": "rdblue"}, "path": "spark3/src/main/java/org/apache/iceberg/spark/source/SparkMergeScan.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.source;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import org.apache.iceberg.CombinedScanTask;\n+import org.apache.iceberg.FileScanTask;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableScan;\n+import org.apache.iceberg.encryption.EncryptionManager;\n+import org.apache.iceberg.exceptions.RuntimeIOException;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.io.CloseableIterable;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.spark.Spark3Util;\n+import org.apache.iceberg.util.PropertyUtil;\n+import org.apache.iceberg.util.TableScanUtil;\n+import org.apache.spark.broadcast.Broadcast;\n+import org.apache.spark.sql.connector.read.Statistics;\n+import org.apache.spark.sql.connector.read.SupportsReportStatistics;\n+import org.apache.spark.sql.util.CaseInsensitiveStringMap;\n+\n+import static org.apache.iceberg.TableProperties.SPLIT_LOOKBACK;\n+import static org.apache.iceberg.TableProperties.SPLIT_LOOKBACK_DEFAULT;\n+import static org.apache.iceberg.TableProperties.SPLIT_OPEN_FILE_COST;\n+import static org.apache.iceberg.TableProperties.SPLIT_OPEN_FILE_COST_DEFAULT;\n+import static org.apache.iceberg.TableProperties.SPLIT_SIZE;\n+import static org.apache.iceberg.TableProperties.SPLIT_SIZE_DEFAULT;\n+\n+class SparkMergeScan extends SparkBatchScan implements SupportsReportStatistics {\n+\n+  private final Table table;\n+  private final boolean ignoreResiduals;\n+  private final Schema expectedSchema;\n+  private final Long snapshotId;\n+  private final Long splitSize;\n+  private final Integer splitLookback;\n+  private final Long splitOpenFileCost;\n+\n+  // lazy variables\n+  private List<FileScanTask> files = null; // lazy cache of files\n+  private List<CombinedScanTask> tasks = null; // lazy cache of tasks\n+\n+  SparkMergeScan(Table table, Broadcast<FileIO> io, Broadcast<EncryptionManager> encryption,\n+                 boolean caseSensitive, boolean ignoreResiduals, Schema expectedSchema,\n+                 List<Expression> filters, CaseInsensitiveStringMap options) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0037930bf5541face88e99eb5493fc987bcaf6a0"}, "originalPosition": 69}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM1NjcyMzY4", "url": "https://github.com/apache/iceberg/pull/1782#pullrequestreview-535672368", "createdAt": "2020-11-20T18:18:13Z", "commit": {"oid": "0037930bf5541face88e99eb5493fc987bcaf6a0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxODoxODoxM1rOH3bzxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxODoxODoxM1rOH3bzxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzg4OTM0OQ==", "bodyText": "Why would snapshotId be null? Don't we need to fix the snapshot ID so that we can use it as the base for validations in the replace commit?", "url": "https://github.com/apache/iceberg/pull/1782#discussion_r527889349", "createdAt": "2020-11-20T18:18:13Z", "author": {"login": "rdblue"}, "path": "spark3/src/main/java/org/apache/iceberg/spark/source/SparkMergeScan.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.source;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import org.apache.iceberg.CombinedScanTask;\n+import org.apache.iceberg.FileScanTask;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableScan;\n+import org.apache.iceberg.encryption.EncryptionManager;\n+import org.apache.iceberg.exceptions.RuntimeIOException;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.io.CloseableIterable;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.spark.Spark3Util;\n+import org.apache.iceberg.util.PropertyUtil;\n+import org.apache.iceberg.util.TableScanUtil;\n+import org.apache.spark.broadcast.Broadcast;\n+import org.apache.spark.sql.connector.read.Statistics;\n+import org.apache.spark.sql.connector.read.SupportsReportStatistics;\n+import org.apache.spark.sql.util.CaseInsensitiveStringMap;\n+\n+import static org.apache.iceberg.TableProperties.SPLIT_LOOKBACK;\n+import static org.apache.iceberg.TableProperties.SPLIT_LOOKBACK_DEFAULT;\n+import static org.apache.iceberg.TableProperties.SPLIT_OPEN_FILE_COST;\n+import static org.apache.iceberg.TableProperties.SPLIT_OPEN_FILE_COST_DEFAULT;\n+import static org.apache.iceberg.TableProperties.SPLIT_SIZE;\n+import static org.apache.iceberg.TableProperties.SPLIT_SIZE_DEFAULT;\n+\n+class SparkMergeScan extends SparkBatchScan implements SupportsReportStatistics {\n+\n+  private final Table table;\n+  private final boolean ignoreResiduals;\n+  private final Schema expectedSchema;\n+  private final Long snapshotId;\n+  private final Long splitSize;\n+  private final Integer splitLookback;\n+  private final Long splitOpenFileCost;\n+\n+  // lazy variables\n+  private List<FileScanTask> files = null; // lazy cache of files\n+  private List<CombinedScanTask> tasks = null; // lazy cache of tasks\n+\n+  SparkMergeScan(Table table, Broadcast<FileIO> io, Broadcast<EncryptionManager> encryption,\n+                 boolean caseSensitive, boolean ignoreResiduals, Schema expectedSchema,\n+                 List<Expression> filters, CaseInsensitiveStringMap options) {\n+\n+    super(table, io, encryption, caseSensitive, expectedSchema, filters, options);\n+\n+    this.table = table;\n+    this.ignoreResiduals = ignoreResiduals;\n+    this.expectedSchema = expectedSchema;\n+    this.snapshotId = Spark3Util.propertyAsLong(options, \"snapshot-id\", null);\n+\n+    Map<String, String> props = table.properties();\n+\n+    long tableSplitSize = PropertyUtil.propertyAsLong(props, SPLIT_SIZE, SPLIT_SIZE_DEFAULT);\n+    this.splitSize = Spark3Util.propertyAsLong(options, \"split-size\", tableSplitSize);\n+\n+    int tableSplitLookback = PropertyUtil.propertyAsInt(props, SPLIT_LOOKBACK, SPLIT_LOOKBACK_DEFAULT);\n+    this.splitLookback = Spark3Util.propertyAsInt(options, \"lookback\", tableSplitLookback);\n+\n+    long tableOpenFileCost = PropertyUtil.propertyAsLong(props, SPLIT_OPEN_FILE_COST, SPLIT_OPEN_FILE_COST_DEFAULT);\n+    this.splitOpenFileCost = Spark3Util.propertyAsLong(options, \"file-open-cost\", tableOpenFileCost);\n+\n+    if (snapshotId == null) {\n+      // init files with an empty list if the snapshot id is not set to avoid picking any concurrent changes\n+      files = Collections.emptyList();\n+    }\n+  }\n+\n+  Long snapshotId() {\n+    return snapshotId;\n+  }\n+\n+  @Override\n+  public Statistics estimateStatistics() {\n+    if (snapshotId == null) {\n+      return new Stats(0L, 0L);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0037930bf5541face88e99eb5493fc987bcaf6a0"}, "originalPosition": 102}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM1NjczNDY3", "url": "https://github.com/apache/iceberg/pull/1782#pullrequestreview-535673467", "createdAt": "2020-11-20T18:19:57Z", "commit": {"oid": "0037930bf5541face88e99eb5493fc987bcaf6a0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxODoxOTo1N1rOH3b3KQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxODoxOTo1N1rOH3b3KQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzg5MDIxNw==", "bodyText": "We need to remember to add the filtered file list here after that is supported, right?", "url": "https://github.com/apache/iceberg/pull/1782#discussion_r527890217", "createdAt": "2020-11-20T18:19:57Z", "author": {"login": "rdblue"}, "path": "spark3/src/main/java/org/apache/iceberg/spark/source/SparkMergeScan.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.source;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import org.apache.iceberg.CombinedScanTask;\n+import org.apache.iceberg.FileScanTask;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableScan;\n+import org.apache.iceberg.encryption.EncryptionManager;\n+import org.apache.iceberg.exceptions.RuntimeIOException;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.io.CloseableIterable;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.spark.Spark3Util;\n+import org.apache.iceberg.util.PropertyUtil;\n+import org.apache.iceberg.util.TableScanUtil;\n+import org.apache.spark.broadcast.Broadcast;\n+import org.apache.spark.sql.connector.read.Statistics;\n+import org.apache.spark.sql.connector.read.SupportsReportStatistics;\n+import org.apache.spark.sql.util.CaseInsensitiveStringMap;\n+\n+import static org.apache.iceberg.TableProperties.SPLIT_LOOKBACK;\n+import static org.apache.iceberg.TableProperties.SPLIT_LOOKBACK_DEFAULT;\n+import static org.apache.iceberg.TableProperties.SPLIT_OPEN_FILE_COST;\n+import static org.apache.iceberg.TableProperties.SPLIT_OPEN_FILE_COST_DEFAULT;\n+import static org.apache.iceberg.TableProperties.SPLIT_SIZE;\n+import static org.apache.iceberg.TableProperties.SPLIT_SIZE_DEFAULT;\n+\n+class SparkMergeScan extends SparkBatchScan implements SupportsReportStatistics {\n+\n+  private final Table table;\n+  private final boolean ignoreResiduals;\n+  private final Schema expectedSchema;\n+  private final Long snapshotId;\n+  private final Long splitSize;\n+  private final Integer splitLookback;\n+  private final Long splitOpenFileCost;\n+\n+  // lazy variables\n+  private List<FileScanTask> files = null; // lazy cache of files\n+  private List<CombinedScanTask> tasks = null; // lazy cache of tasks\n+\n+  SparkMergeScan(Table table, Broadcast<FileIO> io, Broadcast<EncryptionManager> encryption,\n+                 boolean caseSensitive, boolean ignoreResiduals, Schema expectedSchema,\n+                 List<Expression> filters, CaseInsensitiveStringMap options) {\n+\n+    super(table, io, encryption, caseSensitive, expectedSchema, filters, options);\n+\n+    this.table = table;\n+    this.ignoreResiduals = ignoreResiduals;\n+    this.expectedSchema = expectedSchema;\n+    this.snapshotId = Spark3Util.propertyAsLong(options, \"snapshot-id\", null);\n+\n+    Map<String, String> props = table.properties();\n+\n+    long tableSplitSize = PropertyUtil.propertyAsLong(props, SPLIT_SIZE, SPLIT_SIZE_DEFAULT);\n+    this.splitSize = Spark3Util.propertyAsLong(options, \"split-size\", tableSplitSize);\n+\n+    int tableSplitLookback = PropertyUtil.propertyAsInt(props, SPLIT_LOOKBACK, SPLIT_LOOKBACK_DEFAULT);\n+    this.splitLookback = Spark3Util.propertyAsInt(options, \"lookback\", tableSplitLookback);\n+\n+    long tableOpenFileCost = PropertyUtil.propertyAsLong(props, SPLIT_OPEN_FILE_COST, SPLIT_OPEN_FILE_COST_DEFAULT);\n+    this.splitOpenFileCost = Spark3Util.propertyAsLong(options, \"file-open-cost\", tableOpenFileCost);\n+\n+    if (snapshotId == null) {\n+      // init files with an empty list if the snapshot id is not set to avoid picking any concurrent changes\n+      files = Collections.emptyList();\n+    }\n+  }\n+\n+  Long snapshotId() {\n+    return snapshotId;\n+  }\n+\n+  @Override\n+  public Statistics estimateStatistics() {\n+    if (snapshotId == null) {\n+      return new Stats(0L, 0L);\n+    }\n+    return super.estimateStatistics();\n+  }\n+\n+  // should be accessible to the write\n+  List<FileScanTask> files() {\n+    if (files == null) {\n+      TableScan scan = table\n+          .newScan()\n+          .caseSensitive(caseSensitive())\n+          .useSnapshot(snapshotId)\n+          .project(expectedSchema);\n+\n+      for (Expression filter : filterExpressions()) {\n+        scan = scan.filter(filter);\n+      }\n+\n+      if (ignoreResiduals) {\n+        scan.ignoreResiduals();\n+      }\n+\n+      try (CloseableIterable<FileScanTask> filesIterable = scan.planFiles()) {\n+        this.files = Lists.newArrayList(filesIterable);\n+      } catch (IOException e) {\n+        throw new RuntimeIOException(e, \"Failed to close table scan: %s\", scan);\n+      }\n+    }\n+\n+    return files;\n+  }\n+\n+  @Override\n+  protected List<CombinedScanTask> tasks() {\n+    if (tasks == null) {\n+      CloseableIterable<FileScanTask> splitFiles = TableScanUtil.splitFiles(\n+          CloseableIterable.withNoopClose(files()),\n+          splitSize);\n+      CloseableIterable<CombinedScanTask> scanTasks = TableScanUtil.planTasks(\n+          splitFiles, splitSize,\n+          splitLookback, splitOpenFileCost);\n+      tasks = Lists.newArrayList(scanTasks);\n+    }\n+\n+    return tasks;\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) {\n+      return true;\n+    }\n+\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+\n+    SparkMergeScan that = (SparkMergeScan) o;\n+    return table().name().equals(that.table().name()) &&\n+        readSchema().equals(that.readSchema()) && // compare Spark schemas to ignore field ids\n+        filterExpressions().toString().equals(that.filterExpressions().toString()) &&\n+        ignoreResiduals == that.ignoreResiduals &&\n+        Objects.equals(snapshotId, that.snapshotId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0037930bf5541face88e99eb5493fc987bcaf6a0"}, "originalPosition": 164}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM1Njc0OTE2", "url": "https://github.com/apache/iceberg/pull/1782#pullrequestreview-535674916", "createdAt": "2020-11-20T18:22:06Z", "commit": {"oid": "0037930bf5541face88e99eb5493fc987bcaf6a0"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f734ffeaf365c2d4e9a708ec10423c304f54b6bf", "author": {"user": {"login": "aokolnychyi", "name": "Anton Okolnychyi"}}, "url": "https://github.com/apache/iceberg/commit/f734ffeaf365c2d4e9a708ec10423c304f54b6bf", "committedDate": "2020-11-20T21:11:03Z", "message": "Spark: Add SparkMergeScan"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0037930bf5541face88e99eb5493fc987bcaf6a0", "author": {"user": {"login": "aokolnychyi", "name": "Anton Okolnychyi"}}, "url": "https://github.com/apache/iceberg/commit/0037930bf5541face88e99eb5493fc987bcaf6a0", "committedDate": "2020-11-18T18:33:52Z", "message": "Spark: Add SparkMergeScan"}, "afterCommit": {"oid": "f734ffeaf365c2d4e9a708ec10423c304f54b6bf", "author": {"user": {"login": "aokolnychyi", "name": "Anton Okolnychyi"}}, "url": "https://github.com/apache/iceberg/commit/f734ffeaf365c2d4e9a708ec10423c304f54b6bf", "committedDate": "2020-11-20T21:11:03Z", "message": "Spark: Add SparkMergeScan"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUyNzg4Mjkz", "url": "https://github.com/apache/iceberg/pull/1782#pullrequestreview-552788293", "createdAt": "2020-12-15T19:16:35Z", "commit": {"oid": "f734ffeaf365c2d4e9a708ec10423c304f54b6bf"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxOToxNjozNVrOIGb2vA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxOToxNjozNVrOIGb2vA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzYxODc0OA==", "bodyText": "Can you please explain why SparkMergeScan has its own private table field? Afaics, it is only used in files(), where table.newScan() is called. Why can you not call table().newScan() instead? If you can, then there is no need for this private table field; you'll only ever use the table in the superclass, SparkBatchScan.", "url": "https://github.com/apache/iceberg/pull/1782#discussion_r543618748", "createdAt": "2020-12-15T19:16:35Z", "author": {"login": "wypoon"}, "path": "spark3/src/main/java/org/apache/iceberg/spark/source/SparkMergeScan.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.source;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import org.apache.iceberg.CombinedScanTask;\n+import org.apache.iceberg.FileScanTask;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableScan;\n+import org.apache.iceberg.encryption.EncryptionManager;\n+import org.apache.iceberg.exceptions.RuntimeIOException;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.io.CloseableIterable;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.spark.Spark3Util;\n+import org.apache.iceberg.util.PropertyUtil;\n+import org.apache.iceberg.util.TableScanUtil;\n+import org.apache.spark.broadcast.Broadcast;\n+import org.apache.spark.sql.connector.read.Statistics;\n+import org.apache.spark.sql.util.CaseInsensitiveStringMap;\n+\n+import static org.apache.iceberg.TableProperties.SPLIT_LOOKBACK;\n+import static org.apache.iceberg.TableProperties.SPLIT_LOOKBACK_DEFAULT;\n+import static org.apache.iceberg.TableProperties.SPLIT_OPEN_FILE_COST;\n+import static org.apache.iceberg.TableProperties.SPLIT_OPEN_FILE_COST_DEFAULT;\n+import static org.apache.iceberg.TableProperties.SPLIT_SIZE;\n+import static org.apache.iceberg.TableProperties.SPLIT_SIZE_DEFAULT;\n+\n+class SparkMergeScan extends SparkBatchScan {\n+\n+  private final Table table;\n+  private final boolean ignoreResiduals;\n+  private final Schema expectedSchema;\n+  private final Long snapshotId;\n+  private final Long splitSize;\n+  private final Integer splitLookback;\n+  private final Long splitOpenFileCost;\n+\n+  // lazy variables\n+  private List<FileScanTask> files = null; // lazy cache of files\n+  private List<CombinedScanTask> tasks = null; // lazy cache of tasks\n+\n+  SparkMergeScan(Table table, Broadcast<FileIO> io, Broadcast<EncryptionManager> encryption,\n+                 boolean caseSensitive, boolean ignoreResiduals, Schema expectedSchema,\n+                 List<Expression> filters, CaseInsensitiveStringMap options) {\n+\n+    super(table, io, encryption, caseSensitive, expectedSchema, filters, options);\n+\n+    this.table = table;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f734ffeaf365c2d4e9a708ec10423c304f54b6bf"}, "originalPosition": 72}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3775, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}