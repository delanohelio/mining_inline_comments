{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMyMjUyNDQw", "number": 1873, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwODozODoyNVrOFAr-Ww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQyMzo0MzoxMlrOFCpw_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2MjY0Nzk1OnYy", "diffSide": "RIGHT", "path": "hive-metastore/src/main/java/org/apache/iceberg/hive/HiveTableOperations.java", "isResolved": false, "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwODozODoyNVrOH_GTiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxNzo0MjoxN1rOIDVgJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTkyNTY0MQ==", "bodyText": "Might worth to mention in the documentation, or somewhere that this should be smaller than hive.txn.timeout or in newer versions metastore.txn.timeout otherwise the locks might be timed out without because of the lack of heartbeat.", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r535925641", "createdAt": "2020-12-04T08:38:25Z", "author": {"login": "pvary"}, "path": "hive-metastore/src/main/java/org/apache/iceberg/hive/HiveTableOperations.java", "diffHunk": "@@ -70,21 +72,38 @@\n public class HiveTableOperations extends BaseMetastoreTableOperations {\n   private static final Logger LOG = LoggerFactory.getLogger(HiveTableOperations.class);\n \n-  private static final String HIVE_ACQUIRE_LOCK_STATE_TIMEOUT_MS = \"iceberg.hive.lock-timeout-ms\";\n-  private static final long HIVE_ACQUIRE_LOCK_STATE_TIMEOUT_MS_DEFAULT = 3 * 60 * 1000; // 3 minutes\n+  private static final String HIVE_ACQUIRE_LOCK_TIMEOUT_MS = \"iceberg.hive.lock-timeout-ms\";\n+  private static final String HIVE_LOCK_CHECK_MIN_WAIT_MS = \"iceberg.hive.lock-check-min-wait-ms\";\n+  private static final String HIVE_LOCK_CHECK_MAX_WAIT_MS = \"iceberg.hive.lock-check-max-wait-ms\";\n+  private static final String HIVE_LOCK_CHECK_BACKOFF_SCALE_FACTOR = \"iceberg.hive.lock-check-backoff-scale-factor\";\n+  private static final long HIVE_ACQUIRE_LOCK_TIMEOUT_MS_DEFAULT = 3 * 60 * 1000; // 3 minutes\n+  private static final long HIVE_LOCK_CHECK_MIN_WAIT_MS_DEFAULT = 50; // 50 milliseconds\n+  private static final long HIVE_LOCK_CHECK_MAX_WAIT_MS_DEFAULT = 5 * 1000; // 5 seconds", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b201863396dd365ec64d33a43aefa776e23c1cde"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk4ODc4Mg==", "bodyText": "We should also add these configs to configuration.md to the rest of Hadoop conf, @raptond.", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r535988782", "createdAt": "2020-12-04T10:16:13Z", "author": {"login": "aokolnychyi"}, "path": "hive-metastore/src/main/java/org/apache/iceberg/hive/HiveTableOperations.java", "diffHunk": "@@ -70,21 +72,38 @@\n public class HiveTableOperations extends BaseMetastoreTableOperations {\n   private static final Logger LOG = LoggerFactory.getLogger(HiveTableOperations.class);\n \n-  private static final String HIVE_ACQUIRE_LOCK_STATE_TIMEOUT_MS = \"iceberg.hive.lock-timeout-ms\";\n-  private static final long HIVE_ACQUIRE_LOCK_STATE_TIMEOUT_MS_DEFAULT = 3 * 60 * 1000; // 3 minutes\n+  private static final String HIVE_ACQUIRE_LOCK_TIMEOUT_MS = \"iceberg.hive.lock-timeout-ms\";\n+  private static final String HIVE_LOCK_CHECK_MIN_WAIT_MS = \"iceberg.hive.lock-check-min-wait-ms\";\n+  private static final String HIVE_LOCK_CHECK_MAX_WAIT_MS = \"iceberg.hive.lock-check-max-wait-ms\";\n+  private static final String HIVE_LOCK_CHECK_BACKOFF_SCALE_FACTOR = \"iceberg.hive.lock-check-backoff-scale-factor\";\n+  private static final long HIVE_ACQUIRE_LOCK_TIMEOUT_MS_DEFAULT = 3 * 60 * 1000; // 3 minutes\n+  private static final long HIVE_LOCK_CHECK_MIN_WAIT_MS_DEFAULT = 50; // 50 milliseconds\n+  private static final long HIVE_LOCK_CHECK_MAX_WAIT_MS_DEFAULT = 5 * 1000; // 5 seconds", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTkyNTY0MQ=="}, "originalCommit": {"oid": "b201863396dd365ec64d33a43aefa776e23c1cde"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjI1MTYzNQ==", "bodyText": "The Glue catalog is introducing support for a lock using DynamoDB. It would be nice to standardize these options across catalogs so that we only need to document them once and they work the same way. FYI @jackye1995.\nI think it would also make sense for these to be catalog options, rather than pulled from the Hive configuration. We used HiveConf originally because we didn't have catalog-specific configuration, but now I think it would make sense to move these into catalog properties. We don't want to increase the cases where we use a Hadoop Configuration.", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r536251635", "createdAt": "2020-12-04T17:16:38Z", "author": {"login": "rdblue"}, "path": "hive-metastore/src/main/java/org/apache/iceberg/hive/HiveTableOperations.java", "diffHunk": "@@ -70,21 +72,38 @@\n public class HiveTableOperations extends BaseMetastoreTableOperations {\n   private static final Logger LOG = LoggerFactory.getLogger(HiveTableOperations.class);\n \n-  private static final String HIVE_ACQUIRE_LOCK_STATE_TIMEOUT_MS = \"iceberg.hive.lock-timeout-ms\";\n-  private static final long HIVE_ACQUIRE_LOCK_STATE_TIMEOUT_MS_DEFAULT = 3 * 60 * 1000; // 3 minutes\n+  private static final String HIVE_ACQUIRE_LOCK_TIMEOUT_MS = \"iceberg.hive.lock-timeout-ms\";\n+  private static final String HIVE_LOCK_CHECK_MIN_WAIT_MS = \"iceberg.hive.lock-check-min-wait-ms\";\n+  private static final String HIVE_LOCK_CHECK_MAX_WAIT_MS = \"iceberg.hive.lock-check-max-wait-ms\";\n+  private static final String HIVE_LOCK_CHECK_BACKOFF_SCALE_FACTOR = \"iceberg.hive.lock-check-backoff-scale-factor\";\n+  private static final long HIVE_ACQUIRE_LOCK_TIMEOUT_MS_DEFAULT = 3 * 60 * 1000; // 3 minutes\n+  private static final long HIVE_LOCK_CHECK_MIN_WAIT_MS_DEFAULT = 50; // 50 milliseconds\n+  private static final long HIVE_LOCK_CHECK_MAX_WAIT_MS_DEFAULT = 5 * 1000; // 5 seconds", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTkyNTY0MQ=="}, "originalCommit": {"oid": "b201863396dd365ec64d33a43aefa776e23c1cde"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjI3MDY3NQ==", "bodyText": "Yes agree. But Hive is currently built around reading from Hadoop configs. If we want to change it to use catalog properties, we need to also change all the places that loads HiveCatalog using the constructor public HiveCatalog(Configuration conf), such as https://github.com/apache/iceberg/blob/master/mr/src/main/java/org/apache/iceberg/mr/Catalogs.java#L215", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r536270675", "createdAt": "2020-12-04T17:47:10Z", "author": {"login": "jackye1995"}, "path": "hive-metastore/src/main/java/org/apache/iceberg/hive/HiveTableOperations.java", "diffHunk": "@@ -70,21 +72,38 @@\n public class HiveTableOperations extends BaseMetastoreTableOperations {\n   private static final Logger LOG = LoggerFactory.getLogger(HiveTableOperations.class);\n \n-  private static final String HIVE_ACQUIRE_LOCK_STATE_TIMEOUT_MS = \"iceberg.hive.lock-timeout-ms\";\n-  private static final long HIVE_ACQUIRE_LOCK_STATE_TIMEOUT_MS_DEFAULT = 3 * 60 * 1000; // 3 minutes\n+  private static final String HIVE_ACQUIRE_LOCK_TIMEOUT_MS = \"iceberg.hive.lock-timeout-ms\";\n+  private static final String HIVE_LOCK_CHECK_MIN_WAIT_MS = \"iceberg.hive.lock-check-min-wait-ms\";\n+  private static final String HIVE_LOCK_CHECK_MAX_WAIT_MS = \"iceberg.hive.lock-check-max-wait-ms\";\n+  private static final String HIVE_LOCK_CHECK_BACKOFF_SCALE_FACTOR = \"iceberg.hive.lock-check-backoff-scale-factor\";\n+  private static final long HIVE_ACQUIRE_LOCK_TIMEOUT_MS_DEFAULT = 3 * 60 * 1000; // 3 minutes\n+  private static final long HIVE_LOCK_CHECK_MIN_WAIT_MS_DEFAULT = 50; // 50 milliseconds\n+  private static final long HIVE_LOCK_CHECK_MAX_WAIT_MS_DEFAULT = 5 * 1000; // 5 seconds", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTkyNTY0MQ=="}, "originalCommit": {"oid": "b201863396dd365ec64d33a43aefa776e23c1cde"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM4MTcxOA==", "bodyText": "This API is also used from Spark 2 where we don't have a way to specify catalog options. Plus, we already have a Hadoop conf for the lock timeout. How do we approach this?", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r536381718", "createdAt": "2020-12-04T21:11:11Z", "author": {"login": "aokolnychyi"}, "path": "hive-metastore/src/main/java/org/apache/iceberg/hive/HiveTableOperations.java", "diffHunk": "@@ -70,21 +72,38 @@\n public class HiveTableOperations extends BaseMetastoreTableOperations {\n   private static final Logger LOG = LoggerFactory.getLogger(HiveTableOperations.class);\n \n-  private static final String HIVE_ACQUIRE_LOCK_STATE_TIMEOUT_MS = \"iceberg.hive.lock-timeout-ms\";\n-  private static final long HIVE_ACQUIRE_LOCK_STATE_TIMEOUT_MS_DEFAULT = 3 * 60 * 1000; // 3 minutes\n+  private static final String HIVE_ACQUIRE_LOCK_TIMEOUT_MS = \"iceberg.hive.lock-timeout-ms\";\n+  private static final String HIVE_LOCK_CHECK_MIN_WAIT_MS = \"iceberg.hive.lock-check-min-wait-ms\";\n+  private static final String HIVE_LOCK_CHECK_MAX_WAIT_MS = \"iceberg.hive.lock-check-max-wait-ms\";\n+  private static final String HIVE_LOCK_CHECK_BACKOFF_SCALE_FACTOR = \"iceberg.hive.lock-check-backoff-scale-factor\";\n+  private static final long HIVE_ACQUIRE_LOCK_TIMEOUT_MS_DEFAULT = 3 * 60 * 1000; // 3 minutes\n+  private static final long HIVE_LOCK_CHECK_MIN_WAIT_MS_DEFAULT = 50; // 50 milliseconds\n+  private static final long HIVE_LOCK_CHECK_MAX_WAIT_MS_DEFAULT = 5 * 1000; // 5 seconds", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTkyNTY0MQ=="}, "originalCommit": {"oid": "b201863396dd365ec64d33a43aefa776e23c1cde"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM4MjA5Nw==", "bodyText": "That being said, I am +1 for adding catalog options. I am just not sure we can get rid of Hadoop conf completely in this case.", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r536382097", "createdAt": "2020-12-04T21:12:00Z", "author": {"login": "aokolnychyi"}, "path": "hive-metastore/src/main/java/org/apache/iceberg/hive/HiveTableOperations.java", "diffHunk": "@@ -70,21 +72,38 @@\n public class HiveTableOperations extends BaseMetastoreTableOperations {\n   private static final Logger LOG = LoggerFactory.getLogger(HiveTableOperations.class);\n \n-  private static final String HIVE_ACQUIRE_LOCK_STATE_TIMEOUT_MS = \"iceberg.hive.lock-timeout-ms\";\n-  private static final long HIVE_ACQUIRE_LOCK_STATE_TIMEOUT_MS_DEFAULT = 3 * 60 * 1000; // 3 minutes\n+  private static final String HIVE_ACQUIRE_LOCK_TIMEOUT_MS = \"iceberg.hive.lock-timeout-ms\";\n+  private static final String HIVE_LOCK_CHECK_MIN_WAIT_MS = \"iceberg.hive.lock-check-min-wait-ms\";\n+  private static final String HIVE_LOCK_CHECK_MAX_WAIT_MS = \"iceberg.hive.lock-check-max-wait-ms\";\n+  private static final String HIVE_LOCK_CHECK_BACKOFF_SCALE_FACTOR = \"iceberg.hive.lock-check-backoff-scale-factor\";\n+  private static final long HIVE_ACQUIRE_LOCK_TIMEOUT_MS_DEFAULT = 3 * 60 * 1000; // 3 minutes\n+  private static final long HIVE_LOCK_CHECK_MIN_WAIT_MS_DEFAULT = 50; // 50 milliseconds\n+  private static final long HIVE_LOCK_CHECK_MAX_WAIT_MS_DEFAULT = 5 * 1000; // 5 seconds", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTkyNTY0MQ=="}, "originalCommit": {"oid": "b201863396dd365ec64d33a43aefa776e23c1cde"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQwMjI2NA==", "bodyText": "In that case, we should default from Configuration, but prefer options passed to the initialize method.", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r536402264", "createdAt": "2020-12-04T21:52:01Z", "author": {"login": "rdblue"}, "path": "hive-metastore/src/main/java/org/apache/iceberg/hive/HiveTableOperations.java", "diffHunk": "@@ -70,21 +72,38 @@\n public class HiveTableOperations extends BaseMetastoreTableOperations {\n   private static final Logger LOG = LoggerFactory.getLogger(HiveTableOperations.class);\n \n-  private static final String HIVE_ACQUIRE_LOCK_STATE_TIMEOUT_MS = \"iceberg.hive.lock-timeout-ms\";\n-  private static final long HIVE_ACQUIRE_LOCK_STATE_TIMEOUT_MS_DEFAULT = 3 * 60 * 1000; // 3 minutes\n+  private static final String HIVE_ACQUIRE_LOCK_TIMEOUT_MS = \"iceberg.hive.lock-timeout-ms\";\n+  private static final String HIVE_LOCK_CHECK_MIN_WAIT_MS = \"iceberg.hive.lock-check-min-wait-ms\";\n+  private static final String HIVE_LOCK_CHECK_MAX_WAIT_MS = \"iceberg.hive.lock-check-max-wait-ms\";\n+  private static final String HIVE_LOCK_CHECK_BACKOFF_SCALE_FACTOR = \"iceberg.hive.lock-check-backoff-scale-factor\";\n+  private static final long HIVE_ACQUIRE_LOCK_TIMEOUT_MS_DEFAULT = 3 * 60 * 1000; // 3 minutes\n+  private static final long HIVE_LOCK_CHECK_MIN_WAIT_MS_DEFAULT = 50; // 50 milliseconds\n+  private static final long HIVE_LOCK_CHECK_MAX_WAIT_MS_DEFAULT = 5 * 1000; // 5 seconds", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTkyNTY0MQ=="}, "originalCommit": {"oid": "b201863396dd365ec64d33a43aefa776e23c1cde"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTExMjE0MA==", "bodyText": "@aokolnychyi @pvary -", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r539112140", "createdAt": "2020-12-09T08:41:54Z", "author": {"login": "raptond"}, "path": "hive-metastore/src/main/java/org/apache/iceberg/hive/HiveTableOperations.java", "diffHunk": "@@ -70,21 +72,38 @@\n public class HiveTableOperations extends BaseMetastoreTableOperations {\n   private static final Logger LOG = LoggerFactory.getLogger(HiveTableOperations.class);\n \n-  private static final String HIVE_ACQUIRE_LOCK_STATE_TIMEOUT_MS = \"iceberg.hive.lock-timeout-ms\";\n-  private static final long HIVE_ACQUIRE_LOCK_STATE_TIMEOUT_MS_DEFAULT = 3 * 60 * 1000; // 3 minutes\n+  private static final String HIVE_ACQUIRE_LOCK_TIMEOUT_MS = \"iceberg.hive.lock-timeout-ms\";\n+  private static final String HIVE_LOCK_CHECK_MIN_WAIT_MS = \"iceberg.hive.lock-check-min-wait-ms\";\n+  private static final String HIVE_LOCK_CHECK_MAX_WAIT_MS = \"iceberg.hive.lock-check-max-wait-ms\";\n+  private static final String HIVE_LOCK_CHECK_BACKOFF_SCALE_FACTOR = \"iceberg.hive.lock-check-backoff-scale-factor\";\n+  private static final long HIVE_ACQUIRE_LOCK_TIMEOUT_MS_DEFAULT = 3 * 60 * 1000; // 3 minutes\n+  private static final long HIVE_LOCK_CHECK_MIN_WAIT_MS_DEFAULT = 50; // 50 milliseconds\n+  private static final long HIVE_LOCK_CHECK_MAX_WAIT_MS_DEFAULT = 5 * 1000; // 5 seconds", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTkyNTY0MQ=="}, "originalCommit": {"oid": "b201863396dd365ec64d33a43aefa776e23c1cde"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM2ODkzMw==", "bodyText": "To make sure I got @rdblue and @jackye1995. You are talking about generalizing catalog options, right?", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r540368933", "createdAt": "2020-12-10T17:42:17Z", "author": {"login": "aokolnychyi"}, "path": "hive-metastore/src/main/java/org/apache/iceberg/hive/HiveTableOperations.java", "diffHunk": "@@ -70,21 +72,38 @@\n public class HiveTableOperations extends BaseMetastoreTableOperations {\n   private static final Logger LOG = LoggerFactory.getLogger(HiveTableOperations.class);\n \n-  private static final String HIVE_ACQUIRE_LOCK_STATE_TIMEOUT_MS = \"iceberg.hive.lock-timeout-ms\";\n-  private static final long HIVE_ACQUIRE_LOCK_STATE_TIMEOUT_MS_DEFAULT = 3 * 60 * 1000; // 3 minutes\n+  private static final String HIVE_ACQUIRE_LOCK_TIMEOUT_MS = \"iceberg.hive.lock-timeout-ms\";\n+  private static final String HIVE_LOCK_CHECK_MIN_WAIT_MS = \"iceberg.hive.lock-check-min-wait-ms\";\n+  private static final String HIVE_LOCK_CHECK_MAX_WAIT_MS = \"iceberg.hive.lock-check-max-wait-ms\";\n+  private static final String HIVE_LOCK_CHECK_BACKOFF_SCALE_FACTOR = \"iceberg.hive.lock-check-backoff-scale-factor\";\n+  private static final long HIVE_ACQUIRE_LOCK_TIMEOUT_MS_DEFAULT = 3 * 60 * 1000; // 3 minutes\n+  private static final long HIVE_LOCK_CHECK_MIN_WAIT_MS_DEFAULT = 50; // 50 milliseconds\n+  private static final long HIVE_LOCK_CHECK_MAX_WAIT_MS_DEFAULT = 5 * 1000; // 5 seconds", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTkyNTY0MQ=="}, "originalCommit": {"oid": "b201863396dd365ec64d33a43aefa776e23c1cde"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2MjcyMDU3OnYy", "diffSide": "RIGHT", "path": "hive-metastore/src/test/java/org/apache/iceberg/hive/TestHiveMetastore.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwODo1NDo0OVrOH_G75Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwNzo0NzoyOFrOICGvDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTkzNTk3Mw==", "bodyText": "nit: Could we use VisibleForTesting annotation here?", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r535935973", "createdAt": "2020-12-04T08:54:49Z", "author": {"login": "pvary"}, "path": "hive-metastore/src/test/java/org/apache/iceberg/hive/TestHiveMetastore.java", "diffHunk": "@@ -84,7 +84,7 @@\n   private ExecutorService executorService;\n   private TServer server;\n   private HiveMetaStore.HMSHandler baseHandler;\n-  private HiveClientPool clientPool;\n+  protected HiveClientPool clientPool; // Exposed for testing.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b201863396dd365ec64d33a43aefa776e23c1cde"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA3ODQxNQ==", "bodyText": "Since this was a test class, I didn't add this annotation. I finally ended up not using it, so I reverted back the change. Thanks for the review.", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r539078415", "createdAt": "2020-12-09T07:47:28Z", "author": {"login": "raptond"}, "path": "hive-metastore/src/test/java/org/apache/iceberg/hive/TestHiveMetastore.java", "diffHunk": "@@ -84,7 +84,7 @@\n   private ExecutorService executorService;\n   private TServer server;\n   private HiveMetaStore.HMSHandler baseHandler;\n-  private HiveClientPool clientPool;\n+  protected HiveClientPool clientPool; // Exposed for testing.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTkzNTk3Mw=="}, "originalCommit": {"oid": "b201863396dd365ec64d33a43aefa776e23c1cde"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2MzEwNDQ3OnYy", "diffSide": "RIGHT", "path": "hive-metastore/src/main/java/org/apache/iceberg/hive/HiveTableOperations.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxMDoyMjowMFrOH_KYxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMDowMjoyNFrOH_gGgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk5MjUxOQ==", "bodyText": "nit: it seems we use it only in one place. Would it make sense to just call throw new there?", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r535992519", "createdAt": "2020-12-04T10:22:00Z", "author": {"login": "aokolnychyi"}, "path": "hive-metastore/src/main/java/org/apache/iceberg/hive/HiveTableOperations.java", "diffHunk": "@@ -70,21 +72,38 @@\n public class HiveTableOperations extends BaseMetastoreTableOperations {\n   private static final Logger LOG = LoggerFactory.getLogger(HiveTableOperations.class);\n \n-  private static final String HIVE_ACQUIRE_LOCK_STATE_TIMEOUT_MS = \"iceberg.hive.lock-timeout-ms\";\n-  private static final long HIVE_ACQUIRE_LOCK_STATE_TIMEOUT_MS_DEFAULT = 3 * 60 * 1000; // 3 minutes\n+  private static final String HIVE_ACQUIRE_LOCK_TIMEOUT_MS = \"iceberg.hive.lock-timeout-ms\";\n+  private static final String HIVE_LOCK_CHECK_MIN_WAIT_MS = \"iceberg.hive.lock-check-min-wait-ms\";\n+  private static final String HIVE_LOCK_CHECK_MAX_WAIT_MS = \"iceberg.hive.lock-check-max-wait-ms\";\n+  private static final String HIVE_LOCK_CHECK_BACKOFF_SCALE_FACTOR = \"iceberg.hive.lock-check-backoff-scale-factor\";\n+  private static final long HIVE_ACQUIRE_LOCK_TIMEOUT_MS_DEFAULT = 3 * 60 * 1000; // 3 minutes\n+  private static final long HIVE_LOCK_CHECK_MIN_WAIT_MS_DEFAULT = 50; // 50 milliseconds\n+  private static final long HIVE_LOCK_CHECK_MAX_WAIT_MS_DEFAULT = 5 * 1000; // 5 seconds\n+  private static final double HIVE_LOCK_CHECK_BACKOFF_SCALE_FACTOR_DEFAULT = 1.5;\n   private static final DynMethods.UnboundMethod ALTER_TABLE = DynMethods.builder(\"alter_table\")\n       .impl(HiveMetaStoreClient.class, \"alter_table_with_environmentContext\",\n           String.class, String.class, Table.class, EnvironmentContext.class)\n       .impl(HiveMetaStoreClient.class, \"alter_table\",\n           String.class, String.class, Table.class, EnvironmentContext.class)\n       .build();\n \n+  protected static class WaitingForLockException extends RuntimeException {\n+    public WaitingForLockException(String message) {\n+      super(message);\n+    }\n+  }\n+\n+  private static final WaitingForLockException WAITING_FOR_LOCK_EXCEPTION =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b201863396dd365ec64d33a43aefa776e23c1cde"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjI1MjAyNQ==", "bodyText": "I agree. What is the purpose of having a single instance of an exception? Wouldn't that lead to deceptive stack traces?", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r536252025", "createdAt": "2020-12-04T17:17:21Z", "author": {"login": "rdblue"}, "path": "hive-metastore/src/main/java/org/apache/iceberg/hive/HiveTableOperations.java", "diffHunk": "@@ -70,21 +72,38 @@\n public class HiveTableOperations extends BaseMetastoreTableOperations {\n   private static final Logger LOG = LoggerFactory.getLogger(HiveTableOperations.class);\n \n-  private static final String HIVE_ACQUIRE_LOCK_STATE_TIMEOUT_MS = \"iceberg.hive.lock-timeout-ms\";\n-  private static final long HIVE_ACQUIRE_LOCK_STATE_TIMEOUT_MS_DEFAULT = 3 * 60 * 1000; // 3 minutes\n+  private static final String HIVE_ACQUIRE_LOCK_TIMEOUT_MS = \"iceberg.hive.lock-timeout-ms\";\n+  private static final String HIVE_LOCK_CHECK_MIN_WAIT_MS = \"iceberg.hive.lock-check-min-wait-ms\";\n+  private static final String HIVE_LOCK_CHECK_MAX_WAIT_MS = \"iceberg.hive.lock-check-max-wait-ms\";\n+  private static final String HIVE_LOCK_CHECK_BACKOFF_SCALE_FACTOR = \"iceberg.hive.lock-check-backoff-scale-factor\";\n+  private static final long HIVE_ACQUIRE_LOCK_TIMEOUT_MS_DEFAULT = 3 * 60 * 1000; // 3 minutes\n+  private static final long HIVE_LOCK_CHECK_MIN_WAIT_MS_DEFAULT = 50; // 50 milliseconds\n+  private static final long HIVE_LOCK_CHECK_MAX_WAIT_MS_DEFAULT = 5 * 1000; // 5 seconds\n+  private static final double HIVE_LOCK_CHECK_BACKOFF_SCALE_FACTOR_DEFAULT = 1.5;\n   private static final DynMethods.UnboundMethod ALTER_TABLE = DynMethods.builder(\"alter_table\")\n       .impl(HiveMetaStoreClient.class, \"alter_table_with_environmentContext\",\n           String.class, String.class, Table.class, EnvironmentContext.class)\n       .impl(HiveMetaStoreClient.class, \"alter_table\",\n           String.class, String.class, Table.class, EnvironmentContext.class)\n       .build();\n \n+  protected static class WaitingForLockException extends RuntimeException {\n+    public WaitingForLockException(String message) {\n+      super(message);\n+    }\n+  }\n+\n+  private static final WaitingForLockException WAITING_FOR_LOCK_EXCEPTION =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk5MjUxOQ=="}, "originalCommit": {"oid": "b201863396dd365ec64d33a43aefa776e23c1cde"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM0ODI5MA==", "bodyText": "It's not needed to be a single instance and holding a different stack trace than where it originated. I'll fix this.", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r536348290", "createdAt": "2020-12-04T20:02:24Z", "author": {"login": "raptond"}, "path": "hive-metastore/src/main/java/org/apache/iceberg/hive/HiveTableOperations.java", "diffHunk": "@@ -70,21 +72,38 @@\n public class HiveTableOperations extends BaseMetastoreTableOperations {\n   private static final Logger LOG = LoggerFactory.getLogger(HiveTableOperations.class);\n \n-  private static final String HIVE_ACQUIRE_LOCK_STATE_TIMEOUT_MS = \"iceberg.hive.lock-timeout-ms\";\n-  private static final long HIVE_ACQUIRE_LOCK_STATE_TIMEOUT_MS_DEFAULT = 3 * 60 * 1000; // 3 minutes\n+  private static final String HIVE_ACQUIRE_LOCK_TIMEOUT_MS = \"iceberg.hive.lock-timeout-ms\";\n+  private static final String HIVE_LOCK_CHECK_MIN_WAIT_MS = \"iceberg.hive.lock-check-min-wait-ms\";\n+  private static final String HIVE_LOCK_CHECK_MAX_WAIT_MS = \"iceberg.hive.lock-check-max-wait-ms\";\n+  private static final String HIVE_LOCK_CHECK_BACKOFF_SCALE_FACTOR = \"iceberg.hive.lock-check-backoff-scale-factor\";\n+  private static final long HIVE_ACQUIRE_LOCK_TIMEOUT_MS_DEFAULT = 3 * 60 * 1000; // 3 minutes\n+  private static final long HIVE_LOCK_CHECK_MIN_WAIT_MS_DEFAULT = 50; // 50 milliseconds\n+  private static final long HIVE_LOCK_CHECK_MAX_WAIT_MS_DEFAULT = 5 * 1000; // 5 seconds\n+  private static final double HIVE_LOCK_CHECK_BACKOFF_SCALE_FACTOR_DEFAULT = 1.5;\n   private static final DynMethods.UnboundMethod ALTER_TABLE = DynMethods.builder(\"alter_table\")\n       .impl(HiveMetaStoreClient.class, \"alter_table_with_environmentContext\",\n           String.class, String.class, Table.class, EnvironmentContext.class)\n       .impl(HiveMetaStoreClient.class, \"alter_table\",\n           String.class, String.class, Table.class, EnvironmentContext.class)\n       .build();\n \n+  protected static class WaitingForLockException extends RuntimeException {\n+    public WaitingForLockException(String message) {\n+      super(message);\n+    }\n+  }\n+\n+  private static final WaitingForLockException WAITING_FOR_LOCK_EXCEPTION =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk5MjUxOQ=="}, "originalCommit": {"oid": "b201863396dd365ec64d33a43aefa776e23c1cde"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2MzExMjk3OnYy", "diffSide": "RIGHT", "path": "hive-metastore/src/main/java/org/apache/iceberg/hive/HiveTableOperations.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxMDoyNDowOFrOH_Kd1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMDowMjo0MlrOH_gHLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk5MzgxNQ==", "bodyText": "Why protected?", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r535993815", "createdAt": "2020-12-04T10:24:08Z", "author": {"login": "aokolnychyi"}, "path": "hive-metastore/src/main/java/org/apache/iceberg/hive/HiveTableOperations.java", "diffHunk": "@@ -70,21 +72,38 @@\n public class HiveTableOperations extends BaseMetastoreTableOperations {\n   private static final Logger LOG = LoggerFactory.getLogger(HiveTableOperations.class);\n \n-  private static final String HIVE_ACQUIRE_LOCK_STATE_TIMEOUT_MS = \"iceberg.hive.lock-timeout-ms\";\n-  private static final long HIVE_ACQUIRE_LOCK_STATE_TIMEOUT_MS_DEFAULT = 3 * 60 * 1000; // 3 minutes\n+  private static final String HIVE_ACQUIRE_LOCK_TIMEOUT_MS = \"iceberg.hive.lock-timeout-ms\";\n+  private static final String HIVE_LOCK_CHECK_MIN_WAIT_MS = \"iceberg.hive.lock-check-min-wait-ms\";\n+  private static final String HIVE_LOCK_CHECK_MAX_WAIT_MS = \"iceberg.hive.lock-check-max-wait-ms\";\n+  private static final String HIVE_LOCK_CHECK_BACKOFF_SCALE_FACTOR = \"iceberg.hive.lock-check-backoff-scale-factor\";\n+  private static final long HIVE_ACQUIRE_LOCK_TIMEOUT_MS_DEFAULT = 3 * 60 * 1000; // 3 minutes\n+  private static final long HIVE_LOCK_CHECK_MIN_WAIT_MS_DEFAULT = 50; // 50 milliseconds\n+  private static final long HIVE_LOCK_CHECK_MAX_WAIT_MS_DEFAULT = 5 * 1000; // 5 seconds\n+  private static final double HIVE_LOCK_CHECK_BACKOFF_SCALE_FACTOR_DEFAULT = 1.5;\n   private static final DynMethods.UnboundMethod ALTER_TABLE = DynMethods.builder(\"alter_table\")\n       .impl(HiveMetaStoreClient.class, \"alter_table_with_environmentContext\",\n           String.class, String.class, Table.class, EnvironmentContext.class)\n       .impl(HiveMetaStoreClient.class, \"alter_table\",\n           String.class, String.class, Table.class, EnvironmentContext.class)\n       .build();\n \n+  protected static class WaitingForLockException extends RuntimeException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b201863396dd365ec64d33a43aefa776e23c1cde"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjI1NTc1Ng==", "bodyText": "I agree. If this is always caught, it should be private.", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r536255756", "createdAt": "2020-12-04T17:23:39Z", "author": {"login": "rdblue"}, "path": "hive-metastore/src/main/java/org/apache/iceberg/hive/HiveTableOperations.java", "diffHunk": "@@ -70,21 +72,38 @@\n public class HiveTableOperations extends BaseMetastoreTableOperations {\n   private static final Logger LOG = LoggerFactory.getLogger(HiveTableOperations.class);\n \n-  private static final String HIVE_ACQUIRE_LOCK_STATE_TIMEOUT_MS = \"iceberg.hive.lock-timeout-ms\";\n-  private static final long HIVE_ACQUIRE_LOCK_STATE_TIMEOUT_MS_DEFAULT = 3 * 60 * 1000; // 3 minutes\n+  private static final String HIVE_ACQUIRE_LOCK_TIMEOUT_MS = \"iceberg.hive.lock-timeout-ms\";\n+  private static final String HIVE_LOCK_CHECK_MIN_WAIT_MS = \"iceberg.hive.lock-check-min-wait-ms\";\n+  private static final String HIVE_LOCK_CHECK_MAX_WAIT_MS = \"iceberg.hive.lock-check-max-wait-ms\";\n+  private static final String HIVE_LOCK_CHECK_BACKOFF_SCALE_FACTOR = \"iceberg.hive.lock-check-backoff-scale-factor\";\n+  private static final long HIVE_ACQUIRE_LOCK_TIMEOUT_MS_DEFAULT = 3 * 60 * 1000; // 3 minutes\n+  private static final long HIVE_LOCK_CHECK_MIN_WAIT_MS_DEFAULT = 50; // 50 milliseconds\n+  private static final long HIVE_LOCK_CHECK_MAX_WAIT_MS_DEFAULT = 5 * 1000; // 5 seconds\n+  private static final double HIVE_LOCK_CHECK_BACKOFF_SCALE_FACTOR_DEFAULT = 1.5;\n   private static final DynMethods.UnboundMethod ALTER_TABLE = DynMethods.builder(\"alter_table\")\n       .impl(HiveMetaStoreClient.class, \"alter_table_with_environmentContext\",\n           String.class, String.class, Table.class, EnvironmentContext.class)\n       .impl(HiveMetaStoreClient.class, \"alter_table\",\n           String.class, String.class, Table.class, EnvironmentContext.class)\n       .build();\n \n+  protected static class WaitingForLockException extends RuntimeException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk5MzgxNQ=="}, "originalCommit": {"oid": "b201863396dd365ec64d33a43aefa776e23c1cde"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM0ODQ2Mg==", "bodyText": "It's a miss from using in a testing. Fixing it.", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r536348462", "createdAt": "2020-12-04T20:02:42Z", "author": {"login": "raptond"}, "path": "hive-metastore/src/main/java/org/apache/iceberg/hive/HiveTableOperations.java", "diffHunk": "@@ -70,21 +72,38 @@\n public class HiveTableOperations extends BaseMetastoreTableOperations {\n   private static final Logger LOG = LoggerFactory.getLogger(HiveTableOperations.class);\n \n-  private static final String HIVE_ACQUIRE_LOCK_STATE_TIMEOUT_MS = \"iceberg.hive.lock-timeout-ms\";\n-  private static final long HIVE_ACQUIRE_LOCK_STATE_TIMEOUT_MS_DEFAULT = 3 * 60 * 1000; // 3 minutes\n+  private static final String HIVE_ACQUIRE_LOCK_TIMEOUT_MS = \"iceberg.hive.lock-timeout-ms\";\n+  private static final String HIVE_LOCK_CHECK_MIN_WAIT_MS = \"iceberg.hive.lock-check-min-wait-ms\";\n+  private static final String HIVE_LOCK_CHECK_MAX_WAIT_MS = \"iceberg.hive.lock-check-max-wait-ms\";\n+  private static final String HIVE_LOCK_CHECK_BACKOFF_SCALE_FACTOR = \"iceberg.hive.lock-check-backoff-scale-factor\";\n+  private static final long HIVE_ACQUIRE_LOCK_TIMEOUT_MS_DEFAULT = 3 * 60 * 1000; // 3 minutes\n+  private static final long HIVE_LOCK_CHECK_MIN_WAIT_MS_DEFAULT = 50; // 50 milliseconds\n+  private static final long HIVE_LOCK_CHECK_MAX_WAIT_MS_DEFAULT = 5 * 1000; // 5 seconds\n+  private static final double HIVE_LOCK_CHECK_BACKOFF_SCALE_FACTOR_DEFAULT = 1.5;\n   private static final DynMethods.UnboundMethod ALTER_TABLE = DynMethods.builder(\"alter_table\")\n       .impl(HiveMetaStoreClient.class, \"alter_table_with_environmentContext\",\n           String.class, String.class, Table.class, EnvironmentContext.class)\n       .impl(HiveMetaStoreClient.class, \"alter_table\",\n           String.class, String.class, Table.class, EnvironmentContext.class)\n       .build();\n \n+  protected static class WaitingForLockException extends RuntimeException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk5MzgxNQ=="}, "originalCommit": {"oid": "b201863396dd365ec64d33a43aefa776e23c1cde"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NDI3NzM4OnYy", "diffSide": "RIGHT", "path": "hive-metastore/src/main/java/org/apache/iceberg/hive/HiveTableOperations.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNTowNzoyNlrOH_U8BA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwNzo0MjozM1rOICGk8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE2NTM4MA==", "bodyText": "Why - 100?", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r536165380", "createdAt": "2020-12-04T15:07:26Z", "author": {"login": "RussellSpitzer"}, "path": "hive-metastore/src/main/java/org/apache/iceberg/hive/HiveTableOperations.java", "diffHunk": "@@ -304,32 +330,57 @@ private long acquireLock() throws UnknownHostException, TException, InterruptedE\n         System.getProperty(\"user.name\"),\n         InetAddress.getLocalHost().getHostName());\n     LockResponse lockResponse = metaClients.run(client -> client.lock(lockRequest));\n-    LockState state = lockResponse.getState();\n+    AtomicReference<LockState> state = new AtomicReference<>(lockResponse.getState());\n     long lockId = lockResponse.getLockid();\n \n     final long start = System.currentTimeMillis();\n     long duration = 0;\n     boolean timeout = false;\n-    while (!timeout && state.equals(LockState.WAITING)) {\n-      lockResponse = metaClients.run(client -> client.checkLock(lockId));\n-      state = lockResponse.getState();\n \n-      // check timeout\n-      duration = System.currentTimeMillis() - start;\n-      if (duration > lockAcquireTimeout) {\n+    if (state.get().equals(LockState.WAITING)) {\n+      try {\n+        Tasks.foreach(lockId)\n+            .retry(Integer.MAX_VALUE - 100) // Endless retries bound by timeouts. Tasks.retry adds 1 for \"first try\".", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b201863396dd365ec64d33a43aefa776e23c1cde"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3MjI2Ng==", "bodyText": "I only wanted to keep a big number for retry.  Eg Integer.MAX_VALUE. But, the setter adds 1 overflowing to MIN_VALUE.\nInteger.MAX_VALUE - 1 would simply suffice, but I chose conservatively to set Integer.MAX_VALUE - 100.", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r538772266", "createdAt": "2020-12-08T20:10:23Z", "author": {"login": "raptond"}, "path": "hive-metastore/src/main/java/org/apache/iceberg/hive/HiveTableOperations.java", "diffHunk": "@@ -304,32 +330,57 @@ private long acquireLock() throws UnknownHostException, TException, InterruptedE\n         System.getProperty(\"user.name\"),\n         InetAddress.getLocalHost().getHostName());\n     LockResponse lockResponse = metaClients.run(client -> client.lock(lockRequest));\n-    LockState state = lockResponse.getState();\n+    AtomicReference<LockState> state = new AtomicReference<>(lockResponse.getState());\n     long lockId = lockResponse.getLockid();\n \n     final long start = System.currentTimeMillis();\n     long duration = 0;\n     boolean timeout = false;\n-    while (!timeout && state.equals(LockState.WAITING)) {\n-      lockResponse = metaClients.run(client -> client.checkLock(lockId));\n-      state = lockResponse.getState();\n \n-      // check timeout\n-      duration = System.currentTimeMillis() - start;\n-      if (duration > lockAcquireTimeout) {\n+    if (state.get().equals(LockState.WAITING)) {\n+      try {\n+        Tasks.foreach(lockId)\n+            .retry(Integer.MAX_VALUE - 100) // Endless retries bound by timeouts. Tasks.retry adds 1 for \"first try\".", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE2NTM4MA=="}, "originalCommit": {"oid": "b201863396dd365ec64d33a43aefa776e23c1cde"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg1MTg5OQ==", "bodyText": "I think it would be worth noting the rational for a choice like this in a comment.", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r538851899", "createdAt": "2020-12-08T22:21:36Z", "author": {"login": "rdblue"}, "path": "hive-metastore/src/main/java/org/apache/iceberg/hive/HiveTableOperations.java", "diffHunk": "@@ -304,32 +330,57 @@ private long acquireLock() throws UnknownHostException, TException, InterruptedE\n         System.getProperty(\"user.name\"),\n         InetAddress.getLocalHost().getHostName());\n     LockResponse lockResponse = metaClients.run(client -> client.lock(lockRequest));\n-    LockState state = lockResponse.getState();\n+    AtomicReference<LockState> state = new AtomicReference<>(lockResponse.getState());\n     long lockId = lockResponse.getLockid();\n \n     final long start = System.currentTimeMillis();\n     long duration = 0;\n     boolean timeout = false;\n-    while (!timeout && state.equals(LockState.WAITING)) {\n-      lockResponse = metaClients.run(client -> client.checkLock(lockId));\n-      state = lockResponse.getState();\n \n-      // check timeout\n-      duration = System.currentTimeMillis() - start;\n-      if (duration > lockAcquireTimeout) {\n+    if (state.get().equals(LockState.WAITING)) {\n+      try {\n+        Tasks.foreach(lockId)\n+            .retry(Integer.MAX_VALUE - 100) // Endless retries bound by timeouts. Tasks.retry adds 1 for \"first try\".", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE2NTM4MA=="}, "originalCommit": {"oid": "b201863396dd365ec64d33a43aefa776e23c1cde"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA3NTgyNg==", "bodyText": "\ud83d\udc4d +1 I have added the rationale in the comments.", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r539075826", "createdAt": "2020-12-09T07:42:33Z", "author": {"login": "raptond"}, "path": "hive-metastore/src/main/java/org/apache/iceberg/hive/HiveTableOperations.java", "diffHunk": "@@ -304,32 +330,57 @@ private long acquireLock() throws UnknownHostException, TException, InterruptedE\n         System.getProperty(\"user.name\"),\n         InetAddress.getLocalHost().getHostName());\n     LockResponse lockResponse = metaClients.run(client -> client.lock(lockRequest));\n-    LockState state = lockResponse.getState();\n+    AtomicReference<LockState> state = new AtomicReference<>(lockResponse.getState());\n     long lockId = lockResponse.getLockid();\n \n     final long start = System.currentTimeMillis();\n     long duration = 0;\n     boolean timeout = false;\n-    while (!timeout && state.equals(LockState.WAITING)) {\n-      lockResponse = metaClients.run(client -> client.checkLock(lockId));\n-      state = lockResponse.getState();\n \n-      // check timeout\n-      duration = System.currentTimeMillis() - start;\n-      if (duration > lockAcquireTimeout) {\n+    if (state.get().equals(LockState.WAITING)) {\n+      try {\n+        Tasks.foreach(lockId)\n+            .retry(Integer.MAX_VALUE - 100) // Endless retries bound by timeouts. Tasks.retry adds 1 for \"first try\".", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE2NTM4MA=="}, "originalCommit": {"oid": "b201863396dd365ec64d33a43aefa776e23c1cde"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NDI5NjI1OnYy", "diffSide": "RIGHT", "path": "hive-metastore/src/test/java/org/apache/iceberg/hive/TestHiveCommitLocks.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNToxMTo0MlrOH_VHsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwNzozNDoxMFrOICGT5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE2ODM3MQ==", "bodyText": "Is InterruptedException needed?", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r536168371", "createdAt": "2020-12-04T15:11:42Z", "author": {"login": "aokolnychyi"}, "path": "hive-metastore/src/test/java/org/apache/iceberg/hive/TestHiveCommitLocks.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.hive;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hive.metastore.HiveMetaStoreClient;\n+import org.apache.hadoop.hive.metastore.api.LockResponse;\n+import org.apache.hadoop.hive.metastore.api.LockState;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.HasTableOperations;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.exceptions.CommitFailedException;\n+import org.apache.iceberg.types.Types;\n+import org.apache.thrift.TException;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.eq;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.when;\n+\n+public class TestHiveCommitLocks extends HiveTableBaseTest {\n+  HiveTableOperations ops = null;\n+  HiveTableOperations spyOps = null;\n+  HiveClientPool spyClientPool = null;\n+  HiveMetaStoreClient spyClient = null;\n+  TableMetadata metadataV1 = null;\n+  TableMetadata metadataV2 = null;\n+\n+  long dummyLockId = 500L;\n+  LockResponse waitLockResponse = new LockResponse(dummyLockId, LockState.WAITING);\n+  LockResponse acquiredLockResponse = new LockResponse(dummyLockId, LockState.ACQUIRED);\n+  LockResponse notAcquiredLockResponse = new LockResponse(dummyLockId, LockState.NOT_ACQUIRED);\n+\n+  @Before\n+  public void before() throws Exception {\n+    Table table = catalog.loadTable(TABLE_IDENTIFIER);\n+    ops = (HiveTableOperations) ((HasTableOperations) table).operations();\n+    String dbName = TABLE_IDENTIFIER.namespace().level(0);\n+    String tableName = TABLE_IDENTIFIER.name();\n+    Configuration overriddenHiveConf = new Configuration(hiveConf);\n+    overriddenHiveConf.setLong(\"iceberg.hive.lock-timeout-ms\", 10 * 1000);\n+    overriddenHiveConf.setLong(\"iceberg.hive.lock-check-min-wait-ms\", 50);\n+    overriddenHiveConf.setLong(\"iceberg.hive.lock-check-max-wait-ms\", 5 * 1000);\n+    overriddenHiveConf.setDouble(\"iceberg.hive.lock-check-backoff-scale-factor\", 3.0);\n+\n+    metadataV1 = ops.current();\n+\n+    table.updateSchema()\n+        .addColumn(\"n\", Types.IntegerType.get())\n+        .commit();\n+\n+    ops.refresh();\n+\n+    metadataV2 = ops.current();\n+\n+    Assert.assertEquals(2, ops.current().schema().columns().size());\n+\n+    spyClientPool = spy(new HiveClientPool(1, overriddenHiveConf));\n+    AtomicReference<HiveMetaStoreClient> spyClientRef = new AtomicReference<>();\n+\n+    when(spyClientPool.newClient()).thenAnswer(invocation -> {\n+      HiveMetaStoreClient client = (HiveMetaStoreClient) invocation.callRealMethod();\n+      spyClientRef.set(spy(client));\n+      return spyClientRef.get();\n+    });\n+\n+    spyOps = spy(new HiveTableOperations(overriddenHiveConf, spyClientPool, ops.io(), catalog.name(),\n+        dbName, tableName));\n+    spyClientPool.run(client -> client.isLocalMetaStore()); // To ensure new client is created.\n+    Assert.assertNotNull(spyClientRef.get());\n+\n+    spyClient = spyClientRef.get();\n+  }\n+\n+  @After\n+  public void cleanup() {\n+    try {\n+      spyClientPool.close();\n+    } catch (Throwable t) {\n+      // Ignore any exception\n+    }\n+  }\n+\n+  @Test\n+  public void testLockAcquisitionAtFirstTime() throws TException, InterruptedException {\n+    doReturn(acquiredLockResponse).when(spyClient).lock(any());\n+    doNothing().when(spyOps).doUnlock(eq(dummyLockId));\n+\n+    spyOps.doCommit(metadataV2, metadataV1);\n+\n+    Assert.assertEquals(1, spyOps.current().schema().columns().size()); // should be 1 again\n+  }\n+\n+  @Test\n+  public void testLockAcquisitionAfterRetries() throws TException, InterruptedException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b201863396dd365ec64d33a43aefa776e23c1cde"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA3MTQ2Mw==", "bodyText": "yes, here the HiveTableOperations.doUnlock method throws InterruptedException.", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r539071463", "createdAt": "2020-12-09T07:34:10Z", "author": {"login": "raptond"}, "path": "hive-metastore/src/test/java/org/apache/iceberg/hive/TestHiveCommitLocks.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.hive;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hive.metastore.HiveMetaStoreClient;\n+import org.apache.hadoop.hive.metastore.api.LockResponse;\n+import org.apache.hadoop.hive.metastore.api.LockState;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.HasTableOperations;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.exceptions.CommitFailedException;\n+import org.apache.iceberg.types.Types;\n+import org.apache.thrift.TException;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.eq;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.when;\n+\n+public class TestHiveCommitLocks extends HiveTableBaseTest {\n+  HiveTableOperations ops = null;\n+  HiveTableOperations spyOps = null;\n+  HiveClientPool spyClientPool = null;\n+  HiveMetaStoreClient spyClient = null;\n+  TableMetadata metadataV1 = null;\n+  TableMetadata metadataV2 = null;\n+\n+  long dummyLockId = 500L;\n+  LockResponse waitLockResponse = new LockResponse(dummyLockId, LockState.WAITING);\n+  LockResponse acquiredLockResponse = new LockResponse(dummyLockId, LockState.ACQUIRED);\n+  LockResponse notAcquiredLockResponse = new LockResponse(dummyLockId, LockState.NOT_ACQUIRED);\n+\n+  @Before\n+  public void before() throws Exception {\n+    Table table = catalog.loadTable(TABLE_IDENTIFIER);\n+    ops = (HiveTableOperations) ((HasTableOperations) table).operations();\n+    String dbName = TABLE_IDENTIFIER.namespace().level(0);\n+    String tableName = TABLE_IDENTIFIER.name();\n+    Configuration overriddenHiveConf = new Configuration(hiveConf);\n+    overriddenHiveConf.setLong(\"iceberg.hive.lock-timeout-ms\", 10 * 1000);\n+    overriddenHiveConf.setLong(\"iceberg.hive.lock-check-min-wait-ms\", 50);\n+    overriddenHiveConf.setLong(\"iceberg.hive.lock-check-max-wait-ms\", 5 * 1000);\n+    overriddenHiveConf.setDouble(\"iceberg.hive.lock-check-backoff-scale-factor\", 3.0);\n+\n+    metadataV1 = ops.current();\n+\n+    table.updateSchema()\n+        .addColumn(\"n\", Types.IntegerType.get())\n+        .commit();\n+\n+    ops.refresh();\n+\n+    metadataV2 = ops.current();\n+\n+    Assert.assertEquals(2, ops.current().schema().columns().size());\n+\n+    spyClientPool = spy(new HiveClientPool(1, overriddenHiveConf));\n+    AtomicReference<HiveMetaStoreClient> spyClientRef = new AtomicReference<>();\n+\n+    when(spyClientPool.newClient()).thenAnswer(invocation -> {\n+      HiveMetaStoreClient client = (HiveMetaStoreClient) invocation.callRealMethod();\n+      spyClientRef.set(spy(client));\n+      return spyClientRef.get();\n+    });\n+\n+    spyOps = spy(new HiveTableOperations(overriddenHiveConf, spyClientPool, ops.io(), catalog.name(),\n+        dbName, tableName));\n+    spyClientPool.run(client -> client.isLocalMetaStore()); // To ensure new client is created.\n+    Assert.assertNotNull(spyClientRef.get());\n+\n+    spyClient = spyClientRef.get();\n+  }\n+\n+  @After\n+  public void cleanup() {\n+    try {\n+      spyClientPool.close();\n+    } catch (Throwable t) {\n+      // Ignore any exception\n+    }\n+  }\n+\n+  @Test\n+  public void testLockAcquisitionAtFirstTime() throws TException, InterruptedException {\n+    doReturn(acquiredLockResponse).when(spyClient).lock(any());\n+    doNothing().when(spyOps).doUnlock(eq(dummyLockId));\n+\n+    spyOps.doCommit(metadataV2, metadataV1);\n+\n+    Assert.assertEquals(1, spyOps.current().schema().columns().size()); // should be 1 again\n+  }\n+\n+  @Test\n+  public void testLockAcquisitionAfterRetries() throws TException, InterruptedException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE2ODM3MQ=="}, "originalCommit": {"oid": "b201863396dd365ec64d33a43aefa776e23c1cde"}, "originalPosition": 120}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NDMwNzYyOnYy", "diffSide": "RIGHT", "path": "hive-metastore/src/main/java/org/apache/iceberg/hive/HiveTableOperations.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNToxNDowMFrOH_VOLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwNzo0Mjo0OVrOICGlgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE3MDAyOQ==", "bodyText": "nit: extra empty line", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r536170029", "createdAt": "2020-12-04T15:14:00Z", "author": {"login": "aokolnychyi"}, "path": "hive-metastore/src/main/java/org/apache/iceberg/hive/HiveTableOperations.java", "diffHunk": "@@ -96,7 +115,14 @@ protected HiveTableOperations(Configuration conf, HiveClientPool metaClients, Fi\n     this.database = database;\n     this.tableName = table;\n     this.lockAcquireTimeout =\n-        conf.getLong(HIVE_ACQUIRE_LOCK_STATE_TIMEOUT_MS, HIVE_ACQUIRE_LOCK_STATE_TIMEOUT_MS_DEFAULT);\n+        conf.getLong(HIVE_ACQUIRE_LOCK_TIMEOUT_MS, HIVE_ACQUIRE_LOCK_TIMEOUT_MS_DEFAULT);\n+    this.lockCheckMinWaitTime =\n+        conf.getLong(HIVE_LOCK_CHECK_MIN_WAIT_MS, HIVE_LOCK_CHECK_MIN_WAIT_MS_DEFAULT);\n+    this.lockCheckMaxWaitTime =\n+        conf.getLong(HIVE_LOCK_CHECK_MAX_WAIT_MS, HIVE_LOCK_CHECK_MAX_WAIT_MS_DEFAULT);\n+    this.lockCheckBackoffScaleFactor =\n+        conf.getDouble(HIVE_LOCK_CHECK_BACKOFF_SCALE_FACTOR, HIVE_LOCK_CHECK_BACKOFF_SCALE_FACTOR_DEFAULT);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b201863396dd365ec64d33a43aefa776e23c1cde"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA3NTk2OQ==", "bodyText": "taken care.", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r539075969", "createdAt": "2020-12-09T07:42:49Z", "author": {"login": "raptond"}, "path": "hive-metastore/src/main/java/org/apache/iceberg/hive/HiveTableOperations.java", "diffHunk": "@@ -96,7 +115,14 @@ protected HiveTableOperations(Configuration conf, HiveClientPool metaClients, Fi\n     this.database = database;\n     this.tableName = table;\n     this.lockAcquireTimeout =\n-        conf.getLong(HIVE_ACQUIRE_LOCK_STATE_TIMEOUT_MS, HIVE_ACQUIRE_LOCK_STATE_TIMEOUT_MS_DEFAULT);\n+        conf.getLong(HIVE_ACQUIRE_LOCK_TIMEOUT_MS, HIVE_ACQUIRE_LOCK_TIMEOUT_MS_DEFAULT);\n+    this.lockCheckMinWaitTime =\n+        conf.getLong(HIVE_LOCK_CHECK_MIN_WAIT_MS, HIVE_LOCK_CHECK_MIN_WAIT_MS_DEFAULT);\n+    this.lockCheckMaxWaitTime =\n+        conf.getLong(HIVE_LOCK_CHECK_MAX_WAIT_MS, HIVE_LOCK_CHECK_MAX_WAIT_MS_DEFAULT);\n+    this.lockCheckBackoffScaleFactor =\n+        conf.getDouble(HIVE_LOCK_CHECK_BACKOFF_SCALE_FACTOR, HIVE_LOCK_CHECK_BACKOFF_SCALE_FACTOR_DEFAULT);\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE3MDAyOQ=="}, "originalCommit": {"oid": "b201863396dd365ec64d33a43aefa776e23c1cde"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NDg1Mzg0OnYy", "diffSide": "RIGHT", "path": "hive-metastore/src/main/java/org/apache/iceberg/hive/HiveTableOperations.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNzoxOToyNFrOH_aTQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMDoxNTozNFrOH_ggcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjI1MzI1MA==", "bodyText": "We don't expose the scale factor in other places. I think it makes sense to keep it simple and not have one here either.", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r536253250", "createdAt": "2020-12-04T17:19:24Z", "author": {"login": "rdblue"}, "path": "hive-metastore/src/main/java/org/apache/iceberg/hive/HiveTableOperations.java", "diffHunk": "@@ -96,7 +115,14 @@ protected HiveTableOperations(Configuration conf, HiveClientPool metaClients, Fi\n     this.database = database;\n     this.tableName = table;\n     this.lockAcquireTimeout =\n-        conf.getLong(HIVE_ACQUIRE_LOCK_STATE_TIMEOUT_MS, HIVE_ACQUIRE_LOCK_STATE_TIMEOUT_MS_DEFAULT);\n+        conf.getLong(HIVE_ACQUIRE_LOCK_TIMEOUT_MS, HIVE_ACQUIRE_LOCK_TIMEOUT_MS_DEFAULT);\n+    this.lockCheckMinWaitTime =\n+        conf.getLong(HIVE_LOCK_CHECK_MIN_WAIT_MS, HIVE_LOCK_CHECK_MIN_WAIT_MS_DEFAULT);\n+    this.lockCheckMaxWaitTime =\n+        conf.getLong(HIVE_LOCK_CHECK_MAX_WAIT_MS, HIVE_LOCK_CHECK_MAX_WAIT_MS_DEFAULT);\n+    this.lockCheckBackoffScaleFactor =\n+        conf.getDouble(HIVE_LOCK_CHECK_BACKOFF_SCALE_FACTOR, HIVE_LOCK_CHECK_BACKOFF_SCALE_FACTOR_DEFAULT);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b201863396dd365ec64d33a43aefa776e23c1cde"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM1NDkzMA==", "bodyText": "I'll remove the scale factor.", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r536354930", "createdAt": "2020-12-04T20:15:34Z", "author": {"login": "raptond"}, "path": "hive-metastore/src/main/java/org/apache/iceberg/hive/HiveTableOperations.java", "diffHunk": "@@ -96,7 +115,14 @@ protected HiveTableOperations(Configuration conf, HiveClientPool metaClients, Fi\n     this.database = database;\n     this.tableName = table;\n     this.lockAcquireTimeout =\n-        conf.getLong(HIVE_ACQUIRE_LOCK_STATE_TIMEOUT_MS, HIVE_ACQUIRE_LOCK_STATE_TIMEOUT_MS_DEFAULT);\n+        conf.getLong(HIVE_ACQUIRE_LOCK_TIMEOUT_MS, HIVE_ACQUIRE_LOCK_TIMEOUT_MS_DEFAULT);\n+    this.lockCheckMinWaitTime =\n+        conf.getLong(HIVE_LOCK_CHECK_MIN_WAIT_MS, HIVE_LOCK_CHECK_MIN_WAIT_MS_DEFAULT);\n+    this.lockCheckMaxWaitTime =\n+        conf.getLong(HIVE_LOCK_CHECK_MAX_WAIT_MS, HIVE_LOCK_CHECK_MAX_WAIT_MS_DEFAULT);\n+    this.lockCheckBackoffScaleFactor =\n+        conf.getDouble(HIVE_LOCK_CHECK_BACKOFF_SCALE_FACTOR, HIVE_LOCK_CHECK_BACKOFF_SCALE_FACTOR_DEFAULT);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjI1MzI1MA=="}, "originalCommit": {"oid": "b201863396dd365ec64d33a43aefa776e23c1cde"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NDg2NTE2OnYy", "diffSide": "RIGHT", "path": "hive-metastore/src/main/java/org/apache/iceberg/hive/HiveTableOperations.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNzoyMjozMVrOH_aaSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwNzo0NjoyNFrOICGssg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjI1NTA0OQ==", "bodyText": "For InterruptedException, why not throw WaitingForLockException and signal that the thread was interrupted? Then this could use the checked exception call, run(id -> {...}, TException.class) and would not need to wrap the exceptions.", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r536255049", "createdAt": "2020-12-04T17:22:31Z", "author": {"login": "rdblue"}, "path": "hive-metastore/src/main/java/org/apache/iceberg/hive/HiveTableOperations.java", "diffHunk": "@@ -304,32 +330,57 @@ private long acquireLock() throws UnknownHostException, TException, InterruptedE\n         System.getProperty(\"user.name\"),\n         InetAddress.getLocalHost().getHostName());\n     LockResponse lockResponse = metaClients.run(client -> client.lock(lockRequest));\n-    LockState state = lockResponse.getState();\n+    AtomicReference<LockState> state = new AtomicReference<>(lockResponse.getState());\n     long lockId = lockResponse.getLockid();\n \n     final long start = System.currentTimeMillis();\n     long duration = 0;\n     boolean timeout = false;\n-    while (!timeout && state.equals(LockState.WAITING)) {\n-      lockResponse = metaClients.run(client -> client.checkLock(lockId));\n-      state = lockResponse.getState();\n \n-      // check timeout\n-      duration = System.currentTimeMillis() - start;\n-      if (duration > lockAcquireTimeout) {\n+    if (state.get().equals(LockState.WAITING)) {\n+      try {\n+        Tasks.foreach(lockId)\n+            .retry(Integer.MAX_VALUE - 100) // Endless retries bound by timeouts. Tasks.retry adds 1 for \"first try\".\n+            .exponentialBackoff(\n+                lockCheckMinWaitTime,\n+                lockCheckMaxWaitTime,\n+                lockAcquireTimeout,\n+                lockCheckBackoffScaleFactor)\n+            .throwFailureWhenFinished()\n+            .onlyRetryOn(WaitingForLockException.class)\n+            .run(id -> {\n+              try {\n+                LockResponse response = metaClients.run(client -> client.checkLock(id));\n+                LockState newState = response.getState();\n+                state.set(newState);\n+                if (newState.equals(LockState.WAITING)) {\n+                  throw WAITING_FOR_LOCK_EXCEPTION;\n+                }\n+              } catch (InterruptedException | TException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b201863396dd365ec64d33a43aefa776e23c1cde"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc2MjkxMA==", "bodyText": "The code looks better after this comment. However throwing WaitingForLockException ends up losing the source of the original InterruptedException because it would get handled here: https://github.com/apache/iceberg/blob/master/core/src/main/java/org/apache/iceberg/util/Tasks.java#L452\nSo, I chose to throw RuntimeException which will stop the retry and preserve the source stack trace.", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r538762910", "createdAt": "2020-12-08T19:55:04Z", "author": {"login": "raptond"}, "path": "hive-metastore/src/main/java/org/apache/iceberg/hive/HiveTableOperations.java", "diffHunk": "@@ -304,32 +330,57 @@ private long acquireLock() throws UnknownHostException, TException, InterruptedE\n         System.getProperty(\"user.name\"),\n         InetAddress.getLocalHost().getHostName());\n     LockResponse lockResponse = metaClients.run(client -> client.lock(lockRequest));\n-    LockState state = lockResponse.getState();\n+    AtomicReference<LockState> state = new AtomicReference<>(lockResponse.getState());\n     long lockId = lockResponse.getLockid();\n \n     final long start = System.currentTimeMillis();\n     long duration = 0;\n     boolean timeout = false;\n-    while (!timeout && state.equals(LockState.WAITING)) {\n-      lockResponse = metaClients.run(client -> client.checkLock(lockId));\n-      state = lockResponse.getState();\n \n-      // check timeout\n-      duration = System.currentTimeMillis() - start;\n-      if (duration > lockAcquireTimeout) {\n+    if (state.get().equals(LockState.WAITING)) {\n+      try {\n+        Tasks.foreach(lockId)\n+            .retry(Integer.MAX_VALUE - 100) // Endless retries bound by timeouts. Tasks.retry adds 1 for \"first try\".\n+            .exponentialBackoff(\n+                lockCheckMinWaitTime,\n+                lockCheckMaxWaitTime,\n+                lockAcquireTimeout,\n+                lockCheckBackoffScaleFactor)\n+            .throwFailureWhenFinished()\n+            .onlyRetryOn(WaitingForLockException.class)\n+            .run(id -> {\n+              try {\n+                LockResponse response = metaClients.run(client -> client.checkLock(id));\n+                LockState newState = response.getState();\n+                state.set(newState);\n+                if (newState.equals(LockState.WAITING)) {\n+                  throw WAITING_FOR_LOCK_EXCEPTION;\n+                }\n+              } catch (InterruptedException | TException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjI1NTA0OQ=="}, "originalCommit": {"oid": "b201863396dd365ec64d33a43aefa776e23c1cde"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg5NTE4Mw==", "bodyText": "I'd probably opt to suppress the interrupt and let the code carry on after setting that the thread was interrupted. That results in a CommitFailedException. I don't think that preserving the stack of the InterruptedException is really needed, but I'm fin with it this way if you prefer it.", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r538895183", "createdAt": "2020-12-08T23:46:19Z", "author": {"login": "rdblue"}, "path": "hive-metastore/src/main/java/org/apache/iceberg/hive/HiveTableOperations.java", "diffHunk": "@@ -304,32 +330,57 @@ private long acquireLock() throws UnknownHostException, TException, InterruptedE\n         System.getProperty(\"user.name\"),\n         InetAddress.getLocalHost().getHostName());\n     LockResponse lockResponse = metaClients.run(client -> client.lock(lockRequest));\n-    LockState state = lockResponse.getState();\n+    AtomicReference<LockState> state = new AtomicReference<>(lockResponse.getState());\n     long lockId = lockResponse.getLockid();\n \n     final long start = System.currentTimeMillis();\n     long duration = 0;\n     boolean timeout = false;\n-    while (!timeout && state.equals(LockState.WAITING)) {\n-      lockResponse = metaClients.run(client -> client.checkLock(lockId));\n-      state = lockResponse.getState();\n \n-      // check timeout\n-      duration = System.currentTimeMillis() - start;\n-      if (duration > lockAcquireTimeout) {\n+    if (state.get().equals(LockState.WAITING)) {\n+      try {\n+        Tasks.foreach(lockId)\n+            .retry(Integer.MAX_VALUE - 100) // Endless retries bound by timeouts. Tasks.retry adds 1 for \"first try\".\n+            .exponentialBackoff(\n+                lockCheckMinWaitTime,\n+                lockCheckMaxWaitTime,\n+                lockAcquireTimeout,\n+                lockCheckBackoffScaleFactor)\n+            .throwFailureWhenFinished()\n+            .onlyRetryOn(WaitingForLockException.class)\n+            .run(id -> {\n+              try {\n+                LockResponse response = metaClients.run(client -> client.checkLock(id));\n+                LockState newState = response.getState();\n+                state.set(newState);\n+                if (newState.equals(LockState.WAITING)) {\n+                  throw WAITING_FOR_LOCK_EXCEPTION;\n+                }\n+              } catch (InterruptedException | TException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjI1NTA0OQ=="}, "originalCommit": {"oid": "b201863396dd365ec64d33a43aefa776e23c1cde"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA3NzgxMA==", "bodyText": "Taken care as per the other comment.", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r539077810", "createdAt": "2020-12-09T07:46:24Z", "author": {"login": "raptond"}, "path": "hive-metastore/src/main/java/org/apache/iceberg/hive/HiveTableOperations.java", "diffHunk": "@@ -304,32 +330,57 @@ private long acquireLock() throws UnknownHostException, TException, InterruptedE\n         System.getProperty(\"user.name\"),\n         InetAddress.getLocalHost().getHostName());\n     LockResponse lockResponse = metaClients.run(client -> client.lock(lockRequest));\n-    LockState state = lockResponse.getState();\n+    AtomicReference<LockState> state = new AtomicReference<>(lockResponse.getState());\n     long lockId = lockResponse.getLockid();\n \n     final long start = System.currentTimeMillis();\n     long duration = 0;\n     boolean timeout = false;\n-    while (!timeout && state.equals(LockState.WAITING)) {\n-      lockResponse = metaClients.run(client -> client.checkLock(lockId));\n-      state = lockResponse.getState();\n \n-      // check timeout\n-      duration = System.currentTimeMillis() - start;\n-      if (duration > lockAcquireTimeout) {\n+    if (state.get().equals(LockState.WAITING)) {\n+      try {\n+        Tasks.foreach(lockId)\n+            .retry(Integer.MAX_VALUE - 100) // Endless retries bound by timeouts. Tasks.retry adds 1 for \"first try\".\n+            .exponentialBackoff(\n+                lockCheckMinWaitTime,\n+                lockCheckMaxWaitTime,\n+                lockAcquireTimeout,\n+                lockCheckBackoffScaleFactor)\n+            .throwFailureWhenFinished()\n+            .onlyRetryOn(WaitingForLockException.class)\n+            .run(id -> {\n+              try {\n+                LockResponse response = metaClients.run(client -> client.checkLock(id));\n+                LockState newState = response.getState();\n+                state.set(newState);\n+                if (newState.equals(LockState.WAITING)) {\n+                  throw WAITING_FOR_LOCK_EXCEPTION;\n+                }\n+              } catch (InterruptedException | TException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjI1NTA0OQ=="}, "originalCommit": {"oid": "b201863396dd365ec64d33a43aefa776e23c1cde"}, "originalPosition": 110}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MzAwNzI2OnYy", "diffSide": "RIGHT", "path": "hive-metastore/src/main/java/org/apache/iceberg/hive/HiveTableOperations.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQyMjozMTo1MFrOIB5QcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwODo0Nzo1M1rOICJCKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg1NzU4NA==", "bodyText": "Nit: unnecessary whitespace change.", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r538857584", "createdAt": "2020-12-08T22:31:50Z", "author": {"login": "rdblue"}, "path": "hive-metastore/src/main/java/org/apache/iceberg/hive/HiveTableOperations.java", "diffHunk": "@@ -66,33 +68,50 @@\n public class HiveTableOperations extends BaseMetastoreTableOperations {\n   private static final Logger LOG = LoggerFactory.getLogger(HiveTableOperations.class);\n \n-  private static final String HIVE_ACQUIRE_LOCK_STATE_TIMEOUT_MS = \"iceberg.hive.lock-timeout-ms\";\n-  private static final long HIVE_ACQUIRE_LOCK_STATE_TIMEOUT_MS_DEFAULT = 3 * 60 * 1000; // 3 minutes\n+  private static final String HIVE_ACQUIRE_LOCK_TIMEOUT_MS = \"iceberg.hive.lock-timeout-ms\";\n+  private static final String HIVE_LOCK_CHECK_MIN_WAIT_MS = \"iceberg.hive.lock-check-min-wait-ms\";\n+  private static final String HIVE_LOCK_CHECK_MAX_WAIT_MS = \"iceberg.hive.lock-check-max-wait-ms\";\n+  private static final long HIVE_ACQUIRE_LOCK_TIMEOUT_MS_DEFAULT = 3 * 60 * 1000; // 3 minutes\n+  private static final long HIVE_LOCK_CHECK_MIN_WAIT_MS_DEFAULT = 50; // 50 milliseconds\n+  private static final long HIVE_LOCK_CHECK_MAX_WAIT_MS_DEFAULT = 5 * 1000; // 5 seconds\n   private static final DynMethods.UnboundMethod ALTER_TABLE = DynMethods.builder(\"alter_table\")\n       .impl(HiveMetaStoreClient.class, \"alter_table_with_environmentContext\",\n           String.class, String.class, Table.class, EnvironmentContext.class)\n       .impl(HiveMetaStoreClient.class, \"alter_table\",\n           String.class, String.class, Table.class, EnvironmentContext.class)\n       .build();\n \n+  private static class WaitingForLockException extends RuntimeException {\n+    WaitingForLockException(String message) {\n+      super(message);\n+    }\n+  }\n+\n   private final HiveClientPool metaClients;\n   private final String fullName;\n   private final String database;\n   private final String tableName;\n   private final Configuration conf;\n   private final long lockAcquireTimeout;\n+  private final long lockCheckMinWaitTime;\n+  private final long lockCheckMaxWaitTime;\n   private final FileIO fileIO;\n \n   protected HiveTableOperations(Configuration conf, HiveClientPool metaClients, FileIO fileIO,\n-                                String catalogName, String database, String table) {\n+      String catalogName, String database, String table) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4dcc67ead41606389948dab7bf3ff5293981528"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTExNjA3Mw==", "bodyText": "done.", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r539116073", "createdAt": "2020-12-09T08:47:53Z", "author": {"login": "raptond"}, "path": "hive-metastore/src/main/java/org/apache/iceberg/hive/HiveTableOperations.java", "diffHunk": "@@ -66,33 +68,50 @@\n public class HiveTableOperations extends BaseMetastoreTableOperations {\n   private static final Logger LOG = LoggerFactory.getLogger(HiveTableOperations.class);\n \n-  private static final String HIVE_ACQUIRE_LOCK_STATE_TIMEOUT_MS = \"iceberg.hive.lock-timeout-ms\";\n-  private static final long HIVE_ACQUIRE_LOCK_STATE_TIMEOUT_MS_DEFAULT = 3 * 60 * 1000; // 3 minutes\n+  private static final String HIVE_ACQUIRE_LOCK_TIMEOUT_MS = \"iceberg.hive.lock-timeout-ms\";\n+  private static final String HIVE_LOCK_CHECK_MIN_WAIT_MS = \"iceberg.hive.lock-check-min-wait-ms\";\n+  private static final String HIVE_LOCK_CHECK_MAX_WAIT_MS = \"iceberg.hive.lock-check-max-wait-ms\";\n+  private static final long HIVE_ACQUIRE_LOCK_TIMEOUT_MS_DEFAULT = 3 * 60 * 1000; // 3 minutes\n+  private static final long HIVE_LOCK_CHECK_MIN_WAIT_MS_DEFAULT = 50; // 50 milliseconds\n+  private static final long HIVE_LOCK_CHECK_MAX_WAIT_MS_DEFAULT = 5 * 1000; // 5 seconds\n   private static final DynMethods.UnboundMethod ALTER_TABLE = DynMethods.builder(\"alter_table\")\n       .impl(HiveMetaStoreClient.class, \"alter_table_with_environmentContext\",\n           String.class, String.class, Table.class, EnvironmentContext.class)\n       .impl(HiveMetaStoreClient.class, \"alter_table\",\n           String.class, String.class, Table.class, EnvironmentContext.class)\n       .build();\n \n+  private static class WaitingForLockException extends RuntimeException {\n+    WaitingForLockException(String message) {\n+      super(message);\n+    }\n+  }\n+\n   private final HiveClientPool metaClients;\n   private final String fullName;\n   private final String database;\n   private final String tableName;\n   private final Configuration conf;\n   private final long lockAcquireTimeout;\n+  private final long lockCheckMinWaitTime;\n+  private final long lockCheckMaxWaitTime;\n   private final FileIO fileIO;\n \n   protected HiveTableOperations(Configuration conf, HiveClientPool metaClients, FileIO fileIO,\n-                                String catalogName, String database, String table) {\n+      String catalogName, String database, String table) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg1NzU4NA=="}, "originalCommit": {"oid": "b4dcc67ead41606389948dab7bf3ff5293981528"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MzI1NzU4OnYy", "diffSide": "RIGHT", "path": "hive-metastore/src/main/java/org/apache/iceberg/hive/HiveTableOperations.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQyMzo0MzoxMlrOIB7eWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwNzo0NToyOVrOICGq8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg5MzkxNA==", "bodyText": "I don't think it is necessary to throw RuntimeException here. If this doesn't throw WaitingForLockException then it will exit and move on. Since timeout is not set, it would hit the check for whether the lock was acquired and fail, resulting in the CommitFailedException.\nI think that's a fairly reasonable way to handle an interrupt without wrapping it in a RuntimeException.", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r538893914", "createdAt": "2020-12-08T23:43:12Z", "author": {"login": "rdblue"}, "path": "hive-metastore/src/main/java/org/apache/iceberg/hive/HiveTableOperations.java", "diffHunk": "@@ -294,32 +313,50 @@ private long acquireLock() throws UnknownHostException, TException, InterruptedE\n         System.getProperty(\"user.name\"),\n         InetAddress.getLocalHost().getHostName());\n     LockResponse lockResponse = metaClients.run(client -> client.lock(lockRequest));\n-    LockState state = lockResponse.getState();\n+    AtomicReference<LockState> state = new AtomicReference<>(lockResponse.getState());\n     long lockId = lockResponse.getLockid();\n \n     final long start = System.currentTimeMillis();\n     long duration = 0;\n     boolean timeout = false;\n-    while (!timeout && state.equals(LockState.WAITING)) {\n-      lockResponse = metaClients.run(client -> client.checkLock(lockId));\n-      state = lockResponse.getState();\n \n-      // check timeout\n-      duration = System.currentTimeMillis() - start;\n-      if (duration > lockAcquireTimeout) {\n+    if (state.get().equals(LockState.WAITING)) {\n+      try {\n+        Tasks.foreach(lockId)\n+            .retry(Integer.MAX_VALUE - 100) // Endless retries bound by timeouts. Tasks.retry adds 1 for \"first try\".\n+            .exponentialBackoff(\n+                lockCheckMinWaitTime,\n+                lockCheckMaxWaitTime,\n+                lockAcquireTimeout,\n+                1.5)\n+            .throwFailureWhenFinished()\n+            .onlyRetryOn(WaitingForLockException.class)\n+            .run(id -> {\n+              try {\n+                LockResponse response = metaClients.run(client -> client.checkLock(id));\n+                LockState newState = response.getState();\n+                state.set(newState);\n+                if (newState.equals(LockState.WAITING)) {\n+                  throw new WaitingForLockException(\"Waiting for lock.\");\n+                }\n+              } catch (InterruptedException e) {\n+                Thread.currentThread().interrupt();\n+                throw new RuntimeException(\"Interrupted while checking lock status.\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4dcc67ead41606389948dab7bf3ff5293981528"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA3NzM2MA==", "bodyText": "You are correct. I was fixated on failing the execution. This suggestion works nicely and I have a test case for this. Thank you.", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r539077360", "createdAt": "2020-12-09T07:45:29Z", "author": {"login": "raptond"}, "path": "hive-metastore/src/main/java/org/apache/iceberg/hive/HiveTableOperations.java", "diffHunk": "@@ -294,32 +313,50 @@ private long acquireLock() throws UnknownHostException, TException, InterruptedE\n         System.getProperty(\"user.name\"),\n         InetAddress.getLocalHost().getHostName());\n     LockResponse lockResponse = metaClients.run(client -> client.lock(lockRequest));\n-    LockState state = lockResponse.getState();\n+    AtomicReference<LockState> state = new AtomicReference<>(lockResponse.getState());\n     long lockId = lockResponse.getLockid();\n \n     final long start = System.currentTimeMillis();\n     long duration = 0;\n     boolean timeout = false;\n-    while (!timeout && state.equals(LockState.WAITING)) {\n-      lockResponse = metaClients.run(client -> client.checkLock(lockId));\n-      state = lockResponse.getState();\n \n-      // check timeout\n-      duration = System.currentTimeMillis() - start;\n-      if (duration > lockAcquireTimeout) {\n+    if (state.get().equals(LockState.WAITING)) {\n+      try {\n+        Tasks.foreach(lockId)\n+            .retry(Integer.MAX_VALUE - 100) // Endless retries bound by timeouts. Tasks.retry adds 1 for \"first try\".\n+            .exponentialBackoff(\n+                lockCheckMinWaitTime,\n+                lockCheckMaxWaitTime,\n+                lockAcquireTimeout,\n+                1.5)\n+            .throwFailureWhenFinished()\n+            .onlyRetryOn(WaitingForLockException.class)\n+            .run(id -> {\n+              try {\n+                LockResponse response = metaClients.run(client -> client.checkLock(id));\n+                LockState newState = response.getState();\n+                state.set(newState);\n+                if (newState.equals(LockState.WAITING)) {\n+                  throw new WaitingForLockException(\"Waiting for lock.\");\n+                }\n+              } catch (InterruptedException e) {\n+                Thread.currentThread().interrupt();\n+                throw new RuntimeException(\"Interrupted while checking lock status.\", e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg5MzkxNA=="}, "originalCommit": {"oid": "b4dcc67ead41606389948dab7bf3ff5293981528"}, "originalPosition": 110}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3256, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}