{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAyMTE1NDAz", "number": 913, "title": "Add v2 manifests", "bodyText": "This separates the write path for manifests into v1 and v2 using the same approach as #907. It also adds sequence number to the v2 write path.\nThis also adds more checks in v2 writers to validate when sequence numbers are added. When writing ManifestFile to a manifest list, this checks that the snapshot ID of the manifest matches the current write's snapshot ID.", "createdAt": "2020-04-11T00:44:33Z", "url": "https://github.com/apache/iceberg/pull/913", "merged": true, "mergeCommit": {"oid": "fdca3f82cae9dbbe6e2119e61e30a1c9f3c69053"}, "closed": true, "closedAt": "2020-04-20T19:56:40Z", "author": {"login": "rdblue"}, "timelineItems": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcWa3slgBqjMyMjM0NjQ3NjY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcZkeBnAH2gAyNDAyMTE1NDAzOjRiN2M4ZjE5M2UxMzNlNTBkOGYyY2E4NThlNTBiYjU5MzA0MjFhZGI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fb406e9216dfbb77f6e94379caff4bb89416d0d0", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/fb406e9216dfbb77f6e94379caff4bb89416d0d0", "committedDate": "2020-04-11T00:40:25Z", "message": "Add v2 manifest writer and ManifestEntry sequence number."}, "afterCommit": {"oid": "8a544d820f0f00225223339a01603ce62adfafc8", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/8a544d820f0f00225223339a01603ce62adfafc8", "committedDate": "2020-04-11T00:50:33Z", "message": "Add v2 manifest writer and ManifestEntry sequence number."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8a544d820f0f00225223339a01603ce62adfafc8", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/8a544d820f0f00225223339a01603ce62adfafc8", "committedDate": "2020-04-11T00:50:33Z", "message": "Add v2 manifest writer and ManifestEntry sequence number."}, "afterCommit": {"oid": "eaf78717b94097030098c790d7db74f231440408", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/eaf78717b94097030098c790d7db74f231440408", "committedDate": "2020-04-11T16:21:09Z", "message": "Add v2 manifest writer and ManifestEntry sequence number."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxOTM0MTcy", "url": "https://github.com/apache/iceberg/pull/913#pullrequestreview-391934172", "createdAt": "2020-04-13T03:13:59Z", "commit": {"oid": "eaf78717b94097030098c790d7db74f231440408"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QwMzoxMzo1OVrOGEbePw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QwNzoxODo1NFrOGEe5dw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzI5NzU5OQ==", "bodyText": "nit: missing the sequence number here ?", "url": "https://github.com/apache/iceberg/pull/913#discussion_r407297599", "createdAt": "2020-04-13T03:13:59Z", "author": {"login": "openinx"}, "path": "core/src/main/java/org/apache/iceberg/GenericManifestEntry.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import com.google.common.base.MoreObjects;\n+import org.apache.avro.generic.IndexedRecord;\n+import org.apache.avro.specific.SpecificData;\n+import org.apache.iceberg.avro.AvroSchemaUtil;\n+import org.apache.iceberg.types.Types;\n+\n+class GenericManifestEntry implements ManifestEntry, IndexedRecord, SpecificData.SchemaConstructable {\n+  private final org.apache.avro.Schema schema;\n+  private final V1Metadata.IndexedDataFile fileWrapper;\n+  private Status status = Status.EXISTING;\n+  private Long snapshotId = null;\n+  private Long sequenceNumber = null;\n+  private DataFile file = null;\n+\n+  GenericManifestEntry(org.apache.avro.Schema schema) {\n+    this.schema = schema;\n+    this.fileWrapper = null; // do not use the file wrapper to read\n+  }\n+\n+  GenericManifestEntry(Types.StructType partitionType) {\n+    this.schema = AvroSchemaUtil.convert(V1Metadata.entrySchema(partitionType), \"manifest_entry\");\n+    this.fileWrapper = new V1Metadata.IndexedDataFile(schema.getField(\"data_file\").schema());\n+  }\n+\n+  private GenericManifestEntry(GenericManifestEntry toCopy, boolean fullCopy) {\n+    this.schema = toCopy.schema;\n+    this.fileWrapper = new V1Metadata.IndexedDataFile(schema.getField(\"data_file\").schema());\n+    this.status = toCopy.status;\n+    this.snapshotId = toCopy.snapshotId;\n+    if (fullCopy) {\n+      this.file = toCopy.file().copy();\n+    } else {\n+      this.file = toCopy.file().copyWithoutStats();\n+    }\n+  }\n+\n+  ManifestEntry wrapExisting(Long newSnapshotId, Long newSequenceNumber, DataFile newFile) {\n+    this.status = Status.EXISTING;\n+    this.snapshotId = newSnapshotId;\n+    this.sequenceNumber = newSequenceNumber;\n+    this.file = newFile;\n+    return this;\n+  }\n+\n+  ManifestEntry wrapAppend(Long newSnapshotId, DataFile newFile) {\n+    this.status = Status.ADDED;\n+    this.snapshotId = newSnapshotId;\n+    this.sequenceNumber = null;\n+    this.file = newFile;\n+    return this;\n+  }\n+\n+  ManifestEntry wrapDelete(Long newSnapshotId, DataFile newFile) {\n+    this.status = Status.DELETED;\n+    this.snapshotId = newSnapshotId;\n+    this.sequenceNumber = null;\n+    this.file = newFile;\n+    return this;\n+  }\n+\n+  /**\n+   * @return the status of the file, whether EXISTING, ADDED, or DELETED\n+   */\n+  public Status status() {\n+    return status;\n+  }\n+\n+  /**\n+   * @return id of the snapshot in which the file was added to the table\n+   */\n+  public Long snapshotId() {\n+    return snapshotId;\n+  }\n+\n+  @Override\n+  public Long sequenceNumber() {\n+    return sequenceNumber;\n+  }\n+\n+  /**\n+   * @return a file\n+   */\n+  public DataFile file() {\n+    return file;\n+  }\n+\n+  public ManifestEntry copy() {\n+    return new GenericManifestEntry(this, true /* full copy */);\n+  }\n+\n+  public ManifestEntry copyWithoutStats() {\n+    return new GenericManifestEntry(this, false /* drop stats */);\n+  }\n+\n+  @Override\n+  public void setSnapshotId(long newSnapshotId) {\n+    this.snapshotId = newSnapshotId;\n+  }\n+\n+  @Override\n+  public void setSequenceNumber(long newSequenceNumber) {\n+    this.sequenceNumber = newSequenceNumber;\n+  }\n+\n+  @Override\n+  public void put(int i, Object v) {\n+    switch (i) {\n+      case 0:\n+        this.status = Status.values()[(Integer) v];\n+        return;\n+      case 1:\n+        this.snapshotId = (Long) v;\n+        return;\n+      case 2:\n+        this.sequenceNumber = (Long) v;\n+        return;\n+      case 3:\n+        this.file = (DataFile) v;\n+        return;\n+      default:\n+        // ignore the object, it must be from a newer version of the format\n+    }\n+  }\n+\n+  @Override\n+  public Object get(int i) {\n+    switch (i) {\n+      case 0:\n+        return status.id();\n+      case 1:\n+        return snapshotId;\n+      case 2:\n+        return sequenceNumber;\n+      case 3:\n+        if (fileWrapper == null || file instanceof GenericDataFile) {\n+          return file;\n+        } else {\n+          return fileWrapper.wrap(file);\n+        }\n+      default:\n+        throw new UnsupportedOperationException(\"Unknown field ordinal: \" + i);\n+    }\n+  }\n+\n+  @Override\n+  public org.apache.avro.Schema getSchema() {\n+    return schema;\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return MoreObjects.toStringHelper(this)\n+        .add(\"status\", status)\n+        .add(\"snapshot_id\", snapshotId)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eaf78717b94097030098c790d7db74f231440408"}, "originalPosition": 175}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzI5ODE0NQ==", "bodyText": "The append/delete operations won't attach the sequence number to its entries ?", "url": "https://github.com/apache/iceberg/pull/913#discussion_r407298145", "createdAt": "2020-04-13T03:17:29Z", "author": {"login": "openinx"}, "path": "core/src/main/java/org/apache/iceberg/GenericManifestEntry.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import com.google.common.base.MoreObjects;\n+import org.apache.avro.generic.IndexedRecord;\n+import org.apache.avro.specific.SpecificData;\n+import org.apache.iceberg.avro.AvroSchemaUtil;\n+import org.apache.iceberg.types.Types;\n+\n+class GenericManifestEntry implements ManifestEntry, IndexedRecord, SpecificData.SchemaConstructable {\n+  private final org.apache.avro.Schema schema;\n+  private final V1Metadata.IndexedDataFile fileWrapper;\n+  private Status status = Status.EXISTING;\n+  private Long snapshotId = null;\n+  private Long sequenceNumber = null;\n+  private DataFile file = null;\n+\n+  GenericManifestEntry(org.apache.avro.Schema schema) {\n+    this.schema = schema;\n+    this.fileWrapper = null; // do not use the file wrapper to read\n+  }\n+\n+  GenericManifestEntry(Types.StructType partitionType) {\n+    this.schema = AvroSchemaUtil.convert(V1Metadata.entrySchema(partitionType), \"manifest_entry\");\n+    this.fileWrapper = new V1Metadata.IndexedDataFile(schema.getField(\"data_file\").schema());\n+  }\n+\n+  private GenericManifestEntry(GenericManifestEntry toCopy, boolean fullCopy) {\n+    this.schema = toCopy.schema;\n+    this.fileWrapper = new V1Metadata.IndexedDataFile(schema.getField(\"data_file\").schema());\n+    this.status = toCopy.status;\n+    this.snapshotId = toCopy.snapshotId;\n+    if (fullCopy) {\n+      this.file = toCopy.file().copy();\n+    } else {\n+      this.file = toCopy.file().copyWithoutStats();\n+    }\n+  }\n+\n+  ManifestEntry wrapExisting(Long newSnapshotId, Long newSequenceNumber, DataFile newFile) {\n+    this.status = Status.EXISTING;\n+    this.snapshotId = newSnapshotId;\n+    this.sequenceNumber = newSequenceNumber;\n+    this.file = newFile;\n+    return this;\n+  }\n+\n+  ManifestEntry wrapAppend(Long newSnapshotId, DataFile newFile) {\n+    this.status = Status.ADDED;\n+    this.snapshotId = newSnapshotId;\n+    this.sequenceNumber = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eaf78717b94097030098c790d7db74f231440408"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzI5OTExNQ==", "bodyText": "Here we're changing the position of snapshotId/addedFilesCount/ ... etc,   will it break the compatibility ?  I mean the new code couldn't read the old data manifest file ...", "url": "https://github.com/apache/iceberg/pull/913#discussion_r407299115", "createdAt": "2020-04-13T03:23:02Z", "author": {"login": "openinx"}, "path": "core/src/main/java/org/apache/iceberg/GenericManifestFile.java", "diffHunk": "@@ -257,21 +255,25 @@ public Object get(int i) {\n       case 2:\n         return specId;\n       case 3:\n-        return snapshotId;\n+        return sequenceNumber;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eaf78717b94097030098c790d7db74f231440408"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM0ODMxMQ==", "bodyText": "I'm not sure in which case we will encounter the snapshot == null, mind to explain the case ? Thanks.", "url": "https://github.com/apache/iceberg/pull/913#discussion_r407348311", "createdAt": "2020-04-13T07:00:44Z", "author": {"login": "openinx"}, "path": "core/src/main/java/org/apache/iceberg/InheritableMetadataFactory.java", "diffHunk": "@@ -30,22 +31,40 @@ static InheritableMetadata empty() {\n   }\n \n   static InheritableMetadata fromManifest(ManifestFile manifest) {\n-    return new BaseInheritableMetadata(manifest.snapshotId());\n+    if (manifest.snapshotId() != null) {\n+      return new BaseInheritableMetadata(manifest.snapshotId(), manifest.sequenceNumber());\n+    } else {\n+      return NOOP;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eaf78717b94097030098c790d7db74f231440408"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM1MzcxOQ==", "bodyText": "Why need to define this min sequence number ?  for manifest file filtering purpose in read path ?", "url": "https://github.com/apache/iceberg/pull/913#discussion_r407353719", "createdAt": "2020-04-13T07:18:54Z", "author": {"login": "openinx"}, "path": "api/src/main/java/org/apache/iceberg/ManifestFile.java", "diffHunk": "@@ -66,6 +77,16 @@ static Schema schema() {\n    */\n   int partitionSpecId();\n \n+  /**\n+   * @return the sequence number of the commit that added the manifest file\n+   */\n+  long sequenceNumber();\n+\n+  /**\n+   * @return the lowest sequence number of any data file in the manifest\n+   */\n+  long minSequenceNumber();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eaf78717b94097030098c790d7db74f231440408"}, "originalPosition": 61}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyNzE2MTU3", "url": "https://github.com/apache/iceberg/pull/913#pullrequestreview-392716157", "createdAt": "2020-04-14T08:36:17Z", "commit": {"oid": "eaf78717b94097030098c790d7db74f231440408"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwODozNjoxOFrOGFEBcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwOToxNzowOFrOGFFn4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk2MTk3MA==", "bodyText": "I don't see other places call this except a unit test. This may be misused, how about removing it?", "url": "https://github.com/apache/iceberg/pull/913#discussion_r407961970", "createdAt": "2020-04-14T08:36:18Z", "author": {"login": "chenjunjiedada"}, "path": "core/src/main/java/org/apache/iceberg/ManifestLists.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Lists;\n+import java.io.IOException;\n+import java.util.List;\n+import org.apache.iceberg.avro.Avro;\n+import org.apache.iceberg.exceptions.RuntimeIOException;\n+import org.apache.iceberg.io.CloseableIterable;\n+import org.apache.iceberg.io.InputFile;\n+import org.apache.iceberg.io.OutputFile;\n+\n+class ManifestLists {\n+  private ManifestLists() {\n+  }\n+\n+  static List<ManifestFile> read(InputFile manifestList) {\n+    try (CloseableIterable<ManifestFile> files = Avro.read(manifestList)\n+        .rename(\"manifest_file\", GenericManifestFile.class.getName())\n+        .rename(\"partitions\", GenericPartitionFieldSummary.class.getName())\n+        .rename(\"r508\", GenericPartitionFieldSummary.class.getName())\n+        .classLoader(GenericManifestFile.class.getClassLoader())\n+        .project(ManifestFile.schema())\n+        .reuseContainers(false)\n+        .build()) {\n+\n+      return Lists.newLinkedList(files);\n+\n+    } catch (IOException e) {\n+      throw new RuntimeIOException(e, \"Cannot read manifest list file: %s\", manifestList.location());\n+    }\n+  }\n+\n+  static ManifestListWriter write(int formatVersion, OutputFile manifestListFile,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eaf78717b94097030098c790d7db74f231440408"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk2MjI5NQ==", "bodyText": "The document is duplicated with the one in ManifestWriter.write. We can remove this function definition and just call from there.", "url": "https://github.com/apache/iceberg/pull/913#discussion_r407962295", "createdAt": "2020-04-14T08:36:47Z", "author": {"login": "chenjunjiedada"}, "path": "core/src/main/java/org/apache/iceberg/ManifestFiles.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.Map;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.io.InputFile;\n+import org.apache.iceberg.io.OutputFile;\n+\n+public class ManifestFiles {\n+  private ManifestFiles() {\n+  }\n+\n+  /**\n+   * Returns a new {@link ManifestReader} for a {@link ManifestFile}.\n+   * <p>\n+   * <em>Note:</em> Callers should use {@link ManifestFiles#read(ManifestFile, FileIO, Map)} to ensure\n+   * the schema used by filters is the latest table schema. This should be used only when reading\n+   * a manifest without filters.\n+   *\n+   * @param manifest a ManifestFile\n+   * @param io a FileIO\n+   * @return a manifest reader\n+   */\n+  public static ManifestReader read(ManifestFile manifest, FileIO io) {\n+    return read(manifest, io, null);\n+  }\n+\n+  /**\n+   * Returns a new {@link ManifestReader} for a {@link ManifestFile}.\n+   *\n+   * @param manifest a {@link ManifestFile}\n+   * @param io a {@link FileIO}\n+   * @param specsById a Map from spec ID to partition spec\n+   * @return a {@link ManifestReader}\n+   */\n+  public static ManifestReader read(ManifestFile manifest, FileIO io, Map<Integer, PartitionSpec> specsById) {\n+    InputFile file = io.newInputFile(manifest.path());\n+    InheritableMetadata inheritableMetadata = InheritableMetadataFactory.fromManifest(manifest);\n+    return new ManifestReader(file, specsById, inheritableMetadata);\n+  }\n+\n+  /**\n+   * Create a new {@link ManifestWriter}.\n+   * <p>\n+   * Manifests created by this writer have all entry snapshot IDs set to null.\n+   * All entries will inherit the snapshot ID that will be assigned to the manifest on commit.\n+   *\n+   * @param spec {@link PartitionSpec} used to produce {@link DataFile} partition tuples\n+   * @param outputFile the destination file location\n+   * @return a manifest writer\n+   */\n+  public static ManifestWriter write(PartitionSpec spec, OutputFile outputFile) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eaf78717b94097030098c790d7db74f231440408"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk3MzczNQ==", "bodyText": "Does this mean that a manifest file with a new snapshot id must have a sequence number?  Maybe add a more detailed reason in the exception message for this.", "url": "https://github.com/apache/iceberg/pull/913#discussion_r407973735", "createdAt": "2020-04-14T08:54:50Z", "author": {"login": "chenjunjiedada"}, "path": "core/src/main/java/org/apache/iceberg/V2Metadata.java", "diffHunk": "@@ -0,0 +1,321 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.List;\n+import org.apache.avro.generic.IndexedRecord;\n+import org.apache.iceberg.avro.AvroSchemaUtil;\n+import org.apache.iceberg.types.Types;\n+\n+import static org.apache.iceberg.types.Types.NestedField.required;\n+\n+class V2Metadata {\n+  private V2Metadata() {\n+  }\n+\n+  // fields for v2 write schema for required metadata\n+  static final Types.NestedField REQUIRED_SNAPSHOT_ID =\n+      required(503, \"added_snapshot_id\", Types.LongType.get());\n+  static final Types.NestedField REQUIRED_ADDED_FILES_COUNT =\n+      required(504, \"added_data_files_count\", Types.IntegerType.get());\n+  static final Types.NestedField REQUIRED_EXISTING_FILES_COUNT =\n+      required(505, \"existing_data_files_count\", Types.IntegerType.get());\n+  static final Types.NestedField REQUIRED_DELETED_FILES_COUNT =\n+      required(506, \"deleted_data_files_count\", Types.IntegerType.get());\n+  static final Types.NestedField REQUIRED_ADDED_ROWS_COUNT =\n+      required(512, \"added_rows_count\", Types.LongType.get());\n+  static final Types.NestedField REQUIRED_EXISTING_ROWS_COUNT =\n+      required(513, \"existing_rows_count\", Types.LongType.get());\n+  static final Types.NestedField REQUIRED_DELETED_ROWS_COUNT =\n+      required(514, \"deleted_rows_count\", Types.LongType.get());\n+  static final Types.NestedField REQUIRED_SEQUENCE_NUMBER =\n+      required(515, \"sequence_number\", Types.LongType.get());\n+  static final Types.NestedField REQUIRED_MIN_SEQUENCE_NUMBER =\n+      required(516, \"min_sequence_number\", Types.LongType.get());\n+\n+  static final Schema MANIFEST_LIST_SCHEMA = new Schema(\n+      ManifestFile.PATH, ManifestFile.LENGTH, ManifestFile.SPEC_ID,\n+      REQUIRED_SEQUENCE_NUMBER, REQUIRED_MIN_SEQUENCE_NUMBER, REQUIRED_SNAPSHOT_ID,\n+      REQUIRED_ADDED_FILES_COUNT, REQUIRED_EXISTING_FILES_COUNT, REQUIRED_DELETED_FILES_COUNT,\n+      REQUIRED_ADDED_ROWS_COUNT, REQUIRED_EXISTING_ROWS_COUNT, REQUIRED_DELETED_ROWS_COUNT,\n+      ManifestFile.PARTITION_SUMMARIES);\n+\n+\n+  /**\n+   * A wrapper class to write any ManifestFile implementation to Avro using the v2 write schema.\n+   *\n+   * This is used to maintain compatibility with v2 by writing manifest list files with the old schema, instead of\n+   * writing a sequence number into metadata files in v2 tables.\n+   */\n+  static class IndexedManifestFile implements ManifestFile, IndexedRecord {\n+    private static final org.apache.avro.Schema AVRO_SCHEMA =\n+        AvroSchemaUtil.convert(MANIFEST_LIST_SCHEMA, \"manifest_file\");\n+\n+    private final long snapshotId;\n+    private final long sequenceNumber;\n+    private ManifestFile wrapped = null;\n+\n+    IndexedManifestFile(long snapshotId, long sequenceNumber) {\n+      this.snapshotId = snapshotId;\n+      this.sequenceNumber = sequenceNumber;\n+    }\n+\n+    public ManifestFile wrap(ManifestFile file) {\n+      this.wrapped = file;\n+      return this;\n+    }\n+\n+    @Override\n+    public org.apache.avro.Schema getSchema() {\n+      return AVRO_SCHEMA;\n+    }\n+\n+    @Override\n+    public void put(int i, Object v) {\n+      throw new UnsupportedOperationException(\"Cannot read using IndexedManifestFile\");\n+    }\n+\n+    @Override\n+    public Object get(int pos) {\n+      switch (pos) {\n+        case 0:\n+          return wrapped.path();\n+        case 1:\n+          return wrapped.length();\n+        case 2:\n+          return wrapped.partitionSpecId();\n+        case 3:\n+          if (wrapped.sequenceNumber() == ManifestWriter.UNASSIGNED_SEQ) {\n+            Preconditions.checkState(snapshotId == wrapped.snapshotId(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eaf78717b94097030098c790d7db74f231440408"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk4ODE5NQ==", "bodyText": "I think this also needs some detail or document about why it happens.", "url": "https://github.com/apache/iceberg/pull/913#discussion_r407988195", "createdAt": "2020-04-14T09:17:08Z", "author": {"login": "chenjunjiedada"}, "path": "core/src/main/java/org/apache/iceberg/V2Metadata.java", "diffHunk": "@@ -0,0 +1,321 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.List;\n+import org.apache.avro.generic.IndexedRecord;\n+import org.apache.iceberg.avro.AvroSchemaUtil;\n+import org.apache.iceberg.types.Types;\n+\n+import static org.apache.iceberg.types.Types.NestedField.required;\n+\n+class V2Metadata {\n+  private V2Metadata() {\n+  }\n+\n+  // fields for v2 write schema for required metadata\n+  static final Types.NestedField REQUIRED_SNAPSHOT_ID =\n+      required(503, \"added_snapshot_id\", Types.LongType.get());\n+  static final Types.NestedField REQUIRED_ADDED_FILES_COUNT =\n+      required(504, \"added_data_files_count\", Types.IntegerType.get());\n+  static final Types.NestedField REQUIRED_EXISTING_FILES_COUNT =\n+      required(505, \"existing_data_files_count\", Types.IntegerType.get());\n+  static final Types.NestedField REQUIRED_DELETED_FILES_COUNT =\n+      required(506, \"deleted_data_files_count\", Types.IntegerType.get());\n+  static final Types.NestedField REQUIRED_ADDED_ROWS_COUNT =\n+      required(512, \"added_rows_count\", Types.LongType.get());\n+  static final Types.NestedField REQUIRED_EXISTING_ROWS_COUNT =\n+      required(513, \"existing_rows_count\", Types.LongType.get());\n+  static final Types.NestedField REQUIRED_DELETED_ROWS_COUNT =\n+      required(514, \"deleted_rows_count\", Types.LongType.get());\n+  static final Types.NestedField REQUIRED_SEQUENCE_NUMBER =\n+      required(515, \"sequence_number\", Types.LongType.get());\n+  static final Types.NestedField REQUIRED_MIN_SEQUENCE_NUMBER =\n+      required(516, \"min_sequence_number\", Types.LongType.get());\n+\n+  static final Schema MANIFEST_LIST_SCHEMA = new Schema(\n+      ManifestFile.PATH, ManifestFile.LENGTH, ManifestFile.SPEC_ID,\n+      REQUIRED_SEQUENCE_NUMBER, REQUIRED_MIN_SEQUENCE_NUMBER, REQUIRED_SNAPSHOT_ID,\n+      REQUIRED_ADDED_FILES_COUNT, REQUIRED_EXISTING_FILES_COUNT, REQUIRED_DELETED_FILES_COUNT,\n+      REQUIRED_ADDED_ROWS_COUNT, REQUIRED_EXISTING_ROWS_COUNT, REQUIRED_DELETED_ROWS_COUNT,\n+      ManifestFile.PARTITION_SUMMARIES);\n+\n+\n+  /**\n+   * A wrapper class to write any ManifestFile implementation to Avro using the v2 write schema.\n+   *\n+   * This is used to maintain compatibility with v2 by writing manifest list files with the old schema, instead of\n+   * writing a sequence number into metadata files in v2 tables.\n+   */\n+  static class IndexedManifestFile implements ManifestFile, IndexedRecord {\n+    private static final org.apache.avro.Schema AVRO_SCHEMA =\n+        AvroSchemaUtil.convert(MANIFEST_LIST_SCHEMA, \"manifest_file\");\n+\n+    private final long snapshotId;\n+    private final long sequenceNumber;\n+    private ManifestFile wrapped = null;\n+\n+    IndexedManifestFile(long snapshotId, long sequenceNumber) {\n+      this.snapshotId = snapshotId;\n+      this.sequenceNumber = sequenceNumber;\n+    }\n+\n+    public ManifestFile wrap(ManifestFile file) {\n+      this.wrapped = file;\n+      return this;\n+    }\n+\n+    @Override\n+    public org.apache.avro.Schema getSchema() {\n+      return AVRO_SCHEMA;\n+    }\n+\n+    @Override\n+    public void put(int i, Object v) {\n+      throw new UnsupportedOperationException(\"Cannot read using IndexedManifestFile\");\n+    }\n+\n+    @Override\n+    public Object get(int pos) {\n+      switch (pos) {\n+        case 0:\n+          return wrapped.path();\n+        case 1:\n+          return wrapped.length();\n+        case 2:\n+          return wrapped.partitionSpecId();\n+        case 3:\n+          if (wrapped.sequenceNumber() == ManifestWriter.UNASSIGNED_SEQ) {\n+            Preconditions.checkState(snapshotId == wrapped.snapshotId(),\n+                \"Found unassigned sequence number for a manifest from snapshot: %s\", wrapped.snapshotId());\n+            return sequenceNumber;\n+          } else {\n+            return wrapped.sequenceNumber();\n+          }\n+        case 4:\n+          return wrapped.minSequenceNumber();\n+        case 5:\n+          return wrapped.snapshotId();\n+        case 6:\n+          return wrapped.addedFilesCount();\n+        case 7:\n+          return wrapped.existingFilesCount();\n+        case 8:\n+          return wrapped.deletedFilesCount();\n+        case 9:\n+          return wrapped.addedRowsCount();\n+        case 10:\n+          return wrapped.existingRowsCount();\n+        case 11:\n+          return wrapped.deletedRowsCount();\n+        case 12:\n+          return wrapped.partitions();\n+        default:\n+          throw new UnsupportedOperationException(\"Unknown field ordinal: \" + pos);\n+      }\n+    }\n+\n+    @Override\n+    public String path() {\n+      return wrapped.path();\n+    }\n+\n+    @Override\n+    public long length() {\n+      return wrapped.length();\n+    }\n+\n+    @Override\n+    public int partitionSpecId() {\n+      return wrapped.partitionSpecId();\n+    }\n+\n+    @Override\n+    public long sequenceNumber() {\n+      return wrapped.sequenceNumber();\n+    }\n+\n+    @Override\n+    public long minSequenceNumber() {\n+      return wrapped.minSequenceNumber();\n+    }\n+\n+    @Override\n+    public Long snapshotId() {\n+      return wrapped.snapshotId();\n+    }\n+\n+    @Override\n+    public boolean hasAddedFiles() {\n+      return wrapped.hasAddedFiles();\n+    }\n+\n+    @Override\n+    public Integer addedFilesCount() {\n+      return wrapped.addedFilesCount();\n+    }\n+\n+    @Override\n+    public Long addedRowsCount() {\n+      return wrapped.addedRowsCount();\n+    }\n+\n+    @Override\n+    public boolean hasExistingFiles() {\n+      return wrapped.hasExistingFiles();\n+    }\n+\n+    @Override\n+    public Integer existingFilesCount() {\n+      return wrapped.existingFilesCount();\n+    }\n+\n+    @Override\n+    public Long existingRowsCount() {\n+      return wrapped.existingRowsCount();\n+    }\n+\n+    @Override\n+    public boolean hasDeletedFiles() {\n+      return wrapped.hasDeletedFiles();\n+    }\n+\n+    @Override\n+    public Integer deletedFilesCount() {\n+      return wrapped.deletedFilesCount();\n+    }\n+\n+    @Override\n+    public Long deletedRowsCount() {\n+      return wrapped.deletedRowsCount();\n+    }\n+\n+    @Override\n+    public List<PartitionFieldSummary> partitions() {\n+      return wrapped.partitions();\n+    }\n+\n+    @Override\n+    public ManifestFile copy() {\n+      return wrapped.copy();\n+    }\n+  }\n+\n+  static Schema entrySchema(Types.StructType partitionType) {\n+    return wrapFileSchema(DataFile.getType(partitionType));\n+  }\n+\n+  static Schema wrapFileSchema(Types.StructType fileSchema) {\n+    // this is used to build projection schemas\n+    return new Schema(\n+        ManifestEntry.STATUS, ManifestEntry.SNAPSHOT_ID,\n+        required(ManifestEntry.DATA_FILE_ID, \"data_file\", fileSchema));\n+  }\n+\n+  static class IndexedManifestEntry implements ManifestEntry, IndexedRecord {\n+    private final org.apache.avro.Schema avroSchema;\n+    private final long snapshotId;\n+    private final V1Metadata.IndexedDataFile fileWrapper;\n+    private ManifestEntry wrapped = null;\n+\n+    IndexedManifestEntry(long snapshotId, Types.StructType partitionType) {\n+      this.avroSchema = AvroSchemaUtil.convert(entrySchema(partitionType), \"manifest_entry\");\n+      this.snapshotId = snapshotId;\n+      // TODO: when v2 data files differ from v1, this should use a v2 wrapper\n+      this.fileWrapper = new V1Metadata.IndexedDataFile(avroSchema.getField(\"data_file\").schema());\n+    }\n+\n+    public IndexedManifestEntry wrap(ManifestEntry entry) {\n+      this.wrapped = entry;\n+      return this;\n+    }\n+\n+    @Override\n+    public org.apache.avro.Schema getSchema() {\n+      return avroSchema;\n+    }\n+\n+    @Override\n+    public void put(int i, Object v) {\n+      throw new UnsupportedOperationException(\"Cannot read using IndexedManifestEntry\");\n+    }\n+\n+    @Override\n+    public Object get(int i) {\n+      switch (i) {\n+        case 0:\n+          return wrapped.status().id();\n+        case 1:\n+          return wrapped.snapshotId();\n+        case 2:\n+          if (wrapped.sequenceNumber() == null) {\n+            Preconditions.checkState(wrapped.snapshotId() == null || snapshotId == wrapped.snapshotId(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eaf78717b94097030098c790d7db74f231440408"}, "originalPosition": 270}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "eaf78717b94097030098c790d7db74f231440408", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/eaf78717b94097030098c790d7db74f231440408", "committedDate": "2020-04-11T16:21:09Z", "message": "Add v2 manifest writer and ManifestEntry sequence number."}, "afterCommit": {"oid": "9da51d5952873bbe3c5ef115b2fc3f40621c7ebd", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/9da51d5952873bbe3c5ef115b2fc3f40621c7ebd", "committedDate": "2020-04-15T01:38:30Z", "message": "Move copyManifest methods and add format version argument."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1119159033cea2e6e79691a5f1389c327d926e6f", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/1119159033cea2e6e79691a5f1389c327d926e6f", "committedDate": "2020-04-16T22:51:24Z", "message": "Extract ManifestEntry interface and snapshot v1 manifest entries."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ed23f65c7cc4adc582b2712beae71b6144bbfc20", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/ed23f65c7cc4adc582b2712beae71b6144bbfc20", "committedDate": "2020-04-16T22:51:24Z", "message": "Move GenericManifestEntry to a separate file."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2e53e316970e9bb6263e9612d2179e924bed94d5", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/2e53e316970e9bb6263e9612d2179e924bed94d5", "committedDate": "2020-04-16T22:53:28Z", "message": "Add v2 manifest writer and ManifestEntry sequence number."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "da63373bcd06e2693d3c7072ec54e88d291329e2", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/da63373bcd06e2693d3c7072ec54e88d291329e2", "committedDate": "2020-04-16T22:54:01Z", "message": "Add sequence number to GenericManfiestEntry#toString."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "285da49dc096565dff1dfc42d9d80d4d3a0175b6", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/285da49dc096565dff1dfc42d9d80d4d3a0175b6", "committedDate": "2020-04-16T22:54:01Z", "message": "Add more comments to explain sequence numbers in v2 metadata."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "662eb6a48a519b127bc220c363dca5b241e50212", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/662eb6a48a519b127bc220c363dca5b241e50212", "committedDate": "2020-04-16T22:54:01Z", "message": "Fix checkstyle errors."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d4eb3b41cd019303d6ce760f44ae4696c2bea1ef", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/d4eb3b41cd019303d6ce760f44ae4696c2bea1ef", "committedDate": "2020-04-16T22:54:01Z", "message": "Handle missing sequence numbers when calculating min."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3120b09ac79d5a9ea977833f137c62bff82ae25c", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/3120b09ac79d5a9ea977833f137c62bff82ae25c", "committedDate": "2020-04-15T19:38:39Z", "message": "Handle missing sequence numbers when calculating min."}, "afterCommit": {"oid": "d4eb3b41cd019303d6ce760f44ae4696c2bea1ef", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/d4eb3b41cd019303d6ce760f44ae4696c2bea1ef", "committedDate": "2020-04-16T22:54:01Z", "message": "Handle missing sequence numbers when calculating min."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "53e311974102d5e1534534751698e225a8e412d9", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/53e311974102d5e1534534751698e225a8e412d9", "committedDate": "2020-04-16T23:17:01Z", "message": "Add more comments, fill in min seq number, and other minor fixes."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a690e980da8b535c880293ca71419cdc11d3b363", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/a690e980da8b535c880293ca71419cdc11d3b363", "committedDate": "2020-04-17T01:15:08Z", "message": "Add a rewrite test."}, "afterCommit": {"oid": "86cf1b80e33e30fff6795f12f73443439956dd64", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/86cf1b80e33e30fff6795f12f73443439956dd64", "committedDate": "2020-04-17T01:15:31Z", "message": "Add v1 and v2 format test for manifest files."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "86cf1b80e33e30fff6795f12f73443439956dd64", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/86cf1b80e33e30fff6795f12f73443439956dd64", "committedDate": "2020-04-17T01:15:31Z", "message": "Add v1 and v2 format test for manifest files."}, "afterCommit": {"oid": "5377393c197c4be30515dc8cd6738bceac131d65", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/5377393c197c4be30515dc8cd6738bceac131d65", "committedDate": "2020-04-17T01:16:30Z", "message": "Add v1 and v2 format test for manifest files."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b61fb6a70f8d3dbdf7b15ccea96f759850f36df9", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/b61fb6a70f8d3dbdf7b15ccea96f759850f36df9", "committedDate": "2020-04-17T01:20:11Z", "message": "Add v1 and v2 format test for manifest files."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5377393c197c4be30515dc8cd6738bceac131d65", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/5377393c197c4be30515dc8cd6738bceac131d65", "committedDate": "2020-04-17T01:16:30Z", "message": "Add v1 and v2 format test for manifest files."}, "afterCommit": {"oid": "b61fb6a70f8d3dbdf7b15ccea96f759850f36df9", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/b61fb6a70f8d3dbdf7b15ccea96f759850f36df9", "committedDate": "2020-04-17T01:20:11Z", "message": "Add v1 and v2 format test for manifest files."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1NTQ2NzUy", "url": "https://github.com/apache/iceberg/pull/913#pullrequestreview-395546752", "createdAt": "2020-04-17T15:19:30Z", "commit": {"oid": "b61fb6a70f8d3dbdf7b15ccea96f759850f36df9"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "af1d77f7cd3ccbca164e66472983d1b6f1be9ef3", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/af1d77f7cd3ccbca164e66472983d1b6f1be9ef3", "committedDate": "2020-04-17T16:57:36Z", "message": "Add another v2 format test."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NzQ0MDIx", "url": "https://github.com/apache/iceberg/pull/913#pullrequestreview-396744021", "createdAt": "2020-04-20T19:22:17Z", "commit": {"oid": "af1d77f7cd3ccbca164e66472983d1b6f1be9ef3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxOToyMjoxN1rOGIj6_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxOToyMjoxN1rOGIj6_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYzMDMzMw==", "bodyText": "nit: I think we need to update the Javadoc.", "url": "https://github.com/apache/iceberg/pull/913#discussion_r411630333", "createdAt": "2020-04-20T19:22:17Z", "author": {"login": "aokolnychyi"}, "path": "core/src/main/java/org/apache/iceberg/ManifestWriter.java", "diffHunk": "@@ -116,12 +126,12 @@ void add(ManifestEntry entry) {\n    * @param existingFile a data file\n    * @param fileSnapshotId snapshot ID when the data file was added to the table\n    */\n-  public void existing(DataFile existingFile, long fileSnapshotId) {\n-    addEntry(reused.wrapExisting(fileSnapshotId, existingFile));\n+  public void existing(DataFile existingFile, long fileSnapshotId, long sequenceNumber) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af1d77f7cd3ccbca164e66472983d1b6f1be9ef3"}, "originalPosition": 60}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4b7c8f193e133e50d8f2ca858e50bb5930421adb", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/4b7c8f193e133e50d8f2ca858e50bb5930421adb", "committedDate": "2020-04-20T19:43:34Z", "message": "Update Javadoc."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4786, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}