{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMxODY3NTU0", "number": 1870, "title": "Iceberg Jdbc Catalog Implementation", "bodyText": "Implemented simple Jdbc Catalog #1634 it useful feature to have for some scenarios\ncc: @kbendick @jackye1995\ncloses #1634", "createdAt": "2020-12-03T15:27:01Z", "url": "https://github.com/apache/iceberg/pull/1870", "merged": true, "mergeCommit": {"oid": "0c784fae03e792d98aee46f4c71da5e180611f10"}, "closed": true, "closedAt": "2021-06-21T21:48:49Z", "author": {"login": "ismailsimsek"}, "timelineItems": {"totalCount": 159, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABeOPEZBAH2gAyNTMxODY3NTU0OjYwZmFmYzNhYjRmZWFkMGFmMTBhMzE1MmFjMDhmNzczMzEyNDEyYzE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABejCLtKAFqTY4ODg4ODIzNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "60fafc3ab4fead0af10a3152ac08f773312412c1", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/60fafc3ab4fead0af10a3152ac08f773312412c1", "committedDate": "2021-04-18T06:56:42Z", "message": "review fixes\n\nreview fixes\n\nreview fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "af3937ea443ee3a3f6db701f7aaba2203fa7bdff", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/af3937ea443ee3a3f6db701f7aaba2203fa7bdff", "committedDate": "2021-04-18T06:56:42Z", "message": "update spark3 catalog change"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ef240b2087b37c70a4e4ec6643d08b95ce24aa6f", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/ef240b2087b37c70a4e4ec6643d08b95ce24aa6f", "committedDate": "2021-04-18T06:56:42Z", "message": "fix catalog class name"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5386846207d96c5067c8e139fc9423da50ec9b38", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/5386846207d96c5067c8e139fc9423da50ec9b38", "committedDate": "2021-04-18T06:56:42Z", "message": "review updates"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a0d6f9497a6253dd07dc79f1600f84aadcf25e4d", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/a0d6f9497a6253dd07dc79f1600f84aadcf25e4d", "committedDate": "2021-04-18T06:56:42Z", "message": "add method defaultNamespaceLocation(namespace)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aaea91cdd45414d49613dafe4cb10869ffd36502", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/aaea91cdd45414d49613dafe4cb10869ffd36502", "committedDate": "2021-04-18T06:56:42Z", "message": "move sql statements to JdbcUtil"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "428e57a5f1e4c00e811d500a36665222b97866f5", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/428e57a5f1e4c00e811d500a36665222b97866f5", "committedDate": "2021-04-18T06:56:42Z", "message": "use protected for sql constants"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7ac78fa0ed1a732e5dda152030ace826903fdfbf", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/7ac78fa0ed1a732e5dda152030ace826903fdfbf", "committedDate": "2021-04-18T06:56:42Z", "message": "address review notes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "699047429aa823bf0390857b47ee7c5bd1d49b1e", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/699047429aa823bf0390857b47ee7c5bd1d49b1e", "committedDate": "2021-04-18T06:56:42Z", "message": "moved UncheckedSQLException to org.apache.iceberg.jdbc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9d68634cf2656cdf52757bde1a2e6793e4c476cc", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/9d68634cf2656cdf52757bde1a2e6793e4c476cc", "committedDate": "2021-04-18T06:56:42Z", "message": "update messages"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f2c9e850ff73e735e4083319d41ccb3690330bdc", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/f2c9e850ff73e735e4083319d41ccb3690330bdc", "committedDate": "2021-04-18T06:56:42Z", "message": "fix test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1c4bcc0df62193059704c1857a31556dab85878d", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/1c4bcc0df62193059704c1857a31556dab85878d", "committedDate": "2021-04-18T06:56:42Z", "message": "review updates"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dd8d14a8a481f04601b1adbcae553f179ffc6e6d", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/dd8d14a8a481f04601b1adbcae553f179ffc6e6d", "committedDate": "2021-04-18T06:56:42Z", "message": "move column names to constants"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5617a8280095e60a1540152fe1d8af81536b51d1", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/5617a8280095e60a1540152fe1d8af81536b51d1", "committedDate": "2021-04-18T06:56:42Z", "message": "fix concurrent tests and db url"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "87ffe6d3afc0c8b75b7d1b3a4d499185f8c767e7", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/87ffe6d3afc0c8b75b7d1b3a4d499185f8c767e7", "committedDate": "2021-04-18T06:56:42Z", "message": "review fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d4d96870eeea74b0769e1eaf7855e2c5c34436c2", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/d4d96870eeea74b0769e1eaf7855e2c5c34436c2", "committedDate": "2021-04-18T06:56:42Z", "message": "update HIVE_URI to URI"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a63cc091856fc17d3f5d0d1351388a7efad789a3", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/a63cc091856fc17d3f5d0d1351388a7efad789a3", "committedDate": "2021-04-18T06:56:42Z", "message": "update HIVE_URI to URI"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d60f43581132fa9d2c30bc06f35d96a39e879fdc", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/d60f43581132fa9d2c30bc06f35d96a39e879fdc", "committedDate": "2021-04-18T06:56:42Z", "message": "Address review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ebb2de34a4e3e22473dc8d8882c1c2f248c46c57", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/ebb2de34a4e3e22473dc8d8882c1c2f248c46c57", "committedDate": "2021-04-18T06:56:42Z", "message": "moved initializeConnection to initialize"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "75aa896fea43ed1c56a94eb4d25d7232692d2c01", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/75aa896fea43ed1c56a94eb4d25d7232692d2c01", "committedDate": "2021-04-18T07:00:38Z", "message": "move ClientPoolImpl to core"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "706715b70feabe205f293a7dc2476d8ceaad12b9", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/706715b70feabe205f293a7dc2476d8ceaad12b9", "committedDate": "2021-04-18T07:00:39Z", "message": "minor improvements"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d683f7664f2c595570153edcfa0c9520d8e922ca", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/d683f7664f2c595570153edcfa0c9520d8e922ca", "committedDate": "2021-04-18T07:00:39Z", "message": "minor improvements"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4e53dd02075ae619ba86b0d0d7a2ffc0e66126b9", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/4e53dd02075ae619ba86b0d0d7a2ffc0e66126b9", "committedDate": "2021-04-18T07:00:39Z", "message": "minor improvements"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8cfea794377b79a25a014aa7a983547be80c1c4a", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/8cfea794377b79a25a014aa7a983547be80c1c4a", "committedDate": "2021-04-17T19:21:07Z", "message": "minor improvements"}, "afterCommit": {"oid": "4e53dd02075ae619ba86b0d0d7a2ffc0e66126b9", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/4e53dd02075ae619ba86b0d0d7a2ffc0e66126b9", "committedDate": "2021-04-18T07:00:39Z", "message": "minor improvements"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU5MjExNjcx", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-659211671", "createdAt": "2021-05-13T19:02:39Z", "commit": {"oid": "4e53dd02075ae619ba86b0d0d7a2ffc0e66126b9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0xM1QxOTowMjozOVrOJawdVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0xM1QxOTowMjozOVrOJawdVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMjAzNjY5NA==", "bodyText": "Nit: Missing space before opening parens of (if missing).", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r632036694", "createdAt": "2021-05-13T19:02:39Z", "author": {"login": "kbendick"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,394 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.io.Closeable;\n+import java.sql.DatabaseMetaData;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, SupportsNamespaces, Closeable {\n+\n+  public static final String PROPERTY_PREFIX = \"connection.parameter.\";\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcCatalog.class);\n+  private static final Joiner SLASH = Joiner.on(\"/\");\n+\n+  private FileIO io;\n+  private String catalogName = \"jdbc\";\n+  private String warehouseLocation;\n+  private Configuration conf;\n+  private JdbcClientPool connections;\n+\n+  public JdbcCatalog() {\n+  }\n+\n+  @Override\n+  public void initialize(String name, Map<String, String> properties) {\n+    String uri = properties.get(CatalogProperties.URI);\n+    Preconditions.checkNotNull(uri, \"JDBC connection URI is required\");\n+\n+    String warehouse = properties.get(CatalogProperties.WAREHOUSE_LOCATION);\n+    Preconditions.checkNotNull(warehouse, \"JDBC warehouse location is required\");\n+    this.warehouseLocation = warehouse.replaceAll(\"/$\", \"\");\n+\n+    if (name != null) {\n+      this.catalogName = name;\n+    }\n+\n+    String fileIOImpl = properties.get(CatalogProperties.FILE_IO_IMPL);\n+    this.io = fileIOImpl == null ?\n+        new HadoopFileIO(conf) :\n+        CatalogUtil.loadFileIO(fileIOImpl, properties, conf);\n+\n+    try {\n+      LOG.debug(\"Connecting to Jdbc database {}\", properties.get(CatalogProperties.URI));\n+      connections = new JdbcClientPool(uri, properties);\n+      initializeCatalogTables();\n+    } catch (SQLTimeoutException e) {\n+      throw new UncheckedSQLException(\"Database Connection timeout\", e);\n+    } catch (SQLTransientConnectionException | SQLNonTransientConnectionException e) {\n+      throw new UncheckedSQLException(\"Database Connection failed\", e);\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(\"Failed to initialize catalog\", e);\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted in call to initialize\", e);\n+    }\n+  }\n+\n+  private void initializeCatalogTables() throws InterruptedException, SQLException {\n+    LOG.trace(\"Creating tables(if missing) to store iceberg catalog\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e53dd02075ae619ba86b0d0d7a2ffc0e66126b9"}, "originalPosition": 109}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY1MDU4OTk0", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-665058994", "createdAt": "2021-05-21T03:24:02Z", "commit": {"oid": "4e53dd02075ae619ba86b0d0d7a2ffc0e66126b9"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0yMVQwMzoyNDowMlrOJfHiwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0yMVQwMzo0MToxNVrOJfH1Bg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNjYwOTIxOA==", "bodyText": "I don't think we need all the logic in this file, it's much cleaner for everything other than hive and hadoop to be loaded through impl. It makes the user experience much more consistent, and we don't need to keep updating the list of types in documentation.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r636609218", "createdAt": "2021-05-21T03:24:02Z", "author": {"login": "jackye1995"}, "path": "core/src/main/java/org/apache/iceberg/CatalogUtil.java", "diffHunk": "@@ -48,8 +48,10 @@\n   public static final String ICEBERG_CATALOG_TYPE = \"type\";\n   public static final String ICEBERG_CATALOG_TYPE_HADOOP = \"hadoop\";\n   public static final String ICEBERG_CATALOG_TYPE_HIVE = \"hive\";\n+  public static final String ICEBERG_CATALOG_TYPE_JDBC = \"jdbc\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e53dd02075ae619ba86b0d0d7a2ffc0e66126b9"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNjYxMDk5MQ==", "bodyText": "nit: no need for newline here", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r636610991", "createdAt": "2021-05-21T03:29:22Z", "author": {"login": "jackye1995"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,394 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.io.Closeable;\n+import java.sql.DatabaseMetaData;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, SupportsNamespaces, Closeable {\n+\n+  public static final String PROPERTY_PREFIX = \"connection.parameter.\";\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcCatalog.class);\n+  private static final Joiner SLASH = Joiner.on(\"/\");\n+\n+  private FileIO io;\n+  private String catalogName = \"jdbc\";\n+  private String warehouseLocation;\n+  private Configuration conf;\n+  private JdbcClientPool connections;\n+\n+  public JdbcCatalog() {\n+  }\n+\n+  @Override\n+  public void initialize(String name, Map<String, String> properties) {\n+    String uri = properties.get(CatalogProperties.URI);\n+    Preconditions.checkNotNull(uri, \"JDBC connection URI is required\");\n+\n+    String warehouse = properties.get(CatalogProperties.WAREHOUSE_LOCATION);\n+    Preconditions.checkNotNull(warehouse, \"JDBC warehouse location is required\");\n+    this.warehouseLocation = warehouse.replaceAll(\"/$\", \"\");\n+\n+    if (name != null) {\n+      this.catalogName = name;\n+    }\n+\n+    String fileIOImpl = properties.get(CatalogProperties.FILE_IO_IMPL);\n+    this.io = fileIOImpl == null ?\n+        new HadoopFileIO(conf) :", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e53dd02075ae619ba86b0d0d7a2ffc0e66126b9"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNjYxMTE0Ng==", "bodyText": "nit: error message should follow format \"Cannot xxx: reason\"", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r636611146", "createdAt": "2021-05-21T03:29:58Z", "author": {"login": "jackye1995"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,394 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.io.Closeable;\n+import java.sql.DatabaseMetaData;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, SupportsNamespaces, Closeable {\n+\n+  public static final String PROPERTY_PREFIX = \"connection.parameter.\";\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcCatalog.class);\n+  private static final Joiner SLASH = Joiner.on(\"/\");\n+\n+  private FileIO io;\n+  private String catalogName = \"jdbc\";\n+  private String warehouseLocation;\n+  private Configuration conf;\n+  private JdbcClientPool connections;\n+\n+  public JdbcCatalog() {\n+  }\n+\n+  @Override\n+  public void initialize(String name, Map<String, String> properties) {\n+    String uri = properties.get(CatalogProperties.URI);\n+    Preconditions.checkNotNull(uri, \"JDBC connection URI is required\");\n+\n+    String warehouse = properties.get(CatalogProperties.WAREHOUSE_LOCATION);\n+    Preconditions.checkNotNull(warehouse, \"JDBC warehouse location is required\");\n+    this.warehouseLocation = warehouse.replaceAll(\"/$\", \"\");\n+\n+    if (name != null) {\n+      this.catalogName = name;\n+    }\n+\n+    String fileIOImpl = properties.get(CatalogProperties.FILE_IO_IMPL);\n+    this.io = fileIOImpl == null ?\n+        new HadoopFileIO(conf) :\n+        CatalogUtil.loadFileIO(fileIOImpl, properties, conf);\n+\n+    try {\n+      LOG.debug(\"Connecting to Jdbc database {}\", properties.get(CatalogProperties.URI));\n+      connections = new JdbcClientPool(uri, properties);\n+      initializeCatalogTables();\n+    } catch (SQLTimeoutException e) {\n+      throw new UncheckedSQLException(\"Database Connection timeout\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e53dd02075ae619ba86b0d0d7a2ffc0e66126b9"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNjYxMTY3Nw==", "bodyText": "no need for if condition.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r636611677", "createdAt": "2021-05-21T03:32:01Z", "author": {"login": "jackye1995"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,394 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.io.Closeable;\n+import java.sql.DatabaseMetaData;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, SupportsNamespaces, Closeable {\n+\n+  public static final String PROPERTY_PREFIX = \"connection.parameter.\";\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcCatalog.class);\n+  private static final Joiner SLASH = Joiner.on(\"/\");\n+\n+  private FileIO io;\n+  private String catalogName = \"jdbc\";\n+  private String warehouseLocation;\n+  private Configuration conf;\n+  private JdbcClientPool connections;\n+\n+  public JdbcCatalog() {\n+  }\n+\n+  @Override\n+  public void initialize(String name, Map<String, String> properties) {\n+    String uri = properties.get(CatalogProperties.URI);\n+    Preconditions.checkNotNull(uri, \"JDBC connection URI is required\");\n+\n+    String warehouse = properties.get(CatalogProperties.WAREHOUSE_LOCATION);\n+    Preconditions.checkNotNull(warehouse, \"JDBC warehouse location is required\");\n+    this.warehouseLocation = warehouse.replaceAll(\"/$\", \"\");\n+\n+    if (name != null) {\n+      this.catalogName = name;\n+    }\n+\n+    String fileIOImpl = properties.get(CatalogProperties.FILE_IO_IMPL);\n+    this.io = fileIOImpl == null ?\n+        new HadoopFileIO(conf) :\n+        CatalogUtil.loadFileIO(fileIOImpl, properties, conf);\n+\n+    try {\n+      LOG.debug(\"Connecting to Jdbc database {}\", properties.get(CatalogProperties.URI));\n+      connections = new JdbcClientPool(uri, properties);\n+      initializeCatalogTables();\n+    } catch (SQLTimeoutException e) {\n+      throw new UncheckedSQLException(\"Database Connection timeout\", e);\n+    } catch (SQLTransientConnectionException | SQLNonTransientConnectionException e) {\n+      throw new UncheckedSQLException(\"Database Connection failed\", e);\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(\"Failed to initialize catalog\", e);\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted in call to initialize\", e);\n+    }\n+  }\n+\n+  private void initializeCatalogTables() throws InterruptedException, SQLException {\n+    LOG.trace(\"Creating tables(if missing) to store iceberg catalog\");\n+    connections.run(conn -> {\n+      DatabaseMetaData dbMeta = conn.getMetaData();\n+      ResultSet tableExists = dbMeta.getTables(null, null, JdbcUtil.CATALOG_TABLE_NAME, null);\n+\n+      if (tableExists.next()) {\n+        return true;\n+      }\n+\n+      LOG.debug(\"Creating table {} to store iceberg catalog!\", JdbcUtil.CATALOG_TABLE_NAME);\n+      return conn.prepareStatement(JdbcUtil.CREATE_CATALOG_TABLE).execute();\n+    });\n+  }\n+\n+  @Override\n+  protected TableOperations newTableOps(TableIdentifier tableIdentifier) {\n+    return new JdbcTableOperations(connections, io, catalogName, tableIdentifier);\n+  }\n+\n+  @Override\n+  protected String defaultWarehouseLocation(TableIdentifier table) {\n+    if (table.hasNamespace()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e53dd02075ae619ba86b0d0d7a2ffc0e66126b9"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNjYxMjg3Nw==", "bodyText": "should add format constructors following the pattern of other Iceberg exceptions, see ValidationException for more details.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r636612877", "createdAt": "2021-05-21T03:36:56Z", "author": {"login": "jackye1995"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/UncheckedSQLException.java", "diffHunk": "@@ -0,0 +1,29 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.sql.SQLException;\n+\n+public class UncheckedSQLException extends RuntimeException {\n+\n+  public UncheckedSQLException(String message, SQLException cause) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e53dd02075ae619ba86b0d0d7a2ffc0e66126b9"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNjYxMzg5NA==", "bodyText": "will the test fail if we don't set it back? If not we can remove it, if so we should have a @After to clean this up.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r636613894", "createdAt": "2021-05-21T03:41:15Z", "author": {"login": "jackye1995"}, "path": "spark3/src/test/java/org/apache/iceberg/actions/TestRemoveOrphanFilesAction3.java", "diffHunk": "@@ -165,4 +165,64 @@ public void testSparkSessionCatalogHiveTable() throws Exception {\n     spark.conf().unset(\"spark.sql.catalog.spark_catalog.type\");\n   }\n \n+  @Test\n+  public void testSparkCatalogNamedJdbcTable() throws Exception {\n+    spark.conf().set(\"spark.sql.catalog.jdbc\", \"org.apache.iceberg.spark.SparkCatalog\");\n+    spark.conf().set(\"spark.sql.catalog.jdbc.type\", \"jdbc\");\n+    spark.conf().set(\"spark.sql.catalog.jdbc.warehouse\", tableLocation);\n+    spark.conf().set(\"spark.sql.catalog.jdbc.uri\", \"jdbc:sqlite:file::memory:?icsparkjdbctestcat;\");\n+    spark.conf().set(\"spark.sql.catalog.jdbc.connection.parameter.user\", \"testuser\");\n+    spark.conf().set(\"spark.sql.catalog.jdbc.connection.parameter.password\", \"testpassword\");\n+    SparkCatalog cat = (SparkCatalog) spark.sessionState().catalogManager().catalog(\"jdbc\");\n+\n+    String[] database = {\"default\"};\n+    Identifier id = Identifier.of(database, \"table\");\n+    Map<String, String> options = Maps.newHashMap();\n+    Transform[] transforms = {};\n+    cat.createTable(id, SparkSchemaUtil.convert(SCHEMA), transforms, options);\n+    SparkTable table = cat.loadTable(id);\n+\n+    spark.sql(\"INSERT INTO jdbc.default.table VALUES (1,1,1)\");\n+\n+    String location = table.table().location().replaceFirst(\"file:\", \"\");\n+    new File(location + \"/data/trashfile\").createNewFile();\n+\n+    List<String> results = Actions.forTable(table.table()).removeOrphanFiles()\n+        .olderThan(System.currentTimeMillis() + 1000).execute();\n+    Assert.assertTrue(\"trash file should be removed\",\n+        results.contains(\"file:\" + location + \"/data/trashfile\"));\n+  }\n+\n+  @Test\n+  public void testSparkSessionCatalogJdbcTable() throws Exception {\n+    spark.conf().set(\"spark.sql.catalog.spark_catalog\", \"org.apache.iceberg.spark.SparkSessionCatalog\");\n+    spark.conf().set(\"spark.sql.catalog.spark_catalog.type\", \"jdbc\");\n+    spark.conf().set(\"spark.sql.catalog.spark_catalog.warehouse\", tableLocation);\n+    spark.conf().set(\"spark.sql.catalog.spark_catalog.uri\", \"jdbc:sqlite:file::memory:?icsparktestcat;\");\n+    spark.conf().set(\"spark.sql.catalog.spark_catalog.connection.parameter.user\", \"testuser\");\n+    spark.conf().set(\"spark.sql.catalog.spark_catalog.connection.parameter.password\", \"testpassword\");\n+    SparkSessionCatalog cat = (SparkSessionCatalog) spark.sessionState().catalogManager().v2SessionCatalog();\n+\n+    String[] database = {\"default\"};\n+    Identifier id = Identifier.of(database, \"sessioncattest\");\n+    Map<String, String> options = Maps.newHashMap();\n+    Transform[] transforms = {};\n+    cat.dropTable(id);\n+    cat.createTable(id, SparkSchemaUtil.convert(SCHEMA), transforms, options);\n+    SparkTable table = (SparkTable) cat.loadTable(id);\n+\n+    spark.sql(\"INSERT INTO default.sessioncattest VALUES (1,1,1)\");\n+\n+    String location = table.table().location().replaceFirst(\"file:\", \"\");\n+    new File(location + \"/data/trashfile\").createNewFile();\n+\n+    List<String> results = Actions.forTable(table.table()).removeOrphanFiles()\n+        .olderThan(System.currentTimeMillis() + 1000).execute();\n+    Assert.assertTrue(\"trash file should be removed\",\n+        results.contains(\"file:\" + location + \"/data/trashfile\"));\n+    // reset spark_catalog to default", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e53dd02075ae619ba86b0d0d7a2ffc0e66126b9"}, "originalPosition": 59}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fc9446405e27bbf8d4487dd4142079d5265c7336", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/fc9446405e27bbf8d4487dd4142079d5265c7336", "committedDate": "2021-05-22T10:23:16Z", "message": "implement review changes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY2MzE1NDM1", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-666315435", "createdAt": "2021-05-23T23:27:17Z", "commit": {"oid": "fc9446405e27bbf8d4487dd4142079d5265c7336"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0yM1QyMzoyNzoxN1rOJgE_3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0yM1QyMzoyNzoxN1rOJgE_3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNzYxNjA5Mg==", "bodyText": "We may want to consider an UncheckedInterruptedException like UncheckedIOException and UncheckedSQLException.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r637616092", "createdAt": "2021-05-23T23:27:17Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.io.Closeable;\n+import java.sql.DatabaseMetaData;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, SupportsNamespaces, Closeable {\n+\n+  public static final String PROPERTY_PREFIX = \"connection.parameter.\";\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcCatalog.class);\n+  private static final Joiner SLASH = Joiner.on(\"/\");\n+\n+  private FileIO io;\n+  private String catalogName = \"jdbc\";\n+  private String warehouseLocation;\n+  private Configuration conf;\n+  private JdbcClientPool connections;\n+\n+  public JdbcCatalog() {\n+  }\n+\n+  @Override\n+  public void initialize(String name, Map<String, String> properties) {\n+    String uri = properties.get(CatalogProperties.URI);\n+    Preconditions.checkNotNull(uri, \"JDBC connection URI is required\");\n+\n+    String warehouse = properties.get(CatalogProperties.WAREHOUSE_LOCATION);\n+    Preconditions.checkNotNull(warehouse, \"JDBC warehouse location is required\");\n+    this.warehouseLocation = warehouse.replaceAll(\"/$\", \"\");\n+\n+    if (name != null) {\n+      this.catalogName = name;\n+    }\n+\n+    String fileIOImpl = properties.get(CatalogProperties.FILE_IO_IMPL);\n+    this.io = fileIOImpl == null ? new HadoopFileIO(conf) : CatalogUtil.loadFileIO(fileIOImpl, properties, conf);\n+\n+    try {\n+      LOG.debug(\"Connecting to Jdbc database {}\", properties.get(CatalogProperties.URI));\n+      connections = new JdbcClientPool(uri, properties);\n+      initializeCatalogTables();\n+    } catch (SQLTimeoutException e) {\n+      throw new UncheckedSQLException(e, \"Cannot initialize jdbc catalog: Query timed out\");\n+    } catch (SQLTransientConnectionException | SQLNonTransientConnectionException e) {\n+      throw new UncheckedSQLException(e, \"Cannot initialize jdbc catalog: Connection failed\");\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(e, \"Cannot initialize jdbc catalog\");\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted in call to initialize\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc9446405e27bbf8d4487dd4142079d5265c7336"}, "originalPosition": 102}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY2MzE1NTkw", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-666315590", "createdAt": "2021-05-23T23:28:44Z", "commit": {"oid": "fc9446405e27bbf8d4487dd4142079d5265c7336"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0yM1QyMzoyODo0NVrOJgFApA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0yM1QyMzoyODo0NVrOJgFApA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNzYxNjI5Mg==", "bodyText": "Nit: in other log messages and errors, JDBC is in all caps. I think we should use JDBC in messages for consistency, rather than Jdbc.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r637616292", "createdAt": "2021-05-23T23:28:45Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.io.Closeable;\n+import java.sql.DatabaseMetaData;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, SupportsNamespaces, Closeable {\n+\n+  public static final String PROPERTY_PREFIX = \"connection.parameter.\";\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcCatalog.class);\n+  private static final Joiner SLASH = Joiner.on(\"/\");\n+\n+  private FileIO io;\n+  private String catalogName = \"jdbc\";\n+  private String warehouseLocation;\n+  private Configuration conf;\n+  private JdbcClientPool connections;\n+\n+  public JdbcCatalog() {\n+  }\n+\n+  @Override\n+  public void initialize(String name, Map<String, String> properties) {\n+    String uri = properties.get(CatalogProperties.URI);\n+    Preconditions.checkNotNull(uri, \"JDBC connection URI is required\");\n+\n+    String warehouse = properties.get(CatalogProperties.WAREHOUSE_LOCATION);\n+    Preconditions.checkNotNull(warehouse, \"JDBC warehouse location is required\");\n+    this.warehouseLocation = warehouse.replaceAll(\"/$\", \"\");\n+\n+    if (name != null) {\n+      this.catalogName = name;\n+    }\n+\n+    String fileIOImpl = properties.get(CatalogProperties.FILE_IO_IMPL);\n+    this.io = fileIOImpl == null ? new HadoopFileIO(conf) : CatalogUtil.loadFileIO(fileIOImpl, properties, conf);\n+\n+    try {\n+      LOG.debug(\"Connecting to Jdbc database {}\", properties.get(CatalogProperties.URI));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc9446405e27bbf8d4487dd4142079d5265c7336"}, "originalPosition": 91}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY2MzE1NjQz", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-666315643", "createdAt": "2021-05-23T23:29:24Z", "commit": {"oid": "fc9446405e27bbf8d4487dd4142079d5265c7336"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0yM1QyMzoyOToyNFrOJgFA7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0yM1QyMzoyOToyNFrOJgFA7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNzYxNjM2NQ==", "bodyText": "While I appreciate enthusiasm, there's no need for extra characters like ! in log messages.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r637616365", "createdAt": "2021-05-23T23:29:24Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.io.Closeable;\n+import java.sql.DatabaseMetaData;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, SupportsNamespaces, Closeable {\n+\n+  public static final String PROPERTY_PREFIX = \"connection.parameter.\";\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcCatalog.class);\n+  private static final Joiner SLASH = Joiner.on(\"/\");\n+\n+  private FileIO io;\n+  private String catalogName = \"jdbc\";\n+  private String warehouseLocation;\n+  private Configuration conf;\n+  private JdbcClientPool connections;\n+\n+  public JdbcCatalog() {\n+  }\n+\n+  @Override\n+  public void initialize(String name, Map<String, String> properties) {\n+    String uri = properties.get(CatalogProperties.URI);\n+    Preconditions.checkNotNull(uri, \"JDBC connection URI is required\");\n+\n+    String warehouse = properties.get(CatalogProperties.WAREHOUSE_LOCATION);\n+    Preconditions.checkNotNull(warehouse, \"JDBC warehouse location is required\");\n+    this.warehouseLocation = warehouse.replaceAll(\"/$\", \"\");\n+\n+    if (name != null) {\n+      this.catalogName = name;\n+    }\n+\n+    String fileIOImpl = properties.get(CatalogProperties.FILE_IO_IMPL);\n+    this.io = fileIOImpl == null ? new HadoopFileIO(conf) : CatalogUtil.loadFileIO(fileIOImpl, properties, conf);\n+\n+    try {\n+      LOG.debug(\"Connecting to Jdbc database {}\", properties.get(CatalogProperties.URI));\n+      connections = new JdbcClientPool(uri, properties);\n+      initializeCatalogTables();\n+    } catch (SQLTimeoutException e) {\n+      throw new UncheckedSQLException(e, \"Cannot initialize jdbc catalog: Query timed out\");\n+    } catch (SQLTransientConnectionException | SQLNonTransientConnectionException e) {\n+      throw new UncheckedSQLException(e, \"Cannot initialize jdbc catalog: Connection failed\");\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(e, \"Cannot initialize jdbc catalog\");\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted in call to initialize\", e);\n+    }\n+  }\n+\n+  private void initializeCatalogTables() throws InterruptedException, SQLException {\n+    LOG.trace(\"Creating database tables (if missing) to store iceberg catalog\");\n+    connections.run(conn -> {\n+      DatabaseMetaData dbMeta = conn.getMetaData();\n+      ResultSet tableExists = dbMeta.getTables(null, null, JdbcUtil.CATALOG_TABLE_NAME, null);\n+\n+      if (tableExists.next()) {\n+        return true;\n+      }\n+\n+      LOG.debug(\"Creating table {} to store iceberg catalog!\", JdbcUtil.CATALOG_TABLE_NAME);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc9446405e27bbf8d4487dd4142079d5265c7336"}, "originalPosition": 116}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY2MzE1ODQ0", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-666315844", "createdAt": "2021-05-23T23:31:16Z", "commit": {"oid": "fc9446405e27bbf8d4487dd4142079d5265c7336"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0yM1QyMzozMToxNlrOJgFB1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0yM1QyMzozMToxNlrOJgFB1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNzYxNjU5OQ==", "bodyText": "In HadoopCatalog, this is /*$. Maybe we should do the same here?", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r637616599", "createdAt": "2021-05-23T23:31:16Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.io.Closeable;\n+import java.sql.DatabaseMetaData;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, SupportsNamespaces, Closeable {\n+\n+  public static final String PROPERTY_PREFIX = \"connection.parameter.\";\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcCatalog.class);\n+  private static final Joiner SLASH = Joiner.on(\"/\");\n+\n+  private FileIO io;\n+  private String catalogName = \"jdbc\";\n+  private String warehouseLocation;\n+  private Configuration conf;\n+  private JdbcClientPool connections;\n+\n+  public JdbcCatalog() {\n+  }\n+\n+  @Override\n+  public void initialize(String name, Map<String, String> properties) {\n+    String uri = properties.get(CatalogProperties.URI);\n+    Preconditions.checkNotNull(uri, \"JDBC connection URI is required\");\n+\n+    String warehouse = properties.get(CatalogProperties.WAREHOUSE_LOCATION);\n+    Preconditions.checkNotNull(warehouse, \"JDBC warehouse location is required\");\n+    this.warehouseLocation = warehouse.replaceAll(\"/$\", \"\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc9446405e27bbf8d4487dd4142079d5265c7336"}, "originalPosition": 81}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY2MzE1OTA4", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-666315908", "createdAt": "2021-05-23T23:31:45Z", "commit": {"oid": "fc9446405e27bbf8d4487dd4142079d5265c7336"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0yM1QyMzozMTo0NVrOJgFCKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0yM1QyMzozMTo0NVrOJgFCKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNzYxNjY4Mg==", "bodyText": "Nit: we don't typically start a method with an empty line.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r637616682", "createdAt": "2021-05-23T23:31:45Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.io.Closeable;\n+import java.sql.DatabaseMetaData;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, SupportsNamespaces, Closeable {\n+\n+  public static final String PROPERTY_PREFIX = \"connection.parameter.\";\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcCatalog.class);\n+  private static final Joiner SLASH = Joiner.on(\"/\");\n+\n+  private FileIO io;\n+  private String catalogName = \"jdbc\";\n+  private String warehouseLocation;\n+  private Configuration conf;\n+  private JdbcClientPool connections;\n+\n+  public JdbcCatalog() {\n+  }\n+\n+  @Override\n+  public void initialize(String name, Map<String, String> properties) {\n+    String uri = properties.get(CatalogProperties.URI);\n+    Preconditions.checkNotNull(uri, \"JDBC connection URI is required\");\n+\n+    String warehouse = properties.get(CatalogProperties.WAREHOUSE_LOCATION);\n+    Preconditions.checkNotNull(warehouse, \"JDBC warehouse location is required\");\n+    this.warehouseLocation = warehouse.replaceAll(\"/$\", \"\");\n+\n+    if (name != null) {\n+      this.catalogName = name;\n+    }\n+\n+    String fileIOImpl = properties.get(CatalogProperties.FILE_IO_IMPL);\n+    this.io = fileIOImpl == null ? new HadoopFileIO(conf) : CatalogUtil.loadFileIO(fileIOImpl, properties, conf);\n+\n+    try {\n+      LOG.debug(\"Connecting to Jdbc database {}\", properties.get(CatalogProperties.URI));\n+      connections = new JdbcClientPool(uri, properties);\n+      initializeCatalogTables();\n+    } catch (SQLTimeoutException e) {\n+      throw new UncheckedSQLException(e, \"Cannot initialize jdbc catalog: Query timed out\");\n+    } catch (SQLTransientConnectionException | SQLNonTransientConnectionException e) {\n+      throw new UncheckedSQLException(e, \"Cannot initialize jdbc catalog: Connection failed\");\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(e, \"Cannot initialize jdbc catalog\");\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted in call to initialize\", e);\n+    }\n+  }\n+\n+  private void initializeCatalogTables() throws InterruptedException, SQLException {\n+    LOG.trace(\"Creating database tables (if missing) to store iceberg catalog\");\n+    connections.run(conn -> {\n+      DatabaseMetaData dbMeta = conn.getMetaData();\n+      ResultSet tableExists = dbMeta.getTables(null, null, JdbcUtil.CATALOG_TABLE_NAME, null);\n+\n+      if (tableExists.next()) {\n+        return true;\n+      }\n+\n+      LOG.debug(\"Creating table {} to store iceberg catalog!\", JdbcUtil.CATALOG_TABLE_NAME);\n+      return conn.prepareStatement(JdbcUtil.CREATE_CATALOG_TABLE).execute();\n+    });\n+  }\n+\n+  @Override\n+  protected TableOperations newTableOps(TableIdentifier tableIdentifier) {\n+    return new JdbcTableOperations(connections, io, catalogName, tableIdentifier);\n+  }\n+\n+  @Override\n+  protected String defaultWarehouseLocation(TableIdentifier table) {\n+    return SLASH.join(defaultNamespaceLocation(table.namespace()), table.name());\n+  }\n+\n+  @Override\n+  public boolean dropTable(TableIdentifier identifier, boolean purge) {\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc9446405e27bbf8d4487dd4142079d5265c7336"}, "originalPosition": 133}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY2MzE2MjI3", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-666316227", "createdAt": "2021-05-23T23:34:56Z", "commit": {"oid": "fc9446405e27bbf8d4487dd4142079d5265c7336"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0yM1QyMzozNDo1NlrOJgFDow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0yM1QyMzozNDo1NlrOJgFDow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNzYxNzA1OQ==", "bodyText": "Nit: unnecessary newline at the end of the method.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r637617059", "createdAt": "2021-05-23T23:34:56Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.io.Closeable;\n+import java.sql.DatabaseMetaData;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, SupportsNamespaces, Closeable {\n+\n+  public static final String PROPERTY_PREFIX = \"connection.parameter.\";\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcCatalog.class);\n+  private static final Joiner SLASH = Joiner.on(\"/\");\n+\n+  private FileIO io;\n+  private String catalogName = \"jdbc\";\n+  private String warehouseLocation;\n+  private Configuration conf;\n+  private JdbcClientPool connections;\n+\n+  public JdbcCatalog() {\n+  }\n+\n+  @Override\n+  public void initialize(String name, Map<String, String> properties) {\n+    String uri = properties.get(CatalogProperties.URI);\n+    Preconditions.checkNotNull(uri, \"JDBC connection URI is required\");\n+\n+    String warehouse = properties.get(CatalogProperties.WAREHOUSE_LOCATION);\n+    Preconditions.checkNotNull(warehouse, \"JDBC warehouse location is required\");\n+    this.warehouseLocation = warehouse.replaceAll(\"/$\", \"\");\n+\n+    if (name != null) {\n+      this.catalogName = name;\n+    }\n+\n+    String fileIOImpl = properties.get(CatalogProperties.FILE_IO_IMPL);\n+    this.io = fileIOImpl == null ? new HadoopFileIO(conf) : CatalogUtil.loadFileIO(fileIOImpl, properties, conf);\n+\n+    try {\n+      LOG.debug(\"Connecting to Jdbc database {}\", properties.get(CatalogProperties.URI));\n+      connections = new JdbcClientPool(uri, properties);\n+      initializeCatalogTables();\n+    } catch (SQLTimeoutException e) {\n+      throw new UncheckedSQLException(e, \"Cannot initialize jdbc catalog: Query timed out\");\n+    } catch (SQLTransientConnectionException | SQLNonTransientConnectionException e) {\n+      throw new UncheckedSQLException(e, \"Cannot initialize jdbc catalog: Connection failed\");\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(e, \"Cannot initialize jdbc catalog\");\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted in call to initialize\", e);\n+    }\n+  }\n+\n+  private void initializeCatalogTables() throws InterruptedException, SQLException {\n+    LOG.trace(\"Creating database tables (if missing) to store iceberg catalog\");\n+    connections.run(conn -> {\n+      DatabaseMetaData dbMeta = conn.getMetaData();\n+      ResultSet tableExists = dbMeta.getTables(null, null, JdbcUtil.CATALOG_TABLE_NAME, null);\n+\n+      if (tableExists.next()) {\n+        return true;\n+      }\n+\n+      LOG.debug(\"Creating table {} to store iceberg catalog!\", JdbcUtil.CATALOG_TABLE_NAME);\n+      return conn.prepareStatement(JdbcUtil.CREATE_CATALOG_TABLE).execute();\n+    });\n+  }\n+\n+  @Override\n+  protected TableOperations newTableOps(TableIdentifier tableIdentifier) {\n+    return new JdbcTableOperations(connections, io, catalogName, tableIdentifier);\n+  }\n+\n+  @Override\n+  protected String defaultWarehouseLocation(TableIdentifier table) {\n+    return SLASH.join(defaultNamespaceLocation(table.namespace()), table.name());\n+  }\n+\n+  @Override\n+  public boolean dropTable(TableIdentifier identifier, boolean purge) {\n+\n+    int deletedRecords;\n+    try {\n+      deletedRecords = connections.run(conn -> {\n+        try (PreparedStatement sql = conn.prepareStatement(JdbcUtil.DROP_TABLE_SQL)) {\n+          sql.setString(1, catalogName);\n+          sql.setString(2, JdbcUtil.namespaceToString(identifier.namespace()));\n+          sql.setString(3, identifier.name());\n+          return sql.executeUpdate();\n+        }\n+      });\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(e, \"Failed to drop %s\", identifier);\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted in call to dropTable\", e);\n+    }\n+\n+    if (deletedRecords > 0) {\n+      LOG.info(\"Successfully dropped table {}.\", identifier);\n+    } else {\n+      LOG.info(\"Cannot drop table: {}! table not found in the catalog.\", identifier);\n+      return false;\n+    }\n+\n+    TableOperations ops = newTableOps(identifier);\n+    TableMetadata lastMetadata = ops.current();\n+\n+    if (purge && lastMetadata != null) {\n+      CatalogUtil.dropTableData(ops.io(), lastMetadata);\n+      LOG.info(\"Table {} data purged!\", identifier);\n+    }\n+\n+    return true;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc9446405e27bbf8d4487dd4142079d5265c7336"}, "originalPosition": 167}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY2MzE2NDA4", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-666316408", "createdAt": "2021-05-23T23:36:53Z", "commit": {"oid": "fc9446405e27bbf8d4487dd4142079d5265c7336"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0yM1QyMzozNjo1M1rOJgFEmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0yM1QyMzozNjo1M1rOJgFEmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNzYxNzMwNA==", "bodyText": "I think we should base logging on what's done in the HiveCatalog. That way it is consistent. Here's the log for drop table: https://github.com/apache/iceberg/blob/master/hive-metastore/src/main/java/org/apache/iceberg/hive/HiveCatalog.java#L175\nThat also doesn't log if no table was dropped because it doesn't exist. I think that's the right call because we don't want to overwhelm the log with what didn't happen. At most that information should be logged at debug.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r637617304", "createdAt": "2021-05-23T23:36:53Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.io.Closeable;\n+import java.sql.DatabaseMetaData;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, SupportsNamespaces, Closeable {\n+\n+  public static final String PROPERTY_PREFIX = \"connection.parameter.\";\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcCatalog.class);\n+  private static final Joiner SLASH = Joiner.on(\"/\");\n+\n+  private FileIO io;\n+  private String catalogName = \"jdbc\";\n+  private String warehouseLocation;\n+  private Configuration conf;\n+  private JdbcClientPool connections;\n+\n+  public JdbcCatalog() {\n+  }\n+\n+  @Override\n+  public void initialize(String name, Map<String, String> properties) {\n+    String uri = properties.get(CatalogProperties.URI);\n+    Preconditions.checkNotNull(uri, \"JDBC connection URI is required\");\n+\n+    String warehouse = properties.get(CatalogProperties.WAREHOUSE_LOCATION);\n+    Preconditions.checkNotNull(warehouse, \"JDBC warehouse location is required\");\n+    this.warehouseLocation = warehouse.replaceAll(\"/$\", \"\");\n+\n+    if (name != null) {\n+      this.catalogName = name;\n+    }\n+\n+    String fileIOImpl = properties.get(CatalogProperties.FILE_IO_IMPL);\n+    this.io = fileIOImpl == null ? new HadoopFileIO(conf) : CatalogUtil.loadFileIO(fileIOImpl, properties, conf);\n+\n+    try {\n+      LOG.debug(\"Connecting to Jdbc database {}\", properties.get(CatalogProperties.URI));\n+      connections = new JdbcClientPool(uri, properties);\n+      initializeCatalogTables();\n+    } catch (SQLTimeoutException e) {\n+      throw new UncheckedSQLException(e, \"Cannot initialize jdbc catalog: Query timed out\");\n+    } catch (SQLTransientConnectionException | SQLNonTransientConnectionException e) {\n+      throw new UncheckedSQLException(e, \"Cannot initialize jdbc catalog: Connection failed\");\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(e, \"Cannot initialize jdbc catalog\");\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted in call to initialize\", e);\n+    }\n+  }\n+\n+  private void initializeCatalogTables() throws InterruptedException, SQLException {\n+    LOG.trace(\"Creating database tables (if missing) to store iceberg catalog\");\n+    connections.run(conn -> {\n+      DatabaseMetaData dbMeta = conn.getMetaData();\n+      ResultSet tableExists = dbMeta.getTables(null, null, JdbcUtil.CATALOG_TABLE_NAME, null);\n+\n+      if (tableExists.next()) {\n+        return true;\n+      }\n+\n+      LOG.debug(\"Creating table {} to store iceberg catalog!\", JdbcUtil.CATALOG_TABLE_NAME);\n+      return conn.prepareStatement(JdbcUtil.CREATE_CATALOG_TABLE).execute();\n+    });\n+  }\n+\n+  @Override\n+  protected TableOperations newTableOps(TableIdentifier tableIdentifier) {\n+    return new JdbcTableOperations(connections, io, catalogName, tableIdentifier);\n+  }\n+\n+  @Override\n+  protected String defaultWarehouseLocation(TableIdentifier table) {\n+    return SLASH.join(defaultNamespaceLocation(table.namespace()), table.name());\n+  }\n+\n+  @Override\n+  public boolean dropTable(TableIdentifier identifier, boolean purge) {\n+\n+    int deletedRecords;\n+    try {\n+      deletedRecords = connections.run(conn -> {\n+        try (PreparedStatement sql = conn.prepareStatement(JdbcUtil.DROP_TABLE_SQL)) {\n+          sql.setString(1, catalogName);\n+          sql.setString(2, JdbcUtil.namespaceToString(identifier.namespace()));\n+          sql.setString(3, identifier.name());\n+          return sql.executeUpdate();\n+        }\n+      });\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(e, \"Failed to drop %s\", identifier);\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted in call to dropTable\", e);\n+    }\n+\n+    if (deletedRecords > 0) {\n+      LOG.info(\"Successfully dropped table {}.\", identifier);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc9446405e27bbf8d4487dd4142079d5265c7336"}, "originalPosition": 152}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY2MzE2NjE3", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-666316617", "createdAt": "2021-05-23T23:39:07Z", "commit": {"oid": "fc9446405e27bbf8d4487dd4142079d5265c7336"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0yM1QyMzozOTowN1rOJgFFhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0yM1QyMzozOTowN1rOJgFFhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNzYxNzU0MQ==", "bodyText": "I think this should be info. And we should follow the conventions in the HiveCatalog: https://github.com/apache/iceberg/blob/master/hive-metastore/src/main/java/org/apache/iceberg/hive/HiveCatalog.java#L216", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r637617541", "createdAt": "2021-05-23T23:39:07Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.io.Closeable;\n+import java.sql.DatabaseMetaData;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, SupportsNamespaces, Closeable {\n+\n+  public static final String PROPERTY_PREFIX = \"connection.parameter.\";\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcCatalog.class);\n+  private static final Joiner SLASH = Joiner.on(\"/\");\n+\n+  private FileIO io;\n+  private String catalogName = \"jdbc\";\n+  private String warehouseLocation;\n+  private Configuration conf;\n+  private JdbcClientPool connections;\n+\n+  public JdbcCatalog() {\n+  }\n+\n+  @Override\n+  public void initialize(String name, Map<String, String> properties) {\n+    String uri = properties.get(CatalogProperties.URI);\n+    Preconditions.checkNotNull(uri, \"JDBC connection URI is required\");\n+\n+    String warehouse = properties.get(CatalogProperties.WAREHOUSE_LOCATION);\n+    Preconditions.checkNotNull(warehouse, \"JDBC warehouse location is required\");\n+    this.warehouseLocation = warehouse.replaceAll(\"/$\", \"\");\n+\n+    if (name != null) {\n+      this.catalogName = name;\n+    }\n+\n+    String fileIOImpl = properties.get(CatalogProperties.FILE_IO_IMPL);\n+    this.io = fileIOImpl == null ? new HadoopFileIO(conf) : CatalogUtil.loadFileIO(fileIOImpl, properties, conf);\n+\n+    try {\n+      LOG.debug(\"Connecting to Jdbc database {}\", properties.get(CatalogProperties.URI));\n+      connections = new JdbcClientPool(uri, properties);\n+      initializeCatalogTables();\n+    } catch (SQLTimeoutException e) {\n+      throw new UncheckedSQLException(e, \"Cannot initialize jdbc catalog: Query timed out\");\n+    } catch (SQLTransientConnectionException | SQLNonTransientConnectionException e) {\n+      throw new UncheckedSQLException(e, \"Cannot initialize jdbc catalog: Connection failed\");\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(e, \"Cannot initialize jdbc catalog\");\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted in call to initialize\", e);\n+    }\n+  }\n+\n+  private void initializeCatalogTables() throws InterruptedException, SQLException {\n+    LOG.trace(\"Creating database tables (if missing) to store iceberg catalog\");\n+    connections.run(conn -> {\n+      DatabaseMetaData dbMeta = conn.getMetaData();\n+      ResultSet tableExists = dbMeta.getTables(null, null, JdbcUtil.CATALOG_TABLE_NAME, null);\n+\n+      if (tableExists.next()) {\n+        return true;\n+      }\n+\n+      LOG.debug(\"Creating table {} to store iceberg catalog!\", JdbcUtil.CATALOG_TABLE_NAME);\n+      return conn.prepareStatement(JdbcUtil.CREATE_CATALOG_TABLE).execute();\n+    });\n+  }\n+\n+  @Override\n+  protected TableOperations newTableOps(TableIdentifier tableIdentifier) {\n+    return new JdbcTableOperations(connections, io, catalogName, tableIdentifier);\n+  }\n+\n+  @Override\n+  protected String defaultWarehouseLocation(TableIdentifier table) {\n+    return SLASH.join(defaultNamespaceLocation(table.namespace()), table.name());\n+  }\n+\n+  @Override\n+  public boolean dropTable(TableIdentifier identifier, boolean purge) {\n+\n+    int deletedRecords;\n+    try {\n+      deletedRecords = connections.run(conn -> {\n+        try (PreparedStatement sql = conn.prepareStatement(JdbcUtil.DROP_TABLE_SQL)) {\n+          sql.setString(1, catalogName);\n+          sql.setString(2, JdbcUtil.namespaceToString(identifier.namespace()));\n+          sql.setString(3, identifier.name());\n+          return sql.executeUpdate();\n+        }\n+      });\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(e, \"Failed to drop %s\", identifier);\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted in call to dropTable\", e);\n+    }\n+\n+    if (deletedRecords > 0) {\n+      LOG.info(\"Successfully dropped table {}.\", identifier);\n+    } else {\n+      LOG.info(\"Cannot drop table: {}! table not found in the catalog.\", identifier);\n+      return false;\n+    }\n+\n+    TableOperations ops = newTableOps(identifier);\n+    TableMetadata lastMetadata = ops.current();\n+\n+    if (purge && lastMetadata != null) {\n+      CatalogUtil.dropTableData(ops.io(), lastMetadata);\n+      LOG.info(\"Table {} data purged!\", identifier);\n+    }\n+\n+    return true;\n+\n+  }\n+\n+  @Override\n+  public List<TableIdentifier> listTables(Namespace namespace) {\n+    if (!namespaceExists(namespace)) {\n+      throw new NoSuchNamespaceException(\"Namespace does not exist: %s\", namespace);\n+    }\n+\n+    try {\n+      return connections.run(conn -> {\n+        List<TableIdentifier> results = Lists.newArrayList();\n+        try (PreparedStatement sql = conn.prepareStatement(JdbcUtil.LIST_TABLES_SQL)) {\n+          sql.setString(1, catalogName);\n+          sql.setString(2, JdbcUtil.namespaceToString(namespace));\n+\n+          ResultSet rs = sql.executeQuery();\n+          while (rs.next()) {\n+            results.add(JdbcUtil.stringToTableIdentifier(rs.getString(JdbcUtil.TABLE_NAMESPACE), rs.getString(\n+                JdbcUtil.TABLE_NAME)));\n+          }\n+\n+          return results;\n+        }\n+      });\n+\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(e, \"Failed to list tables in namespace: %s\", namespace);\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted during JDBC operation\", e);\n+    }\n+  }\n+\n+  @Override\n+  public void renameTable(TableIdentifier from, TableIdentifier to) {\n+    try {\n+      int updatedRecords = connections.run(conn -> {\n+        try (PreparedStatement sql = conn.prepareStatement(JdbcUtil.RENAME_TABLE_SQL)) {\n+          // SET\n+          sql.setString(1, JdbcUtil.namespaceToString(to.namespace()));\n+          sql.setString(2, to.name());\n+          // WHERE\n+          sql.setString(3, catalogName);\n+          sql.setString(4, JdbcUtil.namespaceToString(from.namespace()));\n+          sql.setString(5, from.name());\n+          return sql.executeUpdate();\n+        }\n+      });\n+\n+      if (updatedRecords == 1) {\n+        LOG.debug(\"Successfully renamed table from {} to {}!\", from, to);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc9446405e27bbf8d4487dd4142079d5265c7336"}, "originalPosition": 218}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY2MzE2OTk4", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-666316998", "createdAt": "2021-05-23T23:42:17Z", "commit": {"oid": "fc9446405e27bbf8d4487dd4142079d5265c7336"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0yM1QyMzo0MjoxN1rOJgFHPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0yM1QyMzo0MjoxN1rOJgFHPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNzYxNzk4MQ==", "bodyText": "This violates our assumption about tables, but it doesn't mean the operation failed. Javadoc states that this will return the number of affected rows or 0. So if this isn't 0 or 1, then it means that more than 1 row was affected and our underlying primary key assumption is violated. I think in that case we want an error message that highlights the problem at WARNING: \"Rename operation affected %s rows: the catalog table's primary key assumption has been violated\"", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r637617981", "createdAt": "2021-05-23T23:42:17Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.io.Closeable;\n+import java.sql.DatabaseMetaData;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, SupportsNamespaces, Closeable {\n+\n+  public static final String PROPERTY_PREFIX = \"connection.parameter.\";\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcCatalog.class);\n+  private static final Joiner SLASH = Joiner.on(\"/\");\n+\n+  private FileIO io;\n+  private String catalogName = \"jdbc\";\n+  private String warehouseLocation;\n+  private Configuration conf;\n+  private JdbcClientPool connections;\n+\n+  public JdbcCatalog() {\n+  }\n+\n+  @Override\n+  public void initialize(String name, Map<String, String> properties) {\n+    String uri = properties.get(CatalogProperties.URI);\n+    Preconditions.checkNotNull(uri, \"JDBC connection URI is required\");\n+\n+    String warehouse = properties.get(CatalogProperties.WAREHOUSE_LOCATION);\n+    Preconditions.checkNotNull(warehouse, \"JDBC warehouse location is required\");\n+    this.warehouseLocation = warehouse.replaceAll(\"/$\", \"\");\n+\n+    if (name != null) {\n+      this.catalogName = name;\n+    }\n+\n+    String fileIOImpl = properties.get(CatalogProperties.FILE_IO_IMPL);\n+    this.io = fileIOImpl == null ? new HadoopFileIO(conf) : CatalogUtil.loadFileIO(fileIOImpl, properties, conf);\n+\n+    try {\n+      LOG.debug(\"Connecting to Jdbc database {}\", properties.get(CatalogProperties.URI));\n+      connections = new JdbcClientPool(uri, properties);\n+      initializeCatalogTables();\n+    } catch (SQLTimeoutException e) {\n+      throw new UncheckedSQLException(e, \"Cannot initialize jdbc catalog: Query timed out\");\n+    } catch (SQLTransientConnectionException | SQLNonTransientConnectionException e) {\n+      throw new UncheckedSQLException(e, \"Cannot initialize jdbc catalog: Connection failed\");\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(e, \"Cannot initialize jdbc catalog\");\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted in call to initialize\", e);\n+    }\n+  }\n+\n+  private void initializeCatalogTables() throws InterruptedException, SQLException {\n+    LOG.trace(\"Creating database tables (if missing) to store iceberg catalog\");\n+    connections.run(conn -> {\n+      DatabaseMetaData dbMeta = conn.getMetaData();\n+      ResultSet tableExists = dbMeta.getTables(null, null, JdbcUtil.CATALOG_TABLE_NAME, null);\n+\n+      if (tableExists.next()) {\n+        return true;\n+      }\n+\n+      LOG.debug(\"Creating table {} to store iceberg catalog!\", JdbcUtil.CATALOG_TABLE_NAME);\n+      return conn.prepareStatement(JdbcUtil.CREATE_CATALOG_TABLE).execute();\n+    });\n+  }\n+\n+  @Override\n+  protected TableOperations newTableOps(TableIdentifier tableIdentifier) {\n+    return new JdbcTableOperations(connections, io, catalogName, tableIdentifier);\n+  }\n+\n+  @Override\n+  protected String defaultWarehouseLocation(TableIdentifier table) {\n+    return SLASH.join(defaultNamespaceLocation(table.namespace()), table.name());\n+  }\n+\n+  @Override\n+  public boolean dropTable(TableIdentifier identifier, boolean purge) {\n+\n+    int deletedRecords;\n+    try {\n+      deletedRecords = connections.run(conn -> {\n+        try (PreparedStatement sql = conn.prepareStatement(JdbcUtil.DROP_TABLE_SQL)) {\n+          sql.setString(1, catalogName);\n+          sql.setString(2, JdbcUtil.namespaceToString(identifier.namespace()));\n+          sql.setString(3, identifier.name());\n+          return sql.executeUpdate();\n+        }\n+      });\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(e, \"Failed to drop %s\", identifier);\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted in call to dropTable\", e);\n+    }\n+\n+    if (deletedRecords > 0) {\n+      LOG.info(\"Successfully dropped table {}.\", identifier);\n+    } else {\n+      LOG.info(\"Cannot drop table: {}! table not found in the catalog.\", identifier);\n+      return false;\n+    }\n+\n+    TableOperations ops = newTableOps(identifier);\n+    TableMetadata lastMetadata = ops.current();\n+\n+    if (purge && lastMetadata != null) {\n+      CatalogUtil.dropTableData(ops.io(), lastMetadata);\n+      LOG.info(\"Table {} data purged!\", identifier);\n+    }\n+\n+    return true;\n+\n+  }\n+\n+  @Override\n+  public List<TableIdentifier> listTables(Namespace namespace) {\n+    if (!namespaceExists(namespace)) {\n+      throw new NoSuchNamespaceException(\"Namespace does not exist: %s\", namespace);\n+    }\n+\n+    try {\n+      return connections.run(conn -> {\n+        List<TableIdentifier> results = Lists.newArrayList();\n+        try (PreparedStatement sql = conn.prepareStatement(JdbcUtil.LIST_TABLES_SQL)) {\n+          sql.setString(1, catalogName);\n+          sql.setString(2, JdbcUtil.namespaceToString(namespace));\n+\n+          ResultSet rs = sql.executeQuery();\n+          while (rs.next()) {\n+            results.add(JdbcUtil.stringToTableIdentifier(rs.getString(JdbcUtil.TABLE_NAMESPACE), rs.getString(\n+                JdbcUtil.TABLE_NAME)));\n+          }\n+\n+          return results;\n+        }\n+      });\n+\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(e, \"Failed to list tables in namespace: %s\", namespace);\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted during JDBC operation\", e);\n+    }\n+  }\n+\n+  @Override\n+  public void renameTable(TableIdentifier from, TableIdentifier to) {\n+    try {\n+      int updatedRecords = connections.run(conn -> {\n+        try (PreparedStatement sql = conn.prepareStatement(JdbcUtil.RENAME_TABLE_SQL)) {\n+          // SET\n+          sql.setString(1, JdbcUtil.namespaceToString(to.namespace()));\n+          sql.setString(2, to.name());\n+          // WHERE\n+          sql.setString(3, catalogName);\n+          sql.setString(4, JdbcUtil.namespaceToString(from.namespace()));\n+          sql.setString(5, from.name());\n+          return sql.executeUpdate();\n+        }\n+      });\n+\n+      if (updatedRecords == 1) {\n+        LOG.debug(\"Successfully renamed table from {} to {}!\", from, to);\n+      } else if (updatedRecords == 0) {\n+        throw new NoSuchTableException(\"Failed to rename table! Table '%s' not found in the catalog!\", from);\n+      } else {\n+        throw new RuntimeException(\"Failed to rename table! Rename operation Failed\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc9446405e27bbf8d4487dd4142079d5265c7336"}, "originalPosition": 222}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY2MzE3MDY5", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-666317069", "createdAt": "2021-05-23T23:42:58Z", "commit": {"oid": "fc9446405e27bbf8d4487dd4142079d5265c7336"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0yM1QyMzo0Mjo1OFrOJgFHdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0yM1QyMzo0Mjo1OFrOJgFHdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNzYxODAzNw==", "bodyText": "We should also mimic the error messages from HiveCatalog: https://github.com/apache/iceberg/blob/master/hive-metastore/src/main/java/org/apache/iceberg/hive/HiveCatalog.java#L222", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r637618037", "createdAt": "2021-05-23T23:42:58Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.io.Closeable;\n+import java.sql.DatabaseMetaData;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, SupportsNamespaces, Closeable {\n+\n+  public static final String PROPERTY_PREFIX = \"connection.parameter.\";\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcCatalog.class);\n+  private static final Joiner SLASH = Joiner.on(\"/\");\n+\n+  private FileIO io;\n+  private String catalogName = \"jdbc\";\n+  private String warehouseLocation;\n+  private Configuration conf;\n+  private JdbcClientPool connections;\n+\n+  public JdbcCatalog() {\n+  }\n+\n+  @Override\n+  public void initialize(String name, Map<String, String> properties) {\n+    String uri = properties.get(CatalogProperties.URI);\n+    Preconditions.checkNotNull(uri, \"JDBC connection URI is required\");\n+\n+    String warehouse = properties.get(CatalogProperties.WAREHOUSE_LOCATION);\n+    Preconditions.checkNotNull(warehouse, \"JDBC warehouse location is required\");\n+    this.warehouseLocation = warehouse.replaceAll(\"/$\", \"\");\n+\n+    if (name != null) {\n+      this.catalogName = name;\n+    }\n+\n+    String fileIOImpl = properties.get(CatalogProperties.FILE_IO_IMPL);\n+    this.io = fileIOImpl == null ? new HadoopFileIO(conf) : CatalogUtil.loadFileIO(fileIOImpl, properties, conf);\n+\n+    try {\n+      LOG.debug(\"Connecting to Jdbc database {}\", properties.get(CatalogProperties.URI));\n+      connections = new JdbcClientPool(uri, properties);\n+      initializeCatalogTables();\n+    } catch (SQLTimeoutException e) {\n+      throw new UncheckedSQLException(e, \"Cannot initialize jdbc catalog: Query timed out\");\n+    } catch (SQLTransientConnectionException | SQLNonTransientConnectionException e) {\n+      throw new UncheckedSQLException(e, \"Cannot initialize jdbc catalog: Connection failed\");\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(e, \"Cannot initialize jdbc catalog\");\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted in call to initialize\", e);\n+    }\n+  }\n+\n+  private void initializeCatalogTables() throws InterruptedException, SQLException {\n+    LOG.trace(\"Creating database tables (if missing) to store iceberg catalog\");\n+    connections.run(conn -> {\n+      DatabaseMetaData dbMeta = conn.getMetaData();\n+      ResultSet tableExists = dbMeta.getTables(null, null, JdbcUtil.CATALOG_TABLE_NAME, null);\n+\n+      if (tableExists.next()) {\n+        return true;\n+      }\n+\n+      LOG.debug(\"Creating table {} to store iceberg catalog!\", JdbcUtil.CATALOG_TABLE_NAME);\n+      return conn.prepareStatement(JdbcUtil.CREATE_CATALOG_TABLE).execute();\n+    });\n+  }\n+\n+  @Override\n+  protected TableOperations newTableOps(TableIdentifier tableIdentifier) {\n+    return new JdbcTableOperations(connections, io, catalogName, tableIdentifier);\n+  }\n+\n+  @Override\n+  protected String defaultWarehouseLocation(TableIdentifier table) {\n+    return SLASH.join(defaultNamespaceLocation(table.namespace()), table.name());\n+  }\n+\n+  @Override\n+  public boolean dropTable(TableIdentifier identifier, boolean purge) {\n+\n+    int deletedRecords;\n+    try {\n+      deletedRecords = connections.run(conn -> {\n+        try (PreparedStatement sql = conn.prepareStatement(JdbcUtil.DROP_TABLE_SQL)) {\n+          sql.setString(1, catalogName);\n+          sql.setString(2, JdbcUtil.namespaceToString(identifier.namespace()));\n+          sql.setString(3, identifier.name());\n+          return sql.executeUpdate();\n+        }\n+      });\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(e, \"Failed to drop %s\", identifier);\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted in call to dropTable\", e);\n+    }\n+\n+    if (deletedRecords > 0) {\n+      LOG.info(\"Successfully dropped table {}.\", identifier);\n+    } else {\n+      LOG.info(\"Cannot drop table: {}! table not found in the catalog.\", identifier);\n+      return false;\n+    }\n+\n+    TableOperations ops = newTableOps(identifier);\n+    TableMetadata lastMetadata = ops.current();\n+\n+    if (purge && lastMetadata != null) {\n+      CatalogUtil.dropTableData(ops.io(), lastMetadata);\n+      LOG.info(\"Table {} data purged!\", identifier);\n+    }\n+\n+    return true;\n+\n+  }\n+\n+  @Override\n+  public List<TableIdentifier> listTables(Namespace namespace) {\n+    if (!namespaceExists(namespace)) {\n+      throw new NoSuchNamespaceException(\"Namespace does not exist: %s\", namespace);\n+    }\n+\n+    try {\n+      return connections.run(conn -> {\n+        List<TableIdentifier> results = Lists.newArrayList();\n+        try (PreparedStatement sql = conn.prepareStatement(JdbcUtil.LIST_TABLES_SQL)) {\n+          sql.setString(1, catalogName);\n+          sql.setString(2, JdbcUtil.namespaceToString(namespace));\n+\n+          ResultSet rs = sql.executeQuery();\n+          while (rs.next()) {\n+            results.add(JdbcUtil.stringToTableIdentifier(rs.getString(JdbcUtil.TABLE_NAMESPACE), rs.getString(\n+                JdbcUtil.TABLE_NAME)));\n+          }\n+\n+          return results;\n+        }\n+      });\n+\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(e, \"Failed to list tables in namespace: %s\", namespace);\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted during JDBC operation\", e);\n+    }\n+  }\n+\n+  @Override\n+  public void renameTable(TableIdentifier from, TableIdentifier to) {\n+    try {\n+      int updatedRecords = connections.run(conn -> {\n+        try (PreparedStatement sql = conn.prepareStatement(JdbcUtil.RENAME_TABLE_SQL)) {\n+          // SET\n+          sql.setString(1, JdbcUtil.namespaceToString(to.namespace()));\n+          sql.setString(2, to.name());\n+          // WHERE\n+          sql.setString(3, catalogName);\n+          sql.setString(4, JdbcUtil.namespaceToString(from.namespace()));\n+          sql.setString(5, from.name());\n+          return sql.executeUpdate();\n+        }\n+      });\n+\n+      if (updatedRecords == 1) {\n+        LOG.debug(\"Successfully renamed table from {} to {}!\", from, to);\n+      } else if (updatedRecords == 0) {\n+        throw new NoSuchTableException(\"Failed to rename table! Table '%s' not found in the catalog!\", from);\n+      } else {\n+        throw new RuntimeException(\"Failed to rename table! Rename operation Failed\");\n+      }\n+\n+    } catch (SQLIntegrityConstraintViolationException e) {\n+      throw new AlreadyExistsException(\"Table with name '%s' already exists in the catalog!\", to);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc9446405e27bbf8d4487dd4142079d5265c7336"}, "originalPosition": 226}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY2MzE3MjE1", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-666317215", "createdAt": "2021-05-23T23:44:02Z", "commit": {"oid": "fc9446405e27bbf8d4487dd4142079d5265c7336"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0yM1QyMzo0NDowMlrOJgFIJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0yM1QyMzo0NDowMlrOJgFIJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNzYxODIxNA==", "bodyText": "Nit: no need for a newline here.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r637618214", "createdAt": "2021-05-23T23:44:02Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.io.Closeable;\n+import java.sql.DatabaseMetaData;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, SupportsNamespaces, Closeable {\n+\n+  public static final String PROPERTY_PREFIX = \"connection.parameter.\";\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcCatalog.class);\n+  private static final Joiner SLASH = Joiner.on(\"/\");\n+\n+  private FileIO io;\n+  private String catalogName = \"jdbc\";\n+  private String warehouseLocation;\n+  private Configuration conf;\n+  private JdbcClientPool connections;\n+\n+  public JdbcCatalog() {\n+  }\n+\n+  @Override\n+  public void initialize(String name, Map<String, String> properties) {\n+    String uri = properties.get(CatalogProperties.URI);\n+    Preconditions.checkNotNull(uri, \"JDBC connection URI is required\");\n+\n+    String warehouse = properties.get(CatalogProperties.WAREHOUSE_LOCATION);\n+    Preconditions.checkNotNull(warehouse, \"JDBC warehouse location is required\");\n+    this.warehouseLocation = warehouse.replaceAll(\"/$\", \"\");\n+\n+    if (name != null) {\n+      this.catalogName = name;\n+    }\n+\n+    String fileIOImpl = properties.get(CatalogProperties.FILE_IO_IMPL);\n+    this.io = fileIOImpl == null ? new HadoopFileIO(conf) : CatalogUtil.loadFileIO(fileIOImpl, properties, conf);\n+\n+    try {\n+      LOG.debug(\"Connecting to Jdbc database {}\", properties.get(CatalogProperties.URI));\n+      connections = new JdbcClientPool(uri, properties);\n+      initializeCatalogTables();\n+    } catch (SQLTimeoutException e) {\n+      throw new UncheckedSQLException(e, \"Cannot initialize jdbc catalog: Query timed out\");\n+    } catch (SQLTransientConnectionException | SQLNonTransientConnectionException e) {\n+      throw new UncheckedSQLException(e, \"Cannot initialize jdbc catalog: Connection failed\");\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(e, \"Cannot initialize jdbc catalog\");\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted in call to initialize\", e);\n+    }\n+  }\n+\n+  private void initializeCatalogTables() throws InterruptedException, SQLException {\n+    LOG.trace(\"Creating database tables (if missing) to store iceberg catalog\");\n+    connections.run(conn -> {\n+      DatabaseMetaData dbMeta = conn.getMetaData();\n+      ResultSet tableExists = dbMeta.getTables(null, null, JdbcUtil.CATALOG_TABLE_NAME, null);\n+\n+      if (tableExists.next()) {\n+        return true;\n+      }\n+\n+      LOG.debug(\"Creating table {} to store iceberg catalog!\", JdbcUtil.CATALOG_TABLE_NAME);\n+      return conn.prepareStatement(JdbcUtil.CREATE_CATALOG_TABLE).execute();\n+    });\n+  }\n+\n+  @Override\n+  protected TableOperations newTableOps(TableIdentifier tableIdentifier) {\n+    return new JdbcTableOperations(connections, io, catalogName, tableIdentifier);\n+  }\n+\n+  @Override\n+  protected String defaultWarehouseLocation(TableIdentifier table) {\n+    return SLASH.join(defaultNamespaceLocation(table.namespace()), table.name());\n+  }\n+\n+  @Override\n+  public boolean dropTable(TableIdentifier identifier, boolean purge) {\n+\n+    int deletedRecords;\n+    try {\n+      deletedRecords = connections.run(conn -> {\n+        try (PreparedStatement sql = conn.prepareStatement(JdbcUtil.DROP_TABLE_SQL)) {\n+          sql.setString(1, catalogName);\n+          sql.setString(2, JdbcUtil.namespaceToString(identifier.namespace()));\n+          sql.setString(3, identifier.name());\n+          return sql.executeUpdate();\n+        }\n+      });\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(e, \"Failed to drop %s\", identifier);\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted in call to dropTable\", e);\n+    }\n+\n+    if (deletedRecords > 0) {\n+      LOG.info(\"Successfully dropped table {}.\", identifier);\n+    } else {\n+      LOG.info(\"Cannot drop table: {}! table not found in the catalog.\", identifier);\n+      return false;\n+    }\n+\n+    TableOperations ops = newTableOps(identifier);\n+    TableMetadata lastMetadata = ops.current();\n+\n+    if (purge && lastMetadata != null) {\n+      CatalogUtil.dropTableData(ops.io(), lastMetadata);\n+      LOG.info(\"Table {} data purged!\", identifier);\n+    }\n+\n+    return true;\n+\n+  }\n+\n+  @Override\n+  public List<TableIdentifier> listTables(Namespace namespace) {\n+    if (!namespaceExists(namespace)) {\n+      throw new NoSuchNamespaceException(\"Namespace does not exist: %s\", namespace);\n+    }\n+\n+    try {\n+      return connections.run(conn -> {\n+        List<TableIdentifier> results = Lists.newArrayList();\n+        try (PreparedStatement sql = conn.prepareStatement(JdbcUtil.LIST_TABLES_SQL)) {\n+          sql.setString(1, catalogName);\n+          sql.setString(2, JdbcUtil.namespaceToString(namespace));\n+\n+          ResultSet rs = sql.executeQuery();\n+          while (rs.next()) {\n+            results.add(JdbcUtil.stringToTableIdentifier(rs.getString(JdbcUtil.TABLE_NAMESPACE), rs.getString(\n+                JdbcUtil.TABLE_NAME)));\n+          }\n+\n+          return results;\n+        }\n+      });\n+\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(e, \"Failed to list tables in namespace: %s\", namespace);\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted during JDBC operation\", e);\n+    }\n+  }\n+\n+  @Override\n+  public void renameTable(TableIdentifier from, TableIdentifier to) {\n+    try {\n+      int updatedRecords = connections.run(conn -> {\n+        try (PreparedStatement sql = conn.prepareStatement(JdbcUtil.RENAME_TABLE_SQL)) {\n+          // SET\n+          sql.setString(1, JdbcUtil.namespaceToString(to.namespace()));\n+          sql.setString(2, to.name());\n+          // WHERE\n+          sql.setString(3, catalogName);\n+          sql.setString(4, JdbcUtil.namespaceToString(from.namespace()));\n+          sql.setString(5, from.name());\n+          return sql.executeUpdate();\n+        }\n+      });\n+\n+      if (updatedRecords == 1) {\n+        LOG.debug(\"Successfully renamed table from {} to {}!\", from, to);\n+      } else if (updatedRecords == 0) {\n+        throw new NoSuchTableException(\"Failed to rename table! Table '%s' not found in the catalog!\", from);\n+      } else {\n+        throw new RuntimeException(\"Failed to rename table! Rename operation Failed\");\n+      }\n+\n+    } catch (SQLIntegrityConstraintViolationException e) {\n+      throw new AlreadyExistsException(\"Table with name '%s' already exists in the catalog!\", to);\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(e, \"Failed to rename table\");\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted in call to rename\", e);\n+    }\n+  }\n+\n+  @Override\n+  public String name() {\n+    return catalogName;\n+  }\n+\n+  @Override\n+  public Configuration getConf() {\n+    return conf;\n+  }\n+\n+  @Override\n+  public void setConf(Configuration conf) {\n+    this.conf = conf;\n+  }\n+\n+  @Override\n+  public void createNamespace(Namespace namespace, Map<String, String> metadata) {\n+    throw new UnsupportedOperationException(\"Cannot create namespace \" + namespace +\n+        \": createNamespace is not supported\");\n+  }\n+\n+  @Override\n+  public List<Namespace> listNamespaces(Namespace namespace) throws NoSuchNamespaceException {\n+    if (!namespaceExists(namespace)) {\n+      throw new NoSuchNamespaceException(\"Namespace does not exist: %s\", namespace);\n+    }\n+\n+    try {\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc9446405e27bbf8d4487dd4142079d5265c7336"}, "originalPosition": 263}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY2MzE3NDk5", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-666317499", "createdAt": "2021-05-23T23:46:36Z", "commit": {"oid": "fc9446405e27bbf8d4487dd4142079d5265c7336"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0yM1QyMzo0NjozNlrOJgFJNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0yM1QyMzo0NjozNlrOJgFJNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNzYxODQ4NA==", "bodyText": "I prefer not to add logs like this that take up so much space. Debug is okay, but in general I would avoid logs that simply state what happened (and in verbose detail) during normal execution unless it is a significant state change for the DB (like renamed, dropped, or created).", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r637618484", "createdAt": "2021-05-23T23:46:36Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.io.Closeable;\n+import java.sql.DatabaseMetaData;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, SupportsNamespaces, Closeable {\n+\n+  public static final String PROPERTY_PREFIX = \"connection.parameter.\";\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcCatalog.class);\n+  private static final Joiner SLASH = Joiner.on(\"/\");\n+\n+  private FileIO io;\n+  private String catalogName = \"jdbc\";\n+  private String warehouseLocation;\n+  private Configuration conf;\n+  private JdbcClientPool connections;\n+\n+  public JdbcCatalog() {\n+  }\n+\n+  @Override\n+  public void initialize(String name, Map<String, String> properties) {\n+    String uri = properties.get(CatalogProperties.URI);\n+    Preconditions.checkNotNull(uri, \"JDBC connection URI is required\");\n+\n+    String warehouse = properties.get(CatalogProperties.WAREHOUSE_LOCATION);\n+    Preconditions.checkNotNull(warehouse, \"JDBC warehouse location is required\");\n+    this.warehouseLocation = warehouse.replaceAll(\"/$\", \"\");\n+\n+    if (name != null) {\n+      this.catalogName = name;\n+    }\n+\n+    String fileIOImpl = properties.get(CatalogProperties.FILE_IO_IMPL);\n+    this.io = fileIOImpl == null ? new HadoopFileIO(conf) : CatalogUtil.loadFileIO(fileIOImpl, properties, conf);\n+\n+    try {\n+      LOG.debug(\"Connecting to Jdbc database {}\", properties.get(CatalogProperties.URI));\n+      connections = new JdbcClientPool(uri, properties);\n+      initializeCatalogTables();\n+    } catch (SQLTimeoutException e) {\n+      throw new UncheckedSQLException(e, \"Cannot initialize jdbc catalog: Query timed out\");\n+    } catch (SQLTransientConnectionException | SQLNonTransientConnectionException e) {\n+      throw new UncheckedSQLException(e, \"Cannot initialize jdbc catalog: Connection failed\");\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(e, \"Cannot initialize jdbc catalog\");\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted in call to initialize\", e);\n+    }\n+  }\n+\n+  private void initializeCatalogTables() throws InterruptedException, SQLException {\n+    LOG.trace(\"Creating database tables (if missing) to store iceberg catalog\");\n+    connections.run(conn -> {\n+      DatabaseMetaData dbMeta = conn.getMetaData();\n+      ResultSet tableExists = dbMeta.getTables(null, null, JdbcUtil.CATALOG_TABLE_NAME, null);\n+\n+      if (tableExists.next()) {\n+        return true;\n+      }\n+\n+      LOG.debug(\"Creating table {} to store iceberg catalog!\", JdbcUtil.CATALOG_TABLE_NAME);\n+      return conn.prepareStatement(JdbcUtil.CREATE_CATALOG_TABLE).execute();\n+    });\n+  }\n+\n+  @Override\n+  protected TableOperations newTableOps(TableIdentifier tableIdentifier) {\n+    return new JdbcTableOperations(connections, io, catalogName, tableIdentifier);\n+  }\n+\n+  @Override\n+  protected String defaultWarehouseLocation(TableIdentifier table) {\n+    return SLASH.join(defaultNamespaceLocation(table.namespace()), table.name());\n+  }\n+\n+  @Override\n+  public boolean dropTable(TableIdentifier identifier, boolean purge) {\n+\n+    int deletedRecords;\n+    try {\n+      deletedRecords = connections.run(conn -> {\n+        try (PreparedStatement sql = conn.prepareStatement(JdbcUtil.DROP_TABLE_SQL)) {\n+          sql.setString(1, catalogName);\n+          sql.setString(2, JdbcUtil.namespaceToString(identifier.namespace()));\n+          sql.setString(3, identifier.name());\n+          return sql.executeUpdate();\n+        }\n+      });\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(e, \"Failed to drop %s\", identifier);\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted in call to dropTable\", e);\n+    }\n+\n+    if (deletedRecords > 0) {\n+      LOG.info(\"Successfully dropped table {}.\", identifier);\n+    } else {\n+      LOG.info(\"Cannot drop table: {}! table not found in the catalog.\", identifier);\n+      return false;\n+    }\n+\n+    TableOperations ops = newTableOps(identifier);\n+    TableMetadata lastMetadata = ops.current();\n+\n+    if (purge && lastMetadata != null) {\n+      CatalogUtil.dropTableData(ops.io(), lastMetadata);\n+      LOG.info(\"Table {} data purged!\", identifier);\n+    }\n+\n+    return true;\n+\n+  }\n+\n+  @Override\n+  public List<TableIdentifier> listTables(Namespace namespace) {\n+    if (!namespaceExists(namespace)) {\n+      throw new NoSuchNamespaceException(\"Namespace does not exist: %s\", namespace);\n+    }\n+\n+    try {\n+      return connections.run(conn -> {\n+        List<TableIdentifier> results = Lists.newArrayList();\n+        try (PreparedStatement sql = conn.prepareStatement(JdbcUtil.LIST_TABLES_SQL)) {\n+          sql.setString(1, catalogName);\n+          sql.setString(2, JdbcUtil.namespaceToString(namespace));\n+\n+          ResultSet rs = sql.executeQuery();\n+          while (rs.next()) {\n+            results.add(JdbcUtil.stringToTableIdentifier(rs.getString(JdbcUtil.TABLE_NAMESPACE), rs.getString(\n+                JdbcUtil.TABLE_NAME)));\n+          }\n+\n+          return results;\n+        }\n+      });\n+\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(e, \"Failed to list tables in namespace: %s\", namespace);\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted during JDBC operation\", e);\n+    }\n+  }\n+\n+  @Override\n+  public void renameTable(TableIdentifier from, TableIdentifier to) {\n+    try {\n+      int updatedRecords = connections.run(conn -> {\n+        try (PreparedStatement sql = conn.prepareStatement(JdbcUtil.RENAME_TABLE_SQL)) {\n+          // SET\n+          sql.setString(1, JdbcUtil.namespaceToString(to.namespace()));\n+          sql.setString(2, to.name());\n+          // WHERE\n+          sql.setString(3, catalogName);\n+          sql.setString(4, JdbcUtil.namespaceToString(from.namespace()));\n+          sql.setString(5, from.name());\n+          return sql.executeUpdate();\n+        }\n+      });\n+\n+      if (updatedRecords == 1) {\n+        LOG.debug(\"Successfully renamed table from {} to {}!\", from, to);\n+      } else if (updatedRecords == 0) {\n+        throw new NoSuchTableException(\"Failed to rename table! Table '%s' not found in the catalog!\", from);\n+      } else {\n+        throw new RuntimeException(\"Failed to rename table! Rename operation Failed\");\n+      }\n+\n+    } catch (SQLIntegrityConstraintViolationException e) {\n+      throw new AlreadyExistsException(\"Table with name '%s' already exists in the catalog!\", to);\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(e, \"Failed to rename table\");\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted in call to rename\", e);\n+    }\n+  }\n+\n+  @Override\n+  public String name() {\n+    return catalogName;\n+  }\n+\n+  @Override\n+  public Configuration getConf() {\n+    return conf;\n+  }\n+\n+  @Override\n+  public void setConf(Configuration conf) {\n+    this.conf = conf;\n+  }\n+\n+  @Override\n+  public void createNamespace(Namespace namespace, Map<String, String> metadata) {\n+    throw new UnsupportedOperationException(\"Cannot create namespace \" + namespace +\n+        \": createNamespace is not supported\");\n+  }\n+\n+  @Override\n+  public List<Namespace> listNamespaces(Namespace namespace) throws NoSuchNamespaceException {\n+    if (!namespaceExists(namespace)) {\n+      throw new NoSuchNamespaceException(\"Namespace does not exist: %s\", namespace);\n+    }\n+\n+    try {\n+\n+      List<Namespace> namespaces = connections.run(conn -> {\n+        List<Namespace> result = Lists.newArrayList();\n+\n+        try (PreparedStatement sql = conn.prepareStatement(JdbcUtil.LIST_NAMESPACES_SQL)) {\n+          sql.setString(1, catalogName);\n+          sql.setString(2, JdbcUtil.namespaceToString(namespace) + \"%\");\n+          ResultSet rs = sql.executeQuery();\n+          while (rs.next()) {\n+            result.add(JdbcUtil.stringToNamespace(rs.getString(JdbcUtil.TABLE_NAMESPACE)));\n+          }\n+          rs.close();\n+        }\n+\n+        return result;\n+      });\n+\n+      int subNamespaceLevelLength = namespace.levels().length + 1;\n+      namespaces = namespaces.stream()\n+          // exclude itself\n+          .filter(n -> !n.equals(namespace))\n+          // only get sub namespaces/children\n+          .filter(n -> n.levels().length >= subNamespaceLevelLength)\n+          // only get sub namespaces/children\n+          .map(n -> Namespace.of(\n+              Arrays.stream(n.levels()).limit(subNamespaceLevelLength).toArray(String[]::new)\n+              )\n+          )\n+          // remove duplicates\n+          .distinct()\n+          .collect(Collectors.toList());\n+\n+      LOG.debug(\"From the namespace '{}' found: {}\", namespace, namespaces);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc9446405e27bbf8d4487dd4142079d5265c7336"}, "originalPosition": 295}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY2MzE3NjQ5", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-666317649", "createdAt": "2021-05-23T23:48:10Z", "commit": {"oid": "fc9446405e27bbf8d4487dd4142079d5265c7336"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0yM1QyMzo0ODoxMFrOJgFJ6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0yM1QyMzo0ODoxMFrOJgFJ6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNzYxODY2NA==", "bodyText": "defaultNamespaceLocation supports empty namespaces. Why did you choose to reject empty here?", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r637618664", "createdAt": "2021-05-23T23:48:10Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.io.Closeable;\n+import java.sql.DatabaseMetaData;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, SupportsNamespaces, Closeable {\n+\n+  public static final String PROPERTY_PREFIX = \"connection.parameter.\";\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcCatalog.class);\n+  private static final Joiner SLASH = Joiner.on(\"/\");\n+\n+  private FileIO io;\n+  private String catalogName = \"jdbc\";\n+  private String warehouseLocation;\n+  private Configuration conf;\n+  private JdbcClientPool connections;\n+\n+  public JdbcCatalog() {\n+  }\n+\n+  @Override\n+  public void initialize(String name, Map<String, String> properties) {\n+    String uri = properties.get(CatalogProperties.URI);\n+    Preconditions.checkNotNull(uri, \"JDBC connection URI is required\");\n+\n+    String warehouse = properties.get(CatalogProperties.WAREHOUSE_LOCATION);\n+    Preconditions.checkNotNull(warehouse, \"JDBC warehouse location is required\");\n+    this.warehouseLocation = warehouse.replaceAll(\"/$\", \"\");\n+\n+    if (name != null) {\n+      this.catalogName = name;\n+    }\n+\n+    String fileIOImpl = properties.get(CatalogProperties.FILE_IO_IMPL);\n+    this.io = fileIOImpl == null ? new HadoopFileIO(conf) : CatalogUtil.loadFileIO(fileIOImpl, properties, conf);\n+\n+    try {\n+      LOG.debug(\"Connecting to Jdbc database {}\", properties.get(CatalogProperties.URI));\n+      connections = new JdbcClientPool(uri, properties);\n+      initializeCatalogTables();\n+    } catch (SQLTimeoutException e) {\n+      throw new UncheckedSQLException(e, \"Cannot initialize jdbc catalog: Query timed out\");\n+    } catch (SQLTransientConnectionException | SQLNonTransientConnectionException e) {\n+      throw new UncheckedSQLException(e, \"Cannot initialize jdbc catalog: Connection failed\");\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(e, \"Cannot initialize jdbc catalog\");\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted in call to initialize\", e);\n+    }\n+  }\n+\n+  private void initializeCatalogTables() throws InterruptedException, SQLException {\n+    LOG.trace(\"Creating database tables (if missing) to store iceberg catalog\");\n+    connections.run(conn -> {\n+      DatabaseMetaData dbMeta = conn.getMetaData();\n+      ResultSet tableExists = dbMeta.getTables(null, null, JdbcUtil.CATALOG_TABLE_NAME, null);\n+\n+      if (tableExists.next()) {\n+        return true;\n+      }\n+\n+      LOG.debug(\"Creating table {} to store iceberg catalog!\", JdbcUtil.CATALOG_TABLE_NAME);\n+      return conn.prepareStatement(JdbcUtil.CREATE_CATALOG_TABLE).execute();\n+    });\n+  }\n+\n+  @Override\n+  protected TableOperations newTableOps(TableIdentifier tableIdentifier) {\n+    return new JdbcTableOperations(connections, io, catalogName, tableIdentifier);\n+  }\n+\n+  @Override\n+  protected String defaultWarehouseLocation(TableIdentifier table) {\n+    return SLASH.join(defaultNamespaceLocation(table.namespace()), table.name());\n+  }\n+\n+  @Override\n+  public boolean dropTable(TableIdentifier identifier, boolean purge) {\n+\n+    int deletedRecords;\n+    try {\n+      deletedRecords = connections.run(conn -> {\n+        try (PreparedStatement sql = conn.prepareStatement(JdbcUtil.DROP_TABLE_SQL)) {\n+          sql.setString(1, catalogName);\n+          sql.setString(2, JdbcUtil.namespaceToString(identifier.namespace()));\n+          sql.setString(3, identifier.name());\n+          return sql.executeUpdate();\n+        }\n+      });\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(e, \"Failed to drop %s\", identifier);\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted in call to dropTable\", e);\n+    }\n+\n+    if (deletedRecords > 0) {\n+      LOG.info(\"Successfully dropped table {}.\", identifier);\n+    } else {\n+      LOG.info(\"Cannot drop table: {}! table not found in the catalog.\", identifier);\n+      return false;\n+    }\n+\n+    TableOperations ops = newTableOps(identifier);\n+    TableMetadata lastMetadata = ops.current();\n+\n+    if (purge && lastMetadata != null) {\n+      CatalogUtil.dropTableData(ops.io(), lastMetadata);\n+      LOG.info(\"Table {} data purged!\", identifier);\n+    }\n+\n+    return true;\n+\n+  }\n+\n+  @Override\n+  public List<TableIdentifier> listTables(Namespace namespace) {\n+    if (!namespaceExists(namespace)) {\n+      throw new NoSuchNamespaceException(\"Namespace does not exist: %s\", namespace);\n+    }\n+\n+    try {\n+      return connections.run(conn -> {\n+        List<TableIdentifier> results = Lists.newArrayList();\n+        try (PreparedStatement sql = conn.prepareStatement(JdbcUtil.LIST_TABLES_SQL)) {\n+          sql.setString(1, catalogName);\n+          sql.setString(2, JdbcUtil.namespaceToString(namespace));\n+\n+          ResultSet rs = sql.executeQuery();\n+          while (rs.next()) {\n+            results.add(JdbcUtil.stringToTableIdentifier(rs.getString(JdbcUtil.TABLE_NAMESPACE), rs.getString(\n+                JdbcUtil.TABLE_NAME)));\n+          }\n+\n+          return results;\n+        }\n+      });\n+\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(e, \"Failed to list tables in namespace: %s\", namespace);\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted during JDBC operation\", e);\n+    }\n+  }\n+\n+  @Override\n+  public void renameTable(TableIdentifier from, TableIdentifier to) {\n+    try {\n+      int updatedRecords = connections.run(conn -> {\n+        try (PreparedStatement sql = conn.prepareStatement(JdbcUtil.RENAME_TABLE_SQL)) {\n+          // SET\n+          sql.setString(1, JdbcUtil.namespaceToString(to.namespace()));\n+          sql.setString(2, to.name());\n+          // WHERE\n+          sql.setString(3, catalogName);\n+          sql.setString(4, JdbcUtil.namespaceToString(from.namespace()));\n+          sql.setString(5, from.name());\n+          return sql.executeUpdate();\n+        }\n+      });\n+\n+      if (updatedRecords == 1) {\n+        LOG.debug(\"Successfully renamed table from {} to {}!\", from, to);\n+      } else if (updatedRecords == 0) {\n+        throw new NoSuchTableException(\"Failed to rename table! Table '%s' not found in the catalog!\", from);\n+      } else {\n+        throw new RuntimeException(\"Failed to rename table! Rename operation Failed\");\n+      }\n+\n+    } catch (SQLIntegrityConstraintViolationException e) {\n+      throw new AlreadyExistsException(\"Table with name '%s' already exists in the catalog!\", to);\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(e, \"Failed to rename table\");\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted in call to rename\", e);\n+    }\n+  }\n+\n+  @Override\n+  public String name() {\n+    return catalogName;\n+  }\n+\n+  @Override\n+  public Configuration getConf() {\n+    return conf;\n+  }\n+\n+  @Override\n+  public void setConf(Configuration conf) {\n+    this.conf = conf;\n+  }\n+\n+  @Override\n+  public void createNamespace(Namespace namespace, Map<String, String> metadata) {\n+    throw new UnsupportedOperationException(\"Cannot create namespace \" + namespace +\n+        \": createNamespace is not supported\");\n+  }\n+\n+  @Override\n+  public List<Namespace> listNamespaces(Namespace namespace) throws NoSuchNamespaceException {\n+    if (!namespaceExists(namespace)) {\n+      throw new NoSuchNamespaceException(\"Namespace does not exist: %s\", namespace);\n+    }\n+\n+    try {\n+\n+      List<Namespace> namespaces = connections.run(conn -> {\n+        List<Namespace> result = Lists.newArrayList();\n+\n+        try (PreparedStatement sql = conn.prepareStatement(JdbcUtil.LIST_NAMESPACES_SQL)) {\n+          sql.setString(1, catalogName);\n+          sql.setString(2, JdbcUtil.namespaceToString(namespace) + \"%\");\n+          ResultSet rs = sql.executeQuery();\n+          while (rs.next()) {\n+            result.add(JdbcUtil.stringToNamespace(rs.getString(JdbcUtil.TABLE_NAMESPACE)));\n+          }\n+          rs.close();\n+        }\n+\n+        return result;\n+      });\n+\n+      int subNamespaceLevelLength = namespace.levels().length + 1;\n+      namespaces = namespaces.stream()\n+          // exclude itself\n+          .filter(n -> !n.equals(namespace))\n+          // only get sub namespaces/children\n+          .filter(n -> n.levels().length >= subNamespaceLevelLength)\n+          // only get sub namespaces/children\n+          .map(n -> Namespace.of(\n+              Arrays.stream(n.levels()).limit(subNamespaceLevelLength).toArray(String[]::new)\n+              )\n+          )\n+          // remove duplicates\n+          .distinct()\n+          .collect(Collectors.toList());\n+\n+      LOG.debug(\"From the namespace '{}' found: {}\", namespace, namespaces);\n+      return namespaces;\n+\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted in call to listNamespaces(namespace) Namespace: \" + namespace, e);\n+    } catch (SQLException e) {\n+      throw new RuntimeException(\"Failed to list all namespace: \" + namespace + \" in catalog!\", e);\n+    }\n+  }\n+\n+  @Override\n+  public Map<String, String> loadNamespaceMetadata(Namespace namespace) throws NoSuchNamespaceException {\n+    if (!namespaceExists(namespace) || namespace.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc9446405e27bbf8d4487dd4142079d5265c7336"}, "originalPosition": 308}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY2MzE3NzMy", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-666317732", "createdAt": "2021-05-23T23:48:51Z", "commit": {"oid": "fc9446405e27bbf8d4487dd4142079d5265c7336"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0yM1QyMzo0ODo1MVrOJgFKTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0yM1QyMzo0ODo1MVrOJgFKTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNzYxODc2NQ==", "bodyText": "No need to list tables, and because can be replaced with :", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r637618765", "createdAt": "2021-05-23T23:48:51Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.io.Closeable;\n+import java.sql.DatabaseMetaData;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, SupportsNamespaces, Closeable {\n+\n+  public static final String PROPERTY_PREFIX = \"connection.parameter.\";\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcCatalog.class);\n+  private static final Joiner SLASH = Joiner.on(\"/\");\n+\n+  private FileIO io;\n+  private String catalogName = \"jdbc\";\n+  private String warehouseLocation;\n+  private Configuration conf;\n+  private JdbcClientPool connections;\n+\n+  public JdbcCatalog() {\n+  }\n+\n+  @Override\n+  public void initialize(String name, Map<String, String> properties) {\n+    String uri = properties.get(CatalogProperties.URI);\n+    Preconditions.checkNotNull(uri, \"JDBC connection URI is required\");\n+\n+    String warehouse = properties.get(CatalogProperties.WAREHOUSE_LOCATION);\n+    Preconditions.checkNotNull(warehouse, \"JDBC warehouse location is required\");\n+    this.warehouseLocation = warehouse.replaceAll(\"/$\", \"\");\n+\n+    if (name != null) {\n+      this.catalogName = name;\n+    }\n+\n+    String fileIOImpl = properties.get(CatalogProperties.FILE_IO_IMPL);\n+    this.io = fileIOImpl == null ? new HadoopFileIO(conf) : CatalogUtil.loadFileIO(fileIOImpl, properties, conf);\n+\n+    try {\n+      LOG.debug(\"Connecting to Jdbc database {}\", properties.get(CatalogProperties.URI));\n+      connections = new JdbcClientPool(uri, properties);\n+      initializeCatalogTables();\n+    } catch (SQLTimeoutException e) {\n+      throw new UncheckedSQLException(e, \"Cannot initialize jdbc catalog: Query timed out\");\n+    } catch (SQLTransientConnectionException | SQLNonTransientConnectionException e) {\n+      throw new UncheckedSQLException(e, \"Cannot initialize jdbc catalog: Connection failed\");\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(e, \"Cannot initialize jdbc catalog\");\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted in call to initialize\", e);\n+    }\n+  }\n+\n+  private void initializeCatalogTables() throws InterruptedException, SQLException {\n+    LOG.trace(\"Creating database tables (if missing) to store iceberg catalog\");\n+    connections.run(conn -> {\n+      DatabaseMetaData dbMeta = conn.getMetaData();\n+      ResultSet tableExists = dbMeta.getTables(null, null, JdbcUtil.CATALOG_TABLE_NAME, null);\n+\n+      if (tableExists.next()) {\n+        return true;\n+      }\n+\n+      LOG.debug(\"Creating table {} to store iceberg catalog!\", JdbcUtil.CATALOG_TABLE_NAME);\n+      return conn.prepareStatement(JdbcUtil.CREATE_CATALOG_TABLE).execute();\n+    });\n+  }\n+\n+  @Override\n+  protected TableOperations newTableOps(TableIdentifier tableIdentifier) {\n+    return new JdbcTableOperations(connections, io, catalogName, tableIdentifier);\n+  }\n+\n+  @Override\n+  protected String defaultWarehouseLocation(TableIdentifier table) {\n+    return SLASH.join(defaultNamespaceLocation(table.namespace()), table.name());\n+  }\n+\n+  @Override\n+  public boolean dropTable(TableIdentifier identifier, boolean purge) {\n+\n+    int deletedRecords;\n+    try {\n+      deletedRecords = connections.run(conn -> {\n+        try (PreparedStatement sql = conn.prepareStatement(JdbcUtil.DROP_TABLE_SQL)) {\n+          sql.setString(1, catalogName);\n+          sql.setString(2, JdbcUtil.namespaceToString(identifier.namespace()));\n+          sql.setString(3, identifier.name());\n+          return sql.executeUpdate();\n+        }\n+      });\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(e, \"Failed to drop %s\", identifier);\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted in call to dropTable\", e);\n+    }\n+\n+    if (deletedRecords > 0) {\n+      LOG.info(\"Successfully dropped table {}.\", identifier);\n+    } else {\n+      LOG.info(\"Cannot drop table: {}! table not found in the catalog.\", identifier);\n+      return false;\n+    }\n+\n+    TableOperations ops = newTableOps(identifier);\n+    TableMetadata lastMetadata = ops.current();\n+\n+    if (purge && lastMetadata != null) {\n+      CatalogUtil.dropTableData(ops.io(), lastMetadata);\n+      LOG.info(\"Table {} data purged!\", identifier);\n+    }\n+\n+    return true;\n+\n+  }\n+\n+  @Override\n+  public List<TableIdentifier> listTables(Namespace namespace) {\n+    if (!namespaceExists(namespace)) {\n+      throw new NoSuchNamespaceException(\"Namespace does not exist: %s\", namespace);\n+    }\n+\n+    try {\n+      return connections.run(conn -> {\n+        List<TableIdentifier> results = Lists.newArrayList();\n+        try (PreparedStatement sql = conn.prepareStatement(JdbcUtil.LIST_TABLES_SQL)) {\n+          sql.setString(1, catalogName);\n+          sql.setString(2, JdbcUtil.namespaceToString(namespace));\n+\n+          ResultSet rs = sql.executeQuery();\n+          while (rs.next()) {\n+            results.add(JdbcUtil.stringToTableIdentifier(rs.getString(JdbcUtil.TABLE_NAMESPACE), rs.getString(\n+                JdbcUtil.TABLE_NAME)));\n+          }\n+\n+          return results;\n+        }\n+      });\n+\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(e, \"Failed to list tables in namespace: %s\", namespace);\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted during JDBC operation\", e);\n+    }\n+  }\n+\n+  @Override\n+  public void renameTable(TableIdentifier from, TableIdentifier to) {\n+    try {\n+      int updatedRecords = connections.run(conn -> {\n+        try (PreparedStatement sql = conn.prepareStatement(JdbcUtil.RENAME_TABLE_SQL)) {\n+          // SET\n+          sql.setString(1, JdbcUtil.namespaceToString(to.namespace()));\n+          sql.setString(2, to.name());\n+          // WHERE\n+          sql.setString(3, catalogName);\n+          sql.setString(4, JdbcUtil.namespaceToString(from.namespace()));\n+          sql.setString(5, from.name());\n+          return sql.executeUpdate();\n+        }\n+      });\n+\n+      if (updatedRecords == 1) {\n+        LOG.debug(\"Successfully renamed table from {} to {}!\", from, to);\n+      } else if (updatedRecords == 0) {\n+        throw new NoSuchTableException(\"Failed to rename table! Table '%s' not found in the catalog!\", from);\n+      } else {\n+        throw new RuntimeException(\"Failed to rename table! Rename operation Failed\");\n+      }\n+\n+    } catch (SQLIntegrityConstraintViolationException e) {\n+      throw new AlreadyExistsException(\"Table with name '%s' already exists in the catalog!\", to);\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(e, \"Failed to rename table\");\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted in call to rename\", e);\n+    }\n+  }\n+\n+  @Override\n+  public String name() {\n+    return catalogName;\n+  }\n+\n+  @Override\n+  public Configuration getConf() {\n+    return conf;\n+  }\n+\n+  @Override\n+  public void setConf(Configuration conf) {\n+    this.conf = conf;\n+  }\n+\n+  @Override\n+  public void createNamespace(Namespace namespace, Map<String, String> metadata) {\n+    throw new UnsupportedOperationException(\"Cannot create namespace \" + namespace +\n+        \": createNamespace is not supported\");\n+  }\n+\n+  @Override\n+  public List<Namespace> listNamespaces(Namespace namespace) throws NoSuchNamespaceException {\n+    if (!namespaceExists(namespace)) {\n+      throw new NoSuchNamespaceException(\"Namespace does not exist: %s\", namespace);\n+    }\n+\n+    try {\n+\n+      List<Namespace> namespaces = connections.run(conn -> {\n+        List<Namespace> result = Lists.newArrayList();\n+\n+        try (PreparedStatement sql = conn.prepareStatement(JdbcUtil.LIST_NAMESPACES_SQL)) {\n+          sql.setString(1, catalogName);\n+          sql.setString(2, JdbcUtil.namespaceToString(namespace) + \"%\");\n+          ResultSet rs = sql.executeQuery();\n+          while (rs.next()) {\n+            result.add(JdbcUtil.stringToNamespace(rs.getString(JdbcUtil.TABLE_NAMESPACE)));\n+          }\n+          rs.close();\n+        }\n+\n+        return result;\n+      });\n+\n+      int subNamespaceLevelLength = namespace.levels().length + 1;\n+      namespaces = namespaces.stream()\n+          // exclude itself\n+          .filter(n -> !n.equals(namespace))\n+          // only get sub namespaces/children\n+          .filter(n -> n.levels().length >= subNamespaceLevelLength)\n+          // only get sub namespaces/children\n+          .map(n -> Namespace.of(\n+              Arrays.stream(n.levels()).limit(subNamespaceLevelLength).toArray(String[]::new)\n+              )\n+          )\n+          // remove duplicates\n+          .distinct()\n+          .collect(Collectors.toList());\n+\n+      LOG.debug(\"From the namespace '{}' found: {}\", namespace, namespaces);\n+      return namespaces;\n+\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted in call to listNamespaces(namespace) Namespace: \" + namespace, e);\n+    } catch (SQLException e) {\n+      throw new RuntimeException(\"Failed to list all namespace: \" + namespace + \" in catalog!\", e);\n+    }\n+  }\n+\n+  @Override\n+  public Map<String, String> loadNamespaceMetadata(Namespace namespace) throws NoSuchNamespaceException {\n+    if (!namespaceExists(namespace) || namespace.isEmpty()) {\n+      throw new NoSuchNamespaceException(\"Namespace does not exist: %s\", namespace);\n+    }\n+\n+    return ImmutableMap.of(\"location\", defaultNamespaceLocation(namespace));\n+  }\n+\n+  private String defaultNamespaceLocation(Namespace namespace) {\n+    if (namespace.isEmpty()) {\n+      return warehouseLocation;\n+    } else {\n+      return SLASH.join(warehouseLocation, SLASH.join(namespace.levels()));\n+    }\n+  }\n+\n+  @Override\n+  public boolean dropNamespace(Namespace namespace) throws NamespaceNotEmptyException {\n+    if (!namespaceExists(namespace)) {\n+      throw new NoSuchNamespaceException(\"Cannot drop namespace %s because it is not found!\", namespace);\n+    }\n+\n+    List<TableIdentifier> tableIdentifiers = listTables(namespace);\n+    if (tableIdentifiers != null && !tableIdentifiers.isEmpty()) {\n+      throw new NamespaceNotEmptyException(\"Cannot drop namespace %s because it is not empty. \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc9446405e27bbf8d4487dd4142079d5265c7336"}, "originalPosition": 331}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY2MzE3OTI1", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-666317925", "createdAt": "2021-05-23T23:50:31Z", "commit": {"oid": "fc9446405e27bbf8d4487dd4142079d5265c7336"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0yM1QyMzo1MDozMVrOJgFLPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0yM1QyMzo1MDozMVrOJgFLPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNzYxOTAwNA==", "bodyText": "This conflicts with the stated behavior from the API. If no action is taken, the method should return false: https://github.com/apache/iceberg/blob/master/api/src/main/java/org/apache/iceberg/catalog/SupportsNamespaces.java#L102", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r637619004", "createdAt": "2021-05-23T23:50:31Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.io.Closeable;\n+import java.sql.DatabaseMetaData;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, SupportsNamespaces, Closeable {\n+\n+  public static final String PROPERTY_PREFIX = \"connection.parameter.\";\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcCatalog.class);\n+  private static final Joiner SLASH = Joiner.on(\"/\");\n+\n+  private FileIO io;\n+  private String catalogName = \"jdbc\";\n+  private String warehouseLocation;\n+  private Configuration conf;\n+  private JdbcClientPool connections;\n+\n+  public JdbcCatalog() {\n+  }\n+\n+  @Override\n+  public void initialize(String name, Map<String, String> properties) {\n+    String uri = properties.get(CatalogProperties.URI);\n+    Preconditions.checkNotNull(uri, \"JDBC connection URI is required\");\n+\n+    String warehouse = properties.get(CatalogProperties.WAREHOUSE_LOCATION);\n+    Preconditions.checkNotNull(warehouse, \"JDBC warehouse location is required\");\n+    this.warehouseLocation = warehouse.replaceAll(\"/$\", \"\");\n+\n+    if (name != null) {\n+      this.catalogName = name;\n+    }\n+\n+    String fileIOImpl = properties.get(CatalogProperties.FILE_IO_IMPL);\n+    this.io = fileIOImpl == null ? new HadoopFileIO(conf) : CatalogUtil.loadFileIO(fileIOImpl, properties, conf);\n+\n+    try {\n+      LOG.debug(\"Connecting to Jdbc database {}\", properties.get(CatalogProperties.URI));\n+      connections = new JdbcClientPool(uri, properties);\n+      initializeCatalogTables();\n+    } catch (SQLTimeoutException e) {\n+      throw new UncheckedSQLException(e, \"Cannot initialize jdbc catalog: Query timed out\");\n+    } catch (SQLTransientConnectionException | SQLNonTransientConnectionException e) {\n+      throw new UncheckedSQLException(e, \"Cannot initialize jdbc catalog: Connection failed\");\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(e, \"Cannot initialize jdbc catalog\");\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted in call to initialize\", e);\n+    }\n+  }\n+\n+  private void initializeCatalogTables() throws InterruptedException, SQLException {\n+    LOG.trace(\"Creating database tables (if missing) to store iceberg catalog\");\n+    connections.run(conn -> {\n+      DatabaseMetaData dbMeta = conn.getMetaData();\n+      ResultSet tableExists = dbMeta.getTables(null, null, JdbcUtil.CATALOG_TABLE_NAME, null);\n+\n+      if (tableExists.next()) {\n+        return true;\n+      }\n+\n+      LOG.debug(\"Creating table {} to store iceberg catalog!\", JdbcUtil.CATALOG_TABLE_NAME);\n+      return conn.prepareStatement(JdbcUtil.CREATE_CATALOG_TABLE).execute();\n+    });\n+  }\n+\n+  @Override\n+  protected TableOperations newTableOps(TableIdentifier tableIdentifier) {\n+    return new JdbcTableOperations(connections, io, catalogName, tableIdentifier);\n+  }\n+\n+  @Override\n+  protected String defaultWarehouseLocation(TableIdentifier table) {\n+    return SLASH.join(defaultNamespaceLocation(table.namespace()), table.name());\n+  }\n+\n+  @Override\n+  public boolean dropTable(TableIdentifier identifier, boolean purge) {\n+\n+    int deletedRecords;\n+    try {\n+      deletedRecords = connections.run(conn -> {\n+        try (PreparedStatement sql = conn.prepareStatement(JdbcUtil.DROP_TABLE_SQL)) {\n+          sql.setString(1, catalogName);\n+          sql.setString(2, JdbcUtil.namespaceToString(identifier.namespace()));\n+          sql.setString(3, identifier.name());\n+          return sql.executeUpdate();\n+        }\n+      });\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(e, \"Failed to drop %s\", identifier);\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted in call to dropTable\", e);\n+    }\n+\n+    if (deletedRecords > 0) {\n+      LOG.info(\"Successfully dropped table {}.\", identifier);\n+    } else {\n+      LOG.info(\"Cannot drop table: {}! table not found in the catalog.\", identifier);\n+      return false;\n+    }\n+\n+    TableOperations ops = newTableOps(identifier);\n+    TableMetadata lastMetadata = ops.current();\n+\n+    if (purge && lastMetadata != null) {\n+      CatalogUtil.dropTableData(ops.io(), lastMetadata);\n+      LOG.info(\"Table {} data purged!\", identifier);\n+    }\n+\n+    return true;\n+\n+  }\n+\n+  @Override\n+  public List<TableIdentifier> listTables(Namespace namespace) {\n+    if (!namespaceExists(namespace)) {\n+      throw new NoSuchNamespaceException(\"Namespace does not exist: %s\", namespace);\n+    }\n+\n+    try {\n+      return connections.run(conn -> {\n+        List<TableIdentifier> results = Lists.newArrayList();\n+        try (PreparedStatement sql = conn.prepareStatement(JdbcUtil.LIST_TABLES_SQL)) {\n+          sql.setString(1, catalogName);\n+          sql.setString(2, JdbcUtil.namespaceToString(namespace));\n+\n+          ResultSet rs = sql.executeQuery();\n+          while (rs.next()) {\n+            results.add(JdbcUtil.stringToTableIdentifier(rs.getString(JdbcUtil.TABLE_NAMESPACE), rs.getString(\n+                JdbcUtil.TABLE_NAME)));\n+          }\n+\n+          return results;\n+        }\n+      });\n+\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(e, \"Failed to list tables in namespace: %s\", namespace);\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted during JDBC operation\", e);\n+    }\n+  }\n+\n+  @Override\n+  public void renameTable(TableIdentifier from, TableIdentifier to) {\n+    try {\n+      int updatedRecords = connections.run(conn -> {\n+        try (PreparedStatement sql = conn.prepareStatement(JdbcUtil.RENAME_TABLE_SQL)) {\n+          // SET\n+          sql.setString(1, JdbcUtil.namespaceToString(to.namespace()));\n+          sql.setString(2, to.name());\n+          // WHERE\n+          sql.setString(3, catalogName);\n+          sql.setString(4, JdbcUtil.namespaceToString(from.namespace()));\n+          sql.setString(5, from.name());\n+          return sql.executeUpdate();\n+        }\n+      });\n+\n+      if (updatedRecords == 1) {\n+        LOG.debug(\"Successfully renamed table from {} to {}!\", from, to);\n+      } else if (updatedRecords == 0) {\n+        throw new NoSuchTableException(\"Failed to rename table! Table '%s' not found in the catalog!\", from);\n+      } else {\n+        throw new RuntimeException(\"Failed to rename table! Rename operation Failed\");\n+      }\n+\n+    } catch (SQLIntegrityConstraintViolationException e) {\n+      throw new AlreadyExistsException(\"Table with name '%s' already exists in the catalog!\", to);\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(e, \"Failed to rename table\");\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted in call to rename\", e);\n+    }\n+  }\n+\n+  @Override\n+  public String name() {\n+    return catalogName;\n+  }\n+\n+  @Override\n+  public Configuration getConf() {\n+    return conf;\n+  }\n+\n+  @Override\n+  public void setConf(Configuration conf) {\n+    this.conf = conf;\n+  }\n+\n+  @Override\n+  public void createNamespace(Namespace namespace, Map<String, String> metadata) {\n+    throw new UnsupportedOperationException(\"Cannot create namespace \" + namespace +\n+        \": createNamespace is not supported\");\n+  }\n+\n+  @Override\n+  public List<Namespace> listNamespaces(Namespace namespace) throws NoSuchNamespaceException {\n+    if (!namespaceExists(namespace)) {\n+      throw new NoSuchNamespaceException(\"Namespace does not exist: %s\", namespace);\n+    }\n+\n+    try {\n+\n+      List<Namespace> namespaces = connections.run(conn -> {\n+        List<Namespace> result = Lists.newArrayList();\n+\n+        try (PreparedStatement sql = conn.prepareStatement(JdbcUtil.LIST_NAMESPACES_SQL)) {\n+          sql.setString(1, catalogName);\n+          sql.setString(2, JdbcUtil.namespaceToString(namespace) + \"%\");\n+          ResultSet rs = sql.executeQuery();\n+          while (rs.next()) {\n+            result.add(JdbcUtil.stringToNamespace(rs.getString(JdbcUtil.TABLE_NAMESPACE)));\n+          }\n+          rs.close();\n+        }\n+\n+        return result;\n+      });\n+\n+      int subNamespaceLevelLength = namespace.levels().length + 1;\n+      namespaces = namespaces.stream()\n+          // exclude itself\n+          .filter(n -> !n.equals(namespace))\n+          // only get sub namespaces/children\n+          .filter(n -> n.levels().length >= subNamespaceLevelLength)\n+          // only get sub namespaces/children\n+          .map(n -> Namespace.of(\n+              Arrays.stream(n.levels()).limit(subNamespaceLevelLength).toArray(String[]::new)\n+              )\n+          )\n+          // remove duplicates\n+          .distinct()\n+          .collect(Collectors.toList());\n+\n+      LOG.debug(\"From the namespace '{}' found: {}\", namespace, namespaces);\n+      return namespaces;\n+\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted in call to listNamespaces(namespace) Namespace: \" + namespace, e);\n+    } catch (SQLException e) {\n+      throw new RuntimeException(\"Failed to list all namespace: \" + namespace + \" in catalog!\", e);\n+    }\n+  }\n+\n+  @Override\n+  public Map<String, String> loadNamespaceMetadata(Namespace namespace) throws NoSuchNamespaceException {\n+    if (!namespaceExists(namespace) || namespace.isEmpty()) {\n+      throw new NoSuchNamespaceException(\"Namespace does not exist: %s\", namespace);\n+    }\n+\n+    return ImmutableMap.of(\"location\", defaultNamespaceLocation(namespace));\n+  }\n+\n+  private String defaultNamespaceLocation(Namespace namespace) {\n+    if (namespace.isEmpty()) {\n+      return warehouseLocation;\n+    } else {\n+      return SLASH.join(warehouseLocation, SLASH.join(namespace.levels()));\n+    }\n+  }\n+\n+  @Override\n+  public boolean dropNamespace(Namespace namespace) throws NamespaceNotEmptyException {\n+    if (!namespaceExists(namespace)) {\n+      throw new NoSuchNamespaceException(\"Cannot drop namespace %s because it is not found!\", namespace);\n+    }\n+\n+    List<TableIdentifier> tableIdentifiers = listTables(namespace);\n+    if (tableIdentifiers != null && !tableIdentifiers.isEmpty()) {\n+      throw new NamespaceNotEmptyException(\"Cannot drop namespace %s because it is not empty. \" +\n+          \"Namespace contains %s tables\", namespace, tableIdentifiers.size());\n+    }\n+\n+    // namespaces are created/deleted by tables by default return true\n+    // when there is no tables with namespace then its considered dropped\n+    return true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc9446405e27bbf8d4487dd4142079d5265c7336"}, "originalPosition": 337}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY2MzE4Mjcz", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-666318273", "createdAt": "2021-05-23T23:53:35Z", "commit": {"oid": "fc9446405e27bbf8d4487dd4142079d5265c7336"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0yM1QyMzo1MzozNVrOJgFM3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0yM1QyMzo1MzozNVrOJgFM3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNzYxOTQyMg==", "bodyText": "I think this needs to throw UncheckedSQLException. It can't assume that any exception indicates that the table doesn't exist.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r637619422", "createdAt": "2021-05-23T23:53:35Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.io.Closeable;\n+import java.sql.DatabaseMetaData;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, SupportsNamespaces, Closeable {\n+\n+  public static final String PROPERTY_PREFIX = \"connection.parameter.\";\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcCatalog.class);\n+  private static final Joiner SLASH = Joiner.on(\"/\");\n+\n+  private FileIO io;\n+  private String catalogName = \"jdbc\";\n+  private String warehouseLocation;\n+  private Configuration conf;\n+  private JdbcClientPool connections;\n+\n+  public JdbcCatalog() {\n+  }\n+\n+  @Override\n+  public void initialize(String name, Map<String, String> properties) {\n+    String uri = properties.get(CatalogProperties.URI);\n+    Preconditions.checkNotNull(uri, \"JDBC connection URI is required\");\n+\n+    String warehouse = properties.get(CatalogProperties.WAREHOUSE_LOCATION);\n+    Preconditions.checkNotNull(warehouse, \"JDBC warehouse location is required\");\n+    this.warehouseLocation = warehouse.replaceAll(\"/$\", \"\");\n+\n+    if (name != null) {\n+      this.catalogName = name;\n+    }\n+\n+    String fileIOImpl = properties.get(CatalogProperties.FILE_IO_IMPL);\n+    this.io = fileIOImpl == null ? new HadoopFileIO(conf) : CatalogUtil.loadFileIO(fileIOImpl, properties, conf);\n+\n+    try {\n+      LOG.debug(\"Connecting to Jdbc database {}\", properties.get(CatalogProperties.URI));\n+      connections = new JdbcClientPool(uri, properties);\n+      initializeCatalogTables();\n+    } catch (SQLTimeoutException e) {\n+      throw new UncheckedSQLException(e, \"Cannot initialize jdbc catalog: Query timed out\");\n+    } catch (SQLTransientConnectionException | SQLNonTransientConnectionException e) {\n+      throw new UncheckedSQLException(e, \"Cannot initialize jdbc catalog: Connection failed\");\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(e, \"Cannot initialize jdbc catalog\");\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted in call to initialize\", e);\n+    }\n+  }\n+\n+  private void initializeCatalogTables() throws InterruptedException, SQLException {\n+    LOG.trace(\"Creating database tables (if missing) to store iceberg catalog\");\n+    connections.run(conn -> {\n+      DatabaseMetaData dbMeta = conn.getMetaData();\n+      ResultSet tableExists = dbMeta.getTables(null, null, JdbcUtil.CATALOG_TABLE_NAME, null);\n+\n+      if (tableExists.next()) {\n+        return true;\n+      }\n+\n+      LOG.debug(\"Creating table {} to store iceberg catalog!\", JdbcUtil.CATALOG_TABLE_NAME);\n+      return conn.prepareStatement(JdbcUtil.CREATE_CATALOG_TABLE).execute();\n+    });\n+  }\n+\n+  @Override\n+  protected TableOperations newTableOps(TableIdentifier tableIdentifier) {\n+    return new JdbcTableOperations(connections, io, catalogName, tableIdentifier);\n+  }\n+\n+  @Override\n+  protected String defaultWarehouseLocation(TableIdentifier table) {\n+    return SLASH.join(defaultNamespaceLocation(table.namespace()), table.name());\n+  }\n+\n+  @Override\n+  public boolean dropTable(TableIdentifier identifier, boolean purge) {\n+\n+    int deletedRecords;\n+    try {\n+      deletedRecords = connections.run(conn -> {\n+        try (PreparedStatement sql = conn.prepareStatement(JdbcUtil.DROP_TABLE_SQL)) {\n+          sql.setString(1, catalogName);\n+          sql.setString(2, JdbcUtil.namespaceToString(identifier.namespace()));\n+          sql.setString(3, identifier.name());\n+          return sql.executeUpdate();\n+        }\n+      });\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(e, \"Failed to drop %s\", identifier);\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted in call to dropTable\", e);\n+    }\n+\n+    if (deletedRecords > 0) {\n+      LOG.info(\"Successfully dropped table {}.\", identifier);\n+    } else {\n+      LOG.info(\"Cannot drop table: {}! table not found in the catalog.\", identifier);\n+      return false;\n+    }\n+\n+    TableOperations ops = newTableOps(identifier);\n+    TableMetadata lastMetadata = ops.current();\n+\n+    if (purge && lastMetadata != null) {\n+      CatalogUtil.dropTableData(ops.io(), lastMetadata);\n+      LOG.info(\"Table {} data purged!\", identifier);\n+    }\n+\n+    return true;\n+\n+  }\n+\n+  @Override\n+  public List<TableIdentifier> listTables(Namespace namespace) {\n+    if (!namespaceExists(namespace)) {\n+      throw new NoSuchNamespaceException(\"Namespace does not exist: %s\", namespace);\n+    }\n+\n+    try {\n+      return connections.run(conn -> {\n+        List<TableIdentifier> results = Lists.newArrayList();\n+        try (PreparedStatement sql = conn.prepareStatement(JdbcUtil.LIST_TABLES_SQL)) {\n+          sql.setString(1, catalogName);\n+          sql.setString(2, JdbcUtil.namespaceToString(namespace));\n+\n+          ResultSet rs = sql.executeQuery();\n+          while (rs.next()) {\n+            results.add(JdbcUtil.stringToTableIdentifier(rs.getString(JdbcUtil.TABLE_NAMESPACE), rs.getString(\n+                JdbcUtil.TABLE_NAME)));\n+          }\n+\n+          return results;\n+        }\n+      });\n+\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(e, \"Failed to list tables in namespace: %s\", namespace);\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted during JDBC operation\", e);\n+    }\n+  }\n+\n+  @Override\n+  public void renameTable(TableIdentifier from, TableIdentifier to) {\n+    try {\n+      int updatedRecords = connections.run(conn -> {\n+        try (PreparedStatement sql = conn.prepareStatement(JdbcUtil.RENAME_TABLE_SQL)) {\n+          // SET\n+          sql.setString(1, JdbcUtil.namespaceToString(to.namespace()));\n+          sql.setString(2, to.name());\n+          // WHERE\n+          sql.setString(3, catalogName);\n+          sql.setString(4, JdbcUtil.namespaceToString(from.namespace()));\n+          sql.setString(5, from.name());\n+          return sql.executeUpdate();\n+        }\n+      });\n+\n+      if (updatedRecords == 1) {\n+        LOG.debug(\"Successfully renamed table from {} to {}!\", from, to);\n+      } else if (updatedRecords == 0) {\n+        throw new NoSuchTableException(\"Failed to rename table! Table '%s' not found in the catalog!\", from);\n+      } else {\n+        throw new RuntimeException(\"Failed to rename table! Rename operation Failed\");\n+      }\n+\n+    } catch (SQLIntegrityConstraintViolationException e) {\n+      throw new AlreadyExistsException(\"Table with name '%s' already exists in the catalog!\", to);\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(e, \"Failed to rename table\");\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted in call to rename\", e);\n+    }\n+  }\n+\n+  @Override\n+  public String name() {\n+    return catalogName;\n+  }\n+\n+  @Override\n+  public Configuration getConf() {\n+    return conf;\n+  }\n+\n+  @Override\n+  public void setConf(Configuration conf) {\n+    this.conf = conf;\n+  }\n+\n+  @Override\n+  public void createNamespace(Namespace namespace, Map<String, String> metadata) {\n+    throw new UnsupportedOperationException(\"Cannot create namespace \" + namespace +\n+        \": createNamespace is not supported\");\n+  }\n+\n+  @Override\n+  public List<Namespace> listNamespaces(Namespace namespace) throws NoSuchNamespaceException {\n+    if (!namespaceExists(namespace)) {\n+      throw new NoSuchNamespaceException(\"Namespace does not exist: %s\", namespace);\n+    }\n+\n+    try {\n+\n+      List<Namespace> namespaces = connections.run(conn -> {\n+        List<Namespace> result = Lists.newArrayList();\n+\n+        try (PreparedStatement sql = conn.prepareStatement(JdbcUtil.LIST_NAMESPACES_SQL)) {\n+          sql.setString(1, catalogName);\n+          sql.setString(2, JdbcUtil.namespaceToString(namespace) + \"%\");\n+          ResultSet rs = sql.executeQuery();\n+          while (rs.next()) {\n+            result.add(JdbcUtil.stringToNamespace(rs.getString(JdbcUtil.TABLE_NAMESPACE)));\n+          }\n+          rs.close();\n+        }\n+\n+        return result;\n+      });\n+\n+      int subNamespaceLevelLength = namespace.levels().length + 1;\n+      namespaces = namespaces.stream()\n+          // exclude itself\n+          .filter(n -> !n.equals(namespace))\n+          // only get sub namespaces/children\n+          .filter(n -> n.levels().length >= subNamespaceLevelLength)\n+          // only get sub namespaces/children\n+          .map(n -> Namespace.of(\n+              Arrays.stream(n.levels()).limit(subNamespaceLevelLength).toArray(String[]::new)\n+              )\n+          )\n+          // remove duplicates\n+          .distinct()\n+          .collect(Collectors.toList());\n+\n+      LOG.debug(\"From the namespace '{}' found: {}\", namespace, namespaces);\n+      return namespaces;\n+\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted in call to listNamespaces(namespace) Namespace: \" + namespace, e);\n+    } catch (SQLException e) {\n+      throw new RuntimeException(\"Failed to list all namespace: \" + namespace + \" in catalog!\", e);\n+    }\n+  }\n+\n+  @Override\n+  public Map<String, String> loadNamespaceMetadata(Namespace namespace) throws NoSuchNamespaceException {\n+    if (!namespaceExists(namespace) || namespace.isEmpty()) {\n+      throw new NoSuchNamespaceException(\"Namespace does not exist: %s\", namespace);\n+    }\n+\n+    return ImmutableMap.of(\"location\", defaultNamespaceLocation(namespace));\n+  }\n+\n+  private String defaultNamespaceLocation(Namespace namespace) {\n+    if (namespace.isEmpty()) {\n+      return warehouseLocation;\n+    } else {\n+      return SLASH.join(warehouseLocation, SLASH.join(namespace.levels()));\n+    }\n+  }\n+\n+  @Override\n+  public boolean dropNamespace(Namespace namespace) throws NamespaceNotEmptyException {\n+    if (!namespaceExists(namespace)) {\n+      throw new NoSuchNamespaceException(\"Cannot drop namespace %s because it is not found!\", namespace);\n+    }\n+\n+    List<TableIdentifier> tableIdentifiers = listTables(namespace);\n+    if (tableIdentifiers != null && !tableIdentifiers.isEmpty()) {\n+      throw new NamespaceNotEmptyException(\"Cannot drop namespace %s because it is not empty. \" +\n+          \"Namespace contains %s tables\", namespace, tableIdentifiers.size());\n+    }\n+\n+    // namespaces are created/deleted by tables by default return true\n+    // when there is no tables with namespace then its considered dropped\n+    return true;\n+  }\n+\n+  @Override\n+  public boolean setProperties(Namespace namespace, Map<String, String> properties) throws\n+      NoSuchNamespaceException {\n+    throw new UnsupportedOperationException(\n+        \"Cannot set properties \" + namespace + \" : setProperties is not supported\");\n+  }\n+\n+  @Override\n+  public boolean removeProperties(Namespace namespace, Set<String> properties) throws NoSuchNamespaceException {\n+    throw new UnsupportedOperationException(\n+        \"Cannot remove properties \" + namespace + \" : removeProperties is not supported\");\n+  }\n+\n+  @Override\n+  public void close() {\n+    connections.close();\n+  }\n+\n+  @Override\n+  public boolean namespaceExists(Namespace namespace) {\n+    try {\n+      return connections.run(conn -> {\n+        boolean exists = false;\n+\n+        try (PreparedStatement sql = conn.prepareStatement(JdbcUtil.GET_NAMESPACE_SQL)) {\n+          sql.setString(1, catalogName);\n+          sql.setString(2, JdbcUtil.namespaceToString(namespace) + \"%\");\n+          ResultSet rs = sql.executeQuery();\n+          if (rs.next()) {\n+            exists = true;\n+          }\n+\n+          rs.close();\n+        }\n+\n+        return exists;\n+      });\n+\n+    } catch (SQLException e) {\n+      LOG.warn(\"SQLException! \", e);\n+      return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc9446405e27bbf8d4487dd4142079d5265c7336"}, "originalPosition": 380}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY2MzE4NTQ2", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-666318546", "createdAt": "2021-05-23T23:55:49Z", "commit": {"oid": "fc9446405e27bbf8d4487dd4142079d5265c7336"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0yM1QyMzo1NTo0OVrOJgFOBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0yM1QyMzo1NTo0OVrOJgFOBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNzYxOTcxNg==", "bodyText": "Minor: it is more readable to wrap lines at the top-level function call's arguments rather than in the middle of those arguments.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r637619716", "createdAt": "2021-05-23T23:55:49Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.io.Closeable;\n+import java.sql.DatabaseMetaData;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, SupportsNamespaces, Closeable {\n+\n+  public static final String PROPERTY_PREFIX = \"connection.parameter.\";\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcCatalog.class);\n+  private static final Joiner SLASH = Joiner.on(\"/\");\n+\n+  private FileIO io;\n+  private String catalogName = \"jdbc\";\n+  private String warehouseLocation;\n+  private Configuration conf;\n+  private JdbcClientPool connections;\n+\n+  public JdbcCatalog() {\n+  }\n+\n+  @Override\n+  public void initialize(String name, Map<String, String> properties) {\n+    String uri = properties.get(CatalogProperties.URI);\n+    Preconditions.checkNotNull(uri, \"JDBC connection URI is required\");\n+\n+    String warehouse = properties.get(CatalogProperties.WAREHOUSE_LOCATION);\n+    Preconditions.checkNotNull(warehouse, \"JDBC warehouse location is required\");\n+    this.warehouseLocation = warehouse.replaceAll(\"/$\", \"\");\n+\n+    if (name != null) {\n+      this.catalogName = name;\n+    }\n+\n+    String fileIOImpl = properties.get(CatalogProperties.FILE_IO_IMPL);\n+    this.io = fileIOImpl == null ? new HadoopFileIO(conf) : CatalogUtil.loadFileIO(fileIOImpl, properties, conf);\n+\n+    try {\n+      LOG.debug(\"Connecting to Jdbc database {}\", properties.get(CatalogProperties.URI));\n+      connections = new JdbcClientPool(uri, properties);\n+      initializeCatalogTables();\n+    } catch (SQLTimeoutException e) {\n+      throw new UncheckedSQLException(e, \"Cannot initialize jdbc catalog: Query timed out\");\n+    } catch (SQLTransientConnectionException | SQLNonTransientConnectionException e) {\n+      throw new UncheckedSQLException(e, \"Cannot initialize jdbc catalog: Connection failed\");\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(e, \"Cannot initialize jdbc catalog\");\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted in call to initialize\", e);\n+    }\n+  }\n+\n+  private void initializeCatalogTables() throws InterruptedException, SQLException {\n+    LOG.trace(\"Creating database tables (if missing) to store iceberg catalog\");\n+    connections.run(conn -> {\n+      DatabaseMetaData dbMeta = conn.getMetaData();\n+      ResultSet tableExists = dbMeta.getTables(null, null, JdbcUtil.CATALOG_TABLE_NAME, null);\n+\n+      if (tableExists.next()) {\n+        return true;\n+      }\n+\n+      LOG.debug(\"Creating table {} to store iceberg catalog!\", JdbcUtil.CATALOG_TABLE_NAME);\n+      return conn.prepareStatement(JdbcUtil.CREATE_CATALOG_TABLE).execute();\n+    });\n+  }\n+\n+  @Override\n+  protected TableOperations newTableOps(TableIdentifier tableIdentifier) {\n+    return new JdbcTableOperations(connections, io, catalogName, tableIdentifier);\n+  }\n+\n+  @Override\n+  protected String defaultWarehouseLocation(TableIdentifier table) {\n+    return SLASH.join(defaultNamespaceLocation(table.namespace()), table.name());\n+  }\n+\n+  @Override\n+  public boolean dropTable(TableIdentifier identifier, boolean purge) {\n+\n+    int deletedRecords;\n+    try {\n+      deletedRecords = connections.run(conn -> {\n+        try (PreparedStatement sql = conn.prepareStatement(JdbcUtil.DROP_TABLE_SQL)) {\n+          sql.setString(1, catalogName);\n+          sql.setString(2, JdbcUtil.namespaceToString(identifier.namespace()));\n+          sql.setString(3, identifier.name());\n+          return sql.executeUpdate();\n+        }\n+      });\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(e, \"Failed to drop %s\", identifier);\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted in call to dropTable\", e);\n+    }\n+\n+    if (deletedRecords > 0) {\n+      LOG.info(\"Successfully dropped table {}.\", identifier);\n+    } else {\n+      LOG.info(\"Cannot drop table: {}! table not found in the catalog.\", identifier);\n+      return false;\n+    }\n+\n+    TableOperations ops = newTableOps(identifier);\n+    TableMetadata lastMetadata = ops.current();\n+\n+    if (purge && lastMetadata != null) {\n+      CatalogUtil.dropTableData(ops.io(), lastMetadata);\n+      LOG.info(\"Table {} data purged!\", identifier);\n+    }\n+\n+    return true;\n+\n+  }\n+\n+  @Override\n+  public List<TableIdentifier> listTables(Namespace namespace) {\n+    if (!namespaceExists(namespace)) {\n+      throw new NoSuchNamespaceException(\"Namespace does not exist: %s\", namespace);\n+    }\n+\n+    try {\n+      return connections.run(conn -> {\n+        List<TableIdentifier> results = Lists.newArrayList();\n+        try (PreparedStatement sql = conn.prepareStatement(JdbcUtil.LIST_TABLES_SQL)) {\n+          sql.setString(1, catalogName);\n+          sql.setString(2, JdbcUtil.namespaceToString(namespace));\n+\n+          ResultSet rs = sql.executeQuery();\n+          while (rs.next()) {\n+            results.add(JdbcUtil.stringToTableIdentifier(rs.getString(JdbcUtil.TABLE_NAMESPACE), rs.getString(\n+                JdbcUtil.TABLE_NAME)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc9446405e27bbf8d4487dd4142079d5265c7336"}, "originalPosition": 186}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY2MzE4NzE0", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-666318714", "createdAt": "2021-05-23T23:57:24Z", "commit": {"oid": "fc9446405e27bbf8d4487dd4142079d5265c7336"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0yM1QyMzo1NzoyNFrOJgFOqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0yM1QyMzo1NzoyNFrOJgFOqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNzYxOTg4Mw==", "bodyText": "If you instantiate the table ops here, then the table will never be cleaned up because it was just removed from the DB above so its metadata is lost.\nLike the Hive implementation, you need to instantiate the table operations, then run the drop only if the metadata is non-null. Otherwise the logic looks correct to me.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r637619883", "createdAt": "2021-05-23T23:57:24Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.io.Closeable;\n+import java.sql.DatabaseMetaData;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, SupportsNamespaces, Closeable {\n+\n+  public static final String PROPERTY_PREFIX = \"connection.parameter.\";\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcCatalog.class);\n+  private static final Joiner SLASH = Joiner.on(\"/\");\n+\n+  private FileIO io;\n+  private String catalogName = \"jdbc\";\n+  private String warehouseLocation;\n+  private Configuration conf;\n+  private JdbcClientPool connections;\n+\n+  public JdbcCatalog() {\n+  }\n+\n+  @Override\n+  public void initialize(String name, Map<String, String> properties) {\n+    String uri = properties.get(CatalogProperties.URI);\n+    Preconditions.checkNotNull(uri, \"JDBC connection URI is required\");\n+\n+    String warehouse = properties.get(CatalogProperties.WAREHOUSE_LOCATION);\n+    Preconditions.checkNotNull(warehouse, \"JDBC warehouse location is required\");\n+    this.warehouseLocation = warehouse.replaceAll(\"/$\", \"\");\n+\n+    if (name != null) {\n+      this.catalogName = name;\n+    }\n+\n+    String fileIOImpl = properties.get(CatalogProperties.FILE_IO_IMPL);\n+    this.io = fileIOImpl == null ? new HadoopFileIO(conf) : CatalogUtil.loadFileIO(fileIOImpl, properties, conf);\n+\n+    try {\n+      LOG.debug(\"Connecting to Jdbc database {}\", properties.get(CatalogProperties.URI));\n+      connections = new JdbcClientPool(uri, properties);\n+      initializeCatalogTables();\n+    } catch (SQLTimeoutException e) {\n+      throw new UncheckedSQLException(e, \"Cannot initialize jdbc catalog: Query timed out\");\n+    } catch (SQLTransientConnectionException | SQLNonTransientConnectionException e) {\n+      throw new UncheckedSQLException(e, \"Cannot initialize jdbc catalog: Connection failed\");\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(e, \"Cannot initialize jdbc catalog\");\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted in call to initialize\", e);\n+    }\n+  }\n+\n+  private void initializeCatalogTables() throws InterruptedException, SQLException {\n+    LOG.trace(\"Creating database tables (if missing) to store iceberg catalog\");\n+    connections.run(conn -> {\n+      DatabaseMetaData dbMeta = conn.getMetaData();\n+      ResultSet tableExists = dbMeta.getTables(null, null, JdbcUtil.CATALOG_TABLE_NAME, null);\n+\n+      if (tableExists.next()) {\n+        return true;\n+      }\n+\n+      LOG.debug(\"Creating table {} to store iceberg catalog!\", JdbcUtil.CATALOG_TABLE_NAME);\n+      return conn.prepareStatement(JdbcUtil.CREATE_CATALOG_TABLE).execute();\n+    });\n+  }\n+\n+  @Override\n+  protected TableOperations newTableOps(TableIdentifier tableIdentifier) {\n+    return new JdbcTableOperations(connections, io, catalogName, tableIdentifier);\n+  }\n+\n+  @Override\n+  protected String defaultWarehouseLocation(TableIdentifier table) {\n+    return SLASH.join(defaultNamespaceLocation(table.namespace()), table.name());\n+  }\n+\n+  @Override\n+  public boolean dropTable(TableIdentifier identifier, boolean purge) {\n+\n+    int deletedRecords;\n+    try {\n+      deletedRecords = connections.run(conn -> {\n+        try (PreparedStatement sql = conn.prepareStatement(JdbcUtil.DROP_TABLE_SQL)) {\n+          sql.setString(1, catalogName);\n+          sql.setString(2, JdbcUtil.namespaceToString(identifier.namespace()));\n+          sql.setString(3, identifier.name());\n+          return sql.executeUpdate();\n+        }\n+      });\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(e, \"Failed to drop %s\", identifier);\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted in call to dropTable\", e);\n+    }\n+\n+    if (deletedRecords > 0) {\n+      LOG.info(\"Successfully dropped table {}.\", identifier);\n+    } else {\n+      LOG.info(\"Cannot drop table: {}! table not found in the catalog.\", identifier);\n+      return false;\n+    }\n+\n+    TableOperations ops = newTableOps(identifier);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc9446405e27bbf8d4487dd4142079d5265c7336"}, "originalPosition": 158}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY2MzE4ODQz", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-666318843", "createdAt": "2021-05-23T23:58:35Z", "commit": {"oid": "fc9446405e27bbf8d4487dd4142079d5265c7336"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0yM1QyMzo1ODozNVrOJgFPRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0yM1QyMzo1ODozNVrOJgFPRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNzYyMDAzOQ==", "bodyText": "This is a long parameter prefix. Could we make it shorter, like just jdbc.?", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r637620039", "createdAt": "2021-05-23T23:58:35Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.io.Closeable;\n+import java.sql.DatabaseMetaData;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, SupportsNamespaces, Closeable {\n+\n+  public static final String PROPERTY_PREFIX = \"connection.parameter.\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc9446405e27bbf8d4487dd4142079d5265c7336"}, "originalPosition": 61}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ac7eb42f9609b2425ab5a8c7011483abd66409f9", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/ac7eb42f9609b2425ab5a8c7011483abd66409f9", "committedDate": "2021-05-28T12:04:03Z", "message": "address review comments, align log messages with hive"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "287c1051e49322959b448040777a50be64812ceb", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/287c1051e49322959b448040777a50be64812ceb", "committedDate": "2021-05-28T12:04:03Z", "message": "address review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "57b83f10a418670a2e76581377c52d5067b14e1c", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/57b83f10a418670a2e76581377c52d5067b14e1c", "committedDate": "2021-05-28T12:53:47Z", "message": "address review comments, allow empty namespace and throw UncheckedSQLException when namespaceExists fails"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4d9028f1d3ef188c3c73fed6a98413289220f5ae", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/4d9028f1d3ef188c3c73fed6a98413289220f5ae", "committedDate": "2021-05-28T13:03:17Z", "message": "checkstyleTest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cb03b9ce900ab169486965dbb79d3fd5545f09d5", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/cb03b9ce900ab169486965dbb79d3fd5545f09d5", "committedDate": "2021-05-28T13:49:33Z", "message": "address review comments, use UncheckedInterruptedException"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg2ODc4ODM0", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-686878834", "createdAt": "2021-06-17T22:03:04Z", "commit": {"oid": "cb03b9ce900ab169486965dbb79d3fd5545f09d5"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a21579f5fdbb7934f8f7ebee5c8d620830c43310", "author": {"user": {"login": "rdblue", "name": "Ryan Blue"}}, "url": "https://github.com/apache/iceberg/commit/a21579f5fdbb7934f8f7ebee5c8d620830c43310", "committedDate": "2021-06-17T22:10:51Z", "message": "Merge branch 'master' into iceberg_jdbccatalog"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg2OTMyNDcz", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-686932473", "createdAt": "2021-06-17T23:57:31Z", "commit": {"oid": "a21579f5fdbb7934f8f7ebee5c8d620830c43310"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xN1QyMzo1NzozMVrOJvwbgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xN1QyMzo1NzozMVrOJvwbgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1NDA1NjMyMQ==", "bodyText": "Nit: should be \"in catalog\" not just \"catalog\"", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r654056321", "createdAt": "2021-06-17T23:57:31Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcTableOperations.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.sql.DataTruncation;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.sql.SQLWarning;\n+import java.util.Map;\n+import java.util.Objects;\n+import org.apache.iceberg.BaseMetastoreTableOperations;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.CommitFailedException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+class JdbcTableOperations extends BaseMetastoreTableOperations {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcTableOperations.class);\n+  private final String catalogName;\n+  private final TableIdentifier tableIdentifier;\n+  private final FileIO fileIO;\n+  private final JdbcClientPool connections;\n+\n+  protected JdbcTableOperations(JdbcClientPool dbConnPool, FileIO fileIO, String catalogName,\n+                                TableIdentifier tableIdentifier) {\n+    this.catalogName = catalogName;\n+    this.tableIdentifier = tableIdentifier;\n+    this.fileIO = fileIO;\n+    this.connections = dbConnPool;\n+  }\n+\n+  @Override\n+  public void doRefresh() {\n+    Map<String, String> table;\n+\n+    try {\n+      table = getTable();\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new UncheckedInterruptedException(e, \"Interrupted during refresh\");\n+    } catch (SQLException e) {\n+      // SQL exception happened when getting table from catalog\n+      throw new UncheckedSQLException(e, \"Failed to get table %s from catalog %s\", tableIdentifier, catalogName);\n+    }\n+\n+    // Table not exists AND currentMetadataLocation is not NULL!\n+    if (table.isEmpty() && currentMetadataLocation() != null) {\n+      throw new NoSuchTableException(\"Failed to get table %s from catalog %s\" +\n+          \" maybe another process deleted it\", tableIdentifier, catalogName);\n+    }\n+\n+    // Table not exists in the catalog! metadataLocation is null here!\n+    if (table.isEmpty()) {\n+      refreshFromMetadataLocation(null);\n+      return;\n+    }\n+\n+    // Table exists but metadataLocation is null\n+    if (table.getOrDefault(JdbcUtil.METADATA_LOCATION, null) == null) {\n+      throw new RuntimeException(String.format(\"Failed to get metadata location of the table %s from catalog %s\",\n+          tableIdentifier, catalogName));\n+    }\n+\n+    refreshFromMetadataLocation(table.get(JdbcUtil.METADATA_LOCATION));\n+  }\n+\n+  @Override\n+  public void doCommit(TableMetadata base, TableMetadata metadata) {\n+    String newMetadataLocation = writeNewMetadata(metadata, currentVersion() + 1);\n+    try {\n+      Map<String, String> table = getTable();\n+\n+      if (!table.isEmpty()) {\n+        validateMetadataLocation(table, base);\n+        String oldMetadataLocation = base.metadataFileLocation();\n+        // Start atomic update\n+        LOG.debug(\"Committing existing table: {}\", tableName());\n+        updateTable(newMetadataLocation, oldMetadataLocation);\n+      } else {\n+        // table not exists create it\n+        LOG.debug(\"Committing new table: {}\", tableName());\n+        createTable(newMetadataLocation);\n+      }\n+\n+    } catch (SQLIntegrityConstraintViolationException e) {\n+      throw new AlreadyExistsException(e, \"Table already exists, maybe another process created it\");\n+    } catch (SQLTimeoutException e) {\n+      throw new UncheckedSQLException(e, \"Database Connection timeout\");\n+    } catch (SQLTransientConnectionException | SQLNonTransientConnectionException e) {\n+      throw new UncheckedSQLException(e, \"Database Connection failed\");\n+    } catch (DataTruncation e) {\n+      throw new UncheckedSQLException(e, \"Database data truncation error\");\n+    } catch (SQLWarning e) {\n+      throw new UncheckedSQLException(e, \"Database warning\");\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(e, \"Failed to connect to database\");\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new UncheckedInterruptedException(e, \"Interrupted during commit\");\n+    }\n+  }\n+\n+  private void updateTable(String newMetadataLocation, String oldMetadataLocation)\n+      throws SQLException, InterruptedException {\n+    int updatedRecords = connections.run(conn -> {\n+      try (PreparedStatement sql = conn.prepareStatement(JdbcUtil.DO_COMMIT_SQL)) {\n+        // UPDATE\n+        sql.setString(1, newMetadataLocation);\n+        sql.setString(2, oldMetadataLocation);\n+        // WHERE\n+        sql.setString(3, catalogName);\n+        sql.setString(4, JdbcUtil.namespaceToString(tableIdentifier.namespace()));\n+        sql.setString(5, tableIdentifier.name());\n+        sql.setString(6, oldMetadataLocation);\n+        return sql.executeUpdate();\n+      }\n+    });\n+\n+    if (updatedRecords == 1) {\n+      LOG.debug(\"Successfully committed to existing table: {}\", tableIdentifier);\n+    } else {\n+      throw new CommitFailedException(\"Failed to update the table %s from catalog %s \" +\n+          \"Maybe another process changed it\", tableIdentifier, catalogName);\n+    }\n+\n+  }\n+\n+  private void createTable(String newMetadataLocation) throws SQLException, InterruptedException {\n+    int insertRecord = connections.run(conn -> {\n+      try (PreparedStatement sql = conn.prepareStatement(JdbcUtil.DO_COMMIT_CREATE_TABLE_SQL)) {\n+        sql.setString(1, catalogName);\n+        sql.setString(2, JdbcUtil.namespaceToString(tableIdentifier.namespace()));\n+        sql.setString(3, tableIdentifier.name());\n+        sql.setString(4, newMetadataLocation);\n+        return sql.executeUpdate();\n+      }\n+    });\n+\n+    if (insertRecord == 1) {\n+      LOG.debug(\"Successfully committed to new table: {}\", tableIdentifier);\n+    } else {\n+      throw new CommitFailedException(\"Failed to create table %s catalog %s\", tableIdentifier, catalogName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a21579f5fdbb7934f8f7ebee5c8d620830c43310"}, "originalPosition": 170}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg2OTMzMTI0", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-686933124", "createdAt": "2021-06-17T23:59:19Z", "commit": {"oid": "a21579f5fdbb7934f8f7ebee5c8d620830c43310"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xN1QyMzo1OToyMFrOJvwdog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xN1QyMzo1OToyMFrOJvwdog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1NDA1Njg2Ng==", "bodyText": "Nit: No need for \"maybe\" here. It is enough to say that the table has changed.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r654056866", "createdAt": "2021-06-17T23:59:20Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcTableOperations.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.sql.DataTruncation;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.sql.SQLWarning;\n+import java.util.Map;\n+import java.util.Objects;\n+import org.apache.iceberg.BaseMetastoreTableOperations;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.CommitFailedException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+class JdbcTableOperations extends BaseMetastoreTableOperations {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcTableOperations.class);\n+  private final String catalogName;\n+  private final TableIdentifier tableIdentifier;\n+  private final FileIO fileIO;\n+  private final JdbcClientPool connections;\n+\n+  protected JdbcTableOperations(JdbcClientPool dbConnPool, FileIO fileIO, String catalogName,\n+                                TableIdentifier tableIdentifier) {\n+    this.catalogName = catalogName;\n+    this.tableIdentifier = tableIdentifier;\n+    this.fileIO = fileIO;\n+    this.connections = dbConnPool;\n+  }\n+\n+  @Override\n+  public void doRefresh() {\n+    Map<String, String> table;\n+\n+    try {\n+      table = getTable();\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new UncheckedInterruptedException(e, \"Interrupted during refresh\");\n+    } catch (SQLException e) {\n+      // SQL exception happened when getting table from catalog\n+      throw new UncheckedSQLException(e, \"Failed to get table %s from catalog %s\", tableIdentifier, catalogName);\n+    }\n+\n+    // Table not exists AND currentMetadataLocation is not NULL!\n+    if (table.isEmpty() && currentMetadataLocation() != null) {\n+      throw new NoSuchTableException(\"Failed to get table %s from catalog %s\" +\n+          \" maybe another process deleted it\", tableIdentifier, catalogName);\n+    }\n+\n+    // Table not exists in the catalog! metadataLocation is null here!\n+    if (table.isEmpty()) {\n+      refreshFromMetadataLocation(null);\n+      return;\n+    }\n+\n+    // Table exists but metadataLocation is null\n+    if (table.getOrDefault(JdbcUtil.METADATA_LOCATION, null) == null) {\n+      throw new RuntimeException(String.format(\"Failed to get metadata location of the table %s from catalog %s\",\n+          tableIdentifier, catalogName));\n+    }\n+\n+    refreshFromMetadataLocation(table.get(JdbcUtil.METADATA_LOCATION));\n+  }\n+\n+  @Override\n+  public void doCommit(TableMetadata base, TableMetadata metadata) {\n+    String newMetadataLocation = writeNewMetadata(metadata, currentVersion() + 1);\n+    try {\n+      Map<String, String> table = getTable();\n+\n+      if (!table.isEmpty()) {\n+        validateMetadataLocation(table, base);\n+        String oldMetadataLocation = base.metadataFileLocation();\n+        // Start atomic update\n+        LOG.debug(\"Committing existing table: {}\", tableName());\n+        updateTable(newMetadataLocation, oldMetadataLocation);\n+      } else {\n+        // table not exists create it\n+        LOG.debug(\"Committing new table: {}\", tableName());\n+        createTable(newMetadataLocation);\n+      }\n+\n+    } catch (SQLIntegrityConstraintViolationException e) {\n+      throw new AlreadyExistsException(e, \"Table already exists, maybe another process created it\");\n+    } catch (SQLTimeoutException e) {\n+      throw new UncheckedSQLException(e, \"Database Connection timeout\");\n+    } catch (SQLTransientConnectionException | SQLNonTransientConnectionException e) {\n+      throw new UncheckedSQLException(e, \"Database Connection failed\");\n+    } catch (DataTruncation e) {\n+      throw new UncheckedSQLException(e, \"Database data truncation error\");\n+    } catch (SQLWarning e) {\n+      throw new UncheckedSQLException(e, \"Database warning\");\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(e, \"Failed to connect to database\");\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new UncheckedInterruptedException(e, \"Interrupted during commit\");\n+    }\n+  }\n+\n+  private void updateTable(String newMetadataLocation, String oldMetadataLocation)\n+      throws SQLException, InterruptedException {\n+    int updatedRecords = connections.run(conn -> {\n+      try (PreparedStatement sql = conn.prepareStatement(JdbcUtil.DO_COMMIT_SQL)) {\n+        // UPDATE\n+        sql.setString(1, newMetadataLocation);\n+        sql.setString(2, oldMetadataLocation);\n+        // WHERE\n+        sql.setString(3, catalogName);\n+        sql.setString(4, JdbcUtil.namespaceToString(tableIdentifier.namespace()));\n+        sql.setString(5, tableIdentifier.name());\n+        sql.setString(6, oldMetadataLocation);\n+        return sql.executeUpdate();\n+      }\n+    });\n+\n+    if (updatedRecords == 1) {\n+      LOG.debug(\"Successfully committed to existing table: {}\", tableIdentifier);\n+    } else {\n+      throw new CommitFailedException(\"Failed to update the table %s from catalog %s \" +\n+          \"Maybe another process changed it\", tableIdentifier, catalogName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a21579f5fdbb7934f8f7ebee5c8d620830c43310"}, "originalPosition": 151}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg2OTMzNzAw", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-686933700", "createdAt": "2021-06-18T00:01:01Z", "commit": {"oid": "a21579f5fdbb7934f8f7ebee5c8d620830c43310"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xOFQwMDowMTowMVrOJvwfgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xOFQwMDowMTowMVrOJvwfgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1NDA1NzM0Ng==", "bodyText": "Similar to below, no need for the \"maybe\" statement. This failed to load a table that it expected to exist.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r654057346", "createdAt": "2021-06-18T00:01:01Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcTableOperations.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.sql.DataTruncation;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.sql.SQLWarning;\n+import java.util.Map;\n+import java.util.Objects;\n+import org.apache.iceberg.BaseMetastoreTableOperations;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.CommitFailedException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+class JdbcTableOperations extends BaseMetastoreTableOperations {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcTableOperations.class);\n+  private final String catalogName;\n+  private final TableIdentifier tableIdentifier;\n+  private final FileIO fileIO;\n+  private final JdbcClientPool connections;\n+\n+  protected JdbcTableOperations(JdbcClientPool dbConnPool, FileIO fileIO, String catalogName,\n+                                TableIdentifier tableIdentifier) {\n+    this.catalogName = catalogName;\n+    this.tableIdentifier = tableIdentifier;\n+    this.fileIO = fileIO;\n+    this.connections = dbConnPool;\n+  }\n+\n+  @Override\n+  public void doRefresh() {\n+    Map<String, String> table;\n+\n+    try {\n+      table = getTable();\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new UncheckedInterruptedException(e, \"Interrupted during refresh\");\n+    } catch (SQLException e) {\n+      // SQL exception happened when getting table from catalog\n+      throw new UncheckedSQLException(e, \"Failed to get table %s from catalog %s\", tableIdentifier, catalogName);\n+    }\n+\n+    // Table not exists AND currentMetadataLocation is not NULL!\n+    if (table.isEmpty() && currentMetadataLocation() != null) {\n+      throw new NoSuchTableException(\"Failed to get table %s from catalog %s\" +\n+          \" maybe another process deleted it\", tableIdentifier, catalogName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a21579f5fdbb7934f8f7ebee5c8d620830c43310"}, "originalPosition": 77}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d9ab91975a557761dc262c85e3d87863669ca81a", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/d9ab91975a557761dc262c85e3d87863669ca81a", "committedDate": "2021-06-18T14:02:34Z", "message": "address review comments, updated logging messages"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6d99ec0d420cec9070d254427e6d599d69f14422", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/6d99ec0d420cec9070d254427e6d599d69f14422", "committedDate": "2021-06-18T14:57:26Z", "message": "address review comments, updated logging messages"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg3NTY1NjQ1", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-687565645", "createdAt": "2021-06-18T16:16:14Z", "commit": {"oid": "a21579f5fdbb7934f8f7ebee5c8d620830c43310"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xOFQxNjoxNjoxNVrOJwOfoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xOFQxNjoxNjoxNVrOJwOfoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1NDU0ODg5Ng==", "bodyText": "Because currentMetadataLocation() must be null because of the check above, this will do basically nothing. I see that this call is probably here because Hive always calls refreshFromMetadataLocation, but I don't think that it is necessary to call it here.\nI'd probably combine this with the previous check:\nif (table.isEmpty()) {\n  if (currentMetadataLocation() != null) {\n    throw new NoSuchTableException(\"Failed to load table %s from catalog %s: dropped by another process\", ...);\n  } else {\n    return;\n  }\n}", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r654548896", "createdAt": "2021-06-18T16:16:15Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcTableOperations.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.sql.DataTruncation;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.sql.SQLWarning;\n+import java.util.Map;\n+import java.util.Objects;\n+import org.apache.iceberg.BaseMetastoreTableOperations;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.CommitFailedException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+class JdbcTableOperations extends BaseMetastoreTableOperations {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcTableOperations.class);\n+  private final String catalogName;\n+  private final TableIdentifier tableIdentifier;\n+  private final FileIO fileIO;\n+  private final JdbcClientPool connections;\n+\n+  protected JdbcTableOperations(JdbcClientPool dbConnPool, FileIO fileIO, String catalogName,\n+                                TableIdentifier tableIdentifier) {\n+    this.catalogName = catalogName;\n+    this.tableIdentifier = tableIdentifier;\n+    this.fileIO = fileIO;\n+    this.connections = dbConnPool;\n+  }\n+\n+  @Override\n+  public void doRefresh() {\n+    Map<String, String> table;\n+\n+    try {\n+      table = getTable();\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new UncheckedInterruptedException(e, \"Interrupted during refresh\");\n+    } catch (SQLException e) {\n+      // SQL exception happened when getting table from catalog\n+      throw new UncheckedSQLException(e, \"Failed to get table %s from catalog %s\", tableIdentifier, catalogName);\n+    }\n+\n+    // Table not exists AND currentMetadataLocation is not NULL!\n+    if (table.isEmpty() && currentMetadataLocation() != null) {\n+      throw new NoSuchTableException(\"Failed to get table %s from catalog %s\" +\n+          \" maybe another process deleted it\", tableIdentifier, catalogName);\n+    }\n+\n+    // Table not exists in the catalog! metadataLocation is null here!\n+    if (table.isEmpty()) {\n+      refreshFromMetadataLocation(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a21579f5fdbb7934f8f7ebee5c8d620830c43310"}, "originalPosition": 82}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg3NTY3MjUy", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-687567252", "createdAt": "2021-06-18T16:18:39Z", "commit": {"oid": "a21579f5fdbb7934f8f7ebee5c8d620830c43310"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xOFQxNjoxODozOVrOJwOkZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xOFQxNjoxODozOVrOJwOkZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1NDU1MDExNw==", "bodyText": "This get is done twice. Can you refactor to use a variable? I think this should also be IllegalStateException rather than just a RuntimeException so you could do this:\nString newMetadataLocation = table.get(JdbcUtil.METADATA_LOCATION);\nPreconditions.checkState(newMetadataLocation != null, \"Invalid table %s: metadata location is null\", tableIdentifier);\n\nrefreshFromMetadataLocation(newMetadataLocation);", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r654550117", "createdAt": "2021-06-18T16:18:39Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcTableOperations.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.sql.DataTruncation;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.sql.SQLWarning;\n+import java.util.Map;\n+import java.util.Objects;\n+import org.apache.iceberg.BaseMetastoreTableOperations;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.CommitFailedException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+class JdbcTableOperations extends BaseMetastoreTableOperations {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcTableOperations.class);\n+  private final String catalogName;\n+  private final TableIdentifier tableIdentifier;\n+  private final FileIO fileIO;\n+  private final JdbcClientPool connections;\n+\n+  protected JdbcTableOperations(JdbcClientPool dbConnPool, FileIO fileIO, String catalogName,\n+                                TableIdentifier tableIdentifier) {\n+    this.catalogName = catalogName;\n+    this.tableIdentifier = tableIdentifier;\n+    this.fileIO = fileIO;\n+    this.connections = dbConnPool;\n+  }\n+\n+  @Override\n+  public void doRefresh() {\n+    Map<String, String> table;\n+\n+    try {\n+      table = getTable();\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new UncheckedInterruptedException(e, \"Interrupted during refresh\");\n+    } catch (SQLException e) {\n+      // SQL exception happened when getting table from catalog\n+      throw new UncheckedSQLException(e, \"Failed to get table %s from catalog %s\", tableIdentifier, catalogName);\n+    }\n+\n+    // Table not exists AND currentMetadataLocation is not NULL!\n+    if (table.isEmpty() && currentMetadataLocation() != null) {\n+      throw new NoSuchTableException(\"Failed to get table %s from catalog %s\" +\n+          \" maybe another process deleted it\", tableIdentifier, catalogName);\n+    }\n+\n+    // Table not exists in the catalog! metadataLocation is null here!\n+    if (table.isEmpty()) {\n+      refreshFromMetadataLocation(null);\n+      return;\n+    }\n+\n+    // Table exists but metadataLocation is null\n+    if (table.getOrDefault(JdbcUtil.METADATA_LOCATION, null) == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a21579f5fdbb7934f8f7ebee5c8d620830c43310"}, "originalPosition": 87}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg3NTY4NDUz", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-687568453", "createdAt": "2021-06-18T16:20:21Z", "commit": {"oid": "a21579f5fdbb7934f8f7ebee5c8d620830c43310"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xOFQxNjoyMDoyMVrOJwOnyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xOFQxNjoyMDoyMVrOJwOnyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1NDU1MDk4NA==", "bodyText": "I think this can just be table.get(JdbcUtil.METADATA_LOCATION).", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r654550984", "createdAt": "2021-06-18T16:20:21Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcTableOperations.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.sql.DataTruncation;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.sql.SQLWarning;\n+import java.util.Map;\n+import java.util.Objects;\n+import org.apache.iceberg.BaseMetastoreTableOperations;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.CommitFailedException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+class JdbcTableOperations extends BaseMetastoreTableOperations {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcTableOperations.class);\n+  private final String catalogName;\n+  private final TableIdentifier tableIdentifier;\n+  private final FileIO fileIO;\n+  private final JdbcClientPool connections;\n+\n+  protected JdbcTableOperations(JdbcClientPool dbConnPool, FileIO fileIO, String catalogName,\n+                                TableIdentifier tableIdentifier) {\n+    this.catalogName = catalogName;\n+    this.tableIdentifier = tableIdentifier;\n+    this.fileIO = fileIO;\n+    this.connections = dbConnPool;\n+  }\n+\n+  @Override\n+  public void doRefresh() {\n+    Map<String, String> table;\n+\n+    try {\n+      table = getTable();\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new UncheckedInterruptedException(e, \"Interrupted during refresh\");\n+    } catch (SQLException e) {\n+      // SQL exception happened when getting table from catalog\n+      throw new UncheckedSQLException(e, \"Failed to get table %s from catalog %s\", tableIdentifier, catalogName);\n+    }\n+\n+    // Table not exists AND currentMetadataLocation is not NULL!\n+    if (table.isEmpty() && currentMetadataLocation() != null) {\n+      throw new NoSuchTableException(\"Failed to get table %s from catalog %s\" +\n+          \" maybe another process deleted it\", tableIdentifier, catalogName);\n+    }\n+\n+    // Table not exists in the catalog! metadataLocation is null here!\n+    if (table.isEmpty()) {\n+      refreshFromMetadataLocation(null);\n+      return;\n+    }\n+\n+    // Table exists but metadataLocation is null\n+    if (table.getOrDefault(JdbcUtil.METADATA_LOCATION, null) == null) {\n+      throw new RuntimeException(String.format(\"Failed to get metadata location of the table %s from catalog %s\",\n+          tableIdentifier, catalogName));\n+    }\n+\n+    refreshFromMetadataLocation(table.get(JdbcUtil.METADATA_LOCATION));\n+  }\n+\n+  @Override\n+  public void doCommit(TableMetadata base, TableMetadata metadata) {\n+    String newMetadataLocation = writeNewMetadata(metadata, currentVersion() + 1);\n+    try {\n+      Map<String, String> table = getTable();\n+\n+      if (!table.isEmpty()) {\n+        validateMetadataLocation(table, base);\n+        String oldMetadataLocation = base.metadataFileLocation();\n+        // Start atomic update\n+        LOG.debug(\"Committing existing table: {}\", tableName());\n+        updateTable(newMetadataLocation, oldMetadataLocation);\n+      } else {\n+        // table not exists create it\n+        LOG.debug(\"Committing new table: {}\", tableName());\n+        createTable(newMetadataLocation);\n+      }\n+\n+    } catch (SQLIntegrityConstraintViolationException e) {\n+      throw new AlreadyExistsException(e, \"Table already exists, maybe another process created it\");\n+    } catch (SQLTimeoutException e) {\n+      throw new UncheckedSQLException(e, \"Database Connection timeout\");\n+    } catch (SQLTransientConnectionException | SQLNonTransientConnectionException e) {\n+      throw new UncheckedSQLException(e, \"Database Connection failed\");\n+    } catch (DataTruncation e) {\n+      throw new UncheckedSQLException(e, \"Database data truncation error\");\n+    } catch (SQLWarning e) {\n+      throw new UncheckedSQLException(e, \"Database warning\");\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(e, \"Failed to connect to database\");\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new UncheckedInterruptedException(e, \"Interrupted during commit\");\n+    }\n+  }\n+\n+  private void updateTable(String newMetadataLocation, String oldMetadataLocation)\n+      throws SQLException, InterruptedException {\n+    int updatedRecords = connections.run(conn -> {\n+      try (PreparedStatement sql = conn.prepareStatement(JdbcUtil.DO_COMMIT_SQL)) {\n+        // UPDATE\n+        sql.setString(1, newMetadataLocation);\n+        sql.setString(2, oldMetadataLocation);\n+        // WHERE\n+        sql.setString(3, catalogName);\n+        sql.setString(4, JdbcUtil.namespaceToString(tableIdentifier.namespace()));\n+        sql.setString(5, tableIdentifier.name());\n+        sql.setString(6, oldMetadataLocation);\n+        return sql.executeUpdate();\n+      }\n+    });\n+\n+    if (updatedRecords == 1) {\n+      LOG.debug(\"Successfully committed to existing table: {}\", tableIdentifier);\n+    } else {\n+      throw new CommitFailedException(\"Failed to update the table %s from catalog %s \" +\n+          \"Maybe another process changed it\", tableIdentifier, catalogName);\n+    }\n+\n+  }\n+\n+  private void createTable(String newMetadataLocation) throws SQLException, InterruptedException {\n+    int insertRecord = connections.run(conn -> {\n+      try (PreparedStatement sql = conn.prepareStatement(JdbcUtil.DO_COMMIT_CREATE_TABLE_SQL)) {\n+        sql.setString(1, catalogName);\n+        sql.setString(2, JdbcUtil.namespaceToString(tableIdentifier.namespace()));\n+        sql.setString(3, tableIdentifier.name());\n+        sql.setString(4, newMetadataLocation);\n+        return sql.executeUpdate();\n+      }\n+    });\n+\n+    if (insertRecord == 1) {\n+      LOG.debug(\"Successfully committed to new table: {}\", tableIdentifier);\n+    } else {\n+      throw new CommitFailedException(\"Failed to create table %s catalog %s\", tableIdentifier, catalogName);\n+    }\n+  }\n+\n+  private void validateMetadataLocation(Map<String, String> table, TableMetadata base) {\n+    String catalogMetadataLocation = !table.isEmpty() ? table.get(JdbcUtil.METADATA_LOCATION) : null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a21579f5fdbb7934f8f7ebee5c8d620830c43310"}, "originalPosition": 175}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg3NTY5MTkz", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-687569193", "createdAt": "2021-06-18T16:21:28Z", "commit": {"oid": "a21579f5fdbb7934f8f7ebee5c8d620830c43310"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xOFQxNjoyMToyOFrOJwOqJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xOFQxNjoyMToyOFrOJwOqJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1NDU1MTU4OQ==", "bodyText": "Nit: error message could be more concise: \"Cannot commit %s: metadata location %s has changed from %s\"", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r654551589", "createdAt": "2021-06-18T16:21:28Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcTableOperations.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.sql.DataTruncation;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.sql.SQLWarning;\n+import java.util.Map;\n+import java.util.Objects;\n+import org.apache.iceberg.BaseMetastoreTableOperations;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.CommitFailedException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+class JdbcTableOperations extends BaseMetastoreTableOperations {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcTableOperations.class);\n+  private final String catalogName;\n+  private final TableIdentifier tableIdentifier;\n+  private final FileIO fileIO;\n+  private final JdbcClientPool connections;\n+\n+  protected JdbcTableOperations(JdbcClientPool dbConnPool, FileIO fileIO, String catalogName,\n+                                TableIdentifier tableIdentifier) {\n+    this.catalogName = catalogName;\n+    this.tableIdentifier = tableIdentifier;\n+    this.fileIO = fileIO;\n+    this.connections = dbConnPool;\n+  }\n+\n+  @Override\n+  public void doRefresh() {\n+    Map<String, String> table;\n+\n+    try {\n+      table = getTable();\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new UncheckedInterruptedException(e, \"Interrupted during refresh\");\n+    } catch (SQLException e) {\n+      // SQL exception happened when getting table from catalog\n+      throw new UncheckedSQLException(e, \"Failed to get table %s from catalog %s\", tableIdentifier, catalogName);\n+    }\n+\n+    // Table not exists AND currentMetadataLocation is not NULL!\n+    if (table.isEmpty() && currentMetadataLocation() != null) {\n+      throw new NoSuchTableException(\"Failed to get table %s from catalog %s\" +\n+          \" maybe another process deleted it\", tableIdentifier, catalogName);\n+    }\n+\n+    // Table not exists in the catalog! metadataLocation is null here!\n+    if (table.isEmpty()) {\n+      refreshFromMetadataLocation(null);\n+      return;\n+    }\n+\n+    // Table exists but metadataLocation is null\n+    if (table.getOrDefault(JdbcUtil.METADATA_LOCATION, null) == null) {\n+      throw new RuntimeException(String.format(\"Failed to get metadata location of the table %s from catalog %s\",\n+          tableIdentifier, catalogName));\n+    }\n+\n+    refreshFromMetadataLocation(table.get(JdbcUtil.METADATA_LOCATION));\n+  }\n+\n+  @Override\n+  public void doCommit(TableMetadata base, TableMetadata metadata) {\n+    String newMetadataLocation = writeNewMetadata(metadata, currentVersion() + 1);\n+    try {\n+      Map<String, String> table = getTable();\n+\n+      if (!table.isEmpty()) {\n+        validateMetadataLocation(table, base);\n+        String oldMetadataLocation = base.metadataFileLocation();\n+        // Start atomic update\n+        LOG.debug(\"Committing existing table: {}\", tableName());\n+        updateTable(newMetadataLocation, oldMetadataLocation);\n+      } else {\n+        // table not exists create it\n+        LOG.debug(\"Committing new table: {}\", tableName());\n+        createTable(newMetadataLocation);\n+      }\n+\n+    } catch (SQLIntegrityConstraintViolationException e) {\n+      throw new AlreadyExistsException(e, \"Table already exists, maybe another process created it\");\n+    } catch (SQLTimeoutException e) {\n+      throw new UncheckedSQLException(e, \"Database Connection timeout\");\n+    } catch (SQLTransientConnectionException | SQLNonTransientConnectionException e) {\n+      throw new UncheckedSQLException(e, \"Database Connection failed\");\n+    } catch (DataTruncation e) {\n+      throw new UncheckedSQLException(e, \"Database data truncation error\");\n+    } catch (SQLWarning e) {\n+      throw new UncheckedSQLException(e, \"Database warning\");\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(e, \"Failed to connect to database\");\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new UncheckedInterruptedException(e, \"Interrupted during commit\");\n+    }\n+  }\n+\n+  private void updateTable(String newMetadataLocation, String oldMetadataLocation)\n+      throws SQLException, InterruptedException {\n+    int updatedRecords = connections.run(conn -> {\n+      try (PreparedStatement sql = conn.prepareStatement(JdbcUtil.DO_COMMIT_SQL)) {\n+        // UPDATE\n+        sql.setString(1, newMetadataLocation);\n+        sql.setString(2, oldMetadataLocation);\n+        // WHERE\n+        sql.setString(3, catalogName);\n+        sql.setString(4, JdbcUtil.namespaceToString(tableIdentifier.namespace()));\n+        sql.setString(5, tableIdentifier.name());\n+        sql.setString(6, oldMetadataLocation);\n+        return sql.executeUpdate();\n+      }\n+    });\n+\n+    if (updatedRecords == 1) {\n+      LOG.debug(\"Successfully committed to existing table: {}\", tableIdentifier);\n+    } else {\n+      throw new CommitFailedException(\"Failed to update the table %s from catalog %s \" +\n+          \"Maybe another process changed it\", tableIdentifier, catalogName);\n+    }\n+\n+  }\n+\n+  private void createTable(String newMetadataLocation) throws SQLException, InterruptedException {\n+    int insertRecord = connections.run(conn -> {\n+      try (PreparedStatement sql = conn.prepareStatement(JdbcUtil.DO_COMMIT_CREATE_TABLE_SQL)) {\n+        sql.setString(1, catalogName);\n+        sql.setString(2, JdbcUtil.namespaceToString(tableIdentifier.namespace()));\n+        sql.setString(3, tableIdentifier.name());\n+        sql.setString(4, newMetadataLocation);\n+        return sql.executeUpdate();\n+      }\n+    });\n+\n+    if (insertRecord == 1) {\n+      LOG.debug(\"Successfully committed to new table: {}\", tableIdentifier);\n+    } else {\n+      throw new CommitFailedException(\"Failed to create table %s catalog %s\", tableIdentifier, catalogName);\n+    }\n+  }\n+\n+  private void validateMetadataLocation(Map<String, String> table, TableMetadata base) {\n+    String catalogMetadataLocation = !table.isEmpty() ? table.get(JdbcUtil.METADATA_LOCATION) : null;\n+    String baseMetadataLocation = base != null ? base.metadataFileLocation() : null;\n+\n+    if (!Objects.equals(baseMetadataLocation, catalogMetadataLocation)) {\n+      throw new CommitFailedException(\n+          \"Cannot commit %s because base metadata location '%s' is not same as the current Catalog location '%s'\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a21579f5fdbb7934f8f7ebee5c8d620830c43310"}, "originalPosition": 180}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg3NTcxNTM3", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-687571537", "createdAt": "2021-06-18T16:24:53Z", "commit": {"oid": "a21579f5fdbb7934f8f7ebee5c8d620830c43310"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xOFQxNjoyNDo1M1rOJwOxmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xOFQxNjoyNDo1M1rOJwOxmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1NDU1MzQ5Nw==", "bodyText": "I think this should only be thrown if currentMetadataLocation() is null because that indicates this is a new table. Otherwise, I think this should throw UncheckedSQLException.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r654553497", "createdAt": "2021-06-18T16:24:53Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcTableOperations.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.sql.DataTruncation;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.sql.SQLWarning;\n+import java.util.Map;\n+import java.util.Objects;\n+import org.apache.iceberg.BaseMetastoreTableOperations;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.CommitFailedException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+class JdbcTableOperations extends BaseMetastoreTableOperations {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcTableOperations.class);\n+  private final String catalogName;\n+  private final TableIdentifier tableIdentifier;\n+  private final FileIO fileIO;\n+  private final JdbcClientPool connections;\n+\n+  protected JdbcTableOperations(JdbcClientPool dbConnPool, FileIO fileIO, String catalogName,\n+                                TableIdentifier tableIdentifier) {\n+    this.catalogName = catalogName;\n+    this.tableIdentifier = tableIdentifier;\n+    this.fileIO = fileIO;\n+    this.connections = dbConnPool;\n+  }\n+\n+  @Override\n+  public void doRefresh() {\n+    Map<String, String> table;\n+\n+    try {\n+      table = getTable();\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new UncheckedInterruptedException(e, \"Interrupted during refresh\");\n+    } catch (SQLException e) {\n+      // SQL exception happened when getting table from catalog\n+      throw new UncheckedSQLException(e, \"Failed to get table %s from catalog %s\", tableIdentifier, catalogName);\n+    }\n+\n+    // Table not exists AND currentMetadataLocation is not NULL!\n+    if (table.isEmpty() && currentMetadataLocation() != null) {\n+      throw new NoSuchTableException(\"Failed to get table %s from catalog %s\" +\n+          \" maybe another process deleted it\", tableIdentifier, catalogName);\n+    }\n+\n+    // Table not exists in the catalog! metadataLocation is null here!\n+    if (table.isEmpty()) {\n+      refreshFromMetadataLocation(null);\n+      return;\n+    }\n+\n+    // Table exists but metadataLocation is null\n+    if (table.getOrDefault(JdbcUtil.METADATA_LOCATION, null) == null) {\n+      throw new RuntimeException(String.format(\"Failed to get metadata location of the table %s from catalog %s\",\n+          tableIdentifier, catalogName));\n+    }\n+\n+    refreshFromMetadataLocation(table.get(JdbcUtil.METADATA_LOCATION));\n+  }\n+\n+  @Override\n+  public void doCommit(TableMetadata base, TableMetadata metadata) {\n+    String newMetadataLocation = writeNewMetadata(metadata, currentVersion() + 1);\n+    try {\n+      Map<String, String> table = getTable();\n+\n+      if (!table.isEmpty()) {\n+        validateMetadataLocation(table, base);\n+        String oldMetadataLocation = base.metadataFileLocation();\n+        // Start atomic update\n+        LOG.debug(\"Committing existing table: {}\", tableName());\n+        updateTable(newMetadataLocation, oldMetadataLocation);\n+      } else {\n+        // table not exists create it\n+        LOG.debug(\"Committing new table: {}\", tableName());\n+        createTable(newMetadataLocation);\n+      }\n+\n+    } catch (SQLIntegrityConstraintViolationException e) {\n+      throw new AlreadyExistsException(e, \"Table already exists, maybe another process created it\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a21579f5fdbb7934f8f7ebee5c8d620830c43310"}, "originalPosition": 114}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg3NTcyMTgx", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-687572181", "createdAt": "2021-06-18T16:25:47Z", "commit": {"oid": "a21579f5fdbb7934f8f7ebee5c8d620830c43310"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xOFQxNjoyNTo0N1rOJwOzaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xOFQxNjoyNTo0N1rOJwOzaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1NDU1Mzk2Mw==", "bodyText": "I don't think that \"failed to connect\" is necessarily correct since the SQL exception is generic. How about \"Unknown failure\"?", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r654553963", "createdAt": "2021-06-18T16:25:47Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcTableOperations.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.sql.DataTruncation;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.sql.SQLWarning;\n+import java.util.Map;\n+import java.util.Objects;\n+import org.apache.iceberg.BaseMetastoreTableOperations;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.CommitFailedException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+class JdbcTableOperations extends BaseMetastoreTableOperations {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcTableOperations.class);\n+  private final String catalogName;\n+  private final TableIdentifier tableIdentifier;\n+  private final FileIO fileIO;\n+  private final JdbcClientPool connections;\n+\n+  protected JdbcTableOperations(JdbcClientPool dbConnPool, FileIO fileIO, String catalogName,\n+                                TableIdentifier tableIdentifier) {\n+    this.catalogName = catalogName;\n+    this.tableIdentifier = tableIdentifier;\n+    this.fileIO = fileIO;\n+    this.connections = dbConnPool;\n+  }\n+\n+  @Override\n+  public void doRefresh() {\n+    Map<String, String> table;\n+\n+    try {\n+      table = getTable();\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new UncheckedInterruptedException(e, \"Interrupted during refresh\");\n+    } catch (SQLException e) {\n+      // SQL exception happened when getting table from catalog\n+      throw new UncheckedSQLException(e, \"Failed to get table %s from catalog %s\", tableIdentifier, catalogName);\n+    }\n+\n+    // Table not exists AND currentMetadataLocation is not NULL!\n+    if (table.isEmpty() && currentMetadataLocation() != null) {\n+      throw new NoSuchTableException(\"Failed to get table %s from catalog %s\" +\n+          \" maybe another process deleted it\", tableIdentifier, catalogName);\n+    }\n+\n+    // Table not exists in the catalog! metadataLocation is null here!\n+    if (table.isEmpty()) {\n+      refreshFromMetadataLocation(null);\n+      return;\n+    }\n+\n+    // Table exists but metadataLocation is null\n+    if (table.getOrDefault(JdbcUtil.METADATA_LOCATION, null) == null) {\n+      throw new RuntimeException(String.format(\"Failed to get metadata location of the table %s from catalog %s\",\n+          tableIdentifier, catalogName));\n+    }\n+\n+    refreshFromMetadataLocation(table.get(JdbcUtil.METADATA_LOCATION));\n+  }\n+\n+  @Override\n+  public void doCommit(TableMetadata base, TableMetadata metadata) {\n+    String newMetadataLocation = writeNewMetadata(metadata, currentVersion() + 1);\n+    try {\n+      Map<String, String> table = getTable();\n+\n+      if (!table.isEmpty()) {\n+        validateMetadataLocation(table, base);\n+        String oldMetadataLocation = base.metadataFileLocation();\n+        // Start atomic update\n+        LOG.debug(\"Committing existing table: {}\", tableName());\n+        updateTable(newMetadataLocation, oldMetadataLocation);\n+      } else {\n+        // table not exists create it\n+        LOG.debug(\"Committing new table: {}\", tableName());\n+        createTable(newMetadataLocation);\n+      }\n+\n+    } catch (SQLIntegrityConstraintViolationException e) {\n+      throw new AlreadyExistsException(e, \"Table already exists, maybe another process created it\");\n+    } catch (SQLTimeoutException e) {\n+      throw new UncheckedSQLException(e, \"Database Connection timeout\");\n+    } catch (SQLTransientConnectionException | SQLNonTransientConnectionException e) {\n+      throw new UncheckedSQLException(e, \"Database Connection failed\");\n+    } catch (DataTruncation e) {\n+      throw new UncheckedSQLException(e, \"Database data truncation error\");\n+    } catch (SQLWarning e) {\n+      throw new UncheckedSQLException(e, \"Database warning\");\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(e, \"Failed to connect to database\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a21579f5fdbb7934f8f7ebee5c8d620830c43310"}, "originalPosition": 124}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c7942523f9b816f8067876a84c664b5db3d9c9fc", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/c7942523f9b816f8067876a84c664b5db3d9c9fc", "committedDate": "2021-06-19T15:46:14Z", "message": "address review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5f1be4c978c75e39fbd98dbd77d3441fb5266e11", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/5f1be4c978c75e39fbd98dbd77d3441fb5266e11", "committedDate": "2021-06-19T15:49:29Z", "message": "address review comments, disable refresh when currentMetadataLocation is null"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d323722abed0acad3dab17e7aa0dffc230d7e844", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/d323722abed0acad3dab17e7aa0dffc230d7e844", "committedDate": "2021-06-19T16:09:01Z", "message": "fix checkstyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8b4b3e8ad8b1e885e64ebf9b398b8ed460cd87ae", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/8b4b3e8ad8b1e885e64ebf9b398b8ed460cd87ae", "committedDate": "2021-06-19T16:19:11Z", "message": "fix checkstyle"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg4ODg4MjM3", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-688888237", "createdAt": "2021-06-21T21:48:20Z", "commit": {"oid": "8b4b3e8ad8b1e885e64ebf9b398b8ed460cd87ae"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0MTkwMTYz", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-544190163", "createdAt": "2020-12-03T17:12:21Z", "commit": {"oid": "a97dfce94e656b4af5cac669790d76257996bc6a"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNzoxMjoyMlrOH-nxfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNzozNDoxMlrOH-otgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQyNTQwNA==", "bodyText": "nit: the variable should be deletedRecords", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r535425404", "createdAt": "2020-12-03T17:12:22Z", "author": {"login": "jackye1995"}, "path": "core/src/main/java/org/apache/iceberg/hadoop/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.hadoop;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.commons.dbutils.DbUtils;\n+import org.apache.commons.dbutils.QueryRunner;\n+import org.apache.commons.dbutils.handlers.BeanListHandler;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.exceptions.RuntimeIOException;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, Closeable {\n+\n+  public static final String JDBC_CATALOG_DEFAULT_NAME = \"default_catalog\";\n+  public static final String JDBC_CATALOG_TABLE_NAME = \"iceberg_catalog\";\n+  public static final String JDB_CATALOG_TABLE_DDL = \"CREATE TABLE IF NOT EXISTS \" +\n+          JDBC_CATALOG_TABLE_NAME + \" ( \" +\n+          \"catalogName VARCHAR(1255) NOT NULL,\" +\n+          \"tableNamespace VARCHAR(1255),\" +\n+          \"tableName VARCHAR(1255) NOT NULL,\" +\n+          \"metadataLocation VARCHAR(66255),\" +\n+          \"previousMetadataLocation VARCHAR(66255),\" +\n+          \"PRIMARY KEY (catalogName,tableNamespace,tableName)  \" +\n+          \")\";\n+  public static final String JDBC_NAMESPACE_TABLE_LIST = \"SELECT catalogName, tableNamespace, tableName, \" +\n+          \"metadataLocation, previousMetadataLocation FROM \" + JDBC_CATALOG_TABLE_NAME + \" \" +\n+          \"WHERE catalogName = ? AND tableNamespace = ?\";\n+  public static final String JDBC_TABLE_RENAME = \"UPDATE \" + JDBC_CATALOG_TABLE_NAME + \" SET tableNamespace = ? , \" +\n+          \"tableName = ? WHERE catalogName = ? AND tableNamespace = ? AND tableName = ? \";\n+  public static final String JDBC_TABLE_DROP = \"DELETE FROM \" + JDBC_CATALOG_TABLE_NAME + \" WHERE catalogName = ? \" +\n+          \"AND tableNamespace = ? AND tableName = ? \";\n+  public static final String JDBC_TABLE_SELECT = \"SELECT catalogName, tableNamespace, tableName, metadataLocation, \" +\n+          \"previousMetadataLocation FROM \" + JDBC_CATALOG_TABLE_NAME + \" WHERE catalogName = ? \" +\n+          \"AND tableNamespace = ? AND tableName = ? \";\n+  public static final String JDBC_TABLE_INSERT = \"INSERT INTO \" + JDBC_CATALOG_TABLE_NAME + \" (catalogName, \" +\n+          \"tableNamespace, tableName, metadataLocation, previousMetadataLocation) VALUES (?,?,?,?,?)\";\n+  public static final String JDBC_TABLE_UPDATE_METADATA = \"UPDATE \" + JDBC_CATALOG_TABLE_NAME + \" \" +\n+          \"SET metadataLocation = ? , previousMetadataLocation = ? WHERE catalogName = ? AND tableNamespace = ? \" +\n+          \"AND tableName = ? \";\n+\n+  public static final String JDBC_CATALOG_JDBC_DRIVER = \"jdbccatalog.jdbcdriver\";\n+  public static final String JDBC_CATALOG_DBURL = \"jdbccatalog.dburl\";\n+  public static final String JDBC_CATALOG_USER = \"jdbccatalog.user\";\n+  public static final String JDBC_CATALOG_PASSWORD = \"jdbccatalog.password\";\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcCatalog.class);\n+  private final QueryRunner queryRunner = new QueryRunner();\n+  private FileIO fileIO;\n+  private String catalogName = JDBC_CATALOG_DEFAULT_NAME;\n+  private String warehouseLocation;\n+  private Configuration hadoopConf;\n+  private Connection jdbcConnection;\n+\n+\n+  public JdbcCatalog() {\n+  }\n+\n+  private void createCatalogIfNotExists() throws SQLException {\n+    queryRunner.execute(jdbcConnection, JDB_CATALOG_TABLE_DDL);\n+    LOG.debug(\"Created Jdbc table '{}' to store iceberg catalog!\", JDBC_CATALOG_TABLE_NAME);\n+  }\n+\n+  @Override\n+  public void initialize(String name, Map<String, String> properties) {\n+    Preconditions.checkArgument(properties.get(CatalogProperties.WAREHOUSE_LOCATION) != null &&\n+                    !properties.get(CatalogProperties.WAREHOUSE_LOCATION).equals(\"\"),\n+            \"no location provided for warehouse\");\n+    Preconditions.checkArgument(!properties.getOrDefault(JDBC_CATALOG_JDBC_DRIVER, \"\").equals(\"\"),\n+            \"no jdbc driver classname provided!\");\n+    Preconditions.checkArgument(!properties.getOrDefault(JDBC_CATALOG_DBURL, \"\").equals(\"\"),\n+            \"no jdbc connection url provided!\");\n+    Preconditions.checkArgument(!properties.getOrDefault(JDBC_CATALOG_USER, \"\").equals(\"\"),\n+            \"no jdbc database user provided!\");\n+    Preconditions.checkArgument(!properties.getOrDefault(JDBC_CATALOG_PASSWORD, \"\").equals(\"\"),\n+            \"no jdbc database user password provided!\");\n+    String catalogJdbcDriver = properties.get(JDBC_CATALOG_JDBC_DRIVER);\n+    String catalogDburl = properties.get(JDBC_CATALOG_DBURL);\n+    String catalogUser = properties.get(JDBC_CATALOG_USER);\n+    String catalogDbpassword = properties.get(JDBC_CATALOG_PASSWORD);\n+    this.catalogName = name;\n+    this.warehouseLocation = properties.get(CatalogProperties.WAREHOUSE_LOCATION).replaceAll(\"/*$\", \"\");\n+\n+    String fileIOImpl = properties.get(CatalogProperties.FILE_IO_IMPL);\n+    this.fileIO = fileIOImpl == null ? new HadoopFileIO(hadoopConf) : CatalogUtil.loadFileIO(fileIOImpl, properties,\n+            hadoopConf);\n+\n+    DbUtils.loadDriver(catalogJdbcDriver);\n+    LOG.debug(\"Connecting to Jdbc database {}.\", catalogDburl);\n+    try {\n+      jdbcConnection = DriverManager.getConnection(catalogDburl, catalogUser, catalogDbpassword);\n+      createCatalogIfNotExists();\n+    } catch (SQLException throwables) {\n+      throw new RuntimeIOException(\"Failed to initialize Jdbc Catalog!\\n %s %s\", throwables.getErrorCode(),\n+              throwables.getMessage());\n+    }\n+\n+  }\n+\n+\n+  @Override\n+  protected TableOperations newTableOps(TableIdentifier tableIdentifier) {\n+    return new JdbcTableOperations(jdbcConnection, fileIO, catalogName, tableIdentifier);\n+  }\n+\n+  @Override\n+  protected String defaultWarehouseLocation(TableIdentifier tableIdentifier) {\n+    String tableName = tableIdentifier.name();\n+    StringBuilder sb = new StringBuilder();\n+\n+    sb.append(warehouseLocation).append('/');\n+    for (String level : tableIdentifier.namespace().levels()) {\n+      sb.append(level).append('/');\n+    }\n+    sb.append(tableName);\n+\n+    return sb.toString();\n+  }\n+\n+  @Override\n+  public boolean dropTable(TableIdentifier identifier, boolean purge) {\n+    TableOperations ops = newTableOps(identifier);\n+    TableMetadata lastMetadata = ops.current();\n+    try {\n+      int insertedRecords = 0;\n+      insertedRecords = queryRunner.update(jdbcConnection, JDBC_TABLE_DROP, catalogName,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a97dfce94e656b4af5cac669790d76257996bc6a"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQyNzEzNw==", "bodyText": "nit: Following the convention of hive and hadoop catalog, the default name should probably be \"jdbc\"", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r535427137", "createdAt": "2020-12-03T17:14:42Z", "author": {"login": "jackye1995"}, "path": "core/src/main/java/org/apache/iceberg/hadoop/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.hadoop;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.commons.dbutils.DbUtils;\n+import org.apache.commons.dbutils.QueryRunner;\n+import org.apache.commons.dbutils.handlers.BeanListHandler;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.exceptions.RuntimeIOException;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, Closeable {\n+\n+  public static final String JDBC_CATALOG_DEFAULT_NAME = \"default_catalog\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a97dfce94e656b4af5cac669790d76257996bc6a"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQyODI5Mg==", "bodyText": "nit: why not just select *?", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r535428292", "createdAt": "2020-12-03T17:16:21Z", "author": {"login": "jackye1995"}, "path": "core/src/main/java/org/apache/iceberg/hadoop/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.hadoop;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.commons.dbutils.DbUtils;\n+import org.apache.commons.dbutils.QueryRunner;\n+import org.apache.commons.dbutils.handlers.BeanListHandler;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.exceptions.RuntimeIOException;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, Closeable {\n+\n+  public static final String JDBC_CATALOG_DEFAULT_NAME = \"default_catalog\";\n+  public static final String JDBC_CATALOG_TABLE_NAME = \"iceberg_catalog\";\n+  public static final String JDB_CATALOG_TABLE_DDL = \"CREATE TABLE IF NOT EXISTS \" +\n+          JDBC_CATALOG_TABLE_NAME + \" ( \" +\n+          \"catalogName VARCHAR(1255) NOT NULL,\" +\n+          \"tableNamespace VARCHAR(1255),\" +\n+          \"tableName VARCHAR(1255) NOT NULL,\" +\n+          \"metadataLocation VARCHAR(66255),\" +\n+          \"previousMetadataLocation VARCHAR(66255),\" +\n+          \"PRIMARY KEY (catalogName,tableNamespace,tableName)  \" +\n+          \")\";\n+  public static final String JDBC_NAMESPACE_TABLE_LIST = \"SELECT catalogName, tableNamespace, tableName, \" +\n+          \"metadataLocation, previousMetadataLocation FROM \" + JDBC_CATALOG_TABLE_NAME + \" \" +\n+          \"WHERE catalogName = ? AND tableNamespace = ?\";\n+  public static final String JDBC_TABLE_RENAME = \"UPDATE \" + JDBC_CATALOG_TABLE_NAME + \" SET tableNamespace = ? , \" +\n+          \"tableName = ? WHERE catalogName = ? AND tableNamespace = ? AND tableName = ? \";\n+  public static final String JDBC_TABLE_DROP = \"DELETE FROM \" + JDBC_CATALOG_TABLE_NAME + \" WHERE catalogName = ? \" +\n+          \"AND tableNamespace = ? AND tableName = ? \";\n+  public static final String JDBC_TABLE_SELECT = \"SELECT catalogName, tableNamespace, tableName, metadataLocation, \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a97dfce94e656b4af5cac669790d76257996bc6a"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQyOTM0NQ==", "bodyText": "we should be able to implement SupportsNamespaces, do you plan to do that in another PR?", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r535429345", "createdAt": "2020-12-03T17:17:51Z", "author": {"login": "jackye1995"}, "path": "core/src/main/java/org/apache/iceberg/hadoop/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.hadoop;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.commons.dbutils.DbUtils;\n+import org.apache.commons.dbutils.QueryRunner;\n+import org.apache.commons.dbutils.handlers.BeanListHandler;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.exceptions.RuntimeIOException;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, Closeable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a97dfce94e656b4af5cac669790d76257996bc6a"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQzMjkzNA==", "bodyText": "How do we incorporate the database concept in all SQL databases? Looks like we are just creating this table in the default database. My though on this is we can have a database named iceberg (maybe configurable), and inside it there can be a namesapce table to store namespace info, and this table (maybe with a different name like tables) to store all table information. Thoughts?", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r535432934", "createdAt": "2020-12-03T17:23:12Z", "author": {"login": "jackye1995"}, "path": "core/src/main/java/org/apache/iceberg/hadoop/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.hadoop;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.commons.dbutils.DbUtils;\n+import org.apache.commons.dbutils.QueryRunner;\n+import org.apache.commons.dbutils.handlers.BeanListHandler;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.exceptions.RuntimeIOException;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, Closeable {\n+\n+  public static final String JDBC_CATALOG_DEFAULT_NAME = \"default_catalog\";\n+  public static final String JDBC_CATALOG_TABLE_NAME = \"iceberg_catalog\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a97dfce94e656b4af5cac669790d76257996bc6a"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ0MDc3MQ==", "bodyText": "I only see the hsqldb used for testing, what are the use of mysql and postgres?\nshould mark as testCompile instead\nversions should go to versions.props\nhave you checked if the license is okay for hsqldb?", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r535440771", "createdAt": "2020-12-03T17:34:12Z", "author": {"login": "jackye1995"}, "path": "build.gradle", "diffHunk": "@@ -226,6 +226,10 @@ project(':iceberg-core') {\n     compile \"com.fasterxml.jackson.core:jackson-databind\"\n     compile \"com.fasterxml.jackson.core:jackson-core\"\n     compile \"com.github.ben-manes.caffeine:caffeine\"\n+    compile 'commons-dbutils:commons-dbutils:1.7'\n+    compile \"org.hsqldb:hsqldb:2.5.1\"\n+    compile \"mysql:mysql-connector-java:8.0.21\"\n+    compile \"org.postgresql:postgresql:42.2.18\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a97dfce94e656b4af5cac669790d76257996bc6a"}, "originalPosition": 7}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ1MTc4OTYz", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-545178963", "createdAt": "2020-12-04T17:59:03Z", "commit": {"oid": "874b13d1a1a23de7c196da2422d4a314e42f608e"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNzo1OTowM1rOH_bzDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxODowNjowMVrOH_cDdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjI3Nzc3Mg==", "bodyText": "I think it is sufficient to do Preconditions.checkNotNull, is there any benefit for doing this complicated check?", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r536277772", "createdAt": "2020-12-04T17:59:03Z", "author": {"login": "jackye1995"}, "path": "core/src/main/java/org/apache/iceberg/hadoop/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,314 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.hadoop;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import java.io.IOException;\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.commons.dbcp2.BasicDataSource;\n+import org.apache.commons.dbutils.QueryRunner;\n+import org.apache.commons.dbutils.handlers.BeanListHandler;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.exceptions.RuntimeIOException;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, SupportsNamespaces {\n+\n+  public static final String JDBC_CATALOG_DEFAULT_NAME = \"jdbc\";\n+\n+  public static final String JDBC_CATALOG_JDBC_DRIVER = \"jdbccatalog.jdbcdriver\";\n+  public static final String JDBC_CATALOG_DBURL = \"jdbccatalog.dburl\";\n+  public static final String JDBC_CATALOG_USER = \"jdbccatalog.user\";\n+  public static final String JDBC_CATALOG_PASSWORD = \"jdbccatalog.password\";\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcCatalog.class);\n+  private QueryRunner queryRunner;\n+  private FileIO fileIO;\n+  private String catalogName = JDBC_CATALOG_DEFAULT_NAME;\n+  private String warehouseLocation;\n+  private Configuration hadoopConf;\n+\n+\n+  public JdbcCatalog() {\n+  }\n+\n+  private void initializeCatalog() throws SQLException {\n+    queryRunner.execute(JdbcNamespaceDao.NAMESPACES_TABLE_DDL);\n+    queryRunner.execute(JdbcTableDao.JDBC_CATALOG_TABLE_DDL);\n+    LOG.debug(\"Created Jdbc tables to store iceberg catalog!\");\n+  }\n+\n+  @Override\n+  public void initialize(String name, Map<String, String> properties) {\n+    Preconditions.checkArgument(properties.get(CatalogProperties.WAREHOUSE_LOCATION) != null &&", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "874b13d1a1a23de7c196da2422d4a314e42f608e"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjI4MTk3NA==", "bodyText": "I think I prefer DriverManager, because getConnection(String url, Properties info) is much more flexible. Many JDBC connector needs more than username and password, for example AWS RDS needs verifyServerCertificate and useSSL.\nI think instead of individual config fields, JDBC catalog can expose a config prefix jdbccatalog.property., and all configs under this prefix would be added to properties and initialize a connection. For example, user name and password would become configs jdbccatalog.property.username, jdbccatalog.property.password.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r536281974", "createdAt": "2020-12-04T18:06:01Z", "author": {"login": "jackye1995"}, "path": "core/src/main/java/org/apache/iceberg/hadoop/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,314 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.hadoop;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import java.io.IOException;\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.commons.dbcp2.BasicDataSource;\n+import org.apache.commons.dbutils.QueryRunner;\n+import org.apache.commons.dbutils.handlers.BeanListHandler;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.exceptions.RuntimeIOException;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, SupportsNamespaces {\n+\n+  public static final String JDBC_CATALOG_DEFAULT_NAME = \"jdbc\";\n+\n+  public static final String JDBC_CATALOG_JDBC_DRIVER = \"jdbccatalog.jdbcdriver\";\n+  public static final String JDBC_CATALOG_DBURL = \"jdbccatalog.dburl\";\n+  public static final String JDBC_CATALOG_USER = \"jdbccatalog.user\";\n+  public static final String JDBC_CATALOG_PASSWORD = \"jdbccatalog.password\";\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcCatalog.class);\n+  private QueryRunner queryRunner;\n+  private FileIO fileIO;\n+  private String catalogName = JDBC_CATALOG_DEFAULT_NAME;\n+  private String warehouseLocation;\n+  private Configuration hadoopConf;\n+\n+\n+  public JdbcCatalog() {\n+  }\n+\n+  private void initializeCatalog() throws SQLException {\n+    queryRunner.execute(JdbcNamespaceDao.NAMESPACES_TABLE_DDL);\n+    queryRunner.execute(JdbcTableDao.JDBC_CATALOG_TABLE_DDL);\n+    LOG.debug(\"Created Jdbc tables to store iceberg catalog!\");\n+  }\n+\n+  @Override\n+  public void initialize(String name, Map<String, String> properties) {\n+    Preconditions.checkArgument(properties.get(CatalogProperties.WAREHOUSE_LOCATION) != null &&\n+                    !properties.get(CatalogProperties.WAREHOUSE_LOCATION).equals(\"\"),\n+            \"no location provided for warehouse\");\n+    Preconditions.checkArgument(!properties.getOrDefault(JDBC_CATALOG_JDBC_DRIVER, \"\").equals(\"\"),\n+            \"no jdbc driver classname provided!\");\n+    Preconditions.checkArgument(!properties.getOrDefault(JDBC_CATALOG_DBURL, \"\").equals(\"\"),\n+            \"no jdbc connection url provided!\");\n+    Preconditions.checkArgument(!properties.getOrDefault(JDBC_CATALOG_USER, \"\").equals(\"\"),\n+            \"no jdbc database user provided!\");\n+    Preconditions.checkArgument(!properties.getOrDefault(JDBC_CATALOG_PASSWORD, \"\").equals(\"\"),\n+            \"no jdbc database user password provided!\");\n+    this.catalogName = name;\n+    this.warehouseLocation = properties.get(CatalogProperties.WAREHOUSE_LOCATION).replaceAll(\"/*$\", \"\");\n+\n+    String fileIOImpl = properties.get(CatalogProperties.FILE_IO_IMPL);\n+    this.fileIO = fileIOImpl == null ? new HadoopFileIO(hadoopConf) : CatalogUtil.loadFileIO(fileIOImpl, properties,\n+            hadoopConf);\n+\n+    LOG.debug(\"Connecting to Jdbc database {}.\", properties.get(JDBC_CATALOG_DBURL));\n+    // jdbcConnection = DriverManager.getConnection(catalogDburl, catalogUser, catalogDbpassword);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "874b13d1a1a23de7c196da2422d4a314e42f608e"}, "originalPosition": 103}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ1MjMzNDc1", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-545233475", "createdAt": "2020-12-04T19:19:40Z", "commit": {"oid": "874b13d1a1a23de7c196da2422d4a314e42f608e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxOToxOTo0MFrOH_etYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxOToxOTo0MFrOH_etYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjMyNTQ3Mg==", "bodyText": "These changes don't look related. Could you add them in a separate PR?", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r536325472", "createdAt": "2020-12-04T19:19:40Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/hadoop/HadoopCatalog.java", "diffHunk": "@@ -56,16 +56,16 @@\n import org.apache.iceberg.relocated.com.google.common.collect.Sets;\n \n /**\n- * HadoopCatalog provides a way to use table names like db.table to work with path-based tables under a common\n- * location. It uses a specified directory under a specified filesystem as the warehouse directory, and organizes\n- * multiple levels directories that mapped to the database, namespace and the table respectively. The HadoopCatalog\n- * takes a location as the warehouse directory. When creating a table such as $db.$tbl, it creates $db/$tbl\n- * directory under the warehouse directory, and put the table metadata into that directory.\n- *\n- * The HadoopCatalog now supports {@link org.apache.iceberg.catalog.Catalog#createTable},\n- * {@link org.apache.iceberg.catalog.Catalog#dropTable}, the {@link org.apache.iceberg.catalog.Catalog#renameTable}\n- * is not supported yet.\n- *\n+ * HadoopCatalog provides a way to use table names like db.table to work with path-based tables under a common location.\n+ * It uses a specified directory under a specified filesystem as the warehouse directory, and organizes multiple levels\n+ * directories that mapped to the database, namespace and the table respectively. The HadoopCatalog takes a location as\n+ * the warehouse directory. When creating a table such as $db.$tbl, it creates $db/$tbl directory under the warehouse\n+ * directory, and put the table metadata into that directory.\n+ * <p>\n+ * The HadoopCatalog now supports {@link org.apache.iceberg.catalog.Catalog#NoSuchNamespaceExceptioncreateTable}, {@link\n+ * org.apache.iceberg.catalog.Catalog#dropTable}, the {@link org.apache.iceberg.catalog.Catalog#renameTable} is not\n+ * supported yet.\n+ * <p>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "874b13d1a1a23de7c196da2422d4a314e42f608e"}, "originalPosition": 23}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ1MjMzODQ5", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-545233849", "createdAt": "2020-12-04T19:20:18Z", "commit": {"oid": "874b13d1a1a23de7c196da2422d4a314e42f608e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxOToyMDoxOFrOH_eujg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxOToyMDoxOFrOH_eujg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjMyNTc3NA==", "bodyText": "Why put this in the hadoop package? There isn't anything specific to Hadoop is there?", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r536325774", "createdAt": "2020-12-04T19:20:18Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/hadoop/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,314 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.hadoop;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "874b13d1a1a23de7c196da2422d4a314e42f608e"}, "originalPosition": 20}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ1MjM0MTkz", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-545234193", "createdAt": "2020-12-04T19:20:54Z", "commit": {"oid": "874b13d1a1a23de7c196da2422d4a314e42f608e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxOToyMDo1NFrOH_evlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxOToyMDo1NFrOH_evlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjMyNjAzNw==", "bodyText": "Nit: please don't use multiple whitespace lines. One is sufficient.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r536326037", "createdAt": "2020-12-04T19:20:54Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/hadoop/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,314 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.hadoop;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import java.io.IOException;\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.commons.dbcp2.BasicDataSource;\n+import org.apache.commons.dbutils.QueryRunner;\n+import org.apache.commons.dbutils.handlers.BeanListHandler;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.exceptions.RuntimeIOException;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "874b13d1a1a23de7c196da2422d4a314e42f608e"}, "originalPosition": 55}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ1MjM2MzY2", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-545236366", "createdAt": "2020-12-04T19:24:29Z", "commit": {"oid": "874b13d1a1a23de7c196da2422d4a314e42f608e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxOToyNDoyOVrOH_e3Ig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxOToyNDoyOVrOH_e3Ig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjMyNzk3MA==", "bodyText": "Exceptions should not be discarded. Instead, this should create a new exception with the caught exception as a cause.\nAlso, we're moving from RuntimeIOException to Java's UncheckedIOException. So please use that instead.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r536327970", "createdAt": "2020-12-04T19:24:29Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/hadoop/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,314 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.hadoop;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import java.io.IOException;\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.commons.dbcp2.BasicDataSource;\n+import org.apache.commons.dbutils.QueryRunner;\n+import org.apache.commons.dbutils.handlers.BeanListHandler;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.exceptions.RuntimeIOException;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, SupportsNamespaces {\n+\n+  public static final String JDBC_CATALOG_DEFAULT_NAME = \"jdbc\";\n+\n+  public static final String JDBC_CATALOG_JDBC_DRIVER = \"jdbccatalog.jdbcdriver\";\n+  public static final String JDBC_CATALOG_DBURL = \"jdbccatalog.dburl\";\n+  public static final String JDBC_CATALOG_USER = \"jdbccatalog.user\";\n+  public static final String JDBC_CATALOG_PASSWORD = \"jdbccatalog.password\";\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcCatalog.class);\n+  private QueryRunner queryRunner;\n+  private FileIO fileIO;\n+  private String catalogName = JDBC_CATALOG_DEFAULT_NAME;\n+  private String warehouseLocation;\n+  private Configuration hadoopConf;\n+\n+\n+  public JdbcCatalog() {\n+  }\n+\n+  private void initializeCatalog() throws SQLException {\n+    queryRunner.execute(JdbcNamespaceDao.NAMESPACES_TABLE_DDL);\n+    queryRunner.execute(JdbcTableDao.JDBC_CATALOG_TABLE_DDL);\n+    LOG.debug(\"Created Jdbc tables to store iceberg catalog!\");\n+  }\n+\n+  @Override\n+  public void initialize(String name, Map<String, String> properties) {\n+    Preconditions.checkArgument(properties.get(CatalogProperties.WAREHOUSE_LOCATION) != null &&\n+                    !properties.get(CatalogProperties.WAREHOUSE_LOCATION).equals(\"\"),\n+            \"no location provided for warehouse\");\n+    Preconditions.checkArgument(!properties.getOrDefault(JDBC_CATALOG_JDBC_DRIVER, \"\").equals(\"\"),\n+            \"no jdbc driver classname provided!\");\n+    Preconditions.checkArgument(!properties.getOrDefault(JDBC_CATALOG_DBURL, \"\").equals(\"\"),\n+            \"no jdbc connection url provided!\");\n+    Preconditions.checkArgument(!properties.getOrDefault(JDBC_CATALOG_USER, \"\").equals(\"\"),\n+            \"no jdbc database user provided!\");\n+    Preconditions.checkArgument(!properties.getOrDefault(JDBC_CATALOG_PASSWORD, \"\").equals(\"\"),\n+            \"no jdbc database user password provided!\");\n+    this.catalogName = name;\n+    this.warehouseLocation = properties.get(CatalogProperties.WAREHOUSE_LOCATION).replaceAll(\"/*$\", \"\");\n+\n+    String fileIOImpl = properties.get(CatalogProperties.FILE_IO_IMPL);\n+    this.fileIO = fileIOImpl == null ? new HadoopFileIO(hadoopConf) : CatalogUtil.loadFileIO(fileIOImpl, properties,\n+            hadoopConf);\n+\n+    LOG.debug(\"Connecting to Jdbc database {}.\", properties.get(JDBC_CATALOG_DBURL));\n+    // jdbcConnection = DriverManager.getConnection(catalogDburl, catalogUser, catalogDbpassword);\n+    BasicDataSource dataSource = new BasicDataSource();\n+    dataSource.setDriverClassName(properties.get(JDBC_CATALOG_JDBC_DRIVER));\n+    dataSource.setUrl(properties.get(JDBC_CATALOG_DBURL));\n+    dataSource.setUsername(properties.get(JDBC_CATALOG_USER));\n+    dataSource.setPassword(properties.get(JDBC_CATALOG_PASSWORD));\n+    this.queryRunner = new QueryRunner(dataSource);\n+\n+    try {\n+      initializeCatalog();\n+    } catch (SQLException throwables) {\n+      throw new RuntimeIOException(\"Failed to initialize Jdbc Catalog!\\n %s %s\", throwables.getErrorCode(),\n+              throwables.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "874b13d1a1a23de7c196da2422d4a314e42f608e"}, "originalPosition": 115}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ1MzM2MTEx", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-545336111", "createdAt": "2020-12-04T22:19:05Z", "commit": {"oid": "874b13d1a1a23de7c196da2422d4a314e42f608e"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMjoxOTowNVrOH_kTMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMjoyMjo1N1rOH_kZ9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQxNzA3Mw==", "bodyText": "Is this List allocation necessary? It seems like it's discarded when results is reassigned from tableDao.getAll(namespace) below.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r536417073", "createdAt": "2020-12-04T22:19:05Z", "author": {"login": "kbendick"}, "path": "core/src/main/java/org/apache/iceberg/hadoop/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,314 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.hadoop;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import java.io.IOException;\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.commons.dbcp2.BasicDataSource;\n+import org.apache.commons.dbutils.QueryRunner;\n+import org.apache.commons.dbutils.handlers.BeanListHandler;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.exceptions.RuntimeIOException;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, SupportsNamespaces {\n+\n+  public static final String JDBC_CATALOG_DEFAULT_NAME = \"jdbc\";\n+\n+  public static final String JDBC_CATALOG_JDBC_DRIVER = \"jdbccatalog.jdbcdriver\";\n+  public static final String JDBC_CATALOG_DBURL = \"jdbccatalog.dburl\";\n+  public static final String JDBC_CATALOG_USER = \"jdbccatalog.user\";\n+  public static final String JDBC_CATALOG_PASSWORD = \"jdbccatalog.password\";\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcCatalog.class);\n+  private QueryRunner queryRunner;\n+  private FileIO fileIO;\n+  private String catalogName = JDBC_CATALOG_DEFAULT_NAME;\n+  private String warehouseLocation;\n+  private Configuration hadoopConf;\n+\n+\n+  public JdbcCatalog() {\n+  }\n+\n+  private void initializeCatalog() throws SQLException {\n+    queryRunner.execute(JdbcNamespaceDao.NAMESPACES_TABLE_DDL);\n+    queryRunner.execute(JdbcTableDao.JDBC_CATALOG_TABLE_DDL);\n+    LOG.debug(\"Created Jdbc tables to store iceberg catalog!\");\n+  }\n+\n+  @Override\n+  public void initialize(String name, Map<String, String> properties) {\n+    Preconditions.checkArgument(properties.get(CatalogProperties.WAREHOUSE_LOCATION) != null &&\n+                    !properties.get(CatalogProperties.WAREHOUSE_LOCATION).equals(\"\"),\n+            \"no location provided for warehouse\");\n+    Preconditions.checkArgument(!properties.getOrDefault(JDBC_CATALOG_JDBC_DRIVER, \"\").equals(\"\"),\n+            \"no jdbc driver classname provided!\");\n+    Preconditions.checkArgument(!properties.getOrDefault(JDBC_CATALOG_DBURL, \"\").equals(\"\"),\n+            \"no jdbc connection url provided!\");\n+    Preconditions.checkArgument(!properties.getOrDefault(JDBC_CATALOG_USER, \"\").equals(\"\"),\n+            \"no jdbc database user provided!\");\n+    Preconditions.checkArgument(!properties.getOrDefault(JDBC_CATALOG_PASSWORD, \"\").equals(\"\"),\n+            \"no jdbc database user password provided!\");\n+    this.catalogName = name;\n+    this.warehouseLocation = properties.get(CatalogProperties.WAREHOUSE_LOCATION).replaceAll(\"/*$\", \"\");\n+\n+    String fileIOImpl = properties.get(CatalogProperties.FILE_IO_IMPL);\n+    this.fileIO = fileIOImpl == null ? new HadoopFileIO(hadoopConf) : CatalogUtil.loadFileIO(fileIOImpl, properties,\n+            hadoopConf);\n+\n+    LOG.debug(\"Connecting to Jdbc database {}.\", properties.get(JDBC_CATALOG_DBURL));\n+    // jdbcConnection = DriverManager.getConnection(catalogDburl, catalogUser, catalogDbpassword);\n+    BasicDataSource dataSource = new BasicDataSource();\n+    dataSource.setDriverClassName(properties.get(JDBC_CATALOG_JDBC_DRIVER));\n+    dataSource.setUrl(properties.get(JDBC_CATALOG_DBURL));\n+    dataSource.setUsername(properties.get(JDBC_CATALOG_USER));\n+    dataSource.setPassword(properties.get(JDBC_CATALOG_PASSWORD));\n+    this.queryRunner = new QueryRunner(dataSource);\n+\n+    try {\n+      initializeCatalog();\n+    } catch (SQLException throwables) {\n+      throw new RuntimeIOException(\"Failed to initialize Jdbc Catalog!\\n %s %s\", throwables.getErrorCode(),\n+              throwables.getMessage());\n+    }\n+\n+  }\n+\n+\n+  @Override\n+  protected TableOperations newTableOps(TableIdentifier tableIdentifier) {\n+    return new JdbcTableOperations(queryRunner, fileIO, catalogName, tableIdentifier);\n+  }\n+\n+  @Override\n+  protected String defaultWarehouseLocation(TableIdentifier tableIdentifier) {\n+    String tableName = tableIdentifier.name();\n+    StringBuilder sb = new StringBuilder();\n+\n+    sb.append(warehouseLocation).append('/');\n+    for (String level : tableIdentifier.namespace().levels()) {\n+      sb.append(level).append('/');\n+    }\n+    sb.append(tableName);\n+\n+    return sb.toString();\n+  }\n+\n+  @Override\n+  public boolean dropTable(TableIdentifier identifier, boolean purge) {\n+    TableOperations ops = newTableOps(identifier);\n+    TableMetadata lastMetadata = ops.current();\n+    try {\n+      new JdbcTableDao(queryRunner, catalogName).delete(identifier);\n+      if (purge && lastMetadata != null) {\n+        CatalogUtil.dropTableData(ops.io(), lastMetadata);\n+        FileSystem fs = Util.getFs(new Path(warehouseLocation), hadoopConf);\n+        fs.delete(new Path(lastMetadata.location()), true /* recursive */);\n+        LOG.info(\"Table {} data purged!\", identifier);\n+      }\n+      return true;\n+    } catch (SQLException | IOException e) {\n+      LOG.error(\"Cannot complete drop table operation for {} due to unexpected exception {}!\", identifier,\n+              e.getMessage(), e);\n+      throw new RuntimeIOException(\"Failed to drop table %s\", identifier.toString());\n+    }\n+  }\n+\n+  public void logTables() {\n+    try {\n+      List<JdbcTable> tables = queryRunner.query(\"SELECT * FROM \" + JdbcTableDao.TABLES_TABLE_NAME,\n+              new BeanListHandler<>(JdbcTable.class));\n+      if (tables.isEmpty()) {\n+        LOG.info(\"No Table found!\");\n+      }\n+      for (JdbcTable table : tables) {\n+        LOG.info(\"Table:{} ,NS: {}\", table.toTableIdentifier().toString(), table.getTableNamespace().toString());\n+        LOG.warn(\"IS NULL:{} \", table.getTableNamespace() == null);\n+      }\n+    } catch (SQLException throwables) {\n+      LOG.error(\"Failed to list tables!\", throwables);\n+    }\n+  }\n+\n+  @Override\n+  public List<TableIdentifier> listTables(Namespace namespace) {\n+\n+    JdbcNamespaceDao nsDao = new JdbcNamespaceDao(queryRunner, catalogName);\n+    if (nsDao.isExists(namespace)) {\n+      throw new NoSuchNamespaceException(\"Namespace %s does not exist!\", namespace.toString());\n+    }\n+    JdbcTableDao tableDao = new JdbcTableDao(queryRunner, catalogName);\n+    List<TableIdentifier> results = Lists.newArrayList();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "874b13d1a1a23de7c196da2422d4a314e42f608e"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQxNzM0OA==", "bodyText": "Nit: More unnecessary white space.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r536417348", "createdAt": "2020-12-04T22:19:40Z", "author": {"login": "kbendick"}, "path": "core/src/main/java/org/apache/iceberg/hadoop/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,314 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.hadoop;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import java.io.IOException;\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.commons.dbcp2.BasicDataSource;\n+import org.apache.commons.dbutils.QueryRunner;\n+import org.apache.commons.dbutils.handlers.BeanListHandler;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.exceptions.RuntimeIOException;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, SupportsNamespaces {\n+\n+  public static final String JDBC_CATALOG_DEFAULT_NAME = \"jdbc\";\n+\n+  public static final String JDBC_CATALOG_JDBC_DRIVER = \"jdbccatalog.jdbcdriver\";\n+  public static final String JDBC_CATALOG_DBURL = \"jdbccatalog.dburl\";\n+  public static final String JDBC_CATALOG_USER = \"jdbccatalog.user\";\n+  public static final String JDBC_CATALOG_PASSWORD = \"jdbccatalog.password\";\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcCatalog.class);\n+  private QueryRunner queryRunner;\n+  private FileIO fileIO;\n+  private String catalogName = JDBC_CATALOG_DEFAULT_NAME;\n+  private String warehouseLocation;\n+  private Configuration hadoopConf;\n+\n+\n+  public JdbcCatalog() {\n+  }\n+\n+  private void initializeCatalog() throws SQLException {\n+    queryRunner.execute(JdbcNamespaceDao.NAMESPACES_TABLE_DDL);\n+    queryRunner.execute(JdbcTableDao.JDBC_CATALOG_TABLE_DDL);\n+    LOG.debug(\"Created Jdbc tables to store iceberg catalog!\");\n+  }\n+\n+  @Override\n+  public void initialize(String name, Map<String, String> properties) {\n+    Preconditions.checkArgument(properties.get(CatalogProperties.WAREHOUSE_LOCATION) != null &&\n+                    !properties.get(CatalogProperties.WAREHOUSE_LOCATION).equals(\"\"),\n+            \"no location provided for warehouse\");\n+    Preconditions.checkArgument(!properties.getOrDefault(JDBC_CATALOG_JDBC_DRIVER, \"\").equals(\"\"),\n+            \"no jdbc driver classname provided!\");\n+    Preconditions.checkArgument(!properties.getOrDefault(JDBC_CATALOG_DBURL, \"\").equals(\"\"),\n+            \"no jdbc connection url provided!\");\n+    Preconditions.checkArgument(!properties.getOrDefault(JDBC_CATALOG_USER, \"\").equals(\"\"),\n+            \"no jdbc database user provided!\");\n+    Preconditions.checkArgument(!properties.getOrDefault(JDBC_CATALOG_PASSWORD, \"\").equals(\"\"),\n+            \"no jdbc database user password provided!\");\n+    this.catalogName = name;\n+    this.warehouseLocation = properties.get(CatalogProperties.WAREHOUSE_LOCATION).replaceAll(\"/*$\", \"\");\n+\n+    String fileIOImpl = properties.get(CatalogProperties.FILE_IO_IMPL);\n+    this.fileIO = fileIOImpl == null ? new HadoopFileIO(hadoopConf) : CatalogUtil.loadFileIO(fileIOImpl, properties,\n+            hadoopConf);\n+\n+    LOG.debug(\"Connecting to Jdbc database {}.\", properties.get(JDBC_CATALOG_DBURL));\n+    // jdbcConnection = DriverManager.getConnection(catalogDburl, catalogUser, catalogDbpassword);\n+    BasicDataSource dataSource = new BasicDataSource();\n+    dataSource.setDriverClassName(properties.get(JDBC_CATALOG_JDBC_DRIVER));\n+    dataSource.setUrl(properties.get(JDBC_CATALOG_DBURL));\n+    dataSource.setUsername(properties.get(JDBC_CATALOG_USER));\n+    dataSource.setPassword(properties.get(JDBC_CATALOG_PASSWORD));\n+    this.queryRunner = new QueryRunner(dataSource);\n+\n+    try {\n+      initializeCatalog();\n+    } catch (SQLException throwables) {\n+      throw new RuntimeIOException(\"Failed to initialize Jdbc Catalog!\\n %s %s\", throwables.getErrorCode(),\n+              throwables.getMessage());\n+    }\n+\n+  }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "874b13d1a1a23de7c196da2422d4a314e42f608e"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQxODgwNQ==", "bodyText": "Would it make more sense to just store the Namespace directly?", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r536418805", "createdAt": "2020-12-04T22:22:57Z", "author": {"login": "kbendick"}, "path": "core/src/main/java/org/apache/iceberg/hadoop/JdbcNamespace.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.hadoop;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.apache.iceberg.catalog.Namespace;\n+\n+public class JdbcNamespace {\n+  private String catalogName;\n+  private String namespace;\n+  private String namespaceMetadata;\n+\n+  public JdbcNamespace(Namespace namespace) {\n+    this.namespace = namespace.toString();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "874b13d1a1a23de7c196da2422d4a314e42f608e"}, "originalPosition": 35}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ1NjUwMzMw", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-545650330", "createdAt": "2020-12-05T21:17:53Z", "commit": {"oid": "874b13d1a1a23de7c196da2422d4a314e42f608e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQyMToxNzo1M1rOIABblg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQyMToxNzo1M1rOIABblg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjg5NDM1OA==", "bodyText": "Minor: Rather than breaking in the middle of a method call, the ternary operator provides good places to break lines:\nthis.fileIO = fileIOImpl == null ?\n   new HadoopFileIO(hadoopConf) :\n   CatalogUtil.loadFileIO(fileIOImpl, properties, hadoopConf);", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r536894358", "createdAt": "2020-12-05T21:17:53Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/hadoop/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,314 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.hadoop;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import java.io.IOException;\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.commons.dbcp2.BasicDataSource;\n+import org.apache.commons.dbutils.QueryRunner;\n+import org.apache.commons.dbutils.handlers.BeanListHandler;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.exceptions.RuntimeIOException;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, SupportsNamespaces {\n+\n+  public static final String JDBC_CATALOG_DEFAULT_NAME = \"jdbc\";\n+\n+  public static final String JDBC_CATALOG_JDBC_DRIVER = \"jdbccatalog.jdbcdriver\";\n+  public static final String JDBC_CATALOG_DBURL = \"jdbccatalog.dburl\";\n+  public static final String JDBC_CATALOG_USER = \"jdbccatalog.user\";\n+  public static final String JDBC_CATALOG_PASSWORD = \"jdbccatalog.password\";\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcCatalog.class);\n+  private QueryRunner queryRunner;\n+  private FileIO fileIO;\n+  private String catalogName = JDBC_CATALOG_DEFAULT_NAME;\n+  private String warehouseLocation;\n+  private Configuration hadoopConf;\n+\n+\n+  public JdbcCatalog() {\n+  }\n+\n+  private void initializeCatalog() throws SQLException {\n+    queryRunner.execute(JdbcNamespaceDao.NAMESPACES_TABLE_DDL);\n+    queryRunner.execute(JdbcTableDao.JDBC_CATALOG_TABLE_DDL);\n+    LOG.debug(\"Created Jdbc tables to store iceberg catalog!\");\n+  }\n+\n+  @Override\n+  public void initialize(String name, Map<String, String> properties) {\n+    Preconditions.checkArgument(properties.get(CatalogProperties.WAREHOUSE_LOCATION) != null &&\n+                    !properties.get(CatalogProperties.WAREHOUSE_LOCATION).equals(\"\"),\n+            \"no location provided for warehouse\");\n+    Preconditions.checkArgument(!properties.getOrDefault(JDBC_CATALOG_JDBC_DRIVER, \"\").equals(\"\"),\n+            \"no jdbc driver classname provided!\");\n+    Preconditions.checkArgument(!properties.getOrDefault(JDBC_CATALOG_DBURL, \"\").equals(\"\"),\n+            \"no jdbc connection url provided!\");\n+    Preconditions.checkArgument(!properties.getOrDefault(JDBC_CATALOG_USER, \"\").equals(\"\"),\n+            \"no jdbc database user provided!\");\n+    Preconditions.checkArgument(!properties.getOrDefault(JDBC_CATALOG_PASSWORD, \"\").equals(\"\"),\n+            \"no jdbc database user password provided!\");\n+    this.catalogName = name;\n+    this.warehouseLocation = properties.get(CatalogProperties.WAREHOUSE_LOCATION).replaceAll(\"/*$\", \"\");\n+\n+    String fileIOImpl = properties.get(CatalogProperties.FILE_IO_IMPL);\n+    this.fileIO = fileIOImpl == null ? new HadoopFileIO(hadoopConf) : CatalogUtil.loadFileIO(fileIOImpl, properties,\n+            hadoopConf);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "874b13d1a1a23de7c196da2422d4a314e42f608e"}, "originalPosition": 100}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ1NjUwNzk0", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-545650794", "createdAt": "2020-12-05T21:26:17Z", "commit": {"oid": "874b13d1a1a23de7c196da2422d4a314e42f608e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQyMToyNjoxOFrOIABf8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQyMToyNjoxOFrOIABf8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjg5NTQ3Mw==", "bodyText": "Looks like this doesn't yet implement an atomic swap of the old metadata location for the new one, so table updates would be unsafe because concurrent writers would clobber each other's commits. @kbendick, did your solution tackle that problem yet?", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r536895473", "createdAt": "2020-12-05T21:26:18Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/hadoop/JdbcTableDao.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.hadoop;\n+\n+import java.sql.SQLException;\n+import java.util.List;\n+import org.apache.commons.dbutils.QueryRunner;\n+import org.apache.commons.dbutils.handlers.BeanHandler;\n+import org.apache.commons.dbutils.handlers.BeanListHandler;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class JdbcTableDao {\n+  public static final String TABLES_TABLE_NAME = \"iceberg_tables\";\n+  public static final String JDBC_CATALOG_TABLE_DDL =\n+          \"CREATE TABLE IF NOT EXISTS \" + JdbcTableDao.TABLES_TABLE_NAME +\n+                  \"(catalogName VARCHAR(1255) NOT NULL,\" +\n+                  \"tableNamespace VARCHAR(1255) NOT NULL,\" +\n+                  \"tableName VARCHAR(1255) NOT NULL,\" +\n+                  \"metadataLocation VARCHAR(32768),\" +\n+                  \"previousMetadataLocation VARCHAR(32768),\" +\n+                  \"PRIMARY KEY (catalogName,tableNamespace,tableName),\" +\n+                  \"FOREIGN KEY (catalogName, tableNamespace) REFERENCES \" + JdbcNamespaceDao.NAMESPACES_TABLE_NAME +\n+                  \"(catalogName, namespace)\" +\n+                  \");\";\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcTableDao.class);\n+  private final QueryRunner queryRunner;\n+  private final String catalogName;\n+\n+\n+  public JdbcTableDao(QueryRunner queryRunner, String catalogName) {\n+    this.queryRunner = queryRunner;\n+    this.catalogName = catalogName;\n+  }\n+\n+  public boolean isExists(TableIdentifier tableIdentifier) {\n+    try {\n+      return this.get(tableIdentifier) != null;\n+    } catch (SQLException throwables) {\n+      return false;\n+    }\n+  }\n+\n+  public JdbcTable get(TableIdentifier tableIdentifier) throws SQLException {\n+    return queryRunner.query(\"SELECT * FROM \" + TABLES_TABLE_NAME + \" \" +\n+                    \"WHERE catalogName = ? AND tableNamespace = ? AND tableName = ? \",\n+            new BeanHandler<>(JdbcTable.class),\n+            catalogName, tableIdentifier.namespace().toString(), tableIdentifier.name());\n+  }\n+\n+  public List<TableIdentifier> getAll(Namespace namespace) throws SQLException {\n+    List<JdbcTable> tables = queryRunner.query(\"SELECT * FROM \" + TABLES_TABLE_NAME + \" \" +\n+                    \"WHERE catalogName = ? AND tableNamespace = ?\",\n+            new BeanListHandler<>(JdbcTable.class), catalogName, namespace.toString());\n+    List<TableIdentifier> results = Lists.newArrayList();\n+    for (JdbcTable table : tables) {\n+      results.add(table.toTableIdentifier());\n+    }\n+    return results;\n+  }\n+\n+  public void update(TableIdentifier tableIdentifier, String oldMetadataLocation,\n+                     String newMetadataLocation) throws SQLException {\n+    queryRunner.update(\"UPDATE \" + TABLES_TABLE_NAME + \" SET metadataLocation = ? , previousMetadataLocation = ? \" +\n+                    \"WHERE catalogName = ? AND tableNamespace = ? \" +\n+                    \"AND tableName = ? \", newMetadataLocation,\n+            oldMetadataLocation, catalogName, tableIdentifier.namespace().toString(), tableIdentifier.name());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "874b13d1a1a23de7c196da2422d4a314e42f608e"}, "originalPosition": 89}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ1NjUwOTI4", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-545650928", "createdAt": "2020-12-05T21:28:25Z", "commit": {"oid": "874b13d1a1a23de7c196da2422d4a314e42f608e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQyMToyODoyNVrOIABhZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQyMToyODoyNVrOIABhZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjg5NTg0NA==", "bodyText": "It doesn't look like the dbutils classes are very useful here compared to simple prepared statements. Unless I'm missing something, I'd rather not rely on this dependency if we can add slightly more code here to use the JDBC API directly.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r536895844", "createdAt": "2020-12-05T21:28:25Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/hadoop/JdbcTableDao.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.hadoop;\n+\n+import java.sql.SQLException;\n+import java.util.List;\n+import org.apache.commons.dbutils.QueryRunner;\n+import org.apache.commons.dbutils.handlers.BeanHandler;\n+import org.apache.commons.dbutils.handlers.BeanListHandler;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "874b13d1a1a23de7c196da2422d4a314e42f608e"}, "originalPosition": 26}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ1NjUxMzUx", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-545651351", "createdAt": "2020-12-05T21:35:11Z", "commit": {"oid": "874b13d1a1a23de7c196da2422d4a314e42f608e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQyMTozNToxMVrOIABlag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQyMTozNToxMVrOIABlag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjg5Njg3NA==", "bodyText": "For structure, I would prefer to have all of the SQL statements as constants up at the top of the file, like the CREATE TABLE command. That makes it easy to read them independent of use here.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r536896874", "createdAt": "2020-12-05T21:35:11Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/hadoop/JdbcTableDao.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.hadoop;\n+\n+import java.sql.SQLException;\n+import java.util.List;\n+import org.apache.commons.dbutils.QueryRunner;\n+import org.apache.commons.dbutils.handlers.BeanHandler;\n+import org.apache.commons.dbutils.handlers.BeanListHandler;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class JdbcTableDao {\n+  public static final String TABLES_TABLE_NAME = \"iceberg_tables\";\n+  public static final String JDBC_CATALOG_TABLE_DDL =\n+          \"CREATE TABLE IF NOT EXISTS \" + JdbcTableDao.TABLES_TABLE_NAME +\n+                  \"(catalogName VARCHAR(1255) NOT NULL,\" +\n+                  \"tableNamespace VARCHAR(1255) NOT NULL,\" +\n+                  \"tableName VARCHAR(1255) NOT NULL,\" +\n+                  \"metadataLocation VARCHAR(32768),\" +\n+                  \"previousMetadataLocation VARCHAR(32768),\" +\n+                  \"PRIMARY KEY (catalogName,tableNamespace,tableName),\" +\n+                  \"FOREIGN KEY (catalogName, tableNamespace) REFERENCES \" + JdbcNamespaceDao.NAMESPACES_TABLE_NAME +\n+                  \"(catalogName, namespace)\" +\n+                  \");\";\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcTableDao.class);\n+  private final QueryRunner queryRunner;\n+  private final String catalogName;\n+\n+\n+  public JdbcTableDao(QueryRunner queryRunner, String catalogName) {\n+    this.queryRunner = queryRunner;\n+    this.catalogName = catalogName;\n+  }\n+\n+  public boolean isExists(TableIdentifier tableIdentifier) {\n+    try {\n+      return this.get(tableIdentifier) != null;\n+    } catch (SQLException throwables) {\n+      return false;\n+    }\n+  }\n+\n+  public JdbcTable get(TableIdentifier tableIdentifier) throws SQLException {\n+    return queryRunner.query(\"SELECT * FROM \" + TABLES_TABLE_NAME + \" \" +\n+                    \"WHERE catalogName = ? AND tableNamespace = ? AND tableName = ? \",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "874b13d1a1a23de7c196da2422d4a314e42f608e"}, "originalPosition": 68}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ1NjUxMzc0", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-545651374", "createdAt": "2020-12-05T21:35:41Z", "commit": {"oid": "874b13d1a1a23de7c196da2422d4a314e42f608e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQyMTozNTo0MVrOIABlqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQyMTozNTo0MVrOIABlqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjg5NjkzOA==", "bodyText": "Any SQL exception? What possible exceptions does this include?", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r536896938", "createdAt": "2020-12-05T21:35:41Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/hadoop/JdbcTableDao.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.hadoop;\n+\n+import java.sql.SQLException;\n+import java.util.List;\n+import org.apache.commons.dbutils.QueryRunner;\n+import org.apache.commons.dbutils.handlers.BeanHandler;\n+import org.apache.commons.dbutils.handlers.BeanListHandler;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class JdbcTableDao {\n+  public static final String TABLES_TABLE_NAME = \"iceberg_tables\";\n+  public static final String JDBC_CATALOG_TABLE_DDL =\n+          \"CREATE TABLE IF NOT EXISTS \" + JdbcTableDao.TABLES_TABLE_NAME +\n+                  \"(catalogName VARCHAR(1255) NOT NULL,\" +\n+                  \"tableNamespace VARCHAR(1255) NOT NULL,\" +\n+                  \"tableName VARCHAR(1255) NOT NULL,\" +\n+                  \"metadataLocation VARCHAR(32768),\" +\n+                  \"previousMetadataLocation VARCHAR(32768),\" +\n+                  \"PRIMARY KEY (catalogName,tableNamespace,tableName),\" +\n+                  \"FOREIGN KEY (catalogName, tableNamespace) REFERENCES \" + JdbcNamespaceDao.NAMESPACES_TABLE_NAME +\n+                  \"(catalogName, namespace)\" +\n+                  \");\";\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcTableDao.class);\n+  private final QueryRunner queryRunner;\n+  private final String catalogName;\n+\n+\n+  public JdbcTableDao(QueryRunner queryRunner, String catalogName) {\n+    this.queryRunner = queryRunner;\n+    this.catalogName = catalogName;\n+  }\n+\n+  public boolean isExists(TableIdentifier tableIdentifier) {\n+    try {\n+      return this.get(tableIdentifier) != null;\n+    } catch (SQLException throwables) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "874b13d1a1a23de7c196da2422d4a314e42f608e"}, "originalPosition": 61}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ1NjUxNjAx", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-545651601", "createdAt": "2020-12-05T21:39:39Z", "commit": {"oid": "874b13d1a1a23de7c196da2422d4a314e42f608e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQyMTozOTo0MFrOIABoEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQyMTozOTo0MFrOIABoEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjg5NzU1NQ==", "bodyText": "You may want to also have a prefix-based lookup using LIKE:\nString namespacePrefix = namespace.toString() + \".%\";\nSELECT * FROM iceberg_namespaces WHERE catalog_name = ? AND namespace LIKE ?", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r536897555", "createdAt": "2020-12-05T21:39:40Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/hadoop/JdbcNamespaceDao.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.hadoop;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.commons.dbutils.QueryRunner;\n+import org.apache.commons.dbutils.handlers.BeanHandler;\n+import org.apache.commons.dbutils.handlers.BeanListHandler;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcNamespaceDao {\n+  public static final String NAMESPACES_TABLE_NAME = \"iceberg_namespaces\";\n+  public static final String NAMESPACES_TABLE_DDL = \"CREATE TABLE IF NOT EXISTS \" +\n+          JdbcNamespaceDao.NAMESPACES_TABLE_NAME + \" ( \" +\n+          \"catalogName VARCHAR(1255) NOT NULL,\" +\n+          \"namespace VARCHAR(1255) NOT NULL,\" +\n+          \"namespaceMetadata VARCHAR(32768),\" +\n+          \"PRIMARY KEY (catalogName, namespace) \" +\n+          \");\";\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcNamespaceDao.class);\n+  private final String catalogName;\n+  private QueryRunner queryRunner;\n+\n+\n+  public JdbcNamespaceDao(QueryRunner queryRunner, String catalogName) {\n+    this.queryRunner = queryRunner;\n+    this.catalogName = catalogName;\n+  }\n+\n+  public JdbcNamespace get(Namespace namespace) throws SQLException {\n+    return queryRunner.query(\"SELECT * FROM \" + NAMESPACES_TABLE_NAME + \" WHERE catalogName = \" +\n+                    \"? AND namespace = ? ;\",\n+            new BeanHandler<>(JdbcNamespace.class), catalogName, namespace.toString());\n+  }\n+\n+  public boolean isExists(Namespace namespace) {\n+    try {\n+      return this.get(namespace) != null;\n+    } catch (SQLException throwables) {\n+      return false;\n+    }\n+  }\n+\n+  public List<JdbcNamespace> getAll() throws SQLException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "874b13d1a1a23de7c196da2422d4a314e42f608e"}, "originalPosition": 69}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ1NjU0MTU5", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-545654159", "createdAt": "2020-12-05T22:24:24Z", "commit": {"oid": "874b13d1a1a23de7c196da2422d4a314e42f608e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQyMjoyNDoyNFrOIACB2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQyMjoyNDoyNFrOIACB2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjkwNDE1Mg==", "bodyText": "For the initial version, let's not support namespace metadata. We can add that later in a separate PR where we consider more options for storage.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r536904152", "createdAt": "2020-12-05T22:24:24Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/hadoop/JdbcNamespace.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.hadoop;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.apache.iceberg.catalog.Namespace;\n+\n+public class JdbcNamespace {\n+  private String catalogName;\n+  private String namespace;\n+  private String namespaceMetadata;\n+\n+  public JdbcNamespace(Namespace namespace) {\n+    this.namespace = namespace.toString();\n+  }\n+\n+  public String getCatalogName() {\n+    return catalogName;\n+  }\n+\n+  public void setCatalogName(String catalogName) {\n+    this.catalogName = catalogName;\n+  }\n+\n+  public String getNamespace() {\n+    return namespace;\n+  }\n+\n+  public void setNamespace(String namespace) {\n+    this.namespace = namespace;\n+  }\n+\n+  public String getNamespaceMetadata() {\n+    return namespaceMetadata;\n+  }\n+\n+  public void setNamespaceMetadata(String namespaceMetadata) {\n+    this.namespaceMetadata = namespaceMetadata;\n+  }\n+\n+  public Namespace toNamespace() {\n+    return Namespace.of(namespaceMetadata);\n+  }\n+\n+  public Map<String, String> toNamespaceMetadata() throws JsonProcessingException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "874b13d1a1a23de7c196da2422d4a314e42f608e"}, "originalPosition": 66}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ1NjU0NTgz", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-545654583", "createdAt": "2020-12-05T22:32:33Z", "commit": {"oid": "874b13d1a1a23de7c196da2422d4a314e42f608e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQyMjozMjozM1rOIACGyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQyMjozMjozM1rOIACGyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjkwNTQxNg==", "bodyText": "Is this PRIMARY KEY and FOREIGN KEY syntax portable? I'm wondering if we should omit them to have more generic SQL.\nOf course, that would require some way to ensure that table creation is atomic because the primary key constraint wouldn't be enforced for the table. That would probably require a transaction to check whether a table exists and insert it to be portable. Some databases support ON CONFLICT DO NOTHING or INSERT IGNORE but it doesn't look like the syntax is portable.\nIt may be more portable to use PRIMARY KEY, but we will need to validate concurrent behavior.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r536905416", "createdAt": "2020-12-05T22:32:33Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/hadoop/JdbcTableDao.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.hadoop;\n+\n+import java.sql.SQLException;\n+import java.util.List;\n+import org.apache.commons.dbutils.QueryRunner;\n+import org.apache.commons.dbutils.handlers.BeanHandler;\n+import org.apache.commons.dbutils.handlers.BeanListHandler;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class JdbcTableDao {\n+  public static final String TABLES_TABLE_NAME = \"iceberg_tables\";\n+  public static final String JDBC_CATALOG_TABLE_DDL =\n+          \"CREATE TABLE IF NOT EXISTS \" + JdbcTableDao.TABLES_TABLE_NAME +\n+                  \"(catalogName VARCHAR(1255) NOT NULL,\" +\n+                  \"tableNamespace VARCHAR(1255) NOT NULL,\" +\n+                  \"tableName VARCHAR(1255) NOT NULL,\" +\n+                  \"metadataLocation VARCHAR(32768),\" +\n+                  \"previousMetadataLocation VARCHAR(32768),\" +\n+                  \"PRIMARY KEY (catalogName,tableNamespace,tableName),\" +\n+                  \"FOREIGN KEY (catalogName, tableNamespace) REFERENCES \" + JdbcNamespaceDao.NAMESPACES_TABLE_NAME +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "874b13d1a1a23de7c196da2422d4a314e42f608e"}, "originalPosition": 45}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ1NjU0ODc3", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-545654877", "createdAt": "2020-12-05T22:38:32Z", "commit": {"oid": "874b13d1a1a23de7c196da2422d4a314e42f608e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQyMjozODozMlrOIACKNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQyMjozODozMlrOIACKNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjkwNjI5Mw==", "bodyText": "This doesn't look quite right because the exception is too generic to simply ignore and move on.\nAlso, no need to add a format argument for the exception. SLF4J loggers will detect that the last argument is an exception and add it properly without a placeholder for it.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r536906293", "createdAt": "2020-12-05T22:38:32Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/hadoop/JdbcTableOperations.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.hadoop;\n+\n+import java.sql.SQLException;\n+import java.util.Objects;\n+import org.apache.commons.dbutils.QueryRunner;\n+import org.apache.iceberg.BaseMetastoreTableOperations;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.CommitFailedException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.io.FileIO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+class JdbcTableOperations extends BaseMetastoreTableOperations {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcTableOperations.class);\n+  private final String catalogName;\n+  private final TableIdentifier tableIdentifier;\n+  private final FileIO fileIO;\n+  private QueryRunner queryRunner;\n+\n+  protected JdbcTableOperations(QueryRunner queryRunner, FileIO fileIO, String catalogName,\n+                                TableIdentifier tableIdentifier) {\n+    this.queryRunner = queryRunner;\n+    this.catalogName = catalogName;\n+    this.tableIdentifier = tableIdentifier;\n+    this.fileIO = fileIO;\n+  }\n+\n+  // The doRefresh method should provide implementation on how to get the metadata location\n+  @Override\n+  public void doRefresh() {\n+    String metadataLocation = null;\n+    JdbcTableDao tableDao = new JdbcTableDao(queryRunner, catalogName);\n+    JdbcTable table = null;\n+    try {\n+      table = tableDao.get(tableIdentifier);\n+    } catch (SQLException throwables) {\n+      LOG.debug(\"Table not found: {} , {}!\", tableIdentifier, throwables);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "874b13d1a1a23de7c196da2422d4a314e42f608e"}, "originalPosition": 59}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "51ea5f05d2e1f4e30cbd52c5315201010da75dc1", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/51ea5f05d2e1f4e30cbd52c5315201010da75dc1", "committedDate": "2020-12-06T13:56:10Z", "message": "Merge remote-tracking branch 'origin/iceberg_jdbccatalog' into iceberg_jdbccatalog"}, "afterCommit": {"oid": "d8fc72d1b9978af4bc09e25be27ff0b5b7584581", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/d8fc72d1b9978af4bc09e25be27ff0b5b7584581", "committedDate": "2020-12-06T13:57:34Z", "message": "implement Closeable"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0daa8f30a1d84dd90288034036b381eba92b32a2", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/0daa8f30a1d84dd90288034036b381eba92b32a2", "committedDate": "2020-12-06T17:02:51Z", "message": "add comments"}, "afterCommit": {"oid": "b230cabb5520d8b30cc244b2b776b5caaeaccb4f", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/b230cabb5520d8b30cc244b2b776b5caaeaccb4f", "committedDate": "2020-12-06T18:59:14Z", "message": "add comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2NDE2MDQz", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-546416043", "createdAt": "2020-12-07T18:22:21Z", "commit": {"oid": "b751492bb6cdfd48515d4519a41f60cdd95acabf"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxODoyMjoyMVrOIA0Q0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxODoyMjoyMVrOIA0Q0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcyNzE4NA==", "bodyText": "This doesn't need to be added unless Iceberg actually contains something that is copyrighted by the H2 database engine. The LICENSE is updated if Iceberg adds code based on another project or if Iceberg bundles another project into an Iceberg artifact (like the runtime Jars). Since this is just used as a test dependency, there is no need.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r537727184", "createdAt": "2020-12-07T18:22:21Z", "author": {"login": "rdblue"}, "path": "LICENSE", "diffHunk": "@@ -289,3 +289,15 @@ Copyright: 2011-2018 The Apache Software Foundation\n Home page: http://hive.apache.org/\n License: http://www.apache.org/licenses/LICENSE-2.0\n \n+--------------------------------------------------------------------------------\n+\n+This software contains unmodified binary redistributions for\n+H2 database engine (https://h2database.com/),\n+which is dual licensed and available under the MPL 2.0\n+(Mozilla Public License) or under the EPL 1.0 (Eclipse Public License).\n+An original copy of the license agreement can be found at:\n+https://h2database.com/html/license.html\n+\n+Copyright: Copyright 2004-2020 H2 Group. Multiple-Licensed under the MPL 2.0, and the EPL 1.0\n+Home page: https://h2database.org/\n+License: https://www.h2database.com/html/license.html", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b751492bb6cdfd48515d4519a41f60cdd95acabf"}, "originalPosition": 15}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2NDE2NjIz", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-546416623", "createdAt": "2020-12-07T18:23:09Z", "commit": {"oid": "b751492bb6cdfd48515d4519a41f60cdd95acabf"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxODoyMzoxMFrOIA0Srg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxODoyMzoxMFrOIA0Srg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcyNzY2Mg==", "bodyText": "Should this be testRuntime because the only compile dependency is for JDBC?\nWhy switch databases?", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r537727662", "createdAt": "2020-12-07T18:23:10Z", "author": {"login": "rdblue"}, "path": "build.gradle", "diffHunk": "@@ -231,6 +231,7 @@ project(':iceberg-core') {\n       exclude group: 'org.slf4j', module: 'slf4j-log4j12'\n     }\n \n+    testCompile \"com.h2database:h2\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b751492bb6cdfd48515d4519a41f60cdd95acabf"}, "originalPosition": 4}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c002a7c966f79be48ec21da3dda4ec9a5ca63817", "author": {"user": {"login": "aokolnychyi", "name": "Anton Okolnychyi"}}, "url": "https://github.com/apache/iceberg/commit/c002a7c966f79be48ec21da3dda4ec9a5ca63817", "committedDate": "2020-12-07T18:28:18Z", "message": "Core: Add table properties for default snapshot retention (#1868)"}, "afterCommit": {"oid": "b751492bb6cdfd48515d4519a41f60cdd95acabf", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/b751492bb6cdfd48515d4519a41f60cdd95acabf", "committedDate": "2020-12-07T14:39:15Z", "message": "remove sql contraints"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b751492bb6cdfd48515d4519a41f60cdd95acabf", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/b751492bb6cdfd48515d4519a41f60cdd95acabf", "committedDate": "2020-12-07T14:39:15Z", "message": "remove sql contraints"}, "afterCommit": {"oid": "dec8e5fe3e8d576f842a0f39bccf2c3816b02be3", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/dec8e5fe3e8d576f842a0f39bccf2c3816b02be3", "committedDate": "2020-12-07T18:43:40Z", "message": "jdbc catalog"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "43194c6dbe95121b2d20f60ec1070327db62340f", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/43194c6dbe95121b2d20f60ec1070327db62340f", "committedDate": "2020-12-07T19:40:05Z", "message": "ensure target namespace is exists before renaming table"}, "afterCommit": {"oid": "9e1dd074565414d9a7417688ad7a89b84069afcf", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/9e1dd074565414d9a7417688ad7a89b84069afcf", "committedDate": "2020-12-08T18:40:09Z", "message": "ensure target namespace is exists before renaming table"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0MTI4MDYy", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-554128062", "createdAt": "2020-12-16T22:14:39Z", "commit": {"oid": "4551cd87bd31fa42204e3be97c977a9a093fd584"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQyMjoxNDozOVrOIHbfhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQyMjoyNzo0MFrOIHb62Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY2MTM4MQ==", "bodyText": "I think testCompile is good enough, if we want to upgrade gradle we should upgrade all syntax at the same time.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r544661381", "createdAt": "2020-12-16T22:14:39Z", "author": {"login": "jackye1995"}, "path": "build.gradle", "diffHunk": "@@ -231,6 +231,7 @@ project(':iceberg-core') {\n       exclude group: 'org.slf4j', module: 'slf4j-log4j12'\n     }\n \n+    testRuntime \"com.h2database:h2\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4551cd87bd31fa42204e3be97c977a9a093fd584"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY2NDAwMg==", "bodyText": "you need to also define a no-arg constructor for initialize for dynamic loading purpose. And in that case, you still need to initialize warehouse location and fileIO. So it is probably better to move all constructor logic to initialize.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r544664002", "createdAt": "2020-12-16T22:19:34Z", "author": {"login": "jackye1995"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.fs.PathFilter;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.hadoop.Util;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, SupportsNamespaces, Closeable {\n+\n+\n+  public static final String JDBC_PARAM_PREFIX = \"connection.parameter.\";\n+  private static final Joiner SLASH = Joiner.on(\"/\");\n+  private static final String TABLE_METADATA_FILE_EXTENSION = \".metadata.json\";\n+  private static final PathFilter TABLE_FILTER = path -> path.getName().endsWith(TABLE_METADATA_FILE_EXTENSION);\n+\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcCatalog.class);\n+  private FileIO fileIO;\n+  private FileSystem fs;\n+  private String name = \"jdbc\";\n+  private String warehouseLocation;\n+  private Configuration hadoopConf;\n+  private Connection dbConn;\n+\n+  public JdbcCatalog(String name, Configuration conf, String warehouseLocation, Map<String, String> properties) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4551cd87bd31fa42204e3be97c977a9a093fd584"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY2ODM3Nw==", "bodyText": "I don't understand why is fs used here. It seems like you have a JdbcNamespace that stores all the information, but also creates a file path for a namespace. Why are you doing this? I don't think the JdbcCatalog should have any dependency on Hadoop file system.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r544668377", "createdAt": "2020-12-16T22:27:40Z", "author": {"login": "jackye1995"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.fs.PathFilter;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.hadoop.Util;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, SupportsNamespaces, Closeable {\n+\n+\n+  public static final String JDBC_PARAM_PREFIX = \"connection.parameter.\";\n+  private static final Joiner SLASH = Joiner.on(\"/\");\n+  private static final String TABLE_METADATA_FILE_EXTENSION = \".metadata.json\";\n+  private static final PathFilter TABLE_FILTER = path -> path.getName().endsWith(TABLE_METADATA_FILE_EXTENSION);\n+\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcCatalog.class);\n+  private FileIO fileIO;\n+  private FileSystem fs;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4551cd87bd31fa42204e3be97c977a9a093fd584"}, "originalPosition": 71}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3NDI5NDQy", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-557429442", "createdAt": "2020-12-22T23:46:11Z", "commit": {"oid": "534babe9d218992035b7d3d8b991fce73ba314fd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMzo0NjoxMVrOIKMc1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMzo0NjoxMVrOIKMc1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU2MDY2Mw==", "bodyText": "This adds quite a bit of complexity to the JDBC implementation because it requires a separate table for namespace and stores both namespace name and metadata as JSON objects. I think that ensuring consistency between the two tables adds a lot of unnecessary complexity. What happens if a table is added to a namespace that as it is concurrently deleted?\nI think a much simpler implementation is to omit the namespace table and determine whether a namespace exists based on whether there are any tables in it. As long as we can guarantee atomic changes to the tables table, consistency problems go away.\nThat's also a simpler way to start a JDBC implementation. Then we can add namespace metadata later in a way that doesn't have those problems.\n@ismailsimsek what do you think about removing this and implementing namespaceExists based just on the tables table?", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r547560663", "createdAt": "2020-12-22T23:46:11Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcNamespace.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcNamespace {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "534babe9d218992035b7d3d8b991fce73ba314fd"}, "originalPosition": 37}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3NDMwMDky", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-557430092", "createdAt": "2020-12-22T23:48:29Z", "commit": {"oid": "534babe9d218992035b7d3d8b991fce73ba314fd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMzo0ODoyOVrOIKMfTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMzo0ODoyOVrOIKMfTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU2MTI5NQ==", "bodyText": "We would normally omit the \"is\" from a method name if it is clear that the return value is a boolean. I think that exists meets that requirement because it is natural to say \"if table exists\" instead of \"if table is exists\".", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r547561295", "createdAt": "2020-12-22T23:48:29Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcTable.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcTable {\n+  public static final String SQL_TABLE_NAME = \"iceberg_tables\";\n+  public static final String SQL_TABLE_DDL =\n+          \"CREATE TABLE \" + JdbcTable.SQL_TABLE_NAME +\n+                  \"(catalog_name VARCHAR(1255) NOT NULL,\" +\n+                  \"table_namespace VARCHAR(1255) NOT NULL,\" +\n+                  \"table_name VARCHAR(1255) NOT NULL,\" +\n+                  \"metadata_location VARCHAR(32768),\" +\n+                  \"previous_metadata_location VARCHAR(32768),\" +\n+                  \"PRIMARY KEY (catalog_name, table_namespace, table_name)\" +\n+                  \")\";\n+  public static final String SQL_SELECT = \"SELECT * FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+  public static final String SQL_SELECT_ALL = \"SELECT * FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace = ?\";\n+  public static final String SQL_UPDATE_METADATA_LOCATION = \"UPDATE \" + SQL_TABLE_NAME +\n+          \" SET metadata_location = ? , previous_metadata_location = ? \" +\n+          \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? AND metadata_location = ?\";\n+  public static final String SQL_INSERT = \"INSERT INTO \" + SQL_TABLE_NAME +\n+          \" (catalog_name, table_namespace, table_name, metadata_location, previous_metadata_location) \" +\n+          \" VALUES (?,?,?,?,?)\";\n+  public static final String SQL_UPDATE_TABLE_NAME = \"UPDATE \" + SQL_TABLE_NAME +\n+          \" SET table_namespace = ? , table_name = ? \" +\n+          \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+  public static final String SQL_DELETE = \"DELETE FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcTable.class);\n+  private final String catalogName;\n+  private final Connection dbConn;\n+\n+  public JdbcTable(Connection dbConn, String catalogName) {\n+    this.dbConn = dbConn;\n+    this.catalogName = catalogName;\n+  }\n+\n+  public void setAutoCommitOff() throws SQLException {\n+    this.dbConn.setAutoCommit(false);\n+  }\n+\n+  public void setAutoCommitOn() throws SQLException {\n+    this.dbConn.setAutoCommit(true);\n+  }\n+\n+  public void commit() throws SQLException {\n+    this.dbConn.commit();\n+  }\n+\n+  public void rollback() throws SQLException {\n+    this.dbConn.rollback();\n+  }\n+\n+  public boolean isExists(TableIdentifier tableIdentifier) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "534babe9d218992035b7d3d8b991fce73ba314fd"}, "originalPosition": 88}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3NDM0NTgy", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-557434582", "createdAt": "2020-12-23T00:05:22Z", "commit": {"oid": "534babe9d218992035b7d3d8b991fce73ba314fd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QwMDowNToyMlrOIKMvpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QwMDowNToyMlrOIKMvpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU2NTQ3Ng==", "bodyText": "Rather than using JSON to encode the namespace, I suggest converting it to a String using Joiner.on(\".\").\nThere's a trade-off to simplifying the problem by doing it that way: both a.`b.c`  and a.b.c end up as a.b.c. That has two effects:\n\nNamespaces that \"collide\" like that are considered the same namespace\nWhen listing namespace a the result is [b] and not [b.c, b]\n\nI think that those are fine. For the collisions, I think it is rare for users to want namespaces that can collide but are not the same. If someone creates the table a.`b.c`.table_name then I really doubt that everyone wants to escape b.c every time they type the identifier. Everyone is going to type a.b.c.table_name anyway, which would return incorrect results if both tables exist. So not allowing namespaces that conflict is actually a good thing.\nThis is exactly what Iceberg does to look up columns in a table, too. All column names are converted to a lookup key by joining the parts with .. Columns that have different structures but identical names aren't allowed, and I think it is better that way.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r547565476", "createdAt": "2020-12-23T00:05:22Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcTable.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcTable {\n+  public static final String SQL_TABLE_NAME = \"iceberg_tables\";\n+  public static final String SQL_TABLE_DDL =\n+          \"CREATE TABLE \" + JdbcTable.SQL_TABLE_NAME +\n+                  \"(catalog_name VARCHAR(1255) NOT NULL,\" +\n+                  \"table_namespace VARCHAR(1255) NOT NULL,\" +\n+                  \"table_name VARCHAR(1255) NOT NULL,\" +\n+                  \"metadata_location VARCHAR(32768),\" +\n+                  \"previous_metadata_location VARCHAR(32768),\" +\n+                  \"PRIMARY KEY (catalog_name, table_namespace, table_name)\" +\n+                  \")\";\n+  public static final String SQL_SELECT = \"SELECT * FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+  public static final String SQL_SELECT_ALL = \"SELECT * FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace = ?\";\n+  public static final String SQL_UPDATE_METADATA_LOCATION = \"UPDATE \" + SQL_TABLE_NAME +\n+          \" SET metadata_location = ? , previous_metadata_location = ? \" +\n+          \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? AND metadata_location = ?\";\n+  public static final String SQL_INSERT = \"INSERT INTO \" + SQL_TABLE_NAME +\n+          \" (catalog_name, table_namespace, table_name, metadata_location, previous_metadata_location) \" +\n+          \" VALUES (?,?,?,?,?)\";\n+  public static final String SQL_UPDATE_TABLE_NAME = \"UPDATE \" + SQL_TABLE_NAME +\n+          \" SET table_namespace = ? , table_name = ? \" +\n+          \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+  public static final String SQL_DELETE = \"DELETE FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcTable.class);\n+  private final String catalogName;\n+  private final Connection dbConn;\n+\n+  public JdbcTable(Connection dbConn, String catalogName) {\n+    this.dbConn = dbConn;\n+    this.catalogName = catalogName;\n+  }\n+\n+  public void setAutoCommitOff() throws SQLException {\n+    this.dbConn.setAutoCommit(false);\n+  }\n+\n+  public void setAutoCommitOn() throws SQLException {\n+    this.dbConn.setAutoCommit(true);\n+  }\n+\n+  public void commit() throws SQLException {\n+    this.dbConn.commit();\n+  }\n+\n+  public void rollback() throws SQLException {\n+    this.dbConn.rollback();\n+  }\n+\n+  public boolean isExists(TableIdentifier tableIdentifier) {\n+    try {\n+      return !this.get(tableIdentifier).isEmpty();\n+    } catch (SQLException | JsonProcessingException throwables) {\n+      return false;\n+    }\n+  }\n+\n+  public Map<String, String> get(TableIdentifier tableIdentifier) throws SQLException, JsonProcessingException {\n+    Map<String, String> table = Maps.newHashMap();\n+    PreparedStatement sql = dbConn.prepareStatement(SQL_SELECT);\n+    sql.setString(1, catalogName);\n+    sql.setString(2, JdbcUtil.namespaceToString(tableIdentifier.namespace()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "534babe9d218992035b7d3d8b991fce73ba314fd"}, "originalPosition": 100}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3NDM1MDk1", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-557435095", "createdAt": "2020-12-23T00:07:21Z", "commit": {"oid": "534babe9d218992035b7d3d8b991fce73ba314fd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QwMDowNzoyMVrOIKMxuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QwMDowNzoyMVrOIKMxuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU2NjAwOQ==", "bodyText": "Nit: no need for a blank line at the start of a method.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r547566009", "createdAt": "2020-12-23T00:07:21Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcTable.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcTable {\n+  public static final String SQL_TABLE_NAME = \"iceberg_tables\";\n+  public static final String SQL_TABLE_DDL =\n+          \"CREATE TABLE \" + JdbcTable.SQL_TABLE_NAME +\n+                  \"(catalog_name VARCHAR(1255) NOT NULL,\" +\n+                  \"table_namespace VARCHAR(1255) NOT NULL,\" +\n+                  \"table_name VARCHAR(1255) NOT NULL,\" +\n+                  \"metadata_location VARCHAR(32768),\" +\n+                  \"previous_metadata_location VARCHAR(32768),\" +\n+                  \"PRIMARY KEY (catalog_name, table_namespace, table_name)\" +\n+                  \")\";\n+  public static final String SQL_SELECT = \"SELECT * FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+  public static final String SQL_SELECT_ALL = \"SELECT * FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace = ?\";\n+  public static final String SQL_UPDATE_METADATA_LOCATION = \"UPDATE \" + SQL_TABLE_NAME +\n+          \" SET metadata_location = ? , previous_metadata_location = ? \" +\n+          \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? AND metadata_location = ?\";\n+  public static final String SQL_INSERT = \"INSERT INTO \" + SQL_TABLE_NAME +\n+          \" (catalog_name, table_namespace, table_name, metadata_location, previous_metadata_location) \" +\n+          \" VALUES (?,?,?,?,?)\";\n+  public static final String SQL_UPDATE_TABLE_NAME = \"UPDATE \" + SQL_TABLE_NAME +\n+          \" SET table_namespace = ? , table_name = ? \" +\n+          \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+  public static final String SQL_DELETE = \"DELETE FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcTable.class);\n+  private final String catalogName;\n+  private final Connection dbConn;\n+\n+  public JdbcTable(Connection dbConn, String catalogName) {\n+    this.dbConn = dbConn;\n+    this.catalogName = catalogName;\n+  }\n+\n+  public void setAutoCommitOff() throws SQLException {\n+    this.dbConn.setAutoCommit(false);\n+  }\n+\n+  public void setAutoCommitOn() throws SQLException {\n+    this.dbConn.setAutoCommit(true);\n+  }\n+\n+  public void commit() throws SQLException {\n+    this.dbConn.commit();\n+  }\n+\n+  public void rollback() throws SQLException {\n+    this.dbConn.rollback();\n+  }\n+\n+  public boolean isExists(TableIdentifier tableIdentifier) {\n+    try {\n+      return !this.get(tableIdentifier).isEmpty();\n+    } catch (SQLException | JsonProcessingException throwables) {\n+      return false;\n+    }\n+  }\n+\n+  public Map<String, String> get(TableIdentifier tableIdentifier) throws SQLException, JsonProcessingException {\n+    Map<String, String> table = Maps.newHashMap();\n+    PreparedStatement sql = dbConn.prepareStatement(SQL_SELECT);\n+    sql.setString(1, catalogName);\n+    sql.setString(2, JdbcUtil.namespaceToString(tableIdentifier.namespace()));\n+    sql.setString(3, tableIdentifier.name());\n+    ResultSet rs = sql.executeQuery();\n+    if (rs.next()) {\n+      table.put(\"catalog_name\", rs.getString(\"catalog_name\"));\n+      table.put(\"table_namespace\", rs.getString(\"table_namespace\"));\n+      table.put(\"table_name\", rs.getString(\"table_name\"));\n+      table.put(\"metadata_location\", rs.getString(\"metadata_location\"));\n+      table.put(\"previous_metadata_location\", rs.getString(\"previous_metadata_location\"));\n+    }\n+    rs.close();\n+    return table;\n+  }\n+\n+  public List<TableIdentifier> getAll(Namespace namespace) throws SQLException, JsonProcessingException {\n+    List<TableIdentifier> results = Lists.newArrayList();\n+\n+    PreparedStatement sql = dbConn.prepareStatement(SQL_SELECT_ALL);\n+    sql.setString(1, catalogName);\n+    sql.setString(2, JdbcUtil.namespaceToString(namespace));\n+    ResultSet rs = sql.executeQuery();\n+\n+    while (rs.next()) {\n+      final TableIdentifier table = JdbcUtil.stringToTableIdentifier(\n+              rs.getString(\"table_namespace\"), rs.getString(\"table_name\"));\n+      results.add(table);\n+    }\n+    rs.close();\n+    return results;\n+  }\n+\n+  public int updateMetadataLocation(TableIdentifier tableIdentifier, String oldMetadataLocation,\n+                                    String newMetadataLocation) throws SQLException, JsonProcessingException {\n+    PreparedStatement sql = dbConn.prepareStatement(SQL_UPDATE_METADATA_LOCATION);\n+    // UPDATE\n+    sql.setString(1, newMetadataLocation);\n+    sql.setString(2, oldMetadataLocation);\n+    // WHERE\n+    sql.setString(3, catalogName);\n+    sql.setString(4, JdbcUtil.namespaceToString(tableIdentifier.namespace()));\n+    sql.setString(5, tableIdentifier.name());\n+    sql.setString(6, oldMetadataLocation);\n+    return sql.executeUpdate();\n+  }\n+\n+  public int save(TableIdentifier tableIdentifier, String oldMetadataLocation,\n+                  String newMetadataLocation) throws SQLException, JsonProcessingException {\n+\n+    PreparedStatement sql = dbConn.prepareStatement(SQL_INSERT);\n+    sql.setString(1, catalogName);\n+    sql.setString(2, JdbcUtil.namespaceToString(tableIdentifier.namespace()));\n+    sql.setString(3, tableIdentifier.name());\n+    sql.setString(4, newMetadataLocation);\n+    sql.setString(5, oldMetadataLocation);\n+    return sql.executeUpdate();\n+\n+  }\n+\n+  public int updateTableName(TableIdentifier from, TableIdentifier to) throws SQLException, JsonProcessingException {\n+\n+    PreparedStatement sql = dbConn.prepareStatement(SQL_UPDATE_TABLE_NAME);\n+    sql.setString(1, JdbcUtil.namespaceToString(to.namespace()));\n+    sql.setString(2, to.name());\n+    sql.setString(3, catalogName);\n+    sql.setString(4, JdbcUtil.namespaceToString(from.namespace()));\n+    sql.setString(5, from.name());\n+    return sql.executeUpdate();\n+\n+  }\n+\n+  public int delete(TableIdentifier identifier) throws SQLException, JsonProcessingException {\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "534babe9d218992035b7d3d8b991fce73ba314fd"}, "originalPosition": 171}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3NDM1Mjk5", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-557435299", "createdAt": "2020-12-23T00:08:11Z", "commit": {"oid": "534babe9d218992035b7d3d8b991fce73ba314fd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QwMDowODoxMVrOIKMyZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QwMDowODoxMVrOIKMyZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU2NjE4Mw==", "bodyText": "Why are there two metadata locations passed here?", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r547566183", "createdAt": "2020-12-23T00:08:11Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcTable.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcTable {\n+  public static final String SQL_TABLE_NAME = \"iceberg_tables\";\n+  public static final String SQL_TABLE_DDL =\n+          \"CREATE TABLE \" + JdbcTable.SQL_TABLE_NAME +\n+                  \"(catalog_name VARCHAR(1255) NOT NULL,\" +\n+                  \"table_namespace VARCHAR(1255) NOT NULL,\" +\n+                  \"table_name VARCHAR(1255) NOT NULL,\" +\n+                  \"metadata_location VARCHAR(32768),\" +\n+                  \"previous_metadata_location VARCHAR(32768),\" +\n+                  \"PRIMARY KEY (catalog_name, table_namespace, table_name)\" +\n+                  \")\";\n+  public static final String SQL_SELECT = \"SELECT * FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+  public static final String SQL_SELECT_ALL = \"SELECT * FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace = ?\";\n+  public static final String SQL_UPDATE_METADATA_LOCATION = \"UPDATE \" + SQL_TABLE_NAME +\n+          \" SET metadata_location = ? , previous_metadata_location = ? \" +\n+          \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? AND metadata_location = ?\";\n+  public static final String SQL_INSERT = \"INSERT INTO \" + SQL_TABLE_NAME +\n+          \" (catalog_name, table_namespace, table_name, metadata_location, previous_metadata_location) \" +\n+          \" VALUES (?,?,?,?,?)\";\n+  public static final String SQL_UPDATE_TABLE_NAME = \"UPDATE \" + SQL_TABLE_NAME +\n+          \" SET table_namespace = ? , table_name = ? \" +\n+          \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+  public static final String SQL_DELETE = \"DELETE FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcTable.class);\n+  private final String catalogName;\n+  private final Connection dbConn;\n+\n+  public JdbcTable(Connection dbConn, String catalogName) {\n+    this.dbConn = dbConn;\n+    this.catalogName = catalogName;\n+  }\n+\n+  public void setAutoCommitOff() throws SQLException {\n+    this.dbConn.setAutoCommit(false);\n+  }\n+\n+  public void setAutoCommitOn() throws SQLException {\n+    this.dbConn.setAutoCommit(true);\n+  }\n+\n+  public void commit() throws SQLException {\n+    this.dbConn.commit();\n+  }\n+\n+  public void rollback() throws SQLException {\n+    this.dbConn.rollback();\n+  }\n+\n+  public boolean isExists(TableIdentifier tableIdentifier) {\n+    try {\n+      return !this.get(tableIdentifier).isEmpty();\n+    } catch (SQLException | JsonProcessingException throwables) {\n+      return false;\n+    }\n+  }\n+\n+  public Map<String, String> get(TableIdentifier tableIdentifier) throws SQLException, JsonProcessingException {\n+    Map<String, String> table = Maps.newHashMap();\n+    PreparedStatement sql = dbConn.prepareStatement(SQL_SELECT);\n+    sql.setString(1, catalogName);\n+    sql.setString(2, JdbcUtil.namespaceToString(tableIdentifier.namespace()));\n+    sql.setString(3, tableIdentifier.name());\n+    ResultSet rs = sql.executeQuery();\n+    if (rs.next()) {\n+      table.put(\"catalog_name\", rs.getString(\"catalog_name\"));\n+      table.put(\"table_namespace\", rs.getString(\"table_namespace\"));\n+      table.put(\"table_name\", rs.getString(\"table_name\"));\n+      table.put(\"metadata_location\", rs.getString(\"metadata_location\"));\n+      table.put(\"previous_metadata_location\", rs.getString(\"previous_metadata_location\"));\n+    }\n+    rs.close();\n+    return table;\n+  }\n+\n+  public List<TableIdentifier> getAll(Namespace namespace) throws SQLException, JsonProcessingException {\n+    List<TableIdentifier> results = Lists.newArrayList();\n+\n+    PreparedStatement sql = dbConn.prepareStatement(SQL_SELECT_ALL);\n+    sql.setString(1, catalogName);\n+    sql.setString(2, JdbcUtil.namespaceToString(namespace));\n+    ResultSet rs = sql.executeQuery();\n+\n+    while (rs.next()) {\n+      final TableIdentifier table = JdbcUtil.stringToTableIdentifier(\n+              rs.getString(\"table_namespace\"), rs.getString(\"table_name\"));\n+      results.add(table);\n+    }\n+    rs.close();\n+    return results;\n+  }\n+\n+  public int updateMetadataLocation(TableIdentifier tableIdentifier, String oldMetadataLocation,\n+                                    String newMetadataLocation) throws SQLException, JsonProcessingException {\n+    PreparedStatement sql = dbConn.prepareStatement(SQL_UPDATE_METADATA_LOCATION);\n+    // UPDATE\n+    sql.setString(1, newMetadataLocation);\n+    sql.setString(2, oldMetadataLocation);\n+    // WHERE\n+    sql.setString(3, catalogName);\n+    sql.setString(4, JdbcUtil.namespaceToString(tableIdentifier.namespace()));\n+    sql.setString(5, tableIdentifier.name());\n+    sql.setString(6, oldMetadataLocation);\n+    return sql.executeUpdate();\n+  }\n+\n+  public int save(TableIdentifier tableIdentifier, String oldMetadataLocation,\n+                  String newMetadataLocation) throws SQLException, JsonProcessingException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "534babe9d218992035b7d3d8b991fce73ba314fd"}, "originalPosition": 146}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3NDM3MzAw", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-557437300", "createdAt": "2020-12-23T00:16:01Z", "commit": {"oid": "534babe9d218992035b7d3d8b991fce73ba314fd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QwMDoxNjowMlrOIKM58w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QwMDoxNjowMlrOIKM58w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU2ODExNQ==", "bodyText": "This connection is passed into the TableOperations when creating a table, which means that it is potentially shared across threads. I don't think that connections are thread-safe, so that is a problem. For Hive, we implemented a connection pool that you should be able to reuse by extending org.apache.iceberg.hive.ClientPool. We may want to move that class into core so it can be used by both.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r547568115", "createdAt": "2020-12-23T00:16:02Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, SupportsNamespaces, Closeable {\n+\n+  public static final String JDBC_PARAM_PREFIX = \"connection.parameter.\";\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcCatalog.class);\n+  private static final Joiner SLASH = Joiner.on(\"/\");\n+  private FileIO fileIO;\n+  private String name = \"jdbc\";\n+  private String warehouseLocation;\n+  private Configuration hadoopConf;\n+  private Connection dbConn;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "534babe9d218992035b7d3d8b991fce73ba314fd"}, "originalPosition": 64}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3NDM3NjQz", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-557437643", "createdAt": "2020-12-23T00:17:27Z", "commit": {"oid": "534babe9d218992035b7d3d8b991fce73ba314fd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QwMDoxNzoyOFrOIKM7eA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QwMDoxNzoyOFrOIKM7eA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU2ODUwNA==", "bodyText": "Style: just one exception is caught, so the variable name should be singular, like throwable. Also, we tend to refer to the exception as simply e in most catch blocks.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r547568504", "createdAt": "2020-12-23T00:17:28Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, SupportsNamespaces, Closeable {\n+\n+  public static final String JDBC_PARAM_PREFIX = \"connection.parameter.\";\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcCatalog.class);\n+  private static final Joiner SLASH = Joiner.on(\"/\");\n+  private FileIO fileIO;\n+  private String name = \"jdbc\";\n+  private String warehouseLocation;\n+  private Configuration hadoopConf;\n+  private Connection dbConn;\n+\n+  public JdbcCatalog() {\n+  }\n+\n+  @SuppressWarnings(\"checkstyle:HiddenField\")\n+  @Override\n+  public void initialize(String name, Map<String, String> properties) throws UncheckedIOException {\n+    Preconditions.checkArgument(!properties.getOrDefault(CatalogProperties.HIVE_URI, \"\").isEmpty(),\n+            \"No connection url provided for jdbc catalog!\");\n+    Preconditions.checkArgument(!properties.getOrDefault(CatalogProperties.WAREHOUSE_LOCATION, \"\").isEmpty(),\n+            \"Cannot initialize Jdbc Catalog because warehousePath must not be null!\");\n+\n+    this.warehouseLocation = properties.get(CatalogProperties.WAREHOUSE_LOCATION).replaceAll(\"/$\", \"\");\n+    this.name = name == null ? \"jdbc\" : name;\n+    String fileIOImpl = properties.get(CatalogProperties.FILE_IO_IMPL);\n+    this.fileIO = fileIOImpl == null ?\n+            new HadoopFileIO(hadoopConf) :\n+            CatalogUtil.loadFileIO(fileIOImpl, properties, hadoopConf);\n+    initializeConnection(properties);\n+  }\n+\n+  private void initializeConnection(Map<String, String> properties) throws UncheckedIOException {\n+    try {\n+\n+      LOG.debug(\"Connecting to Jdbc database {}.\", properties.get(CatalogProperties.HIVE_URI));\n+      Properties connectionProps = new Properties();\n+      for (Map.Entry<String, String> prop : properties.entrySet()) {\n+        if (prop.getKey().startsWith(JDBC_PARAM_PREFIX)) {\n+          connectionProps.put(prop.getKey().substring(JDBC_PARAM_PREFIX.length()), prop.getValue());\n+        }\n+      }\n+\n+      dbConn = DriverManager.getConnection(properties.get(CatalogProperties.HIVE_URI), connectionProps);\n+      initializeCatalogTables();\n+\n+    } catch (SQLException throwables) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "534babe9d218992035b7d3d8b991fce73ba314fd"}, "originalPosition": 100}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3NDM3OTk3", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-557437997", "createdAt": "2020-12-23T00:18:40Z", "commit": {"oid": "534babe9d218992035b7d3d8b991fce73ba314fd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QwMDoxODo0MFrOIKM8vA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QwMDoxODo0MFrOIKM8vA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU2ODgyOA==", "bodyText": "No need to wrap in an IOException. I think we should create an unchecked exception used to wrap SQLException.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r547568828", "createdAt": "2020-12-23T00:18:40Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, SupportsNamespaces, Closeable {\n+\n+  public static final String JDBC_PARAM_PREFIX = \"connection.parameter.\";\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcCatalog.class);\n+  private static final Joiner SLASH = Joiner.on(\"/\");\n+  private FileIO fileIO;\n+  private String name = \"jdbc\";\n+  private String warehouseLocation;\n+  private Configuration hadoopConf;\n+  private Connection dbConn;\n+\n+  public JdbcCatalog() {\n+  }\n+\n+  @SuppressWarnings(\"checkstyle:HiddenField\")\n+  @Override\n+  public void initialize(String name, Map<String, String> properties) throws UncheckedIOException {\n+    Preconditions.checkArgument(!properties.getOrDefault(CatalogProperties.HIVE_URI, \"\").isEmpty(),\n+            \"No connection url provided for jdbc catalog!\");\n+    Preconditions.checkArgument(!properties.getOrDefault(CatalogProperties.WAREHOUSE_LOCATION, \"\").isEmpty(),\n+            \"Cannot initialize Jdbc Catalog because warehousePath must not be null!\");\n+\n+    this.warehouseLocation = properties.get(CatalogProperties.WAREHOUSE_LOCATION).replaceAll(\"/$\", \"\");\n+    this.name = name == null ? \"jdbc\" : name;\n+    String fileIOImpl = properties.get(CatalogProperties.FILE_IO_IMPL);\n+    this.fileIO = fileIOImpl == null ?\n+            new HadoopFileIO(hadoopConf) :\n+            CatalogUtil.loadFileIO(fileIOImpl, properties, hadoopConf);\n+    initializeConnection(properties);\n+  }\n+\n+  private void initializeConnection(Map<String, String> properties) throws UncheckedIOException {\n+    try {\n+\n+      LOG.debug(\"Connecting to Jdbc database {}.\", properties.get(CatalogProperties.HIVE_URI));\n+      Properties connectionProps = new Properties();\n+      for (Map.Entry<String, String> prop : properties.entrySet()) {\n+        if (prop.getKey().startsWith(JDBC_PARAM_PREFIX)) {\n+          connectionProps.put(prop.getKey().substring(JDBC_PARAM_PREFIX.length()), prop.getValue());\n+        }\n+      }\n+\n+      dbConn = DriverManager.getConnection(properties.get(CatalogProperties.HIVE_URI), connectionProps);\n+      initializeCatalogTables();\n+\n+    } catch (SQLException throwables) {\n+      throw new UncheckedIOException(\"Failed to initialize Jdbc Catalog!\", new IOException(throwables));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "534babe9d218992035b7d3d8b991fce73ba314fd"}, "originalPosition": 101}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3NDQyNTYz", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-557442563", "createdAt": "2020-12-23T00:34:27Z", "commit": {"oid": "534babe9d218992035b7d3d8b991fce73ba314fd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QwMDozNDoyOFrOIKNM2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QwMDozNDoyOFrOIKNM2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU3Mjk1Mg==", "bodyText": "I'm not sure that I think this class is valuable. It is nice that it keeps track of the SQL statements and exposes some high-level methods, like update. The problem is that this provides many of the same operations as catalog, just under different names and with a slightly different API. For example, getAll(Namespace) is basically the same thing as Catalog.listTables.\nThis class is also used in inconsistent ways. In Catalog.delete and in TableOperations, it is used for a single table even though it can work with any table and has no state other than catalog and connection. It is also used in Catalog.listTables and Catalog.renameTable, even though there is no table to encapsulate.\nI think that the problem is that this is attempting to encapsulate a table, but it is really more about abstracting some of the SQL details. I think an improvement would be to instantiate one per catalog instead (and pass in a connection pool so it can be shared with TableOperations). You'd probably want to rename it to something like TableSQL?", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r547572952", "createdAt": "2020-12-23T00:34:28Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcTable.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcTable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "534babe9d218992035b7d3d8b991fce73ba314fd"}, "originalPosition": 36}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3NDQzMzg1", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-557443385", "createdAt": "2020-12-23T00:37:50Z", "commit": {"oid": "534babe9d218992035b7d3d8b991fce73ba314fd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QwMDozNzo1MVrOIKNQIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QwMDozNzo1MVrOIKNQIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU3Mzc5Mw==", "bodyText": "Are these needed? I think that autocommit can be used since all of the operations should just require a single command.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r547573793", "createdAt": "2020-12-23T00:37:51Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcTable.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcTable {\n+  public static final String SQL_TABLE_NAME = \"iceberg_tables\";\n+  public static final String SQL_TABLE_DDL =\n+          \"CREATE TABLE \" + JdbcTable.SQL_TABLE_NAME +\n+                  \"(catalog_name VARCHAR(1255) NOT NULL,\" +\n+                  \"table_namespace VARCHAR(1255) NOT NULL,\" +\n+                  \"table_name VARCHAR(1255) NOT NULL,\" +\n+                  \"metadata_location VARCHAR(32768),\" +\n+                  \"previous_metadata_location VARCHAR(32768),\" +\n+                  \"PRIMARY KEY (catalog_name, table_namespace, table_name)\" +\n+                  \")\";\n+  public static final String SQL_SELECT = \"SELECT * FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+  public static final String SQL_SELECT_ALL = \"SELECT * FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace = ?\";\n+  public static final String SQL_UPDATE_METADATA_LOCATION = \"UPDATE \" + SQL_TABLE_NAME +\n+          \" SET metadata_location = ? , previous_metadata_location = ? \" +\n+          \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? AND metadata_location = ?\";\n+  public static final String SQL_INSERT = \"INSERT INTO \" + SQL_TABLE_NAME +\n+          \" (catalog_name, table_namespace, table_name, metadata_location, previous_metadata_location) \" +\n+          \" VALUES (?,?,?,?,?)\";\n+  public static final String SQL_UPDATE_TABLE_NAME = \"UPDATE \" + SQL_TABLE_NAME +\n+          \" SET table_namespace = ? , table_name = ? \" +\n+          \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+  public static final String SQL_DELETE = \"DELETE FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcTable.class);\n+  private final String catalogName;\n+  private final Connection dbConn;\n+\n+  public JdbcTable(Connection dbConn, String catalogName) {\n+    this.dbConn = dbConn;\n+    this.catalogName = catalogName;\n+  }\n+\n+  public void setAutoCommitOff() throws SQLException {\n+    this.dbConn.setAutoCommit(false);\n+  }\n+\n+  public void setAutoCommitOn() throws SQLException {\n+    this.dbConn.setAutoCommit(true);\n+  }\n+\n+  public void commit() throws SQLException {\n+    this.dbConn.commit();\n+  }\n+\n+  public void rollback() throws SQLException {\n+    this.dbConn.rollback();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "534babe9d218992035b7d3d8b991fce73ba314fd"}, "originalPosition": 85}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3NDQ0Nzcx", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-557444771", "createdAt": "2020-12-23T00:43:34Z", "commit": {"oid": "534babe9d218992035b7d3d8b991fce73ba314fd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QwMDo0MzozNVrOIKNVvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QwMDo0MzozNVrOIKNVvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU3NTIzMQ==", "bodyText": "This shouldn't be needed because only Hadoop tables use version hints.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r547575231", "createdAt": "2020-12-23T00:43:35Z", "author": {"login": "rdblue"}, "path": "core/src/test/java/org/apache/iceberg/jdbc/TestJdbcCatalog.java", "diffHunk": "@@ -0,0 +1,566 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.DataFile;\n+import org.apache.iceberg.DataFiles;\n+import org.apache.iceberg.PartitionSpec;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.SortOrder;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.Transaction;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.hadoop.Util;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Sets;\n+import org.apache.iceberg.transforms.Transform;\n+import org.apache.iceberg.transforms.Transforms;\n+import org.apache.iceberg.types.Types;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import static org.apache.iceberg.NullOrder.NULLS_FIRST;\n+import static org.apache.iceberg.SortDirection.ASC;\n+import static org.apache.iceberg.types.Types.NestedField.required;\n+\n+public class TestJdbcCatalog {\n+  // Schema passed to create tables\n+  static final Schema SCHEMA = new Schema(\n+          required(1, \"id\", Types.IntegerType.get(), \"unique ID\"),\n+          required(2, \"data\", Types.StringType.get())\n+  );\n+\n+  // This is the actual schema for the table, with column IDs reassigned\n+  static final Schema TABLE_SCHEMA = new Schema(\n+          required(1, \"id\", Types.IntegerType.get(), \"unique ID\"),\n+          required(2, \"data\", Types.StringType.get())\n+  );\n+\n+  // Partition spec used to create tables\n+  static final PartitionSpec SPEC = PartitionSpec.builderFor(SCHEMA)\n+          .bucket(\"data\", 16)\n+          .build();\n+\n+  private static final ImmutableMap<String, String> meta = ImmutableMap.of();\n+  static Configuration conf;\n+  private static JdbcCatalog catalog;\n+  @Rule\n+  public TemporaryFolder temp = new TemporaryFolder();\n+  File tableDir = null;\n+  String tableLocation = null;\n+  File versionHintFile = null;\n+  String warehousePath;\n+\n+  protected List<String> metadataVersionFiles(String location) {\n+    return Stream.of(new File(location).listFiles())\n+            .filter(file -> !file.isDirectory())\n+            .map(File::getName)\n+            .filter(fileName -> fileName.endsWith(\"metadata.json\"))\n+            .collect(Collectors.toList())\n+            ;\n+  }\n+\n+  protected List<String> manifestFiles(String location) {\n+    return Stream.of(new File(location).listFiles())\n+            .filter(file -> !file.isDirectory())\n+            .map(File::getName)\n+            .filter(fileName -> fileName.endsWith(\".avro\"))\n+            .collect(Collectors.toList())\n+            ;\n+  }\n+\n+  @Before\n+  public void setupTable() throws Exception {\n+    this.tableDir = temp.newFolder();\n+    tableDir.delete(); // created by table create\n+\n+    this.tableLocation = tableDir.toURI().toString();\n+    this.versionHintFile = new File(new File(tableDir, \"metadata\"), \"version-hint.text\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "534babe9d218992035b7d3d8b991fce73ba314fd"}, "originalPosition": 121}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3NDQ1MzM4", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-557445338", "createdAt": "2020-12-23T00:45:51Z", "commit": {"oid": "534babe9d218992035b7d3d8b991fce73ba314fd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QwMDo0NTo1MVrOIKNX1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QwMDo0NTo1MVrOIKNX1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU3NTc2Nw==", "bodyText": "I think that there need to be tests for the JDBC operations that are exposed by JdbcTable directly. Those should check cases that are required, like creating a table fails if it already exists, updating a table when metadata is out of date catches the error, etc. Then we can add functional tests to ensure that the catalog calls those correctly.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r547575767", "createdAt": "2020-12-23T00:45:51Z", "author": {"login": "rdblue"}, "path": "core/src/test/java/org/apache/iceberg/jdbc/TestJdbcCatalog.java", "diffHunk": "@@ -0,0 +1,566 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.DataFile;\n+import org.apache.iceberg.DataFiles;\n+import org.apache.iceberg.PartitionSpec;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.SortOrder;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.Transaction;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.hadoop.Util;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Sets;\n+import org.apache.iceberg.transforms.Transform;\n+import org.apache.iceberg.transforms.Transforms;\n+import org.apache.iceberg.types.Types;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import static org.apache.iceberg.NullOrder.NULLS_FIRST;\n+import static org.apache.iceberg.SortDirection.ASC;\n+import static org.apache.iceberg.types.Types.NestedField.required;\n+\n+public class TestJdbcCatalog {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "534babe9d218992035b7d3d8b991fce73ba314fd"}, "originalPosition": 69}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "afbae165f92693e86f58a3a7ad84f99e8a19a35d", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/afbae165f92693e86f58a3a7ad84f99e8a19a35d", "committedDate": "2020-12-23T19:44:48Z", "message": "address review comments"}, "afterCommit": {"oid": "561f1bce03b8c4a6217539d0ed50d697c9bf227b", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/561f1bce03b8c4a6217539d0ed50d697c9bf227b", "committedDate": "2020-12-23T20:07:30Z", "message": "WIP address review comments - connection pool"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "561f1bce03b8c4a6217539d0ed50d697c9bf227b", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/561f1bce03b8c4a6217539d0ed50d697c9bf227b", "committedDate": "2020-12-23T20:07:30Z", "message": "WIP address review comments - connection pool"}, "afterCommit": {"oid": "9febe36ee420a77be431ce38b0e9960e5f31d04c", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/9febe36ee420a77be431ce38b0e9960e5f31d04c", "committedDate": "2020-12-23T20:09:53Z", "message": "jdbc catalog\n\naddress review comments\n\nmore cleanup\n\ntest rollback scenario with renameTable\n\nfix\n\ncleanup\n\ncleanup, removed fs, create empty constructor and updated initialization\n\nfix unittest\n\nadded jdbc catalog to SparkCatalog and added tests to TestRemoveOrphanFilesAction3\n\nadded new test\n\nfix naming\n\ndo updates inside transaction and rollback updates if it fails.\n\nensure target namespace is exists before renaming table\n\nfix scope, revert license changes\n\njdbc catalog"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "09919f97a8171930c997f6c0af6139ddacfb91e3", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/09919f97a8171930c997f6c0af6139ddacfb91e3", "committedDate": "2020-12-27T20:07:25Z", "message": "address review comments\n\naddress review comments"}, "afterCommit": {"oid": "81b65f7383b4b0cf5823aac7aa56c796126fcd7d", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/81b65f7383b4b0cf5823aac7aa56c796126fcd7d", "committedDate": "2020-12-27T20:09:38Z", "message": "address review comments\n\naddress review comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6d3737f9b5a04d4cadf2c8244e773ea6872a00c9", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/6d3737f9b5a04d4cadf2c8244e773ea6872a00c9", "committedDate": "2020-12-27T23:30:34Z", "message": "extent UncheckedIOException from UncheckedIOException"}, "afterCommit": {"oid": "e6f8c6e36d78a79c8a8561292c2fa07f7e7f480a", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/e6f8c6e36d78a79c8a8561292c2fa07f7e7f480a", "committedDate": "2020-12-27T23:32:44Z", "message": "extent UncheckedSQLException from UncheckedIOException"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5MzM5Mjg2", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-559339286", "createdAt": "2020-12-29T00:14:02Z", "commit": {"oid": "e6f8c6e36d78a79c8a8561292c2fa07f7e7f480a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwMDoxNDowMlrOIMEVRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwMDoxNDowMlrOIMEVRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUyNDgwNA==", "bodyText": "Why extend UncheckedIOException? This class is supposed to be the equivalent for SQLException, which is not an IOException.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r549524804", "createdAt": "2020-12-29T00:14:02Z", "author": {"login": "rdblue"}, "path": "api/src/main/java/org/apache/iceberg/exceptions/UncheckedSQLException.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.exceptions;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.sql.SQLException;\n+\n+public class UncheckedSQLException extends UncheckedIOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6f8c6e36d78a79c8a8561292c2fa07f7e7f480a"}, "originalPosition": 26}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5MzM5MzM3", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-559339337", "createdAt": "2020-12-29T00:14:28Z", "commit": {"oid": "e6f8c6e36d78a79c8a8561292c2fa07f7e7f480a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwMDoxNDoyOVrOIMEVhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwMDoxNDoyOVrOIMEVhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUyNDg2OQ==", "bodyText": "There is no need to wrap an exception that isn't a SQLException is there?", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r549524869", "createdAt": "2020-12-29T00:14:29Z", "author": {"login": "rdblue"}, "path": "api/src/main/java/org/apache/iceberg/exceptions/UncheckedSQLException.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.exceptions;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.sql.SQLException;\n+\n+public class UncheckedSQLException extends UncheckedIOException {\n+\n+  public UncheckedSQLException(String message, SQLException cause) {\n+    super(message, new IOException(cause));\n+  }\n+\n+  public UncheckedSQLException(String message, Exception cause) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6f8c6e36d78a79c8a8561292c2fa07f7e7f480a"}, "originalPosition": 32}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5MzM5MzY4", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-559339368", "createdAt": "2020-12-29T00:14:40Z", "commit": {"oid": "e6f8c6e36d78a79c8a8561292c2fa07f7e7f480a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwMDoxNDo0MFrOIMEVmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwMDoxNDo0MFrOIMEVmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUyNDg5MQ==", "bodyText": "I don't think this is needed.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r549524891", "createdAt": "2020-12-29T00:14:40Z", "author": {"login": "rdblue"}, "path": "api/src/main/java/org/apache/iceberg/exceptions/UncheckedSQLException.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.exceptions;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.sql.SQLException;\n+\n+public class UncheckedSQLException extends UncheckedIOException {\n+\n+  public UncheckedSQLException(String message, SQLException cause) {\n+    super(message, new IOException(cause));\n+  }\n+\n+  public UncheckedSQLException(String message, Exception cause) {\n+    super(message, new IOException(cause));\n+  }\n+\n+  public UncheckedSQLException(String message, InterruptedException cause) {\n+    super(message, new IOException(cause));\n+  }\n+\n+  public UncheckedSQLException(String message) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6f8c6e36d78a79c8a8561292c2fa07f7e7f480a"}, "originalPosition": 40}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5MzM5Mzc0", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-559339374", "createdAt": "2020-12-29T00:14:43Z", "commit": {"oid": "e6f8c6e36d78a79c8a8561292c2fa07f7e7f480a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwMDoxNDo0M1rOIMEVog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwMDoxNDo0M1rOIMEVog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUyNDg5OA==", "bodyText": "I don't think this is needed.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r549524898", "createdAt": "2020-12-29T00:14:43Z", "author": {"login": "rdblue"}, "path": "api/src/main/java/org/apache/iceberg/exceptions/UncheckedSQLException.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.exceptions;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.sql.SQLException;\n+\n+public class UncheckedSQLException extends UncheckedIOException {\n+\n+  public UncheckedSQLException(String message, SQLException cause) {\n+    super(message, new IOException(cause));\n+  }\n+\n+  public UncheckedSQLException(String message, Exception cause) {\n+    super(message, new IOException(cause));\n+  }\n+\n+  public UncheckedSQLException(String message, InterruptedException cause) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6f8c6e36d78a79c8a8561292c2fa07f7e7f480a"}, "originalPosition": 36}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5MzQwNDQ4", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-559340448", "createdAt": "2020-12-29T00:22:27Z", "commit": {"oid": "e6f8c6e36d78a79c8a8561292c2fa07f7e7f480a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwMDoyMjoyN1rOIMEaWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwMDoyMjoyN1rOIMEaWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUyNjEwNw==", "bodyText": "DriverManager.getConnection will throw SQLTimeoutException or a generic SQLException. Those are the only two exception classes that need to be handled. Considering there isn't much that can be done for either one, I think this should simply wrap any SQLException in UncheckedSQLException with a little context, like the connect URI.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r549526107", "createdAt": "2020-12-29T00:22:27Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcClientPool.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.SQLException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.sql.SQLWarning;\n+import java.util.Properties;\n+import org.apache.iceberg.ClientPool;\n+import org.apache.iceberg.exceptions.UncheckedSQLException;\n+\n+public class JdbcClientPool extends ClientPool<Connection, SQLException> {\n+\n+  private final String dbUrl;\n+  private final Properties dbProperties;\n+\n+  JdbcClientPool(String dbUrl, Properties props) {\n+    this((Integer) props.getOrDefault(\"iceberg.jdbc.client-pool-size\", 5), dbUrl, props);\n+  }\n+\n+  public JdbcClientPool(int poolSize, String dbUrl, Properties props) {\n+    super(poolSize, SQLException.class);\n+    dbProperties = props;\n+    this.dbUrl = dbUrl;\n+  }\n+\n+  @Override\n+  protected Connection newClient() {\n+    try {\n+      return DriverManager.getConnection(dbUrl, dbProperties);\n+    } catch (SQLTimeoutException e) {\n+      throw new UncheckedSQLException(\"Connection timeout!\", e);\n+    } catch (SQLTransientConnectionException | SQLNonTransientConnectionException e) {\n+      throw new UncheckedSQLException(\"Connection failed!\", e);\n+    } catch (SQLWarning e) {\n+      throw new UncheckedSQLException(\"Database connection warning!\", e);\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(\"Failed to connect to database!\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6f8c6e36d78a79c8a8561292c2fa07f7e7f480a"}, "originalPosition": 59}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5MzQxMzg0", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-559341384", "createdAt": "2020-12-29T00:29:06Z", "commit": {"oid": "e6f8c6e36d78a79c8a8561292c2fa07f7e7f480a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwMDoyOTowNlrOIMEe7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwMDoyOTowNlrOIMEe7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUyNzI3Ng==", "bodyText": "The second argument for the ClientPool constructor is an exception that indicates a connection has gone bad and should be recreated using reconnect. I don't think that any SQLException should trigger reconnecting because there are a lot of different subclasses that have nothing to do with connection issues.\nIn Hive, we use TTransportException, which indicates a connection failure rather than an error from the remote service. It looks like the equivalent for JDBC might be SQLNonTransientConnectionException.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r549527276", "createdAt": "2020-12-29T00:29:06Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcClientPool.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.SQLException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.sql.SQLWarning;\n+import java.util.Properties;\n+import org.apache.iceberg.ClientPool;\n+import org.apache.iceberg.exceptions.UncheckedSQLException;\n+\n+public class JdbcClientPool extends ClientPool<Connection, SQLException> {\n+\n+  private final String dbUrl;\n+  private final Properties dbProperties;\n+\n+  JdbcClientPool(String dbUrl, Properties props) {\n+    this((Integer) props.getOrDefault(\"iceberg.jdbc.client-pool-size\", 5), dbUrl, props);\n+  }\n+\n+  public JdbcClientPool(int poolSize, String dbUrl, Properties props) {\n+    super(poolSize, SQLException.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6f8c6e36d78a79c8a8561292c2fa07f7e7f480a"}, "originalPosition": 43}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5MzQxODI2", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-559341826", "createdAt": "2020-12-29T00:32:31Z", "commit": {"oid": "e6f8c6e36d78a79c8a8561292c2fa07f7e7f480a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwMDozMjozMVrOIMEg5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwMDozMjozMVrOIMEg5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUyNzc4MQ==", "bodyText": "I don't think that Iceberg uses Properties anywhere, so this should probably accept Map<String, String> and pass that to JDBC as properties if necessary.\nAlso, config properties don't need config context like iceberg.jdbc because that context is already dependent on how the catalog is configured. For example, Spark catalogs will use spark.sql.catalog.catalog_name.uri for the connection URI already. So the property keys here should just be the standard ones defined in CatalogProperties.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r549527781", "createdAt": "2020-12-29T00:32:31Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcClientPool.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.SQLException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.sql.SQLWarning;\n+import java.util.Properties;\n+import org.apache.iceberg.ClientPool;\n+import org.apache.iceberg.exceptions.UncheckedSQLException;\n+\n+public class JdbcClientPool extends ClientPool<Connection, SQLException> {\n+\n+  private final String dbUrl;\n+  private final Properties dbProperties;\n+\n+  JdbcClientPool(String dbUrl, Properties props) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6f8c6e36d78a79c8a8561292c2fa07f7e7f480a"}, "originalPosition": 38}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5MzQyMDQx", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-559342041", "createdAt": "2020-12-29T00:34:05Z", "commit": {"oid": "e6f8c6e36d78a79c8a8561292c2fa07f7e7f480a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwMDozNDowNlrOIMEhzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwMDozNDowNlrOIMEhzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUyODAxNA==", "bodyText": "No need to prefix with this when calling a method or reading a field. We only add it to distinguish between setting instance fields (this.x = ...) and local variables (x = ...).", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r549528014", "createdAt": "2020-12-29T00:34:06Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcClientPool.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.SQLException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.sql.SQLWarning;\n+import java.util.Properties;\n+import org.apache.iceberg.ClientPool;\n+import org.apache.iceberg.exceptions.UncheckedSQLException;\n+\n+public class JdbcClientPool extends ClientPool<Connection, SQLException> {\n+\n+  private final String dbUrl;\n+  private final Properties dbProperties;\n+\n+  JdbcClientPool(String dbUrl, Properties props) {\n+    this((Integer) props.getOrDefault(\"iceberg.jdbc.client-pool-size\", 5), dbUrl, props);\n+  }\n+\n+  public JdbcClientPool(int poolSize, String dbUrl, Properties props) {\n+    super(poolSize, SQLException.class);\n+    dbProperties = props;\n+    this.dbUrl = dbUrl;\n+  }\n+\n+  @Override\n+  protected Connection newClient() {\n+    try {\n+      return DriverManager.getConnection(dbUrl, dbProperties);\n+    } catch (SQLTimeoutException e) {\n+      throw new UncheckedSQLException(\"Connection timeout!\", e);\n+    } catch (SQLTransientConnectionException | SQLNonTransientConnectionException e) {\n+      throw new UncheckedSQLException(\"Connection failed!\", e);\n+    } catch (SQLWarning e) {\n+      throw new UncheckedSQLException(\"Database connection warning!\", e);\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(\"Failed to connect to database!\", e);\n+    }\n+  }\n+\n+  @Override\n+  protected Connection reconnect(Connection client) {\n+    this.close(client);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6f8c6e36d78a79c8a8561292c2fa07f7e7f480a"}, "originalPosition": 65}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5MzQyMTk0", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-559342194", "createdAt": "2020-12-29T00:35:31Z", "commit": {"oid": "e6f8c6e36d78a79c8a8561292c2fa07f7e7f480a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwMDozNTozMVrOIMEinw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwMDozNTozMVrOIMEinw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUyODIyMw==", "bodyText": "Nit: continuation indents should be 2 indents, which is 4 spaces, not 8.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r549528223", "createdAt": "2020-12-29T00:35:31Z", "author": {"login": "rdblue"}, "path": "core/src/test/java/org/apache/iceberg/jdbc/TestJdbcTableConcurrency.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.DataFile;\n+import org.apache.iceberg.DataFiles;\n+import org.apache.iceberg.FileFormat;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.relocated.com.google.common.collect.Iterables;\n+import org.apache.iceberg.relocated.com.google.common.util.concurrent.MoreExecutors;\n+import org.apache.iceberg.types.Types;\n+import org.apache.iceberg.util.Tasks;\n+import org.junit.Assert;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import static org.apache.iceberg.TableProperties.COMMIT_MAX_RETRY_WAIT_MS;\n+import static org.apache.iceberg.TableProperties.COMMIT_MIN_RETRY_WAIT_MS;\n+import static org.apache.iceberg.TableProperties.COMMIT_NUM_RETRIES;\n+import static org.apache.iceberg.types.Types.NestedField.required;\n+\n+public class TestJdbcTableConcurrency {\n+\n+  static final TableIdentifier TABLE_IDENTIFIER = TableIdentifier.of(\"db\", \"test_table\");\n+  static final Schema SCHEMA = new Schema(\n+          required(1, \"id\", Types.IntegerType.get(), \"unique ID\"),\n+          required(2, \"data\", Types.StringType.get())\n+  );\n+  @Rule\n+  public TemporaryFolder temp = new TemporaryFolder();\n+  File tableDir;\n+\n+  @Test\n+  public synchronized void testConcurrentFastAppends() throws IOException {\n+    Map<String, String> properties = new HashMap<>();\n+    this.tableDir = temp.newFolder();\n+    properties.put(CatalogProperties.WAREHOUSE_LOCATION, tableDir.getAbsolutePath());\n+    properties.put(CatalogProperties.HIVE_URI, \"jdbc:h2:mem:concurentFastAppend;create=true\");\n+    JdbcCatalog catalog = new JdbcCatalog();\n+    catalog.setConf(new Configuration());\n+    catalog.initialize(\"jdbc\", properties);\n+    catalog.createTable(TABLE_IDENTIFIER, SCHEMA);\n+\n+    Table icebergTable = catalog.loadTable(TABLE_IDENTIFIER);\n+\n+    String fileName = UUID.randomUUID().toString();\n+    DataFile file = DataFiles.builder(icebergTable.spec())\n+            .withPath(FileFormat.PARQUET.addExtension(fileName))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6f8c6e36d78a79c8a8561292c2fa07f7e7f480a"}, "originalPosition": 80}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5MzQyMzEw", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-559342310", "createdAt": "2020-12-29T00:36:17Z", "commit": {"oid": "e6f8c6e36d78a79c8a8561292c2fa07f7e7f480a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwMDozNjoxN1rOIMEjMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwMDozNjoxN1rOIMEjMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUyODM2OQ==", "bodyText": "This test should also be moved if the original class was moved.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r549528369", "createdAt": "2020-12-29T00:36:17Z", "author": {"login": "rdblue"}, "path": "hive-metastore/src/test/java/org/apache/iceberg/hive/TestClientPool.java", "diffHunk": "@@ -19,6 +19,7 @@\n \n package org.apache.iceberg.hive;\n \n+import org.apache.iceberg.ClientPool;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6f8c6e36d78a79c8a8561292c2fa07f7e7f480a"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5MzQyMzQ4", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-559342348", "createdAt": "2020-12-29T00:36:34Z", "commit": {"oid": "e6f8c6e36d78a79c8a8561292c2fa07f7e7f480a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwMDozNjozNFrOIMEjYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwMDozNjozNFrOIMEjYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUyODQxNg==", "bodyText": "Nit: unnecessary whitespace change.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r549528416", "createdAt": "2020-12-29T00:36:34Z", "author": {"login": "rdblue"}, "path": "spark3/src/main/java/org/apache/iceberg/spark/SparkCatalog.java", "diffHunk": "@@ -111,14 +113,20 @@ protected Catalog buildIcebergCatalog(String name, CaseInsensitiveStringMap opti\n     switch (catalogType.toLowerCase(Locale.ENGLISH)) {\n       case ICEBERG_CATALOG_TYPE_HIVE:\n         int clientPoolSize = options.getInt(CatalogProperties.HIVE_CLIENT_POOL_SIZE,\n-            CatalogProperties.HIVE_CLIENT_POOL_SIZE_DEFAULT);\n+                CatalogProperties.HIVE_CLIENT_POOL_SIZE_DEFAULT);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6f8c6e36d78a79c8a8561292c2fa07f7e7f480a"}, "originalPosition": 21}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5MzQyOTQz", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-559342943", "createdAt": "2020-12-29T00:40:48Z", "commit": {"oid": "e6f8c6e36d78a79c8a8561292c2fa07f7e7f480a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwMDo0MDo0OFrOIMEl_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwMDo0MDo0OFrOIMEl_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUyOTA4Ng==", "bodyText": "Style: in other places, we use different naming conventions:\n\nFileIO instances are typically called io\nConfiguration instances are typically called conf\nA pool would typically be a plural named for the pooled objects, like connections", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r549529086", "createdAt": "2020-12-29T00:40:48Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,391 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.io.Closeable;\n+import java.sql.Connection;\n+import java.sql.DataTruncation;\n+import java.sql.DatabaseMetaData;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.sql.SQLWarning;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.exceptions.UncheckedSQLException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, SupportsNamespaces, Closeable {\n+\n+  public static final String SQL_TABLE_NAME = \"iceberg_tables\";\n+  public static final String SQL_TABLE_DDL =\n+          \"CREATE TABLE \" + SQL_TABLE_NAME +\n+                  \"(catalog_name VARCHAR(1255) NOT NULL,\" +\n+                  \"table_namespace VARCHAR(1255) NOT NULL,\" +\n+                  \"table_name VARCHAR(1255) NOT NULL,\" +\n+                  \"metadata_location VARCHAR(32768),\" +\n+                  \"previous_metadata_location VARCHAR(32768),\" +\n+                  \"PRIMARY KEY (catalog_name, table_namespace, table_name)\" +\n+                  \")\";\n+  public static final String SQL_SELECT_TABLE = \"SELECT * FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+  public static final String SQL_SELECT_ALL = \"SELECT * FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace = ?\";\n+  public static final String SQL_UPDATE_TABLE_NAME = \"UPDATE \" + SQL_TABLE_NAME +\n+          \" SET table_namespace = ? , table_name = ? \" +\n+          \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+  public static final String SQL_DELETE_TABLE = \"DELETE FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+  public static final String SQL_SELECT_NAMESPACE = \"SELECT table_namespace FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace LIKE ? LIMIT 1\";\n+  public static final String SQL_SELECT_NAMESPACES = \"SELECT DISTINCT table_namespace FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace LIKE ?\";\n+  public static final String JDBC_PARAM_PREFIX = \"connection.parameter.\";\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcCatalog.class);\n+  private static final Joiner SLASH = Joiner.on(\"/\");\n+\n+  private FileIO fileIO;\n+  private String catalogName = \"jdbc\";\n+  private String warehouseLocation;\n+  private Configuration hadoopConf;\n+  private JdbcClientPool dbConnPool;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6f8c6e36d78a79c8a8561292c2fa07f7e7f480a"}, "originalPosition": 98}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5MzQzMDI0", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-559343024", "createdAt": "2020-12-29T00:41:32Z", "commit": {"oid": "e6f8c6e36d78a79c8a8561292c2fa07f7e7f480a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwMDo0MTozMlrOIMEmTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwMDo0MTozMlrOIMEmTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUyOTE2NA==", "bodyText": "I don't think we should suppress this. Instead, can you update the code to avoid it?", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r549529164", "createdAt": "2020-12-29T00:41:32Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,391 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.io.Closeable;\n+import java.sql.Connection;\n+import java.sql.DataTruncation;\n+import java.sql.DatabaseMetaData;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.sql.SQLWarning;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.exceptions.UncheckedSQLException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, SupportsNamespaces, Closeable {\n+\n+  public static final String SQL_TABLE_NAME = \"iceberg_tables\";\n+  public static final String SQL_TABLE_DDL =\n+          \"CREATE TABLE \" + SQL_TABLE_NAME +\n+                  \"(catalog_name VARCHAR(1255) NOT NULL,\" +\n+                  \"table_namespace VARCHAR(1255) NOT NULL,\" +\n+                  \"table_name VARCHAR(1255) NOT NULL,\" +\n+                  \"metadata_location VARCHAR(32768),\" +\n+                  \"previous_metadata_location VARCHAR(32768),\" +\n+                  \"PRIMARY KEY (catalog_name, table_namespace, table_name)\" +\n+                  \")\";\n+  public static final String SQL_SELECT_TABLE = \"SELECT * FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+  public static final String SQL_SELECT_ALL = \"SELECT * FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace = ?\";\n+  public static final String SQL_UPDATE_TABLE_NAME = \"UPDATE \" + SQL_TABLE_NAME +\n+          \" SET table_namespace = ? , table_name = ? \" +\n+          \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+  public static final String SQL_DELETE_TABLE = \"DELETE FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+  public static final String SQL_SELECT_NAMESPACE = \"SELECT table_namespace FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace LIKE ? LIMIT 1\";\n+  public static final String SQL_SELECT_NAMESPACES = \"SELECT DISTINCT table_namespace FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace LIKE ?\";\n+  public static final String JDBC_PARAM_PREFIX = \"connection.parameter.\";\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcCatalog.class);\n+  private static final Joiner SLASH = Joiner.on(\"/\");\n+\n+  private FileIO fileIO;\n+  private String catalogName = \"jdbc\";\n+  private String warehouseLocation;\n+  private Configuration hadoopConf;\n+  private JdbcClientPool dbConnPool;\n+\n+  public JdbcCatalog() {\n+  }\n+\n+  @SuppressWarnings(\"checkstyle:HiddenField\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6f8c6e36d78a79c8a8561292c2fa07f7e7f480a"}, "originalPosition": 103}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5MzQzMzc4", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-559343378", "createdAt": "2020-12-29T00:44:02Z", "commit": {"oid": "e6f8c6e36d78a79c8a8561292c2fa07f7e7f480a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwMDo0NDowM1rOIMEn3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwMDo0NDowM1rOIMEn3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUyOTU2Nw==", "bodyText": "Is this required by the database or is it just a convention? I don't think we should check for multiple table names.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r549529567", "createdAt": "2020-12-29T00:44:03Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,391 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.io.Closeable;\n+import java.sql.Connection;\n+import java.sql.DataTruncation;\n+import java.sql.DatabaseMetaData;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.sql.SQLWarning;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.exceptions.UncheckedSQLException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, SupportsNamespaces, Closeable {\n+\n+  public static final String SQL_TABLE_NAME = \"iceberg_tables\";\n+  public static final String SQL_TABLE_DDL =\n+          \"CREATE TABLE \" + SQL_TABLE_NAME +\n+                  \"(catalog_name VARCHAR(1255) NOT NULL,\" +\n+                  \"table_namespace VARCHAR(1255) NOT NULL,\" +\n+                  \"table_name VARCHAR(1255) NOT NULL,\" +\n+                  \"metadata_location VARCHAR(32768),\" +\n+                  \"previous_metadata_location VARCHAR(32768),\" +\n+                  \"PRIMARY KEY (catalog_name, table_namespace, table_name)\" +\n+                  \")\";\n+  public static final String SQL_SELECT_TABLE = \"SELECT * FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+  public static final String SQL_SELECT_ALL = \"SELECT * FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace = ?\";\n+  public static final String SQL_UPDATE_TABLE_NAME = \"UPDATE \" + SQL_TABLE_NAME +\n+          \" SET table_namespace = ? , table_name = ? \" +\n+          \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+  public static final String SQL_DELETE_TABLE = \"DELETE FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+  public static final String SQL_SELECT_NAMESPACE = \"SELECT table_namespace FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace LIKE ? LIMIT 1\";\n+  public static final String SQL_SELECT_NAMESPACES = \"SELECT DISTINCT table_namespace FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace LIKE ?\";\n+  public static final String JDBC_PARAM_PREFIX = \"connection.parameter.\";\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcCatalog.class);\n+  private static final Joiner SLASH = Joiner.on(\"/\");\n+\n+  private FileIO fileIO;\n+  private String catalogName = \"jdbc\";\n+  private String warehouseLocation;\n+  private Configuration hadoopConf;\n+  private JdbcClientPool dbConnPool;\n+\n+  public JdbcCatalog() {\n+  }\n+\n+  @SuppressWarnings(\"checkstyle:HiddenField\")\n+  @Override\n+  public void initialize(String name, Map<String, String> properties) {\n+    Preconditions.checkArgument(!properties.getOrDefault(CatalogProperties.HIVE_URI, \"\").isEmpty(),\n+            \"No connection url provided for jdbc catalog!\");\n+    Preconditions.checkArgument(!properties.getOrDefault(CatalogProperties.WAREHOUSE_LOCATION, \"\").isEmpty(),\n+            \"Cannot initialize Jdbc Catalog because warehousePath must not be null!\");\n+\n+    this.warehouseLocation = properties.get(CatalogProperties.WAREHOUSE_LOCATION).replaceAll(\"/$\", \"\");\n+    this.catalogName = name == null ? \"jdbc\" : name;\n+    String fileIOImpl = properties.get(CatalogProperties.FILE_IO_IMPL);\n+    this.fileIO = fileIOImpl == null ?\n+            new HadoopFileIO(hadoopConf) :\n+            CatalogUtil.loadFileIO(fileIOImpl, properties, hadoopConf);\n+    initializeConnection(properties);\n+  }\n+\n+  private void initializeConnection(Map<String, String> properties) {\n+    try {\n+      LOG.debug(\"Connecting to Jdbc database {}\", properties.get(CatalogProperties.HIVE_URI));\n+      Properties dbProps = new Properties();\n+      for (Map.Entry<String, String> prop : properties.entrySet()) {\n+        if (prop.getKey().startsWith(JDBC_PARAM_PREFIX)) {\n+          dbProps.put(prop.getKey().substring(JDBC_PARAM_PREFIX.length()), prop.getValue());\n+        }\n+      }\n+      dbConnPool = new JdbcClientPool(properties.get(CatalogProperties.HIVE_URI), dbProps);\n+      initializeCatalogTables();\n+    } catch (SQLTimeoutException e) {\n+      throw new UncheckedSQLException(\"Database Connection timeout!\", e);\n+    } catch (SQLTransientConnectionException | SQLNonTransientConnectionException e) {\n+      throw new UncheckedSQLException(\"Database Connection failed!\", e);\n+    } catch (SQLWarning e) {\n+      throw new UncheckedSQLException(\"Database connection warning!\", e);\n+    } catch (SQLException | InterruptedException e) {\n+      throw new UncheckedSQLException(\"Failed to initialize Jdbc Catalog!\", e);\n+    }\n+  }\n+\n+  private void initializeCatalogTables() throws InterruptedException, SQLException {\n+    // need to check multiple times because some databases are using different naming standard. ex: H2db keeping\n+    // table names as uppercase", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6f8c6e36d78a79c8a8561292c2fa07f7e7f480a"}, "originalPosition": 144}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5MzQzNTc2", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-559343576", "createdAt": "2020-12-29T00:45:28Z", "commit": {"oid": "e6f8c6e36d78a79c8a8561292c2fa07f7e7f480a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwMDo0NToyOVrOIMEoyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwMDo0NToyOVrOIMEoyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUyOTgwMA==", "bodyText": "I think these exceptions should be handled in initializeCatalogTables, not in this method.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r549529800", "createdAt": "2020-12-29T00:45:29Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,391 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.io.Closeable;\n+import java.sql.Connection;\n+import java.sql.DataTruncation;\n+import java.sql.DatabaseMetaData;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.sql.SQLWarning;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.exceptions.UncheckedSQLException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, SupportsNamespaces, Closeable {\n+\n+  public static final String SQL_TABLE_NAME = \"iceberg_tables\";\n+  public static final String SQL_TABLE_DDL =\n+          \"CREATE TABLE \" + SQL_TABLE_NAME +\n+                  \"(catalog_name VARCHAR(1255) NOT NULL,\" +\n+                  \"table_namespace VARCHAR(1255) NOT NULL,\" +\n+                  \"table_name VARCHAR(1255) NOT NULL,\" +\n+                  \"metadata_location VARCHAR(32768),\" +\n+                  \"previous_metadata_location VARCHAR(32768),\" +\n+                  \"PRIMARY KEY (catalog_name, table_namespace, table_name)\" +\n+                  \")\";\n+  public static final String SQL_SELECT_TABLE = \"SELECT * FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+  public static final String SQL_SELECT_ALL = \"SELECT * FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace = ?\";\n+  public static final String SQL_UPDATE_TABLE_NAME = \"UPDATE \" + SQL_TABLE_NAME +\n+          \" SET table_namespace = ? , table_name = ? \" +\n+          \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+  public static final String SQL_DELETE_TABLE = \"DELETE FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+  public static final String SQL_SELECT_NAMESPACE = \"SELECT table_namespace FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace LIKE ? LIMIT 1\";\n+  public static final String SQL_SELECT_NAMESPACES = \"SELECT DISTINCT table_namespace FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace LIKE ?\";\n+  public static final String JDBC_PARAM_PREFIX = \"connection.parameter.\";\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcCatalog.class);\n+  private static final Joiner SLASH = Joiner.on(\"/\");\n+\n+  private FileIO fileIO;\n+  private String catalogName = \"jdbc\";\n+  private String warehouseLocation;\n+  private Configuration hadoopConf;\n+  private JdbcClientPool dbConnPool;\n+\n+  public JdbcCatalog() {\n+  }\n+\n+  @SuppressWarnings(\"checkstyle:HiddenField\")\n+  @Override\n+  public void initialize(String name, Map<String, String> properties) {\n+    Preconditions.checkArgument(!properties.getOrDefault(CatalogProperties.HIVE_URI, \"\").isEmpty(),\n+            \"No connection url provided for jdbc catalog!\");\n+    Preconditions.checkArgument(!properties.getOrDefault(CatalogProperties.WAREHOUSE_LOCATION, \"\").isEmpty(),\n+            \"Cannot initialize Jdbc Catalog because warehousePath must not be null!\");\n+\n+    this.warehouseLocation = properties.get(CatalogProperties.WAREHOUSE_LOCATION).replaceAll(\"/$\", \"\");\n+    this.catalogName = name == null ? \"jdbc\" : name;\n+    String fileIOImpl = properties.get(CatalogProperties.FILE_IO_IMPL);\n+    this.fileIO = fileIOImpl == null ?\n+            new HadoopFileIO(hadoopConf) :\n+            CatalogUtil.loadFileIO(fileIOImpl, properties, hadoopConf);\n+    initializeConnection(properties);\n+  }\n+\n+  private void initializeConnection(Map<String, String> properties) {\n+    try {\n+      LOG.debug(\"Connecting to Jdbc database {}\", properties.get(CatalogProperties.HIVE_URI));\n+      Properties dbProps = new Properties();\n+      for (Map.Entry<String, String> prop : properties.entrySet()) {\n+        if (prop.getKey().startsWith(JDBC_PARAM_PREFIX)) {\n+          dbProps.put(prop.getKey().substring(JDBC_PARAM_PREFIX.length()), prop.getValue());\n+        }\n+      }\n+      dbConnPool = new JdbcClientPool(properties.get(CatalogProperties.HIVE_URI), dbProps);\n+      initializeCatalogTables();\n+    } catch (SQLTimeoutException e) {\n+      throw new UncheckedSQLException(\"Database Connection timeout!\", e);\n+    } catch (SQLTransientConnectionException | SQLNonTransientConnectionException e) {\n+      throw new UncheckedSQLException(\"Database Connection failed!\", e);\n+    } catch (SQLWarning e) {\n+      throw new UncheckedSQLException(\"Database connection warning!\", e);\n+    } catch (SQLException | InterruptedException e) {\n+      throw new UncheckedSQLException(\"Failed to initialize Jdbc Catalog!\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6f8c6e36d78a79c8a8561292c2fa07f7e7f480a"}, "originalPosition": 138}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5MzQzNjkw", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-559343690", "createdAt": "2020-12-29T00:46:20Z", "commit": {"oid": "e6f8c6e36d78a79c8a8561292c2fa07f7e7f480a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwMDo0NjoyMFrOIMEpYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwMDo0NjoyMFrOIMEpYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUyOTk1NQ==", "bodyText": "Why doesn't this store the table name that was found? Does it rely on case insensitive SQL behavior later?", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r549529955", "createdAt": "2020-12-29T00:46:20Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,391 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.io.Closeable;\n+import java.sql.Connection;\n+import java.sql.DataTruncation;\n+import java.sql.DatabaseMetaData;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.sql.SQLWarning;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.exceptions.UncheckedSQLException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, SupportsNamespaces, Closeable {\n+\n+  public static final String SQL_TABLE_NAME = \"iceberg_tables\";\n+  public static final String SQL_TABLE_DDL =\n+          \"CREATE TABLE \" + SQL_TABLE_NAME +\n+                  \"(catalog_name VARCHAR(1255) NOT NULL,\" +\n+                  \"table_namespace VARCHAR(1255) NOT NULL,\" +\n+                  \"table_name VARCHAR(1255) NOT NULL,\" +\n+                  \"metadata_location VARCHAR(32768),\" +\n+                  \"previous_metadata_location VARCHAR(32768),\" +\n+                  \"PRIMARY KEY (catalog_name, table_namespace, table_name)\" +\n+                  \")\";\n+  public static final String SQL_SELECT_TABLE = \"SELECT * FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+  public static final String SQL_SELECT_ALL = \"SELECT * FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace = ?\";\n+  public static final String SQL_UPDATE_TABLE_NAME = \"UPDATE \" + SQL_TABLE_NAME +\n+          \" SET table_namespace = ? , table_name = ? \" +\n+          \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+  public static final String SQL_DELETE_TABLE = \"DELETE FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+  public static final String SQL_SELECT_NAMESPACE = \"SELECT table_namespace FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace LIKE ? LIMIT 1\";\n+  public static final String SQL_SELECT_NAMESPACES = \"SELECT DISTINCT table_namespace FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace LIKE ?\";\n+  public static final String JDBC_PARAM_PREFIX = \"connection.parameter.\";\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcCatalog.class);\n+  private static final Joiner SLASH = Joiner.on(\"/\");\n+\n+  private FileIO fileIO;\n+  private String catalogName = \"jdbc\";\n+  private String warehouseLocation;\n+  private Configuration hadoopConf;\n+  private JdbcClientPool dbConnPool;\n+\n+  public JdbcCatalog() {\n+  }\n+\n+  @SuppressWarnings(\"checkstyle:HiddenField\")\n+  @Override\n+  public void initialize(String name, Map<String, String> properties) {\n+    Preconditions.checkArgument(!properties.getOrDefault(CatalogProperties.HIVE_URI, \"\").isEmpty(),\n+            \"No connection url provided for jdbc catalog!\");\n+    Preconditions.checkArgument(!properties.getOrDefault(CatalogProperties.WAREHOUSE_LOCATION, \"\").isEmpty(),\n+            \"Cannot initialize Jdbc Catalog because warehousePath must not be null!\");\n+\n+    this.warehouseLocation = properties.get(CatalogProperties.WAREHOUSE_LOCATION).replaceAll(\"/$\", \"\");\n+    this.catalogName = name == null ? \"jdbc\" : name;\n+    String fileIOImpl = properties.get(CatalogProperties.FILE_IO_IMPL);\n+    this.fileIO = fileIOImpl == null ?\n+            new HadoopFileIO(hadoopConf) :\n+            CatalogUtil.loadFileIO(fileIOImpl, properties, hadoopConf);\n+    initializeConnection(properties);\n+  }\n+\n+  private void initializeConnection(Map<String, String> properties) {\n+    try {\n+      LOG.debug(\"Connecting to Jdbc database {}\", properties.get(CatalogProperties.HIVE_URI));\n+      Properties dbProps = new Properties();\n+      for (Map.Entry<String, String> prop : properties.entrySet()) {\n+        if (prop.getKey().startsWith(JDBC_PARAM_PREFIX)) {\n+          dbProps.put(prop.getKey().substring(JDBC_PARAM_PREFIX.length()), prop.getValue());\n+        }\n+      }\n+      dbConnPool = new JdbcClientPool(properties.get(CatalogProperties.HIVE_URI), dbProps);\n+      initializeCatalogTables();\n+    } catch (SQLTimeoutException e) {\n+      throw new UncheckedSQLException(\"Database Connection timeout!\", e);\n+    } catch (SQLTransientConnectionException | SQLNonTransientConnectionException e) {\n+      throw new UncheckedSQLException(\"Database Connection failed!\", e);\n+    } catch (SQLWarning e) {\n+      throw new UncheckedSQLException(\"Database connection warning!\", e);\n+    } catch (SQLException | InterruptedException e) {\n+      throw new UncheckedSQLException(\"Failed to initialize Jdbc Catalog!\", e);\n+    }\n+  }\n+\n+  private void initializeCatalogTables() throws InterruptedException, SQLException {\n+    // need to check multiple times because some databases are using different naming standard. ex: H2db keeping\n+    // table names as uppercase\n+    boolean exists = false;\n+    DatabaseMetaData dbMeta = dbConnPool.run(Connection::getMetaData);\n+    ResultSet tables = dbMeta.getTables(null, null, SQL_TABLE_NAME, null);\n+    if (tables.next()) {\n+      exists = true;\n+    }\n+    tables.close();\n+    ResultSet tablesUpper = dbMeta.getTables(null, null, SQL_TABLE_NAME.toUpperCase(), null);\n+    if (tablesUpper.next()) {\n+      exists = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6f8c6e36d78a79c8a8561292c2fa07f7e7f480a"}, "originalPosition": 154}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5MzQzOTg2", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-559343986", "createdAt": "2020-12-29T00:48:35Z", "commit": {"oid": "e6f8c6e36d78a79c8a8561292c2fa07f7e7f480a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwMDo0ODozNVrOIMEqvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwMDo0ODozNVrOIMEqvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUzMDMwMg==", "bodyText": "This will result in toString called on the result of levels(), which is a String[]. That isn't correct. I think you want to pass SLASH.join(table.namespace().levels()) into this join instead.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r549530302", "createdAt": "2020-12-29T00:48:35Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,391 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.io.Closeable;\n+import java.sql.Connection;\n+import java.sql.DataTruncation;\n+import java.sql.DatabaseMetaData;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.sql.SQLWarning;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.exceptions.UncheckedSQLException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, SupportsNamespaces, Closeable {\n+\n+  public static final String SQL_TABLE_NAME = \"iceberg_tables\";\n+  public static final String SQL_TABLE_DDL =\n+          \"CREATE TABLE \" + SQL_TABLE_NAME +\n+                  \"(catalog_name VARCHAR(1255) NOT NULL,\" +\n+                  \"table_namespace VARCHAR(1255) NOT NULL,\" +\n+                  \"table_name VARCHAR(1255) NOT NULL,\" +\n+                  \"metadata_location VARCHAR(32768),\" +\n+                  \"previous_metadata_location VARCHAR(32768),\" +\n+                  \"PRIMARY KEY (catalog_name, table_namespace, table_name)\" +\n+                  \")\";\n+  public static final String SQL_SELECT_TABLE = \"SELECT * FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+  public static final String SQL_SELECT_ALL = \"SELECT * FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace = ?\";\n+  public static final String SQL_UPDATE_TABLE_NAME = \"UPDATE \" + SQL_TABLE_NAME +\n+          \" SET table_namespace = ? , table_name = ? \" +\n+          \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+  public static final String SQL_DELETE_TABLE = \"DELETE FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+  public static final String SQL_SELECT_NAMESPACE = \"SELECT table_namespace FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace LIKE ? LIMIT 1\";\n+  public static final String SQL_SELECT_NAMESPACES = \"SELECT DISTINCT table_namespace FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace LIKE ?\";\n+  public static final String JDBC_PARAM_PREFIX = \"connection.parameter.\";\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcCatalog.class);\n+  private static final Joiner SLASH = Joiner.on(\"/\");\n+\n+  private FileIO fileIO;\n+  private String catalogName = \"jdbc\";\n+  private String warehouseLocation;\n+  private Configuration hadoopConf;\n+  private JdbcClientPool dbConnPool;\n+\n+  public JdbcCatalog() {\n+  }\n+\n+  @SuppressWarnings(\"checkstyle:HiddenField\")\n+  @Override\n+  public void initialize(String name, Map<String, String> properties) {\n+    Preconditions.checkArgument(!properties.getOrDefault(CatalogProperties.HIVE_URI, \"\").isEmpty(),\n+            \"No connection url provided for jdbc catalog!\");\n+    Preconditions.checkArgument(!properties.getOrDefault(CatalogProperties.WAREHOUSE_LOCATION, \"\").isEmpty(),\n+            \"Cannot initialize Jdbc Catalog because warehousePath must not be null!\");\n+\n+    this.warehouseLocation = properties.get(CatalogProperties.WAREHOUSE_LOCATION).replaceAll(\"/$\", \"\");\n+    this.catalogName = name == null ? \"jdbc\" : name;\n+    String fileIOImpl = properties.get(CatalogProperties.FILE_IO_IMPL);\n+    this.fileIO = fileIOImpl == null ?\n+            new HadoopFileIO(hadoopConf) :\n+            CatalogUtil.loadFileIO(fileIOImpl, properties, hadoopConf);\n+    initializeConnection(properties);\n+  }\n+\n+  private void initializeConnection(Map<String, String> properties) {\n+    try {\n+      LOG.debug(\"Connecting to Jdbc database {}\", properties.get(CatalogProperties.HIVE_URI));\n+      Properties dbProps = new Properties();\n+      for (Map.Entry<String, String> prop : properties.entrySet()) {\n+        if (prop.getKey().startsWith(JDBC_PARAM_PREFIX)) {\n+          dbProps.put(prop.getKey().substring(JDBC_PARAM_PREFIX.length()), prop.getValue());\n+        }\n+      }\n+      dbConnPool = new JdbcClientPool(properties.get(CatalogProperties.HIVE_URI), dbProps);\n+      initializeCatalogTables();\n+    } catch (SQLTimeoutException e) {\n+      throw new UncheckedSQLException(\"Database Connection timeout!\", e);\n+    } catch (SQLTransientConnectionException | SQLNonTransientConnectionException e) {\n+      throw new UncheckedSQLException(\"Database Connection failed!\", e);\n+    } catch (SQLWarning e) {\n+      throw new UncheckedSQLException(\"Database connection warning!\", e);\n+    } catch (SQLException | InterruptedException e) {\n+      throw new UncheckedSQLException(\"Failed to initialize Jdbc Catalog!\", e);\n+    }\n+  }\n+\n+  private void initializeCatalogTables() throws InterruptedException, SQLException {\n+    // need to check multiple times because some databases are using different naming standard. ex: H2db keeping\n+    // table names as uppercase\n+    boolean exists = false;\n+    DatabaseMetaData dbMeta = dbConnPool.run(Connection::getMetaData);\n+    ResultSet tables = dbMeta.getTables(null, null, SQL_TABLE_NAME, null);\n+    if (tables.next()) {\n+      exists = true;\n+    }\n+    tables.close();\n+    ResultSet tablesUpper = dbMeta.getTables(null, null, SQL_TABLE_NAME.toUpperCase(), null);\n+    if (tablesUpper.next()) {\n+      exists = true;\n+    }\n+    tablesUpper.close();\n+    ResultSet tablesLower = dbMeta.getTables(null, null, SQL_TABLE_NAME.toLowerCase(), null);\n+    if (tablesLower.next()) {\n+      exists = true;\n+    }\n+    tablesLower.close();\n+\n+    // create table if not exits\n+    if (!exists) {\n+      dbConnPool.run(conn -> conn.prepareStatement(SQL_TABLE_DDL).execute());\n+      LOG.debug(\"Created table {} to store iceberg tables!\", SQL_TABLE_NAME);\n+    }\n+  }\n+\n+  @Override\n+  protected TableOperations newTableOps(TableIdentifier tableIdentifier) {\n+    return new JdbcTableOperations(dbConnPool, fileIO, catalogName, tableIdentifier);\n+  }\n+\n+  @Override\n+  protected String defaultWarehouseLocation(TableIdentifier table) {\n+    if (table.hasNamespace()) {\n+      return SLASH.join(warehouseLocation, table.namespace().levels(), table.name());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6f8c6e36d78a79c8a8561292c2fa07f7e7f480a"}, "originalPosition": 178}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5MzQ0MjMz", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-559344233", "createdAt": "2020-12-29T00:50:23Z", "commit": {"oid": "e6f8c6e36d78a79c8a8561292c2fa07f7e7f480a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwMDo1MDoyM1rOIMEr2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwMDo1MDoyM1rOIMEr2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUzMDU4Ng==", "bodyText": "Style: please add newlines after control flow blocks like if, for, etc.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r549530586", "createdAt": "2020-12-29T00:50:23Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,391 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.io.Closeable;\n+import java.sql.Connection;\n+import java.sql.DataTruncation;\n+import java.sql.DatabaseMetaData;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.sql.SQLWarning;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.exceptions.UncheckedSQLException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, SupportsNamespaces, Closeable {\n+\n+  public static final String SQL_TABLE_NAME = \"iceberg_tables\";\n+  public static final String SQL_TABLE_DDL =\n+          \"CREATE TABLE \" + SQL_TABLE_NAME +\n+                  \"(catalog_name VARCHAR(1255) NOT NULL,\" +\n+                  \"table_namespace VARCHAR(1255) NOT NULL,\" +\n+                  \"table_name VARCHAR(1255) NOT NULL,\" +\n+                  \"metadata_location VARCHAR(32768),\" +\n+                  \"previous_metadata_location VARCHAR(32768),\" +\n+                  \"PRIMARY KEY (catalog_name, table_namespace, table_name)\" +\n+                  \")\";\n+  public static final String SQL_SELECT_TABLE = \"SELECT * FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+  public static final String SQL_SELECT_ALL = \"SELECT * FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace = ?\";\n+  public static final String SQL_UPDATE_TABLE_NAME = \"UPDATE \" + SQL_TABLE_NAME +\n+          \" SET table_namespace = ? , table_name = ? \" +\n+          \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+  public static final String SQL_DELETE_TABLE = \"DELETE FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+  public static final String SQL_SELECT_NAMESPACE = \"SELECT table_namespace FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace LIKE ? LIMIT 1\";\n+  public static final String SQL_SELECT_NAMESPACES = \"SELECT DISTINCT table_namespace FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace LIKE ?\";\n+  public static final String JDBC_PARAM_PREFIX = \"connection.parameter.\";\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcCatalog.class);\n+  private static final Joiner SLASH = Joiner.on(\"/\");\n+\n+  private FileIO fileIO;\n+  private String catalogName = \"jdbc\";\n+  private String warehouseLocation;\n+  private Configuration hadoopConf;\n+  private JdbcClientPool dbConnPool;\n+\n+  public JdbcCatalog() {\n+  }\n+\n+  @SuppressWarnings(\"checkstyle:HiddenField\")\n+  @Override\n+  public void initialize(String name, Map<String, String> properties) {\n+    Preconditions.checkArgument(!properties.getOrDefault(CatalogProperties.HIVE_URI, \"\").isEmpty(),\n+            \"No connection url provided for jdbc catalog!\");\n+    Preconditions.checkArgument(!properties.getOrDefault(CatalogProperties.WAREHOUSE_LOCATION, \"\").isEmpty(),\n+            \"Cannot initialize Jdbc Catalog because warehousePath must not be null!\");\n+\n+    this.warehouseLocation = properties.get(CatalogProperties.WAREHOUSE_LOCATION).replaceAll(\"/$\", \"\");\n+    this.catalogName = name == null ? \"jdbc\" : name;\n+    String fileIOImpl = properties.get(CatalogProperties.FILE_IO_IMPL);\n+    this.fileIO = fileIOImpl == null ?\n+            new HadoopFileIO(hadoopConf) :\n+            CatalogUtil.loadFileIO(fileIOImpl, properties, hadoopConf);\n+    initializeConnection(properties);\n+  }\n+\n+  private void initializeConnection(Map<String, String> properties) {\n+    try {\n+      LOG.debug(\"Connecting to Jdbc database {}\", properties.get(CatalogProperties.HIVE_URI));\n+      Properties dbProps = new Properties();\n+      for (Map.Entry<String, String> prop : properties.entrySet()) {\n+        if (prop.getKey().startsWith(JDBC_PARAM_PREFIX)) {\n+          dbProps.put(prop.getKey().substring(JDBC_PARAM_PREFIX.length()), prop.getValue());\n+        }\n+      }\n+      dbConnPool = new JdbcClientPool(properties.get(CatalogProperties.HIVE_URI), dbProps);\n+      initializeCatalogTables();\n+    } catch (SQLTimeoutException e) {\n+      throw new UncheckedSQLException(\"Database Connection timeout!\", e);\n+    } catch (SQLTransientConnectionException | SQLNonTransientConnectionException e) {\n+      throw new UncheckedSQLException(\"Database Connection failed!\", e);\n+    } catch (SQLWarning e) {\n+      throw new UncheckedSQLException(\"Database connection warning!\", e);\n+    } catch (SQLException | InterruptedException e) {\n+      throw new UncheckedSQLException(\"Failed to initialize Jdbc Catalog!\", e);\n+    }\n+  }\n+\n+  private void initializeCatalogTables() throws InterruptedException, SQLException {\n+    // need to check multiple times because some databases are using different naming standard. ex: H2db keeping\n+    // table names as uppercase\n+    boolean exists = false;\n+    DatabaseMetaData dbMeta = dbConnPool.run(Connection::getMetaData);\n+    ResultSet tables = dbMeta.getTables(null, null, SQL_TABLE_NAME, null);\n+    if (tables.next()) {\n+      exists = true;\n+    }\n+    tables.close();\n+    ResultSet tablesUpper = dbMeta.getTables(null, null, SQL_TABLE_NAME.toUpperCase(), null);\n+    if (tablesUpper.next()) {\n+      exists = true;\n+    }\n+    tablesUpper.close();\n+    ResultSet tablesLower = dbMeta.getTables(null, null, SQL_TABLE_NAME.toLowerCase(), null);\n+    if (tablesLower.next()) {\n+      exists = true;\n+    }\n+    tablesLower.close();\n+\n+    // create table if not exits\n+    if (!exists) {\n+      dbConnPool.run(conn -> conn.prepareStatement(SQL_TABLE_DDL).execute());\n+      LOG.debug(\"Created table {} to store iceberg tables!\", SQL_TABLE_NAME);\n+    }\n+  }\n+\n+  @Override\n+  protected TableOperations newTableOps(TableIdentifier tableIdentifier) {\n+    return new JdbcTableOperations(dbConnPool, fileIO, catalogName, tableIdentifier);\n+  }\n+\n+  @Override\n+  protected String defaultWarehouseLocation(TableIdentifier table) {\n+    if (table.hasNamespace()) {\n+      return SLASH.join(warehouseLocation, table.namespace().levels(), table.name());\n+    }\n+    return SLASH.join(warehouseLocation, table.name());\n+  }\n+\n+  @Override\n+  public boolean dropTable(TableIdentifier identifier, boolean purge) {\n+    TableOperations ops = newTableOps(identifier);\n+    TableMetadata lastMetadata = ops.current();\n+    try {\n+      PreparedStatement sql = dbConnPool.run(c -> c.prepareStatement(SQL_DELETE_TABLE));\n+      sql.setString(1, catalogName);\n+      sql.setString(2, JdbcUtil.namespaceToString(identifier.namespace()));\n+      sql.setString(3, identifier.name());\n+      int deletedRecords = sql.executeUpdate();\n+\n+      if (deletedRecords > 0) {\n+        LOG.debug(\"Successfully dropped table {}.\", identifier);\n+      } else {\n+        throw new NoSuchTableException(\"Cannot drop table %s! table not found in the catalog.\", identifier);\n+      }\n+\n+      if (purge && lastMetadata != null) {\n+        CatalogUtil.dropTableData(ops.io(), lastMetadata);\n+        LOG.info(\"Table {} data purged!\", identifier);\n+      }\n+      return true;\n+    } catch (SQLException | InterruptedException e) {\n+      throw new UncheckedSQLException(\"Failed to drop table!\", e);\n+    }\n+  }\n+\n+  @Override\n+  public List<TableIdentifier> listTables(Namespace namespace) {\n+    if (!this.namespaceExists(namespace)) {\n+      throw new NoSuchNamespaceException(\"Namespace %s does not exist!\", namespace);\n+    }\n+    try {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6f8c6e36d78a79c8a8561292c2fa07f7e7f480a"}, "originalPosition": 215}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5MzQ0Mjk5", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-559344299", "createdAt": "2020-12-29T00:50:59Z", "commit": {"oid": "e6f8c6e36d78a79c8a8561292c2fa07f7e7f480a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwMDo1MDo1OVrOIMEsFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwMDo1MDo1OVrOIMEsFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUzMDY0NA==", "bodyText": "Could this use try-with-resources instead of calling close later?", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r549530644", "createdAt": "2020-12-29T00:50:59Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,391 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.io.Closeable;\n+import java.sql.Connection;\n+import java.sql.DataTruncation;\n+import java.sql.DatabaseMetaData;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.sql.SQLWarning;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.exceptions.UncheckedSQLException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, SupportsNamespaces, Closeable {\n+\n+  public static final String SQL_TABLE_NAME = \"iceberg_tables\";\n+  public static final String SQL_TABLE_DDL =\n+          \"CREATE TABLE \" + SQL_TABLE_NAME +\n+                  \"(catalog_name VARCHAR(1255) NOT NULL,\" +\n+                  \"table_namespace VARCHAR(1255) NOT NULL,\" +\n+                  \"table_name VARCHAR(1255) NOT NULL,\" +\n+                  \"metadata_location VARCHAR(32768),\" +\n+                  \"previous_metadata_location VARCHAR(32768),\" +\n+                  \"PRIMARY KEY (catalog_name, table_namespace, table_name)\" +\n+                  \")\";\n+  public static final String SQL_SELECT_TABLE = \"SELECT * FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+  public static final String SQL_SELECT_ALL = \"SELECT * FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace = ?\";\n+  public static final String SQL_UPDATE_TABLE_NAME = \"UPDATE \" + SQL_TABLE_NAME +\n+          \" SET table_namespace = ? , table_name = ? \" +\n+          \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+  public static final String SQL_DELETE_TABLE = \"DELETE FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+  public static final String SQL_SELECT_NAMESPACE = \"SELECT table_namespace FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace LIKE ? LIMIT 1\";\n+  public static final String SQL_SELECT_NAMESPACES = \"SELECT DISTINCT table_namespace FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace LIKE ?\";\n+  public static final String JDBC_PARAM_PREFIX = \"connection.parameter.\";\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcCatalog.class);\n+  private static final Joiner SLASH = Joiner.on(\"/\");\n+\n+  private FileIO fileIO;\n+  private String catalogName = \"jdbc\";\n+  private String warehouseLocation;\n+  private Configuration hadoopConf;\n+  private JdbcClientPool dbConnPool;\n+\n+  public JdbcCatalog() {\n+  }\n+\n+  @SuppressWarnings(\"checkstyle:HiddenField\")\n+  @Override\n+  public void initialize(String name, Map<String, String> properties) {\n+    Preconditions.checkArgument(!properties.getOrDefault(CatalogProperties.HIVE_URI, \"\").isEmpty(),\n+            \"No connection url provided for jdbc catalog!\");\n+    Preconditions.checkArgument(!properties.getOrDefault(CatalogProperties.WAREHOUSE_LOCATION, \"\").isEmpty(),\n+            \"Cannot initialize Jdbc Catalog because warehousePath must not be null!\");\n+\n+    this.warehouseLocation = properties.get(CatalogProperties.WAREHOUSE_LOCATION).replaceAll(\"/$\", \"\");\n+    this.catalogName = name == null ? \"jdbc\" : name;\n+    String fileIOImpl = properties.get(CatalogProperties.FILE_IO_IMPL);\n+    this.fileIO = fileIOImpl == null ?\n+            new HadoopFileIO(hadoopConf) :\n+            CatalogUtil.loadFileIO(fileIOImpl, properties, hadoopConf);\n+    initializeConnection(properties);\n+  }\n+\n+  private void initializeConnection(Map<String, String> properties) {\n+    try {\n+      LOG.debug(\"Connecting to Jdbc database {}\", properties.get(CatalogProperties.HIVE_URI));\n+      Properties dbProps = new Properties();\n+      for (Map.Entry<String, String> prop : properties.entrySet()) {\n+        if (prop.getKey().startsWith(JDBC_PARAM_PREFIX)) {\n+          dbProps.put(prop.getKey().substring(JDBC_PARAM_PREFIX.length()), prop.getValue());\n+        }\n+      }\n+      dbConnPool = new JdbcClientPool(properties.get(CatalogProperties.HIVE_URI), dbProps);\n+      initializeCatalogTables();\n+    } catch (SQLTimeoutException e) {\n+      throw new UncheckedSQLException(\"Database Connection timeout!\", e);\n+    } catch (SQLTransientConnectionException | SQLNonTransientConnectionException e) {\n+      throw new UncheckedSQLException(\"Database Connection failed!\", e);\n+    } catch (SQLWarning e) {\n+      throw new UncheckedSQLException(\"Database connection warning!\", e);\n+    } catch (SQLException | InterruptedException e) {\n+      throw new UncheckedSQLException(\"Failed to initialize Jdbc Catalog!\", e);\n+    }\n+  }\n+\n+  private void initializeCatalogTables() throws InterruptedException, SQLException {\n+    // need to check multiple times because some databases are using different naming standard. ex: H2db keeping\n+    // table names as uppercase\n+    boolean exists = false;\n+    DatabaseMetaData dbMeta = dbConnPool.run(Connection::getMetaData);\n+    ResultSet tables = dbMeta.getTables(null, null, SQL_TABLE_NAME, null);\n+    if (tables.next()) {\n+      exists = true;\n+    }\n+    tables.close();\n+    ResultSet tablesUpper = dbMeta.getTables(null, null, SQL_TABLE_NAME.toUpperCase(), null);\n+    if (tablesUpper.next()) {\n+      exists = true;\n+    }\n+    tablesUpper.close();\n+    ResultSet tablesLower = dbMeta.getTables(null, null, SQL_TABLE_NAME.toLowerCase(), null);\n+    if (tablesLower.next()) {\n+      exists = true;\n+    }\n+    tablesLower.close();\n+\n+    // create table if not exits\n+    if (!exists) {\n+      dbConnPool.run(conn -> conn.prepareStatement(SQL_TABLE_DDL).execute());\n+      LOG.debug(\"Created table {} to store iceberg tables!\", SQL_TABLE_NAME);\n+    }\n+  }\n+\n+  @Override\n+  protected TableOperations newTableOps(TableIdentifier tableIdentifier) {\n+    return new JdbcTableOperations(dbConnPool, fileIO, catalogName, tableIdentifier);\n+  }\n+\n+  @Override\n+  protected String defaultWarehouseLocation(TableIdentifier table) {\n+    if (table.hasNamespace()) {\n+      return SLASH.join(warehouseLocation, table.namespace().levels(), table.name());\n+    }\n+    return SLASH.join(warehouseLocation, table.name());\n+  }\n+\n+  @Override\n+  public boolean dropTable(TableIdentifier identifier, boolean purge) {\n+    TableOperations ops = newTableOps(identifier);\n+    TableMetadata lastMetadata = ops.current();\n+    try {\n+      PreparedStatement sql = dbConnPool.run(c -> c.prepareStatement(SQL_DELETE_TABLE));\n+      sql.setString(1, catalogName);\n+      sql.setString(2, JdbcUtil.namespaceToString(identifier.namespace()));\n+      sql.setString(3, identifier.name());\n+      int deletedRecords = sql.executeUpdate();\n+\n+      if (deletedRecords > 0) {\n+        LOG.debug(\"Successfully dropped table {}.\", identifier);\n+      } else {\n+        throw new NoSuchTableException(\"Cannot drop table %s! table not found in the catalog.\", identifier);\n+      }\n+\n+      if (purge && lastMetadata != null) {\n+        CatalogUtil.dropTableData(ops.io(), lastMetadata);\n+        LOG.info(\"Table {} data purged!\", identifier);\n+      }\n+      return true;\n+    } catch (SQLException | InterruptedException e) {\n+      throw new UncheckedSQLException(\"Failed to drop table!\", e);\n+    }\n+  }\n+\n+  @Override\n+  public List<TableIdentifier> listTables(Namespace namespace) {\n+    if (!this.namespaceExists(namespace)) {\n+      throw new NoSuchNamespaceException(\"Namespace %s does not exist!\", namespace);\n+    }\n+    try {\n+      List<TableIdentifier> results = Lists.newArrayList();\n+      PreparedStatement sql = dbConnPool.run(c -> c.prepareStatement(SQL_SELECT_ALL));\n+      sql.setString(1, catalogName);\n+      sql.setString(2, JdbcUtil.namespaceToString(namespace));\n+      ResultSet rs = sql.executeQuery();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6f8c6e36d78a79c8a8561292c2fa07f7e7f480a"}, "originalPosition": 220}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5MzQ0NjYz", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-559344663", "createdAt": "2020-12-29T00:53:31Z", "commit": {"oid": "e6f8c6e36d78a79c8a8561292c2fa07f7e7f480a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwMDo1MzozMVrOIMEtig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwMDo1MzozMVrOIMEtig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUzMTAxOA==", "bodyText": "This is not a correct return. If SQLException was thrown, then this should throw UncheckedSQLException with context about the operation, like Cannot list tables in namespace: %s.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r549531018", "createdAt": "2020-12-29T00:53:31Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,391 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.io.Closeable;\n+import java.sql.Connection;\n+import java.sql.DataTruncation;\n+import java.sql.DatabaseMetaData;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.sql.SQLWarning;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.exceptions.UncheckedSQLException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, SupportsNamespaces, Closeable {\n+\n+  public static final String SQL_TABLE_NAME = \"iceberg_tables\";\n+  public static final String SQL_TABLE_DDL =\n+          \"CREATE TABLE \" + SQL_TABLE_NAME +\n+                  \"(catalog_name VARCHAR(1255) NOT NULL,\" +\n+                  \"table_namespace VARCHAR(1255) NOT NULL,\" +\n+                  \"table_name VARCHAR(1255) NOT NULL,\" +\n+                  \"metadata_location VARCHAR(32768),\" +\n+                  \"previous_metadata_location VARCHAR(32768),\" +\n+                  \"PRIMARY KEY (catalog_name, table_namespace, table_name)\" +\n+                  \")\";\n+  public static final String SQL_SELECT_TABLE = \"SELECT * FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+  public static final String SQL_SELECT_ALL = \"SELECT * FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace = ?\";\n+  public static final String SQL_UPDATE_TABLE_NAME = \"UPDATE \" + SQL_TABLE_NAME +\n+          \" SET table_namespace = ? , table_name = ? \" +\n+          \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+  public static final String SQL_DELETE_TABLE = \"DELETE FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+  public static final String SQL_SELECT_NAMESPACE = \"SELECT table_namespace FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace LIKE ? LIMIT 1\";\n+  public static final String SQL_SELECT_NAMESPACES = \"SELECT DISTINCT table_namespace FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace LIKE ?\";\n+  public static final String JDBC_PARAM_PREFIX = \"connection.parameter.\";\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcCatalog.class);\n+  private static final Joiner SLASH = Joiner.on(\"/\");\n+\n+  private FileIO fileIO;\n+  private String catalogName = \"jdbc\";\n+  private String warehouseLocation;\n+  private Configuration hadoopConf;\n+  private JdbcClientPool dbConnPool;\n+\n+  public JdbcCatalog() {\n+  }\n+\n+  @SuppressWarnings(\"checkstyle:HiddenField\")\n+  @Override\n+  public void initialize(String name, Map<String, String> properties) {\n+    Preconditions.checkArgument(!properties.getOrDefault(CatalogProperties.HIVE_URI, \"\").isEmpty(),\n+            \"No connection url provided for jdbc catalog!\");\n+    Preconditions.checkArgument(!properties.getOrDefault(CatalogProperties.WAREHOUSE_LOCATION, \"\").isEmpty(),\n+            \"Cannot initialize Jdbc Catalog because warehousePath must not be null!\");\n+\n+    this.warehouseLocation = properties.get(CatalogProperties.WAREHOUSE_LOCATION).replaceAll(\"/$\", \"\");\n+    this.catalogName = name == null ? \"jdbc\" : name;\n+    String fileIOImpl = properties.get(CatalogProperties.FILE_IO_IMPL);\n+    this.fileIO = fileIOImpl == null ?\n+            new HadoopFileIO(hadoopConf) :\n+            CatalogUtil.loadFileIO(fileIOImpl, properties, hadoopConf);\n+    initializeConnection(properties);\n+  }\n+\n+  private void initializeConnection(Map<String, String> properties) {\n+    try {\n+      LOG.debug(\"Connecting to Jdbc database {}\", properties.get(CatalogProperties.HIVE_URI));\n+      Properties dbProps = new Properties();\n+      for (Map.Entry<String, String> prop : properties.entrySet()) {\n+        if (prop.getKey().startsWith(JDBC_PARAM_PREFIX)) {\n+          dbProps.put(prop.getKey().substring(JDBC_PARAM_PREFIX.length()), prop.getValue());\n+        }\n+      }\n+      dbConnPool = new JdbcClientPool(properties.get(CatalogProperties.HIVE_URI), dbProps);\n+      initializeCatalogTables();\n+    } catch (SQLTimeoutException e) {\n+      throw new UncheckedSQLException(\"Database Connection timeout!\", e);\n+    } catch (SQLTransientConnectionException | SQLNonTransientConnectionException e) {\n+      throw new UncheckedSQLException(\"Database Connection failed!\", e);\n+    } catch (SQLWarning e) {\n+      throw new UncheckedSQLException(\"Database connection warning!\", e);\n+    } catch (SQLException | InterruptedException e) {\n+      throw new UncheckedSQLException(\"Failed to initialize Jdbc Catalog!\", e);\n+    }\n+  }\n+\n+  private void initializeCatalogTables() throws InterruptedException, SQLException {\n+    // need to check multiple times because some databases are using different naming standard. ex: H2db keeping\n+    // table names as uppercase\n+    boolean exists = false;\n+    DatabaseMetaData dbMeta = dbConnPool.run(Connection::getMetaData);\n+    ResultSet tables = dbMeta.getTables(null, null, SQL_TABLE_NAME, null);\n+    if (tables.next()) {\n+      exists = true;\n+    }\n+    tables.close();\n+    ResultSet tablesUpper = dbMeta.getTables(null, null, SQL_TABLE_NAME.toUpperCase(), null);\n+    if (tablesUpper.next()) {\n+      exists = true;\n+    }\n+    tablesUpper.close();\n+    ResultSet tablesLower = dbMeta.getTables(null, null, SQL_TABLE_NAME.toLowerCase(), null);\n+    if (tablesLower.next()) {\n+      exists = true;\n+    }\n+    tablesLower.close();\n+\n+    // create table if not exits\n+    if (!exists) {\n+      dbConnPool.run(conn -> conn.prepareStatement(SQL_TABLE_DDL).execute());\n+      LOG.debug(\"Created table {} to store iceberg tables!\", SQL_TABLE_NAME);\n+    }\n+  }\n+\n+  @Override\n+  protected TableOperations newTableOps(TableIdentifier tableIdentifier) {\n+    return new JdbcTableOperations(dbConnPool, fileIO, catalogName, tableIdentifier);\n+  }\n+\n+  @Override\n+  protected String defaultWarehouseLocation(TableIdentifier table) {\n+    if (table.hasNamespace()) {\n+      return SLASH.join(warehouseLocation, table.namespace().levels(), table.name());\n+    }\n+    return SLASH.join(warehouseLocation, table.name());\n+  }\n+\n+  @Override\n+  public boolean dropTable(TableIdentifier identifier, boolean purge) {\n+    TableOperations ops = newTableOps(identifier);\n+    TableMetadata lastMetadata = ops.current();\n+    try {\n+      PreparedStatement sql = dbConnPool.run(c -> c.prepareStatement(SQL_DELETE_TABLE));\n+      sql.setString(1, catalogName);\n+      sql.setString(2, JdbcUtil.namespaceToString(identifier.namespace()));\n+      sql.setString(3, identifier.name());\n+      int deletedRecords = sql.executeUpdate();\n+\n+      if (deletedRecords > 0) {\n+        LOG.debug(\"Successfully dropped table {}.\", identifier);\n+      } else {\n+        throw new NoSuchTableException(\"Cannot drop table %s! table not found in the catalog.\", identifier);\n+      }\n+\n+      if (purge && lastMetadata != null) {\n+        CatalogUtil.dropTableData(ops.io(), lastMetadata);\n+        LOG.info(\"Table {} data purged!\", identifier);\n+      }\n+      return true;\n+    } catch (SQLException | InterruptedException e) {\n+      throw new UncheckedSQLException(\"Failed to drop table!\", e);\n+    }\n+  }\n+\n+  @Override\n+  public List<TableIdentifier> listTables(Namespace namespace) {\n+    if (!this.namespaceExists(namespace)) {\n+      throw new NoSuchNamespaceException(\"Namespace %s does not exist!\", namespace);\n+    }\n+    try {\n+      List<TableIdentifier> results = Lists.newArrayList();\n+      PreparedStatement sql = dbConnPool.run(c -> c.prepareStatement(SQL_SELECT_ALL));\n+      sql.setString(1, catalogName);\n+      sql.setString(2, JdbcUtil.namespaceToString(namespace));\n+      ResultSet rs = sql.executeQuery();\n+\n+      while (rs.next()) {\n+        final TableIdentifier table = JdbcUtil.stringToTableIdentifier(\n+                rs.getString(\"table_namespace\"), rs.getString(\"table_name\"));\n+        results.add(table);\n+      }\n+      rs.close();\n+      return results;\n+\n+    } catch (SQLException | InterruptedException e) {\n+      LOG.error(\"Failed to list tables!\", e);\n+      return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6f8c6e36d78a79c8a8561292c2fa07f7e7f480a"}, "originalPosition": 232}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5MzQ3NDUz", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-559347453", "createdAt": "2020-12-29T01:14:20Z", "commit": {"oid": "e6f8c6e36d78a79c8a8561292c2fa07f7e7f480a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwMToxNDoyMFrOIME6SA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwMToxNDoyMFrOIME6SA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUzNDI4MA==", "bodyText": "I think that the result set and prepared statement are tied to the connection that was used to create the statement. That means that as long as this method is using either the statement or the result set, the connection should not be reused by another thread.\nTo hold the connection, the whole query will need to go in the run block. Here's my version of this method with that change:\n  @Override\n  public List<TableIdentifier> listTables(Namespace namespace) {\n    if (!this.namespaceExists(namespace)) {\n      throw new NoSuchNamespaceException(\"Namespace %s does not exist!\", namespace);\n    }\n\n    try {\n      return dbConnPool.run(conn -> {\n        List<TableIdentifier> results = Lists.newArrayList();\n        try (PreparedStatement sql = conn.prepareStatement(SQL_SELECT_ALL)) {\n          sql.setString(1, catalogName);\n          sql.setString(2, JdbcUtil.namespaceToString(namespace));\n\n          ResultSet rs = sql.executeQuery();\n          while (rs.next()) {\n            results.add(JdbcUtil.stringToTableIdentifier(rs.getString(\"table_namespace\"), rs.getString(\"table_name\")));\n          }\n\n          return results;\n        }\n      });\n\n    } catch (SQLException e) {\n      throw new UncheckedSQLException(String.format(\"Failed to list tables in namespace: %s\", namespace), e);\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      throw new RuntimeException(\"Interrupted during JDBC operation\", e);\n    }\n  }\nI've also separated out the InterruptedException and handled it just like in HiveCatalog. I think that should be done in all cases here as well.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r549534280", "createdAt": "2020-12-29T01:14:20Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,391 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.io.Closeable;\n+import java.sql.Connection;\n+import java.sql.DataTruncation;\n+import java.sql.DatabaseMetaData;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.sql.SQLWarning;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.exceptions.UncheckedSQLException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, SupportsNamespaces, Closeable {\n+\n+  public static final String SQL_TABLE_NAME = \"iceberg_tables\";\n+  public static final String SQL_TABLE_DDL =\n+          \"CREATE TABLE \" + SQL_TABLE_NAME +\n+                  \"(catalog_name VARCHAR(1255) NOT NULL,\" +\n+                  \"table_namespace VARCHAR(1255) NOT NULL,\" +\n+                  \"table_name VARCHAR(1255) NOT NULL,\" +\n+                  \"metadata_location VARCHAR(32768),\" +\n+                  \"previous_metadata_location VARCHAR(32768),\" +\n+                  \"PRIMARY KEY (catalog_name, table_namespace, table_name)\" +\n+                  \")\";\n+  public static final String SQL_SELECT_TABLE = \"SELECT * FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+  public static final String SQL_SELECT_ALL = \"SELECT * FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace = ?\";\n+  public static final String SQL_UPDATE_TABLE_NAME = \"UPDATE \" + SQL_TABLE_NAME +\n+          \" SET table_namespace = ? , table_name = ? \" +\n+          \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+  public static final String SQL_DELETE_TABLE = \"DELETE FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+  public static final String SQL_SELECT_NAMESPACE = \"SELECT table_namespace FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace LIKE ? LIMIT 1\";\n+  public static final String SQL_SELECT_NAMESPACES = \"SELECT DISTINCT table_namespace FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace LIKE ?\";\n+  public static final String JDBC_PARAM_PREFIX = \"connection.parameter.\";\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcCatalog.class);\n+  private static final Joiner SLASH = Joiner.on(\"/\");\n+\n+  private FileIO fileIO;\n+  private String catalogName = \"jdbc\";\n+  private String warehouseLocation;\n+  private Configuration hadoopConf;\n+  private JdbcClientPool dbConnPool;\n+\n+  public JdbcCatalog() {\n+  }\n+\n+  @SuppressWarnings(\"checkstyle:HiddenField\")\n+  @Override\n+  public void initialize(String name, Map<String, String> properties) {\n+    Preconditions.checkArgument(!properties.getOrDefault(CatalogProperties.HIVE_URI, \"\").isEmpty(),\n+            \"No connection url provided for jdbc catalog!\");\n+    Preconditions.checkArgument(!properties.getOrDefault(CatalogProperties.WAREHOUSE_LOCATION, \"\").isEmpty(),\n+            \"Cannot initialize Jdbc Catalog because warehousePath must not be null!\");\n+\n+    this.warehouseLocation = properties.get(CatalogProperties.WAREHOUSE_LOCATION).replaceAll(\"/$\", \"\");\n+    this.catalogName = name == null ? \"jdbc\" : name;\n+    String fileIOImpl = properties.get(CatalogProperties.FILE_IO_IMPL);\n+    this.fileIO = fileIOImpl == null ?\n+            new HadoopFileIO(hadoopConf) :\n+            CatalogUtil.loadFileIO(fileIOImpl, properties, hadoopConf);\n+    initializeConnection(properties);\n+  }\n+\n+  private void initializeConnection(Map<String, String> properties) {\n+    try {\n+      LOG.debug(\"Connecting to Jdbc database {}\", properties.get(CatalogProperties.HIVE_URI));\n+      Properties dbProps = new Properties();\n+      for (Map.Entry<String, String> prop : properties.entrySet()) {\n+        if (prop.getKey().startsWith(JDBC_PARAM_PREFIX)) {\n+          dbProps.put(prop.getKey().substring(JDBC_PARAM_PREFIX.length()), prop.getValue());\n+        }\n+      }\n+      dbConnPool = new JdbcClientPool(properties.get(CatalogProperties.HIVE_URI), dbProps);\n+      initializeCatalogTables();\n+    } catch (SQLTimeoutException e) {\n+      throw new UncheckedSQLException(\"Database Connection timeout!\", e);\n+    } catch (SQLTransientConnectionException | SQLNonTransientConnectionException e) {\n+      throw new UncheckedSQLException(\"Database Connection failed!\", e);\n+    } catch (SQLWarning e) {\n+      throw new UncheckedSQLException(\"Database connection warning!\", e);\n+    } catch (SQLException | InterruptedException e) {\n+      throw new UncheckedSQLException(\"Failed to initialize Jdbc Catalog!\", e);\n+    }\n+  }\n+\n+  private void initializeCatalogTables() throws InterruptedException, SQLException {\n+    // need to check multiple times because some databases are using different naming standard. ex: H2db keeping\n+    // table names as uppercase\n+    boolean exists = false;\n+    DatabaseMetaData dbMeta = dbConnPool.run(Connection::getMetaData);\n+    ResultSet tables = dbMeta.getTables(null, null, SQL_TABLE_NAME, null);\n+    if (tables.next()) {\n+      exists = true;\n+    }\n+    tables.close();\n+    ResultSet tablesUpper = dbMeta.getTables(null, null, SQL_TABLE_NAME.toUpperCase(), null);\n+    if (tablesUpper.next()) {\n+      exists = true;\n+    }\n+    tablesUpper.close();\n+    ResultSet tablesLower = dbMeta.getTables(null, null, SQL_TABLE_NAME.toLowerCase(), null);\n+    if (tablesLower.next()) {\n+      exists = true;\n+    }\n+    tablesLower.close();\n+\n+    // create table if not exits\n+    if (!exists) {\n+      dbConnPool.run(conn -> conn.prepareStatement(SQL_TABLE_DDL).execute());\n+      LOG.debug(\"Created table {} to store iceberg tables!\", SQL_TABLE_NAME);\n+    }\n+  }\n+\n+  @Override\n+  protected TableOperations newTableOps(TableIdentifier tableIdentifier) {\n+    return new JdbcTableOperations(dbConnPool, fileIO, catalogName, tableIdentifier);\n+  }\n+\n+  @Override\n+  protected String defaultWarehouseLocation(TableIdentifier table) {\n+    if (table.hasNamespace()) {\n+      return SLASH.join(warehouseLocation, table.namespace().levels(), table.name());\n+    }\n+    return SLASH.join(warehouseLocation, table.name());\n+  }\n+\n+  @Override\n+  public boolean dropTable(TableIdentifier identifier, boolean purge) {\n+    TableOperations ops = newTableOps(identifier);\n+    TableMetadata lastMetadata = ops.current();\n+    try {\n+      PreparedStatement sql = dbConnPool.run(c -> c.prepareStatement(SQL_DELETE_TABLE));\n+      sql.setString(1, catalogName);\n+      sql.setString(2, JdbcUtil.namespaceToString(identifier.namespace()));\n+      sql.setString(3, identifier.name());\n+      int deletedRecords = sql.executeUpdate();\n+\n+      if (deletedRecords > 0) {\n+        LOG.debug(\"Successfully dropped table {}.\", identifier);\n+      } else {\n+        throw new NoSuchTableException(\"Cannot drop table %s! table not found in the catalog.\", identifier);\n+      }\n+\n+      if (purge && lastMetadata != null) {\n+        CatalogUtil.dropTableData(ops.io(), lastMetadata);\n+        LOG.info(\"Table {} data purged!\", identifier);\n+      }\n+      return true;\n+    } catch (SQLException | InterruptedException e) {\n+      throw new UncheckedSQLException(\"Failed to drop table!\", e);\n+    }\n+  }\n+\n+  @Override\n+  public List<TableIdentifier> listTables(Namespace namespace) {\n+    if (!this.namespaceExists(namespace)) {\n+      throw new NoSuchNamespaceException(\"Namespace %s does not exist!\", namespace);\n+    }\n+    try {\n+      List<TableIdentifier> results = Lists.newArrayList();\n+      PreparedStatement sql = dbConnPool.run(c -> c.prepareStatement(SQL_SELECT_ALL));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6f8c6e36d78a79c8a8561292c2fa07f7e7f480a"}, "originalPosition": 217}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5MzQ3ODQ0", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-559347844", "createdAt": "2020-12-29T01:17:06Z", "commit": {"oid": "e6f8c6e36d78a79c8a8561292c2fa07f7e7f480a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwMToxNzowN1rOIME8OA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwMToxNzowN1rOIME8OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUzNDc3Ng==", "bodyText": "This case should return false, not throw an exception. That's the contract of the method specified in Javadoc.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r549534776", "createdAt": "2020-12-29T01:17:07Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,391 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.io.Closeable;\n+import java.sql.Connection;\n+import java.sql.DataTruncation;\n+import java.sql.DatabaseMetaData;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.sql.SQLWarning;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.exceptions.UncheckedSQLException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, SupportsNamespaces, Closeable {\n+\n+  public static final String SQL_TABLE_NAME = \"iceberg_tables\";\n+  public static final String SQL_TABLE_DDL =\n+          \"CREATE TABLE \" + SQL_TABLE_NAME +\n+                  \"(catalog_name VARCHAR(1255) NOT NULL,\" +\n+                  \"table_namespace VARCHAR(1255) NOT NULL,\" +\n+                  \"table_name VARCHAR(1255) NOT NULL,\" +\n+                  \"metadata_location VARCHAR(32768),\" +\n+                  \"previous_metadata_location VARCHAR(32768),\" +\n+                  \"PRIMARY KEY (catalog_name, table_namespace, table_name)\" +\n+                  \")\";\n+  public static final String SQL_SELECT_TABLE = \"SELECT * FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+  public static final String SQL_SELECT_ALL = \"SELECT * FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace = ?\";\n+  public static final String SQL_UPDATE_TABLE_NAME = \"UPDATE \" + SQL_TABLE_NAME +\n+          \" SET table_namespace = ? , table_name = ? \" +\n+          \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+  public static final String SQL_DELETE_TABLE = \"DELETE FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+  public static final String SQL_SELECT_NAMESPACE = \"SELECT table_namespace FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace LIKE ? LIMIT 1\";\n+  public static final String SQL_SELECT_NAMESPACES = \"SELECT DISTINCT table_namespace FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace LIKE ?\";\n+  public static final String JDBC_PARAM_PREFIX = \"connection.parameter.\";\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcCatalog.class);\n+  private static final Joiner SLASH = Joiner.on(\"/\");\n+\n+  private FileIO fileIO;\n+  private String catalogName = \"jdbc\";\n+  private String warehouseLocation;\n+  private Configuration hadoopConf;\n+  private JdbcClientPool dbConnPool;\n+\n+  public JdbcCatalog() {\n+  }\n+\n+  @SuppressWarnings(\"checkstyle:HiddenField\")\n+  @Override\n+  public void initialize(String name, Map<String, String> properties) {\n+    Preconditions.checkArgument(!properties.getOrDefault(CatalogProperties.HIVE_URI, \"\").isEmpty(),\n+            \"No connection url provided for jdbc catalog!\");\n+    Preconditions.checkArgument(!properties.getOrDefault(CatalogProperties.WAREHOUSE_LOCATION, \"\").isEmpty(),\n+            \"Cannot initialize Jdbc Catalog because warehousePath must not be null!\");\n+\n+    this.warehouseLocation = properties.get(CatalogProperties.WAREHOUSE_LOCATION).replaceAll(\"/$\", \"\");\n+    this.catalogName = name == null ? \"jdbc\" : name;\n+    String fileIOImpl = properties.get(CatalogProperties.FILE_IO_IMPL);\n+    this.fileIO = fileIOImpl == null ?\n+            new HadoopFileIO(hadoopConf) :\n+            CatalogUtil.loadFileIO(fileIOImpl, properties, hadoopConf);\n+    initializeConnection(properties);\n+  }\n+\n+  private void initializeConnection(Map<String, String> properties) {\n+    try {\n+      LOG.debug(\"Connecting to Jdbc database {}\", properties.get(CatalogProperties.HIVE_URI));\n+      Properties dbProps = new Properties();\n+      for (Map.Entry<String, String> prop : properties.entrySet()) {\n+        if (prop.getKey().startsWith(JDBC_PARAM_PREFIX)) {\n+          dbProps.put(prop.getKey().substring(JDBC_PARAM_PREFIX.length()), prop.getValue());\n+        }\n+      }\n+      dbConnPool = new JdbcClientPool(properties.get(CatalogProperties.HIVE_URI), dbProps);\n+      initializeCatalogTables();\n+    } catch (SQLTimeoutException e) {\n+      throw new UncheckedSQLException(\"Database Connection timeout!\", e);\n+    } catch (SQLTransientConnectionException | SQLNonTransientConnectionException e) {\n+      throw new UncheckedSQLException(\"Database Connection failed!\", e);\n+    } catch (SQLWarning e) {\n+      throw new UncheckedSQLException(\"Database connection warning!\", e);\n+    } catch (SQLException | InterruptedException e) {\n+      throw new UncheckedSQLException(\"Failed to initialize Jdbc Catalog!\", e);\n+    }\n+  }\n+\n+  private void initializeCatalogTables() throws InterruptedException, SQLException {\n+    // need to check multiple times because some databases are using different naming standard. ex: H2db keeping\n+    // table names as uppercase\n+    boolean exists = false;\n+    DatabaseMetaData dbMeta = dbConnPool.run(Connection::getMetaData);\n+    ResultSet tables = dbMeta.getTables(null, null, SQL_TABLE_NAME, null);\n+    if (tables.next()) {\n+      exists = true;\n+    }\n+    tables.close();\n+    ResultSet tablesUpper = dbMeta.getTables(null, null, SQL_TABLE_NAME.toUpperCase(), null);\n+    if (tablesUpper.next()) {\n+      exists = true;\n+    }\n+    tablesUpper.close();\n+    ResultSet tablesLower = dbMeta.getTables(null, null, SQL_TABLE_NAME.toLowerCase(), null);\n+    if (tablesLower.next()) {\n+      exists = true;\n+    }\n+    tablesLower.close();\n+\n+    // create table if not exits\n+    if (!exists) {\n+      dbConnPool.run(conn -> conn.prepareStatement(SQL_TABLE_DDL).execute());\n+      LOG.debug(\"Created table {} to store iceberg tables!\", SQL_TABLE_NAME);\n+    }\n+  }\n+\n+  @Override\n+  protected TableOperations newTableOps(TableIdentifier tableIdentifier) {\n+    return new JdbcTableOperations(dbConnPool, fileIO, catalogName, tableIdentifier);\n+  }\n+\n+  @Override\n+  protected String defaultWarehouseLocation(TableIdentifier table) {\n+    if (table.hasNamespace()) {\n+      return SLASH.join(warehouseLocation, table.namespace().levels(), table.name());\n+    }\n+    return SLASH.join(warehouseLocation, table.name());\n+  }\n+\n+  @Override\n+  public boolean dropTable(TableIdentifier identifier, boolean purge) {\n+    TableOperations ops = newTableOps(identifier);\n+    TableMetadata lastMetadata = ops.current();\n+    try {\n+      PreparedStatement sql = dbConnPool.run(c -> c.prepareStatement(SQL_DELETE_TABLE));\n+      sql.setString(1, catalogName);\n+      sql.setString(2, JdbcUtil.namespaceToString(identifier.namespace()));\n+      sql.setString(3, identifier.name());\n+      int deletedRecords = sql.executeUpdate();\n+\n+      if (deletedRecords > 0) {\n+        LOG.debug(\"Successfully dropped table {}.\", identifier);\n+      } else {\n+        throw new NoSuchTableException(\"Cannot drop table %s! table not found in the catalog.\", identifier);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6f8c6e36d78a79c8a8561292c2fa07f7e7f480a"}, "originalPosition": 197}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5MzQ3OTI0", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-559347924", "createdAt": "2020-12-29T01:17:47Z", "commit": {"oid": "e6f8c6e36d78a79c8a8561292c2fa07f7e7f480a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwMToxNzo0N1rOIME8hw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwMToxNzo0N1rOIME8hw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUzNDg1NQ==", "bodyText": "Other places use Namespace does not exist: %s", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r549534855", "createdAt": "2020-12-29T01:17:47Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,391 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.io.Closeable;\n+import java.sql.Connection;\n+import java.sql.DataTruncation;\n+import java.sql.DatabaseMetaData;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.sql.SQLWarning;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.exceptions.UncheckedSQLException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, SupportsNamespaces, Closeable {\n+\n+  public static final String SQL_TABLE_NAME = \"iceberg_tables\";\n+  public static final String SQL_TABLE_DDL =\n+          \"CREATE TABLE \" + SQL_TABLE_NAME +\n+                  \"(catalog_name VARCHAR(1255) NOT NULL,\" +\n+                  \"table_namespace VARCHAR(1255) NOT NULL,\" +\n+                  \"table_name VARCHAR(1255) NOT NULL,\" +\n+                  \"metadata_location VARCHAR(32768),\" +\n+                  \"previous_metadata_location VARCHAR(32768),\" +\n+                  \"PRIMARY KEY (catalog_name, table_namespace, table_name)\" +\n+                  \")\";\n+  public static final String SQL_SELECT_TABLE = \"SELECT * FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+  public static final String SQL_SELECT_ALL = \"SELECT * FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace = ?\";\n+  public static final String SQL_UPDATE_TABLE_NAME = \"UPDATE \" + SQL_TABLE_NAME +\n+          \" SET table_namespace = ? , table_name = ? \" +\n+          \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+  public static final String SQL_DELETE_TABLE = \"DELETE FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+  public static final String SQL_SELECT_NAMESPACE = \"SELECT table_namespace FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace LIKE ? LIMIT 1\";\n+  public static final String SQL_SELECT_NAMESPACES = \"SELECT DISTINCT table_namespace FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace LIKE ?\";\n+  public static final String JDBC_PARAM_PREFIX = \"connection.parameter.\";\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcCatalog.class);\n+  private static final Joiner SLASH = Joiner.on(\"/\");\n+\n+  private FileIO fileIO;\n+  private String catalogName = \"jdbc\";\n+  private String warehouseLocation;\n+  private Configuration hadoopConf;\n+  private JdbcClientPool dbConnPool;\n+\n+  public JdbcCatalog() {\n+  }\n+\n+  @SuppressWarnings(\"checkstyle:HiddenField\")\n+  @Override\n+  public void initialize(String name, Map<String, String> properties) {\n+    Preconditions.checkArgument(!properties.getOrDefault(CatalogProperties.HIVE_URI, \"\").isEmpty(),\n+            \"No connection url provided for jdbc catalog!\");\n+    Preconditions.checkArgument(!properties.getOrDefault(CatalogProperties.WAREHOUSE_LOCATION, \"\").isEmpty(),\n+            \"Cannot initialize Jdbc Catalog because warehousePath must not be null!\");\n+\n+    this.warehouseLocation = properties.get(CatalogProperties.WAREHOUSE_LOCATION).replaceAll(\"/$\", \"\");\n+    this.catalogName = name == null ? \"jdbc\" : name;\n+    String fileIOImpl = properties.get(CatalogProperties.FILE_IO_IMPL);\n+    this.fileIO = fileIOImpl == null ?\n+            new HadoopFileIO(hadoopConf) :\n+            CatalogUtil.loadFileIO(fileIOImpl, properties, hadoopConf);\n+    initializeConnection(properties);\n+  }\n+\n+  private void initializeConnection(Map<String, String> properties) {\n+    try {\n+      LOG.debug(\"Connecting to Jdbc database {}\", properties.get(CatalogProperties.HIVE_URI));\n+      Properties dbProps = new Properties();\n+      for (Map.Entry<String, String> prop : properties.entrySet()) {\n+        if (prop.getKey().startsWith(JDBC_PARAM_PREFIX)) {\n+          dbProps.put(prop.getKey().substring(JDBC_PARAM_PREFIX.length()), prop.getValue());\n+        }\n+      }\n+      dbConnPool = new JdbcClientPool(properties.get(CatalogProperties.HIVE_URI), dbProps);\n+      initializeCatalogTables();\n+    } catch (SQLTimeoutException e) {\n+      throw new UncheckedSQLException(\"Database Connection timeout!\", e);\n+    } catch (SQLTransientConnectionException | SQLNonTransientConnectionException e) {\n+      throw new UncheckedSQLException(\"Database Connection failed!\", e);\n+    } catch (SQLWarning e) {\n+      throw new UncheckedSQLException(\"Database connection warning!\", e);\n+    } catch (SQLException | InterruptedException e) {\n+      throw new UncheckedSQLException(\"Failed to initialize Jdbc Catalog!\", e);\n+    }\n+  }\n+\n+  private void initializeCatalogTables() throws InterruptedException, SQLException {\n+    // need to check multiple times because some databases are using different naming standard. ex: H2db keeping\n+    // table names as uppercase\n+    boolean exists = false;\n+    DatabaseMetaData dbMeta = dbConnPool.run(Connection::getMetaData);\n+    ResultSet tables = dbMeta.getTables(null, null, SQL_TABLE_NAME, null);\n+    if (tables.next()) {\n+      exists = true;\n+    }\n+    tables.close();\n+    ResultSet tablesUpper = dbMeta.getTables(null, null, SQL_TABLE_NAME.toUpperCase(), null);\n+    if (tablesUpper.next()) {\n+      exists = true;\n+    }\n+    tablesUpper.close();\n+    ResultSet tablesLower = dbMeta.getTables(null, null, SQL_TABLE_NAME.toLowerCase(), null);\n+    if (tablesLower.next()) {\n+      exists = true;\n+    }\n+    tablesLower.close();\n+\n+    // create table if not exits\n+    if (!exists) {\n+      dbConnPool.run(conn -> conn.prepareStatement(SQL_TABLE_DDL).execute());\n+      LOG.debug(\"Created table {} to store iceberg tables!\", SQL_TABLE_NAME);\n+    }\n+  }\n+\n+  @Override\n+  protected TableOperations newTableOps(TableIdentifier tableIdentifier) {\n+    return new JdbcTableOperations(dbConnPool, fileIO, catalogName, tableIdentifier);\n+  }\n+\n+  @Override\n+  protected String defaultWarehouseLocation(TableIdentifier table) {\n+    if (table.hasNamespace()) {\n+      return SLASH.join(warehouseLocation, table.namespace().levels(), table.name());\n+    }\n+    return SLASH.join(warehouseLocation, table.name());\n+  }\n+\n+  @Override\n+  public boolean dropTable(TableIdentifier identifier, boolean purge) {\n+    TableOperations ops = newTableOps(identifier);\n+    TableMetadata lastMetadata = ops.current();\n+    try {\n+      PreparedStatement sql = dbConnPool.run(c -> c.prepareStatement(SQL_DELETE_TABLE));\n+      sql.setString(1, catalogName);\n+      sql.setString(2, JdbcUtil.namespaceToString(identifier.namespace()));\n+      sql.setString(3, identifier.name());\n+      int deletedRecords = sql.executeUpdate();\n+\n+      if (deletedRecords > 0) {\n+        LOG.debug(\"Successfully dropped table {}.\", identifier);\n+      } else {\n+        throw new NoSuchTableException(\"Cannot drop table %s! table not found in the catalog.\", identifier);\n+      }\n+\n+      if (purge && lastMetadata != null) {\n+        CatalogUtil.dropTableData(ops.io(), lastMetadata);\n+        LOG.info(\"Table {} data purged!\", identifier);\n+      }\n+      return true;\n+    } catch (SQLException | InterruptedException e) {\n+      throw new UncheckedSQLException(\"Failed to drop table!\", e);\n+    }\n+  }\n+\n+  @Override\n+  public List<TableIdentifier> listTables(Namespace namespace) {\n+    if (!this.namespaceExists(namespace)) {\n+      throw new NoSuchNamespaceException(\"Namespace %s does not exist!\", namespace);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6f8c6e36d78a79c8a8561292c2fa07f7e7f480a"}, "originalPosition": 213}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5MzQ4MDI0", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-559348024", "createdAt": "2020-12-29T01:18:43Z", "commit": {"oid": "e6f8c6e36d78a79c8a8561292c2fa07f7e7f480a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwMToxODo0NFrOIME9Cg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwMToxODo0NFrOIME9Cg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUzNDk4Ng==", "bodyText": "Can you name these SQL statements for the methods that they are used in? For example, LOAD_TABLE_SQL, RENAME_TABLE_SQL, etc.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r549534986", "createdAt": "2020-12-29T01:18:44Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,391 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.io.Closeable;\n+import java.sql.Connection;\n+import java.sql.DataTruncation;\n+import java.sql.DatabaseMetaData;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.sql.SQLWarning;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.exceptions.UncheckedSQLException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, SupportsNamespaces, Closeable {\n+\n+  public static final String SQL_TABLE_NAME = \"iceberg_tables\";\n+  public static final String SQL_TABLE_DDL =\n+          \"CREATE TABLE \" + SQL_TABLE_NAME +\n+                  \"(catalog_name VARCHAR(1255) NOT NULL,\" +\n+                  \"table_namespace VARCHAR(1255) NOT NULL,\" +\n+                  \"table_name VARCHAR(1255) NOT NULL,\" +\n+                  \"metadata_location VARCHAR(32768),\" +\n+                  \"previous_metadata_location VARCHAR(32768),\" +\n+                  \"PRIMARY KEY (catalog_name, table_namespace, table_name)\" +\n+                  \")\";\n+  public static final String SQL_SELECT_TABLE = \"SELECT * FROM \" + SQL_TABLE_NAME +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6f8c6e36d78a79c8a8561292c2fa07f7e7f480a"}, "originalPosition": 77}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5MzQ4Mzg5", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-559348389", "createdAt": "2020-12-29T01:21:25Z", "commit": {"oid": "e6f8c6e36d78a79c8a8561292c2fa07f7e7f480a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwMToyMToyNVrOIME-nA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwMToyMToyNVrOIME-nA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUzNTM4OA==", "bodyText": "Shouldn't this use SLASH for the path instead?", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r549535388", "createdAt": "2020-12-29T01:21:25Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,391 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.io.Closeable;\n+import java.sql.Connection;\n+import java.sql.DataTruncation;\n+import java.sql.DatabaseMetaData;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.sql.SQLWarning;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.exceptions.UncheckedSQLException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, SupportsNamespaces, Closeable {\n+\n+  public static final String SQL_TABLE_NAME = \"iceberg_tables\";\n+  public static final String SQL_TABLE_DDL =\n+          \"CREATE TABLE \" + SQL_TABLE_NAME +\n+                  \"(catalog_name VARCHAR(1255) NOT NULL,\" +\n+                  \"table_namespace VARCHAR(1255) NOT NULL,\" +\n+                  \"table_name VARCHAR(1255) NOT NULL,\" +\n+                  \"metadata_location VARCHAR(32768),\" +\n+                  \"previous_metadata_location VARCHAR(32768),\" +\n+                  \"PRIMARY KEY (catalog_name, table_namespace, table_name)\" +\n+                  \")\";\n+  public static final String SQL_SELECT_TABLE = \"SELECT * FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+  public static final String SQL_SELECT_ALL = \"SELECT * FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace = ?\";\n+  public static final String SQL_UPDATE_TABLE_NAME = \"UPDATE \" + SQL_TABLE_NAME +\n+          \" SET table_namespace = ? , table_name = ? \" +\n+          \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+  public static final String SQL_DELETE_TABLE = \"DELETE FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+  public static final String SQL_SELECT_NAMESPACE = \"SELECT table_namespace FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace LIKE ? LIMIT 1\";\n+  public static final String SQL_SELECT_NAMESPACES = \"SELECT DISTINCT table_namespace FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace LIKE ?\";\n+  public static final String JDBC_PARAM_PREFIX = \"connection.parameter.\";\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcCatalog.class);\n+  private static final Joiner SLASH = Joiner.on(\"/\");\n+\n+  private FileIO fileIO;\n+  private String catalogName = \"jdbc\";\n+  private String warehouseLocation;\n+  private Configuration hadoopConf;\n+  private JdbcClientPool dbConnPool;\n+\n+  public JdbcCatalog() {\n+  }\n+\n+  @SuppressWarnings(\"checkstyle:HiddenField\")\n+  @Override\n+  public void initialize(String name, Map<String, String> properties) {\n+    Preconditions.checkArgument(!properties.getOrDefault(CatalogProperties.HIVE_URI, \"\").isEmpty(),\n+            \"No connection url provided for jdbc catalog!\");\n+    Preconditions.checkArgument(!properties.getOrDefault(CatalogProperties.WAREHOUSE_LOCATION, \"\").isEmpty(),\n+            \"Cannot initialize Jdbc Catalog because warehousePath must not be null!\");\n+\n+    this.warehouseLocation = properties.get(CatalogProperties.WAREHOUSE_LOCATION).replaceAll(\"/$\", \"\");\n+    this.catalogName = name == null ? \"jdbc\" : name;\n+    String fileIOImpl = properties.get(CatalogProperties.FILE_IO_IMPL);\n+    this.fileIO = fileIOImpl == null ?\n+            new HadoopFileIO(hadoopConf) :\n+            CatalogUtil.loadFileIO(fileIOImpl, properties, hadoopConf);\n+    initializeConnection(properties);\n+  }\n+\n+  private void initializeConnection(Map<String, String> properties) {\n+    try {\n+      LOG.debug(\"Connecting to Jdbc database {}\", properties.get(CatalogProperties.HIVE_URI));\n+      Properties dbProps = new Properties();\n+      for (Map.Entry<String, String> prop : properties.entrySet()) {\n+        if (prop.getKey().startsWith(JDBC_PARAM_PREFIX)) {\n+          dbProps.put(prop.getKey().substring(JDBC_PARAM_PREFIX.length()), prop.getValue());\n+        }\n+      }\n+      dbConnPool = new JdbcClientPool(properties.get(CatalogProperties.HIVE_URI), dbProps);\n+      initializeCatalogTables();\n+    } catch (SQLTimeoutException e) {\n+      throw new UncheckedSQLException(\"Database Connection timeout!\", e);\n+    } catch (SQLTransientConnectionException | SQLNonTransientConnectionException e) {\n+      throw new UncheckedSQLException(\"Database Connection failed!\", e);\n+    } catch (SQLWarning e) {\n+      throw new UncheckedSQLException(\"Database connection warning!\", e);\n+    } catch (SQLException | InterruptedException e) {\n+      throw new UncheckedSQLException(\"Failed to initialize Jdbc Catalog!\", e);\n+    }\n+  }\n+\n+  private void initializeCatalogTables() throws InterruptedException, SQLException {\n+    // need to check multiple times because some databases are using different naming standard. ex: H2db keeping\n+    // table names as uppercase\n+    boolean exists = false;\n+    DatabaseMetaData dbMeta = dbConnPool.run(Connection::getMetaData);\n+    ResultSet tables = dbMeta.getTables(null, null, SQL_TABLE_NAME, null);\n+    if (tables.next()) {\n+      exists = true;\n+    }\n+    tables.close();\n+    ResultSet tablesUpper = dbMeta.getTables(null, null, SQL_TABLE_NAME.toUpperCase(), null);\n+    if (tablesUpper.next()) {\n+      exists = true;\n+    }\n+    tablesUpper.close();\n+    ResultSet tablesLower = dbMeta.getTables(null, null, SQL_TABLE_NAME.toLowerCase(), null);\n+    if (tablesLower.next()) {\n+      exists = true;\n+    }\n+    tablesLower.close();\n+\n+    // create table if not exits\n+    if (!exists) {\n+      dbConnPool.run(conn -> conn.prepareStatement(SQL_TABLE_DDL).execute());\n+      LOG.debug(\"Created table {} to store iceberg tables!\", SQL_TABLE_NAME);\n+    }\n+  }\n+\n+  @Override\n+  protected TableOperations newTableOps(TableIdentifier tableIdentifier) {\n+    return new JdbcTableOperations(dbConnPool, fileIO, catalogName, tableIdentifier);\n+  }\n+\n+  @Override\n+  protected String defaultWarehouseLocation(TableIdentifier table) {\n+    if (table.hasNamespace()) {\n+      return SLASH.join(warehouseLocation, table.namespace().levels(), table.name());\n+    }\n+    return SLASH.join(warehouseLocation, table.name());\n+  }\n+\n+  @Override\n+  public boolean dropTable(TableIdentifier identifier, boolean purge) {\n+    TableOperations ops = newTableOps(identifier);\n+    TableMetadata lastMetadata = ops.current();\n+    try {\n+      PreparedStatement sql = dbConnPool.run(c -> c.prepareStatement(SQL_DELETE_TABLE));\n+      sql.setString(1, catalogName);\n+      sql.setString(2, JdbcUtil.namespaceToString(identifier.namespace()));\n+      sql.setString(3, identifier.name());\n+      int deletedRecords = sql.executeUpdate();\n+\n+      if (deletedRecords > 0) {\n+        LOG.debug(\"Successfully dropped table {}.\", identifier);\n+      } else {\n+        throw new NoSuchTableException(\"Cannot drop table %s! table not found in the catalog.\", identifier);\n+      }\n+\n+      if (purge && lastMetadata != null) {\n+        CatalogUtil.dropTableData(ops.io(), lastMetadata);\n+        LOG.info(\"Table {} data purged!\", identifier);\n+      }\n+      return true;\n+    } catch (SQLException | InterruptedException e) {\n+      throw new UncheckedSQLException(\"Failed to drop table!\", e);\n+    }\n+  }\n+\n+  @Override\n+  public List<TableIdentifier> listTables(Namespace namespace) {\n+    if (!this.namespaceExists(namespace)) {\n+      throw new NoSuchNamespaceException(\"Namespace %s does not exist!\", namespace);\n+    }\n+    try {\n+      List<TableIdentifier> results = Lists.newArrayList();\n+      PreparedStatement sql = dbConnPool.run(c -> c.prepareStatement(SQL_SELECT_ALL));\n+      sql.setString(1, catalogName);\n+      sql.setString(2, JdbcUtil.namespaceToString(namespace));\n+      ResultSet rs = sql.executeQuery();\n+\n+      while (rs.next()) {\n+        final TableIdentifier table = JdbcUtil.stringToTableIdentifier(\n+                rs.getString(\"table_namespace\"), rs.getString(\"table_name\"));\n+        results.add(table);\n+      }\n+      rs.close();\n+      return results;\n+\n+    } catch (SQLException | InterruptedException e) {\n+      LOG.error(\"Failed to list tables!\", e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void renameTable(TableIdentifier from, TableIdentifier to) {\n+    try {\n+      PreparedStatement sql = dbConnPool.run(c -> c.prepareStatement(SQL_UPDATE_TABLE_NAME));\n+      // SET\n+      sql.setString(1, JdbcUtil.namespaceToString(to.namespace()));\n+      sql.setString(2, to.name());\n+      // WHERE\n+      sql.setString(3, catalogName);\n+      sql.setString(4, JdbcUtil.namespaceToString(from.namespace()));\n+      sql.setString(5, from.name());\n+      int updatedRecords = sql.executeUpdate();\n+\n+      if (updatedRecords == 1) {\n+        LOG.debug(\"Successfully renamed table from {} to {}!\", from, to);\n+      } else if (updatedRecords == 0) {\n+        throw new NoSuchTableException(\"Failed to rename table! Table '%s' not found in the catalog!\", from);\n+      } else {\n+        throw new UncheckedSQLException(\"Failed to rename table! Rename operation Failed\");\n+      }\n+    } catch (SQLIntegrityConstraintViolationException e) {\n+      throw new AlreadyExistsException(\"Table with name '%s' already exists in the catalog!\", to);\n+    } catch (DataTruncation e) {\n+      throw new UncheckedSQLException(\"Database data truncation error!\", e);\n+    } catch (SQLWarning e) {\n+      throw new UncheckedSQLException(\"Database warning!\", e);\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(\"Failed to rename table!\", e);\n+    } catch (InterruptedException e) {\n+      throw new UncheckedSQLException(\"Database Connection interrupted!\", e);\n+    }\n+  }\n+\n+  @Override\n+  public String name() {\n+    return catalogName;\n+  }\n+\n+  @Override\n+  public Configuration getConf() {\n+    return this.hadoopConf;\n+  }\n+\n+  @Override\n+  public void setConf(Configuration conf) {\n+    this.hadoopConf = conf;\n+  }\n+\n+  @Override\n+  public void createNamespace(Namespace namespace, Map<String, String> metadata) {\n+    throw new UnsupportedOperationException(\"Cannot create namespace \" + namespace +\n+            \": createNamespace is not supported\");\n+  }\n+\n+  @Override\n+  public List<Namespace> listNamespaces(Namespace namespace) throws NoSuchNamespaceException {\n+    if (!this.namespaceExists(namespace)) {\n+      throw new NoSuchNamespaceException(\"Namespace does not exist %s\", namespace);\n+    }\n+    try {\n+      List<Namespace> namespaces = Lists.newArrayList();\n+      PreparedStatement sql = dbConnPool.run(c -> c.prepareStatement(SQL_SELECT_NAMESPACES));\n+      sql.setString(1, catalogName);\n+      if (namespace.isEmpty()) {\n+        sql.setString(2, JdbcUtil.namespaceToString(namespace) + \"%\");\n+      } else {\n+        sql.setString(2, JdbcUtil.namespaceToString(namespace) + \".%\");\n+      }\n+      ResultSet rs = sql.executeQuery();\n+      while (rs.next()) {\n+        rs.getString(\"table_namespace\");\n+        namespaces.add(JdbcUtil.stringToNamespace(rs.getString(\"table_namespace\")));\n+      }\n+      rs.close();\n+      int subNamespaceLevelLength = namespace.levels().length + 1;\n+      namespaces = namespaces.stream()\n+              // exclude itself\n+              .filter(n -> !n.equals(namespace))\n+              // only get sub namespaces/children\n+              .map(n -> Namespace.of(\n+                      Arrays.stream(n.levels()).limit(subNamespaceLevelLength).toArray(String[]::new)\n+                      )\n+              )\n+              // remove duplicates\n+              .distinct()\n+              .collect(Collectors.toList());\n+\n+      LOG.debug(\"From the namespace '{}' found: {}\", namespace, namespaces);\n+      return namespaces;\n+    } catch (Exception e) {\n+      LOG.error(\"Failed to list namespace!\", e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public Map<String, String> loadNamespaceMetadata(Namespace namespace) throws NoSuchNamespaceException {\n+    Path nsPath = new Path(warehouseLocation, JdbcUtil.JOINER_DOT.join(namespace.levels()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6f8c6e36d78a79c8a8561292c2fa07f7e7f480a"}, "originalPosition": 333}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5MzQ4NDY0", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-559348464", "createdAt": "2020-12-29T01:21:58Z", "commit": {"oid": "e6f8c6e36d78a79c8a8561292c2fa07f7e7f480a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwMToyMTo1OVrOIME-9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwMToyMTo1OVrOIME-9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUzNTQ3Ng==", "bodyText": "Missing @Override.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r549535476", "createdAt": "2020-12-29T01:21:59Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,391 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.io.Closeable;\n+import java.sql.Connection;\n+import java.sql.DataTruncation;\n+import java.sql.DatabaseMetaData;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.sql.SQLWarning;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.exceptions.UncheckedSQLException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, SupportsNamespaces, Closeable {\n+\n+  public static final String SQL_TABLE_NAME = \"iceberg_tables\";\n+  public static final String SQL_TABLE_DDL =\n+          \"CREATE TABLE \" + SQL_TABLE_NAME +\n+                  \"(catalog_name VARCHAR(1255) NOT NULL,\" +\n+                  \"table_namespace VARCHAR(1255) NOT NULL,\" +\n+                  \"table_name VARCHAR(1255) NOT NULL,\" +\n+                  \"metadata_location VARCHAR(32768),\" +\n+                  \"previous_metadata_location VARCHAR(32768),\" +\n+                  \"PRIMARY KEY (catalog_name, table_namespace, table_name)\" +\n+                  \")\";\n+  public static final String SQL_SELECT_TABLE = \"SELECT * FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+  public static final String SQL_SELECT_ALL = \"SELECT * FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace = ?\";\n+  public static final String SQL_UPDATE_TABLE_NAME = \"UPDATE \" + SQL_TABLE_NAME +\n+          \" SET table_namespace = ? , table_name = ? \" +\n+          \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+  public static final String SQL_DELETE_TABLE = \"DELETE FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+  public static final String SQL_SELECT_NAMESPACE = \"SELECT table_namespace FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace LIKE ? LIMIT 1\";\n+  public static final String SQL_SELECT_NAMESPACES = \"SELECT DISTINCT table_namespace FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace LIKE ?\";\n+  public static final String JDBC_PARAM_PREFIX = \"connection.parameter.\";\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcCatalog.class);\n+  private static final Joiner SLASH = Joiner.on(\"/\");\n+\n+  private FileIO fileIO;\n+  private String catalogName = \"jdbc\";\n+  private String warehouseLocation;\n+  private Configuration hadoopConf;\n+  private JdbcClientPool dbConnPool;\n+\n+  public JdbcCatalog() {\n+  }\n+\n+  @SuppressWarnings(\"checkstyle:HiddenField\")\n+  @Override\n+  public void initialize(String name, Map<String, String> properties) {\n+    Preconditions.checkArgument(!properties.getOrDefault(CatalogProperties.HIVE_URI, \"\").isEmpty(),\n+            \"No connection url provided for jdbc catalog!\");\n+    Preconditions.checkArgument(!properties.getOrDefault(CatalogProperties.WAREHOUSE_LOCATION, \"\").isEmpty(),\n+            \"Cannot initialize Jdbc Catalog because warehousePath must not be null!\");\n+\n+    this.warehouseLocation = properties.get(CatalogProperties.WAREHOUSE_LOCATION).replaceAll(\"/$\", \"\");\n+    this.catalogName = name == null ? \"jdbc\" : name;\n+    String fileIOImpl = properties.get(CatalogProperties.FILE_IO_IMPL);\n+    this.fileIO = fileIOImpl == null ?\n+            new HadoopFileIO(hadoopConf) :\n+            CatalogUtil.loadFileIO(fileIOImpl, properties, hadoopConf);\n+    initializeConnection(properties);\n+  }\n+\n+  private void initializeConnection(Map<String, String> properties) {\n+    try {\n+      LOG.debug(\"Connecting to Jdbc database {}\", properties.get(CatalogProperties.HIVE_URI));\n+      Properties dbProps = new Properties();\n+      for (Map.Entry<String, String> prop : properties.entrySet()) {\n+        if (prop.getKey().startsWith(JDBC_PARAM_PREFIX)) {\n+          dbProps.put(prop.getKey().substring(JDBC_PARAM_PREFIX.length()), prop.getValue());\n+        }\n+      }\n+      dbConnPool = new JdbcClientPool(properties.get(CatalogProperties.HIVE_URI), dbProps);\n+      initializeCatalogTables();\n+    } catch (SQLTimeoutException e) {\n+      throw new UncheckedSQLException(\"Database Connection timeout!\", e);\n+    } catch (SQLTransientConnectionException | SQLNonTransientConnectionException e) {\n+      throw new UncheckedSQLException(\"Database Connection failed!\", e);\n+    } catch (SQLWarning e) {\n+      throw new UncheckedSQLException(\"Database connection warning!\", e);\n+    } catch (SQLException | InterruptedException e) {\n+      throw new UncheckedSQLException(\"Failed to initialize Jdbc Catalog!\", e);\n+    }\n+  }\n+\n+  private void initializeCatalogTables() throws InterruptedException, SQLException {\n+    // need to check multiple times because some databases are using different naming standard. ex: H2db keeping\n+    // table names as uppercase\n+    boolean exists = false;\n+    DatabaseMetaData dbMeta = dbConnPool.run(Connection::getMetaData);\n+    ResultSet tables = dbMeta.getTables(null, null, SQL_TABLE_NAME, null);\n+    if (tables.next()) {\n+      exists = true;\n+    }\n+    tables.close();\n+    ResultSet tablesUpper = dbMeta.getTables(null, null, SQL_TABLE_NAME.toUpperCase(), null);\n+    if (tablesUpper.next()) {\n+      exists = true;\n+    }\n+    tablesUpper.close();\n+    ResultSet tablesLower = dbMeta.getTables(null, null, SQL_TABLE_NAME.toLowerCase(), null);\n+    if (tablesLower.next()) {\n+      exists = true;\n+    }\n+    tablesLower.close();\n+\n+    // create table if not exits\n+    if (!exists) {\n+      dbConnPool.run(conn -> conn.prepareStatement(SQL_TABLE_DDL).execute());\n+      LOG.debug(\"Created table {} to store iceberg tables!\", SQL_TABLE_NAME);\n+    }\n+  }\n+\n+  @Override\n+  protected TableOperations newTableOps(TableIdentifier tableIdentifier) {\n+    return new JdbcTableOperations(dbConnPool, fileIO, catalogName, tableIdentifier);\n+  }\n+\n+  @Override\n+  protected String defaultWarehouseLocation(TableIdentifier table) {\n+    if (table.hasNamespace()) {\n+      return SLASH.join(warehouseLocation, table.namespace().levels(), table.name());\n+    }\n+    return SLASH.join(warehouseLocation, table.name());\n+  }\n+\n+  @Override\n+  public boolean dropTable(TableIdentifier identifier, boolean purge) {\n+    TableOperations ops = newTableOps(identifier);\n+    TableMetadata lastMetadata = ops.current();\n+    try {\n+      PreparedStatement sql = dbConnPool.run(c -> c.prepareStatement(SQL_DELETE_TABLE));\n+      sql.setString(1, catalogName);\n+      sql.setString(2, JdbcUtil.namespaceToString(identifier.namespace()));\n+      sql.setString(3, identifier.name());\n+      int deletedRecords = sql.executeUpdate();\n+\n+      if (deletedRecords > 0) {\n+        LOG.debug(\"Successfully dropped table {}.\", identifier);\n+      } else {\n+        throw new NoSuchTableException(\"Cannot drop table %s! table not found in the catalog.\", identifier);\n+      }\n+\n+      if (purge && lastMetadata != null) {\n+        CatalogUtil.dropTableData(ops.io(), lastMetadata);\n+        LOG.info(\"Table {} data purged!\", identifier);\n+      }\n+      return true;\n+    } catch (SQLException | InterruptedException e) {\n+      throw new UncheckedSQLException(\"Failed to drop table!\", e);\n+    }\n+  }\n+\n+  @Override\n+  public List<TableIdentifier> listTables(Namespace namespace) {\n+    if (!this.namespaceExists(namespace)) {\n+      throw new NoSuchNamespaceException(\"Namespace %s does not exist!\", namespace);\n+    }\n+    try {\n+      List<TableIdentifier> results = Lists.newArrayList();\n+      PreparedStatement sql = dbConnPool.run(c -> c.prepareStatement(SQL_SELECT_ALL));\n+      sql.setString(1, catalogName);\n+      sql.setString(2, JdbcUtil.namespaceToString(namespace));\n+      ResultSet rs = sql.executeQuery();\n+\n+      while (rs.next()) {\n+        final TableIdentifier table = JdbcUtil.stringToTableIdentifier(\n+                rs.getString(\"table_namespace\"), rs.getString(\"table_name\"));\n+        results.add(table);\n+      }\n+      rs.close();\n+      return results;\n+\n+    } catch (SQLException | InterruptedException e) {\n+      LOG.error(\"Failed to list tables!\", e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void renameTable(TableIdentifier from, TableIdentifier to) {\n+    try {\n+      PreparedStatement sql = dbConnPool.run(c -> c.prepareStatement(SQL_UPDATE_TABLE_NAME));\n+      // SET\n+      sql.setString(1, JdbcUtil.namespaceToString(to.namespace()));\n+      sql.setString(2, to.name());\n+      // WHERE\n+      sql.setString(3, catalogName);\n+      sql.setString(4, JdbcUtil.namespaceToString(from.namespace()));\n+      sql.setString(5, from.name());\n+      int updatedRecords = sql.executeUpdate();\n+\n+      if (updatedRecords == 1) {\n+        LOG.debug(\"Successfully renamed table from {} to {}!\", from, to);\n+      } else if (updatedRecords == 0) {\n+        throw new NoSuchTableException(\"Failed to rename table! Table '%s' not found in the catalog!\", from);\n+      } else {\n+        throw new UncheckedSQLException(\"Failed to rename table! Rename operation Failed\");\n+      }\n+    } catch (SQLIntegrityConstraintViolationException e) {\n+      throw new AlreadyExistsException(\"Table with name '%s' already exists in the catalog!\", to);\n+    } catch (DataTruncation e) {\n+      throw new UncheckedSQLException(\"Database data truncation error!\", e);\n+    } catch (SQLWarning e) {\n+      throw new UncheckedSQLException(\"Database warning!\", e);\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(\"Failed to rename table!\", e);\n+    } catch (InterruptedException e) {\n+      throw new UncheckedSQLException(\"Database Connection interrupted!\", e);\n+    }\n+  }\n+\n+  @Override\n+  public String name() {\n+    return catalogName;\n+  }\n+\n+  @Override\n+  public Configuration getConf() {\n+    return this.hadoopConf;\n+  }\n+\n+  @Override\n+  public void setConf(Configuration conf) {\n+    this.hadoopConf = conf;\n+  }\n+\n+  @Override\n+  public void createNamespace(Namespace namespace, Map<String, String> metadata) {\n+    throw new UnsupportedOperationException(\"Cannot create namespace \" + namespace +\n+            \": createNamespace is not supported\");\n+  }\n+\n+  @Override\n+  public List<Namespace> listNamespaces(Namespace namespace) throws NoSuchNamespaceException {\n+    if (!this.namespaceExists(namespace)) {\n+      throw new NoSuchNamespaceException(\"Namespace does not exist %s\", namespace);\n+    }\n+    try {\n+      List<Namespace> namespaces = Lists.newArrayList();\n+      PreparedStatement sql = dbConnPool.run(c -> c.prepareStatement(SQL_SELECT_NAMESPACES));\n+      sql.setString(1, catalogName);\n+      if (namespace.isEmpty()) {\n+        sql.setString(2, JdbcUtil.namespaceToString(namespace) + \"%\");\n+      } else {\n+        sql.setString(2, JdbcUtil.namespaceToString(namespace) + \".%\");\n+      }\n+      ResultSet rs = sql.executeQuery();\n+      while (rs.next()) {\n+        rs.getString(\"table_namespace\");\n+        namespaces.add(JdbcUtil.stringToNamespace(rs.getString(\"table_namespace\")));\n+      }\n+      rs.close();\n+      int subNamespaceLevelLength = namespace.levels().length + 1;\n+      namespaces = namespaces.stream()\n+              // exclude itself\n+              .filter(n -> !n.equals(namespace))\n+              // only get sub namespaces/children\n+              .map(n -> Namespace.of(\n+                      Arrays.stream(n.levels()).limit(subNamespaceLevelLength).toArray(String[]::new)\n+                      )\n+              )\n+              // remove duplicates\n+              .distinct()\n+              .collect(Collectors.toList());\n+\n+      LOG.debug(\"From the namespace '{}' found: {}\", namespace, namespaces);\n+      return namespaces;\n+    } catch (Exception e) {\n+      LOG.error(\"Failed to list namespace!\", e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public Map<String, String> loadNamespaceMetadata(Namespace namespace) throws NoSuchNamespaceException {\n+    Path nsPath = new Path(warehouseLocation, JdbcUtil.JOINER_DOT.join(namespace.levels()));\n+    if (!this.namespaceExists(namespace) || namespace.isEmpty()) {\n+      throw new NoSuchNamespaceException(\"Namespace does not exist: %s\", namespace);\n+    }\n+\n+    return ImmutableMap.of(\"location\", nsPath.toString());\n+  }\n+\n+  @Override\n+  public boolean dropNamespace(Namespace namespace) throws NamespaceNotEmptyException {\n+    if (!this.namespaceExists(namespace)) {\n+      throw new NoSuchNamespaceException(\"Cannot drop namespace %s because it is not found!\", namespace);\n+    }\n+\n+    List<TableIdentifier> tableIdentifiers = listTables(namespace);\n+    if (tableIdentifiers != null && !tableIdentifiers.isEmpty()) {\n+      throw new NamespaceNotEmptyException(\"Cannot drop namespace %s because it is not empty. \" +\n+              \"The following tables still exist under the namespace: %s\", namespace, tableIdentifiers);\n+    }\n+    // namespaces are created/deleted by tables by default return true\n+    return true;\n+  }\n+\n+  @Override\n+  public boolean setProperties(Namespace namespace, Map<String, String> properties) throws\n+          NoSuchNamespaceException {\n+    throw new UnsupportedOperationException(\n+            \"Cannot set properties \" + namespace + \" : setProperties is not supported\");\n+  }\n+\n+  @Override\n+  public boolean removeProperties(Namespace namespace, Set<String> properties) throws NoSuchNamespaceException {\n+    throw new UnsupportedOperationException(\n+            \"Cannot remove properties \" + namespace + \" : removeProperties is not supported\");\n+  }\n+\n+  @Override\n+  public void close() {\n+    this.dbConnPool.close();\n+  }\n+\n+  public boolean namespaceExists(Namespace namespace) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6f8c6e36d78a79c8a8561292c2fa07f7e7f480a"}, "originalPosition": 374}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b783df8184edad58957414bd5679682465be6c63", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/b783df8184edad58957414bd5679682465be6c63", "committedDate": "2020-12-31T12:31:36Z", "message": "review fixes\n\nreview fixes\n\nreview fixes"}, "afterCommit": {"oid": "bac375f6b7144abfe6839c0e64609afc7f812bac", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/bac375f6b7144abfe6839c0e64609afc7f812bac", "committedDate": "2020-12-31T13:12:05Z", "message": "update spark3 catalog change"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYxMTcwNDcx", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-561170471", "createdAt": "2021-01-04T16:37:45Z", "commit": {"oid": "bac375f6b7144abfe6839c0e64609afc7f812bac"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNjozNzo0NVrOIN4kiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNjozNzo0NVrOIN4kiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQyOTI1Nw==", "bodyText": "Shouldn't this refer to the JdbcCatalog class not HadoopCatalog?", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r551429257", "createdAt": "2021-01-04T16:37:45Z", "author": {"login": "massdosage"}, "path": "core/src/main/java/org/apache/iceberg/CatalogUtil.java", "diffHunk": "@@ -44,8 +44,10 @@\n   public static final String ICEBERG_CATALOG_TYPE = \"type\";\n   public static final String ICEBERG_CATALOG_TYPE_HADOOP = \"hadoop\";\n   public static final String ICEBERG_CATALOG_TYPE_HIVE = \"hive\";\n+  public static final String ICEBERG_CATALOG_TYPE_JDBC = \"jdbc\";\n   public static final String ICEBERG_CATALOG_HIVE = \"org.apache.iceberg.hive.HiveCatalog\";\n   public static final String ICEBERG_CATALOG_HADOOP = \"org.apache.iceberg.hadoop.HadoopCatalog\";\n+  public static final String ICEBERG_CATALOG_JDBC = \"org.apache.iceberg.hadoop.HadoopCatalog\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bac375f6b7144abfe6839c0e64609afc7f812bac"}, "originalPosition": 7}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyODYxNTc3", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-562861577", "createdAt": "2021-01-06T16:37:24Z", "commit": {"oid": "849b0d2a12b44102c02ba6b89fe45374ad7398ec"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxNjozNzoyNVrOIPLgKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxNzowNToyM1rOIPNGag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjc4ODAxMQ==", "bodyText": "SQL standard requires names stored in uppercase. I think we can just use upper case names for all tables we define.\nnit: put ex on a second line as a complete sentence", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r552788011", "createdAt": "2021-01-06T16:37:25Z", "author": {"login": "jackye1995"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,391 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.io.Closeable;\n+import java.sql.Connection;\n+import java.sql.DataTruncation;\n+import java.sql.DatabaseMetaData;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.sql.SQLWarning;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.exceptions.UncheckedSQLException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, SupportsNamespaces, Closeable {\n+\n+  public static final String SQL_TABLE_NAME = \"iceberg_tables\";\n+  public static final String SQL_TABLE_DDL =\n+          \"CREATE TABLE \" + SQL_TABLE_NAME +\n+                  \"(catalog_name VARCHAR(1255) NOT NULL,\" +\n+                  \"table_namespace VARCHAR(1255) NOT NULL,\" +\n+                  \"table_name VARCHAR(1255) NOT NULL,\" +\n+                  \"metadata_location VARCHAR(32768),\" +\n+                  \"previous_metadata_location VARCHAR(32768),\" +\n+                  \"PRIMARY KEY (catalog_name, table_namespace, table_name)\" +\n+                  \")\";\n+  public static final String SQL_SELECT_TABLE = \"SELECT * FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+  public static final String SQL_SELECT_ALL = \"SELECT * FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace = ?\";\n+  public static final String SQL_UPDATE_TABLE_NAME = \"UPDATE \" + SQL_TABLE_NAME +\n+          \" SET table_namespace = ? , table_name = ? \" +\n+          \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+  public static final String SQL_DELETE_TABLE = \"DELETE FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+  public static final String SQL_SELECT_NAMESPACE = \"SELECT table_namespace FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace LIKE ? LIMIT 1\";\n+  public static final String SQL_SELECT_NAMESPACES = \"SELECT DISTINCT table_namespace FROM \" + SQL_TABLE_NAME +\n+          \" WHERE catalog_name = ? AND table_namespace LIKE ?\";\n+  public static final String JDBC_PARAM_PREFIX = \"connection.parameter.\";\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcCatalog.class);\n+  private static final Joiner SLASH = Joiner.on(\"/\");\n+\n+  private FileIO fileIO;\n+  private String catalogName = \"jdbc\";\n+  private String warehouseLocation;\n+  private Configuration hadoopConf;\n+  private JdbcClientPool dbConnPool;\n+\n+  public JdbcCatalog() {\n+  }\n+\n+  @SuppressWarnings(\"checkstyle:HiddenField\")\n+  @Override\n+  public void initialize(String name, Map<String, String> properties) {\n+    Preconditions.checkArgument(!properties.getOrDefault(CatalogProperties.HIVE_URI, \"\").isEmpty(),\n+            \"No connection url provided for jdbc catalog!\");\n+    Preconditions.checkArgument(!properties.getOrDefault(CatalogProperties.WAREHOUSE_LOCATION, \"\").isEmpty(),\n+            \"Cannot initialize Jdbc Catalog because warehousePath must not be null!\");\n+\n+    this.warehouseLocation = properties.get(CatalogProperties.WAREHOUSE_LOCATION).replaceAll(\"/$\", \"\");\n+    this.catalogName = name == null ? \"jdbc\" : name;\n+    String fileIOImpl = properties.get(CatalogProperties.FILE_IO_IMPL);\n+    this.fileIO = fileIOImpl == null ?\n+            new HadoopFileIO(hadoopConf) :\n+            CatalogUtil.loadFileIO(fileIOImpl, properties, hadoopConf);\n+    initializeConnection(properties);\n+  }\n+\n+  private void initializeConnection(Map<String, String> properties) {\n+    try {\n+      LOG.debug(\"Connecting to Jdbc database {}\", properties.get(CatalogProperties.HIVE_URI));\n+      Properties dbProps = new Properties();\n+      for (Map.Entry<String, String> prop : properties.entrySet()) {\n+        if (prop.getKey().startsWith(JDBC_PARAM_PREFIX)) {\n+          dbProps.put(prop.getKey().substring(JDBC_PARAM_PREFIX.length()), prop.getValue());\n+        }\n+      }\n+      dbConnPool = new JdbcClientPool(properties.get(CatalogProperties.HIVE_URI), dbProps);\n+      initializeCatalogTables();\n+    } catch (SQLTimeoutException e) {\n+      throw new UncheckedSQLException(\"Database Connection timeout!\", e);\n+    } catch (SQLTransientConnectionException | SQLNonTransientConnectionException e) {\n+      throw new UncheckedSQLException(\"Database Connection failed!\", e);\n+    } catch (SQLWarning e) {\n+      throw new UncheckedSQLException(\"Database connection warning!\", e);\n+    } catch (SQLException | InterruptedException e) {\n+      throw new UncheckedSQLException(\"Failed to initialize Jdbc Catalog!\", e);\n+    }\n+  }\n+\n+  private void initializeCatalogTables() throws InterruptedException, SQLException {\n+    // need to check multiple times because some databases are using different naming standard. ex: H2db keeping\n+    // table names as uppercase", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUyOTU2Nw=="}, "originalCommit": {"oid": "e6f8c6e36d78a79c8a8561292c2fa07f7e7f480a"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjc5NDYxNg==", "bodyText": "I am a bit confused, why we don't support creating namespace, but we have all the other namespace operations?\nLooks like the route we are going is to allow table creation with any namespace name, and simply collect namespace information by scanning the iceberg_tables table.\nI think we can do better, by having another iceberg_namesapce table. By doing that, we can also support storing and updating any namespace property. (I don't know if this is already discussed, I am still catching up with latest comments)", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r552794616", "createdAt": "2021-01-06T16:44:24Z", "author": {"login": "jackye1995"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,423 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.io.Closeable;\n+import java.sql.DatabaseMetaData;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.exceptions.UncheckedSQLException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, SupportsNamespaces, Closeable {\n+\n+  public static final String SQL_TABLE_NAME = \"iceberg_tables\";\n+  public static final String SQL_CREATE_CATALOG_TABLE =\n+      \"CREATE TABLE \" + SQL_TABLE_NAME +\n+          \"(catalog_name VARCHAR(1255) NOT NULL,\" +\n+          \"table_namespace VARCHAR(1255) NOT NULL,\" +\n+          \"table_name VARCHAR(1255) NOT NULL,\" +\n+          \"metadata_location VARCHAR(32768),\" +\n+          \"previous_metadata_location VARCHAR(32768),\" +\n+          \"PRIMARY KEY (catalog_name, table_namespace, table_name)\" +\n+          \")\";\n+  public static final String LOAD_TABLE_SQL = \"SELECT * FROM \" + SQL_TABLE_NAME +\n+      \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+  public static final String LIST_TABLES_SQL = \"SELECT * FROM \" + SQL_TABLE_NAME +\n+      \" WHERE catalog_name = ? AND table_namespace = ?\";\n+  public static final String RENAME_TABLE_SQL = \"UPDATE \" + SQL_TABLE_NAME +\n+      \" SET table_namespace = ? , table_name = ? \" +\n+      \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+  public static final String DROP_TABLE_SQL = \"DELETE FROM \" + SQL_TABLE_NAME +\n+      \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+  public static final String GET_NAMESPACE_SQL = \"SELECT table_namespace FROM \" + SQL_TABLE_NAME +\n+      \" WHERE catalog_name = ? AND table_namespace LIKE ? LIMIT 1\";\n+  public static final String LIST_NAMESPACES_SQL = \"SELECT DISTINCT table_namespace FROM \" + SQL_TABLE_NAME +\n+      \" WHERE catalog_name = ? AND table_namespace LIKE ?\";\n+  public static final String JDBC_PARAM_PREFIX = \"connection.parameter.\";\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcCatalog.class);\n+  private static final Joiner SLASH = Joiner.on(\"/\");\n+\n+  private FileIO io;\n+  private String catalogName = \"jdbc\";\n+  private String warehouseLocation;\n+  private Configuration conf;\n+  private JdbcClientPool connections;\n+\n+  public JdbcCatalog() {\n+  }\n+\n+  @Override\n+  public void initialize(String name, Map<String, String> properties) {\n+    Preconditions.checkArgument(!properties.getOrDefault(CatalogProperties.HIVE_URI, \"\").isEmpty(),\n+        \"No connection url provided for jdbc catalog!\");\n+    Preconditions.checkArgument(!properties.getOrDefault(CatalogProperties.WAREHOUSE_LOCATION, \"\").isEmpty(),\n+        \"Cannot initialize Jdbc Catalog because warehousePath must not be null!\");\n+\n+    this.warehouseLocation = properties.get(CatalogProperties.WAREHOUSE_LOCATION).replaceAll(\"/$\", \"\");\n+    this.catalogName = name == null ? \"jdbc\" : name;\n+    String fileIOImpl = properties.get(CatalogProperties.FILE_IO_IMPL);\n+    this.io = fileIOImpl == null ?\n+        new HadoopFileIO(conf) :\n+        CatalogUtil.loadFileIO(fileIOImpl, properties, conf);\n+\n+    try {\n+      initializeConnection(properties);\n+    } catch (SQLTimeoutException e) {\n+      throw new UncheckedSQLException(\"Database Connection timeout!\", e);\n+    } catch (SQLTransientConnectionException | SQLNonTransientConnectionException e) {\n+      throw new UncheckedSQLException(\"Database Connection failed!\", e);\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(\"Failed to initialize catalog!\", e);\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted in call to initialize!\", e);\n+    }\n+  }\n+\n+  private void initializeConnection(Map<String, String> properties) throws SQLException, InterruptedException {\n+    LOG.debug(\"Connecting to Jdbc database {}\", properties.get(CatalogProperties.HIVE_URI));\n+    connections = new JdbcClientPool(properties.get(CatalogProperties.HIVE_URI), properties);\n+    initializeCatalogTables();\n+  }\n+\n+  private void initializeCatalogTables() throws InterruptedException, SQLException {\n+    // need to check multiple times because some databases are using different naming standard. ex: H2db keeping\n+    // table names as uppercase\n+\n+    boolean exists = connections.run(conn -> {\n+      boolean foundTable = false;\n+      DatabaseMetaData dbMeta = conn.getMetaData();\n+      ResultSet tables = dbMeta.getTables(null, null, SQL_TABLE_NAME, null);\n+      if (tables.next()) {\n+        foundTable = true;\n+      }\n+      tables.close();\n+      ResultSet tablesUpper = dbMeta.getTables(null, null, SQL_TABLE_NAME.toUpperCase(), null);\n+      if (tablesUpper.next()) {\n+        foundTable = true;\n+      }\n+      tablesUpper.close();\n+      ResultSet tablesLower = dbMeta.getTables(null, null, SQL_TABLE_NAME.toLowerCase(), null);\n+      if (tablesLower.next()) {\n+        foundTable = true;\n+      }\n+      tablesLower.close();\n+      return foundTable;\n+    });\n+\n+    // create table if not exits\n+    if (!exists) {\n+      connections.run(conn -> conn.prepareStatement(SQL_CREATE_CATALOG_TABLE).execute());\n+      LOG.debug(\"Created table {} to store iceberg tables!\", SQL_TABLE_NAME);\n+    }\n+  }\n+\n+  @Override\n+  protected TableOperations newTableOps(TableIdentifier tableIdentifier) {\n+    return new JdbcTableOperations(connections, io, catalogName, tableIdentifier);\n+  }\n+\n+  @Override\n+  protected String defaultWarehouseLocation(TableIdentifier table) {\n+    if (table.hasNamespace()) {\n+      return SLASH.join(warehouseLocation, SLASH.join(table.namespace().levels()), table.name());\n+    }\n+    return SLASH.join(warehouseLocation, table.name());\n+  }\n+\n+  @Override\n+  public boolean dropTable(TableIdentifier identifier, boolean purge) {\n+\n+    int deletedRecords;\n+    try {\n+      deletedRecords = connections.run(conn -> {\n+        try (PreparedStatement sql = conn.prepareStatement(DROP_TABLE_SQL)) {\n+          sql.setString(1, catalogName);\n+          sql.setString(2, JdbcUtil.namespaceToString(identifier.namespace()));\n+          sql.setString(3, identifier.name());\n+          return sql.executeUpdate();\n+        }\n+      });\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(\"Failed to drop \" + identifier, e);\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted in call to dropTable\", e);\n+    }\n+\n+    if (deletedRecords > 0) {\n+      LOG.debug(\"Successfully dropped table {}.\", identifier);\n+    } else {\n+      LOG.debug(\"Cannot drop table: {}! table not found in the catalog.\", identifier);\n+      return false;\n+    }\n+\n+    TableOperations ops = newTableOps(identifier);\n+    TableMetadata lastMetadata = ops.current();\n+\n+    if (purge && lastMetadata != null) {\n+      CatalogUtil.dropTableData(ops.io(), lastMetadata);\n+      LOG.info(\"Table {} data purged!\", identifier);\n+    }\n+    return true;\n+\n+  }\n+\n+  @Override\n+  public List<TableIdentifier> listTables(Namespace namespace) {\n+    if (!namespaceExists(namespace)) {\n+      throw new NoSuchNamespaceException(\"Namespace does not exist: %s\", namespace);\n+    }\n+\n+    try {\n+      return connections.run(conn -> {\n+        List<TableIdentifier> results = Lists.newArrayList();\n+        try (PreparedStatement sql = conn.prepareStatement(LIST_TABLES_SQL)) {\n+          sql.setString(1, catalogName);\n+          sql.setString(2, JdbcUtil.namespaceToString(namespace));\n+\n+          ResultSet rs = sql.executeQuery();\n+          while (rs.next()) {\n+            results.add(JdbcUtil.stringToTableIdentifier(rs.getString(\"table_namespace\"), rs.getString(\"table_name\")));\n+          }\n+\n+          return results;\n+        }\n+      });\n+\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(String.format(\"Failed to list tables in namespace: %s\", namespace), e);\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted during JDBC operation\", e);\n+    }\n+  }\n+\n+  @Override\n+  public void renameTable(TableIdentifier from, TableIdentifier to) {\n+    try {\n+      int updatedRecords = connections.run(conn -> {\n+        try (PreparedStatement sql = conn.prepareStatement(RENAME_TABLE_SQL)) {\n+          // SET\n+          sql.setString(1, JdbcUtil.namespaceToString(to.namespace()));\n+          sql.setString(2, to.name());\n+          // WHERE\n+          sql.setString(3, catalogName);\n+          sql.setString(4, JdbcUtil.namespaceToString(from.namespace()));\n+          sql.setString(5, from.name());\n+          return sql.executeUpdate();\n+        }\n+      });\n+\n+      if (updatedRecords == 1) {\n+        LOG.debug(\"Successfully renamed table from {} to {}!\", from, to);\n+      } else if (updatedRecords == 0) {\n+        throw new NoSuchTableException(\"Failed to rename table! Table '%s' not found in the catalog!\", from);\n+      } else {\n+        throw new RuntimeException(\"Failed to rename table! Rename operation Failed\");\n+      }\n+    } catch (SQLIntegrityConstraintViolationException e) {\n+      throw new AlreadyExistsException(\"Table with name '%s' already exists in the catalog!\", to);\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(\"Failed to rename table!\", e);\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted in call to rename\", e);\n+    }\n+  }\n+\n+  @Override\n+  public String name() {\n+    return catalogName;\n+  }\n+\n+  @Override\n+  public Configuration getConf() {\n+    return conf;\n+  }\n+\n+  @Override\n+  public void setConf(Configuration conf) {\n+    this.conf = conf;\n+  }\n+\n+  @Override\n+  public void createNamespace(Namespace namespace, Map<String, String> metadata) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "849b0d2a12b44102c02ba6b89fe45374ad7398ec"}, "originalPosition": 295}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjc5NzY1Mw==", "bodyText": "Seems like we are cross referencing constants in JdbcCatalog and JdbcTableOperations, I suggest we move all the SQL table names and statements to a centralized place such as JdbcUtil, what do you think?", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r552797653", "createdAt": "2021-01-06T16:47:41Z", "author": {"login": "jackye1995"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcTableOperations.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.sql.DataTruncation;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.sql.SQLWarning;\n+import java.util.Map;\n+import java.util.Objects;\n+import org.apache.iceberg.BaseMetastoreTableOperations;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.CommitFailedException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.exceptions.UncheckedSQLException;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+class JdbcTableOperations extends BaseMetastoreTableOperations {\n+\n+  public static final String DO_COMMIT_SQL = \"UPDATE \" + JdbcCatalog.SQL_TABLE_NAME +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "849b0d2a12b44102c02ba6b89fe45374ad7398ec"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjgwNDU2Ng==", "bodyText": "why not put % in LIST_NAMESPACES_SQL? And also the same comment for other places using %.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r552804566", "createdAt": "2021-01-06T16:54:57Z", "author": {"login": "jackye1995"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,423 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.io.Closeable;\n+import java.sql.DatabaseMetaData;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.exceptions.UncheckedSQLException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, SupportsNamespaces, Closeable {\n+\n+  public static final String SQL_TABLE_NAME = \"iceberg_tables\";\n+  public static final String SQL_CREATE_CATALOG_TABLE =\n+      \"CREATE TABLE \" + SQL_TABLE_NAME +\n+          \"(catalog_name VARCHAR(1255) NOT NULL,\" +\n+          \"table_namespace VARCHAR(1255) NOT NULL,\" +\n+          \"table_name VARCHAR(1255) NOT NULL,\" +\n+          \"metadata_location VARCHAR(32768),\" +\n+          \"previous_metadata_location VARCHAR(32768),\" +\n+          \"PRIMARY KEY (catalog_name, table_namespace, table_name)\" +\n+          \")\";\n+  public static final String LOAD_TABLE_SQL = \"SELECT * FROM \" + SQL_TABLE_NAME +\n+      \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+  public static final String LIST_TABLES_SQL = \"SELECT * FROM \" + SQL_TABLE_NAME +\n+      \" WHERE catalog_name = ? AND table_namespace = ?\";\n+  public static final String RENAME_TABLE_SQL = \"UPDATE \" + SQL_TABLE_NAME +\n+      \" SET table_namespace = ? , table_name = ? \" +\n+      \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+  public static final String DROP_TABLE_SQL = \"DELETE FROM \" + SQL_TABLE_NAME +\n+      \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+  public static final String GET_NAMESPACE_SQL = \"SELECT table_namespace FROM \" + SQL_TABLE_NAME +\n+      \" WHERE catalog_name = ? AND table_namespace LIKE ? LIMIT 1\";\n+  public static final String LIST_NAMESPACES_SQL = \"SELECT DISTINCT table_namespace FROM \" + SQL_TABLE_NAME +\n+      \" WHERE catalog_name = ? AND table_namespace LIKE ?\";\n+  public static final String JDBC_PARAM_PREFIX = \"connection.parameter.\";\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcCatalog.class);\n+  private static final Joiner SLASH = Joiner.on(\"/\");\n+\n+  private FileIO io;\n+  private String catalogName = \"jdbc\";\n+  private String warehouseLocation;\n+  private Configuration conf;\n+  private JdbcClientPool connections;\n+\n+  public JdbcCatalog() {\n+  }\n+\n+  @Override\n+  public void initialize(String name, Map<String, String> properties) {\n+    Preconditions.checkArgument(!properties.getOrDefault(CatalogProperties.HIVE_URI, \"\").isEmpty(),\n+        \"No connection url provided for jdbc catalog!\");\n+    Preconditions.checkArgument(!properties.getOrDefault(CatalogProperties.WAREHOUSE_LOCATION, \"\").isEmpty(),\n+        \"Cannot initialize Jdbc Catalog because warehousePath must not be null!\");\n+\n+    this.warehouseLocation = properties.get(CatalogProperties.WAREHOUSE_LOCATION).replaceAll(\"/$\", \"\");\n+    this.catalogName = name == null ? \"jdbc\" : name;\n+    String fileIOImpl = properties.get(CatalogProperties.FILE_IO_IMPL);\n+    this.io = fileIOImpl == null ?\n+        new HadoopFileIO(conf) :\n+        CatalogUtil.loadFileIO(fileIOImpl, properties, conf);\n+\n+    try {\n+      initializeConnection(properties);\n+    } catch (SQLTimeoutException e) {\n+      throw new UncheckedSQLException(\"Database Connection timeout!\", e);\n+    } catch (SQLTransientConnectionException | SQLNonTransientConnectionException e) {\n+      throw new UncheckedSQLException(\"Database Connection failed!\", e);\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(\"Failed to initialize catalog!\", e);\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted in call to initialize!\", e);\n+    }\n+  }\n+\n+  private void initializeConnection(Map<String, String> properties) throws SQLException, InterruptedException {\n+    LOG.debug(\"Connecting to Jdbc database {}\", properties.get(CatalogProperties.HIVE_URI));\n+    connections = new JdbcClientPool(properties.get(CatalogProperties.HIVE_URI), properties);\n+    initializeCatalogTables();\n+  }\n+\n+  private void initializeCatalogTables() throws InterruptedException, SQLException {\n+    // need to check multiple times because some databases are using different naming standard. ex: H2db keeping\n+    // table names as uppercase\n+\n+    boolean exists = connections.run(conn -> {\n+      boolean foundTable = false;\n+      DatabaseMetaData dbMeta = conn.getMetaData();\n+      ResultSet tables = dbMeta.getTables(null, null, SQL_TABLE_NAME, null);\n+      if (tables.next()) {\n+        foundTable = true;\n+      }\n+      tables.close();\n+      ResultSet tablesUpper = dbMeta.getTables(null, null, SQL_TABLE_NAME.toUpperCase(), null);\n+      if (tablesUpper.next()) {\n+        foundTable = true;\n+      }\n+      tablesUpper.close();\n+      ResultSet tablesLower = dbMeta.getTables(null, null, SQL_TABLE_NAME.toLowerCase(), null);\n+      if (tablesLower.next()) {\n+        foundTable = true;\n+      }\n+      tablesLower.close();\n+      return foundTable;\n+    });\n+\n+    // create table if not exits\n+    if (!exists) {\n+      connections.run(conn -> conn.prepareStatement(SQL_CREATE_CATALOG_TABLE).execute());\n+      LOG.debug(\"Created table {} to store iceberg tables!\", SQL_TABLE_NAME);\n+    }\n+  }\n+\n+  @Override\n+  protected TableOperations newTableOps(TableIdentifier tableIdentifier) {\n+    return new JdbcTableOperations(connections, io, catalogName, tableIdentifier);\n+  }\n+\n+  @Override\n+  protected String defaultWarehouseLocation(TableIdentifier table) {\n+    if (table.hasNamespace()) {\n+      return SLASH.join(warehouseLocation, SLASH.join(table.namespace().levels()), table.name());\n+    }\n+    return SLASH.join(warehouseLocation, table.name());\n+  }\n+\n+  @Override\n+  public boolean dropTable(TableIdentifier identifier, boolean purge) {\n+\n+    int deletedRecords;\n+    try {\n+      deletedRecords = connections.run(conn -> {\n+        try (PreparedStatement sql = conn.prepareStatement(DROP_TABLE_SQL)) {\n+          sql.setString(1, catalogName);\n+          sql.setString(2, JdbcUtil.namespaceToString(identifier.namespace()));\n+          sql.setString(3, identifier.name());\n+          return sql.executeUpdate();\n+        }\n+      });\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(\"Failed to drop \" + identifier, e);\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted in call to dropTable\", e);\n+    }\n+\n+    if (deletedRecords > 0) {\n+      LOG.debug(\"Successfully dropped table {}.\", identifier);\n+    } else {\n+      LOG.debug(\"Cannot drop table: {}! table not found in the catalog.\", identifier);\n+      return false;\n+    }\n+\n+    TableOperations ops = newTableOps(identifier);\n+    TableMetadata lastMetadata = ops.current();\n+\n+    if (purge && lastMetadata != null) {\n+      CatalogUtil.dropTableData(ops.io(), lastMetadata);\n+      LOG.info(\"Table {} data purged!\", identifier);\n+    }\n+    return true;\n+\n+  }\n+\n+  @Override\n+  public List<TableIdentifier> listTables(Namespace namespace) {\n+    if (!namespaceExists(namespace)) {\n+      throw new NoSuchNamespaceException(\"Namespace does not exist: %s\", namespace);\n+    }\n+\n+    try {\n+      return connections.run(conn -> {\n+        List<TableIdentifier> results = Lists.newArrayList();\n+        try (PreparedStatement sql = conn.prepareStatement(LIST_TABLES_SQL)) {\n+          sql.setString(1, catalogName);\n+          sql.setString(2, JdbcUtil.namespaceToString(namespace));\n+\n+          ResultSet rs = sql.executeQuery();\n+          while (rs.next()) {\n+            results.add(JdbcUtil.stringToTableIdentifier(rs.getString(\"table_namespace\"), rs.getString(\"table_name\")));\n+          }\n+\n+          return results;\n+        }\n+      });\n+\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(String.format(\"Failed to list tables in namespace: %s\", namespace), e);\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted during JDBC operation\", e);\n+    }\n+  }\n+\n+  @Override\n+  public void renameTable(TableIdentifier from, TableIdentifier to) {\n+    try {\n+      int updatedRecords = connections.run(conn -> {\n+        try (PreparedStatement sql = conn.prepareStatement(RENAME_TABLE_SQL)) {\n+          // SET\n+          sql.setString(1, JdbcUtil.namespaceToString(to.namespace()));\n+          sql.setString(2, to.name());\n+          // WHERE\n+          sql.setString(3, catalogName);\n+          sql.setString(4, JdbcUtil.namespaceToString(from.namespace()));\n+          sql.setString(5, from.name());\n+          return sql.executeUpdate();\n+        }\n+      });\n+\n+      if (updatedRecords == 1) {\n+        LOG.debug(\"Successfully renamed table from {} to {}!\", from, to);\n+      } else if (updatedRecords == 0) {\n+        throw new NoSuchTableException(\"Failed to rename table! Table '%s' not found in the catalog!\", from);\n+      } else {\n+        throw new RuntimeException(\"Failed to rename table! Rename operation Failed\");\n+      }\n+    } catch (SQLIntegrityConstraintViolationException e) {\n+      throw new AlreadyExistsException(\"Table with name '%s' already exists in the catalog!\", to);\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(\"Failed to rename table!\", e);\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted in call to rename\", e);\n+    }\n+  }\n+\n+  @Override\n+  public String name() {\n+    return catalogName;\n+  }\n+\n+  @Override\n+  public Configuration getConf() {\n+    return conf;\n+  }\n+\n+  @Override\n+  public void setConf(Configuration conf) {\n+    this.conf = conf;\n+  }\n+\n+  @Override\n+  public void createNamespace(Namespace namespace, Map<String, String> metadata) {\n+    throw new UnsupportedOperationException(\"Cannot create namespace \" + namespace +\n+        \": createNamespace is not supported\");\n+  }\n+\n+  @Override\n+  public List<Namespace> listNamespaces(Namespace namespace) throws NoSuchNamespaceException {\n+    if (!namespaceExists(namespace)) {\n+      throw new NoSuchNamespaceException(\"Namespace does not exist: %s\", namespace);\n+    }\n+    try {\n+\n+      List<Namespace> namespaces = connections.run(conn -> {\n+        List<Namespace> result = Lists.newArrayList();\n+\n+        try (PreparedStatement sql = conn.prepareStatement(LIST_NAMESPACES_SQL)) {\n+          sql.setString(1, catalogName);\n+          if (namespace.isEmpty()) {\n+            sql.setString(2, JdbcUtil.namespaceToString(namespace) + \"%\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "849b0d2a12b44102c02ba6b89fe45374ad7398ec"}, "originalPosition": 313}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjgwNjE5MQ==", "bodyText": "nit: seems like we are just using Path to join the two paths. Why not just use SLASH.join(warehouseLocation, SLASH.join(namespace.levels()))\nAlso, if this is the default namespace path, I think it is better to have its own method:\nprivate String defaultNamespaceLocation() {\n    return ....\n}", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r552806191", "createdAt": "2021-01-06T16:56:22Z", "author": {"login": "jackye1995"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,423 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.io.Closeable;\n+import java.sql.DatabaseMetaData;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.exceptions.UncheckedSQLException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, SupportsNamespaces, Closeable {\n+\n+  public static final String SQL_TABLE_NAME = \"iceberg_tables\";\n+  public static final String SQL_CREATE_CATALOG_TABLE =\n+      \"CREATE TABLE \" + SQL_TABLE_NAME +\n+          \"(catalog_name VARCHAR(1255) NOT NULL,\" +\n+          \"table_namespace VARCHAR(1255) NOT NULL,\" +\n+          \"table_name VARCHAR(1255) NOT NULL,\" +\n+          \"metadata_location VARCHAR(32768),\" +\n+          \"previous_metadata_location VARCHAR(32768),\" +\n+          \"PRIMARY KEY (catalog_name, table_namespace, table_name)\" +\n+          \")\";\n+  public static final String LOAD_TABLE_SQL = \"SELECT * FROM \" + SQL_TABLE_NAME +\n+      \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+  public static final String LIST_TABLES_SQL = \"SELECT * FROM \" + SQL_TABLE_NAME +\n+      \" WHERE catalog_name = ? AND table_namespace = ?\";\n+  public static final String RENAME_TABLE_SQL = \"UPDATE \" + SQL_TABLE_NAME +\n+      \" SET table_namespace = ? , table_name = ? \" +\n+      \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+  public static final String DROP_TABLE_SQL = \"DELETE FROM \" + SQL_TABLE_NAME +\n+      \" WHERE catalog_name = ? AND table_namespace = ? AND table_name = ? \";\n+  public static final String GET_NAMESPACE_SQL = \"SELECT table_namespace FROM \" + SQL_TABLE_NAME +\n+      \" WHERE catalog_name = ? AND table_namespace LIKE ? LIMIT 1\";\n+  public static final String LIST_NAMESPACES_SQL = \"SELECT DISTINCT table_namespace FROM \" + SQL_TABLE_NAME +\n+      \" WHERE catalog_name = ? AND table_namespace LIKE ?\";\n+  public static final String JDBC_PARAM_PREFIX = \"connection.parameter.\";\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcCatalog.class);\n+  private static final Joiner SLASH = Joiner.on(\"/\");\n+\n+  private FileIO io;\n+  private String catalogName = \"jdbc\";\n+  private String warehouseLocation;\n+  private Configuration conf;\n+  private JdbcClientPool connections;\n+\n+  public JdbcCatalog() {\n+  }\n+\n+  @Override\n+  public void initialize(String name, Map<String, String> properties) {\n+    Preconditions.checkArgument(!properties.getOrDefault(CatalogProperties.HIVE_URI, \"\").isEmpty(),\n+        \"No connection url provided for jdbc catalog!\");\n+    Preconditions.checkArgument(!properties.getOrDefault(CatalogProperties.WAREHOUSE_LOCATION, \"\").isEmpty(),\n+        \"Cannot initialize Jdbc Catalog because warehousePath must not be null!\");\n+\n+    this.warehouseLocation = properties.get(CatalogProperties.WAREHOUSE_LOCATION).replaceAll(\"/$\", \"\");\n+    this.catalogName = name == null ? \"jdbc\" : name;\n+    String fileIOImpl = properties.get(CatalogProperties.FILE_IO_IMPL);\n+    this.io = fileIOImpl == null ?\n+        new HadoopFileIO(conf) :\n+        CatalogUtil.loadFileIO(fileIOImpl, properties, conf);\n+\n+    try {\n+      initializeConnection(properties);\n+    } catch (SQLTimeoutException e) {\n+      throw new UncheckedSQLException(\"Database Connection timeout!\", e);\n+    } catch (SQLTransientConnectionException | SQLNonTransientConnectionException e) {\n+      throw new UncheckedSQLException(\"Database Connection failed!\", e);\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(\"Failed to initialize catalog!\", e);\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted in call to initialize!\", e);\n+    }\n+  }\n+\n+  private void initializeConnection(Map<String, String> properties) throws SQLException, InterruptedException {\n+    LOG.debug(\"Connecting to Jdbc database {}\", properties.get(CatalogProperties.HIVE_URI));\n+    connections = new JdbcClientPool(properties.get(CatalogProperties.HIVE_URI), properties);\n+    initializeCatalogTables();\n+  }\n+\n+  private void initializeCatalogTables() throws InterruptedException, SQLException {\n+    // need to check multiple times because some databases are using different naming standard. ex: H2db keeping\n+    // table names as uppercase\n+\n+    boolean exists = connections.run(conn -> {\n+      boolean foundTable = false;\n+      DatabaseMetaData dbMeta = conn.getMetaData();\n+      ResultSet tables = dbMeta.getTables(null, null, SQL_TABLE_NAME, null);\n+      if (tables.next()) {\n+        foundTable = true;\n+      }\n+      tables.close();\n+      ResultSet tablesUpper = dbMeta.getTables(null, null, SQL_TABLE_NAME.toUpperCase(), null);\n+      if (tablesUpper.next()) {\n+        foundTable = true;\n+      }\n+      tablesUpper.close();\n+      ResultSet tablesLower = dbMeta.getTables(null, null, SQL_TABLE_NAME.toLowerCase(), null);\n+      if (tablesLower.next()) {\n+        foundTable = true;\n+      }\n+      tablesLower.close();\n+      return foundTable;\n+    });\n+\n+    // create table if not exits\n+    if (!exists) {\n+      connections.run(conn -> conn.prepareStatement(SQL_CREATE_CATALOG_TABLE).execute());\n+      LOG.debug(\"Created table {} to store iceberg tables!\", SQL_TABLE_NAME);\n+    }\n+  }\n+\n+  @Override\n+  protected TableOperations newTableOps(TableIdentifier tableIdentifier) {\n+    return new JdbcTableOperations(connections, io, catalogName, tableIdentifier);\n+  }\n+\n+  @Override\n+  protected String defaultWarehouseLocation(TableIdentifier table) {\n+    if (table.hasNamespace()) {\n+      return SLASH.join(warehouseLocation, SLASH.join(table.namespace().levels()), table.name());\n+    }\n+    return SLASH.join(warehouseLocation, table.name());\n+  }\n+\n+  @Override\n+  public boolean dropTable(TableIdentifier identifier, boolean purge) {\n+\n+    int deletedRecords;\n+    try {\n+      deletedRecords = connections.run(conn -> {\n+        try (PreparedStatement sql = conn.prepareStatement(DROP_TABLE_SQL)) {\n+          sql.setString(1, catalogName);\n+          sql.setString(2, JdbcUtil.namespaceToString(identifier.namespace()));\n+          sql.setString(3, identifier.name());\n+          return sql.executeUpdate();\n+        }\n+      });\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(\"Failed to drop \" + identifier, e);\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted in call to dropTable\", e);\n+    }\n+\n+    if (deletedRecords > 0) {\n+      LOG.debug(\"Successfully dropped table {}.\", identifier);\n+    } else {\n+      LOG.debug(\"Cannot drop table: {}! table not found in the catalog.\", identifier);\n+      return false;\n+    }\n+\n+    TableOperations ops = newTableOps(identifier);\n+    TableMetadata lastMetadata = ops.current();\n+\n+    if (purge && lastMetadata != null) {\n+      CatalogUtil.dropTableData(ops.io(), lastMetadata);\n+      LOG.info(\"Table {} data purged!\", identifier);\n+    }\n+    return true;\n+\n+  }\n+\n+  @Override\n+  public List<TableIdentifier> listTables(Namespace namespace) {\n+    if (!namespaceExists(namespace)) {\n+      throw new NoSuchNamespaceException(\"Namespace does not exist: %s\", namespace);\n+    }\n+\n+    try {\n+      return connections.run(conn -> {\n+        List<TableIdentifier> results = Lists.newArrayList();\n+        try (PreparedStatement sql = conn.prepareStatement(LIST_TABLES_SQL)) {\n+          sql.setString(1, catalogName);\n+          sql.setString(2, JdbcUtil.namespaceToString(namespace));\n+\n+          ResultSet rs = sql.executeQuery();\n+          while (rs.next()) {\n+            results.add(JdbcUtil.stringToTableIdentifier(rs.getString(\"table_namespace\"), rs.getString(\"table_name\")));\n+          }\n+\n+          return results;\n+        }\n+      });\n+\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(String.format(\"Failed to list tables in namespace: %s\", namespace), e);\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted during JDBC operation\", e);\n+    }\n+  }\n+\n+  @Override\n+  public void renameTable(TableIdentifier from, TableIdentifier to) {\n+    try {\n+      int updatedRecords = connections.run(conn -> {\n+        try (PreparedStatement sql = conn.prepareStatement(RENAME_TABLE_SQL)) {\n+          // SET\n+          sql.setString(1, JdbcUtil.namespaceToString(to.namespace()));\n+          sql.setString(2, to.name());\n+          // WHERE\n+          sql.setString(3, catalogName);\n+          sql.setString(4, JdbcUtil.namespaceToString(from.namespace()));\n+          sql.setString(5, from.name());\n+          return sql.executeUpdate();\n+        }\n+      });\n+\n+      if (updatedRecords == 1) {\n+        LOG.debug(\"Successfully renamed table from {} to {}!\", from, to);\n+      } else if (updatedRecords == 0) {\n+        throw new NoSuchTableException(\"Failed to rename table! Table '%s' not found in the catalog!\", from);\n+      } else {\n+        throw new RuntimeException(\"Failed to rename table! Rename operation Failed\");\n+      }\n+    } catch (SQLIntegrityConstraintViolationException e) {\n+      throw new AlreadyExistsException(\"Table with name '%s' already exists in the catalog!\", to);\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(\"Failed to rename table!\", e);\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted in call to rename\", e);\n+    }\n+  }\n+\n+  @Override\n+  public String name() {\n+    return catalogName;\n+  }\n+\n+  @Override\n+  public Configuration getConf() {\n+    return conf;\n+  }\n+\n+  @Override\n+  public void setConf(Configuration conf) {\n+    this.conf = conf;\n+  }\n+\n+  @Override\n+  public void createNamespace(Namespace namespace, Map<String, String> metadata) {\n+    throw new UnsupportedOperationException(\"Cannot create namespace \" + namespace +\n+        \": createNamespace is not supported\");\n+  }\n+\n+  @Override\n+  public List<Namespace> listNamespaces(Namespace namespace) throws NoSuchNamespaceException {\n+    if (!namespaceExists(namespace)) {\n+      throw new NoSuchNamespaceException(\"Namespace does not exist: %s\", namespace);\n+    }\n+    try {\n+\n+      List<Namespace> namespaces = connections.run(conn -> {\n+        List<Namespace> result = Lists.newArrayList();\n+\n+        try (PreparedStatement sql = conn.prepareStatement(LIST_NAMESPACES_SQL)) {\n+          sql.setString(1, catalogName);\n+          if (namespace.isEmpty()) {\n+            sql.setString(2, JdbcUtil.namespaceToString(namespace) + \"%\");\n+          } else {\n+            sql.setString(2, JdbcUtil.namespaceToString(namespace) + \".%\");\n+          }\n+          ResultSet rs = sql.executeQuery();\n+          while (rs.next()) {\n+            result.add(JdbcUtil.stringToNamespace(rs.getString(\"table_namespace\")));\n+          }\n+          rs.close();\n+        }\n+\n+        return result;\n+      });\n+\n+      int subNamespaceLevelLength = namespace.levels().length + 1;\n+      namespaces = namespaces.stream()\n+          // exclude itself\n+          .filter(n -> !n.equals(namespace))\n+          // only get sub namespaces/children\n+          .map(n -> Namespace.of(\n+              Arrays.stream(n.levels()).limit(subNamespaceLevelLength).toArray(String[]::new)\n+              )\n+          )\n+          // remove duplicates\n+          .distinct()\n+          .collect(Collectors.toList());\n+\n+      LOG.debug(\"From the namespace '{}' found: {}\", namespace, namespaces);\n+      return namespaces;\n+\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted in call to listNamespaces(namespace) Namespace: \" + namespace, e);\n+    } catch (SQLException e) {\n+      throw new RuntimeException(\"Failed to list all namespace: \" + namespace + \" in catalog!\", e);\n+    }\n+  }\n+\n+  @Override\n+  public Map<String, String> loadNamespaceMetadata(Namespace namespace) throws NoSuchNamespaceException {\n+    if (!namespaceExists(namespace) || namespace.isEmpty()) {\n+      throw new NoSuchNamespaceException(\"Namespace does not exist: %s\", namespace);\n+    }\n+\n+    Path nsPath = new Path(warehouseLocation, SLASH.join(namespace.levels()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "849b0d2a12b44102c02ba6b89fe45374ad7398ec"}, "originalPosition": 357}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjgxNDE4Ng==", "bodyText": "Is this necessary?", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r552814186", "createdAt": "2021-01-06T17:05:23Z", "author": {"login": "jackye1995"}, "path": "core/src/test/resources/simplelogger.properties", "diffHunk": "@@ -0,0 +1,20 @@\n+# Licensed to the Apache Software Foundation (ASF) under one", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "849b0d2a12b44102c02ba6b89fe45374ad7398ec"}, "originalPosition": 1}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY2OTQ0MjEy", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-566944212", "createdAt": "2021-01-13T07:16:23Z", "commit": {"oid": "75079f3360208f71730c9b0df8c1fe535686a613"}, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QwNzoxNjoyM1rOISiPvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QwNzozMzowNVrOISisDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjMwNjM2Ng==", "bodyText": "The MPL license is a copyleft license, which means that in principle people are not allowed to distribute code that is under the MPL-2.0 license under different terms. The GPL licenses (including LGPL and AGPL) require that the entire application is distributed under the terms of the GPL license.\nI think we cannot use it. Could you switch to use https://mvnrepository.com/artifact/org.xerial/sqlite-jdbc?", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r556306366", "createdAt": "2021-01-13T07:16:23Z", "author": {"login": "jackye1995"}, "path": "build.gradle", "diffHunk": "@@ -231,6 +231,7 @@ project(':iceberg-core') {\n       exclude group: 'org.slf4j', module: 'slf4j-log4j12'\n     }\n \n+    testCompile \"com.h2database:h2\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcyNzY2Mg=="}, "originalCommit": {"oid": "b751492bb6cdfd48515d4519a41f60cdd95acabf"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjMwNjk1OQ==", "bodyText": "nit: unnecessary keyword protected", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r556306959", "createdAt": "2021-01-13T07:17:49Z", "author": {"login": "jackye1995"}, "path": "core/src/main/java/org/apache/iceberg/ClientPool.java", "diffHunk": "@@ -36,7 +36,7 @@\n   private volatile int currentSize;\n   private boolean closed;\n \n-  ClientPool(int poolSize, Class<? extends E> reconnectExc) {\n+  protected ClientPool(int poolSize, Class<? extends E> reconnectExc) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75079f3360208f71730c9b0df8c1fe535686a613"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjMwNzYxOA==", "bodyText": "I think this exception is specific to JDBC catalog and should be in the core jdbc package path.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r556307618", "createdAt": "2021-01-13T07:19:27Z", "author": {"login": "jackye1995"}, "path": "api/src/main/java/org/apache/iceberg/exceptions/UncheckedSQLException.java", "diffHunk": "@@ -0,0 +1,29 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.exceptions;\n+\n+import java.sql.SQLException;\n+\n+public class UncheckedSQLException extends RuntimeException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75079f3360208f71730c9b0df8c1fe535686a613"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjMwOTAyNw==", "bodyText": "This needs to be public, so that users can import this variable to set their custom properties.\nto be consistent with the name CatalogProperties, this should be named PROPERTY_PREFIX, so that users can use JdbcCatalog.PROPERTY_PREFIX.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r556309027", "createdAt": "2021-01-13T07:23:03Z", "author": {"login": "jackye1995"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,404 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.io.Closeable;\n+import java.sql.DatabaseMetaData;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.exceptions.UncheckedSQLException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, SupportsNamespaces, Closeable {\n+\n+  protected static final String JDBC_PARAM_PREFIX = \"connection.parameter.\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75079f3360208f71730c9b0df8c1fe535686a613"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjMxMDE0Nw==", "bodyText": "This do not need to be public", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r556310147", "createdAt": "2021-01-13T07:25:30Z", "author": {"login": "jackye1995"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcClientPool.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.SQLException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.util.Map;\n+import java.util.Properties;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.ClientPool;\n+import org.apache.iceberg.exceptions.UncheckedSQLException;\n+\n+public class JdbcClientPool extends ClientPool<Connection, SQLException> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75079f3360208f71730c9b0df8c1fe535686a613"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjMxMDc1MQ==", "bodyText": "This do not need to be public", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r556310751", "createdAt": "2021-01-13T07:26:43Z", "author": {"login": "jackye1995"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcClientPool.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.SQLException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.util.Map;\n+import java.util.Properties;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.ClientPool;\n+import org.apache.iceberg.exceptions.UncheckedSQLException;\n+\n+public class JdbcClientPool extends ClientPool<Connection, SQLException> {\n+\n+  private final String dbUrl;\n+  private final Map<String, String> properties;\n+\n+  JdbcClientPool(String dbUrl, Map<String, String> props) {\n+    this(Integer.parseInt(props.getOrDefault(CatalogProperties.HIVE_CLIENT_POOL_SIZE,\n+        String.valueOf(CatalogProperties.HIVE_CLIENT_POOL_SIZE_DEFAULT))), dbUrl, props);\n+  }\n+\n+  public JdbcClientPool(int poolSize, String dbUrl, Map<String, String> props) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75079f3360208f71730c9b0df8c1fe535686a613"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjMxMDkzMA==", "bodyText": "why not use your UncheckedSQLException?", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r556310930", "createdAt": "2021-01-13T07:27:05Z", "author": {"login": "jackye1995"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcClientPool.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.SQLException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.util.Map;\n+import java.util.Properties;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.ClientPool;\n+import org.apache.iceberg.exceptions.UncheckedSQLException;\n+\n+public class JdbcClientPool extends ClientPool<Connection, SQLException> {\n+\n+  private final String dbUrl;\n+  private final Map<String, String> properties;\n+\n+  JdbcClientPool(String dbUrl, Map<String, String> props) {\n+    this(Integer.parseInt(props.getOrDefault(CatalogProperties.HIVE_CLIENT_POOL_SIZE,\n+        String.valueOf(CatalogProperties.HIVE_CLIENT_POOL_SIZE_DEFAULT))), dbUrl, props);\n+  }\n+\n+  public JdbcClientPool(int poolSize, String dbUrl, Map<String, String> props) {\n+    super(poolSize, SQLNonTransientConnectionException.class);\n+    properties = props;\n+    this.dbUrl = dbUrl;\n+  }\n+\n+  @Override\n+  protected Connection newClient() {\n+    try {\n+      Properties dbProps = new Properties();\n+      properties.forEach((key, value) -> dbProps.put(key.replace(JdbcCatalog.JDBC_PARAM_PREFIX, \"\"), value));\n+      return DriverManager.getConnection(dbUrl, dbProps);\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(\"Failed to connect: \" + dbUrl, e);\n+    }\n+  }\n+\n+  @Override\n+  protected Connection reconnect(Connection client) {\n+    close(client);\n+    return newClient();\n+  }\n+\n+  @Override\n+  protected void close(Connection client) {\n+    try {\n+      client.close();\n+    } catch (SQLException e) {\n+      throw new RuntimeException(\"Failed to connect to database!\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75079f3360208f71730c9b0df8c1fe535686a613"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjMxMjAwMg==", "bodyText": "nit: Failed to get table %s from catalog %s, tableIdentifier, catalogName sounds better, also for other similar error messages below.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r556312002", "createdAt": "2021-01-13T07:29:38Z", "author": {"login": "jackye1995"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcTableOperations.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.sql.DataTruncation;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.sql.SQLWarning;\n+import java.util.Map;\n+import java.util.Objects;\n+import org.apache.iceberg.BaseMetastoreTableOperations;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.CommitFailedException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.exceptions.UncheckedSQLException;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+class JdbcTableOperations extends BaseMetastoreTableOperations {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcTableOperations.class);\n+  private final String catalogName;\n+  private final TableIdentifier tableIdentifier;\n+  private final FileIO fileIO;\n+  private final JdbcClientPool connections;\n+\n+  protected JdbcTableOperations(JdbcClientPool dbConnPool, FileIO fileIO, String catalogName,\n+                                TableIdentifier tableIdentifier) {\n+    this.catalogName = catalogName;\n+    this.tableIdentifier = tableIdentifier;\n+    this.fileIO = fileIO;\n+    this.connections = dbConnPool;\n+  }\n+\n+  @Override\n+  public void doRefresh() {\n+    Map<String, String> table;\n+\n+    try {\n+      table = getTable();\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted during refresh\", e);\n+    } catch (SQLException e) {\n+      // unknown exception happened when getting table from catalog\n+      throw new UncheckedSQLException(String.format(\"Failed to get table from catalog %s.%s\", catalogName,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75079f3360208f71730c9b0df8c1fe535686a613"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjMxMjc5Nw==", "bodyText": "\"metadata_location\" should be a static variable", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r556312797", "createdAt": "2021-01-13T07:31:21Z", "author": {"login": "jackye1995"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcTableOperations.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.sql.DataTruncation;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.sql.SQLWarning;\n+import java.util.Map;\n+import java.util.Objects;\n+import org.apache.iceberg.BaseMetastoreTableOperations;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.CommitFailedException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.exceptions.UncheckedSQLException;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+class JdbcTableOperations extends BaseMetastoreTableOperations {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcTableOperations.class);\n+  private final String catalogName;\n+  private final TableIdentifier tableIdentifier;\n+  private final FileIO fileIO;\n+  private final JdbcClientPool connections;\n+\n+  protected JdbcTableOperations(JdbcClientPool dbConnPool, FileIO fileIO, String catalogName,\n+                                TableIdentifier tableIdentifier) {\n+    this.catalogName = catalogName;\n+    this.tableIdentifier = tableIdentifier;\n+    this.fileIO = fileIO;\n+    this.connections = dbConnPool;\n+  }\n+\n+  @Override\n+  public void doRefresh() {\n+    Map<String, String> table;\n+\n+    try {\n+      table = getTable();\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted during refresh\", e);\n+    } catch (SQLException e) {\n+      // unknown exception happened when getting table from catalog\n+      throw new UncheckedSQLException(String.format(\"Failed to get table from catalog %s.%s\", catalogName,\n+          tableIdentifier), e);\n+    }\n+\n+    // Table not exists AND currentMetadataLocation is not NULL!\n+    if (table.isEmpty() && currentMetadataLocation() != null) {\n+      throw new NoSuchTableException(\"Failed to get table from catalog %s.%s!\" +\n+          \" maybe another process deleted it!\", catalogName, tableIdentifier);\n+    }\n+\n+    // Table not exists in the catalog! metadataLocation is null here!\n+    if (table.isEmpty()) {\n+      refreshFromMetadataLocation(null);\n+      return;\n+    }\n+\n+    // Table exists but metadataLocation is null\n+    if (table.getOrDefault(\"metadata_location\", null) == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75079f3360208f71730c9b0df8c1fe535686a613"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjMxMzYxMw==", "bodyText": "method too long, prefer to separate to smaller methods like updateTable and createTable based on exist condition.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r556313613", "createdAt": "2021-01-13T07:33:05Z", "author": {"login": "jackye1995"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcTableOperations.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.sql.DataTruncation;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.sql.SQLWarning;\n+import java.util.Map;\n+import java.util.Objects;\n+import org.apache.iceberg.BaseMetastoreTableOperations;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.CommitFailedException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.exceptions.UncheckedSQLException;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+class JdbcTableOperations extends BaseMetastoreTableOperations {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcTableOperations.class);\n+  private final String catalogName;\n+  private final TableIdentifier tableIdentifier;\n+  private final FileIO fileIO;\n+  private final JdbcClientPool connections;\n+\n+  protected JdbcTableOperations(JdbcClientPool dbConnPool, FileIO fileIO, String catalogName,\n+                                TableIdentifier tableIdentifier) {\n+    this.catalogName = catalogName;\n+    this.tableIdentifier = tableIdentifier;\n+    this.fileIO = fileIO;\n+    this.connections = dbConnPool;\n+  }\n+\n+  @Override\n+  public void doRefresh() {\n+    Map<String, String> table;\n+\n+    try {\n+      table = getTable();\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted during refresh\", e);\n+    } catch (SQLException e) {\n+      // unknown exception happened when getting table from catalog\n+      throw new UncheckedSQLException(String.format(\"Failed to get table from catalog %s.%s\", catalogName,\n+          tableIdentifier), e);\n+    }\n+\n+    // Table not exists AND currentMetadataLocation is not NULL!\n+    if (table.isEmpty() && currentMetadataLocation() != null) {\n+      throw new NoSuchTableException(\"Failed to get table from catalog %s.%s!\" +\n+          \" maybe another process deleted it!\", catalogName, tableIdentifier);\n+    }\n+\n+    // Table not exists in the catalog! metadataLocation is null here!\n+    if (table.isEmpty()) {\n+      refreshFromMetadataLocation(null);\n+      return;\n+    }\n+\n+    // Table exists but metadataLocation is null\n+    if (table.getOrDefault(\"metadata_location\", null) == null) {\n+      throw new RuntimeException(String.format(\"Failed to get metadata location if the table %s.%s\", catalogName,\n+          tableIdentifier));\n+    }\n+\n+    refreshFromMetadataLocation(table.get(\"metadata_location\"));\n+  }\n+\n+  @Override\n+  public void doCommit(TableMetadata base, TableMetadata metadata) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75079f3360208f71730c9b0df8c1fe535686a613"}, "originalPosition": 98}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY3ODQ2MzA5", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-567846309", "createdAt": "2021-01-14T04:37:55Z", "commit": {"oid": "e1cee5e8b26fdebae8b0e423ce9430b6bad5165c"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQwNDozNzo1NVrOITO-IQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQwNTowNDozN1rOITPYZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzAzOTEzNw==", "bodyText": "Since this is now used by more than Hive, it does not make sense to say HIVE_URI now. Let me update that in another PR so that you can rebase it.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r557039137", "createdAt": "2021-01-14T04:37:55Z", "author": {"login": "jackye1995"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,403 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.io.Closeable;\n+import java.sql.DatabaseMetaData;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, SupportsNamespaces, Closeable {\n+\n+  public static final String PROPERTY_PREFIX = \"connection.parameter.\";\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcCatalog.class);\n+  private static final Joiner SLASH = Joiner.on(\"/\");\n+\n+  private FileIO io;\n+  private String catalogName = \"jdbc\";\n+  private String warehouseLocation;\n+  private Configuration conf;\n+  private JdbcClientPool connections;\n+\n+  public JdbcCatalog() {\n+  }\n+\n+  @Override\n+  public void initialize(String name, Map<String, String> properties) {\n+    Preconditions.checkArgument(!properties.getOrDefault(CatalogProperties.HIVE_URI, \"\").isEmpty(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1cee5e8b26fdebae8b0e423ce9430b6bad5165c"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzAzOTg1NQ==", "bodyText": "warehouse location is stored in the next line, so it make sense to first do this.warehouseLocation = properties.getOrDefault(CatalogProperties.WAREHOUSE_LOCATION, \"\").replaceAll(\"/$\", \"\"), and then do all the condition checks against this.warehouseLocation.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r557039855", "createdAt": "2021-01-14T04:40:51Z", "author": {"login": "jackye1995"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,403 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.io.Closeable;\n+import java.sql.DatabaseMetaData;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, SupportsNamespaces, Closeable {\n+\n+  public static final String PROPERTY_PREFIX = \"connection.parameter.\";\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcCatalog.class);\n+  private static final Joiner SLASH = Joiner.on(\"/\");\n+\n+  private FileIO io;\n+  private String catalogName = \"jdbc\";\n+  private String warehouseLocation;\n+  private Configuration conf;\n+  private JdbcClientPool connections;\n+\n+  public JdbcCatalog() {\n+  }\n+\n+  @Override\n+  public void initialize(String name, Map<String, String> properties) {\n+    Preconditions.checkArgument(!properties.getOrDefault(CatalogProperties.HIVE_URI, \"\").isEmpty(),\n+        \"No connection url provided for jdbc catalog!\");\n+    Preconditions.checkArgument(!properties.getOrDefault(CatalogProperties.WAREHOUSE_LOCATION, \"\").isEmpty(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1cee5e8b26fdebae8b0e423ce9430b6bad5165c"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzA0MDA4NQ==", "bodyText": "catalogName is already jdbc if not set, so only need to do a if statement.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r557040085", "createdAt": "2021-01-14T04:41:45Z", "author": {"login": "jackye1995"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,403 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.io.Closeable;\n+import java.sql.DatabaseMetaData;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, SupportsNamespaces, Closeable {\n+\n+  public static final String PROPERTY_PREFIX = \"connection.parameter.\";\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcCatalog.class);\n+  private static final Joiner SLASH = Joiner.on(\"/\");\n+\n+  private FileIO io;\n+  private String catalogName = \"jdbc\";\n+  private String warehouseLocation;\n+  private Configuration conf;\n+  private JdbcClientPool connections;\n+\n+  public JdbcCatalog() {\n+  }\n+\n+  @Override\n+  public void initialize(String name, Map<String, String> properties) {\n+    Preconditions.checkArgument(!properties.getOrDefault(CatalogProperties.HIVE_URI, \"\").isEmpty(),\n+        \"No connection url provided for jdbc catalog!\");\n+    Preconditions.checkArgument(!properties.getOrDefault(CatalogProperties.WAREHOUSE_LOCATION, \"\").isEmpty(),\n+        \"Cannot initialize Jdbc Catalog because warehousePath must not be null!\");\n+\n+    this.warehouseLocation = properties.get(CatalogProperties.WAREHOUSE_LOCATION).replaceAll(\"/$\", \"\");\n+    this.catalogName = name == null ? \"jdbc\" : name;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1cee5e8b26fdebae8b0e423ce9430b6bad5165c"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzA0MTMxOA==", "bodyText": "I think CATALOG_TABLE_NAME is a better name, in case we will introduce other tables in the future.\nAlso as discussed above, I think we can use upper case for the table name.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r557041318", "createdAt": "2021-01-14T04:46:52Z", "author": {"login": "jackye1995"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcUtil.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.relocated.com.google.common.base.Splitter;\n+import org.apache.iceberg.relocated.com.google.common.collect.Iterables;\n+\n+public final class JdbcUtil {\n+  protected static final String SQL_TABLE_NAME = \"iceberg_tables\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1cee5e8b26fdebae8b0e423ce9430b6bad5165c"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzA0NDY5NQ==", "bodyText": "I just verified, postgres can accept all upper letter table name in queries. The table name is case insensitve anyway in SQL standard. So I think it is better to only check for upper case table name. Also change SQL_TABLE_NAME value to upper case.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r557044695", "createdAt": "2021-01-14T04:59:34Z", "author": {"login": "jackye1995"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,403 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.io.Closeable;\n+import java.sql.DatabaseMetaData;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, SupportsNamespaces, Closeable {\n+\n+  public static final String PROPERTY_PREFIX = \"connection.parameter.\";\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcCatalog.class);\n+  private static final Joiner SLASH = Joiner.on(\"/\");\n+\n+  private FileIO io;\n+  private String catalogName = \"jdbc\";\n+  private String warehouseLocation;\n+  private Configuration conf;\n+  private JdbcClientPool connections;\n+\n+  public JdbcCatalog() {\n+  }\n+\n+  @Override\n+  public void initialize(String name, Map<String, String> properties) {\n+    Preconditions.checkArgument(!properties.getOrDefault(CatalogProperties.HIVE_URI, \"\").isEmpty(),\n+        \"No connection url provided for jdbc catalog!\");\n+    Preconditions.checkArgument(!properties.getOrDefault(CatalogProperties.WAREHOUSE_LOCATION, \"\").isEmpty(),\n+        \"Cannot initialize Jdbc Catalog because warehousePath must not be null!\");\n+\n+    this.warehouseLocation = properties.get(CatalogProperties.WAREHOUSE_LOCATION).replaceAll(\"/$\", \"\");\n+    this.catalogName = name == null ? \"jdbc\" : name;\n+    String fileIOImpl = properties.get(CatalogProperties.FILE_IO_IMPL);\n+    this.io = fileIOImpl == null ?\n+        new HadoopFileIO(conf) :\n+        CatalogUtil.loadFileIO(fileIOImpl, properties, conf);\n+\n+    try {\n+      initializeConnection(properties);\n+    } catch (SQLTimeoutException e) {\n+      throw new UncheckedSQLException(\"Database Connection timeout!\", e);\n+    } catch (SQLTransientConnectionException | SQLNonTransientConnectionException e) {\n+      throw new UncheckedSQLException(\"Database Connection failed!\", e);\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(\"Failed to initialize catalog!\", e);\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted in call to initialize!\", e);\n+    }\n+  }\n+\n+  private void initializeConnection(Map<String, String> properties) throws SQLException, InterruptedException {\n+    LOG.debug(\"Connecting to Jdbc database {}\", properties.get(CatalogProperties.HIVE_URI));\n+    connections = new JdbcClientPool(properties.get(CatalogProperties.HIVE_URI), properties);\n+    initializeCatalogTables();\n+  }\n+\n+  private void initializeCatalogTables() throws InterruptedException, SQLException {\n+    // need to check multiple times because some databases are using different naming standard.\n+    // ex: H2db keeping table names as uppercase, PostgreSQL is keeping lowercase", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1cee5e8b26fdebae8b0e423ce9430b6bad5165c"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzA0NTA1MQ==", "bodyText": "nit: space after if statement", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r557045051", "createdAt": "2021-01-14T05:01:01Z", "author": {"login": "jackye1995"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,403 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.io.Closeable;\n+import java.sql.DatabaseMetaData;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, SupportsNamespaces, Closeable {\n+\n+  public static final String PROPERTY_PREFIX = \"connection.parameter.\";\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcCatalog.class);\n+  private static final Joiner SLASH = Joiner.on(\"/\");\n+\n+  private FileIO io;\n+  private String catalogName = \"jdbc\";\n+  private String warehouseLocation;\n+  private Configuration conf;\n+  private JdbcClientPool connections;\n+\n+  public JdbcCatalog() {\n+  }\n+\n+  @Override\n+  public void initialize(String name, Map<String, String> properties) {\n+    Preconditions.checkArgument(!properties.getOrDefault(CatalogProperties.HIVE_URI, \"\").isEmpty(),\n+        \"No connection url provided for jdbc catalog!\");\n+    Preconditions.checkArgument(!properties.getOrDefault(CatalogProperties.WAREHOUSE_LOCATION, \"\").isEmpty(),\n+        \"Cannot initialize Jdbc Catalog because warehousePath must not be null!\");\n+\n+    this.warehouseLocation = properties.get(CatalogProperties.WAREHOUSE_LOCATION).replaceAll(\"/$\", \"\");\n+    this.catalogName = name == null ? \"jdbc\" : name;\n+    String fileIOImpl = properties.get(CatalogProperties.FILE_IO_IMPL);\n+    this.io = fileIOImpl == null ?\n+        new HadoopFileIO(conf) :\n+        CatalogUtil.loadFileIO(fileIOImpl, properties, conf);\n+\n+    try {\n+      initializeConnection(properties);\n+    } catch (SQLTimeoutException e) {\n+      throw new UncheckedSQLException(\"Database Connection timeout!\", e);\n+    } catch (SQLTransientConnectionException | SQLNonTransientConnectionException e) {\n+      throw new UncheckedSQLException(\"Database Connection failed!\", e);\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(\"Failed to initialize catalog!\", e);\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted in call to initialize!\", e);\n+    }\n+  }\n+\n+  private void initializeConnection(Map<String, String> properties) throws SQLException, InterruptedException {\n+    LOG.debug(\"Connecting to Jdbc database {}\", properties.get(CatalogProperties.HIVE_URI));\n+    connections = new JdbcClientPool(properties.get(CatalogProperties.HIVE_URI), properties);\n+    initializeCatalogTables();\n+  }\n+\n+  private void initializeCatalogTables() throws InterruptedException, SQLException {\n+    // need to check multiple times because some databases are using different naming standard.\n+    // ex: H2db keeping table names as uppercase, PostgreSQL is keeping lowercase\n+\n+    boolean exists = connections.run(conn -> {\n+      boolean foundTable = false;\n+      DatabaseMetaData dbMeta = conn.getMetaData();\n+      ResultSet tables = dbMeta.getTables(null, null, JdbcUtil.SQL_TABLE_NAME, null);\n+      if (tables.next()) {\n+        foundTable = true;\n+      }\n+      tables.close();\n+      ResultSet tablesUpper = dbMeta.getTables(null, null, JdbcUtil.SQL_TABLE_NAME.toUpperCase(), null);\n+      if (tablesUpper.next()) {\n+        foundTable = true;\n+      }\n+      tablesUpper.close();\n+      ResultSet tablesLower = dbMeta.getTables(null, null, JdbcUtil.SQL_TABLE_NAME.toLowerCase(), null);\n+      if (tablesLower.next()) {\n+        foundTable = true;\n+      }\n+      tablesLower.close();\n+      return foundTable;\n+    });\n+\n+    // create table if not exits\n+    if (!exists) {\n+      connections.run(conn -> conn.prepareStatement(JdbcUtil.SQL_CREATE_CATALOG_TABLE).execute());\n+      LOG.debug(\"Created table {} to store iceberg tables!\", JdbcUtil.SQL_TABLE_NAME);\n+    }\n+  }\n+\n+  @Override\n+  protected TableOperations newTableOps(TableIdentifier tableIdentifier) {\n+    return new JdbcTableOperations(connections, io, catalogName, tableIdentifier);\n+  }\n+\n+  @Override\n+  protected String defaultWarehouseLocation(TableIdentifier table) {\n+    if (table.hasNamespace()) {\n+      return SLASH.join(defaultNamespaceLocation(table.namespace()), table.name());\n+    }\n+    return SLASH.join(defaultNamespaceLocation(table.namespace()), table.name());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1cee5e8b26fdebae8b0e423ce9430b6bad5165c"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzA0NTA5MQ==", "bodyText": "nit: space after if statement", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r557045091", "createdAt": "2021-01-14T05:01:09Z", "author": {"login": "jackye1995"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,403 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.io.Closeable;\n+import java.sql.DatabaseMetaData;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, SupportsNamespaces, Closeable {\n+\n+  public static final String PROPERTY_PREFIX = \"connection.parameter.\";\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcCatalog.class);\n+  private static final Joiner SLASH = Joiner.on(\"/\");\n+\n+  private FileIO io;\n+  private String catalogName = \"jdbc\";\n+  private String warehouseLocation;\n+  private Configuration conf;\n+  private JdbcClientPool connections;\n+\n+  public JdbcCatalog() {\n+  }\n+\n+  @Override\n+  public void initialize(String name, Map<String, String> properties) {\n+    Preconditions.checkArgument(!properties.getOrDefault(CatalogProperties.HIVE_URI, \"\").isEmpty(),\n+        \"No connection url provided for jdbc catalog!\");\n+    Preconditions.checkArgument(!properties.getOrDefault(CatalogProperties.WAREHOUSE_LOCATION, \"\").isEmpty(),\n+        \"Cannot initialize Jdbc Catalog because warehousePath must not be null!\");\n+\n+    this.warehouseLocation = properties.get(CatalogProperties.WAREHOUSE_LOCATION).replaceAll(\"/$\", \"\");\n+    this.catalogName = name == null ? \"jdbc\" : name;\n+    String fileIOImpl = properties.get(CatalogProperties.FILE_IO_IMPL);\n+    this.io = fileIOImpl == null ?\n+        new HadoopFileIO(conf) :\n+        CatalogUtil.loadFileIO(fileIOImpl, properties, conf);\n+\n+    try {\n+      initializeConnection(properties);\n+    } catch (SQLTimeoutException e) {\n+      throw new UncheckedSQLException(\"Database Connection timeout!\", e);\n+    } catch (SQLTransientConnectionException | SQLNonTransientConnectionException e) {\n+      throw new UncheckedSQLException(\"Database Connection failed!\", e);\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(\"Failed to initialize catalog!\", e);\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted in call to initialize!\", e);\n+    }\n+  }\n+\n+  private void initializeConnection(Map<String, String> properties) throws SQLException, InterruptedException {\n+    LOG.debug(\"Connecting to Jdbc database {}\", properties.get(CatalogProperties.HIVE_URI));\n+    connections = new JdbcClientPool(properties.get(CatalogProperties.HIVE_URI), properties);\n+    initializeCatalogTables();\n+  }\n+\n+  private void initializeCatalogTables() throws InterruptedException, SQLException {\n+    // need to check multiple times because some databases are using different naming standard.\n+    // ex: H2db keeping table names as uppercase, PostgreSQL is keeping lowercase\n+\n+    boolean exists = connections.run(conn -> {\n+      boolean foundTable = false;\n+      DatabaseMetaData dbMeta = conn.getMetaData();\n+      ResultSet tables = dbMeta.getTables(null, null, JdbcUtil.SQL_TABLE_NAME, null);\n+      if (tables.next()) {\n+        foundTable = true;\n+      }\n+      tables.close();\n+      ResultSet tablesUpper = dbMeta.getTables(null, null, JdbcUtil.SQL_TABLE_NAME.toUpperCase(), null);\n+      if (tablesUpper.next()) {\n+        foundTable = true;\n+      }\n+      tablesUpper.close();\n+      ResultSet tablesLower = dbMeta.getTables(null, null, JdbcUtil.SQL_TABLE_NAME.toLowerCase(), null);\n+      if (tablesLower.next()) {\n+        foundTable = true;\n+      }\n+      tablesLower.close();\n+      return foundTable;\n+    });\n+\n+    // create table if not exits\n+    if (!exists) {\n+      connections.run(conn -> conn.prepareStatement(JdbcUtil.SQL_CREATE_CATALOG_TABLE).execute());\n+      LOG.debug(\"Created table {} to store iceberg tables!\", JdbcUtil.SQL_TABLE_NAME);\n+    }\n+  }\n+\n+  @Override\n+  protected TableOperations newTableOps(TableIdentifier tableIdentifier) {\n+    return new JdbcTableOperations(connections, io, catalogName, tableIdentifier);\n+  }\n+\n+  @Override\n+  protected String defaultWarehouseLocation(TableIdentifier table) {\n+    if (table.hasNamespace()) {\n+      return SLASH.join(defaultNamespaceLocation(table.namespace()), table.name());\n+    }\n+    return SLASH.join(defaultNamespaceLocation(table.namespace()), table.name());\n+  }\n+\n+  @Override\n+  public boolean dropTable(TableIdentifier identifier, boolean purge) {\n+\n+    int deletedRecords;\n+    try {\n+      deletedRecords = connections.run(conn -> {\n+        try (PreparedStatement sql = conn.prepareStatement(JdbcUtil.DROP_TABLE_SQL)) {\n+          sql.setString(1, catalogName);\n+          sql.setString(2, JdbcUtil.namespaceToString(identifier.namespace()));\n+          sql.setString(3, identifier.name());\n+          return sql.executeUpdate();\n+        }\n+      });\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(\"Failed to drop \" + identifier, e);\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted in call to dropTable\", e);\n+    }\n+\n+    if (deletedRecords > 0) {\n+      LOG.debug(\"Successfully dropped table {}.\", identifier);\n+    } else {\n+      LOG.debug(\"Cannot drop table: {}! table not found in the catalog.\", identifier);\n+      return false;\n+    }\n+\n+    TableOperations ops = newTableOps(identifier);\n+    TableMetadata lastMetadata = ops.current();\n+\n+    if (purge && lastMetadata != null) {\n+      CatalogUtil.dropTableData(ops.io(), lastMetadata);\n+      LOG.info(\"Table {} data purged!\", identifier);\n+    }\n+    return true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1cee5e8b26fdebae8b0e423ce9430b6bad5165c"}, "originalPosition": 187}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzA0NTcwMQ==", "bodyText": "should indicate this is a create table operation, maybe message can be fail to create the table .... Same for the update table exception above.", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r557045701", "createdAt": "2021-01-14T05:03:51Z", "author": {"login": "jackye1995"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcTableOperations.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.sql.DataTruncation;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.sql.SQLWarning;\n+import java.util.Map;\n+import java.util.Objects;\n+import org.apache.iceberg.BaseMetastoreTableOperations;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.CommitFailedException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+class JdbcTableOperations extends BaseMetastoreTableOperations {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcTableOperations.class);\n+  private final String catalogName;\n+  private final TableIdentifier tableIdentifier;\n+  private final FileIO fileIO;\n+  private final JdbcClientPool connections;\n+\n+  protected JdbcTableOperations(JdbcClientPool dbConnPool, FileIO fileIO, String catalogName,\n+                                TableIdentifier tableIdentifier) {\n+    this.catalogName = catalogName;\n+    this.tableIdentifier = tableIdentifier;\n+    this.fileIO = fileIO;\n+    this.connections = dbConnPool;\n+  }\n+\n+  @Override\n+  public void doRefresh() {\n+    Map<String, String> table;\n+\n+    try {\n+      table = getTable();\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted during refresh\", e);\n+    } catch (SQLException e) {\n+      // unknown exception happened when getting table from catalog\n+      throw new UncheckedSQLException(\n+          String.format(\"Failed to get table %s from catalog %s\", tableIdentifier, catalogName), e);\n+    }\n+\n+    // Table not exists AND currentMetadataLocation is not NULL!\n+    if (table.isEmpty() && currentMetadataLocation() != null) {\n+      throw new NoSuchTableException(\"Failed to get table %s from catalog %s!\" +\n+          \" maybe another process deleted it!\", tableIdentifier, catalogName);\n+    }\n+\n+    // Table not exists in the catalog! metadataLocation is null here!\n+    if (table.isEmpty()) {\n+      refreshFromMetadataLocation(null);\n+      return;\n+    }\n+\n+    // Table exists but metadataLocation is null\n+    if (table.getOrDefault(\"metadata_location\", null) == null) {\n+      throw new RuntimeException(String.format(\"Failed to get metadata location of the table %s from catalog %s\",\n+          tableIdentifier, catalogName));\n+    }\n+\n+    refreshFromMetadataLocation(table.get(\"metadata_location\"));\n+  }\n+\n+  @Override\n+  public void doCommit(TableMetadata base, TableMetadata metadata) {\n+    String newMetadataLocation = writeNewMetadata(metadata, currentVersion() + 1);\n+    try {\n+      Map<String, String> table = getTable();\n+\n+      if (!table.isEmpty()) {\n+        validateMetadataLocation(table, base);\n+        String oldMetadataLocation = base.metadataFileLocation();\n+        // Start atomic update\n+        updateTable(newMetadataLocation, oldMetadataLocation);\n+      } else {\n+        // table not exists create it!\n+        createTable(newMetadataLocation);\n+      }\n+\n+    } catch (SQLIntegrityConstraintViolationException e) {\n+      throw new AlreadyExistsException(e, \"Table already exists! maybe another process created it!\");\n+    } catch (SQLTimeoutException e) {\n+      throw new UncheckedSQLException(\"Database Connection timeout!\", e);\n+    } catch (SQLTransientConnectionException | SQLNonTransientConnectionException e) {\n+      throw new UncheckedSQLException(\"Database Connection failed!\", e);\n+    } catch (DataTruncation e) {\n+      throw new UncheckedSQLException(\"Database data truncation error!\", e);\n+    } catch (SQLWarning e) {\n+      throw new UncheckedSQLException(\"Database warning!\", e);\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(\"Failed to connect to database!\", e);\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted during commit\", e);\n+    }\n+  }\n+\n+  private void updateTable(String newMetadataLocation, String oldMetadataLocation)\n+      throws SQLException, InterruptedException {\n+    int updatedRecords = connections.run(conn -> {\n+      try (PreparedStatement sql = conn.prepareStatement(JdbcUtil.DO_COMMIT_SQL)) {\n+        // UPDATE\n+        sql.setString(1, newMetadataLocation);\n+        sql.setString(2, oldMetadataLocation);\n+        // WHERE\n+        sql.setString(3, catalogName);\n+        sql.setString(4, JdbcUtil.namespaceToString(tableIdentifier.namespace()));\n+        sql.setString(5, tableIdentifier.name());\n+        sql.setString(6, oldMetadataLocation);\n+        return sql.executeUpdate();\n+      }\n+    });\n+\n+    if (updatedRecords == 1) {\n+      LOG.debug(\"Successfully committed to existing table: {}\", tableIdentifier);\n+    } else {\n+      throw new CommitFailedException(\"Failed to commit the table %s from catalog %s! \" +\n+          \"Maybe another process changed it!\", tableIdentifier, catalogName);\n+    }\n+\n+  }\n+\n+  private void createTable(String newMetadataLocation) throws SQLException, InterruptedException {\n+    int insertRecord = connections.run(conn -> {\n+      try (PreparedStatement sql = conn.prepareStatement(JdbcUtil.DO_COMMIT_CREATE_SQL)) {\n+        sql.setString(1, catalogName);\n+        sql.setString(2, JdbcUtil.namespaceToString(tableIdentifier.namespace()));\n+        sql.setString(3, tableIdentifier.name());\n+        sql.setString(4, newMetadataLocation);\n+        return sql.executeUpdate();\n+      }\n+    });\n+\n+    if (insertRecord == 1) {\n+      LOG.debug(\"Successfully committed to new table: {}\", tableIdentifier);\n+    } else {\n+      throw new CommitFailedException(\"Failed to commit the table %s from catalog %s\", tableIdentifier, catalogName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1cee5e8b26fdebae8b0e423ce9430b6bad5165c"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzA0NTg2Mw==", "bodyText": "these column names should all be static variables in JdbcUtil", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r557045863", "createdAt": "2021-01-14T05:04:37Z", "author": {"login": "jackye1995"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcTableOperations.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.sql.DataTruncation;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.sql.SQLWarning;\n+import java.util.Map;\n+import java.util.Objects;\n+import org.apache.iceberg.BaseMetastoreTableOperations;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.CommitFailedException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+class JdbcTableOperations extends BaseMetastoreTableOperations {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcTableOperations.class);\n+  private final String catalogName;\n+  private final TableIdentifier tableIdentifier;\n+  private final FileIO fileIO;\n+  private final JdbcClientPool connections;\n+\n+  protected JdbcTableOperations(JdbcClientPool dbConnPool, FileIO fileIO, String catalogName,\n+                                TableIdentifier tableIdentifier) {\n+    this.catalogName = catalogName;\n+    this.tableIdentifier = tableIdentifier;\n+    this.fileIO = fileIO;\n+    this.connections = dbConnPool;\n+  }\n+\n+  @Override\n+  public void doRefresh() {\n+    Map<String, String> table;\n+\n+    try {\n+      table = getTable();\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted during refresh\", e);\n+    } catch (SQLException e) {\n+      // unknown exception happened when getting table from catalog\n+      throw new UncheckedSQLException(\n+          String.format(\"Failed to get table %s from catalog %s\", tableIdentifier, catalogName), e);\n+    }\n+\n+    // Table not exists AND currentMetadataLocation is not NULL!\n+    if (table.isEmpty() && currentMetadataLocation() != null) {\n+      throw new NoSuchTableException(\"Failed to get table %s from catalog %s!\" +\n+          \" maybe another process deleted it!\", tableIdentifier, catalogName);\n+    }\n+\n+    // Table not exists in the catalog! metadataLocation is null here!\n+    if (table.isEmpty()) {\n+      refreshFromMetadataLocation(null);\n+      return;\n+    }\n+\n+    // Table exists but metadataLocation is null\n+    if (table.getOrDefault(\"metadata_location\", null) == null) {\n+      throw new RuntimeException(String.format(\"Failed to get metadata location of the table %s from catalog %s\",\n+          tableIdentifier, catalogName));\n+    }\n+\n+    refreshFromMetadataLocation(table.get(\"metadata_location\"));\n+  }\n+\n+  @Override\n+  public void doCommit(TableMetadata base, TableMetadata metadata) {\n+    String newMetadataLocation = writeNewMetadata(metadata, currentVersion() + 1);\n+    try {\n+      Map<String, String> table = getTable();\n+\n+      if (!table.isEmpty()) {\n+        validateMetadataLocation(table, base);\n+        String oldMetadataLocation = base.metadataFileLocation();\n+        // Start atomic update\n+        updateTable(newMetadataLocation, oldMetadataLocation);\n+      } else {\n+        // table not exists create it!\n+        createTable(newMetadataLocation);\n+      }\n+\n+    } catch (SQLIntegrityConstraintViolationException e) {\n+      throw new AlreadyExistsException(e, \"Table already exists! maybe another process created it!\");\n+    } catch (SQLTimeoutException e) {\n+      throw new UncheckedSQLException(\"Database Connection timeout!\", e);\n+    } catch (SQLTransientConnectionException | SQLNonTransientConnectionException e) {\n+      throw new UncheckedSQLException(\"Database Connection failed!\", e);\n+    } catch (DataTruncation e) {\n+      throw new UncheckedSQLException(\"Database data truncation error!\", e);\n+    } catch (SQLWarning e) {\n+      throw new UncheckedSQLException(\"Database warning!\", e);\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(\"Failed to connect to database!\", e);\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted during commit\", e);\n+    }\n+  }\n+\n+  private void updateTable(String newMetadataLocation, String oldMetadataLocation)\n+      throws SQLException, InterruptedException {\n+    int updatedRecords = connections.run(conn -> {\n+      try (PreparedStatement sql = conn.prepareStatement(JdbcUtil.DO_COMMIT_SQL)) {\n+        // UPDATE\n+        sql.setString(1, newMetadataLocation);\n+        sql.setString(2, oldMetadataLocation);\n+        // WHERE\n+        sql.setString(3, catalogName);\n+        sql.setString(4, JdbcUtil.namespaceToString(tableIdentifier.namespace()));\n+        sql.setString(5, tableIdentifier.name());\n+        sql.setString(6, oldMetadataLocation);\n+        return sql.executeUpdate();\n+      }\n+    });\n+\n+    if (updatedRecords == 1) {\n+      LOG.debug(\"Successfully committed to existing table: {}\", tableIdentifier);\n+    } else {\n+      throw new CommitFailedException(\"Failed to commit the table %s from catalog %s! \" +\n+          \"Maybe another process changed it!\", tableIdentifier, catalogName);\n+    }\n+\n+  }\n+\n+  private void createTable(String newMetadataLocation) throws SQLException, InterruptedException {\n+    int insertRecord = connections.run(conn -> {\n+      try (PreparedStatement sql = conn.prepareStatement(JdbcUtil.DO_COMMIT_CREATE_SQL)) {\n+        sql.setString(1, catalogName);\n+        sql.setString(2, JdbcUtil.namespaceToString(tableIdentifier.namespace()));\n+        sql.setString(3, tableIdentifier.name());\n+        sql.setString(4, newMetadataLocation);\n+        return sql.executeUpdate();\n+      }\n+    });\n+\n+    if (insertRecord == 1) {\n+      LOG.debug(\"Successfully committed to new table: {}\", tableIdentifier);\n+    } else {\n+      throw new CommitFailedException(\"Failed to commit the table %s from catalog %s\", tableIdentifier, catalogName);\n+    }\n+  }\n+\n+  private void validateMetadataLocation(Map<String, String> table, TableMetadata base) {\n+    String catalogMetadataLocation = !table.isEmpty() ? table.get(\"metadata_location\") : null;\n+    String baseMetadataLocation = base != null ? base.metadataFileLocation() : null;\n+\n+    if (!Objects.equals(baseMetadataLocation, catalogMetadataLocation)) {\n+      throw new CommitFailedException(\n+          \"Cannot commit %s because base metadata location '%s' is not same as the current Catalog location '%s'\",\n+          tableIdentifier, baseMetadataLocation, catalogMetadataLocation);\n+    }\n+  }\n+\n+  @Override\n+  public FileIO io() {\n+    return fileIO;\n+  }\n+\n+  @Override\n+  protected String tableName() {\n+    return tableIdentifier.toString();\n+  }\n+\n+  private Map<String, String> getTable() throws UncheckedSQLException, SQLException, InterruptedException {\n+    return connections.run(conn -> {\n+      Map<String, String> table = Maps.newHashMap();\n+\n+      try (PreparedStatement sql = conn.prepareStatement(JdbcUtil.LOAD_TABLE_SQL)) {\n+        sql.setString(1, catalogName);\n+        sql.setString(2, JdbcUtil.namespaceToString(tableIdentifier.namespace()));\n+        sql.setString(3, tableIdentifier.name());\n+        ResultSet rs = sql.executeQuery();\n+\n+        if (rs.next()) {\n+          table.put(\"catalog_name\", rs.getString(\"catalog_name\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1cee5e8b26fdebae8b0e423ce9430b6bad5165c"}, "originalPosition": 205}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY4NDc4NTA0", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-568478504", "createdAt": "2021-01-14T17:48:30Z", "commit": {"oid": "5eeb6941ea2d5c31d54231c706107edfe7a59c48"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQxNzo0ODozMFrOITv-ww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQxODozMTozOFrOITxg1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzU3OTk3MQ==", "bodyText": "nit: fail to update the table", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r557579971", "createdAt": "2021-01-14T17:48:30Z", "author": {"login": "jackye1995"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcTableOperations.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.sql.DataTruncation;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.sql.SQLWarning;\n+import java.util.Map;\n+import java.util.Objects;\n+import org.apache.iceberg.BaseMetastoreTableOperations;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.CommitFailedException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+class JdbcTableOperations extends BaseMetastoreTableOperations {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcTableOperations.class);\n+  private final String catalogName;\n+  private final TableIdentifier tableIdentifier;\n+  private final FileIO fileIO;\n+  private final JdbcClientPool connections;\n+\n+  protected JdbcTableOperations(JdbcClientPool dbConnPool, FileIO fileIO, String catalogName,\n+                                TableIdentifier tableIdentifier) {\n+    this.catalogName = catalogName;\n+    this.tableIdentifier = tableIdentifier;\n+    this.fileIO = fileIO;\n+    this.connections = dbConnPool;\n+  }\n+\n+  @Override\n+  public void doRefresh() {\n+    Map<String, String> table;\n+\n+    try {\n+      table = getTable();\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted during refresh\", e);\n+    } catch (SQLException e) {\n+      // unknown exception happened when getting table from catalog\n+      throw new UncheckedSQLException(\n+          String.format(\"Failed to get table %s from catalog %s\", tableIdentifier, catalogName), e);\n+    }\n+\n+    // Table not exists AND currentMetadataLocation is not NULL!\n+    if (table.isEmpty() && currentMetadataLocation() != null) {\n+      throw new NoSuchTableException(\"Failed to get table %s from catalog %s!\" +\n+          \" maybe another process deleted it!\", tableIdentifier, catalogName);\n+    }\n+\n+    // Table not exists in the catalog! metadataLocation is null here!\n+    if (table.isEmpty()) {\n+      refreshFromMetadataLocation(null);\n+      return;\n+    }\n+\n+    // Table exists but metadataLocation is null\n+    if (table.getOrDefault(JdbcUtil.METADATA_LOCATION, null) == null) {\n+      throw new RuntimeException(String.format(\"Failed to get metadata location of the table %s from catalog %s\",\n+          tableIdentifier, catalogName));\n+    }\n+\n+    refreshFromMetadataLocation(table.get(JdbcUtil.METADATA_LOCATION));\n+  }\n+\n+  @Override\n+  public void doCommit(TableMetadata base, TableMetadata metadata) {\n+    String newMetadataLocation = writeNewMetadata(metadata, currentVersion() + 1);\n+    try {\n+      Map<String, String> table = getTable();\n+\n+      if (!table.isEmpty()) {\n+        validateMetadataLocation(table, base);\n+        String oldMetadataLocation = base.metadataFileLocation();\n+        // Start atomic update\n+        updateTable(newMetadataLocation, oldMetadataLocation);\n+      } else {\n+        // table not exists create it!\n+        createTable(newMetadataLocation);\n+      }\n+\n+    } catch (SQLIntegrityConstraintViolationException e) {\n+      throw new AlreadyExistsException(e, \"Table already exists! maybe another process created it!\");\n+    } catch (SQLTimeoutException e) {\n+      throw new UncheckedSQLException(\"Database Connection timeout!\", e);\n+    } catch (SQLTransientConnectionException | SQLNonTransientConnectionException e) {\n+      throw new UncheckedSQLException(\"Database Connection failed!\", e);\n+    } catch (DataTruncation e) {\n+      throw new UncheckedSQLException(\"Database data truncation error!\", e);\n+    } catch (SQLWarning e) {\n+      throw new UncheckedSQLException(\"Database warning!\", e);\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(\"Failed to connect to database!\", e);\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted during commit\", e);\n+    }\n+  }\n+\n+  private void updateTable(String newMetadataLocation, String oldMetadataLocation)\n+      throws SQLException, InterruptedException {\n+    int updatedRecords = connections.run(conn -> {\n+      try (PreparedStatement sql = conn.prepareStatement(JdbcUtil.DO_COMMIT_SQL)) {\n+        // UPDATE\n+        sql.setString(1, newMetadataLocation);\n+        sql.setString(2, oldMetadataLocation);\n+        // WHERE\n+        sql.setString(3, catalogName);\n+        sql.setString(4, JdbcUtil.namespaceToString(tableIdentifier.namespace()));\n+        sql.setString(5, tableIdentifier.name());\n+        sql.setString(6, oldMetadataLocation);\n+        return sql.executeUpdate();\n+      }\n+    });\n+\n+    if (updatedRecords == 1) {\n+      LOG.debug(\"Successfully committed to existing table: {}\", tableIdentifier);\n+    } else {\n+      throw new CommitFailedException(\"Failed to commit the table %s from catalog %s! \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eeb6941ea2d5c31d54231c706107edfe7a59c48"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzU4MDQzMw==", "bodyText": "nit: space after if", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r557580433", "createdAt": "2021-01-14T17:49:13Z", "author": {"login": "jackye1995"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,403 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.io.Closeable;\n+import java.sql.DatabaseMetaData;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, SupportsNamespaces, Closeable {\n+\n+  public static final String PROPERTY_PREFIX = \"connection.parameter.\";\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcCatalog.class);\n+  private static final Joiner SLASH = Joiner.on(\"/\");\n+\n+  private FileIO io;\n+  private String catalogName = \"jdbc\";\n+  private String warehouseLocation;\n+  private Configuration conf;\n+  private JdbcClientPool connections;\n+\n+  public JdbcCatalog() {\n+  }\n+\n+  @Override\n+  public void initialize(String name, Map<String, String> properties) {\n+    Preconditions.checkArgument(!properties.getOrDefault(CatalogProperties.HIVE_URI, \"\").isEmpty(),\n+        \"No connection url provided for jdbc catalog!\");\n+\n+    this.warehouseLocation = properties.getOrDefault(CatalogProperties.WAREHOUSE_LOCATION, \"\")\n+        .replaceAll(\"/$\", \"\");\n+    Preconditions.checkArgument(!warehouseLocation.isEmpty(),\n+        \"Cannot initialize Jdbc Catalog because warehousePath must not be null!\");\n+\n+    if (name != null) {\n+      this.catalogName = name;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eeb6941ea2d5c31d54231c706107edfe7a59c48"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzYwMzEwNw==", "bodyText": "nit: since we removed lower case part, there is not need to have upper in the variable names, and no need to use JdbcUtil.CATALOG_TABLE_NAME.toUpperCase()", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r557603107", "createdAt": "2021-01-14T18:28:10Z", "author": {"login": "jackye1995"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,403 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.io.Closeable;\n+import java.sql.DatabaseMetaData;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, SupportsNamespaces, Closeable {\n+\n+  public static final String PROPERTY_PREFIX = \"connection.parameter.\";\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcCatalog.class);\n+  private static final Joiner SLASH = Joiner.on(\"/\");\n+\n+  private FileIO io;\n+  private String catalogName = \"jdbc\";\n+  private String warehouseLocation;\n+  private Configuration conf;\n+  private JdbcClientPool connections;\n+\n+  public JdbcCatalog() {\n+  }\n+\n+  @Override\n+  public void initialize(String name, Map<String, String> properties) {\n+    Preconditions.checkArgument(!properties.getOrDefault(CatalogProperties.HIVE_URI, \"\").isEmpty(),\n+        \"No connection url provided for jdbc catalog!\");\n+\n+    this.warehouseLocation = properties.getOrDefault(CatalogProperties.WAREHOUSE_LOCATION, \"\")\n+        .replaceAll(\"/$\", \"\");\n+    Preconditions.checkArgument(!warehouseLocation.isEmpty(),\n+        \"Cannot initialize Jdbc Catalog because warehousePath must not be null!\");\n+\n+    if (name != null) {\n+      this.catalogName = name;\n+    }\n+    String fileIOImpl = properties.get(CatalogProperties.FILE_IO_IMPL);\n+    this.io = fileIOImpl == null ?\n+        new HadoopFileIO(conf) :\n+        CatalogUtil.loadFileIO(fileIOImpl, properties, conf);\n+\n+    try {\n+      initializeConnection(properties);\n+    } catch (SQLTimeoutException e) {\n+      throw new UncheckedSQLException(\"Database Connection timeout!\", e);\n+    } catch (SQLTransientConnectionException | SQLNonTransientConnectionException e) {\n+      throw new UncheckedSQLException(\"Database Connection failed!\", e);\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(\"Failed to initialize catalog!\", e);\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted in call to initialize!\", e);\n+    }\n+  }\n+\n+  private void initializeConnection(Map<String, String> properties) throws SQLException, InterruptedException {\n+    LOG.debug(\"Connecting to Jdbc database {}\", properties.get(CatalogProperties.HIVE_URI));\n+    connections = new JdbcClientPool(properties.get(CatalogProperties.HIVE_URI), properties);\n+    initializeCatalogTables();\n+  }\n+\n+  private void initializeCatalogTables() throws InterruptedException, SQLException {\n+    connections.run(conn -> {\n+      boolean catalogTableExists = false;\n+      DatabaseMetaData dbMeta = conn.getMetaData();\n+      ResultSet tablesUpper = dbMeta.getTables(null, null, JdbcUtil.CATALOG_TABLE_NAME.toUpperCase(), null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eeb6941ea2d5c31d54231c706107edfe7a59c48"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzYwNTA3OQ==", "bodyText": "no need to be public", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r557605079", "createdAt": "2021-01-14T18:31:38Z", "author": {"login": "jackye1995"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcUtil.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.relocated.com.google.common.base.Splitter;\n+import org.apache.iceberg.relocated.com.google.common.collect.Iterables;\n+\n+public final class JdbcUtil {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eeb6941ea2d5c31d54231c706107edfe7a59c48"}, "originalPosition": 28}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "97e7ea089084ecd7c8da4b1fd4d8aa042337f12d", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/97e7ea089084ecd7c8da4b1fd4d8aa042337f12d", "committedDate": "2021-01-17T09:58:25Z", "message": "review fixes"}, "afterCommit": {"oid": "420633629ec20b6f68cf339529ac608668444437", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/420633629ec20b6f68cf339529ac608668444437", "committedDate": "2021-01-21T08:32:16Z", "message": "update HIVE_URI to URI"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTczODU3OTI2", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-573857926", "createdAt": "2021-01-22T00:57:45Z", "commit": {"oid": "f7bc654216a7c30752feb49825ed3a35f0ca6a51"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQwMDo1Nzo0NVrOIYQCwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQwMDo1Nzo0NVrOIYQCwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjI5OTU4NA==", "bodyText": "This mixes together two separate problems. First, the URI is required so it must be non-null in the map. Second, the URI must be valid. This uses isEmpty to check both, but that's not sufficient to know it is a valid URI, and hides when the URI is not set.\nI think this should check that the URI is non-null and leave the validity check to the JDBC driver. Then this error message can be more specific:\nString uri = properties.get(CatalogProperties.URI);\nPreconditions.checkNotNull(uri, \"JDBC connection URI is required\");", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r562299584", "createdAt": "2021-01-22T00:57:45Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,404 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.io.Closeable;\n+import java.sql.DatabaseMetaData;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, SupportsNamespaces, Closeable {\n+\n+  public static final String PROPERTY_PREFIX = \"connection.parameter.\";\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcCatalog.class);\n+  private static final Joiner SLASH = Joiner.on(\"/\");\n+\n+  private FileIO io;\n+  private String catalogName = \"jdbc\";\n+  private String warehouseLocation;\n+  private Configuration conf;\n+  private JdbcClientPool connections;\n+\n+  public JdbcCatalog() {\n+  }\n+\n+  @Override\n+  public void initialize(String name, Map<String, String> properties) {\n+    Preconditions.checkArgument(!properties.getOrDefault(CatalogProperties.URI, \"\").isEmpty(),\n+        \"No connection url provided for jdbc catalog!\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7bc654216a7c30752feb49825ed3a35f0ca6a51"}, "originalPosition": 77}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTczODU4NDI2", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-573858426", "createdAt": "2021-01-22T00:59:11Z", "commit": {"oid": "f7bc654216a7c30752feb49825ed3a35f0ca6a51"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQwMDo1OToxMVrOIYQEaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQwMDo1OToxMVrOIYQEaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjMwMDAxMQ==", "bodyText": "This should also not mix together cases where the warehouse location is missing vs invalid.\nCan you update it to this?\nString warehouse = properties.get(CatalogProperties.WAREHOUSE_LOCATION);\nPreconditions.checkNotNull(warehouse, \"JDBC warehouse location is required\");\nthis.warehouseLocation = warehouse.replaceAll(\"/$\", \"\");", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r562300011", "createdAt": "2021-01-22T00:59:11Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,404 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.io.Closeable;\n+import java.sql.DatabaseMetaData;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, SupportsNamespaces, Closeable {\n+\n+  public static final String PROPERTY_PREFIX = \"connection.parameter.\";\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcCatalog.class);\n+  private static final Joiner SLASH = Joiner.on(\"/\");\n+\n+  private FileIO io;\n+  private String catalogName = \"jdbc\";\n+  private String warehouseLocation;\n+  private Configuration conf;\n+  private JdbcClientPool connections;\n+\n+  public JdbcCatalog() {\n+  }\n+\n+  @Override\n+  public void initialize(String name, Map<String, String> properties) {\n+    Preconditions.checkArgument(!properties.getOrDefault(CatalogProperties.URI, \"\").isEmpty(),\n+        \"No connection url provided for jdbc catalog!\");\n+\n+    this.warehouseLocation = properties.getOrDefault(CatalogProperties.WAREHOUSE_LOCATION, \"\")\n+        .replaceAll(\"/$\", \"\");\n+    Preconditions.checkArgument(!warehouseLocation.isEmpty(),\n+        \"Cannot initialize Jdbc Catalog because warehousePath must not be null!\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7bc654216a7c30752feb49825ed3a35f0ca6a51"}, "originalPosition": 82}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTczODU4NjU1", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-573858655", "createdAt": "2021-01-22T00:59:49Z", "commit": {"oid": "f7bc654216a7c30752feb49825ed3a35f0ca6a51"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQwMDo1OTo0OVrOIYQFMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQwMDo1OTo0OVrOIYQFMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjMwMDIwOA==", "bodyText": "Error messages should not end in !", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r562300208", "createdAt": "2021-01-22T00:59:49Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,404 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.io.Closeable;\n+import java.sql.DatabaseMetaData;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, SupportsNamespaces, Closeable {\n+\n+  public static final String PROPERTY_PREFIX = \"connection.parameter.\";\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcCatalog.class);\n+  private static final Joiner SLASH = Joiner.on(\"/\");\n+\n+  private FileIO io;\n+  private String catalogName = \"jdbc\";\n+  private String warehouseLocation;\n+  private Configuration conf;\n+  private JdbcClientPool connections;\n+\n+  public JdbcCatalog() {\n+  }\n+\n+  @Override\n+  public void initialize(String name, Map<String, String> properties) {\n+    Preconditions.checkArgument(!properties.getOrDefault(CatalogProperties.URI, \"\").isEmpty(),\n+        \"No connection url provided for jdbc catalog!\");\n+\n+    this.warehouseLocation = properties.getOrDefault(CatalogProperties.WAREHOUSE_LOCATION, \"\")\n+        .replaceAll(\"/$\", \"\");\n+    Preconditions.checkArgument(!warehouseLocation.isEmpty(),\n+        \"Cannot initialize Jdbc Catalog because warehousePath must not be null!\");\n+\n+    if (name != null) {\n+      this.catalogName = name;\n+    }\n+\n+    String fileIOImpl = properties.get(CatalogProperties.FILE_IO_IMPL);\n+    this.io = fileIOImpl == null ?\n+        new HadoopFileIO(conf) :\n+        CatalogUtil.loadFileIO(fileIOImpl, properties, conf);\n+\n+    try {\n+      initializeConnection(properties);\n+    } catch (SQLTimeoutException e) {\n+      throw new UncheckedSQLException(\"Database Connection timeout!\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7bc654216a7c30752feb49825ed3a35f0ca6a51"}, "originalPosition": 96}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTczODU4OTY5", "url": "https://github.com/apache/iceberg/pull/1870#pullrequestreview-573858969", "createdAt": "2021-01-22T01:00:37Z", "commit": {"oid": "f7bc654216a7c30752feb49825ed3a35f0ca6a51"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQwMTowMDozN1rOIYQGPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQwMTowMDozN1rOIYQGPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjMwMDQ3Ng==", "bodyText": "I don't think it is necessary to pass all of the properties here. Just the URI, right?", "url": "https://github.com/apache/iceberg/pull/1870#discussion_r562300476", "createdAt": "2021-01-22T01:00:37Z", "author": {"login": "rdblue"}, "path": "core/src/main/java/org/apache/iceberg/jdbc/JdbcCatalog.java", "diffHunk": "@@ -0,0 +1,404 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.jdbc;\n+\n+import java.io.Closeable;\n+import java.sql.DatabaseMetaData;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.SQLNonTransientConnectionException;\n+import java.sql.SQLTimeoutException;\n+import java.sql.SQLTransientConnectionException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Joiner;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JdbcCatalog extends BaseMetastoreCatalog implements Configurable, SupportsNamespaces, Closeable {\n+\n+  public static final String PROPERTY_PREFIX = \"connection.parameter.\";\n+  private static final Logger LOG = LoggerFactory.getLogger(JdbcCatalog.class);\n+  private static final Joiner SLASH = Joiner.on(\"/\");\n+\n+  private FileIO io;\n+  private String catalogName = \"jdbc\";\n+  private String warehouseLocation;\n+  private Configuration conf;\n+  private JdbcClientPool connections;\n+\n+  public JdbcCatalog() {\n+  }\n+\n+  @Override\n+  public void initialize(String name, Map<String, String> properties) {\n+    Preconditions.checkArgument(!properties.getOrDefault(CatalogProperties.URI, \"\").isEmpty(),\n+        \"No connection url provided for jdbc catalog!\");\n+\n+    this.warehouseLocation = properties.getOrDefault(CatalogProperties.WAREHOUSE_LOCATION, \"\")\n+        .replaceAll(\"/$\", \"\");\n+    Preconditions.checkArgument(!warehouseLocation.isEmpty(),\n+        \"Cannot initialize Jdbc Catalog because warehousePath must not be null!\");\n+\n+    if (name != null) {\n+      this.catalogName = name;\n+    }\n+\n+    String fileIOImpl = properties.get(CatalogProperties.FILE_IO_IMPL);\n+    this.io = fileIOImpl == null ?\n+        new HadoopFileIO(conf) :\n+        CatalogUtil.loadFileIO(fileIOImpl, properties, conf);\n+\n+    try {\n+      initializeConnection(properties);\n+    } catch (SQLTimeoutException e) {\n+      throw new UncheckedSQLException(\"Database Connection timeout!\", e);\n+    } catch (SQLTransientConnectionException | SQLNonTransientConnectionException e) {\n+      throw new UncheckedSQLException(\"Database Connection failed!\", e);\n+    } catch (SQLException e) {\n+      throw new UncheckedSQLException(\"Failed to initialize catalog!\", e);\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(\"Interrupted in call to initialize!\", e);\n+    }\n+  }\n+\n+  private void initializeConnection(Map<String, String> properties) throws SQLException, InterruptedException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7bc654216a7c30752feb49825ed3a35f0ca6a51"}, "originalPosition": 107}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4f04b4382e4536bb09a0c29f7455080de89685f8", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/4f04b4382e4536bb09a0c29f7455080de89685f8", "committedDate": "2021-01-22T21:16:45Z", "message": "moved initializeConnection to initialize"}, "afterCommit": {"oid": "4fa1449c9305221988b763733d6fc1488052eab7", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/4fa1449c9305221988b763733d6fc1488052eab7", "committedDate": "2021-01-29T22:14:14Z", "message": "moved initializeConnection to initialize"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4fa1449c9305221988b763733d6fc1488052eab7", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/4fa1449c9305221988b763733d6fc1488052eab7", "committedDate": "2021-01-29T22:14:14Z", "message": "moved initializeConnection to initialize"}, "afterCommit": {"oid": "db4cb06f1a141a0bd0d9a0f96ea705e2b45a6988", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/db4cb06f1a141a0bd0d9a0f96ea705e2b45a6988", "committedDate": "2021-02-13T11:46:38Z", "message": "move TestClientPool hive tests to TestHiveClientPool"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "db4cb06f1a141a0bd0d9a0f96ea705e2b45a6988", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/db4cb06f1a141a0bd0d9a0f96ea705e2b45a6988", "committedDate": "2021-02-13T11:46:38Z", "message": "move TestClientPool hive tests to TestHiveClientPool"}, "afterCommit": {"oid": "7b4a736a90123595de5a02fe3e0a334d1a1eeeb3", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/7b4a736a90123595de5a02fe3e0a334d1a1eeeb3", "committedDate": "2021-04-05T18:26:04Z", "message": "move ClientPoolImpl to core"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2e4769578a9f0868e896aca4137dbc73657b8ad9", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/2e4769578a9f0868e896aca4137dbc73657b8ad9", "committedDate": "2021-04-18T06:56:41Z", "message": "jdbc catalog\n\naddress review comments\n\nmore cleanup\n\ntest rollback scenario with renameTable\n\nfix\n\ncleanup\n\ncleanup, removed fs, create empty constructor and updated initialization\n\nfix unittest\n\nadded jdbc catalog to SparkCatalog and added tests to TestRemoveOrphanFilesAction3\n\nadded new test\n\nfix naming\n\ndo updates inside transaction and rollback updates if it fails.\n\nensure target namespace is exists before renaming table\n\nfix scope, revert license changes\n\njdbc catalog"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "49382464569aff7f9e3097f90dc500473db20206", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/49382464569aff7f9e3097f90dc500473db20206", "committedDate": "2021-04-18T06:56:41Z", "message": "address review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0c507843783b04e67ac182540e5891b73a087d3f", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/0c507843783b04e67ac182540e5891b73a087d3f", "committedDate": "2021-04-18T06:56:41Z", "message": "address review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3fb7f6a8d89f8e2928b65f452e4f852d369f874d", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/3fb7f6a8d89f8e2928b65f452e4f852d369f874d", "committedDate": "2021-04-18T06:56:41Z", "message": "address review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "61b921331bf8755685d544d91d4a1096d3ec8adf", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/61b921331bf8755685d544d91d4a1096d3ec8adf", "committedDate": "2021-04-18T06:56:41Z", "message": "address review comments\n\naddress review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "33524d6846bc83e0f1fd254613f4dc270d4953c9", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/33524d6846bc83e0f1fd254613f4dc270d4953c9", "committedDate": "2021-04-18T06:56:41Z", "message": "address review comments\n\naddress review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fce1a8fcd89b4c417d3af1095f269f28cfe1ca17", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/fce1a8fcd89b4c417d3af1095f269f28cfe1ca17", "committedDate": "2021-04-18T06:56:41Z", "message": "jdbc catalog duplicate concurrent test from hive"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "40163066f42a9f64d2df77fd84e638f369ea5066", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/40163066f42a9f64d2df77fd84e638f369ea5066", "committedDate": "2021-04-18T06:56:41Z", "message": "capture specific sql exceptions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9bd2e474a25de4c8cf07d98eaa4ce5fe10e7f715", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/9bd2e474a25de4c8cf07d98eaa4ce5fe10e7f715", "committedDate": "2021-04-18T06:56:41Z", "message": "extent UncheckedSQLException from UncheckedIOException"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "60fafc3ab4fead0af10a3152ac08f773312412c1", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/60fafc3ab4fead0af10a3152ac08f773312412c1", "committedDate": "2021-04-18T06:56:42Z", "message": "review fixes\n\nreview fixes\n\nreview fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "af3937ea443ee3a3f6db701f7aaba2203fa7bdff", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/af3937ea443ee3a3f6db701f7aaba2203fa7bdff", "committedDate": "2021-04-18T06:56:42Z", "message": "update spark3 catalog change"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ef240b2087b37c70a4e4ec6643d08b95ce24aa6f", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/ef240b2087b37c70a4e4ec6643d08b95ce24aa6f", "committedDate": "2021-04-18T06:56:42Z", "message": "fix catalog class name"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5386846207d96c5067c8e139fc9423da50ec9b38", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/5386846207d96c5067c8e139fc9423da50ec9b38", "committedDate": "2021-04-18T06:56:42Z", "message": "review updates"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a0d6f9497a6253dd07dc79f1600f84aadcf25e4d", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/a0d6f9497a6253dd07dc79f1600f84aadcf25e4d", "committedDate": "2021-04-18T06:56:42Z", "message": "add method defaultNamespaceLocation(namespace)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aaea91cdd45414d49613dafe4cb10869ffd36502", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/aaea91cdd45414d49613dafe4cb10869ffd36502", "committedDate": "2021-04-18T06:56:42Z", "message": "move sql statements to JdbcUtil"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "428e57a5f1e4c00e811d500a36665222b97866f5", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/428e57a5f1e4c00e811d500a36665222b97866f5", "committedDate": "2021-04-18T06:56:42Z", "message": "use protected for sql constants"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7ac78fa0ed1a732e5dda152030ace826903fdfbf", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/7ac78fa0ed1a732e5dda152030ace826903fdfbf", "committedDate": "2021-04-18T06:56:42Z", "message": "address review notes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "699047429aa823bf0390857b47ee7c5bd1d49b1e", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/699047429aa823bf0390857b47ee7c5bd1d49b1e", "committedDate": "2021-04-18T06:56:42Z", "message": "moved UncheckedSQLException to org.apache.iceberg.jdbc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9d68634cf2656cdf52757bde1a2e6793e4c476cc", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/9d68634cf2656cdf52757bde1a2e6793e4c476cc", "committedDate": "2021-04-18T06:56:42Z", "message": "update messages"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1a17053ab7fa6217dd278ade9e10d0060ec8e82d", "author": {"user": {"login": "ismailsimsek", "name": "ismail simsek"}}, "url": "https://github.com/apache/iceberg/commit/1a17053ab7fa6217dd278ade9e10d0060ec8e82d", "committedDate": "2021-04-18T06:56:42Z", "message": "use sqlite-jdbc for tests"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3505, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}