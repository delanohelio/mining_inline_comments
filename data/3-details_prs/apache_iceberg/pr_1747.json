{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE4MTQ0NTYw", "number": 1747, "title": "API: add isNaN and notNaN predicates", "bodyText": "This changes adds isNaN/notNaN predicates. Metrics evaluators currently work against a null NaN counter, which will be populated in a later pr. The logic of updating SparkFilters.convert to direct queries to isNaN/notNaN methods will also be in a later pr.", "createdAt": "2020-11-10T01:23:46Z", "url": "https://github.com/apache/iceberg/pull/1747", "merged": true, "mergeCommit": {"oid": "fab4a5f2db140fdb132205e78934a145e646758b"}, "closed": true, "closedAt": "2020-12-06T01:14:28Z", "author": {"login": "yyanyy"}, "timelineItems": {"totalCount": 25, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdbk7eSAFqTUyODU1MTE5Nw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdjWZtvgFqTU0NTY2MTUyNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI4NTUxMTk3", "url": "https://github.com/apache/iceberg/pull/1747#pullrequestreview-528551197", "createdAt": "2020-11-11T21:34:44Z", "commit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMTozNDo0NFrOHxfGgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMTozNDo0NFrOHxfGgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY1MTg0Mw==", "bodyText": "I think new methods should throw UnsupportedOperationException so that visitors must be updated to work with isNaN.", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r521651843", "createdAt": "2020-11-11T21:34:44Z", "author": {"login": "rdblue"}, "path": "api/src/main/java/org/apache/iceberg/expressions/ExpressionVisitors.java", "diffHunk": "@@ -75,6 +75,14 @@ public R or(R leftResult, R rightResult) {\n       return null;\n     }\n \n+    public <T> R isNaN(BoundReference<T> ref) {\n+      return null;\n+    }\n+\n+    public <T> R notNaN(BoundReference<T> ref) {\n+      return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "originalPosition": 9}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI4NTUyOTgw", "url": "https://github.com/apache/iceberg/pull/1747#pullrequestreview-528552980", "createdAt": "2020-11-11T21:37:22Z", "commit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMTozNzoyM1rOHxfMPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMTozNzoyM1rOHxfMPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY1MzMxMA==", "bodyText": "I think \"accepts\" isn't quite the right verb. What about \"includes\" instead?", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r521653310", "createdAt": "2020-11-11T21:37:23Z", "author": {"login": "rdblue"}, "path": "api/src/main/java/org/apache/iceberg/expressions/UnboundPredicate.java", "diffHunk": "@@ -127,11 +128,27 @@ private Expression bindUnaryOperation(BoundTerm<T> boundTerm) {\n           return Expressions.alwaysTrue();\n         }\n         return new BoundUnaryPredicate<>(Operation.NOT_NULL, boundTerm);\n+      case IS_NAN:\n+        if (typeAcceptsNaN(boundTerm.type().typeId())) {\n+          return new BoundUnaryPredicate<>(Operation.IS_NAN, boundTerm);\n+        } else {\n+          return Expressions.alwaysFalse();\n+        }\n+      case NOT_NAN:\n+        if (typeAcceptsNaN(boundTerm.type().typeId())) {\n+          return new BoundUnaryPredicate<>(Operation.NOT_NAN, boundTerm);\n+        } else {\n+          return Expressions.alwaysTrue();\n+        }\n       default:\n-        throw new ValidationException(\"Operation must be IS_NULL or NOT_NULL\");\n+        throw new ValidationException(\"Operation must be IS_NULL, NOT_NULL, IS_NAN, or NOT_NAN\");\n     }\n   }\n \n+  private boolean typeAcceptsNaN(Type.TypeID typeID) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "originalPosition": 30}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI4NTU0MTg0", "url": "https://github.com/apache/iceberg/pull/1747#pullrequestreview-528554184", "createdAt": "2020-11-11T21:39:17Z", "commit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMTozOToxN1rOHxfQkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMTozOToxN1rOHxfQkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY1NDQxNw==", "bodyText": "Should this be a static helper somewhere since it is duplicated here and in Evaluator?", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r521654417", "createdAt": "2020-11-11T21:39:17Z", "author": {"login": "rdblue"}, "path": "api/src/main/java/org/apache/iceberg/expressions/BoundUnaryPredicate.java", "diffHunk": "@@ -46,18 +46,35 @@ public boolean test(T value) {\n         return value == null;\n       case NOT_NULL:\n         return value != null;\n+      case IS_NAN:\n+        return isNaN(value);\n+      case NOT_NAN:\n+        return !isNaN(value);\n       default:\n         throw new IllegalStateException(\"Invalid operation for BoundUnaryPredicate: \" + op());\n     }\n   }\n \n+  private boolean isNaN(T value) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "originalPosition": 13}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI4NTU1Njc2", "url": "https://github.com/apache/iceberg/pull/1747#pullrequestreview-528555676", "createdAt": "2020-11-11T21:41:57Z", "commit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMTo0MTo1N1rOHxfVcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMTo0MTo1N1rOHxfVcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY1NTY2Ng==", "bodyText": "Should we define a similar containsNaNsOnly method to use in notNaN and for a similar use in isNull?", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r521655666", "createdAt": "2020-11-11T21:41:57Z", "author": {"login": "rdblue"}, "path": "api/src/main/java/org/apache/iceberg/expressions/InclusiveMetricsEvaluator.java", "diffHunk": "@@ -150,6 +152,53 @@ public Boolean or(Boolean leftResult, Boolean rightResult) {\n       return ROWS_MIGHT_MATCH;\n     }\n \n+    @Override\n+    public <T> Boolean isNaN(BoundReference<T> ref) {\n+      Integer id = ref.fieldId();\n+\n+      if (nanCounts != null && nanCounts.containsKey(id) && nanCounts.get(id) == 0) {\n+        return ROWS_CANNOT_MATCH;\n+      }\n+\n+      // when there's no nanCounts information, but we already know the column only contains null,\n+      // it's guaranteed that there's no NaN value\n+      if (containsNullsOnly(id)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "originalPosition": 30}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI4NTU2ODMx", "url": "https://github.com/apache/iceberg/pull/1747#pullrequestreview-528556831", "createdAt": "2020-11-11T21:44:00Z", "commit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMTo0NDowMFrOHxfY3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMTo0NDowMFrOHxfY3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY1NjU0MA==", "bodyText": "I don't think this is true. This test shows an ORC case where upper and lower are NaN, but there are non-NaN values in the column.", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r521656540", "createdAt": "2020-11-11T21:44:00Z", "author": {"login": "rdblue"}, "path": "api/src/main/java/org/apache/iceberg/expressions/InclusiveMetricsEvaluator.java", "diffHunk": "@@ -150,6 +152,53 @@ public Boolean or(Boolean leftResult, Boolean rightResult) {\n       return ROWS_MIGHT_MATCH;\n     }\n \n+    @Override\n+    public <T> Boolean isNaN(BoundReference<T> ref) {\n+      Integer id = ref.fieldId();\n+\n+      if (nanCounts != null && nanCounts.containsKey(id) && nanCounts.get(id) == 0) {\n+        return ROWS_CANNOT_MATCH;\n+      }\n+\n+      // when there's no nanCounts information, but we already know the column only contains null,\n+      // it's guaranteed that there's no NaN value\n+      if (containsNullsOnly(id)) {\n+        return ROWS_CANNOT_MATCH;\n+      }\n+\n+      return ROWS_MIGHT_MATCH;\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"checkstyle:CyclomaticComplexity\")\n+    public <T> Boolean notNaN(BoundReference<T> ref) {\n+      Integer id = ref.fieldId();\n+\n+      if (nanCounts != null && nanCounts.containsKey(id) &&\n+          valueCounts != null && valueCounts.containsKey(id)) {\n+        if (nanCounts.get(id).equals(valueCounts.get(id))) {\n+          return ROWS_CANNOT_MATCH;\n+        }\n+\n+        return ROWS_MIGHT_MATCH;\n+      }\n+\n+      // for v1 table, when NaN could still be upper/lower bound,\n+      // if upper == lower == NaN and null count == 0, the column will only contain NaN", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "originalPosition": 52}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI4NTYxOTk5", "url": "https://github.com/apache/iceberg/pull/1747#pullrequestreview-528561999", "createdAt": "2020-11-11T21:52:50Z", "commit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMTo1Mjo1MFrOHxfpmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMTo1Mjo1MFrOHxfpmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY2MDgyNg==", "bodyText": "Do we also need to update the equality predicate to catch NaN and rewrite to isNaN?", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r521660826", "createdAt": "2020-11-11T21:52:50Z", "author": {"login": "rdblue"}, "path": "api/src/main/java/org/apache/iceberg/expressions/Expressions.java", "diffHunk": "@@ -123,6 +123,22 @@ public static Expression not(Expression child) {\n     return new UnboundPredicate<>(Expression.Operation.NOT_NULL, expr);\n   }\n \n+  public static <T> UnboundPredicate<T> isNaN(String name) {\n+    return new UnboundPredicate<>(Expression.Operation.IS_NAN, ref(name));\n+  }\n+\n+  public static <T> UnboundPredicate<T> isNaN(UnboundTerm<T> expr) {\n+    return new UnboundPredicate<>(Expression.Operation.IS_NAN, expr);\n+  }\n+\n+  public static <T> UnboundPredicate<T> notNaN(String name) {\n+    return new UnboundPredicate<>(Expression.Operation.NOT_NAN, ref(name));\n+  }\n+\n+  public static <T> UnboundPredicate<T> notNaN(UnboundTerm<T> expr) {\n+    return new UnboundPredicate<>(Expression.Operation.NOT_NAN, expr);\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "originalPosition": 18}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI4NTYzMTQ1", "url": "https://github.com/apache/iceberg/pull/1747#pullrequestreview-528563145", "createdAt": "2020-11-11T21:54:43Z", "commit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMTo1NDo0M1rOHxftHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMTo1NDo0M1rOHxftHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY2MTcyNA==", "bodyText": "To be safe, I think this should validate that containsNull is true.", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r521661724", "createdAt": "2020-11-11T21:54:43Z", "author": {"login": "rdblue"}, "path": "api/src/main/java/org/apache/iceberg/expressions/ManifestEvaluator.java", "diffHunk": "@@ -142,6 +142,25 @@ public Boolean or(Boolean leftResult, Boolean rightResult) {\n       return ROWS_MIGHT_MATCH;\n     }\n \n+    @Override\n+    public <T> Boolean isNaN(BoundReference<T> ref) {\n+      int pos = Accessors.toPosition(ref.accessor());\n+      // containsNull encodes whether at least one partition value is null, lowerBound is null if\n+      // all partition values are null.\n+      ByteBuffer lowerBound = stats.get(pos).lowerBound();\n+      if (lowerBound == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "originalPosition": 10}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI4NTY0ODM4", "url": "https://github.com/apache/iceberg/pull/1747#pullrequestreview-528564838", "createdAt": "2020-11-11T21:57:39Z", "commit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMTo1NzozOVrOHxfyEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMTo1NzozOVrOHxfyEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY2Mjk5NQ==", "bodyText": "Good catch.", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r521662995", "createdAt": "2020-11-11T21:57:39Z", "author": {"login": "rdblue"}, "path": "api/src/main/java/org/apache/iceberg/expressions/StrictMetricsEvaluator.java", "diffHunk": "@@ -57,10 +57,10 @@ public StrictMetricsEvaluator(Schema schema, Expression unbound) {\n   }\n \n   /**\n-   * Test whether the file may contain records that match the expression.\n+   * Test whether all records within the file match the expression.\n    *\n    * @param file a data file\n-   * @return false if the file cannot contain rows that match the expression, true otherwise.\n+   * @return false if the file may contain any row that doesn't match the expression, true otherwise.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "originalPosition": 9}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI4NTY1NDY2", "url": "https://github.com/apache/iceberg/pull/1747#pullrequestreview-528565466", "createdAt": "2020-11-11T21:58:47Z", "commit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMTo1ODo0N1rOHxf0IQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMTo1ODo0N1rOHxf0IQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY2MzUyMQ==", "bodyText": "Same here as above. If there are non-NaN values then this should return ROWS_MIGHT_NOT_MATCH.", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r521663521", "createdAt": "2020-11-11T21:58:47Z", "author": {"login": "rdblue"}, "path": "api/src/main/java/org/apache/iceberg/expressions/StrictMetricsEvaluator.java", "diffHunk": "@@ -144,6 +146,51 @@ public Boolean or(Boolean leftResult, Boolean rightResult) {\n       return ROWS_MIGHT_NOT_MATCH;\n     }\n \n+    @Override\n+    @SuppressWarnings(\"checkstyle:CyclomaticComplexity\")\n+    public <T> Boolean isNaN(BoundReference<T> ref) {\n+      int id = ref.fieldId();\n+\n+      if (nanCounts != null && nanCounts.containsKey(id) &&\n+          valueCounts != null && valueCounts.containsKey(id)) {\n+        if (nanCounts.get(id).equals(valueCounts.get(id))) {\n+          return ROWS_MUST_MATCH;\n+        }\n+\n+        return ROWS_MIGHT_NOT_MATCH;\n+      }\n+\n+      // for v1 table, when NaN could still be upper/lower bound,\n+      // if upper == lower == NaN and null count == 0, the column will only contain NaN", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "originalPosition": 66}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI4NTY2MzI0", "url": "https://github.com/apache/iceberg/pull/1747#pullrequestreview-528566324", "createdAt": "2020-11-11T22:00:19Z", "commit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMjowMDoxOVrOHxf3FA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMjowMDoxOVrOHxf3FA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY2NDI3Ng==", "bodyText": "Here's another implementation of the same test.", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r521664276", "createdAt": "2020-11-11T22:00:19Z", "author": {"login": "rdblue"}, "path": "api/src/main/java/org/apache/iceberg/expressions/ResidualEvaluator.java", "diffHunk": "@@ -152,6 +152,30 @@ public Expression or(Expression leftResult, Expression rightResult) {\n       return (ref.eval(struct) != null) ? alwaysTrue() : alwaysFalse();\n     }\n \n+    @Override\n+    public <T> Expression isNaN(BoundReference<T> ref) {\n+      return isNaN(ref.eval(struct)) ? alwaysTrue() : alwaysFalse();\n+    }\n+\n+    @Override\n+    public <T> Expression notNaN(BoundReference<T> ref) {\n+      return isNaN(ref.eval(struct)) ? alwaysFalse() : alwaysTrue();\n+    }\n+\n+    private <T> boolean isNaN(T value) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "originalPosition": 14}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI4NTcwMzcw", "url": "https://github.com/apache/iceberg/pull/1747#pullrequestreview-528570370", "createdAt": "2020-11-11T22:07:37Z", "commit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMjowNzozN1rOHxgDQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMjowNzozN1rOHxgDQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY2NzM5NA==", "bodyText": "Minor: Using FILE_2 is a little strange to read because the column is still called \"no_nans\". Consider adding another column instead called no_nan_stats just like the no_stats column that is used for isNull/notNull.", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r521667394", "createdAt": "2020-11-11T22:07:37Z", "author": {"login": "rdblue"}, "path": "api/src/test/java/org/apache/iceberg/expressions/TestInclusiveMetricsEvaluator.java", "diffHunk": "@@ -156,6 +192,54 @@ public void testNoNulls() {\n     Assert.assertFalse(\"Should skip: non-null column contains no null values\", shouldRead);\n   }\n \n+  @Test\n+  public void testIsNaN() {\n+    boolean shouldRead = new InclusiveMetricsEvaluator(SCHEMA, isNaN(\"all_nans\")).eval(FILE);\n+    Assert.assertTrue(\"Should read: at least one nan value in all nan column\", shouldRead);\n+\n+    shouldRead = new InclusiveMetricsEvaluator(SCHEMA, isNaN(\"some_nans\")).eval(FILE);\n+    Assert.assertTrue(\"Should read: at least one nan value in some nan column\", shouldRead);\n+\n+    shouldRead = new InclusiveMetricsEvaluator(SCHEMA, isNaN(\"no_nans\")).eval(FILE);\n+    Assert.assertFalse(\"Should skip: no-nans column contains no nan values\", shouldRead);\n+\n+    shouldRead = new InclusiveMetricsEvaluator(SCHEMA, isNaN(\"all_nulls_double\")).eval(FILE);\n+    Assert.assertFalse(\"Should skip: all-null column doesn't contain nan value\", shouldRead);\n+\n+    shouldRead = new InclusiveMetricsEvaluator(SCHEMA, isNaN(\"no_nans\")).eval(FILE_2);\n+    Assert.assertTrue(\"Should read: no guarantee on if contains nan value without nan stats\", shouldRead);\n+\n+    shouldRead = new InclusiveMetricsEvaluator(SCHEMA, isNaN(\"all_nans_v1_stats\")).eval(FILE);\n+    Assert.assertTrue(\"Should read: at least one nan value in all nan column\", shouldRead);\n+\n+    shouldRead = new InclusiveMetricsEvaluator(SCHEMA, isNaN(\"nan_and_null_only\")).eval(FILE);\n+    Assert.assertTrue(\"Should read: at least one nan value in nan and nulls only column\", shouldRead);\n+  }\n+\n+  @Test\n+  public void testNotNaN() {\n+    boolean shouldRead = new InclusiveMetricsEvaluator(SCHEMA, notNaN(\"all_nans\")).eval(FILE);\n+    Assert.assertFalse(\"Should skip: column with all nans will not contain non-nan\", shouldRead);\n+\n+    shouldRead = new InclusiveMetricsEvaluator(SCHEMA, notNaN(\"some_nans\")).eval(FILE);\n+    Assert.assertTrue(\"Should read: at least one non-nan value in some nan column\", shouldRead);\n+\n+    shouldRead = new InclusiveMetricsEvaluator(SCHEMA, notNaN(\"no_nans\")).eval(FILE);\n+    Assert.assertTrue(\"Should read: at least one non-nan value in no nan column\", shouldRead);\n+\n+    shouldRead = new InclusiveMetricsEvaluator(SCHEMA, notNaN(\"all_nulls_double\")).eval(FILE);\n+    Assert.assertTrue(\"Should read: at least one non-nan value in all null column\", shouldRead);\n+\n+    shouldRead = new InclusiveMetricsEvaluator(SCHEMA, notNaN(\"no_nans\")).eval(FILE_2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "originalPosition": 152}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI4NTc2OTIz", "url": "https://github.com/apache/iceberg/pull/1747#pullrequestreview-528576923", "createdAt": "2020-11-11T22:19:21Z", "commit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMjoxOToyMVrOHxgXYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMjoxOToyMVrOHxgXYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY3MjU0NQ==", "bodyText": "Do we need NaN cases for other evaluators?", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r521672545", "createdAt": "2020-11-11T22:19:21Z", "author": {"login": "rdblue"}, "path": "api/src/test/java/org/apache/iceberg/transforms/TestResiduals.java", "diffHunk": "@@ -214,6 +218,36 @@ public void testInTimestamp() {\n     Assert.assertEquals(\"Residual should be alwaysFalse\", alwaysFalse(), residual);\n   }\n \n+  @Test\n+  public void testInNaN() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "originalPosition": 27}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI4NTc5MjAw", "url": "https://github.com/apache/iceberg/pull/1747#pullrequestreview-528579200", "createdAt": "2020-11-11T22:23:30Z", "commit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMjoyMzozMFrOHxgetQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMjoyMzozMFrOHxgetQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY3NDQyMQ==", "bodyText": "Maybe update the context to \"NaN counts are not tracked in Parquet metrics\".", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r521674421", "createdAt": "2020-11-11T22:23:30Z", "author": {"login": "rdblue"}, "path": "data/src/test/java/org/apache/iceberg/data/TestMetricsRowGroupFilter.java", "diffHunk": "@@ -281,6 +295,37 @@ public void testNoNulls() {\n     Assert.assertTrue(\"Should read: struct type is not skipped\", shouldRead);\n   }\n \n+  @Test\n+  public void testIsNaN() {\n+    boolean shouldRead = shouldRead(isNaN(\"all_nans\"));\n+    Assert.assertTrue(\"Should read: not enough information\", shouldRead);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "originalPosition": 90}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI4NTgwMjI1", "url": "https://github.com/apache/iceberg/pull/1747#pullrequestreview-528580225", "createdAt": "2020-11-11T22:25:28Z", "commit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMjoyNToyOFrOHxgiEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMjoyNToyOFrOHxgiEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY3NTI4MQ==", "bodyText": "If there is a NaN value, then it would be in the Parquet dictionary. I think that we can implement this for Parquet.", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r521675281", "createdAt": "2020-11-11T22:25:28Z", "author": {"login": "rdblue"}, "path": "parquet/src/main/java/org/apache/iceberg/parquet/ParquetDictionaryRowGroupFilter.java", "diffHunk": "@@ -148,6 +148,16 @@ public Boolean or(Boolean leftResult, Boolean rightResult) {\n       return ROWS_MIGHT_MATCH;\n     }\n \n+    @Override\n+    public <T> Boolean isNaN(BoundReference<T> ref) {\n+      return ROWS_MIGHT_MATCH;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "originalPosition": 6}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c", "author": {"user": {"login": "yyanyy", "name": null}}, "url": "https://github.com/apache/iceberg/commit/5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c", "committedDate": "2020-11-10T01:09:28Z", "message": "API: add isNaN and notNaN predicates"}, "afterCommit": {"oid": "3fc48a0f465426d032cbe2fe0a6c6026438536ec", "author": {"user": {"login": "yyanyy", "name": null}}, "url": "https://github.com/apache/iceberg/commit/3fc48a0f465426d032cbe2fe0a6c6026438536ec", "committedDate": "2020-11-18T02:27:05Z", "message": "update based on comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2MTQwMzMy", "url": "https://github.com/apache/iceberg/pull/1747#pullrequestreview-536140332", "createdAt": "2020-11-23T01:19:31Z", "commit": {"oid": "3fc48a0f465426d032cbe2fe0a6c6026438536ec"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QwMToxOTozMVrOH39LwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QwMzoyODo1MVrOH3-adA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQzNjE2MQ==", "bodyText": "why not be consistent with isNull and notNull and return null?", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r528436161", "createdAt": "2020-11-23T01:19:31Z", "author": {"login": "jackye1995"}, "path": "api/src/main/java/org/apache/iceberg/expressions/ExpressionVisitors.java", "diffHunk": "@@ -75,6 +75,14 @@ public R or(R leftResult, R rightResult) {\n       return null;\n     }\n \n+    public <T> R isNaN(BoundReference<T> ref) {\n+      throw new UnsupportedOperationException(this.getClass().getName() + \" does not implement isNaN\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fc48a0f465426d032cbe2fe0a6c6026438536ec"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQzNzU1NQ==", "bodyText": "nit: looks like iceberg util classes use XxxUtil instead of utils. And there is a org.apache.iceberg.util package path for utils in the api module.", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r528437555", "createdAt": "2020-11-23T01:30:14Z", "author": {"login": "jackye1995"}, "path": "api/src/main/java/org/apache/iceberg/expressions/NaNUtils.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fc48a0f465426d032cbe2fe0a6c6026438536ec"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQ1MjgwNA==", "bodyText": "I agree that the containsNaNsOnly logic will not be very useful as Yan said, but I think it is also valuable to have that private method just for readability.\nThen the question reduces to: do we need to consider the case that null value metrics do not exist but NaN metrics do. For now I think the answer is no, because in all metrics modes NaN and null counters either both exist or both not exist.", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r528452804", "createdAt": "2020-11-23T03:08:32Z", "author": {"login": "jackye1995"}, "path": "api/src/main/java/org/apache/iceberg/expressions/InclusiveMetricsEvaluator.java", "diffHunk": "@@ -150,6 +152,53 @@ public Boolean or(Boolean leftResult, Boolean rightResult) {\n       return ROWS_MIGHT_MATCH;\n     }\n \n+    @Override\n+    public <T> Boolean isNaN(BoundReference<T> ref) {\n+      Integer id = ref.fieldId();\n+\n+      if (nanCounts != null && nanCounts.containsKey(id) && nanCounts.get(id) == 0) {\n+        return ROWS_CANNOT_MATCH;\n+      }\n+\n+      // when there's no nanCounts information, but we already know the column only contains null,\n+      // it's guaranteed that there's no NaN value\n+      if (containsNullsOnly(id)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY1NTY2Ng=="}, "originalCommit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQ1NDc2OA==", "bodyText": "Seems like #1803 is missing PartitionFieldSummary.containsNaN(), or is it in some other PR?", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r528454768", "createdAt": "2020-11-23T03:20:04Z", "author": {"login": "jackye1995"}, "path": "api/src/main/java/org/apache/iceberg/expressions/ManifestEvaluator.java", "diffHunk": "@@ -142,6 +142,25 @@ public Boolean or(Boolean leftResult, Boolean rightResult) {\n       return ROWS_MIGHT_MATCH;\n     }\n \n+    @Override\n+    public <T> Boolean isNaN(BoundReference<T> ref) {\n+      int pos = Accessors.toPosition(ref.accessor());\n+      // containsNull encodes whether at least one partition value is null, lowerBound is null if\n+      // all partition values are null.\n+      ByteBuffer lowerBound = stats.get(pos).lowerBound();\n+      if (lowerBound == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY2MTcyNA=="}, "originalCommit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQ1NTI4OA==", "bodyText": "good catch", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r528455288", "createdAt": "2020-11-23T03:23:05Z", "author": {"login": "jackye1995"}, "path": "api/src/main/java/org/apache/iceberg/expressions/StrictMetricsEvaluator.java", "diffHunk": "@@ -118,7 +120,7 @@ public Boolean or(Boolean leftResult, Boolean rightResult) {\n     public <T> Boolean isNull(BoundReference<T> ref) {\n       // no need to check whether the field is required because binding evaluates that case\n       // if the column has any non-null values, the expression does not match\n-      Integer id = ref.fieldId();\n+      int id = ref.fieldId();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fc48a0f465426d032cbe2fe0a6c6026438536ec"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQ1NTQxNQ==", "bodyText": "can refactor with containsNaNOnly as discussed above, and the checkstyle issue should not show up anymore.", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r528455415", "createdAt": "2020-11-23T03:23:46Z", "author": {"login": "jackye1995"}, "path": "api/src/main/java/org/apache/iceberg/expressions/StrictMetricsEvaluator.java", "diffHunk": "@@ -144,6 +146,35 @@ public Boolean or(Boolean leftResult, Boolean rightResult) {\n       return ROWS_MIGHT_NOT_MATCH;\n     }\n \n+    @Override\n+    @SuppressWarnings(\"checkstyle:CyclomaticComplexity\")\n+    public <T> Boolean isNaN(BoundReference<T> ref) {\n+      int id = ref.fieldId();\n+\n+      if (nanCounts != null && nanCounts.containsKey(id) &&", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fc48a0f465426d032cbe2fe0a6c6026438536ec"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQ1NjMwOA==", "bodyText": "I do not fully understand what you mean by \"rewrite logic of or(isNaN, in)/and(notNaN, notIn)\" when you talk about rewriting in. Can you give some examples of what predicate are you trying to support?", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r528456308", "createdAt": "2020-11-23T03:28:51Z", "author": {"login": "jackye1995"}, "path": "api/src/main/java/org/apache/iceberg/expressions/Expressions.java", "diffHunk": "@@ -123,6 +123,22 @@ public static Expression not(Expression child) {\n     return new UnboundPredicate<>(Expression.Operation.NOT_NULL, expr);\n   }\n \n+  public static <T> UnboundPredicate<T> isNaN(String name) {\n+    return new UnboundPredicate<>(Expression.Operation.IS_NAN, ref(name));\n+  }\n+\n+  public static <T> UnboundPredicate<T> isNaN(UnboundTerm<T> expr) {\n+    return new UnboundPredicate<>(Expression.Operation.IS_NAN, expr);\n+  }\n+\n+  public static <T> UnboundPredicate<T> notNaN(String name) {\n+    return new UnboundPredicate<>(Expression.Operation.NOT_NAN, ref(name));\n+  }\n+\n+  public static <T> UnboundPredicate<T> notNaN(UnboundTerm<T> expr) {\n+    return new UnboundPredicate<>(Expression.Operation.NOT_NAN, expr);\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY2MDgyNg=="}, "originalCommit": {"oid": "5789abb3c923c2528f42eed3f9f75bfcb8fb8a0c"}, "originalPosition": 18}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2ODc0MDIy", "url": "https://github.com/apache/iceberg/pull/1747#pullrequestreview-536874022", "createdAt": "2020-11-23T21:52:54Z", "commit": {"oid": "e853e50b369112ed337d46345d361b0c0697f6f1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMTo1Mjo1NFrOH4g0rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMTo1Mjo1NFrOH4g0rg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTAyMDA3OA==", "bodyText": "You can also use Comparators.forType. The dictionary cannot contain null values so there is no need to wrap for null handling.", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r529020078", "createdAt": "2020-11-23T21:52:54Z", "author": {"login": "rdblue"}, "path": "parquet/src/main/java/org/apache/iceberg/parquet/ParquetDictionaryRowGroupFilter.java", "diffHunk": "@@ -148,6 +150,39 @@ public Boolean or(Boolean leftResult, Boolean rightResult) {\n       return ROWS_MIGHT_MATCH;\n     }\n \n+    @Override\n+    public <T> Boolean isNaN(BoundReference<T> ref) {\n+      int id = ref.fieldId();\n+\n+      Boolean hasNonDictPage = isFallback.get(id);\n+      if (hasNonDictPage == null || hasNonDictPage) {\n+        return ROWS_MIGHT_MATCH;\n+      }\n+\n+      Set<T> dictionary = dict(id, comparatorForNaNPredicate(ref));\n+      return dictionary.stream().anyMatch(NaNUtil::isNaN) ? ROWS_MIGHT_MATCH : ROWS_CANNOT_MATCH;\n+    }\n+\n+    @Override\n+    public <T> Boolean notNaN(BoundReference<T> ref) {\n+      int id = ref.fieldId();\n+\n+      Boolean hasNonDictPage = isFallback.get(id);\n+      if (hasNonDictPage == null || hasNonDictPage) {\n+        return ROWS_MIGHT_MATCH;\n+      }\n+\n+      Set<T> dictionary = dict(id, comparatorForNaNPredicate(ref));\n+      return dictionary.stream().allMatch(NaNUtil::isNaN) ? ROWS_CANNOT_MATCH : ROWS_MIGHT_MATCH;\n+    }\n+\n+    private <T> Comparator<T> comparatorForNaNPredicate(BoundReference<T> ref) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e853e50b369112ed337d46345d361b0c0697f6f1"}, "originalPosition": 40}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "951699acce5dd52b5dd008a20619534f9362570d", "author": {"user": {"login": "yyanyy", "name": null}}, "url": "https://github.com/apache/iceberg/commit/951699acce5dd52b5dd008a20619534f9362570d", "committedDate": "2020-11-26T01:05:33Z", "message": "API: add isNaN and notNaN predicates"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f33f5fc9743dc7e214c3c7c3c63d6490b18ff327", "author": {"user": {"login": "yyanyy", "name": null}}, "url": "https://github.com/apache/iceberg/commit/f33f5fc9743dc7e214c3c7c3c63d6490b18ff327", "committedDate": "2020-11-26T01:05:33Z", "message": "update based on comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "80263ac891b53ae2e5748b5aa2b5e02e4f9de604", "author": {"user": {"login": "yyanyy", "name": null}}, "url": "https://github.com/apache/iceberg/commit/80263ac891b53ae2e5748b5aa2b5e02e4f9de604", "committedDate": "2020-11-26T01:05:33Z", "message": "minor refactoring/renaming"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "742d89855088d9e83cc26a54197333d4b9014744", "author": {"user": {"login": "yyanyy", "name": null}}, "url": "https://github.com/apache/iceberg/commit/742d89855088d9e83cc26a54197333d4b9014744", "committedDate": "2020-11-26T01:05:33Z", "message": "fix indentation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d7c3c3eacef4aced0bd89fe67339b2908a749a0f", "author": {"user": {"login": "yyanyy", "name": null}}, "url": "https://github.com/apache/iceberg/commit/d7c3c3eacef4aced0bd89fe67339b2908a749a0f", "committedDate": "2020-11-26T01:05:33Z", "message": "fix import order"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d5e666399663685d5fc583a692c57c090de74de3", "author": {"user": {"login": "yyanyy", "name": null}}, "url": "https://github.com/apache/iceberg/commit/d5e666399663685d5fc583a692c57c090de74de3", "committedDate": "2020-11-26T02:50:30Z", "message": "do not accept NaN in Expressions, or mismatch type"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e853e50b369112ed337d46345d361b0c0697f6f1", "author": {"user": {"login": "yyanyy", "name": null}}, "url": "https://github.com/apache/iceberg/commit/e853e50b369112ed337d46345d361b0c0697f6f1", "committedDate": "2020-11-23T21:16:52Z", "message": "fix import order"}, "afterCommit": {"oid": "d5e666399663685d5fc583a692c57c090de74de3", "author": {"user": {"login": "yyanyy", "name": null}}, "url": "https://github.com/apache/iceberg/commit/d5e666399663685d5fc583a692c57c090de74de3", "committedDate": "2020-11-26T02:50:30Z", "message": "do not accept NaN in Expressions, or mismatch type"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ1NjYxNTI2", "url": "https://github.com/apache/iceberg/pull/1747#pullrequestreview-545661526", "createdAt": "2020-12-06T01:10:34Z", "commit": {"oid": "d5e666399663685d5fc583a692c57c090de74de3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNlQwMToxMDozNFrOIADZ6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNlQwMToxMDozNFrOIADZ6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjkyNjY5Nw==", "bodyText": "An easier way to do this is to add the check in Literal.from. That's where Iceberg enforces that the value cannot be null. Since a literal is created for every value that is passed in, we would only need to change that one place instead of all of the factory methods here.\nIt also ensures that we don't add factory methods later and forget to add the check to them.", "url": "https://github.com/apache/iceberg/pull/1747#discussion_r536926697", "createdAt": "2020-12-06T01:10:34Z", "author": {"login": "rdblue"}, "path": "api/src/main/java/org/apache/iceberg/expressions/Expressions.java", "diffHunk": "@@ -123,51 +124,79 @@ public static Expression not(Expression child) {\n     return new UnboundPredicate<>(Expression.Operation.NOT_NULL, expr);\n   }\n \n+  public static <T> UnboundPredicate<T> isNaN(String name) {\n+    return new UnboundPredicate<>(Expression.Operation.IS_NAN, ref(name));\n+  }\n+\n+  public static <T> UnboundPredicate<T> isNaN(UnboundTerm<T> expr) {\n+    return new UnboundPredicate<>(Expression.Operation.IS_NAN, expr);\n+  }\n+\n+  public static <T> UnboundPredicate<T> notNaN(String name) {\n+    return new UnboundPredicate<>(Expression.Operation.NOT_NAN, ref(name));\n+  }\n+\n+  public static <T> UnboundPredicate<T> notNaN(UnboundTerm<T> expr) {\n+    return new UnboundPredicate<>(Expression.Operation.NOT_NAN, expr);\n+  }\n+\n   public static <T> UnboundPredicate<T> lessThan(String name, T value) {\n+    validateInput(\"lessThan\", value);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5e666399663685d5fc583a692c57c090de74de3"}, "originalPosition": 29}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3731, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}