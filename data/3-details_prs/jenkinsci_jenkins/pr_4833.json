{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ1NjQ0NTQx", "number": 4833, "title": "[JENKINS-62723] Fix behaviour of Util.isOverridden()", "bodyText": "See JENKINS-62723.\nBased on #4832 (which provides a unit test reproducing the issue)\nProposed changelog entries\n\nJENKINS-62723: Fix IllegalArgumentException: Method not found error caused by misbehaviour in Util.isOverridden() (regression in 2.241)\n\nProposed upgrade guidelines\nN/A\nSubmitter checklist\n\n (If applicable) Jira issue is well described\n Changelog entries and upgrade guidelines are appropriate for the audience affected by the change (users or developer, depending on the change). Examples\n\nFill-in the Proposed changelog entries section only if there are breaking changes or other changes which may require extra steps from users during the upgrade\n\n\n Appropriate autotests or explanation to why this change has no tests\n For dependency updates: links to external changelogs and, if possible, full diffs\n\nDesired reviewers\n@jglick\nMaintainer checklist\nBefore the changes are marked as ready-for-merge:\n\n There are at least 2 approvals for the pull request and no outstanding requests for change\n Conversations in the pull request are over OR it is explicit that a reviewer does not block the change\n Changelog entries in the PR title and/or Proposed changelog entries are correct\n Proper changelog labels are set so that the changelog can be generated automatically\n If the change needs additional upgrade steps from users, upgrade-guide-needed label is set and there is a Proposed upgrade guidelines section in the PR title. (example)\n If it would make sense to backport the change to LTS, a Jira issue must exist, be a Bug or Improvement, and be labeled as lts-candidate to be considered (see query).", "createdAt": "2020-07-07T20:11:45Z", "url": "https://github.com/jenkinsci/jenkins/pull/4833", "merged": true, "mergeCommit": {"oid": "f7ae11e6306935d0f3a4fdc0d0861c3b879304e9"}, "closed": true, "closedAt": "2020-07-15T19:51:16Z", "author": {"login": "Zastai"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcymiBdgH2gAyNDQ1NjQ0NTQxOmI5OGZlOTc5NDAyOTYwMjRhMzM3NmYxMjhhMWI3YjJlZWJiMjEwZmI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc0TJ8UAFqTQ0NjkwODc5OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "b98fe97940296024a3376f128a1b7b2eebb210fb", "author": {"user": {"login": "jglick", "name": "Jesse Glick"}}, "url": "https://github.com/jenkinsci/jenkins/commit/b98fe97940296024a3376f128a1b7b2eebb210fb", "committedDate": "2020-07-07T14:15:51Z", "message": "[JENKINS-62723] Demonstrating that Util.isOverridden is broken on final overrides"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "94eaecbe9352f3ee723d8ddb128085704c08a22c", "author": {"user": {"login": "jglick", "name": "Jesse Glick"}}, "url": "https://github.com/jenkinsci/jenkins/commit/94eaecbe9352f3ee723d8ddb128085704c08a22c", "committedDate": "2020-07-07T14:26:29Z", "message": "Make ErrorCollector actually work"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ccc0e347240d2f10da77ac8a311be9a30d5434ed", "author": {"user": {"login": "Zastai", "name": "Tim Van Holder"}}, "url": "https://github.com/jenkinsci/jenkins/commit/ccc0e347240d2f10da77ac8a311be9a30d5434ed", "committedDate": "2020-07-07T20:09:59Z", "message": "[JENKINS-62723] Improve Util.isOverridden\n\nIt will now deal with final/abstract methods appropriately.\nIt will also clearly report bad arguments (base not base of derived, or base does not declare the method).\nAdded a unit test for interface cases.\n\nSmall gap to be looked into: overrides provided via default implementation of a (derived) interface."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9c088c27f205e8e96125c5d55cb05a49b22909d5", "author": {"user": {"login": "Zastai", "name": "Tim Van Holder"}}, "url": "https://github.com/jenkinsci/jenkins/commit/9c088c27f205e8e96125c5d55cb05a49b22909d5", "committedDate": "2020-07-07T20:23:40Z", "message": "[JENKINS-62723] Further fix for Util.isOverridden\n\nThis handles the remaining case (override provided by default implementation of an interface)."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0Mjc3MzQy", "url": "https://github.com/jenkinsci/jenkins/pull/4833#pullrequestreview-444277342", "createdAt": "2020-07-07T21:54:39Z", "commit": {"oid": "9c088c27f205e8e96125c5d55cb05a49b22909d5"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMTo1NDozOVrOGuQ_XQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMTo1Njo0NlrOGuRC0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE2NjA0NQ==", "bodyText": "maybe document with @throws", "url": "https://github.com/jenkinsci/jenkins/pull/4833#discussion_r451166045", "createdAt": "2020-07-07T21:54:39Z", "author": {"login": "jglick"}, "path": "core/src/main/java/hudson/Util.java", "diffHunk": "@@ -1432,36 +1432,76 @@ public static Number tryParseNumber(@CheckForNull String numberStr, @CheckForNul\n     }\n \n     /**\n-     * Checks if the method defined on the base type with the given arguments\n-     * is overridden in the given derived type.\n-     */\n-    public static boolean isOverridden(@NonNull Class base, @NonNull Class derived, @NonNull String methodName, @NonNull Class... types) {\n-        return !getMethod(base, methodName, types).equals(getMethod(derived, methodName, types));\n+     * Checks whether the method defined on the base type with the given arguments is overridden in the given derived\n+     * type.\n+     *\n+     * @param base       The base type.\n+     * @param derived    The derived type.\n+     * @param methodName The name of the method.\n+     * @param types      The types of the arguments for the method.\n+     * @return {@code true} when {@code derived} provides the specified method other than as inherited from {@code base}.\n+     */\n+    public static boolean isOverridden(@NonNull Class<?> base, @NonNull Class<?> derived, @NonNull String methodName, @NonNull Class<?>... types) {\n+        // If derived is not a subclass or implementor of base, it can't override any method\n+        // Technically this should also be triggered when base == derived, because it can't override its own method, but\n+        // the unit tests explicitly test for that as working.\n+        if (!base.isAssignableFrom(derived)) {\n+            throw new IllegalArgumentException(\"The specified derived class (\" + derived.getCanonicalName() + \") does not derive from the specified base class (\" + base.getCanonicalName() + \").\");\n+        }\n+        final Method baseMethod = Util.getMethod(base, null, methodName, types);\n+        if (baseMethod == null) {\n+            throw new IllegalArgumentException(\"The specified method is not declared by the specified base class (\" + base.getCanonicalName() + \"), or it is private, static or final.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c088c27f205e8e96125c5d55cb05a49b22909d5"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE2Njc4Nw==", "bodyText": "The definition may come from a (non-default) interface method too. So this comment seems misleading?", "url": "https://github.com/jenkinsci/jenkins/pull/4833#discussion_r451166787", "createdAt": "2020-07-07T21:56:24Z", "author": {"login": "jglick"}, "path": "core/src/main/java/hudson/Util.java", "diffHunk": "@@ -1432,36 +1432,76 @@ public static Number tryParseNumber(@CheckForNull String numberStr, @CheckForNul\n     }\n \n     /**\n-     * Checks if the method defined on the base type with the given arguments\n-     * is overridden in the given derived type.\n-     */\n-    public static boolean isOverridden(@NonNull Class base, @NonNull Class derived, @NonNull String methodName, @NonNull Class... types) {\n-        return !getMethod(base, methodName, types).equals(getMethod(derived, methodName, types));\n+     * Checks whether the method defined on the base type with the given arguments is overridden in the given derived\n+     * type.\n+     *\n+     * @param base       The base type.\n+     * @param derived    The derived type.\n+     * @param methodName The name of the method.\n+     * @param types      The types of the arguments for the method.\n+     * @return {@code true} when {@code derived} provides the specified method other than as inherited from {@code base}.\n+     */\n+    public static boolean isOverridden(@NonNull Class<?> base, @NonNull Class<?> derived, @NonNull String methodName, @NonNull Class<?>... types) {\n+        // If derived is not a subclass or implementor of base, it can't override any method\n+        // Technically this should also be triggered when base == derived, because it can't override its own method, but\n+        // the unit tests explicitly test for that as working.\n+        if (!base.isAssignableFrom(derived)) {\n+            throw new IllegalArgumentException(\"The specified derived class (\" + derived.getCanonicalName() + \") does not derive from the specified base class (\" + base.getCanonicalName() + \").\");\n+        }\n+        final Method baseMethod = Util.getMethod(base, null, methodName, types);\n+        if (baseMethod == null) {\n+            throw new IllegalArgumentException(\"The specified method is not declared by the specified base class (\" + base.getCanonicalName() + \"), or it is private, static or final.\");\n+        }\n+        final Method derivedMethod = Util.getMethod(derived, base, methodName, types);\n+        // the lookup will either return null or the base method when no override has been found (depending on whether\n+        // the base is an interface)\n+        return derivedMethod != null && derivedMethod != baseMethod;\n     }\n \n-    private static Method getMethod(@NonNull Class clazz, @NonNull String methodName, @NonNull Class... types) {\n-        Method res = null;\n+    private static Method getMethod(@NonNull Class<?> clazz, @Nullable Class<?> base, @NonNull String methodName, @NonNull Class<?>... types) {\n         try {\n-            res = clazz.getDeclaredMethod(methodName, types);\n-            // private, static or final methods can not be overridden\n-            if (res != null && (Modifier.isPrivate(res.getModifiers()) || Modifier.isFinal(res.getModifiers()) \n-                    || Modifier.isStatic(res.getModifiers()))) {\n-                res = null;\n+            final Method res = clazz.getDeclaredMethod(methodName, types);\n+            final int mod = res.getModifiers();\n+            // private and static methods are never ok, and end the search\n+            if (Modifier.isPrivate(mod) || Modifier.isStatic(mod)) {\n+                return null;\n             }\n+            // when looking for the base/declaring method, final is not ok\n+            if (base == null && Modifier.isFinal(mod)) {\n+                return null;\n+            }\n+            // when looking for the overriding method, abstract is not ok\n+            if (base != null && Modifier.isAbstract(mod)) {\n+                return null;\n+            }\n+            return res;\n         } catch (NoSuchMethodException e) {\n+            // If the base is an interface, the implementation may come from a default implementation on a derived\n+            // interface. So look at interfaces too.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c088c27f205e8e96125c5d55cb05a49b22909d5"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE2NjkzMA==", "bodyText": "ditto this variable naming", "url": "https://github.com/jenkinsci/jenkins/pull/4833#discussion_r451166930", "createdAt": "2020-07-07T21:56:46Z", "author": {"login": "jglick"}, "path": "core/src/main/java/hudson/Util.java", "diffHunk": "@@ -1432,36 +1432,76 @@ public static Number tryParseNumber(@CheckForNull String numberStr, @CheckForNul\n     }\n \n     /**\n-     * Checks if the method defined on the base type with the given arguments\n-     * is overridden in the given derived type.\n-     */\n-    public static boolean isOverridden(@NonNull Class base, @NonNull Class derived, @NonNull String methodName, @NonNull Class... types) {\n-        return !getMethod(base, methodName, types).equals(getMethod(derived, methodName, types));\n+     * Checks whether the method defined on the base type with the given arguments is overridden in the given derived\n+     * type.\n+     *\n+     * @param base       The base type.\n+     * @param derived    The derived type.\n+     * @param methodName The name of the method.\n+     * @param types      The types of the arguments for the method.\n+     * @return {@code true} when {@code derived} provides the specified method other than as inherited from {@code base}.\n+     */\n+    public static boolean isOverridden(@NonNull Class<?> base, @NonNull Class<?> derived, @NonNull String methodName, @NonNull Class<?>... types) {\n+        // If derived is not a subclass or implementor of base, it can't override any method\n+        // Technically this should also be triggered when base == derived, because it can't override its own method, but\n+        // the unit tests explicitly test for that as working.\n+        if (!base.isAssignableFrom(derived)) {\n+            throw new IllegalArgumentException(\"The specified derived class (\" + derived.getCanonicalName() + \") does not derive from the specified base class (\" + base.getCanonicalName() + \").\");\n+        }\n+        final Method baseMethod = Util.getMethod(base, null, methodName, types);\n+        if (baseMethod == null) {\n+            throw new IllegalArgumentException(\"The specified method is not declared by the specified base class (\" + base.getCanonicalName() + \"), or it is private, static or final.\");\n+        }\n+        final Method derivedMethod = Util.getMethod(derived, base, methodName, types);\n+        // the lookup will either return null or the base method when no override has been found (depending on whether\n+        // the base is an interface)\n+        return derivedMethod != null && derivedMethod != baseMethod;\n     }\n \n-    private static Method getMethod(@NonNull Class clazz, @NonNull String methodName, @NonNull Class... types) {\n-        Method res = null;\n+    private static Method getMethod(@NonNull Class<?> clazz, @Nullable Class<?> base, @NonNull String methodName, @NonNull Class<?>... types) {\n         try {\n-            res = clazz.getDeclaredMethod(methodName, types);\n-            // private, static or final methods can not be overridden\n-            if (res != null && (Modifier.isPrivate(res.getModifiers()) || Modifier.isFinal(res.getModifiers()) \n-                    || Modifier.isStatic(res.getModifiers()))) {\n-                res = null;\n+            final Method res = clazz.getDeclaredMethod(methodName, types);\n+            final int mod = res.getModifiers();\n+            // private and static methods are never ok, and end the search\n+            if (Modifier.isPrivate(mod) || Modifier.isStatic(mod)) {\n+                return null;\n             }\n+            // when looking for the base/declaring method, final is not ok\n+            if (base == null && Modifier.isFinal(mod)) {\n+                return null;\n+            }\n+            // when looking for the overriding method, abstract is not ok\n+            if (base != null && Modifier.isAbstract(mod)) {\n+                return null;\n+            }\n+            return res;\n         } catch (NoSuchMethodException e) {\n+            // If the base is an interface, the implementation may come from a default implementation on a derived\n+            // interface. So look at interfaces too.\n+            if (base != null && Modifier.isInterface(base.getModifiers())) {\n+                for (Class<?> iface : clazz.getInterfaces()) {\n+                    if (base.equals(iface) || !base.isAssignableFrom(iface)) {\n+                        continue;\n+                    }\n+                    final Method defaultImpl = Util.getMethod(iface, base, methodName, types);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c088c27f205e8e96125c5d55cb05a49b22909d5"}, "originalPosition": 67}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0Mjg0MDgy", "url": "https://github.com/jenkinsci/jenkins/pull/4833#pullrequestreview-444284082", "createdAt": "2020-07-07T22:08:03Z", "commit": {"oid": "9c088c27f205e8e96125c5d55cb05a49b22909d5"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMjowODowM1rOGuRVKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMjowODoxN1rOGuRVdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE3MTYyNw==", "bodyText": "Should we not also check that baseMethod.getDeclaringClass() == base?", "url": "https://github.com/jenkinsci/jenkins/pull/4833#discussion_r451171627", "createdAt": "2020-07-07T22:08:03Z", "author": {"login": "jglick"}, "path": "core/src/main/java/hudson/Util.java", "diffHunk": "@@ -1432,36 +1432,76 @@ public static Number tryParseNumber(@CheckForNull String numberStr, @CheckForNul\n     }\n \n     /**\n-     * Checks if the method defined on the base type with the given arguments\n-     * is overridden in the given derived type.\n-     */\n-    public static boolean isOverridden(@NonNull Class base, @NonNull Class derived, @NonNull String methodName, @NonNull Class... types) {\n-        return !getMethod(base, methodName, types).equals(getMethod(derived, methodName, types));\n+     * Checks whether the method defined on the base type with the given arguments is overridden in the given derived\n+     * type.\n+     *\n+     * @param base       The base type.\n+     * @param derived    The derived type.\n+     * @param methodName The name of the method.\n+     * @param types      The types of the arguments for the method.\n+     * @return {@code true} when {@code derived} provides the specified method other than as inherited from {@code base}.\n+     */\n+    public static boolean isOverridden(@NonNull Class<?> base, @NonNull Class<?> derived, @NonNull String methodName, @NonNull Class<?>... types) {\n+        // If derived is not a subclass or implementor of base, it can't override any method\n+        // Technically this should also be triggered when base == derived, because it can't override its own method, but\n+        // the unit tests explicitly test for that as working.\n+        if (!base.isAssignableFrom(derived)) {\n+            throw new IllegalArgumentException(\"The specified derived class (\" + derived.getCanonicalName() + \") does not derive from the specified base class (\" + base.getCanonicalName() + \").\");\n+        }\n+        final Method baseMethod = Util.getMethod(base, null, methodName, types);\n+        if (baseMethod == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c088c27f205e8e96125c5d55cb05a49b22909d5"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE3MTcwMA==", "bodyText": "OK, only fuzzily understand what is going on here, ignore.", "url": "https://github.com/jenkinsci/jenkins/pull/4833#discussion_r451171700", "createdAt": "2020-07-07T22:08:17Z", "author": {"login": "jglick"}, "path": "core/src/main/java/hudson/Util.java", "diffHunk": "@@ -1432,36 +1432,76 @@ public static Number tryParseNumber(@CheckForNull String numberStr, @CheckForNul\n     }\n \n     /**\n-     * Checks if the method defined on the base type with the given arguments\n-     * is overridden in the given derived type.\n-     */\n-    public static boolean isOverridden(@NonNull Class base, @NonNull Class derived, @NonNull String methodName, @NonNull Class... types) {\n-        return !getMethod(base, methodName, types).equals(getMethod(derived, methodName, types));\n+     * Checks whether the method defined on the base type with the given arguments is overridden in the given derived\n+     * type.\n+     *\n+     * @param base       The base type.\n+     * @param derived    The derived type.\n+     * @param methodName The name of the method.\n+     * @param types      The types of the arguments for the method.\n+     * @return {@code true} when {@code derived} provides the specified method other than as inherited from {@code base}.\n+     */\n+    public static boolean isOverridden(@NonNull Class<?> base, @NonNull Class<?> derived, @NonNull String methodName, @NonNull Class<?>... types) {\n+        // If derived is not a subclass or implementor of base, it can't override any method\n+        // Technically this should also be triggered when base == derived, because it can't override its own method, but\n+        // the unit tests explicitly test for that as working.\n+        if (!base.isAssignableFrom(derived)) {\n+            throw new IllegalArgumentException(\"The specified derived class (\" + derived.getCanonicalName() + \") does not derive from the specified base class (\" + base.getCanonicalName() + \").\");\n+        }\n+        final Method baseMethod = Util.getMethod(base, null, methodName, types);\n+        if (baseMethod == null) {\n+            throw new IllegalArgumentException(\"The specified method is not declared by the specified base class (\" + base.getCanonicalName() + \"), or it is private, static or final.\");\n+        }\n+        final Method derivedMethod = Util.getMethod(derived, base, methodName, types);\n+        // the lookup will either return null or the base method when no override has been found (depending on whether\n+        // the base is an interface)\n+        return derivedMethod != null && derivedMethod != baseMethod;\n     }\n \n-    private static Method getMethod(@NonNull Class clazz, @NonNull String methodName, @NonNull Class... types) {\n-        Method res = null;\n+    private static Method getMethod(@NonNull Class<?> clazz, @Nullable Class<?> base, @NonNull String methodName, @NonNull Class<?>... types) {\n         try {\n-            res = clazz.getDeclaredMethod(methodName, types);\n-            // private, static or final methods can not be overridden\n-            if (res != null && (Modifier.isPrivate(res.getModifiers()) || Modifier.isFinal(res.getModifiers()) \n-                    || Modifier.isStatic(res.getModifiers()))) {\n-                res = null;\n+            final Method res = clazz.getDeclaredMethod(methodName, types);\n+            final int mod = res.getModifiers();\n+            // private and static methods are never ok, and end the search\n+            if (Modifier.isPrivate(mod) || Modifier.isStatic(mod)) {\n+                return null;\n             }\n+            // when looking for the base/declaring method, final is not ok\n+            if (base == null && Modifier.isFinal(mod)) {\n+                return null;\n+            }\n+            // when looking for the overriding method, abstract is not ok\n+            if (base != null && Modifier.isAbstract(mod)) {\n+                return null;\n+            }\n+            return res;\n         } catch (NoSuchMethodException e) {\n+            // If the base is an interface, the implementation may come from a default implementation on a derived\n+            // interface. So look at interfaces too.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE2Njc4Nw=="}, "originalCommit": {"oid": "9c088c27f205e8e96125c5d55cb05a49b22909d5"}, "originalPosition": 61}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7c2abcfa944cbe1285c9932dc797ee6c1db8eee9", "author": {"user": {"login": "Zastai", "name": "Tim Van Holder"}}, "url": "https://github.com/jenkinsci/jenkins/commit/7c2abcfa944cbe1285c9932dc797ee6c1db8eee9", "committedDate": "2020-07-07T22:09:21Z", "message": "[JENKINS-62723] Extend JavaDoc with `@throws`"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0NDY0NzMx", "url": "https://github.com/jenkinsci/jenkins/pull/4833#pullrequestreview-444464731", "createdAt": "2020-07-08T07:05:22Z", "commit": {"oid": "7c2abcfa944cbe1285c9932dc797ee6c1db8eee9"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0NDcxNjQ5", "url": "https://github.com/jenkinsci/jenkins/pull/4833#pullrequestreview-444471649", "createdAt": "2020-07-08T07:16:56Z", "commit": {"oid": "7c2abcfa944cbe1285c9932dc797ee6c1db8eee9"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2OTA4Nzk4", "url": "https://github.com/jenkinsci/jenkins/pull/4833#pullrequestreview-446908798", "createdAt": "2020-07-12T20:49:12Z", "commit": {"oid": "7c2abcfa944cbe1285c9932dc797ee6c1db8eee9"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2106, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}