{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc4NjQwMzI2", "number": 4517, "title": "[JENKINS-43889] Make sure Environments are always torn down (in AbstractBuild)", "bodyText": "See JENKINS-43889.\nTLDR for JENKINS-43889: Environments can be attached very early to an AbstractBuild (before SCM checkout), by either BuildWrappers and RunListeners, but then they might never be torn down, if the build fails too early (in SCM checkout). A real-life example is the SSH-Agent plugin leaving orphan ssh-agent processes running (when a Freestyle job, or Maven job, fails in SCM).\nThis PR contains three commits:\n\nfirst commit (5f324c7) adds a test case showing the issue in the case of a SimpleBuildWrapper set for pre-checkout execution (it shows a Disposer not being called in case of failure of SCM checkout)\nsecond commit (a5ab5dc) is the fix: it moves the teardown logic from the AbtractBuildExecution#doRun implementation (BuildExecution#doRun for Freestyle jobs) up to the AbtractBuildExecution#run method itself, in a finally block. To avoid tearing down environments twice in case a different AbtractBuildExecution#doRun implementation is at play (for instance in case of a Maven job), an extra Environment is added, which changes state when torn down, and serves as a marker.\nthird commit (33ecdda) adds a test case to verify that the Disposer of a SimpleBuildWrapper is called exactly once, including for a Maven build (to validate the above trick with the marker Environment).\n\nUpdate: commits added after opening the PR:\n\nextraction of the tear down loop into its own method: 050f166\nutility method in Result, to get the worse of two nullable Results: 2132275 + ee8002f => let me know if this doesn't deserve being in Result, and I should use a local private method instead\nimprove exceptions handling when tearing down environments: 625b783 + 0a44fe0\n\nNotes:\n\nthis PR is easier to review when ignoring whitespaces (because of the added try/finally)\nBefore this change, the AbstractBuild#buildEnvironments list was only initialized in createLauncher() after the wrappers' decorateLauncher() had been called. Which means these methods were not able to contribute environments (I think). It is now done a bit earlier, meaning they can. I don't know if it's an issue.\nThe code for calling tearDown on environments in finally block is a bit different from what was previously in BuildExecution#doRun: is catches exceptions, and tries hard to complete iteration on all environments. It is closer to what's done in the Maven plugin. And in case of an InterruptedException, I was not sure what to do TBH: I went for finishing the iteration and then interrupting the thread again (and setting result to FAILED, like for any other exception) after some reviewers feedback, I went for re-throwing the (first) caught InterruptedException, and let the caller (Run#execute(RunExecution)) deal with it (which will result in an ABORTED build result).\n\nProposed changelog entries\n\nJENKINS-43889, bug: fix environments not always being torn down (issue 43889)\nJENKINS-43889, rfe: Developer: new static utility method Result#combine(Result,Result) to get the worst of two (nullable) build results\n\nProposed upgrade guidelines\nN/A\nSubmitter checklist\n\n JIRA issue is well described\n Changelog entries and upgrade guidelines are appropriate for the audience affected by the change (users or developer, depending on the change). Examples\n\nFill-in the Proposed changelog entries section only if there are breaking changes or other changes which may require extra steps from users during the upgrade\n\n\n Appropriate autotests or explanation to why this change has no tests\n For dependency updates: links to external changelogs and, if possible, full diffs\n\nDesired reviewers\nMaybe @jglick? (as author of SimpleBuildWrapper(Test))\nMaintainer checklist\nBefore the changes are marked as ready-for-merge:\n\n There are at least 2 approvals for the pull request and no outstanding requests for change\n Conversations in the pull request are over OR it is explicit that a reviewer does not block the change\n Changelog entries in the PR title and/or Proposed changelog entries are correct\n Proper changelog labels are set so that the changelog can be generated automatically\n If the change needs additional upgrade steps from users, upgrade-guide-needed label is set and there is a Proposed upgrade guidelines section in the PR title. (example)\n If it would make sense to backport the change to LTS, a JIRA issue should exist and be labeled as lts-candidate", "createdAt": "2020-02-22T23:01:31Z", "url": "https://github.com/jenkinsci/jenkins/pull/4517", "merged": true, "mergeCommit": {"oid": "5b1dd72d9b7f295c23f19dd21a8827de519be6d8"}, "closed": true, "closedAt": "2020-09-14T06:46:38Z", "author": {"login": "thomasgl-orange"}, "timelineItems": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcG7MgMgH2gAyMzc4NjQwMzI2OjVmMzI0Yzc3NWFiZjM3N2UyNzRiZTk0YTVjNGY1YjY2YjkxZTZiYjc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcYcKKBABqjMyNDMxNjcyMzg=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "5f324c775abf377e274be94a5c4f5b66b91e6bb7", "author": {"user": {"login": "thomasgl-orange", "name": "Thomas de Grenier de Latour"}}, "url": "https://github.com/jenkinsci/jenkins/commit/5f324c775abf377e274be94a5c4f5b66b91e6bb7", "committedDate": "2020-02-22T21:27:41Z", "message": "[JENKINS-43889] Environment from pre-checkout SimpleBuildWrapper not always teared down\n\nAn Environment contributed by a pre-checkout SimpleBuildWrapper will not be teared\ndown is the build stops too early (for instance during SCM checkout).\nAlthough JENKINS-43889 was not originally about SimpleBuildWrapper, but about a\n\"regular\" BuildWrapper (in ssh-agent-plugin), it really is the same issue (with the\nEnvironment being added by the preCheckout method)."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a5ab5dc27341003032d708d18152bb696cfd3e1f", "author": {"user": {"login": "thomasgl-orange", "name": "Thomas de Grenier de Latour"}}, "url": "https://github.com/jenkinsci/jenkins/commit/a5ab5dc27341003032d708d18152bb696cfd3e1f", "committedDate": "2020-02-22T21:27:41Z", "message": "[JENKINS-43889] AbstractBuildExecution: ensure Environments are always teared down\n\nBefore this change, in an AbstractBuildExecution, tearing down Environments used to\nbe left to the doRun() implementations.  But this comes too late to actually tear down\nthe ones which have been setup before checkout (by BuildWrapper#preCheckout, or\nRunListener#setUpEnvironment).\n\nTearing down Environments is now done directly in AbstractBuildExecution#run(), in a\nfinally block.\n\nThe BuildExecution#doRun implementation is modified to take that into account.\nBut because in plugins (for instance maven-plugin) there are still implementations\nof doRun() which could tear down Environments themselves, we use a dummy\nEnvironment (TearDownCheckEnvironment) as a marker to check whether teardown\nhas been done already, and avoid doing it twice."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "33ecdda7747b4c366ca9194f906934021a0e0928", "author": {"user": {"login": "thomasgl-orange", "name": "Thomas de Grenier de Latour"}}, "url": "https://github.com/jenkinsci/jenkins/commit/33ecdda7747b4c366ca9194f906934021a0e0928", "committedDate": "2020-02-22T21:27:41Z", "message": "[JENKINS-43889] test tearDown is called only once (including for Maven builds)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d7a024ec2a5d17c3814141e88edf0edc33af7af5", "author": {"user": {"login": "thomasgl-orange", "name": "Thomas de Grenier de Latour"}}, "url": "https://github.com/jenkinsci/jenkins/commit/d7a024ec2a5d17c3814141e88edf0edc33af7af5", "committedDate": "2020-02-23T14:57:58Z", "message": "s/teared/torn/ - sorry my bad English"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0ODc5Mjg1", "url": "https://github.com/jenkinsci/jenkins/pull/4517#pullrequestreview-364879285", "createdAt": "2020-02-26T13:04:06Z", "commit": {"oid": "d7a024ec2a5d17c3814141e88edf0edc33af7af5"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxMzowNDowNlrOFuqrnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxMzoxMjowNlrOFuq6zg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQ3ODEwOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    private class TearDownCheckEnvironment extends Environment {\n          \n          \n            \n                    private static class TearDownCheckEnvironment extends Environment {", "url": "https://github.com/jenkinsci/jenkins/pull/4517#discussion_r384478108", "createdAt": "2020-02-26T13:04:06Z", "author": {"login": "res0nance"}, "path": "core/src/main/java/hudson/model/AbstractBuild.java", "diffHunk": "@@ -518,6 +559,20 @@ public Result run(@Nonnull BuildListener listener) throws Exception {\n             return result;\n         }\n \n+        /**\n+         * An {@link Environment} which does nothing, but change state when it gets torn down. Used in\n+         * {@link AbstractBuildExecution#run(BuildListener)} to detect whether environments have yet to be torn down,\n+         * or if it has been done already (in the {@link AbstractBuildExecution#doRun(BuildListener)} implementation).\n+         */\n+        private class TearDownCheckEnvironment extends Environment {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7a024ec2a5d17c3814141e88edf0edc33af7af5"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQ4MTAzOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        e.printStackTrace(listener.getLogger());\n          \n          \n            \n                                        Functions.printStackTrace(e,listener.getLogger());\n          \n      \n    \n    \n  \n\nCore has something close to this i forgot what it was exactly", "url": "https://github.com/jenkinsci/jenkins/pull/4517#discussion_r384481039", "createdAt": "2020-02-26T13:10:11Z", "author": {"login": "res0nance"}, "path": "core/src/main/java/hudson/model/AbstractBuild.java", "diffHunk": "@@ -459,49 +459,90 @@ public Result run(@Nonnull BuildListener listener) throws Exception {\n             hudsonVersion = Jenkins.VERSION;\n             this.listener = listener;\n \n-            launcher = createLauncher(listener);\n-            if (!Jenkins.get().getNodes().isEmpty()) {\n-                if (node instanceof Jenkins) {\n-                    listener.getLogger().print(Messages.AbstractBuild_BuildingOnMaster());\n-                } else {\n-                    listener.getLogger().print(Messages.AbstractBuild_BuildingRemotely(ModelHyperlinkNote.encodeTo(\"/computer/\" + builtOn, node.getDisplayName())));\n-                    Set<LabelAtom> assignedLabels = new HashSet<>(node.getAssignedLabels());\n-                    assignedLabels.remove(node.getSelfLabel());\n-                    if (!assignedLabels.isEmpty()) {\n-                        boolean first = true;\n-                        for (LabelAtom label : assignedLabels) {\n-                            if (first) {\n-                                listener.getLogger().print(\" (\");\n-                                first = false;\n-                            } else {\n-                                listener.getLogger().print(' ');\n+            Result result;\n+            buildEnvironments = new ArrayList<>();\n+            // JENKINS-43889: try/finally to make sure Environments are eventually torn down. This used to be done in\n+            // the doRun() implementation, but was not happening in case of early error (for instance in SCM checkout).\n+            // Because some plugin (Maven) implement their own doRun() logic which still includes tearing down in some\n+            // cases, we use a dummy Environment as a marker, to avoid doing it here if redundant.\n+            TearDownCheckEnvironment tearDownMarker = new TearDownCheckEnvironment();\n+            buildEnvironments.add(tearDownMarker);\n+            try {\n+                launcher = createLauncher(listener);\n+                if (!Jenkins.get().getNodes().isEmpty()) {\n+                    if (node instanceof Jenkins) {\n+                        listener.getLogger().print(Messages.AbstractBuild_BuildingOnMaster());\n+                    } else {\n+                        listener.getLogger().print(Messages.AbstractBuild_BuildingRemotely(ModelHyperlinkNote.encodeTo(\"/computer/\" + builtOn, node.getDisplayName())));\n+                        Set<LabelAtom> assignedLabels = new HashSet<>(node.getAssignedLabels());\n+                        assignedLabels.remove(node.getSelfLabel());\n+                        if (!assignedLabels.isEmpty()) {\n+                            boolean first = true;\n+                            for (LabelAtom label : assignedLabels) {\n+                                if (first) {\n+                                    listener.getLogger().print(\" (\");\n+                                    first = false;\n+                                } else {\n+                                    listener.getLogger().print(' ');\n+                                }\n+                                listener.getLogger().print(label.getName());\n                             }\n-                            listener.getLogger().print(label.getName());\n+                            listener.getLogger().print(')');\n                         }\n-                        listener.getLogger().print(')');\n                     }\n+                } else {\n+                    listener.getLogger().print(Messages.AbstractBuild_Building());\n                 }\n-            } else {\n-                listener.getLogger().print(Messages.AbstractBuild_Building());\n-            }\n-            \n-            lease = decideWorkspace(node, Computer.currentComputer().getWorkspaceList());\n+                \n+                lease = decideWorkspace(node, Computer.currentComputer().getWorkspaceList());\n \n-            workspace = lease.path.getRemote();\n-            listener.getLogger().println(Messages.AbstractBuild_BuildingInWorkspace(workspace));\n-            node.getFileSystemProvisioner().prepareWorkspace(AbstractBuild.this,lease.path,listener);\n+                workspace = lease.path.getRemote();\n+                listener.getLogger().println(Messages.AbstractBuild_BuildingInWorkspace(workspace));\n+                node.getFileSystemProvisioner().prepareWorkspace(AbstractBuild.this,lease.path,listener);\n \n-            for (WorkspaceListener wl : WorkspaceListener.all()) {\n-                wl.beforeUse(AbstractBuild.this, lease.path, listener);\n-            }\n+                for (WorkspaceListener wl : WorkspaceListener.all()) {\n+                    wl.beforeUse(AbstractBuild.this, lease.path, listener);\n+                }\n \n-            getProject().getScmCheckoutStrategy().preCheckout(AbstractBuild.this, launcher, this.listener);\n-            getProject().getScmCheckoutStrategy().checkout(this);\n+                getProject().getScmCheckoutStrategy().preCheckout(AbstractBuild.this, launcher, this.listener);\n+                getProject().getScmCheckoutStrategy().checkout(this);\n \n-            if (!preBuild(listener,project.getProperties()))\n-                return Result.FAILURE;\n+                if (!preBuild(listener,project.getProperties()))\n+                    return Result.FAILURE;\n \n-            Result result = doRun(listener);\n+                result = doRun(listener);\n+            } finally {\n+                if (!tearDownMarker.tornDown) {\n+                    // looks like environments are not torn down yet, do it now (in reverse order)\n+                    boolean tearDownFailed = false;\n+                    boolean tearDownInterrupted = false;\n+                    for (int i = buildEnvironments.size() - 1; i >= 0; i--) {\n+                        final Environment environment = buildEnvironments.get(i);\n+                        try {\n+                            if (!environment.tearDown(AbstractBuild.this, listener)) {\n+                                tearDownFailed = true;\n+                            }\n+                        } catch (IOException | InterruptedException | RuntimeException e) {\n+                            tearDownFailed = true;\n+                            // exceptions are ignored to give a chance to all environments to tear down\n+                            listener.error(\"Unable to tear down: \" + e.getMessage());\n+                            e.printStackTrace(listener.getLogger());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7a024ec2a5d17c3814141e88edf0edc33af7af5"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQ4MTk5OA==", "bodyText": "I'm not sure if this is the right approach since being interrupted usually means to exit ASAP", "url": "https://github.com/jenkinsci/jenkins/pull/4517#discussion_r384481998", "createdAt": "2020-02-26T13:12:06Z", "author": {"login": "res0nance"}, "path": "core/src/main/java/hudson/model/AbstractBuild.java", "diffHunk": "@@ -459,49 +459,90 @@ public Result run(@Nonnull BuildListener listener) throws Exception {\n             hudsonVersion = Jenkins.VERSION;\n             this.listener = listener;\n \n-            launcher = createLauncher(listener);\n-            if (!Jenkins.get().getNodes().isEmpty()) {\n-                if (node instanceof Jenkins) {\n-                    listener.getLogger().print(Messages.AbstractBuild_BuildingOnMaster());\n-                } else {\n-                    listener.getLogger().print(Messages.AbstractBuild_BuildingRemotely(ModelHyperlinkNote.encodeTo(\"/computer/\" + builtOn, node.getDisplayName())));\n-                    Set<LabelAtom> assignedLabels = new HashSet<>(node.getAssignedLabels());\n-                    assignedLabels.remove(node.getSelfLabel());\n-                    if (!assignedLabels.isEmpty()) {\n-                        boolean first = true;\n-                        for (LabelAtom label : assignedLabels) {\n-                            if (first) {\n-                                listener.getLogger().print(\" (\");\n-                                first = false;\n-                            } else {\n-                                listener.getLogger().print(' ');\n+            Result result;\n+            buildEnvironments = new ArrayList<>();\n+            // JENKINS-43889: try/finally to make sure Environments are eventually torn down. This used to be done in\n+            // the doRun() implementation, but was not happening in case of early error (for instance in SCM checkout).\n+            // Because some plugin (Maven) implement their own doRun() logic which still includes tearing down in some\n+            // cases, we use a dummy Environment as a marker, to avoid doing it here if redundant.\n+            TearDownCheckEnvironment tearDownMarker = new TearDownCheckEnvironment();\n+            buildEnvironments.add(tearDownMarker);\n+            try {\n+                launcher = createLauncher(listener);\n+                if (!Jenkins.get().getNodes().isEmpty()) {\n+                    if (node instanceof Jenkins) {\n+                        listener.getLogger().print(Messages.AbstractBuild_BuildingOnMaster());\n+                    } else {\n+                        listener.getLogger().print(Messages.AbstractBuild_BuildingRemotely(ModelHyperlinkNote.encodeTo(\"/computer/\" + builtOn, node.getDisplayName())));\n+                        Set<LabelAtom> assignedLabels = new HashSet<>(node.getAssignedLabels());\n+                        assignedLabels.remove(node.getSelfLabel());\n+                        if (!assignedLabels.isEmpty()) {\n+                            boolean first = true;\n+                            for (LabelAtom label : assignedLabels) {\n+                                if (first) {\n+                                    listener.getLogger().print(\" (\");\n+                                    first = false;\n+                                } else {\n+                                    listener.getLogger().print(' ');\n+                                }\n+                                listener.getLogger().print(label.getName());\n                             }\n-                            listener.getLogger().print(label.getName());\n+                            listener.getLogger().print(')');\n                         }\n-                        listener.getLogger().print(')');\n                     }\n+                } else {\n+                    listener.getLogger().print(Messages.AbstractBuild_Building());\n                 }\n-            } else {\n-                listener.getLogger().print(Messages.AbstractBuild_Building());\n-            }\n-            \n-            lease = decideWorkspace(node, Computer.currentComputer().getWorkspaceList());\n+                \n+                lease = decideWorkspace(node, Computer.currentComputer().getWorkspaceList());\n \n-            workspace = lease.path.getRemote();\n-            listener.getLogger().println(Messages.AbstractBuild_BuildingInWorkspace(workspace));\n-            node.getFileSystemProvisioner().prepareWorkspace(AbstractBuild.this,lease.path,listener);\n+                workspace = lease.path.getRemote();\n+                listener.getLogger().println(Messages.AbstractBuild_BuildingInWorkspace(workspace));\n+                node.getFileSystemProvisioner().prepareWorkspace(AbstractBuild.this,lease.path,listener);\n \n-            for (WorkspaceListener wl : WorkspaceListener.all()) {\n-                wl.beforeUse(AbstractBuild.this, lease.path, listener);\n-            }\n+                for (WorkspaceListener wl : WorkspaceListener.all()) {\n+                    wl.beforeUse(AbstractBuild.this, lease.path, listener);\n+                }\n \n-            getProject().getScmCheckoutStrategy().preCheckout(AbstractBuild.this, launcher, this.listener);\n-            getProject().getScmCheckoutStrategy().checkout(this);\n+                getProject().getScmCheckoutStrategy().preCheckout(AbstractBuild.this, launcher, this.listener);\n+                getProject().getScmCheckoutStrategy().checkout(this);\n \n-            if (!preBuild(listener,project.getProperties()))\n-                return Result.FAILURE;\n+                if (!preBuild(listener,project.getProperties()))\n+                    return Result.FAILURE;\n \n-            Result result = doRun(listener);\n+                result = doRun(listener);\n+            } finally {\n+                if (!tearDownMarker.tornDown) {\n+                    // looks like environments are not torn down yet, do it now (in reverse order)\n+                    boolean tearDownFailed = false;\n+                    boolean tearDownInterrupted = false;\n+                    for (int i = buildEnvironments.size() - 1; i >= 0; i--) {\n+                        final Environment environment = buildEnvironments.get(i);\n+                        try {\n+                            if (!environment.tearDown(AbstractBuild.this, listener)) {\n+                                tearDownFailed = true;\n+                            }\n+                        } catch (IOException | InterruptedException | RuntimeException e) {\n+                            tearDownFailed = true;\n+                            // exceptions are ignored to give a chance to all environments to tear down\n+                            listener.error(\"Unable to tear down: \" + e.getMessage());\n+                            e.printStackTrace(listener.getLogger());\n+                            if (e instanceof InterruptedException) {\n+                                // don't forget we've been interrupted\n+                                tearDownInterrupted = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7a024ec2a5d17c3814141e88edf0edc33af7af5"}, "originalPosition": 108}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "15193af21d387218ed248182b2ef3e398ad0a593", "author": {"user": {"login": "thomasgl-orange", "name": "Thomas de Grenier de Latour"}}, "url": "https://github.com/jenkinsci/jenkins/commit/15193af21d387218ed248182b2ef3e398ad0a593", "committedDate": "2020-02-26T13:58:58Z", "message": "Apply suggestions from code review\n\nCo-Authored-By: Raihaan Shouhell <raihaanhimself@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8aacaca83d48b63852097c3a3e0e58bd37e8c5bf", "author": {"user": {"login": "thomasgl-orange", "name": "Thomas de Grenier de Latour"}}, "url": "https://github.com/jenkinsci/jenkins/commit/8aacaca83d48b63852097c3a3e0e58bd37e8c5bf", "committedDate": "2020-02-26T13:40:22Z", "message": "Apply suggestions from code review\n\nCo-Authored-By: Raihaan Shouhell <raihaanhimself@gmail.com>"}, "afterCommit": {"oid": "15193af21d387218ed248182b2ef3e398ad0a593", "author": {"user": {"login": "thomasgl-orange", "name": "Thomas de Grenier de Latour"}}, "url": "https://github.com/jenkinsci/jenkins/commit/15193af21d387218ed248182b2ef3e398ad0a593", "committedDate": "2020-02-26T13:58:58Z", "message": "Apply suggestions from code review\n\nCo-Authored-By: Raihaan Shouhell <raihaanhimself@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1NTc0OTc2", "url": "https://github.com/jenkinsci/jenkins/pull/4517#pullrequestreview-365574976", "createdAt": "2020-02-27T10:37:23Z", "commit": {"oid": "15193af21d387218ed248182b2ef3e398ad0a593"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxMDozNzoyM1rOFvNMQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxMDo0MDozN1rOFvNS_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA0MzUyMw==", "bodyText": "Maybe a good opportunity to include curly brackets here.", "url": "https://github.com/jenkinsci/jenkins/pull/4517#discussion_r385043523", "createdAt": "2020-02-27T10:37:23Z", "author": {"login": "varyvol"}, "path": "core/src/main/java/hudson/model/AbstractBuild.java", "diffHunk": "@@ -459,49 +459,90 @@ public Result run(@Nonnull BuildListener listener) throws Exception {\n             hudsonVersion = Jenkins.VERSION;\n             this.listener = listener;\n \n-            launcher = createLauncher(listener);\n-            if (!Jenkins.get().getNodes().isEmpty()) {\n-                if (node instanceof Jenkins) {\n-                    listener.getLogger().print(Messages.AbstractBuild_BuildingOnMaster());\n-                } else {\n-                    listener.getLogger().print(Messages.AbstractBuild_BuildingRemotely(ModelHyperlinkNote.encodeTo(\"/computer/\" + builtOn, node.getDisplayName())));\n-                    Set<LabelAtom> assignedLabels = new HashSet<>(node.getAssignedLabels());\n-                    assignedLabels.remove(node.getSelfLabel());\n-                    if (!assignedLabels.isEmpty()) {\n-                        boolean first = true;\n-                        for (LabelAtom label : assignedLabels) {\n-                            if (first) {\n-                                listener.getLogger().print(\" (\");\n-                                first = false;\n-                            } else {\n-                                listener.getLogger().print(' ');\n+            Result result;\n+            buildEnvironments = new ArrayList<>();\n+            // JENKINS-43889: try/finally to make sure Environments are eventually torn down. This used to be done in\n+            // the doRun() implementation, but was not happening in case of early error (for instance in SCM checkout).\n+            // Because some plugin (Maven) implement their own doRun() logic which still includes tearing down in some\n+            // cases, we use a dummy Environment as a marker, to avoid doing it here if redundant.\n+            TearDownCheckEnvironment tearDownMarker = new TearDownCheckEnvironment();\n+            buildEnvironments.add(tearDownMarker);\n+            try {\n+                launcher = createLauncher(listener);\n+                if (!Jenkins.get().getNodes().isEmpty()) {\n+                    if (node instanceof Jenkins) {\n+                        listener.getLogger().print(Messages.AbstractBuild_BuildingOnMaster());\n+                    } else {\n+                        listener.getLogger().print(Messages.AbstractBuild_BuildingRemotely(ModelHyperlinkNote.encodeTo(\"/computer/\" + builtOn, node.getDisplayName())));\n+                        Set<LabelAtom> assignedLabels = new HashSet<>(node.getAssignedLabels());\n+                        assignedLabels.remove(node.getSelfLabel());\n+                        if (!assignedLabels.isEmpty()) {\n+                            boolean first = true;\n+                            for (LabelAtom label : assignedLabels) {\n+                                if (first) {\n+                                    listener.getLogger().print(\" (\");\n+                                    first = false;\n+                                } else {\n+                                    listener.getLogger().print(' ');\n+                                }\n+                                listener.getLogger().print(label.getName());\n                             }\n-                            listener.getLogger().print(label.getName());\n+                            listener.getLogger().print(')');\n                         }\n-                        listener.getLogger().print(')');\n                     }\n+                } else {\n+                    listener.getLogger().print(Messages.AbstractBuild_Building());\n                 }\n-            } else {\n-                listener.getLogger().print(Messages.AbstractBuild_Building());\n-            }\n-            \n-            lease = decideWorkspace(node, Computer.currentComputer().getWorkspaceList());\n+                \n+                lease = decideWorkspace(node, Computer.currentComputer().getWorkspaceList());\n \n-            workspace = lease.path.getRemote();\n-            listener.getLogger().println(Messages.AbstractBuild_BuildingInWorkspace(workspace));\n-            node.getFileSystemProvisioner().prepareWorkspace(AbstractBuild.this,lease.path,listener);\n+                workspace = lease.path.getRemote();\n+                listener.getLogger().println(Messages.AbstractBuild_BuildingInWorkspace(workspace));\n+                node.getFileSystemProvisioner().prepareWorkspace(AbstractBuild.this,lease.path,listener);\n \n-            for (WorkspaceListener wl : WorkspaceListener.all()) {\n-                wl.beforeUse(AbstractBuild.this, lease.path, listener);\n-            }\n+                for (WorkspaceListener wl : WorkspaceListener.all()) {\n+                    wl.beforeUse(AbstractBuild.this, lease.path, listener);\n+                }\n \n-            getProject().getScmCheckoutStrategy().preCheckout(AbstractBuild.this, launcher, this.listener);\n-            getProject().getScmCheckoutStrategy().checkout(this);\n+                getProject().getScmCheckoutStrategy().preCheckout(AbstractBuild.this, launcher, this.listener);\n+                getProject().getScmCheckoutStrategy().checkout(this);\n \n-            if (!preBuild(listener,project.getProperties()))\n-                return Result.FAILURE;\n+                if (!preBuild(listener,project.getProperties()))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15193af21d387218ed248182b2ef3e398ad0a593"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA0NDMwNA==", "bodyText": "for (Environment  environment : buildEnvironments) {", "url": "https://github.com/jenkinsci/jenkins/pull/4517#discussion_r385044304", "createdAt": "2020-02-27T10:38:49Z", "author": {"login": "varyvol"}, "path": "core/src/main/java/hudson/model/AbstractBuild.java", "diffHunk": "@@ -459,49 +459,90 @@ public Result run(@Nonnull BuildListener listener) throws Exception {\n             hudsonVersion = Jenkins.VERSION;\n             this.listener = listener;\n \n-            launcher = createLauncher(listener);\n-            if (!Jenkins.get().getNodes().isEmpty()) {\n-                if (node instanceof Jenkins) {\n-                    listener.getLogger().print(Messages.AbstractBuild_BuildingOnMaster());\n-                } else {\n-                    listener.getLogger().print(Messages.AbstractBuild_BuildingRemotely(ModelHyperlinkNote.encodeTo(\"/computer/\" + builtOn, node.getDisplayName())));\n-                    Set<LabelAtom> assignedLabels = new HashSet<>(node.getAssignedLabels());\n-                    assignedLabels.remove(node.getSelfLabel());\n-                    if (!assignedLabels.isEmpty()) {\n-                        boolean first = true;\n-                        for (LabelAtom label : assignedLabels) {\n-                            if (first) {\n-                                listener.getLogger().print(\" (\");\n-                                first = false;\n-                            } else {\n-                                listener.getLogger().print(' ');\n+            Result result;\n+            buildEnvironments = new ArrayList<>();\n+            // JENKINS-43889: try/finally to make sure Environments are eventually torn down. This used to be done in\n+            // the doRun() implementation, but was not happening in case of early error (for instance in SCM checkout).\n+            // Because some plugin (Maven) implement their own doRun() logic which still includes tearing down in some\n+            // cases, we use a dummy Environment as a marker, to avoid doing it here if redundant.\n+            TearDownCheckEnvironment tearDownMarker = new TearDownCheckEnvironment();\n+            buildEnvironments.add(tearDownMarker);\n+            try {\n+                launcher = createLauncher(listener);\n+                if (!Jenkins.get().getNodes().isEmpty()) {\n+                    if (node instanceof Jenkins) {\n+                        listener.getLogger().print(Messages.AbstractBuild_BuildingOnMaster());\n+                    } else {\n+                        listener.getLogger().print(Messages.AbstractBuild_BuildingRemotely(ModelHyperlinkNote.encodeTo(\"/computer/\" + builtOn, node.getDisplayName())));\n+                        Set<LabelAtom> assignedLabels = new HashSet<>(node.getAssignedLabels());\n+                        assignedLabels.remove(node.getSelfLabel());\n+                        if (!assignedLabels.isEmpty()) {\n+                            boolean first = true;\n+                            for (LabelAtom label : assignedLabels) {\n+                                if (first) {\n+                                    listener.getLogger().print(\" (\");\n+                                    first = false;\n+                                } else {\n+                                    listener.getLogger().print(' ');\n+                                }\n+                                listener.getLogger().print(label.getName());\n                             }\n-                            listener.getLogger().print(label.getName());\n+                            listener.getLogger().print(')');\n                         }\n-                        listener.getLogger().print(')');\n                     }\n+                } else {\n+                    listener.getLogger().print(Messages.AbstractBuild_Building());\n                 }\n-            } else {\n-                listener.getLogger().print(Messages.AbstractBuild_Building());\n-            }\n-            \n-            lease = decideWorkspace(node, Computer.currentComputer().getWorkspaceList());\n+                \n+                lease = decideWorkspace(node, Computer.currentComputer().getWorkspaceList());\n \n-            workspace = lease.path.getRemote();\n-            listener.getLogger().println(Messages.AbstractBuild_BuildingInWorkspace(workspace));\n-            node.getFileSystemProvisioner().prepareWorkspace(AbstractBuild.this,lease.path,listener);\n+                workspace = lease.path.getRemote();\n+                listener.getLogger().println(Messages.AbstractBuild_BuildingInWorkspace(workspace));\n+                node.getFileSystemProvisioner().prepareWorkspace(AbstractBuild.this,lease.path,listener);\n \n-            for (WorkspaceListener wl : WorkspaceListener.all()) {\n-                wl.beforeUse(AbstractBuild.this, lease.path, listener);\n-            }\n+                for (WorkspaceListener wl : WorkspaceListener.all()) {\n+                    wl.beforeUse(AbstractBuild.this, lease.path, listener);\n+                }\n \n-            getProject().getScmCheckoutStrategy().preCheckout(AbstractBuild.this, launcher, this.listener);\n-            getProject().getScmCheckoutStrategy().checkout(this);\n+                getProject().getScmCheckoutStrategy().preCheckout(AbstractBuild.this, launcher, this.listener);\n+                getProject().getScmCheckoutStrategy().checkout(this);\n \n-            if (!preBuild(listener,project.getProperties()))\n-                return Result.FAILURE;\n+                if (!preBuild(listener,project.getProperties()))\n+                    return Result.FAILURE;\n \n-            Result result = doRun(listener);\n+                result = doRun(listener);\n+            } finally {\n+                if (!tearDownMarker.tornDown) {\n+                    // looks like environments are not torn down yet, do it now (in reverse order)\n+                    boolean tearDownFailed = false;\n+                    boolean tearDownInterrupted = false;\n+                    for (int i = buildEnvironments.size() - 1; i >= 0; i--) {\n+                        final Environment environment = buildEnvironments.get(i);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15193af21d387218ed248182b2ef3e398ad0a593"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA0NTI0Nw==", "bodyText": "Just a suggestion but maybe this would be nicer to read/follow if moved to an independent method, the current method is already long enough.", "url": "https://github.com/jenkinsci/jenkins/pull/4517#discussion_r385045247", "createdAt": "2020-02-27T10:40:37Z", "author": {"login": "varyvol"}, "path": "core/src/main/java/hudson/model/AbstractBuild.java", "diffHunk": "@@ -459,49 +459,90 @@ public Result run(@Nonnull BuildListener listener) throws Exception {\n             hudsonVersion = Jenkins.VERSION;\n             this.listener = listener;\n \n-            launcher = createLauncher(listener);\n-            if (!Jenkins.get().getNodes().isEmpty()) {\n-                if (node instanceof Jenkins) {\n-                    listener.getLogger().print(Messages.AbstractBuild_BuildingOnMaster());\n-                } else {\n-                    listener.getLogger().print(Messages.AbstractBuild_BuildingRemotely(ModelHyperlinkNote.encodeTo(\"/computer/\" + builtOn, node.getDisplayName())));\n-                    Set<LabelAtom> assignedLabels = new HashSet<>(node.getAssignedLabels());\n-                    assignedLabels.remove(node.getSelfLabel());\n-                    if (!assignedLabels.isEmpty()) {\n-                        boolean first = true;\n-                        for (LabelAtom label : assignedLabels) {\n-                            if (first) {\n-                                listener.getLogger().print(\" (\");\n-                                first = false;\n-                            } else {\n-                                listener.getLogger().print(' ');\n+            Result result;\n+            buildEnvironments = new ArrayList<>();\n+            // JENKINS-43889: try/finally to make sure Environments are eventually torn down. This used to be done in\n+            // the doRun() implementation, but was not happening in case of early error (for instance in SCM checkout).\n+            // Because some plugin (Maven) implement their own doRun() logic which still includes tearing down in some\n+            // cases, we use a dummy Environment as a marker, to avoid doing it here if redundant.\n+            TearDownCheckEnvironment tearDownMarker = new TearDownCheckEnvironment();\n+            buildEnvironments.add(tearDownMarker);\n+            try {\n+                launcher = createLauncher(listener);\n+                if (!Jenkins.get().getNodes().isEmpty()) {\n+                    if (node instanceof Jenkins) {\n+                        listener.getLogger().print(Messages.AbstractBuild_BuildingOnMaster());\n+                    } else {\n+                        listener.getLogger().print(Messages.AbstractBuild_BuildingRemotely(ModelHyperlinkNote.encodeTo(\"/computer/\" + builtOn, node.getDisplayName())));\n+                        Set<LabelAtom> assignedLabels = new HashSet<>(node.getAssignedLabels());\n+                        assignedLabels.remove(node.getSelfLabel());\n+                        if (!assignedLabels.isEmpty()) {\n+                            boolean first = true;\n+                            for (LabelAtom label : assignedLabels) {\n+                                if (first) {\n+                                    listener.getLogger().print(\" (\");\n+                                    first = false;\n+                                } else {\n+                                    listener.getLogger().print(' ');\n+                                }\n+                                listener.getLogger().print(label.getName());\n                             }\n-                            listener.getLogger().print(label.getName());\n+                            listener.getLogger().print(')');\n                         }\n-                        listener.getLogger().print(')');\n                     }\n+                } else {\n+                    listener.getLogger().print(Messages.AbstractBuild_Building());\n                 }\n-            } else {\n-                listener.getLogger().print(Messages.AbstractBuild_Building());\n-            }\n-            \n-            lease = decideWorkspace(node, Computer.currentComputer().getWorkspaceList());\n+                \n+                lease = decideWorkspace(node, Computer.currentComputer().getWorkspaceList());\n \n-            workspace = lease.path.getRemote();\n-            listener.getLogger().println(Messages.AbstractBuild_BuildingInWorkspace(workspace));\n-            node.getFileSystemProvisioner().prepareWorkspace(AbstractBuild.this,lease.path,listener);\n+                workspace = lease.path.getRemote();\n+                listener.getLogger().println(Messages.AbstractBuild_BuildingInWorkspace(workspace));\n+                node.getFileSystemProvisioner().prepareWorkspace(AbstractBuild.this,lease.path,listener);\n \n-            for (WorkspaceListener wl : WorkspaceListener.all()) {\n-                wl.beforeUse(AbstractBuild.this, lease.path, listener);\n-            }\n+                for (WorkspaceListener wl : WorkspaceListener.all()) {\n+                    wl.beforeUse(AbstractBuild.this, lease.path, listener);\n+                }\n \n-            getProject().getScmCheckoutStrategy().preCheckout(AbstractBuild.this, launcher, this.listener);\n-            getProject().getScmCheckoutStrategy().checkout(this);\n+                getProject().getScmCheckoutStrategy().preCheckout(AbstractBuild.this, launcher, this.listener);\n+                getProject().getScmCheckoutStrategy().checkout(this);\n \n-            if (!preBuild(listener,project.getProperties()))\n-                return Result.FAILURE;\n+                if (!preBuild(listener,project.getProperties()))\n+                    return Result.FAILURE;\n \n-            Result result = doRun(listener);\n+                result = doRun(listener);\n+            } finally {\n+                if (!tearDownMarker.tornDown) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15193af21d387218ed248182b2ef3e398ad0a593"}, "originalPosition": 91}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "050f1661dbd4d740b4bf6fb68f511cce6e841c03", "author": {"user": {"login": "thomasgl-orange", "name": "Thomas de Grenier de Latour"}}, "url": "https://github.com/jenkinsci/jenkins/commit/050f1661dbd4d740b4bf6fb68f511cce6e841c03", "committedDate": "2020-02-27T11:36:58Z", "message": "move environments tearing down to its own method"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1NTgyMzEx", "url": "https://github.com/jenkinsci/jenkins/pull/4517#pullrequestreview-365582311", "createdAt": "2020-02-27T10:48:07Z", "commit": {"oid": "15193af21d387218ed248182b2ef3e398ad0a593"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxMDo0ODowOFrOFvNjYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxMToyNzo1MlrOFvOt6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA0OTQ0Mg==", "bodyText": "For reviewers: This is the same as before", "url": "https://github.com/jenkinsci/jenkins/pull/4517#discussion_r385049442", "createdAt": "2020-02-27T10:48:08Z", "author": {"login": "MRamonLeon"}, "path": "core/src/main/java/hudson/model/AbstractBuild.java", "diffHunk": "@@ -459,49 +459,90 @@ public Result run(@Nonnull BuildListener listener) throws Exception {\n             hudsonVersion = Jenkins.VERSION;\n             this.listener = listener;\n \n-            launcher = createLauncher(listener);\n-            if (!Jenkins.get().getNodes().isEmpty()) {\n-                if (node instanceof Jenkins) {\n-                    listener.getLogger().print(Messages.AbstractBuild_BuildingOnMaster());\n-                } else {\n-                    listener.getLogger().print(Messages.AbstractBuild_BuildingRemotely(ModelHyperlinkNote.encodeTo(\"/computer/\" + builtOn, node.getDisplayName())));\n-                    Set<LabelAtom> assignedLabels = new HashSet<>(node.getAssignedLabels());\n-                    assignedLabels.remove(node.getSelfLabel());\n-                    if (!assignedLabels.isEmpty()) {\n-                        boolean first = true;\n-                        for (LabelAtom label : assignedLabels) {\n-                            if (first) {\n-                                listener.getLogger().print(\" (\");\n-                                first = false;\n-                            } else {\n-                                listener.getLogger().print(' ');\n+            Result result;\n+            buildEnvironments = new ArrayList<>();\n+            // JENKINS-43889: try/finally to make sure Environments are eventually torn down. This used to be done in\n+            // the doRun() implementation, but was not happening in case of early error (for instance in SCM checkout).\n+            // Because some plugin (Maven) implement their own doRun() logic which still includes tearing down in some\n+            // cases, we use a dummy Environment as a marker, to avoid doing it here if redundant.\n+            TearDownCheckEnvironment tearDownMarker = new TearDownCheckEnvironment();\n+            buildEnvironments.add(tearDownMarker);\n+            try {\n+                launcher = createLauncher(listener);\n+                if (!Jenkins.get().getNodes().isEmpty()) {\n+                    if (node instanceof Jenkins) {\n+                        listener.getLogger().print(Messages.AbstractBuild_BuildingOnMaster());\n+                    } else {\n+                        listener.getLogger().print(Messages.AbstractBuild_BuildingRemotely(ModelHyperlinkNote.encodeTo(\"/computer/\" + builtOn, node.getDisplayName())));\n+                        Set<LabelAtom> assignedLabels = new HashSet<>(node.getAssignedLabels());\n+                        assignedLabels.remove(node.getSelfLabel());\n+                        if (!assignedLabels.isEmpty()) {\n+                            boolean first = true;\n+                            for (LabelAtom label : assignedLabels) {\n+                                if (first) {\n+                                    listener.getLogger().print(\" (\");\n+                                    first = false;\n+                                } else {\n+                                    listener.getLogger().print(' ');\n+                                }\n+                                listener.getLogger().print(label.getName());\n                             }\n-                            listener.getLogger().print(label.getName());\n+                            listener.getLogger().print(')');\n                         }\n-                        listener.getLogger().print(')');\n                     }\n+                } else {\n+                    listener.getLogger().print(Messages.AbstractBuild_Building());\n                 }\n-            } else {\n-                listener.getLogger().print(Messages.AbstractBuild_Building());\n-            }\n-            \n-            lease = decideWorkspace(node, Computer.currentComputer().getWorkspaceList());\n+                \n+                lease = decideWorkspace(node, Computer.currentComputer().getWorkspaceList());\n \n-            workspace = lease.path.getRemote();\n-            listener.getLogger().println(Messages.AbstractBuild_BuildingInWorkspace(workspace));\n-            node.getFileSystemProvisioner().prepareWorkspace(AbstractBuild.this,lease.path,listener);\n+                workspace = lease.path.getRemote();\n+                listener.getLogger().println(Messages.AbstractBuild_BuildingInWorkspace(workspace));\n+                node.getFileSystemProvisioner().prepareWorkspace(AbstractBuild.this,lease.path,listener);\n \n-            for (WorkspaceListener wl : WorkspaceListener.all()) {\n-                wl.beforeUse(AbstractBuild.this, lease.path, listener);\n-            }\n+                for (WorkspaceListener wl : WorkspaceListener.all()) {\n+                    wl.beforeUse(AbstractBuild.this, lease.path, listener);\n+                }\n \n-            getProject().getScmCheckoutStrategy().preCheckout(AbstractBuild.this, launcher, this.listener);\n-            getProject().getScmCheckoutStrategy().checkout(this);\n+                getProject().getScmCheckoutStrategy().preCheckout(AbstractBuild.this, launcher, this.listener);\n+                getProject().getScmCheckoutStrategy().checkout(this);\n \n-            if (!preBuild(listener,project.getProperties()))\n-                return Result.FAILURE;\n+                if (!preBuild(listener,project.getProperties()))\n+                    return Result.FAILURE;\n \n-            Result result = doRun(listener);\n+                result = doRun(listener);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15193af21d387218ed248182b2ef3e398ad0a593"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA1MDE0Mg==", "bodyText": "From this line, all lines are the same", "url": "https://github.com/jenkinsci/jenkins/pull/4517#discussion_r385050142", "createdAt": "2020-02-27T10:49:27Z", "author": {"login": "MRamonLeon"}, "path": "core/src/main/java/hudson/model/AbstractBuild.java", "diffHunk": "@@ -459,49 +459,90 @@ public Result run(@Nonnull BuildListener listener) throws Exception {\n             hudsonVersion = Jenkins.VERSION;\n             this.listener = listener;\n \n-            launcher = createLauncher(listener);\n-            if (!Jenkins.get().getNodes().isEmpty()) {\n-                if (node instanceof Jenkins) {\n-                    listener.getLogger().print(Messages.AbstractBuild_BuildingOnMaster());\n-                } else {\n-                    listener.getLogger().print(Messages.AbstractBuild_BuildingRemotely(ModelHyperlinkNote.encodeTo(\"/computer/\" + builtOn, node.getDisplayName())));\n-                    Set<LabelAtom> assignedLabels = new HashSet<>(node.getAssignedLabels());\n-                    assignedLabels.remove(node.getSelfLabel());\n-                    if (!assignedLabels.isEmpty()) {\n-                        boolean first = true;\n-                        for (LabelAtom label : assignedLabels) {\n-                            if (first) {\n-                                listener.getLogger().print(\" (\");\n-                                first = false;\n-                            } else {\n-                                listener.getLogger().print(' ');\n+            Result result;\n+            buildEnvironments = new ArrayList<>();\n+            // JENKINS-43889: try/finally to make sure Environments are eventually torn down. This used to be done in\n+            // the doRun() implementation, but was not happening in case of early error (for instance in SCM checkout).\n+            // Because some plugin (Maven) implement their own doRun() logic which still includes tearing down in some\n+            // cases, we use a dummy Environment as a marker, to avoid doing it here if redundant.\n+            TearDownCheckEnvironment tearDownMarker = new TearDownCheckEnvironment();\n+            buildEnvironments.add(tearDownMarker);\n+            try {\n+                launcher = createLauncher(listener);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15193af21d387218ed248182b2ef3e398ad0a593"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA1MzUwMQ==", "bodyText": "Does it make more sense to use here UNSTABLE? From its definition:\n    /**\n     * The build had some errors but they were not fatal.\n     * For example, some tests failed.\n     */\n    public static final @Nonnull Result UNSTABLE = new Result(\"UNSTABLE\",BallColor.YELLOW,1,true);\n\nAnd if it was interrupted, what about ABORTED?\n    /**\n     * The build was manually aborted.\n     *\n     * If you are catching {@link InterruptedException} and interpreting it as {@link #ABORTED},\n     * you should check {@link Executor#abortResult()} instead (starting 1.417.)\n     */\n    public static final @Nonnull Result ABORTED = new Result(\"ABORTED\",BallColor.ABORTED,4,false);", "url": "https://github.com/jenkinsci/jenkins/pull/4517#discussion_r385053501", "createdAt": "2020-02-27T10:55:40Z", "author": {"login": "MRamonLeon"}, "path": "core/src/main/java/hudson/model/AbstractBuild.java", "diffHunk": "@@ -459,49 +459,90 @@ public Result run(@Nonnull BuildListener listener) throws Exception {\n             hudsonVersion = Jenkins.VERSION;\n             this.listener = listener;\n \n-            launcher = createLauncher(listener);\n-            if (!Jenkins.get().getNodes().isEmpty()) {\n-                if (node instanceof Jenkins) {\n-                    listener.getLogger().print(Messages.AbstractBuild_BuildingOnMaster());\n-                } else {\n-                    listener.getLogger().print(Messages.AbstractBuild_BuildingRemotely(ModelHyperlinkNote.encodeTo(\"/computer/\" + builtOn, node.getDisplayName())));\n-                    Set<LabelAtom> assignedLabels = new HashSet<>(node.getAssignedLabels());\n-                    assignedLabels.remove(node.getSelfLabel());\n-                    if (!assignedLabels.isEmpty()) {\n-                        boolean first = true;\n-                        for (LabelAtom label : assignedLabels) {\n-                            if (first) {\n-                                listener.getLogger().print(\" (\");\n-                                first = false;\n-                            } else {\n-                                listener.getLogger().print(' ');\n+            Result result;\n+            buildEnvironments = new ArrayList<>();\n+            // JENKINS-43889: try/finally to make sure Environments are eventually torn down. This used to be done in\n+            // the doRun() implementation, but was not happening in case of early error (for instance in SCM checkout).\n+            // Because some plugin (Maven) implement their own doRun() logic which still includes tearing down in some\n+            // cases, we use a dummy Environment as a marker, to avoid doing it here if redundant.\n+            TearDownCheckEnvironment tearDownMarker = new TearDownCheckEnvironment();\n+            buildEnvironments.add(tearDownMarker);\n+            try {\n+                launcher = createLauncher(listener);\n+                if (!Jenkins.get().getNodes().isEmpty()) {\n+                    if (node instanceof Jenkins) {\n+                        listener.getLogger().print(Messages.AbstractBuild_BuildingOnMaster());\n+                    } else {\n+                        listener.getLogger().print(Messages.AbstractBuild_BuildingRemotely(ModelHyperlinkNote.encodeTo(\"/computer/\" + builtOn, node.getDisplayName())));\n+                        Set<LabelAtom> assignedLabels = new HashSet<>(node.getAssignedLabels());\n+                        assignedLabels.remove(node.getSelfLabel());\n+                        if (!assignedLabels.isEmpty()) {\n+                            boolean first = true;\n+                            for (LabelAtom label : assignedLabels) {\n+                                if (first) {\n+                                    listener.getLogger().print(\" (\");\n+                                    first = false;\n+                                } else {\n+                                    listener.getLogger().print(' ');\n+                                }\n+                                listener.getLogger().print(label.getName());\n                             }\n-                            listener.getLogger().print(label.getName());\n+                            listener.getLogger().print(')');\n                         }\n-                        listener.getLogger().print(')');\n                     }\n+                } else {\n+                    listener.getLogger().print(Messages.AbstractBuild_Building());\n                 }\n-            } else {\n-                listener.getLogger().print(Messages.AbstractBuild_Building());\n-            }\n-            \n-            lease = decideWorkspace(node, Computer.currentComputer().getWorkspaceList());\n+                \n+                lease = decideWorkspace(node, Computer.currentComputer().getWorkspaceList());\n \n-            workspace = lease.path.getRemote();\n-            listener.getLogger().println(Messages.AbstractBuild_BuildingInWorkspace(workspace));\n-            node.getFileSystemProvisioner().prepareWorkspace(AbstractBuild.this,lease.path,listener);\n+                workspace = lease.path.getRemote();\n+                listener.getLogger().println(Messages.AbstractBuild_BuildingInWorkspace(workspace));\n+                node.getFileSystemProvisioner().prepareWorkspace(AbstractBuild.this,lease.path,listener);\n \n-            for (WorkspaceListener wl : WorkspaceListener.all()) {\n-                wl.beforeUse(AbstractBuild.this, lease.path, listener);\n-            }\n+                for (WorkspaceListener wl : WorkspaceListener.all()) {\n+                    wl.beforeUse(AbstractBuild.this, lease.path, listener);\n+                }\n \n-            getProject().getScmCheckoutStrategy().preCheckout(AbstractBuild.this, launcher, this.listener);\n-            getProject().getScmCheckoutStrategy().checkout(this);\n+                getProject().getScmCheckoutStrategy().preCheckout(AbstractBuild.this, launcher, this.listener);\n+                getProject().getScmCheckoutStrategy().checkout(this);\n \n-            if (!preBuild(listener,project.getProperties()))\n-                return Result.FAILURE;\n+                if (!preBuild(listener,project.getProperties()))\n+                    return Result.FAILURE;\n \n-            Result result = doRun(listener);\n+                result = doRun(listener);\n+            } finally {\n+                if (!tearDownMarker.tornDown) {\n+                    // looks like environments are not torn down yet, do it now (in reverse order)\n+                    boolean tearDownFailed = false;\n+                    boolean tearDownInterrupted = false;\n+                    for (int i = buildEnvironments.size() - 1; i >= 0; i--) {\n+                        final Environment environment = buildEnvironments.get(i);\n+                        try {\n+                            if (!environment.tearDown(AbstractBuild.this, listener)) {\n+                                tearDownFailed = true;\n+                            }\n+                        } catch (IOException | InterruptedException | RuntimeException e) {\n+                            tearDownFailed = true;\n+                            // exceptions are ignored to give a chance to all environments to tear down\n+                            listener.error(\"Unable to tear down: \" + e.getMessage());\n+                            Functions.printStackTrace(e, listener.getLogger());\n+                            if (e instanceof InterruptedException) {\n+                                // don't forget we've been interrupted\n+                                tearDownInterrupted = true;\n+                            }\n+                        }\n+                    }\n+                    // report any error while tearing down an Environment as a build failure\n+                    if (tearDownFailed) {\n+                        result = Result.FAILURE;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15193af21d387218ed248182b2ef3e398ad0a593"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA2NjYwMA==", "bodyText": "I think he didn't do so to do it in reverse order", "url": "https://github.com/jenkinsci/jenkins/pull/4517#discussion_r385066600", "createdAt": "2020-02-27T11:23:28Z", "author": {"login": "MRamonLeon"}, "path": "core/src/main/java/hudson/model/AbstractBuild.java", "diffHunk": "@@ -459,49 +459,90 @@ public Result run(@Nonnull BuildListener listener) throws Exception {\n             hudsonVersion = Jenkins.VERSION;\n             this.listener = listener;\n \n-            launcher = createLauncher(listener);\n-            if (!Jenkins.get().getNodes().isEmpty()) {\n-                if (node instanceof Jenkins) {\n-                    listener.getLogger().print(Messages.AbstractBuild_BuildingOnMaster());\n-                } else {\n-                    listener.getLogger().print(Messages.AbstractBuild_BuildingRemotely(ModelHyperlinkNote.encodeTo(\"/computer/\" + builtOn, node.getDisplayName())));\n-                    Set<LabelAtom> assignedLabels = new HashSet<>(node.getAssignedLabels());\n-                    assignedLabels.remove(node.getSelfLabel());\n-                    if (!assignedLabels.isEmpty()) {\n-                        boolean first = true;\n-                        for (LabelAtom label : assignedLabels) {\n-                            if (first) {\n-                                listener.getLogger().print(\" (\");\n-                                first = false;\n-                            } else {\n-                                listener.getLogger().print(' ');\n+            Result result;\n+            buildEnvironments = new ArrayList<>();\n+            // JENKINS-43889: try/finally to make sure Environments are eventually torn down. This used to be done in\n+            // the doRun() implementation, but was not happening in case of early error (for instance in SCM checkout).\n+            // Because some plugin (Maven) implement their own doRun() logic which still includes tearing down in some\n+            // cases, we use a dummy Environment as a marker, to avoid doing it here if redundant.\n+            TearDownCheckEnvironment tearDownMarker = new TearDownCheckEnvironment();\n+            buildEnvironments.add(tearDownMarker);\n+            try {\n+                launcher = createLauncher(listener);\n+                if (!Jenkins.get().getNodes().isEmpty()) {\n+                    if (node instanceof Jenkins) {\n+                        listener.getLogger().print(Messages.AbstractBuild_BuildingOnMaster());\n+                    } else {\n+                        listener.getLogger().print(Messages.AbstractBuild_BuildingRemotely(ModelHyperlinkNote.encodeTo(\"/computer/\" + builtOn, node.getDisplayName())));\n+                        Set<LabelAtom> assignedLabels = new HashSet<>(node.getAssignedLabels());\n+                        assignedLabels.remove(node.getSelfLabel());\n+                        if (!assignedLabels.isEmpty()) {\n+                            boolean first = true;\n+                            for (LabelAtom label : assignedLabels) {\n+                                if (first) {\n+                                    listener.getLogger().print(\" (\");\n+                                    first = false;\n+                                } else {\n+                                    listener.getLogger().print(' ');\n+                                }\n+                                listener.getLogger().print(label.getName());\n                             }\n-                            listener.getLogger().print(label.getName());\n+                            listener.getLogger().print(')');\n                         }\n-                        listener.getLogger().print(')');\n                     }\n+                } else {\n+                    listener.getLogger().print(Messages.AbstractBuild_Building());\n                 }\n-            } else {\n-                listener.getLogger().print(Messages.AbstractBuild_Building());\n-            }\n-            \n-            lease = decideWorkspace(node, Computer.currentComputer().getWorkspaceList());\n+                \n+                lease = decideWorkspace(node, Computer.currentComputer().getWorkspaceList());\n \n-            workspace = lease.path.getRemote();\n-            listener.getLogger().println(Messages.AbstractBuild_BuildingInWorkspace(workspace));\n-            node.getFileSystemProvisioner().prepareWorkspace(AbstractBuild.this,lease.path,listener);\n+                workspace = lease.path.getRemote();\n+                listener.getLogger().println(Messages.AbstractBuild_BuildingInWorkspace(workspace));\n+                node.getFileSystemProvisioner().prepareWorkspace(AbstractBuild.this,lease.path,listener);\n \n-            for (WorkspaceListener wl : WorkspaceListener.all()) {\n-                wl.beforeUse(AbstractBuild.this, lease.path, listener);\n-            }\n+                for (WorkspaceListener wl : WorkspaceListener.all()) {\n+                    wl.beforeUse(AbstractBuild.this, lease.path, listener);\n+                }\n \n-            getProject().getScmCheckoutStrategy().preCheckout(AbstractBuild.this, launcher, this.listener);\n-            getProject().getScmCheckoutStrategy().checkout(this);\n+                getProject().getScmCheckoutStrategy().preCheckout(AbstractBuild.this, launcher, this.listener);\n+                getProject().getScmCheckoutStrategy().checkout(this);\n \n-            if (!preBuild(listener,project.getProperties()))\n-                return Result.FAILURE;\n+                if (!preBuild(listener,project.getProperties()))\n+                    return Result.FAILURE;\n \n-            Result result = doRun(listener);\n+                result = doRun(listener);\n+            } finally {\n+                if (!tearDownMarker.tornDown) {\n+                    // looks like environments are not torn down yet, do it now (in reverse order)\n+                    boolean tearDownFailed = false;\n+                    boolean tearDownInterrupted = false;\n+                    for (int i = buildEnvironments.size() - 1; i >= 0; i--) {\n+                        final Environment environment = buildEnvironments.get(i);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA0NDMwNA=="}, "originalCommit": {"oid": "15193af21d387218ed248182b2ef3e398ad0a593"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA2ODUyMg==", "bodyText": "Isn't it better to throw an interrupted exception here?", "url": "https://github.com/jenkinsci/jenkins/pull/4517#discussion_r385068522", "createdAt": "2020-02-27T11:27:52Z", "author": {"login": "MRamonLeon"}, "path": "core/src/main/java/hudson/model/AbstractBuild.java", "diffHunk": "@@ -459,49 +459,90 @@ public Result run(@Nonnull BuildListener listener) throws Exception {\n             hudsonVersion = Jenkins.VERSION;\n             this.listener = listener;\n \n-            launcher = createLauncher(listener);\n-            if (!Jenkins.get().getNodes().isEmpty()) {\n-                if (node instanceof Jenkins) {\n-                    listener.getLogger().print(Messages.AbstractBuild_BuildingOnMaster());\n-                } else {\n-                    listener.getLogger().print(Messages.AbstractBuild_BuildingRemotely(ModelHyperlinkNote.encodeTo(\"/computer/\" + builtOn, node.getDisplayName())));\n-                    Set<LabelAtom> assignedLabels = new HashSet<>(node.getAssignedLabels());\n-                    assignedLabels.remove(node.getSelfLabel());\n-                    if (!assignedLabels.isEmpty()) {\n-                        boolean first = true;\n-                        for (LabelAtom label : assignedLabels) {\n-                            if (first) {\n-                                listener.getLogger().print(\" (\");\n-                                first = false;\n-                            } else {\n-                                listener.getLogger().print(' ');\n+            Result result;\n+            buildEnvironments = new ArrayList<>();\n+            // JENKINS-43889: try/finally to make sure Environments are eventually torn down. This used to be done in\n+            // the doRun() implementation, but was not happening in case of early error (for instance in SCM checkout).\n+            // Because some plugin (Maven) implement their own doRun() logic which still includes tearing down in some\n+            // cases, we use a dummy Environment as a marker, to avoid doing it here if redundant.\n+            TearDownCheckEnvironment tearDownMarker = new TearDownCheckEnvironment();\n+            buildEnvironments.add(tearDownMarker);\n+            try {\n+                launcher = createLauncher(listener);\n+                if (!Jenkins.get().getNodes().isEmpty()) {\n+                    if (node instanceof Jenkins) {\n+                        listener.getLogger().print(Messages.AbstractBuild_BuildingOnMaster());\n+                    } else {\n+                        listener.getLogger().print(Messages.AbstractBuild_BuildingRemotely(ModelHyperlinkNote.encodeTo(\"/computer/\" + builtOn, node.getDisplayName())));\n+                        Set<LabelAtom> assignedLabels = new HashSet<>(node.getAssignedLabels());\n+                        assignedLabels.remove(node.getSelfLabel());\n+                        if (!assignedLabels.isEmpty()) {\n+                            boolean first = true;\n+                            for (LabelAtom label : assignedLabels) {\n+                                if (first) {\n+                                    listener.getLogger().print(\" (\");\n+                                    first = false;\n+                                } else {\n+                                    listener.getLogger().print(' ');\n+                                }\n+                                listener.getLogger().print(label.getName());\n                             }\n-                            listener.getLogger().print(label.getName());\n+                            listener.getLogger().print(')');\n                         }\n-                        listener.getLogger().print(')');\n                     }\n+                } else {\n+                    listener.getLogger().print(Messages.AbstractBuild_Building());\n                 }\n-            } else {\n-                listener.getLogger().print(Messages.AbstractBuild_Building());\n-            }\n-            \n-            lease = decideWorkspace(node, Computer.currentComputer().getWorkspaceList());\n+                \n+                lease = decideWorkspace(node, Computer.currentComputer().getWorkspaceList());\n \n-            workspace = lease.path.getRemote();\n-            listener.getLogger().println(Messages.AbstractBuild_BuildingInWorkspace(workspace));\n-            node.getFileSystemProvisioner().prepareWorkspace(AbstractBuild.this,lease.path,listener);\n+                workspace = lease.path.getRemote();\n+                listener.getLogger().println(Messages.AbstractBuild_BuildingInWorkspace(workspace));\n+                node.getFileSystemProvisioner().prepareWorkspace(AbstractBuild.this,lease.path,listener);\n \n-            for (WorkspaceListener wl : WorkspaceListener.all()) {\n-                wl.beforeUse(AbstractBuild.this, lease.path, listener);\n-            }\n+                for (WorkspaceListener wl : WorkspaceListener.all()) {\n+                    wl.beforeUse(AbstractBuild.this, lease.path, listener);\n+                }\n \n-            getProject().getScmCheckoutStrategy().preCheckout(AbstractBuild.this, launcher, this.listener);\n-            getProject().getScmCheckoutStrategy().checkout(this);\n+                getProject().getScmCheckoutStrategy().preCheckout(AbstractBuild.this, launcher, this.listener);\n+                getProject().getScmCheckoutStrategy().checkout(this);\n \n-            if (!preBuild(listener,project.getProperties()))\n-                return Result.FAILURE;\n+                if (!preBuild(listener,project.getProperties()))\n+                    return Result.FAILURE;\n \n-            Result result = doRun(listener);\n+                result = doRun(listener);\n+            } finally {\n+                if (!tearDownMarker.tornDown) {\n+                    // looks like environments are not torn down yet, do it now (in reverse order)\n+                    boolean tearDownFailed = false;\n+                    boolean tearDownInterrupted = false;\n+                    for (int i = buildEnvironments.size() - 1; i >= 0; i--) {\n+                        final Environment environment = buildEnvironments.get(i);\n+                        try {\n+                            if (!environment.tearDown(AbstractBuild.this, listener)) {\n+                                tearDownFailed = true;\n+                            }\n+                        } catch (IOException | InterruptedException | RuntimeException e) {\n+                            tearDownFailed = true;\n+                            // exceptions are ignored to give a chance to all environments to tear down\n+                            listener.error(\"Unable to tear down: \" + e.getMessage());\n+                            Functions.printStackTrace(e, listener.getLogger());\n+                            if (e instanceof InterruptedException) {\n+                                // don't forget we've been interrupted\n+                                tearDownInterrupted = true;\n+                            }\n+                        }\n+                    }\n+                    // report any error while tearing down an Environment as a build failure\n+                    if (tearDownFailed) {\n+                        result = Result.FAILURE;\n+                    }\n+                    if (tearDownInterrupted) {\n+                        // don't forget we've been interrupted\n+                        Thread.currentThread().interrupt();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15193af21d387218ed248182b2ef3e398ad0a593"}, "originalPosition": 118}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1NzI2MjU3", "url": "https://github.com/jenkinsci/jenkins/pull/4517#pullrequestreview-365726257", "createdAt": "2020-02-27T14:30:13Z", "commit": {"oid": "050f1661dbd4d740b4bf6fb68f511cce6e841c03"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2132275280f775520e79f8ea127bf3efcd5cefea", "author": {"user": {"login": "thomasgl-orange", "name": "Thomas de Grenier de Latour"}}, "url": "https://github.com/jenkinsci/jenkins/commit/2132275280f775520e79f8ea127bf3efcd5cefea", "committedDate": "2020-02-27T22:31:24Z", "message": "utility method to worsen a nullable Result"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "625b783b9fb81fb785be904ba9568c03f9320241", "author": {"user": {"login": "thomasgl-orange", "name": "Thomas de Grenier de Latour"}}, "url": "https://github.com/jenkinsci/jenkins/commit/625b783b9fb81fb785be904ba9568c03f9320241", "committedDate": "2020-02-27T22:31:41Z", "message": "improve exceptions handling when tearing down environments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0a44fe0ef6d40b273800f6e9fa57b73a45278204", "author": {"user": {"login": "thomasgl-orange", "name": "Thomas de Grenier de Latour"}}, "url": "https://github.com/jenkinsci/jenkins/commit/0a44fe0ef6d40b273800f6e9fa57b73a45278204", "committedDate": "2020-02-27T22:55:28Z", "message": "oops, fix compilation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ee8002f808558ec205bd4a81e773b3729234e81a", "author": {"user": {"login": "thomasgl-orange", "name": "Thomas de Grenier de Latour"}}, "url": "https://github.com/jenkinsci/jenkins/commit/ee8002f808558ec205bd4a81e773b3729234e81a", "committedDate": "2020-02-28T02:09:39Z", "message": "javadoc fix"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5NDA0ODUx", "url": "https://github.com/jenkinsci/jenkins/pull/4517#pullrequestreview-369404851", "createdAt": "2020-03-05T09:19:58Z", "commit": {"oid": "ee8002f808558ec205bd4a81e773b3729234e81a"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQwOToxOTo1OFrOFyLxFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQwOToyNDozMlrOFyL7Fg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODE2NTkxMQ==", "bodyText": "This historical implementation just asks for concurrency issues at some point. Not blocking this change, because it does not make it any worse", "url": "https://github.com/jenkinsci/jenkins/pull/4517#discussion_r388165911", "createdAt": "2020-03-05T09:19:58Z", "author": {"login": "oleg-nenashev"}, "path": "core/src/main/java/hudson/model/AbstractBuild.java", "diffHunk": "@@ -459,49 +460,64 @@ public Result run(@Nonnull BuildListener listener) throws Exception {\n             hudsonVersion = Jenkins.VERSION;\n             this.listener = listener;\n \n-            launcher = createLauncher(listener);\n-            if (!Jenkins.get().getNodes().isEmpty()) {\n-                if (node instanceof Jenkins) {\n-                    listener.getLogger().print(Messages.AbstractBuild_BuildingOnMaster());\n-                } else {\n-                    listener.getLogger().print(Messages.AbstractBuild_BuildingRemotely(ModelHyperlinkNote.encodeTo(\"/computer/\" + builtOn, node.getDisplayName())));\n-                    Set<LabelAtom> assignedLabels = new HashSet<>(node.getAssignedLabels());\n-                    assignedLabels.remove(node.getSelfLabel());\n-                    if (!assignedLabels.isEmpty()) {\n-                        boolean first = true;\n-                        for (LabelAtom label : assignedLabels) {\n-                            if (first) {\n-                                listener.getLogger().print(\" (\");\n-                                first = false;\n-                            } else {\n-                                listener.getLogger().print(' ');\n+            Result result = null;\n+            buildEnvironments = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee8002f808558ec205bd4a81e773b3729234e81a"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODE2NzA1MA==", "bodyText": "InterruptedException in tearDownBuildEnvironments() will bypass this logic and cause loss of the original build result information. I doubt this is what we want", "url": "https://github.com/jenkinsci/jenkins/pull/4517#discussion_r388167050", "createdAt": "2020-03-05T09:22:00Z", "author": {"login": "oleg-nenashev"}, "path": "core/src/main/java/hudson/model/AbstractBuild.java", "diffHunk": "@@ -459,49 +460,64 @@ public Result run(@Nonnull BuildListener listener) throws Exception {\n             hudsonVersion = Jenkins.VERSION;\n             this.listener = listener;\n \n-            launcher = createLauncher(listener);\n-            if (!Jenkins.get().getNodes().isEmpty()) {\n-                if (node instanceof Jenkins) {\n-                    listener.getLogger().print(Messages.AbstractBuild_BuildingOnMaster());\n-                } else {\n-                    listener.getLogger().print(Messages.AbstractBuild_BuildingRemotely(ModelHyperlinkNote.encodeTo(\"/computer/\" + builtOn, node.getDisplayName())));\n-                    Set<LabelAtom> assignedLabels = new HashSet<>(node.getAssignedLabels());\n-                    assignedLabels.remove(node.getSelfLabel());\n-                    if (!assignedLabels.isEmpty()) {\n-                        boolean first = true;\n-                        for (LabelAtom label : assignedLabels) {\n-                            if (first) {\n-                                listener.getLogger().print(\" (\");\n-                                first = false;\n-                            } else {\n-                                listener.getLogger().print(' ');\n+            Result result = null;\n+            buildEnvironments = new ArrayList<>();\n+            // JENKINS-43889: try/finally to make sure Environments are eventually torn down. This used to be done in\n+            // the doRun() implementation, but was not happening in case of early error (for instance in SCM checkout).\n+            // Because some plugin (Maven) implement their own doRun() logic which still includes tearing down in some\n+            // cases, we use a dummy Environment as a marker, to avoid doing it here if redundant.\n+            TearDownCheckEnvironment tearDownMarker = new TearDownCheckEnvironment();\n+            buildEnvironments.add(tearDownMarker);\n+            try {\n+                launcher = createLauncher(listener);\n+                if (!Jenkins.get().getNodes().isEmpty()) {\n+                    if (node instanceof Jenkins) {\n+                        listener.getLogger().print(Messages.AbstractBuild_BuildingOnMaster());\n+                    } else {\n+                        listener.getLogger().print(Messages.AbstractBuild_BuildingRemotely(ModelHyperlinkNote.encodeTo(\"/computer/\" + builtOn, node.getDisplayName())));\n+                        Set<LabelAtom> assignedLabels = new HashSet<>(node.getAssignedLabels());\n+                        assignedLabels.remove(node.getSelfLabel());\n+                        if (!assignedLabels.isEmpty()) {\n+                            boolean first = true;\n+                            for (LabelAtom label : assignedLabels) {\n+                                if (first) {\n+                                    listener.getLogger().print(\" (\");\n+                                    first = false;\n+                                } else {\n+                                    listener.getLogger().print(' ');\n+                                }\n+                                listener.getLogger().print(label.getName());\n                             }\n-                            listener.getLogger().print(label.getName());\n+                            listener.getLogger().print(')');\n                         }\n-                        listener.getLogger().print(')');\n                     }\n+                } else {\n+                    listener.getLogger().print(Messages.AbstractBuild_Building());\n                 }\n-            } else {\n-                listener.getLogger().print(Messages.AbstractBuild_Building());\n-            }\n-            \n-            lease = decideWorkspace(node, Computer.currentComputer().getWorkspaceList());\n+                \n+                lease = decideWorkspace(node, Computer.currentComputer().getWorkspaceList());\n \n-            workspace = lease.path.getRemote();\n-            listener.getLogger().println(Messages.AbstractBuild_BuildingInWorkspace(workspace));\n-            node.getFileSystemProvisioner().prepareWorkspace(AbstractBuild.this,lease.path,listener);\n+                workspace = lease.path.getRemote();\n+                listener.getLogger().println(Messages.AbstractBuild_BuildingInWorkspace(workspace));\n+                node.getFileSystemProvisioner().prepareWorkspace(AbstractBuild.this,lease.path,listener);\n \n-            for (WorkspaceListener wl : WorkspaceListener.all()) {\n-                wl.beforeUse(AbstractBuild.this, lease.path, listener);\n-            }\n+                for (WorkspaceListener wl : WorkspaceListener.all()) {\n+                    wl.beforeUse(AbstractBuild.this, lease.path, listener);\n+                }\n \n-            getProject().getScmCheckoutStrategy().preCheckout(AbstractBuild.this, launcher, this.listener);\n-            getProject().getScmCheckoutStrategy().checkout(this);\n+                getProject().getScmCheckoutStrategy().preCheckout(AbstractBuild.this, launcher, this.listener);\n+                getProject().getScmCheckoutStrategy().checkout(this);\n \n-            if (!preBuild(listener,project.getProperties()))\n-                return Result.FAILURE;\n+                if (!preBuild(listener,project.getProperties()))\n+                    return Result.FAILURE;\n \n-            Result result = doRun(listener);\n+                result = doRun(listener);\n+            } finally {\n+                if (!tearDownMarker.tornDown) {\n+                    // looks like environments are not torn down yet, do it now (might affect the build result)\n+                    result = Result.combine(result, tearDownBuildEnvironments(listener));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee8002f808558ec205bd4a81e773b3729234e81a"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODE2ODQ3MA==", "bodyText": "Would be better to avoid non-static nested classes when possible. Better safe than sorry", "url": "https://github.com/jenkinsci/jenkins/pull/4517#discussion_r388168470", "createdAt": "2020-03-05T09:24:32Z", "author": {"login": "oleg-nenashev"}, "path": "core/src/main/java/hudson/model/AbstractBuild.java", "diffHunk": "@@ -518,6 +559,20 @@ public Result run(@Nonnull BuildListener listener) throws Exception {\n             return result;\n         }\n \n+        /**\n+         * An {@link Environment} which does nothing, but change state when it gets torn down. Used in\n+         * {@link AbstractBuildExecution#run(BuildListener)} to detect whether environments have yet to be torn down,\n+         * or if it has been done already (in the {@link AbstractBuildExecution#doRun(BuildListener)} implementation).\n+         */\n+        private class TearDownCheckEnvironment extends Environment {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQ3ODEwOA=="}, "originalCommit": {"oid": "d7a024ec2a5d17c3814141e88edf0edc33af7af5"}, "originalPosition": 134}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "462104a49cf378ad9aa7be4069faa56f7aa052c7", "author": {"user": {"login": "thomasgl-orange", "name": "Thomas de Grenier de Latour"}}, "url": "https://github.com/jenkinsci/jenkins/commit/462104a49cf378ad9aa7be4069faa56f7aa052c7", "committedDate": "2020-03-05T11:38:47Z", "message": "move TearDownCheckEnvironment inner class to make it static"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "83c260289a1f3a848a20ffd4e5615f72341e660e", "author": {"user": {"login": "thomasgl-orange", "name": "Thomas de Grenier de Latour"}}, "url": "https://github.com/jenkinsci/jenkins/commit/83c260289a1f3a848a20ffd4e5615f72341e660e", "committedDate": "2020-03-06T22:18:04Z", "message": "simple test for InterruptedException from Environment#tearDown()"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgxOTE2MTQw", "url": "https://github.com/jenkinsci/jenkins/pull/4517#pullrequestreview-381916140", "createdAt": "2020-03-26T11:24:38Z", "commit": {"oid": "83c260289a1f3a848a20ffd4e5615f72341e660e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b0889f1d9498a23e704adbc6b717dec5591c67cc", "author": {"user": {"login": "thomasgl-orange", "name": "Thomas de Grenier de Latour"}}, "url": "https://github.com/jenkinsci/jenkins/commit/b0889f1d9498a23e704adbc6b717dec5591c67cc", "committedDate": "2020-04-17T07:26:34Z", "message": "Merge tag 'jenkins-2.232' into JENKINS-43889\n\n[maven-release-plugin] copy for tag jenkins-2.232"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3b2195e0945fe3b5f6cba80fc8327177e0281480", "author": {"user": {"login": "thomasgl-orange", "name": "Thomas de Grenier de Latour"}}, "url": "https://github.com/jenkinsci/jenkins/commit/3b2195e0945fe3b5f6cba80fc8327177e0281480", "committedDate": "2020-04-17T07:17:38Z", "message": "Merge tag 'jenkins-2.232' into JENKINS-43889\n\n[maven-release-plugin] copy for tag jenkins-2.232"}, "afterCommit": {"oid": "b0889f1d9498a23e704adbc6b717dec5591c67cc", "author": {"user": {"login": "thomasgl-orange", "name": "Thomas de Grenier de Latour"}}, "url": "https://github.com/jenkinsci/jenkins/commit/b0889f1d9498a23e704adbc6b717dec5591c67cc", "committedDate": "2020-04-17T07:26:34Z", "message": "Merge tag 'jenkins-2.232' into JENKINS-43889\n\n[maven-release-plugin] copy for tag jenkins-2.232"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1603, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}