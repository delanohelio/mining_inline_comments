{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI2NzY2MzU3", "number": 10301, "reviewThreads": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxNjoyMjo0MVrOFFEVfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxODoxMjo0MlrOFFvAMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwODU4MjM4OnYy", "diffSide": "RIGHT", "path": "frontend/src/actions/InlineTabActions.js", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxNjoyMjo0MVrOIFYoMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwNzo1MjoyNVrOIHoxwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjUxNzI5OA==", "bodyText": "Why not just use a single splice tabData.splice(lastAdditionIndex, 1, tempData); ? Or even better - create a new array instead of mutating the response object ?", "url": "https://github.com/metasfresh/metasfresh/pull/10301#discussion_r542517298", "createdAt": "2020-12-14T16:22:41Z", "author": {"login": "siemiatj"}, "path": "frontend/src/actions/InlineTabActions.js", "diffHunk": "@@ -0,0 +1,223 @@\n+import { fetchTab } from './WindowActions';\n+import { getLayout, getData } from '../api';\n+import { INLINE_TAB_SHOW_MORE_FROM } from '../constants/Constants';\n+import {\n+  UPDATE_INLINE_TAB_ITEM_FIELDS,\n+  UPDATE_INLINE_TAB_WRAPPER_FIELDS,\n+  SET_INLINE_TAB_WRAPPER_DATA,\n+  SET_INLINE_TAB_LAYOUT_AND_DATA,\n+  SET_INLINE_TAB_ADD_NEW,\n+  SET_INLINE_TAB_SHOW_MORE,\n+} from '../constants/ActionTypes';\n+\n+/*\n+ * @method updateInlineTabItemFields\n+ * @summary Action creator for updating the fields for the `InlineTab` Item\n+ *\n+ * @param {string} inlineTabId\n+ * @param {string} rowId\n+ * @param {object} fieldsByName\n+ */\n+export function updateInlineTabItemFields({ inlineTabId, fieldsByName }) {\n+  return {\n+    type: UPDATE_INLINE_TAB_ITEM_FIELDS,\n+    payload: { inlineTabId, fieldsByName },\n+  };\n+}\n+\n+/*\n+ * @method updateInlineTabWrapperFields\n+ * @summary Action creator for updating the fields for the `InlineTab` Wrapper\n+ *\n+ * @param {string} inlineTabWrapperId\n+ * @param {string} rowId\n+ * @param {object} fieldsByName\n+ */\n+export function updateInlineTabWrapperFields({\n+  inlineTabWrapperId,\n+  rowId,\n+  response,\n+}) {\n+  return {\n+    type: UPDATE_INLINE_TAB_WRAPPER_FIELDS,\n+    payload: { inlineTabWrapperId, rowId, response },\n+  };\n+}\n+\n+/*\n+ * Action creator called to set the inlineTabWrapper branch in the redux store with the data payload\n+ */\n+export function setInlineTabWrapperData({ inlineTabWrapperId, data }) {\n+  return {\n+    type: SET_INLINE_TAB_WRAPPER_DATA,\n+    payload: { inlineTabWrapperId, data },\n+  };\n+}\n+\n+/*\n+ * Action creator called to set the showMore value for the corresponding inlineTabWrapperId\n+ */\n+export function setInlineTabShowMore({ inlineTabWrapperId, showMore }) {\n+  return {\n+    type: SET_INLINE_TAB_SHOW_MORE,\n+    payload: { inlineTabWrapperId, showMore },\n+  };\n+}\n+\n+/*\n+ * Action creator called to set the inlineTab branch in the redux store with the data payload\n+ */\n+export function setInlineTabLayoutAndData({ inlineTabId, data }) {\n+  return {\n+    type: SET_INLINE_TAB_LAYOUT_AND_DATA,\n+    payload: { inlineTabId, data },\n+  };\n+}\n+\n+/*\n+ * Action creator called to set the inlineTab AddNew form related data in the store, visible is for toggling the visibility\n+ */\n+export function setInlineTabAddNew({ visible, windowId, tabId, rowId, docId }) {\n+  return {\n+    type: SET_INLINE_TAB_ADD_NEW,\n+    payload: { visible, windowId, tabId, rowId, docId },\n+  };\n+}\n+\n+/*\n+ * @method fetchInlineTabWrapperData\n+ * @summary Action creator for fetching the data for the `InlineTab` Wrapper (note: wrapper not the inline tab item!)\n+ *\n+ * @param {string} windowId\n+ * @param {string} tabId\n+ * @param {string} docId\n+ * @param {string} query\n+ */\n+export function fetchInlineTabWrapperData({\n+  windowId,\n+  tabId,\n+  docId,\n+  query,\n+  rowId,\n+  postDeletion,\n+}) {\n+  return (dispatch) => {\n+    dispatch(fetchTab({ tabId, windowId, docId, query })).then((tabData) => {\n+      /** - if we have the rowId it means we have a new record addition, so we put that at the end of the array - only if this doesn't happen as a result of deletion */\n+      if (rowId && !postDeletion) {\n+        const lastAdditionIndex = tabData.findIndex(\n+          (item) => item.rowId === rowId\n+        );\n+        if (lastAdditionIndex) {\n+          const tempData = tabData[lastAdditionIndex];\n+          tabData.splice(lastAdditionIndex, 1);\n+          tabData.splice(tabData.length, 0, tempData);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f63af1096f726bd57a4b913066b8932edd49d7a"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg3OTA0MA==", "bodyText": "That would not work as we need to always have it last after the addition.", "url": "https://github.com/metasfresh/metasfresh/pull/10301#discussion_r544879040", "createdAt": "2020-12-17T07:52:25Z", "author": {"login": "petrican"}, "path": "frontend/src/actions/InlineTabActions.js", "diffHunk": "@@ -0,0 +1,223 @@\n+import { fetchTab } from './WindowActions';\n+import { getLayout, getData } from '../api';\n+import { INLINE_TAB_SHOW_MORE_FROM } from '../constants/Constants';\n+import {\n+  UPDATE_INLINE_TAB_ITEM_FIELDS,\n+  UPDATE_INLINE_TAB_WRAPPER_FIELDS,\n+  SET_INLINE_TAB_WRAPPER_DATA,\n+  SET_INLINE_TAB_LAYOUT_AND_DATA,\n+  SET_INLINE_TAB_ADD_NEW,\n+  SET_INLINE_TAB_SHOW_MORE,\n+} from '../constants/ActionTypes';\n+\n+/*\n+ * @method updateInlineTabItemFields\n+ * @summary Action creator for updating the fields for the `InlineTab` Item\n+ *\n+ * @param {string} inlineTabId\n+ * @param {string} rowId\n+ * @param {object} fieldsByName\n+ */\n+export function updateInlineTabItemFields({ inlineTabId, fieldsByName }) {\n+  return {\n+    type: UPDATE_INLINE_TAB_ITEM_FIELDS,\n+    payload: { inlineTabId, fieldsByName },\n+  };\n+}\n+\n+/*\n+ * @method updateInlineTabWrapperFields\n+ * @summary Action creator for updating the fields for the `InlineTab` Wrapper\n+ *\n+ * @param {string} inlineTabWrapperId\n+ * @param {string} rowId\n+ * @param {object} fieldsByName\n+ */\n+export function updateInlineTabWrapperFields({\n+  inlineTabWrapperId,\n+  rowId,\n+  response,\n+}) {\n+  return {\n+    type: UPDATE_INLINE_TAB_WRAPPER_FIELDS,\n+    payload: { inlineTabWrapperId, rowId, response },\n+  };\n+}\n+\n+/*\n+ * Action creator called to set the inlineTabWrapper branch in the redux store with the data payload\n+ */\n+export function setInlineTabWrapperData({ inlineTabWrapperId, data }) {\n+  return {\n+    type: SET_INLINE_TAB_WRAPPER_DATA,\n+    payload: { inlineTabWrapperId, data },\n+  };\n+}\n+\n+/*\n+ * Action creator called to set the showMore value for the corresponding inlineTabWrapperId\n+ */\n+export function setInlineTabShowMore({ inlineTabWrapperId, showMore }) {\n+  return {\n+    type: SET_INLINE_TAB_SHOW_MORE,\n+    payload: { inlineTabWrapperId, showMore },\n+  };\n+}\n+\n+/*\n+ * Action creator called to set the inlineTab branch in the redux store with the data payload\n+ */\n+export function setInlineTabLayoutAndData({ inlineTabId, data }) {\n+  return {\n+    type: SET_INLINE_TAB_LAYOUT_AND_DATA,\n+    payload: { inlineTabId, data },\n+  };\n+}\n+\n+/*\n+ * Action creator called to set the inlineTab AddNew form related data in the store, visible is for toggling the visibility\n+ */\n+export function setInlineTabAddNew({ visible, windowId, tabId, rowId, docId }) {\n+  return {\n+    type: SET_INLINE_TAB_ADD_NEW,\n+    payload: { visible, windowId, tabId, rowId, docId },\n+  };\n+}\n+\n+/*\n+ * @method fetchInlineTabWrapperData\n+ * @summary Action creator for fetching the data for the `InlineTab` Wrapper (note: wrapper not the inline tab item!)\n+ *\n+ * @param {string} windowId\n+ * @param {string} tabId\n+ * @param {string} docId\n+ * @param {string} query\n+ */\n+export function fetchInlineTabWrapperData({\n+  windowId,\n+  tabId,\n+  docId,\n+  query,\n+  rowId,\n+  postDeletion,\n+}) {\n+  return (dispatch) => {\n+    dispatch(fetchTab({ tabId, windowId, docId, query })).then((tabData) => {\n+      /** - if we have the rowId it means we have a new record addition, so we put that at the end of the array - only if this doesn't happen as a result of deletion */\n+      if (rowId && !postDeletion) {\n+        const lastAdditionIndex = tabData.findIndex(\n+          (item) => item.rowId === rowId\n+        );\n+        if (lastAdditionIndex) {\n+          const tempData = tabData[lastAdditionIndex];\n+          tabData.splice(lastAdditionIndex, 1);\n+          tabData.splice(tabData.length, 0, tempData);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjUxNzI5OA=="}, "originalCommit": {"oid": "7f63af1096f726bd57a4b913066b8932edd49d7a"}, "originalPosition": 114}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwODU4NTg5OnYy", "diffSide": "RIGHT", "path": "frontend/src/actions/InlineTabActions.js", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxNjoyMzoyOFrOIFYqWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwODowMTozM1rOIHpEcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjUxNzg0OA==", "bodyText": "Add a helper to format id's ?", "url": "https://github.com/metasfresh/metasfresh/pull/10301#discussion_r542517848", "createdAt": "2020-12-14T16:23:28Z", "author": {"login": "siemiatj"}, "path": "frontend/src/actions/InlineTabActions.js", "diffHunk": "@@ -0,0 +1,223 @@\n+import { fetchTab } from './WindowActions';\n+import { getLayout, getData } from '../api';\n+import { INLINE_TAB_SHOW_MORE_FROM } from '../constants/Constants';\n+import {\n+  UPDATE_INLINE_TAB_ITEM_FIELDS,\n+  UPDATE_INLINE_TAB_WRAPPER_FIELDS,\n+  SET_INLINE_TAB_WRAPPER_DATA,\n+  SET_INLINE_TAB_LAYOUT_AND_DATA,\n+  SET_INLINE_TAB_ADD_NEW,\n+  SET_INLINE_TAB_SHOW_MORE,\n+} from '../constants/ActionTypes';\n+\n+/*\n+ * @method updateInlineTabItemFields\n+ * @summary Action creator for updating the fields for the `InlineTab` Item\n+ *\n+ * @param {string} inlineTabId\n+ * @param {string} rowId\n+ * @param {object} fieldsByName\n+ */\n+export function updateInlineTabItemFields({ inlineTabId, fieldsByName }) {\n+  return {\n+    type: UPDATE_INLINE_TAB_ITEM_FIELDS,\n+    payload: { inlineTabId, fieldsByName },\n+  };\n+}\n+\n+/*\n+ * @method updateInlineTabWrapperFields\n+ * @summary Action creator for updating the fields for the `InlineTab` Wrapper\n+ *\n+ * @param {string} inlineTabWrapperId\n+ * @param {string} rowId\n+ * @param {object} fieldsByName\n+ */\n+export function updateInlineTabWrapperFields({\n+  inlineTabWrapperId,\n+  rowId,\n+  response,\n+}) {\n+  return {\n+    type: UPDATE_INLINE_TAB_WRAPPER_FIELDS,\n+    payload: { inlineTabWrapperId, rowId, response },\n+  };\n+}\n+\n+/*\n+ * Action creator called to set the inlineTabWrapper branch in the redux store with the data payload\n+ */\n+export function setInlineTabWrapperData({ inlineTabWrapperId, data }) {\n+  return {\n+    type: SET_INLINE_TAB_WRAPPER_DATA,\n+    payload: { inlineTabWrapperId, data },\n+  };\n+}\n+\n+/*\n+ * Action creator called to set the showMore value for the corresponding inlineTabWrapperId\n+ */\n+export function setInlineTabShowMore({ inlineTabWrapperId, showMore }) {\n+  return {\n+    type: SET_INLINE_TAB_SHOW_MORE,\n+    payload: { inlineTabWrapperId, showMore },\n+  };\n+}\n+\n+/*\n+ * Action creator called to set the inlineTab branch in the redux store with the data payload\n+ */\n+export function setInlineTabLayoutAndData({ inlineTabId, data }) {\n+  return {\n+    type: SET_INLINE_TAB_LAYOUT_AND_DATA,\n+    payload: { inlineTabId, data },\n+  };\n+}\n+\n+/*\n+ * Action creator called to set the inlineTab AddNew form related data in the store, visible is for toggling the visibility\n+ */\n+export function setInlineTabAddNew({ visible, windowId, tabId, rowId, docId }) {\n+  return {\n+    type: SET_INLINE_TAB_ADD_NEW,\n+    payload: { visible, windowId, tabId, rowId, docId },\n+  };\n+}\n+\n+/*\n+ * @method fetchInlineTabWrapperData\n+ * @summary Action creator for fetching the data for the `InlineTab` Wrapper (note: wrapper not the inline tab item!)\n+ *\n+ * @param {string} windowId\n+ * @param {string} tabId\n+ * @param {string} docId\n+ * @param {string} query\n+ */\n+export function fetchInlineTabWrapperData({\n+  windowId,\n+  tabId,\n+  docId,\n+  query,\n+  rowId,\n+  postDeletion,\n+}) {\n+  return (dispatch) => {\n+    dispatch(fetchTab({ tabId, windowId, docId, query })).then((tabData) => {\n+      /** - if we have the rowId it means we have a new record addition, so we put that at the end of the array - only if this doesn't happen as a result of deletion */\n+      if (rowId && !postDeletion) {\n+        const lastAdditionIndex = tabData.findIndex(\n+          (item) => item.rowId === rowId\n+        );\n+        if (lastAdditionIndex) {\n+          const tempData = tabData[lastAdditionIndex];\n+          tabData.splice(lastAdditionIndex, 1);\n+          tabData.splice(tabData.length, 0, tempData);\n+        }\n+        dispatch(\n+          setInlineTabShowMore({\n+            inlineTabWrapperId: `${windowId}_${tabId}_${docId}`,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f63af1096f726bd57a4b913066b8932edd49d7a"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg4MzgyNw==", "bodyText": "calling each time a function for that would be counter performance. But a solution would be to just define the selector in one place instead of how I put it now. This Is fixed. Ty", "url": "https://github.com/metasfresh/metasfresh/pull/10301#discussion_r544883827", "createdAt": "2020-12-17T08:01:33Z", "author": {"login": "petrican"}, "path": "frontend/src/actions/InlineTabActions.js", "diffHunk": "@@ -0,0 +1,223 @@\n+import { fetchTab } from './WindowActions';\n+import { getLayout, getData } from '../api';\n+import { INLINE_TAB_SHOW_MORE_FROM } from '../constants/Constants';\n+import {\n+  UPDATE_INLINE_TAB_ITEM_FIELDS,\n+  UPDATE_INLINE_TAB_WRAPPER_FIELDS,\n+  SET_INLINE_TAB_WRAPPER_DATA,\n+  SET_INLINE_TAB_LAYOUT_AND_DATA,\n+  SET_INLINE_TAB_ADD_NEW,\n+  SET_INLINE_TAB_SHOW_MORE,\n+} from '../constants/ActionTypes';\n+\n+/*\n+ * @method updateInlineTabItemFields\n+ * @summary Action creator for updating the fields for the `InlineTab` Item\n+ *\n+ * @param {string} inlineTabId\n+ * @param {string} rowId\n+ * @param {object} fieldsByName\n+ */\n+export function updateInlineTabItemFields({ inlineTabId, fieldsByName }) {\n+  return {\n+    type: UPDATE_INLINE_TAB_ITEM_FIELDS,\n+    payload: { inlineTabId, fieldsByName },\n+  };\n+}\n+\n+/*\n+ * @method updateInlineTabWrapperFields\n+ * @summary Action creator for updating the fields for the `InlineTab` Wrapper\n+ *\n+ * @param {string} inlineTabWrapperId\n+ * @param {string} rowId\n+ * @param {object} fieldsByName\n+ */\n+export function updateInlineTabWrapperFields({\n+  inlineTabWrapperId,\n+  rowId,\n+  response,\n+}) {\n+  return {\n+    type: UPDATE_INLINE_TAB_WRAPPER_FIELDS,\n+    payload: { inlineTabWrapperId, rowId, response },\n+  };\n+}\n+\n+/*\n+ * Action creator called to set the inlineTabWrapper branch in the redux store with the data payload\n+ */\n+export function setInlineTabWrapperData({ inlineTabWrapperId, data }) {\n+  return {\n+    type: SET_INLINE_TAB_WRAPPER_DATA,\n+    payload: { inlineTabWrapperId, data },\n+  };\n+}\n+\n+/*\n+ * Action creator called to set the showMore value for the corresponding inlineTabWrapperId\n+ */\n+export function setInlineTabShowMore({ inlineTabWrapperId, showMore }) {\n+  return {\n+    type: SET_INLINE_TAB_SHOW_MORE,\n+    payload: { inlineTabWrapperId, showMore },\n+  };\n+}\n+\n+/*\n+ * Action creator called to set the inlineTab branch in the redux store with the data payload\n+ */\n+export function setInlineTabLayoutAndData({ inlineTabId, data }) {\n+  return {\n+    type: SET_INLINE_TAB_LAYOUT_AND_DATA,\n+    payload: { inlineTabId, data },\n+  };\n+}\n+\n+/*\n+ * Action creator called to set the inlineTab AddNew form related data in the store, visible is for toggling the visibility\n+ */\n+export function setInlineTabAddNew({ visible, windowId, tabId, rowId, docId }) {\n+  return {\n+    type: SET_INLINE_TAB_ADD_NEW,\n+    payload: { visible, windowId, tabId, rowId, docId },\n+  };\n+}\n+\n+/*\n+ * @method fetchInlineTabWrapperData\n+ * @summary Action creator for fetching the data for the `InlineTab` Wrapper (note: wrapper not the inline tab item!)\n+ *\n+ * @param {string} windowId\n+ * @param {string} tabId\n+ * @param {string} docId\n+ * @param {string} query\n+ */\n+export function fetchInlineTabWrapperData({\n+  windowId,\n+  tabId,\n+  docId,\n+  query,\n+  rowId,\n+  postDeletion,\n+}) {\n+  return (dispatch) => {\n+    dispatch(fetchTab({ tabId, windowId, docId, query })).then((tabData) => {\n+      /** - if we have the rowId it means we have a new record addition, so we put that at the end of the array - only if this doesn't happen as a result of deletion */\n+      if (rowId && !postDeletion) {\n+        const lastAdditionIndex = tabData.findIndex(\n+          (item) => item.rowId === rowId\n+        );\n+        if (lastAdditionIndex) {\n+          const tempData = tabData[lastAdditionIndex];\n+          tabData.splice(lastAdditionIndex, 1);\n+          tabData.splice(tabData.length, 0, tempData);\n+        }\n+        dispatch(\n+          setInlineTabShowMore({\n+            inlineTabWrapperId: `${windowId}_${tabId}_${docId}`,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjUxNzg0OA=="}, "originalCommit": {"oid": "7f63af1096f726bd57a4b913066b8932edd49d7a"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwODU5OTA2OnYy", "diffSide": "RIGHT", "path": "frontend/src/assets/css/tabs.css", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxNjoyNjowNFrOIFYyVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwODo0ODo0N1rOIHqxHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjUxOTg5Mg==", "bodyText": "are we supposed to have a new color for this ?", "url": "https://github.com/metasfresh/metasfresh/pull/10301#discussion_r542519892", "createdAt": "2020-12-14T16:26:04Z", "author": {"login": "siemiatj"}, "path": "frontend/src/assets/css/tabs.css", "diffHunk": "@@ -308,3 +309,96 @@\n     display: flex;\n     flex-direction: column;\n }\n+\n+/** Inline TAB **/\n+.inline-tab-wrapper {\n+    width: 100%;\n+    box-sizing: border-box;\n+    .main-label {\n+      font-weight: bold; \n+      color: #495057;\n+    }\n+    .inlinetab-action-button {\n+      float:left;\n+    }\n+    .inlinetab-showmore {\n+      float: right;\n+    }\n+    .bottom-offset {\n+      margin-bottom: 5px;\n+    }\n+}\n+.inline-tab-fullscreen-top-offset {\n+  padding-top: 20px !important;\n+}\n+.inline-tab {\n+    background: #E3E1E2;\n+    width: 100%;\n+    box-sizing: border-box;\n+    padding: 10px 15px 10px 15px;\n+    border-radius: 3px;\n+    cursor: pointer;\n+    margin-bottom:5px;\n+\n+    .arrow-pointer {\n+      display: block;\n+      float: left;\n+      margin: 6px 8px 8px 0px;\n+      width: 8px;\n+      height: 8px;\n+      border-top: 2px solid #000;\n+      border-left: 2px solid #000;\n+      transform: rotate(135deg);\n+    }\n+    .offset-left {\n+      margin-left:15px;\n+    }\n+}\n+\n+.inline-tab:hover {\n+  background-color: #dddddd;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f63af1096f726bd57a4b913066b8932edd49d7a"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDkxMTY0Ng==", "bodyText": "light-gray would do it", "url": "https://github.com/metasfresh/metasfresh/pull/10301#discussion_r544911646", "createdAt": "2020-12-17T08:48:47Z", "author": {"login": "petrican"}, "path": "frontend/src/assets/css/tabs.css", "diffHunk": "@@ -308,3 +309,96 @@\n     display: flex;\n     flex-direction: column;\n }\n+\n+/** Inline TAB **/\n+.inline-tab-wrapper {\n+    width: 100%;\n+    box-sizing: border-box;\n+    .main-label {\n+      font-weight: bold; \n+      color: #495057;\n+    }\n+    .inlinetab-action-button {\n+      float:left;\n+    }\n+    .inlinetab-showmore {\n+      float: right;\n+    }\n+    .bottom-offset {\n+      margin-bottom: 5px;\n+    }\n+}\n+.inline-tab-fullscreen-top-offset {\n+  padding-top: 20px !important;\n+}\n+.inline-tab {\n+    background: #E3E1E2;\n+    width: 100%;\n+    box-sizing: border-box;\n+    padding: 10px 15px 10px 15px;\n+    border-radius: 3px;\n+    cursor: pointer;\n+    margin-bottom:5px;\n+\n+    .arrow-pointer {\n+      display: block;\n+      float: left;\n+      margin: 6px 8px 8px 0px;\n+      width: 8px;\n+      height: 8px;\n+      border-top: 2px solid #000;\n+      border-left: 2px solid #000;\n+      transform: rotate(135deg);\n+    }\n+    .offset-left {\n+      margin-left:15px;\n+    }\n+}\n+\n+.inline-tab:hover {\n+  background-color: #dddddd;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjUxOTg5Mg=="}, "originalCommit": {"oid": "7f63af1096f726bd57a4b913066b8932edd49d7a"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwODYwMjEyOnYy", "diffSide": "RIGHT", "path": "frontend/src/assets/css/tabs.css", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxNjoyNjozNVrOIFY0Hw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwODo0ODozMFrOIHqwiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjUyMDM1MQ==", "bodyText": "New color again ? Won't brand-bright-color work ?", "url": "https://github.com/metasfresh/metasfresh/pull/10301#discussion_r542520351", "createdAt": "2020-12-14T16:26:35Z", "author": {"login": "siemiatj"}, "path": "frontend/src/assets/css/tabs.css", "diffHunk": "@@ -308,3 +309,96 @@\n     display: flex;\n     flex-direction: column;\n }\n+\n+/** Inline TAB **/\n+.inline-tab-wrapper {\n+    width: 100%;\n+    box-sizing: border-box;\n+    .main-label {\n+      font-weight: bold; \n+      color: #495057;\n+    }\n+    .inlinetab-action-button {\n+      float:left;\n+    }\n+    .inlinetab-showmore {\n+      float: right;\n+    }\n+    .bottom-offset {\n+      margin-bottom: 5px;\n+    }\n+}\n+.inline-tab-fullscreen-top-offset {\n+  padding-top: 20px !important;\n+}\n+.inline-tab {\n+    background: #E3E1E2;\n+    width: 100%;\n+    box-sizing: border-box;\n+    padding: 10px 15px 10px 15px;\n+    border-radius: 3px;\n+    cursor: pointer;\n+    margin-bottom:5px;\n+\n+    .arrow-pointer {\n+      display: block;\n+      float: left;\n+      margin: 6px 8px 8px 0px;\n+      width: 8px;\n+      height: 8px;\n+      border-top: 2px solid #000;\n+      border-left: 2px solid #000;\n+      transform: rotate(135deg);\n+    }\n+    .offset-left {\n+      margin-left:15px;\n+    }\n+}\n+\n+.inline-tab:hover {\n+  background-color: #dddddd;\n+}\n+\n+.inline-tab-offset-top {\n+  margin-top: -5px;\n+}\n+\n+.inline-tab-active {\n+  background: #F6F4EF;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f63af1096f726bd57a4b913066b8932edd49d7a"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDkxMTQ5Nw==", "bodyText": "nope, added new var", "url": "https://github.com/metasfresh/metasfresh/pull/10301#discussion_r544911497", "createdAt": "2020-12-17T08:48:30Z", "author": {"login": "petrican"}, "path": "frontend/src/assets/css/tabs.css", "diffHunk": "@@ -308,3 +309,96 @@\n     display: flex;\n     flex-direction: column;\n }\n+\n+/** Inline TAB **/\n+.inline-tab-wrapper {\n+    width: 100%;\n+    box-sizing: border-box;\n+    .main-label {\n+      font-weight: bold; \n+      color: #495057;\n+    }\n+    .inlinetab-action-button {\n+      float:left;\n+    }\n+    .inlinetab-showmore {\n+      float: right;\n+    }\n+    .bottom-offset {\n+      margin-bottom: 5px;\n+    }\n+}\n+.inline-tab-fullscreen-top-offset {\n+  padding-top: 20px !important;\n+}\n+.inline-tab {\n+    background: #E3E1E2;\n+    width: 100%;\n+    box-sizing: border-box;\n+    padding: 10px 15px 10px 15px;\n+    border-radius: 3px;\n+    cursor: pointer;\n+    margin-bottom:5px;\n+\n+    .arrow-pointer {\n+      display: block;\n+      float: left;\n+      margin: 6px 8px 8px 0px;\n+      width: 8px;\n+      height: 8px;\n+      border-top: 2px solid #000;\n+      border-left: 2px solid #000;\n+      transform: rotate(135deg);\n+    }\n+    .offset-left {\n+      margin-left:15px;\n+    }\n+}\n+\n+.inline-tab:hover {\n+  background-color: #dddddd;\n+}\n+\n+.inline-tab-offset-top {\n+  margin-top: -5px;\n+}\n+\n+.inline-tab-active {\n+  background: #F6F4EF;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjUyMDM1MQ=="}, "originalCommit": {"oid": "7f63af1096f726bd57a4b913066b8932edd49d7a"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwODYwNTMxOnYy", "diffSide": "RIGHT", "path": "frontend/src/assets/css/tabs.css", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxNjoyNzoxMlrOIFY2Dw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwODo1MToxMlrOIHq3YQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjUyMDg0Nw==", "bodyText": "This looks like brand-light-color", "url": "https://github.com/metasfresh/metasfresh/pull/10301#discussion_r542520847", "createdAt": "2020-12-14T16:27:12Z", "author": {"login": "siemiatj"}, "path": "frontend/src/assets/css/tabs.css", "diffHunk": "@@ -308,3 +309,96 @@\n     display: flex;\n     flex-direction: column;\n }\n+\n+/** Inline TAB **/\n+.inline-tab-wrapper {\n+    width: 100%;\n+    box-sizing: border-box;\n+    .main-label {\n+      font-weight: bold; \n+      color: #495057;\n+    }\n+    .inlinetab-action-button {\n+      float:left;\n+    }\n+    .inlinetab-showmore {\n+      float: right;\n+    }\n+    .bottom-offset {\n+      margin-bottom: 5px;\n+    }\n+}\n+.inline-tab-fullscreen-top-offset {\n+  padding-top: 20px !important;\n+}\n+.inline-tab {\n+    background: #E3E1E2;\n+    width: 100%;\n+    box-sizing: border-box;\n+    padding: 10px 15px 10px 15px;\n+    border-radius: 3px;\n+    cursor: pointer;\n+    margin-bottom:5px;\n+\n+    .arrow-pointer {\n+      display: block;\n+      float: left;\n+      margin: 6px 8px 8px 0px;\n+      width: 8px;\n+      height: 8px;\n+      border-top: 2px solid #000;\n+      border-left: 2px solid #000;\n+      transform: rotate(135deg);\n+    }\n+    .offset-left {\n+      margin-left:15px;\n+    }\n+}\n+\n+.inline-tab:hover {\n+  background-color: #dddddd;\n+}\n+\n+.inline-tab-offset-top {\n+  margin-top: -5px;\n+}\n+\n+.inline-tab-active {\n+  background: #F6F4EF;\n+  width: 100%;\n+  box-sizing: border-box;\n+  padding: 10px 15px 10px 15px;\n+  border-radius: 3px;\n+  cursor: pointer;\n+  margin-bottom:5px;\n+\n+  .arrow-pointer {\n+    display: block;\n+    float: left;\n+    margin: 4px 8px 8px 0px;\n+    width: 8px;\n+    height: 8px;\n+    border-top: 2px solid #000;\n+    border-left: 2px solid #000;\n+    transform: rotate(224deg);\n+  }\n+  .offset-left {\n+    margin-left:15px;\n+  }\n+  .inline-tab-separator {\n+    width:100%;\n+    border-top: 1px solid #C8D6D5;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f63af1096f726bd57a4b913066b8932edd49d7a"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDkxMzI0OQ==", "bodyText": "changed", "url": "https://github.com/metasfresh/metasfresh/pull/10301#discussion_r544913249", "createdAt": "2020-12-17T08:51:12Z", "author": {"login": "petrican"}, "path": "frontend/src/assets/css/tabs.css", "diffHunk": "@@ -308,3 +309,96 @@\n     display: flex;\n     flex-direction: column;\n }\n+\n+/** Inline TAB **/\n+.inline-tab-wrapper {\n+    width: 100%;\n+    box-sizing: border-box;\n+    .main-label {\n+      font-weight: bold; \n+      color: #495057;\n+    }\n+    .inlinetab-action-button {\n+      float:left;\n+    }\n+    .inlinetab-showmore {\n+      float: right;\n+    }\n+    .bottom-offset {\n+      margin-bottom: 5px;\n+    }\n+}\n+.inline-tab-fullscreen-top-offset {\n+  padding-top: 20px !important;\n+}\n+.inline-tab {\n+    background: #E3E1E2;\n+    width: 100%;\n+    box-sizing: border-box;\n+    padding: 10px 15px 10px 15px;\n+    border-radius: 3px;\n+    cursor: pointer;\n+    margin-bottom:5px;\n+\n+    .arrow-pointer {\n+      display: block;\n+      float: left;\n+      margin: 6px 8px 8px 0px;\n+      width: 8px;\n+      height: 8px;\n+      border-top: 2px solid #000;\n+      border-left: 2px solid #000;\n+      transform: rotate(135deg);\n+    }\n+    .offset-left {\n+      margin-left:15px;\n+    }\n+}\n+\n+.inline-tab:hover {\n+  background-color: #dddddd;\n+}\n+\n+.inline-tab-offset-top {\n+  margin-top: -5px;\n+}\n+\n+.inline-tab-active {\n+  background: #F6F4EF;\n+  width: 100%;\n+  box-sizing: border-box;\n+  padding: 10px 15px 10px 15px;\n+  border-radius: 3px;\n+  cursor: pointer;\n+  margin-bottom:5px;\n+\n+  .arrow-pointer {\n+    display: block;\n+    float: left;\n+    margin: 4px 8px 8px 0px;\n+    width: 8px;\n+    height: 8px;\n+    border-top: 2px solid #000;\n+    border-left: 2px solid #000;\n+    transform: rotate(224deg);\n+  }\n+  .offset-left {\n+    margin-left:15px;\n+  }\n+  .inline-tab-separator {\n+    width:100%;\n+    border-top: 1px solid #C8D6D5;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjUyMDg0Nw=="}, "originalCommit": {"oid": "7f63af1096f726bd57a4b913066b8932edd49d7a"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwODYyNjY1OnYy", "diffSide": "RIGHT", "path": "frontend/src/reducers/windowHandler.js", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxNjozMTowMlrOIFZCbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxNjozMTowMlrOIFZCbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjUyNDAxMg==", "bodyText": "typo", "url": "https://github.com/metasfresh/metasfresh/pull/10301#discussion_r542524012", "createdAt": "2020-12-14T16:31:02Z", "author": {"login": "siemiatj"}, "path": "frontend/src/reducers/windowHandler.js", "diffHunk": "@@ -732,6 +790,111 @@ export default function windowHandler(state = initialState, action) {\n         },\n       };\n     }\n+    // INLINE TAB ACTINIONS", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f63af1096f726bd57a4b913066b8932edd49d7a"}, "originalPosition": 131}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwODY0MjAxOnYy", "diffSide": "RIGHT", "path": "frontend/src/reducers/windowHandler.js", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxNjozMzo1OVrOIFZLRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwODo1Njo0M1rOIHrFDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjUyNjI3Ng==", "bodyText": "Why use map if you're not returning a map but just iterate over items ?", "url": "https://github.com/metasfresh/metasfresh/pull/10301#discussion_r542526276", "createdAt": "2020-12-14T16:33:59Z", "author": {"login": "siemiatj"}, "path": "frontend/src/reducers/windowHandler.js", "diffHunk": "@@ -732,6 +790,111 @@ export default function windowHandler(state = initialState, action) {\n         },\n       };\n     }\n+    // INLINE TAB ACTINIONS\n+    case SET_INLINE_TAB_LAYOUT_AND_DATA: {\n+      return {\n+        ...state,\n+        inlineTab: {\n+          ...state.inlineTab,\n+          [`${action.payload.inlineTabId}`]: action.payload.data,\n+        },\n+      };\n+    }\n+    case SET_INLINE_TAB_WRAPPER_DATA: {\n+      return {\n+        ...state,\n+        inlineTab: {\n+          ...state.inlineTab,\n+          wrapperData: {\n+            ...state.inlineTab.wrapperData,\n+            [`${action.payload.inlineTabWrapperId}`]: action.payload.data,\n+          },\n+        },\n+      };\n+    }\n+    case UPDATE_INLINE_TAB_WRAPPER_FIELDS: {\n+      let indexWD;\n+      const { inlineTabWrapperId, rowId, response } = action.payload;\n+      const { fieldsByName, saveStatus, validStatus } = response;\n+      state.inlineTab.wrapperData[inlineTabWrapperId].forEach((item, i) => {\n+        if (item.rowId === rowId) indexWD = i;\n+      });\n+\n+      const wrapperDataClone = { ...state.inlineTab.wrapperData };\n+      if (wrapperDataClone[inlineTabWrapperId][indexWD]) {\n+        wrapperDataClone[inlineTabWrapperId][indexWD].saveStatus = saveStatus;\n+        wrapperDataClone[inlineTabWrapperId][indexWD].validStatus = validStatus;\n+        wrapperDataClone[inlineTabWrapperId][indexWD].fieldsByName = {\n+          ...wrapperDataClone[inlineTabWrapperId][indexWD].fieldsByName,\n+          ...fieldsByName,\n+        };\n+      }\n+\n+      return {\n+        ...state,\n+        inlineTab: {\n+          ...state.inlineTab,\n+          wrapperData: wrapperDataClone,\n+        },\n+      };\n+    }\n+\n+    case UPDATE_INLINE_TAB_ITEM_FIELDS: {\n+      const { inlineTabId, fieldsByName } = action.payload;\n+\n+      const targetTabData = { ...state.inlineTab[`${inlineTabId}`].data };\n+\n+      Object.keys(fieldsByName).map((fieldItem) => {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f63af1096f726bd57a4b913066b8932edd49d7a"}, "originalPosition": 185}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDkxNjc1MA==", "bodyText": "Good point. Fixed", "url": "https://github.com/metasfresh/metasfresh/pull/10301#discussion_r544916750", "createdAt": "2020-12-17T08:56:43Z", "author": {"login": "petrican"}, "path": "frontend/src/reducers/windowHandler.js", "diffHunk": "@@ -732,6 +790,111 @@ export default function windowHandler(state = initialState, action) {\n         },\n       };\n     }\n+    // INLINE TAB ACTINIONS\n+    case SET_INLINE_TAB_LAYOUT_AND_DATA: {\n+      return {\n+        ...state,\n+        inlineTab: {\n+          ...state.inlineTab,\n+          [`${action.payload.inlineTabId}`]: action.payload.data,\n+        },\n+      };\n+    }\n+    case SET_INLINE_TAB_WRAPPER_DATA: {\n+      return {\n+        ...state,\n+        inlineTab: {\n+          ...state.inlineTab,\n+          wrapperData: {\n+            ...state.inlineTab.wrapperData,\n+            [`${action.payload.inlineTabWrapperId}`]: action.payload.data,\n+          },\n+        },\n+      };\n+    }\n+    case UPDATE_INLINE_TAB_WRAPPER_FIELDS: {\n+      let indexWD;\n+      const { inlineTabWrapperId, rowId, response } = action.payload;\n+      const { fieldsByName, saveStatus, validStatus } = response;\n+      state.inlineTab.wrapperData[inlineTabWrapperId].forEach((item, i) => {\n+        if (item.rowId === rowId) indexWD = i;\n+      });\n+\n+      const wrapperDataClone = { ...state.inlineTab.wrapperData };\n+      if (wrapperDataClone[inlineTabWrapperId][indexWD]) {\n+        wrapperDataClone[inlineTabWrapperId][indexWD].saveStatus = saveStatus;\n+        wrapperDataClone[inlineTabWrapperId][indexWD].validStatus = validStatus;\n+        wrapperDataClone[inlineTabWrapperId][indexWD].fieldsByName = {\n+          ...wrapperDataClone[inlineTabWrapperId][indexWD].fieldsByName,\n+          ...fieldsByName,\n+        };\n+      }\n+\n+      return {\n+        ...state,\n+        inlineTab: {\n+          ...state.inlineTab,\n+          wrapperData: wrapperDataClone,\n+        },\n+      };\n+    }\n+\n+    case UPDATE_INLINE_TAB_ITEM_FIELDS: {\n+      const { inlineTabId, fieldsByName } = action.payload;\n+\n+      const targetTabData = { ...state.inlineTab[`${inlineTabId}`].data };\n+\n+      Object.keys(fieldsByName).map((fieldItem) => {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjUyNjI3Ng=="}, "originalCommit": {"oid": "7f63af1096f726bd57a4b913066b8932edd49d7a"}, "originalPosition": 185}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwODY1MTU5OnYy", "diffSide": "RIGHT", "path": "frontend/src/reducers/windowHandler.js", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxNjozNTozNlrOIFZQ2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxNjozNTozNlrOIFZQ2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjUyNzcwNg==", "bodyText": "Please add a fallback when state.windowHandler.inlineTab[id] doesn't exist. Best to just use lodash's get", "url": "https://github.com/metasfresh/metasfresh/pull/10301#discussion_r542527706", "createdAt": "2020-12-14T16:35:36Z", "author": {"login": "siemiatj"}, "path": "frontend/src/reducers/windowHandler.js", "diffHunk": "@@ -205,6 +250,19 @@ export const getElementWidgetData = createCachedSelector(\n   (data, layout) => selectWidgetData(data, layout)\n )((_state_, isModal, layoutPath) => layoutPath);\n \n+/**\n+ * @method getInlineTabWidgetFields\n+ *\n+ * @param {object} state - redux state\n+ * @param {boolean} isModal\n+ * @param {string} layoutPath - indexes of elements in the layout structure\n+ */\n+export const getInlineTabWidgetFields = ({ state, inlineTabId }) => {\n+  const data = state.windowHandler.inlineTab[`${inlineTabId}`].data;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f63af1096f726bd57a4b913066b8932edd49d7a"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNDI1NDcyOnYy", "diffSide": "RIGHT", "path": "frontend/src/__tests__/actions/InlineTabActions.test.js", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNDoxMToyMFrOIGM4VA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwNzoxMzoxMVrOIHnolA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzM3MzM5Ng==", "bodyText": "What are those comments for ?", "url": "https://github.com/metasfresh/metasfresh/pull/10301#discussion_r543373396", "createdAt": "2020-12-15T14:11:20Z", "author": {"login": "siemiatj"}, "path": "frontend/src/__tests__/actions/InlineTabActions.test.js", "diffHunk": "@@ -0,0 +1,322 @@\n+import thunk from 'redux-thunk';\n+import configureStore from 'redux-mock-store';\n+import merge from 'merge';\n+import {\n+  updateInlineTabItemFields,\n+  updateInlineTabWrapperFields,\n+  setInlineTabWrapperData,\n+  setInlineTabShowMore,\n+  setInlineTabLayoutAndData,\n+  setInlineTabAddNew,\n+} from '../../actions/InlineTabActions';\n+import * as ACTION_TYPES from '../../constants/ActionTypes';\n+import gridProps from '../../../test_setup/fixtures/grid.json';\n+import gridLayoutFixtures from '../../../test_setup/fixtures/grid/layout.json';\n+import { initialState as initialViewsState } from '../../reducers/viewHandler';\n+import tablesHandler from '../../reducers/tables';\n+const middlewares = [thunk];\n+const mockStore = configureStore(middlewares);\n+\n+const createState = function(state = {}) {\n+  const res = merge.recursive(\n+    true,\n+    {\n+      viewHandler: initialViewsState,\n+      tables: { ...tablesHandler(undefined, {}) },\n+    },\n+    state\n+  );\n+\n+  return res;\n+};\n+\n+describe('InlineTab - actions general', () => {\n+  /** UPDATE_INLINE_TAB_ITEM_FIELDS action */\n+  it('should call UPDATE_INLINE_TAB_ITEM_FIELDS action with correct payload', () => {\n+    const { windowType } = gridProps.props1;\n+    const layoutResponse = gridLayoutFixtures.layout1;\n+    const initialInlineTabId = '123_AD_Tab-222_2205230';\n+    const initialFieldsByName = {\n+      BPartnerName: {\n+        field: 'BPartnerName',\n+        value: 'e',\n+        widgetType: 'Text',\n+        validStatus: {\n+          valid: true,\n+          initialValue: true,\n+          fieldName: 'BPartnerName',\n+        },\n+      },\n+    };\n+    const payload = {\n+      inlineTabId: initialInlineTabId,\n+      fieldsByName: initialFieldsByName,\n+    };\n+    const action = updateInlineTabItemFields({\n+      inlineTabId: initialInlineTabId,\n+      fieldsByName: initialFieldsByName,\n+    });\n+\n+    expect(action.type).toEqual(ACTION_TYPES.UPDATE_INLINE_TAB_ITEM_FIELDS);\n+    expect(action.payload).toHaveProperty('inlineTabId', payload.inlineTabId);\n+    expect(action.payload).toHaveProperty('fieldsByName', payload.fieldsByName);\n+\n+    const initialState = createState({\n+      viewHandler: {\n+        views: {\n+          [windowType]: {\n+            layout: { ...layoutResponse },\n+          },\n+        },\n+      },\n+    });\n+    const store = mockStore(initialState);\n+    const expectedActions = [\n+      { type: ACTION_TYPES.UPDATE_INLINE_TAB_ITEM_FIELDS, payload },\n+    ];\n+\n+    store.dispatch(\n+      updateInlineTabItemFields({\n+        inlineTabId: initialInlineTabId,\n+        fieldsByName: initialFieldsByName,\n+      })\n+    );\n+    expect(store.getActions()).toEqual(expect.arrayContaining(expectedActions));\n+  });\n+\n+  /** UPDATE_INLINE_TAB_WRAPPER_FIELDS action */\n+  it('should call UPDATE_INLINE_TAB_WRAPPER_FIELDS action with correct payload', () => {\n+    const { windowType } = gridProps.props1;\n+    const layoutResponse = gridLayoutFixtures.layout1;\n+    const initialInlineTabId = '123_AD_Tab-222_2205230';\n+    const rowId = '2205230';\n+    const payload = {\n+      inlineTabWrapperId: initialInlineTabId,\n+      rowId,\n+      response: {},\n+    };\n+\n+    const action = updateInlineTabWrapperFields({\n+      inlineTabWrapperId: initialInlineTabId,\n+      rowId,\n+      response: {},\n+    });\n+\n+    expect(action.type).toEqual(ACTION_TYPES.UPDATE_INLINE_TAB_WRAPPER_FIELDS);\n+    expect(action.payload).toHaveProperty(\n+      'inlineTabWrapperId',\n+      payload.inlineTabWrapperId\n+    );\n+    expect(action.payload).toHaveProperty('rowId', payload.rowId);\n+    expect(action.payload).toHaveProperty('response', payload.response);\n+\n+    const initialState = createState({\n+      viewHandler: {\n+        views: {\n+          [windowType]: {\n+            layout: { ...layoutResponse },\n+          },\n+        },\n+      },\n+    });\n+    const store = mockStore(initialState);\n+    const expectedActions = [\n+      { type: ACTION_TYPES.UPDATE_INLINE_TAB_WRAPPER_FIELDS, payload },\n+    ];\n+\n+    store.dispatch(\n+      updateInlineTabWrapperFields({\n+        inlineTabWrapperId: initialInlineTabId,\n+        rowId,\n+        response: {},\n+      })\n+    );\n+    expect(store.getActions()).toEqual(expect.arrayContaining(expectedActions));\n+  });\n+\n+  /** SET_INLINE_TAB_WRAPPER_DATA action */\n+  it('should call SET_INLINE_TAB_WRAPPER_DATA action with correct payload', () => {\n+    const { windowType } = gridProps.props1;\n+    const layoutResponse = gridLayoutFixtures.layout1;\n+    const initialInlineTabWrapperId = '123_AD_Tab-222_2205230';\n+    const dummyProp = { dummyProp: 'test ' };\n+    const payload = {\n+      inlineTabWrapperId: initialInlineTabWrapperId,\n+      data: dummyProp,\n+    };\n+\n+    const action = setInlineTabWrapperData({\n+      inlineTabWrapperId: initialInlineTabWrapperId,\n+      data: dummyProp,\n+    });\n+\n+    expect(action.type).toEqual(ACTION_TYPES.SET_INLINE_TAB_WRAPPER_DATA);\n+    expect(action.payload).toHaveProperty(\n+      'inlineTabWrapperId',\n+      payload.inlineTabWrapperId\n+    );\n+    expect(action.payload).toHaveProperty('data', payload.data);\n+\n+    const initialState = createState({\n+      viewHandler: {\n+        views: {\n+          [windowType]: {\n+            layout: { ...layoutResponse },\n+          },\n+        },\n+      },\n+    });\n+    const store = mockStore(initialState);\n+    const expectedActions = [\n+      { type: ACTION_TYPES.SET_INLINE_TAB_WRAPPER_DATA, payload },\n+    ];\n+\n+    store.dispatch(\n+      setInlineTabWrapperData({\n+        inlineTabWrapperId: initialInlineTabWrapperId,\n+        data: dummyProp,\n+      })\n+    );\n+    expect(store.getActions()).toEqual(expect.arrayContaining(expectedActions));\n+  });\n+\n+  /** SET_INLINE_TAB_SHOW_MORE action */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ec15cf84fe4c3753efc94169806a5a0ef9f76bf"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg2MDMwOA==", "bodyText": "Just a way to see easier what is been tested.", "url": "https://github.com/metasfresh/metasfresh/pull/10301#discussion_r544860308", "createdAt": "2020-12-17T07:13:11Z", "author": {"login": "petrican"}, "path": "frontend/src/__tests__/actions/InlineTabActions.test.js", "diffHunk": "@@ -0,0 +1,322 @@\n+import thunk from 'redux-thunk';\n+import configureStore from 'redux-mock-store';\n+import merge from 'merge';\n+import {\n+  updateInlineTabItemFields,\n+  updateInlineTabWrapperFields,\n+  setInlineTabWrapperData,\n+  setInlineTabShowMore,\n+  setInlineTabLayoutAndData,\n+  setInlineTabAddNew,\n+} from '../../actions/InlineTabActions';\n+import * as ACTION_TYPES from '../../constants/ActionTypes';\n+import gridProps from '../../../test_setup/fixtures/grid.json';\n+import gridLayoutFixtures from '../../../test_setup/fixtures/grid/layout.json';\n+import { initialState as initialViewsState } from '../../reducers/viewHandler';\n+import tablesHandler from '../../reducers/tables';\n+const middlewares = [thunk];\n+const mockStore = configureStore(middlewares);\n+\n+const createState = function(state = {}) {\n+  const res = merge.recursive(\n+    true,\n+    {\n+      viewHandler: initialViewsState,\n+      tables: { ...tablesHandler(undefined, {}) },\n+    },\n+    state\n+  );\n+\n+  return res;\n+};\n+\n+describe('InlineTab - actions general', () => {\n+  /** UPDATE_INLINE_TAB_ITEM_FIELDS action */\n+  it('should call UPDATE_INLINE_TAB_ITEM_FIELDS action with correct payload', () => {\n+    const { windowType } = gridProps.props1;\n+    const layoutResponse = gridLayoutFixtures.layout1;\n+    const initialInlineTabId = '123_AD_Tab-222_2205230';\n+    const initialFieldsByName = {\n+      BPartnerName: {\n+        field: 'BPartnerName',\n+        value: 'e',\n+        widgetType: 'Text',\n+        validStatus: {\n+          valid: true,\n+          initialValue: true,\n+          fieldName: 'BPartnerName',\n+        },\n+      },\n+    };\n+    const payload = {\n+      inlineTabId: initialInlineTabId,\n+      fieldsByName: initialFieldsByName,\n+    };\n+    const action = updateInlineTabItemFields({\n+      inlineTabId: initialInlineTabId,\n+      fieldsByName: initialFieldsByName,\n+    });\n+\n+    expect(action.type).toEqual(ACTION_TYPES.UPDATE_INLINE_TAB_ITEM_FIELDS);\n+    expect(action.payload).toHaveProperty('inlineTabId', payload.inlineTabId);\n+    expect(action.payload).toHaveProperty('fieldsByName', payload.fieldsByName);\n+\n+    const initialState = createState({\n+      viewHandler: {\n+        views: {\n+          [windowType]: {\n+            layout: { ...layoutResponse },\n+          },\n+        },\n+      },\n+    });\n+    const store = mockStore(initialState);\n+    const expectedActions = [\n+      { type: ACTION_TYPES.UPDATE_INLINE_TAB_ITEM_FIELDS, payload },\n+    ];\n+\n+    store.dispatch(\n+      updateInlineTabItemFields({\n+        inlineTabId: initialInlineTabId,\n+        fieldsByName: initialFieldsByName,\n+      })\n+    );\n+    expect(store.getActions()).toEqual(expect.arrayContaining(expectedActions));\n+  });\n+\n+  /** UPDATE_INLINE_TAB_WRAPPER_FIELDS action */\n+  it('should call UPDATE_INLINE_TAB_WRAPPER_FIELDS action with correct payload', () => {\n+    const { windowType } = gridProps.props1;\n+    const layoutResponse = gridLayoutFixtures.layout1;\n+    const initialInlineTabId = '123_AD_Tab-222_2205230';\n+    const rowId = '2205230';\n+    const payload = {\n+      inlineTabWrapperId: initialInlineTabId,\n+      rowId,\n+      response: {},\n+    };\n+\n+    const action = updateInlineTabWrapperFields({\n+      inlineTabWrapperId: initialInlineTabId,\n+      rowId,\n+      response: {},\n+    });\n+\n+    expect(action.type).toEqual(ACTION_TYPES.UPDATE_INLINE_TAB_WRAPPER_FIELDS);\n+    expect(action.payload).toHaveProperty(\n+      'inlineTabWrapperId',\n+      payload.inlineTabWrapperId\n+    );\n+    expect(action.payload).toHaveProperty('rowId', payload.rowId);\n+    expect(action.payload).toHaveProperty('response', payload.response);\n+\n+    const initialState = createState({\n+      viewHandler: {\n+        views: {\n+          [windowType]: {\n+            layout: { ...layoutResponse },\n+          },\n+        },\n+      },\n+    });\n+    const store = mockStore(initialState);\n+    const expectedActions = [\n+      { type: ACTION_TYPES.UPDATE_INLINE_TAB_WRAPPER_FIELDS, payload },\n+    ];\n+\n+    store.dispatch(\n+      updateInlineTabWrapperFields({\n+        inlineTabWrapperId: initialInlineTabId,\n+        rowId,\n+        response: {},\n+      })\n+    );\n+    expect(store.getActions()).toEqual(expect.arrayContaining(expectedActions));\n+  });\n+\n+  /** SET_INLINE_TAB_WRAPPER_DATA action */\n+  it('should call SET_INLINE_TAB_WRAPPER_DATA action with correct payload', () => {\n+    const { windowType } = gridProps.props1;\n+    const layoutResponse = gridLayoutFixtures.layout1;\n+    const initialInlineTabWrapperId = '123_AD_Tab-222_2205230';\n+    const dummyProp = { dummyProp: 'test ' };\n+    const payload = {\n+      inlineTabWrapperId: initialInlineTabWrapperId,\n+      data: dummyProp,\n+    };\n+\n+    const action = setInlineTabWrapperData({\n+      inlineTabWrapperId: initialInlineTabWrapperId,\n+      data: dummyProp,\n+    });\n+\n+    expect(action.type).toEqual(ACTION_TYPES.SET_INLINE_TAB_WRAPPER_DATA);\n+    expect(action.payload).toHaveProperty(\n+      'inlineTabWrapperId',\n+      payload.inlineTabWrapperId\n+    );\n+    expect(action.payload).toHaveProperty('data', payload.data);\n+\n+    const initialState = createState({\n+      viewHandler: {\n+        views: {\n+          [windowType]: {\n+            layout: { ...layoutResponse },\n+          },\n+        },\n+      },\n+    });\n+    const store = mockStore(initialState);\n+    const expectedActions = [\n+      { type: ACTION_TYPES.SET_INLINE_TAB_WRAPPER_DATA, payload },\n+    ];\n+\n+    store.dispatch(\n+      setInlineTabWrapperData({\n+        inlineTabWrapperId: initialInlineTabWrapperId,\n+        data: dummyProp,\n+      })\n+    );\n+    expect(store.getActions()).toEqual(expect.arrayContaining(expectedActions));\n+  });\n+\n+  /** SET_INLINE_TAB_SHOW_MORE action */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzM3MzM5Ng=="}, "originalCommit": {"oid": "6ec15cf84fe4c3753efc94169806a5a0ef9f76bf"}, "originalPosition": 183}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNDI2OTgzOnYy", "diffSide": "RIGHT", "path": "frontend/src/actions/WindowActions.js", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNDoxMzoxMFrOIGNBbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNDoxMzoxMFrOIGNBbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzM3NTcyNw==", "bodyText": "From what I saw in the test these could probably get a default null value here.", "url": "https://github.com/metasfresh/metasfresh/pull/10301#discussion_r543375727", "createdAt": "2020-12-15T14:13:10Z", "author": {"login": "siemiatj"}, "path": "frontend/src/actions/WindowActions.js", "diffHunk": "@@ -499,14 +500,17 @@ export function initWindow(windowType, docId, tabId, rowId = null, isAdvanced) {\n /*\n  * Main method to generate window\n  */\n-export function createWindow(\n-  windowType,\n-  documentId = 'NEW',\n+export function createWindow({\n+  windowId: windowType,\n+  docId,\n   tabId,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ec15cf84fe4c3753efc94169806a5a0ef9f76bf"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNTAxNzA5OnYy", "diffSide": "RIGHT", "path": "frontend/src/__tests__/components/widget/InlineTab/InlineTabWrapper.test.js", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNjoyMjozOVrOIGT9qQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwNzoyODo1OVrOIHoDOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ4OTQ0OQ==", "bodyText": "please use values from fixtures instead of hardcoded ids", "url": "https://github.com/metasfresh/metasfresh/pull/10301#discussion_r543489449", "createdAt": "2020-12-15T16:22:39Z", "author": {"login": "siemiatj"}, "path": "frontend/src/__tests__/components/widget/InlineTab/InlineTabWrapper.test.js", "diffHunk": "@@ -0,0 +1,229 @@\n+import React from 'react';\n+import nock from 'nock';\n+import { shallow, mount } from 'enzyme';\n+import configureStore from 'redux-mock-store';\n+import merge from 'merge';\n+import viewHandler from '../../../../reducers/viewHandler';\n+import InlineTabWrapper from '../../../../components/widget/InlineTabWrapper';\n+import hotkeys from '../../../../../test_setup/fixtures/hotkeys.json';\n+import keymap from '../../../../../test_setup/fixtures/keymap.json';\n+import { ShortcutProvider } from '../../../../components/keyshortcuts/ShortcutProvider';\n+import { initialState as appHandlerState } from '../../../../reducers/appHandler';\n+import { initialState as windowHandlerState } from '../../../../reducers/windowHandler';\n+import tablesHandler from '../../../../reducers/tables';\n+import { Provider } from 'react-redux';\n+import props from '../../../../../test_setup/fixtures/widget/inlinetab/inline_tab_wrapper.json';\n+import tabData from '../../../../../test_setup/fixtures/widget/inlinetab/inline_tab_data.json';\n+import inlineTabStoreMore from '../../../../../test_setup/fixtures/widget/inlinetab/inline_tab_data_more.json';\n+import inlineTabStore from '../../../../../test_setup/fixtures/widget/inlinetab/inlineTabStore.json';\n+import addNewData from '../../../../../test_setup/fixtures/widget/inlinetab/addNewData.json';\n+import inlineTabInvalid from '../../../../../test_setup/fixtures/widget/inlinetab/inline_tab_invalid.json';\n+import thunk from 'redux-thunk';\n+const middlewares = [thunk];\n+\n+const mockStore = configureStore(middlewares);\n+\n+const createStore = function(state = {}) {\n+  const res = merge.recursive(\n+    true,\n+    {\n+      appHandler: {\n+        ...appHandlerState,\n+        me: { timeZone: 'America/Los_Angeles' },\n+      },\n+      windowHandler: { ...windowHandlerState },\n+      ...viewHandler,\n+      tables: { ...tablesHandler(undefined, {}) },\n+    },\n+    state\n+  );\n+\n+  return res;\n+};\n+\n+describe('InlineTabWrapper component', () => {\n+  describe('rendering tests:', () => {\n+    it('renders without errors', () => {\n+      shallow(<InlineTabWrapper {...props} />);\n+    });\n+\n+    it('renders a line properly', () => {\n+      const initialState = createStore({\n+        windowHandler: {\n+          allowShortcut: true,\n+          modal: {\n+            visible: true,\n+          },\n+          inlineTab: inlineTabStore,\n+        },\n+      });\n+      const store = mockStore(initialState);\n+\n+      nock(config.API_URL)\n+        .defaultReplyHeaders({ 'access-control-allow-origin': '*' })\n+        .get(`/window/123/2156425/AD_Tab-222/`)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72ae73b53cf0243bf5886ba2b8435dcabd6668d8"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg2NzEyOQ==", "bodyText": "If I am changing that with the values from the fixtures for some reason nock is giving these errors. So having bunch of errors would fill up the logs. It's a test, I am going to leave it hardcoded for now as I don't want to spend more time investigating why nock is trowing those errors in case I am using the ids from the fixture", "url": "https://github.com/metasfresh/metasfresh/pull/10301#discussion_r544867129", "createdAt": "2020-12-17T07:28:59Z", "author": {"login": "petrican"}, "path": "frontend/src/__tests__/components/widget/InlineTab/InlineTabWrapper.test.js", "diffHunk": "@@ -0,0 +1,229 @@\n+import React from 'react';\n+import nock from 'nock';\n+import { shallow, mount } from 'enzyme';\n+import configureStore from 'redux-mock-store';\n+import merge from 'merge';\n+import viewHandler from '../../../../reducers/viewHandler';\n+import InlineTabWrapper from '../../../../components/widget/InlineTabWrapper';\n+import hotkeys from '../../../../../test_setup/fixtures/hotkeys.json';\n+import keymap from '../../../../../test_setup/fixtures/keymap.json';\n+import { ShortcutProvider } from '../../../../components/keyshortcuts/ShortcutProvider';\n+import { initialState as appHandlerState } from '../../../../reducers/appHandler';\n+import { initialState as windowHandlerState } from '../../../../reducers/windowHandler';\n+import tablesHandler from '../../../../reducers/tables';\n+import { Provider } from 'react-redux';\n+import props from '../../../../../test_setup/fixtures/widget/inlinetab/inline_tab_wrapper.json';\n+import tabData from '../../../../../test_setup/fixtures/widget/inlinetab/inline_tab_data.json';\n+import inlineTabStoreMore from '../../../../../test_setup/fixtures/widget/inlinetab/inline_tab_data_more.json';\n+import inlineTabStore from '../../../../../test_setup/fixtures/widget/inlinetab/inlineTabStore.json';\n+import addNewData from '../../../../../test_setup/fixtures/widget/inlinetab/addNewData.json';\n+import inlineTabInvalid from '../../../../../test_setup/fixtures/widget/inlinetab/inline_tab_invalid.json';\n+import thunk from 'redux-thunk';\n+const middlewares = [thunk];\n+\n+const mockStore = configureStore(middlewares);\n+\n+const createStore = function(state = {}) {\n+  const res = merge.recursive(\n+    true,\n+    {\n+      appHandler: {\n+        ...appHandlerState,\n+        me: { timeZone: 'America/Los_Angeles' },\n+      },\n+      windowHandler: { ...windowHandlerState },\n+      ...viewHandler,\n+      tables: { ...tablesHandler(undefined, {}) },\n+    },\n+    state\n+  );\n+\n+  return res;\n+};\n+\n+describe('InlineTabWrapper component', () => {\n+  describe('rendering tests:', () => {\n+    it('renders without errors', () => {\n+      shallow(<InlineTabWrapper {...props} />);\n+    });\n+\n+    it('renders a line properly', () => {\n+      const initialState = createStore({\n+        windowHandler: {\n+          allowShortcut: true,\n+          modal: {\n+            visible: true,\n+          },\n+          inlineTab: inlineTabStore,\n+        },\n+      });\n+      const store = mockStore(initialState);\n+\n+      nock(config.API_URL)\n+        .defaultReplyHeaders({ 'access-control-allow-origin': '*' })\n+        .get(`/window/123/2156425/AD_Tab-222/`)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ4OTQ0OQ=="}, "originalCommit": {"oid": "72ae73b53cf0243bf5886ba2b8435dcabd6668d8"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNTAyNDgyOnYy", "diffSide": "RIGHT", "path": "frontend/src/__tests__/components/widget/InlineTab/InlineTabWrapper.test.js", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNjoyNDowMVrOIGUCMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNjoyNDowMVrOIGUCMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ5MDYwOQ==", "bodyText": "Same here. Otherwise whenever we'll use new fixtures these will fail for no real reason.", "url": "https://github.com/metasfresh/metasfresh/pull/10301#discussion_r543490609", "createdAt": "2020-12-15T16:24:01Z", "author": {"login": "siemiatj"}, "path": "frontend/src/__tests__/components/widget/InlineTab/InlineTabWrapper.test.js", "diffHunk": "@@ -0,0 +1,229 @@\n+import React from 'react';\n+import nock from 'nock';\n+import { shallow, mount } from 'enzyme';\n+import configureStore from 'redux-mock-store';\n+import merge from 'merge';\n+import viewHandler from '../../../../reducers/viewHandler';\n+import InlineTabWrapper from '../../../../components/widget/InlineTabWrapper';\n+import hotkeys from '../../../../../test_setup/fixtures/hotkeys.json';\n+import keymap from '../../../../../test_setup/fixtures/keymap.json';\n+import { ShortcutProvider } from '../../../../components/keyshortcuts/ShortcutProvider';\n+import { initialState as appHandlerState } from '../../../../reducers/appHandler';\n+import { initialState as windowHandlerState } from '../../../../reducers/windowHandler';\n+import tablesHandler from '../../../../reducers/tables';\n+import { Provider } from 'react-redux';\n+import props from '../../../../../test_setup/fixtures/widget/inlinetab/inline_tab_wrapper.json';\n+import tabData from '../../../../../test_setup/fixtures/widget/inlinetab/inline_tab_data.json';\n+import inlineTabStoreMore from '../../../../../test_setup/fixtures/widget/inlinetab/inline_tab_data_more.json';\n+import inlineTabStore from '../../../../../test_setup/fixtures/widget/inlinetab/inlineTabStore.json';\n+import addNewData from '../../../../../test_setup/fixtures/widget/inlinetab/addNewData.json';\n+import inlineTabInvalid from '../../../../../test_setup/fixtures/widget/inlinetab/inline_tab_invalid.json';\n+import thunk from 'redux-thunk';\n+const middlewares = [thunk];\n+\n+const mockStore = configureStore(middlewares);\n+\n+const createStore = function(state = {}) {\n+  const res = merge.recursive(\n+    true,\n+    {\n+      appHandler: {\n+        ...appHandlerState,\n+        me: { timeZone: 'America/Los_Angeles' },\n+      },\n+      windowHandler: { ...windowHandlerState },\n+      ...viewHandler,\n+      tables: { ...tablesHandler(undefined, {}) },\n+    },\n+    state\n+  );\n+\n+  return res;\n+};\n+\n+describe('InlineTabWrapper component', () => {\n+  describe('rendering tests:', () => {\n+    it('renders without errors', () => {\n+      shallow(<InlineTabWrapper {...props} />);\n+    });\n+\n+    it('renders a line properly', () => {\n+      const initialState = createStore({\n+        windowHandler: {\n+          allowShortcut: true,\n+          modal: {\n+            visible: true,\n+          },\n+          inlineTab: inlineTabStore,\n+        },\n+      });\n+      const store = mockStore(initialState);\n+\n+      nock(config.API_URL)\n+        .defaultReplyHeaders({ 'access-control-allow-origin': '*' })\n+        .get(`/window/123/2156425/AD_Tab-222/`)\n+        .reply(200, tabData);\n+\n+      const wrapper = mount(\n+        <ShortcutProvider hotkeys={hotkeys} keymap={keymap}>\n+          <Provider store={store}>\n+            <InlineTabWrapper {...props} />\n+          </Provider>\n+        </ShortcutProvider>\n+      );\n+      const htmlOutput = wrapper.html();\n+      expect(htmlOutput).toContain('<span>Testadresse 3</span');\n+      expect(htmlOutput).toContain('inlinetab-action-button');\n+      expect(htmlOutput).not.toContain('meta-icon-fullscreen');\n+    });\n+  });\n+\n+  it('renders more lines properly', () => {\n+    props.dataId = '2155894'; // we pass different docId such that will match the selector used for the mocked up data\n+    const initialState = createStore({\n+      windowHandler: {\n+        allowShortcut: true,\n+        modal: {\n+          visible: true,\n+        },\n+        inlineTab: inlineTabStoreMore,\n+      },\n+    });\n+    const store = mockStore(initialState);\n+\n+    nock(config.API_URL)\n+      .defaultReplyHeaders({ 'access-control-allow-origin': '*' })\n+      .get(`/window/123/2155894/AD_Tab-222/`)\n+      .reply(200, tabData);\n+\n+    const wrapper = mount(\n+      <ShortcutProvider hotkeys={hotkeys} keymap={keymap}>\n+        <Provider store={store}>\n+          <InlineTabWrapper {...props} />\n+        </Provider>\n+      </ShortcutProvider>\n+    );\n+    const htmlOutput = wrapper.html();\n+\n+    expect(htmlOutput).toContain('Amerikanische Jungferninseln');", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72ae73b53cf0243bf5886ba2b8435dcabd6668d8"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNTAzMzA5OnYy", "diffSide": "RIGHT", "path": "frontend/src/__tests__/components/widget/InlineTab/InlineTabWrapper.test.js", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNjoyNTozMlrOIGUHLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwNzozNzoyMVrOIHoTUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ5MTg4Ng==", "bodyText": "Maybe it's worth adding a test that tries adding something with the form too ? Then intercept the request, send back dummy response and see if all works ok ?", "url": "https://github.com/metasfresh/metasfresh/pull/10301#discussion_r543491886", "createdAt": "2020-12-15T16:25:32Z", "author": {"login": "siemiatj"}, "path": "frontend/src/__tests__/components/widget/InlineTab/InlineTabWrapper.test.js", "diffHunk": "@@ -0,0 +1,229 @@\n+import React from 'react';\n+import nock from 'nock';\n+import { shallow, mount } from 'enzyme';\n+import configureStore from 'redux-mock-store';\n+import merge from 'merge';\n+import viewHandler from '../../../../reducers/viewHandler';\n+import InlineTabWrapper from '../../../../components/widget/InlineTabWrapper';\n+import hotkeys from '../../../../../test_setup/fixtures/hotkeys.json';\n+import keymap from '../../../../../test_setup/fixtures/keymap.json';\n+import { ShortcutProvider } from '../../../../components/keyshortcuts/ShortcutProvider';\n+import { initialState as appHandlerState } from '../../../../reducers/appHandler';\n+import { initialState as windowHandlerState } from '../../../../reducers/windowHandler';\n+import tablesHandler from '../../../../reducers/tables';\n+import { Provider } from 'react-redux';\n+import props from '../../../../../test_setup/fixtures/widget/inlinetab/inline_tab_wrapper.json';\n+import tabData from '../../../../../test_setup/fixtures/widget/inlinetab/inline_tab_data.json';\n+import inlineTabStoreMore from '../../../../../test_setup/fixtures/widget/inlinetab/inline_tab_data_more.json';\n+import inlineTabStore from '../../../../../test_setup/fixtures/widget/inlinetab/inlineTabStore.json';\n+import addNewData from '../../../../../test_setup/fixtures/widget/inlinetab/addNewData.json';\n+import inlineTabInvalid from '../../../../../test_setup/fixtures/widget/inlinetab/inline_tab_invalid.json';\n+import thunk from 'redux-thunk';\n+const middlewares = [thunk];\n+\n+const mockStore = configureStore(middlewares);\n+\n+const createStore = function(state = {}) {\n+  const res = merge.recursive(\n+    true,\n+    {\n+      appHandler: {\n+        ...appHandlerState,\n+        me: { timeZone: 'America/Los_Angeles' },\n+      },\n+      windowHandler: { ...windowHandlerState },\n+      ...viewHandler,\n+      tables: { ...tablesHandler(undefined, {}) },\n+    },\n+    state\n+  );\n+\n+  return res;\n+};\n+\n+describe('InlineTabWrapper component', () => {\n+  describe('rendering tests:', () => {\n+    it('renders without errors', () => {\n+      shallow(<InlineTabWrapper {...props} />);\n+    });\n+\n+    it('renders a line properly', () => {\n+      const initialState = createStore({\n+        windowHandler: {\n+          allowShortcut: true,\n+          modal: {\n+            visible: true,\n+          },\n+          inlineTab: inlineTabStore,\n+        },\n+      });\n+      const store = mockStore(initialState);\n+\n+      nock(config.API_URL)\n+        .defaultReplyHeaders({ 'access-control-allow-origin': '*' })\n+        .get(`/window/123/2156425/AD_Tab-222/`)\n+        .reply(200, tabData);\n+\n+      const wrapper = mount(\n+        <ShortcutProvider hotkeys={hotkeys} keymap={keymap}>\n+          <Provider store={store}>\n+            <InlineTabWrapper {...props} />\n+          </Provider>\n+        </ShortcutProvider>\n+      );\n+      const htmlOutput = wrapper.html();\n+      expect(htmlOutput).toContain('<span>Testadresse 3</span');\n+      expect(htmlOutput).toContain('inlinetab-action-button');\n+      expect(htmlOutput).not.toContain('meta-icon-fullscreen');\n+    });\n+  });\n+\n+  it('renders more lines properly', () => {\n+    props.dataId = '2155894'; // we pass different docId such that will match the selector used for the mocked up data\n+    const initialState = createStore({\n+      windowHandler: {\n+        allowShortcut: true,\n+        modal: {\n+          visible: true,\n+        },\n+        inlineTab: inlineTabStoreMore,\n+      },\n+    });\n+    const store = mockStore(initialState);\n+\n+    nock(config.API_URL)\n+      .defaultReplyHeaders({ 'access-control-allow-origin': '*' })\n+      .get(`/window/123/2155894/AD_Tab-222/`)\n+      .reply(200, tabData);\n+\n+    const wrapper = mount(\n+      <ShortcutProvider hotkeys={hotkeys} keymap={keymap}>\n+        <Provider store={store}>\n+          <InlineTabWrapper {...props} />\n+        </Provider>\n+      </ShortcutProvider>\n+    );\n+    const htmlOutput = wrapper.html();\n+\n+    expect(htmlOutput).toContain('Amerikanische Jungferninseln');\n+    expect(htmlOutput).toContain('Amerikanisch-Samoa');\n+    expect(htmlOutput).toContain('Amerikanisch-Samoa (2)');\n+    expect(htmlOutput).toContain('Am Nossbacher Weg 2');\n+    expect(htmlOutput).toContain(\n+      'Antarktis (Sonderstatus durch Antarktis-Vertrag)'\n+    );\n+    expect(htmlOutput).not.toContain('Russland'); // only five rows shown - this should not be rendered\n+    expect(htmlOutput).toContain('meta-icon-fullscreen');\n+  });\n+\n+  it('renders the form in full screen correctly', () => {\n+    props.dataId = '2155894'; // we pass different docId such that will match the selector used for the mocked up data\n+    inlineTabStoreMore.showMore['123_AD_Tab-222_2155894'] = false;\n+    const initialState = createStore({\n+      windowHandler: {\n+        allowShortcut: true,\n+        modal: {\n+          visible: true,\n+        },\n+        inlineTab: inlineTabStoreMore,\n+      },\n+    });\n+    const store = mockStore(initialState);\n+\n+    nock(config.API_URL)\n+      .defaultReplyHeaders({ 'access-control-allow-origin': '*' })\n+      .get(`/window/123/2155894/AD_Tab-222/`)\n+      .reply(200, tabData);\n+\n+    const wrapper = mount(\n+      <ShortcutProvider hotkeys={hotkeys} keymap={keymap}>\n+        <Provider store={store}>\n+          <InlineTabWrapper {...props} />\n+        </Provider>\n+      </ShortcutProvider>\n+    );\n+    const htmlOutput = wrapper.html();\n+\n+    expect(htmlOutput).toContain('Amerikanische Jungferninseln');\n+    expect(htmlOutput).toContain('Amerikanisch-Samoa');\n+    expect(htmlOutput).toContain('Amerikanisch-Samoa (2)');\n+    expect(htmlOutput).toContain('Am Nossbacher Weg 2');\n+    expect(htmlOutput).toContain(\n+      'Antarktis (Sonderstatus durch Antarktis-Vertrag)'\n+    );\n+    expect(htmlOutput).toContain('Russland'); // all rows should be visible now, including this one\n+    expect(htmlOutput).toContain('meta-icon-fullscreen');\n+  });\n+\n+  it('renders the add new form', () => {\n+    props.dataId = '2155894'; // we pass different docId such that will match the selector used for the mocked up data\n+    // inlineTabStoreMore.showMore['123_AD_Tab-222_2155894'] = false;\n+    inlineTabStoreMore.addNew[`123_AD_Tab-222_2155894`] = {\n+      visible: true,\n+      windowId: '123',\n+      tabId: 'AD_Tab-222',\n+      rowId: '2205259',\n+    };\n+    inlineTabStoreMore[`123_AD_Tab-222_2205259`] = addNewData;\n+    const initialState = createStore({\n+      windowHandler: {\n+        allowShortcut: true,\n+        modal: {\n+          visible: true,\n+        },\n+        inlineTab: inlineTabStoreMore,\n+      },\n+    });\n+    const store = mockStore(initialState);\n+\n+    nock(config.API_URL)\n+      .defaultReplyHeaders({ 'access-control-allow-origin': '*' })\n+      .get(`/window/123/2155894/AD_Tab-222/`)\n+      .reply(200, tabData);\n+\n+    const wrapper = mount(\n+      <ShortcutProvider hotkeys={hotkeys} keymap={keymap}>\n+        <Provider store={store}>\n+          <InlineTabWrapper {...props} />\n+        </Provider>\n+      </ShortcutProvider>\n+    );\n+    const htmlOutput = wrapper.html();\n+\n+    expect(htmlOutput).toContain(\n+      `<div class=\"form-group form-field-BPartnerName\">`\n+    );\n+    expect(htmlOutput).toContain(`<i class=\"meta-icon-close-alt\">`);\n+  });\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72ae73b53cf0243bf5886ba2b8435dcabd6668d8"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg3MTI1MQ==", "bodyText": "That is beyond unit testing. That would be a functional test. Thinking that would be better to add a cypress test for the inlinetab widget. Going to open a mf15 for this", "url": "https://github.com/metasfresh/metasfresh/pull/10301#discussion_r544871251", "createdAt": "2020-12-17T07:37:21Z", "author": {"login": "petrican"}, "path": "frontend/src/__tests__/components/widget/InlineTab/InlineTabWrapper.test.js", "diffHunk": "@@ -0,0 +1,229 @@\n+import React from 'react';\n+import nock from 'nock';\n+import { shallow, mount } from 'enzyme';\n+import configureStore from 'redux-mock-store';\n+import merge from 'merge';\n+import viewHandler from '../../../../reducers/viewHandler';\n+import InlineTabWrapper from '../../../../components/widget/InlineTabWrapper';\n+import hotkeys from '../../../../../test_setup/fixtures/hotkeys.json';\n+import keymap from '../../../../../test_setup/fixtures/keymap.json';\n+import { ShortcutProvider } from '../../../../components/keyshortcuts/ShortcutProvider';\n+import { initialState as appHandlerState } from '../../../../reducers/appHandler';\n+import { initialState as windowHandlerState } from '../../../../reducers/windowHandler';\n+import tablesHandler from '../../../../reducers/tables';\n+import { Provider } from 'react-redux';\n+import props from '../../../../../test_setup/fixtures/widget/inlinetab/inline_tab_wrapper.json';\n+import tabData from '../../../../../test_setup/fixtures/widget/inlinetab/inline_tab_data.json';\n+import inlineTabStoreMore from '../../../../../test_setup/fixtures/widget/inlinetab/inline_tab_data_more.json';\n+import inlineTabStore from '../../../../../test_setup/fixtures/widget/inlinetab/inlineTabStore.json';\n+import addNewData from '../../../../../test_setup/fixtures/widget/inlinetab/addNewData.json';\n+import inlineTabInvalid from '../../../../../test_setup/fixtures/widget/inlinetab/inline_tab_invalid.json';\n+import thunk from 'redux-thunk';\n+const middlewares = [thunk];\n+\n+const mockStore = configureStore(middlewares);\n+\n+const createStore = function(state = {}) {\n+  const res = merge.recursive(\n+    true,\n+    {\n+      appHandler: {\n+        ...appHandlerState,\n+        me: { timeZone: 'America/Los_Angeles' },\n+      },\n+      windowHandler: { ...windowHandlerState },\n+      ...viewHandler,\n+      tables: { ...tablesHandler(undefined, {}) },\n+    },\n+    state\n+  );\n+\n+  return res;\n+};\n+\n+describe('InlineTabWrapper component', () => {\n+  describe('rendering tests:', () => {\n+    it('renders without errors', () => {\n+      shallow(<InlineTabWrapper {...props} />);\n+    });\n+\n+    it('renders a line properly', () => {\n+      const initialState = createStore({\n+        windowHandler: {\n+          allowShortcut: true,\n+          modal: {\n+            visible: true,\n+          },\n+          inlineTab: inlineTabStore,\n+        },\n+      });\n+      const store = mockStore(initialState);\n+\n+      nock(config.API_URL)\n+        .defaultReplyHeaders({ 'access-control-allow-origin': '*' })\n+        .get(`/window/123/2156425/AD_Tab-222/`)\n+        .reply(200, tabData);\n+\n+      const wrapper = mount(\n+        <ShortcutProvider hotkeys={hotkeys} keymap={keymap}>\n+          <Provider store={store}>\n+            <InlineTabWrapper {...props} />\n+          </Provider>\n+        </ShortcutProvider>\n+      );\n+      const htmlOutput = wrapper.html();\n+      expect(htmlOutput).toContain('<span>Testadresse 3</span');\n+      expect(htmlOutput).toContain('inlinetab-action-button');\n+      expect(htmlOutput).not.toContain('meta-icon-fullscreen');\n+    });\n+  });\n+\n+  it('renders more lines properly', () => {\n+    props.dataId = '2155894'; // we pass different docId such that will match the selector used for the mocked up data\n+    const initialState = createStore({\n+      windowHandler: {\n+        allowShortcut: true,\n+        modal: {\n+          visible: true,\n+        },\n+        inlineTab: inlineTabStoreMore,\n+      },\n+    });\n+    const store = mockStore(initialState);\n+\n+    nock(config.API_URL)\n+      .defaultReplyHeaders({ 'access-control-allow-origin': '*' })\n+      .get(`/window/123/2155894/AD_Tab-222/`)\n+      .reply(200, tabData);\n+\n+    const wrapper = mount(\n+      <ShortcutProvider hotkeys={hotkeys} keymap={keymap}>\n+        <Provider store={store}>\n+          <InlineTabWrapper {...props} />\n+        </Provider>\n+      </ShortcutProvider>\n+    );\n+    const htmlOutput = wrapper.html();\n+\n+    expect(htmlOutput).toContain('Amerikanische Jungferninseln');\n+    expect(htmlOutput).toContain('Amerikanisch-Samoa');\n+    expect(htmlOutput).toContain('Amerikanisch-Samoa (2)');\n+    expect(htmlOutput).toContain('Am Nossbacher Weg 2');\n+    expect(htmlOutput).toContain(\n+      'Antarktis (Sonderstatus durch Antarktis-Vertrag)'\n+    );\n+    expect(htmlOutput).not.toContain('Russland'); // only five rows shown - this should not be rendered\n+    expect(htmlOutput).toContain('meta-icon-fullscreen');\n+  });\n+\n+  it('renders the form in full screen correctly', () => {\n+    props.dataId = '2155894'; // we pass different docId such that will match the selector used for the mocked up data\n+    inlineTabStoreMore.showMore['123_AD_Tab-222_2155894'] = false;\n+    const initialState = createStore({\n+      windowHandler: {\n+        allowShortcut: true,\n+        modal: {\n+          visible: true,\n+        },\n+        inlineTab: inlineTabStoreMore,\n+      },\n+    });\n+    const store = mockStore(initialState);\n+\n+    nock(config.API_URL)\n+      .defaultReplyHeaders({ 'access-control-allow-origin': '*' })\n+      .get(`/window/123/2155894/AD_Tab-222/`)\n+      .reply(200, tabData);\n+\n+    const wrapper = mount(\n+      <ShortcutProvider hotkeys={hotkeys} keymap={keymap}>\n+        <Provider store={store}>\n+          <InlineTabWrapper {...props} />\n+        </Provider>\n+      </ShortcutProvider>\n+    );\n+    const htmlOutput = wrapper.html();\n+\n+    expect(htmlOutput).toContain('Amerikanische Jungferninseln');\n+    expect(htmlOutput).toContain('Amerikanisch-Samoa');\n+    expect(htmlOutput).toContain('Amerikanisch-Samoa (2)');\n+    expect(htmlOutput).toContain('Am Nossbacher Weg 2');\n+    expect(htmlOutput).toContain(\n+      'Antarktis (Sonderstatus durch Antarktis-Vertrag)'\n+    );\n+    expect(htmlOutput).toContain('Russland'); // all rows should be visible now, including this one\n+    expect(htmlOutput).toContain('meta-icon-fullscreen');\n+  });\n+\n+  it('renders the add new form', () => {\n+    props.dataId = '2155894'; // we pass different docId such that will match the selector used for the mocked up data\n+    // inlineTabStoreMore.showMore['123_AD_Tab-222_2155894'] = false;\n+    inlineTabStoreMore.addNew[`123_AD_Tab-222_2155894`] = {\n+      visible: true,\n+      windowId: '123',\n+      tabId: 'AD_Tab-222',\n+      rowId: '2205259',\n+    };\n+    inlineTabStoreMore[`123_AD_Tab-222_2205259`] = addNewData;\n+    const initialState = createStore({\n+      windowHandler: {\n+        allowShortcut: true,\n+        modal: {\n+          visible: true,\n+        },\n+        inlineTab: inlineTabStoreMore,\n+      },\n+    });\n+    const store = mockStore(initialState);\n+\n+    nock(config.API_URL)\n+      .defaultReplyHeaders({ 'access-control-allow-origin': '*' })\n+      .get(`/window/123/2155894/AD_Tab-222/`)\n+      .reply(200, tabData);\n+\n+    const wrapper = mount(\n+      <ShortcutProvider hotkeys={hotkeys} keymap={keymap}>\n+        <Provider store={store}>\n+          <InlineTabWrapper {...props} />\n+        </Provider>\n+      </ShortcutProvider>\n+    );\n+    const htmlOutput = wrapper.html();\n+\n+    expect(htmlOutput).toContain(\n+      `<div class=\"form-group form-field-BPartnerName\">`\n+    );\n+    expect(htmlOutput).toContain(`<i class=\"meta-icon-close-alt\">`);\n+  });\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ5MTg4Ng=="}, "originalCommit": {"oid": "72ae73b53cf0243bf5886ba2b8435dcabd6668d8"}, "originalPosition": 198}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNTA0NzYyOnYy", "diffSide": "RIGHT", "path": "frontend/src/actions/InlineTabActions.js", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNjoyODoyMFrOIGUP9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwODoyNDowMlrOIHp2Lg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ5NDEzMw==", "bodyText": "add docs", "url": "https://github.com/metasfresh/metasfresh/pull/10301#discussion_r543494133", "createdAt": "2020-12-15T16:28:20Z", "author": {"login": "siemiatj"}, "path": "frontend/src/actions/InlineTabActions.js", "diffHunk": "@@ -0,0 +1,223 @@\n+import { fetchTab } from './WindowActions';\n+import { getLayout, getData } from '../api';\n+import { INLINE_TAB_SHOW_MORE_FROM } from '../constants/Constants';\n+import {\n+  UPDATE_INLINE_TAB_ITEM_FIELDS,\n+  UPDATE_INLINE_TAB_WRAPPER_FIELDS,\n+  SET_INLINE_TAB_WRAPPER_DATA,\n+  SET_INLINE_TAB_LAYOUT_AND_DATA,\n+  SET_INLINE_TAB_ADD_NEW,\n+  SET_INLINE_TAB_SHOW_MORE,\n+} from '../constants/ActionTypes';\n+\n+/*\n+ * @method updateInlineTabItemFields\n+ * @summary Action creator for updating the fields for the `InlineTab` Item\n+ *\n+ * @param {string} inlineTabId\n+ * @param {string} rowId\n+ * @param {object} fieldsByName\n+ */\n+export function updateInlineTabItemFields({ inlineTabId, fieldsByName }) {\n+  return {\n+    type: UPDATE_INLINE_TAB_ITEM_FIELDS,\n+    payload: { inlineTabId, fieldsByName },\n+  };\n+}\n+\n+/*\n+ * @method updateInlineTabWrapperFields\n+ * @summary Action creator for updating the fields for the `InlineTab` Wrapper\n+ *\n+ * @param {string} inlineTabWrapperId\n+ * @param {string} rowId\n+ * @param {object} fieldsByName\n+ */\n+export function updateInlineTabWrapperFields({\n+  inlineTabWrapperId,\n+  rowId,\n+  response,\n+}) {\n+  return {\n+    type: UPDATE_INLINE_TAB_WRAPPER_FIELDS,\n+    payload: { inlineTabWrapperId, rowId, response },\n+  };\n+}\n+\n+/*\n+ * Action creator called to set the inlineTabWrapper branch in the redux store with the data payload\n+ */\n+export function setInlineTabWrapperData({ inlineTabWrapperId, data }) {\n+  return {\n+    type: SET_INLINE_TAB_WRAPPER_DATA,\n+    payload: { inlineTabWrapperId, data },\n+  };\n+}\n+\n+/*\n+ * Action creator called to set the showMore value for the corresponding inlineTabWrapperId\n+ */\n+export function setInlineTabShowMore({ inlineTabWrapperId, showMore }) {\n+  return {\n+    type: SET_INLINE_TAB_SHOW_MORE,\n+    payload: { inlineTabWrapperId, showMore },\n+  };\n+}\n+\n+/*\n+ * Action creator called to set the inlineTab branch in the redux store with the data payload\n+ */\n+export function setInlineTabLayoutAndData({ inlineTabId, data }) {\n+  return {\n+    type: SET_INLINE_TAB_LAYOUT_AND_DATA,\n+    payload: { inlineTabId, data },\n+  };\n+}\n+\n+/*\n+ * Action creator called to set the inlineTab AddNew form related data in the store, visible is for toggling the visibility\n+ */\n+export function setInlineTabAddNew({ visible, windowId, tabId, rowId, docId }) {\n+  return {\n+    type: SET_INLINE_TAB_ADD_NEW,\n+    payload: { visible, windowId, tabId, rowId, docId },\n+  };\n+}\n+\n+/*\n+ * @method fetchInlineTabWrapperData\n+ * @summary Action creator for fetching the data for the `InlineTab` Wrapper (note: wrapper not the inline tab item!)\n+ *\n+ * @param {string} windowId\n+ * @param {string} tabId\n+ * @param {string} docId\n+ * @param {string} query\n+ */\n+export function fetchInlineTabWrapperData({\n+  windowId,\n+  tabId,\n+  docId,\n+  query,\n+  rowId,\n+  postDeletion,\n+}) {\n+  return (dispatch) => {\n+    dispatch(fetchTab({ tabId, windowId, docId, query })).then((tabData) => {\n+      /** - if we have the rowId it means we have a new record addition, so we put that at the end of the array - only if this doesn't happen as a result of deletion */\n+      if (rowId && !postDeletion) {\n+        const lastAdditionIndex = tabData.findIndex(\n+          (item) => item.rowId === rowId\n+        );\n+        if (lastAdditionIndex) {\n+          const tempData = tabData[lastAdditionIndex];\n+          tabData.splice(lastAdditionIndex, 1);\n+          tabData.splice(tabData.length, 0, tempData);\n+        }\n+        dispatch(\n+          setInlineTabShowMore({\n+            inlineTabWrapperId: `${windowId}_${tabId}_${docId}`,\n+            showMore: false,\n+          })\n+        );\n+      }\n+\n+      dispatch(\n+        setInlineTabWrapperData({\n+          inlineTabWrapperId: `${windowId}_${tabId}_${docId}`,\n+          data: tabData,\n+        })\n+      );\n+      /** when we don't have the rowId then we are in the case of the normal rendering, we set the flag to show more (if criteria is met) */\n+      !rowId &&\n+        dispatch(\n+          setInlineTabShowMore({\n+            inlineTabWrapperId: `${windowId}_${tabId}_${docId}`,\n+            showMore: tabData.length > INLINE_TAB_SHOW_MORE_FROM ? true : false,\n+          })\n+        );\n+    });\n+  };\n+}\n+\n+/*\n+ * @method getInlineTabLayoutAndData\n+ * @summary Action creator for fetching and updating the layout and data for the `inlineTab`\n+ *\n+ * @param {string} windowId\n+ * @param {string} tabId\n+ * @param {string} docId\n+ * @param {string} rowId\n+ */\n+export function getInlineTabLayoutAndData({ windowId, tabId, docId, rowId }) {\n+  return (dispatch) => {\n+    getLayout('window', windowId, tabId, null, null, false).then(\n+      ({ data: layoutData }) => {\n+        getData({\n+          entity: 'window',\n+          docType: windowId,\n+          docId,\n+          tabId,\n+          fetchAdvancedFields: false,\n+        }).then(({ data: respFields }) => {\n+          const { result } = respFields;\n+          const wantedData = result.filter((item) => item.rowId === rowId);\n+          dispatch(\n+            setInlineTabLayoutAndData({\n+              inlineTabId: `${windowId}_${tabId}_${rowId}`,\n+              data: { layout: layoutData, data: wantedData[0] },\n+            })\n+          );\n+        });\n+      }\n+    );\n+  };\n+}\n+\n+/**\n+ * @method inlineTabAfterGetLayout\n+ * @summary triggers post layout fetch actions that will update the inline tab layout and data and the inlineTab addNew sub-branch\n+ * @param {object} data - the layout fetched previously with getLayout\n+ * @param {object} disconnectedData - result from initWindow (add new case for inlineTab) - see in the WindowActions what it contains (for debug)\n+ */\n+export function inlineTabAfterGetLayout({ data, disconnectedData }) {\n+  return (dispatch) => {\n+    const inlineTabTargetId = `${disconnectedData.windowId}_${\n+      disconnectedData.tabId\n+    }_${disconnectedData.rowId}`;\n+    dispatch(\n+      setInlineTabLayoutAndData({\n+        inlineTabId: inlineTabTargetId,\n+        data: { layout: data, data: disconnectedData },\n+      })\n+    );\n+    dispatch(\n+      setInlineTabAddNew({\n+        visible: true,\n+        docId: disconnectedData.id,\n+        windowId: disconnectedData.windowId,\n+        tabId: disconnectedData.tabId,\n+        rowId: disconnectedData.rowId,\n+      })\n+    );\n+  };\n+}\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72ae73b53cf0243bf5886ba2b8435dcabd6668d8"}, "originalPosition": 204}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg5NjU1OA==", "bodyText": "Done", "url": "https://github.com/metasfresh/metasfresh/pull/10301#discussion_r544896558", "createdAt": "2020-12-17T08:24:02Z", "author": {"login": "petrican"}, "path": "frontend/src/actions/InlineTabActions.js", "diffHunk": "@@ -0,0 +1,223 @@\n+import { fetchTab } from './WindowActions';\n+import { getLayout, getData } from '../api';\n+import { INLINE_TAB_SHOW_MORE_FROM } from '../constants/Constants';\n+import {\n+  UPDATE_INLINE_TAB_ITEM_FIELDS,\n+  UPDATE_INLINE_TAB_WRAPPER_FIELDS,\n+  SET_INLINE_TAB_WRAPPER_DATA,\n+  SET_INLINE_TAB_LAYOUT_AND_DATA,\n+  SET_INLINE_TAB_ADD_NEW,\n+  SET_INLINE_TAB_SHOW_MORE,\n+} from '../constants/ActionTypes';\n+\n+/*\n+ * @method updateInlineTabItemFields\n+ * @summary Action creator for updating the fields for the `InlineTab` Item\n+ *\n+ * @param {string} inlineTabId\n+ * @param {string} rowId\n+ * @param {object} fieldsByName\n+ */\n+export function updateInlineTabItemFields({ inlineTabId, fieldsByName }) {\n+  return {\n+    type: UPDATE_INLINE_TAB_ITEM_FIELDS,\n+    payload: { inlineTabId, fieldsByName },\n+  };\n+}\n+\n+/*\n+ * @method updateInlineTabWrapperFields\n+ * @summary Action creator for updating the fields for the `InlineTab` Wrapper\n+ *\n+ * @param {string} inlineTabWrapperId\n+ * @param {string} rowId\n+ * @param {object} fieldsByName\n+ */\n+export function updateInlineTabWrapperFields({\n+  inlineTabWrapperId,\n+  rowId,\n+  response,\n+}) {\n+  return {\n+    type: UPDATE_INLINE_TAB_WRAPPER_FIELDS,\n+    payload: { inlineTabWrapperId, rowId, response },\n+  };\n+}\n+\n+/*\n+ * Action creator called to set the inlineTabWrapper branch in the redux store with the data payload\n+ */\n+export function setInlineTabWrapperData({ inlineTabWrapperId, data }) {\n+  return {\n+    type: SET_INLINE_TAB_WRAPPER_DATA,\n+    payload: { inlineTabWrapperId, data },\n+  };\n+}\n+\n+/*\n+ * Action creator called to set the showMore value for the corresponding inlineTabWrapperId\n+ */\n+export function setInlineTabShowMore({ inlineTabWrapperId, showMore }) {\n+  return {\n+    type: SET_INLINE_TAB_SHOW_MORE,\n+    payload: { inlineTabWrapperId, showMore },\n+  };\n+}\n+\n+/*\n+ * Action creator called to set the inlineTab branch in the redux store with the data payload\n+ */\n+export function setInlineTabLayoutAndData({ inlineTabId, data }) {\n+  return {\n+    type: SET_INLINE_TAB_LAYOUT_AND_DATA,\n+    payload: { inlineTabId, data },\n+  };\n+}\n+\n+/*\n+ * Action creator called to set the inlineTab AddNew form related data in the store, visible is for toggling the visibility\n+ */\n+export function setInlineTabAddNew({ visible, windowId, tabId, rowId, docId }) {\n+  return {\n+    type: SET_INLINE_TAB_ADD_NEW,\n+    payload: { visible, windowId, tabId, rowId, docId },\n+  };\n+}\n+\n+/*\n+ * @method fetchInlineTabWrapperData\n+ * @summary Action creator for fetching the data for the `InlineTab` Wrapper (note: wrapper not the inline tab item!)\n+ *\n+ * @param {string} windowId\n+ * @param {string} tabId\n+ * @param {string} docId\n+ * @param {string} query\n+ */\n+export function fetchInlineTabWrapperData({\n+  windowId,\n+  tabId,\n+  docId,\n+  query,\n+  rowId,\n+  postDeletion,\n+}) {\n+  return (dispatch) => {\n+    dispatch(fetchTab({ tabId, windowId, docId, query })).then((tabData) => {\n+      /** - if we have the rowId it means we have a new record addition, so we put that at the end of the array - only if this doesn't happen as a result of deletion */\n+      if (rowId && !postDeletion) {\n+        const lastAdditionIndex = tabData.findIndex(\n+          (item) => item.rowId === rowId\n+        );\n+        if (lastAdditionIndex) {\n+          const tempData = tabData[lastAdditionIndex];\n+          tabData.splice(lastAdditionIndex, 1);\n+          tabData.splice(tabData.length, 0, tempData);\n+        }\n+        dispatch(\n+          setInlineTabShowMore({\n+            inlineTabWrapperId: `${windowId}_${tabId}_${docId}`,\n+            showMore: false,\n+          })\n+        );\n+      }\n+\n+      dispatch(\n+        setInlineTabWrapperData({\n+          inlineTabWrapperId: `${windowId}_${tabId}_${docId}`,\n+          data: tabData,\n+        })\n+      );\n+      /** when we don't have the rowId then we are in the case of the normal rendering, we set the flag to show more (if criteria is met) */\n+      !rowId &&\n+        dispatch(\n+          setInlineTabShowMore({\n+            inlineTabWrapperId: `${windowId}_${tabId}_${docId}`,\n+            showMore: tabData.length > INLINE_TAB_SHOW_MORE_FROM ? true : false,\n+          })\n+        );\n+    });\n+  };\n+}\n+\n+/*\n+ * @method getInlineTabLayoutAndData\n+ * @summary Action creator for fetching and updating the layout and data for the `inlineTab`\n+ *\n+ * @param {string} windowId\n+ * @param {string} tabId\n+ * @param {string} docId\n+ * @param {string} rowId\n+ */\n+export function getInlineTabLayoutAndData({ windowId, tabId, docId, rowId }) {\n+  return (dispatch) => {\n+    getLayout('window', windowId, tabId, null, null, false).then(\n+      ({ data: layoutData }) => {\n+        getData({\n+          entity: 'window',\n+          docType: windowId,\n+          docId,\n+          tabId,\n+          fetchAdvancedFields: false,\n+        }).then(({ data: respFields }) => {\n+          const { result } = respFields;\n+          const wantedData = result.filter((item) => item.rowId === rowId);\n+          dispatch(\n+            setInlineTabLayoutAndData({\n+              inlineTabId: `${windowId}_${tabId}_${rowId}`,\n+              data: { layout: layoutData, data: wantedData[0] },\n+            })\n+          );\n+        });\n+      }\n+    );\n+  };\n+}\n+\n+/**\n+ * @method inlineTabAfterGetLayout\n+ * @summary triggers post layout fetch actions that will update the inline tab layout and data and the inlineTab addNew sub-branch\n+ * @param {object} data - the layout fetched previously with getLayout\n+ * @param {object} disconnectedData - result from initWindow (add new case for inlineTab) - see in the WindowActions what it contains (for debug)\n+ */\n+export function inlineTabAfterGetLayout({ data, disconnectedData }) {\n+  return (dispatch) => {\n+    const inlineTabTargetId = `${disconnectedData.windowId}_${\n+      disconnectedData.tabId\n+    }_${disconnectedData.rowId}`;\n+    dispatch(\n+      setInlineTabLayoutAndData({\n+        inlineTabId: inlineTabTargetId,\n+        data: { layout: data, data: disconnectedData },\n+      })\n+    );\n+    dispatch(\n+      setInlineTabAddNew({\n+        visible: true,\n+        docId: disconnectedData.id,\n+        windowId: disconnectedData.windowId,\n+        tabId: disconnectedData.tabId,\n+        rowId: disconnectedData.rowId,\n+      })\n+    );\n+  };\n+}\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ5NDEzMw=="}, "originalCommit": {"oid": "72ae73b53cf0243bf5886ba2b8435dcabd6668d8"}, "originalPosition": 204}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNTI3OTk5OnYy", "diffSide": "RIGHT", "path": "frontend/src/actions/InlineTabActions.js", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNzoxMToyOFrOIGWYOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwNjoyOTowMFrOIHmlrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzUyOTAxNg==", "bodyText": "can this get a more meaningful name ? I think it's showing the add new form, right ?", "url": "https://github.com/metasfresh/metasfresh/pull/10301#discussion_r543529016", "createdAt": "2020-12-15T17:11:28Z", "author": {"login": "siemiatj"}, "path": "frontend/src/actions/InlineTabActions.js", "diffHunk": "@@ -0,0 +1,223 @@\n+import { fetchTab } from './WindowActions';\n+import { getLayout, getData } from '../api';\n+import { INLINE_TAB_SHOW_MORE_FROM } from '../constants/Constants';\n+import {\n+  UPDATE_INLINE_TAB_ITEM_FIELDS,\n+  UPDATE_INLINE_TAB_WRAPPER_FIELDS,\n+  SET_INLINE_TAB_WRAPPER_DATA,\n+  SET_INLINE_TAB_LAYOUT_AND_DATA,\n+  SET_INLINE_TAB_ADD_NEW,\n+  SET_INLINE_TAB_SHOW_MORE,\n+} from '../constants/ActionTypes';\n+\n+/*\n+ * @method updateInlineTabItemFields\n+ * @summary Action creator for updating the fields for the `InlineTab` Item\n+ *\n+ * @param {string} inlineTabId\n+ * @param {string} rowId\n+ * @param {object} fieldsByName\n+ */\n+export function updateInlineTabItemFields({ inlineTabId, fieldsByName }) {\n+  return {\n+    type: UPDATE_INLINE_TAB_ITEM_FIELDS,\n+    payload: { inlineTabId, fieldsByName },\n+  };\n+}\n+\n+/*\n+ * @method updateInlineTabWrapperFields\n+ * @summary Action creator for updating the fields for the `InlineTab` Wrapper\n+ *\n+ * @param {string} inlineTabWrapperId\n+ * @param {string} rowId\n+ * @param {object} fieldsByName\n+ */\n+export function updateInlineTabWrapperFields({\n+  inlineTabWrapperId,\n+  rowId,\n+  response,\n+}) {\n+  return {\n+    type: UPDATE_INLINE_TAB_WRAPPER_FIELDS,\n+    payload: { inlineTabWrapperId, rowId, response },\n+  };\n+}\n+\n+/*\n+ * Action creator called to set the inlineTabWrapper branch in the redux store with the data payload\n+ */\n+export function setInlineTabWrapperData({ inlineTabWrapperId, data }) {\n+  return {\n+    type: SET_INLINE_TAB_WRAPPER_DATA,\n+    payload: { inlineTabWrapperId, data },\n+  };\n+}\n+\n+/*\n+ * Action creator called to set the showMore value for the corresponding inlineTabWrapperId\n+ */\n+export function setInlineTabShowMore({ inlineTabWrapperId, showMore }) {\n+  return {\n+    type: SET_INLINE_TAB_SHOW_MORE,\n+    payload: { inlineTabWrapperId, showMore },\n+  };\n+}\n+\n+/*\n+ * Action creator called to set the inlineTab branch in the redux store with the data payload\n+ */\n+export function setInlineTabLayoutAndData({ inlineTabId, data }) {\n+  return {\n+    type: SET_INLINE_TAB_LAYOUT_AND_DATA,\n+    payload: { inlineTabId, data },\n+  };\n+}\n+\n+/*\n+ * Action creator called to set the inlineTab AddNew form related data in the store, visible is for toggling the visibility\n+ */\n+export function setInlineTabAddNew({ visible, windowId, tabId, rowId, docId }) {\n+  return {\n+    type: SET_INLINE_TAB_ADD_NEW,\n+    payload: { visible, windowId, tabId, rowId, docId },\n+  };\n+}\n+\n+/*\n+ * @method fetchInlineTabWrapperData\n+ * @summary Action creator for fetching the data for the `InlineTab` Wrapper (note: wrapper not the inline tab item!)\n+ *\n+ * @param {string} windowId\n+ * @param {string} tabId\n+ * @param {string} docId\n+ * @param {string} query\n+ */\n+export function fetchInlineTabWrapperData({\n+  windowId,\n+  tabId,\n+  docId,\n+  query,\n+  rowId,\n+  postDeletion,\n+}) {\n+  return (dispatch) => {\n+    dispatch(fetchTab({ tabId, windowId, docId, query })).then((tabData) => {\n+      /** - if we have the rowId it means we have a new record addition, so we put that at the end of the array - only if this doesn't happen as a result of deletion */\n+      if (rowId && !postDeletion) {\n+        const lastAdditionIndex = tabData.findIndex(\n+          (item) => item.rowId === rowId\n+        );\n+        if (lastAdditionIndex) {\n+          const tempData = tabData[lastAdditionIndex];\n+          tabData.splice(lastAdditionIndex, 1);\n+          tabData.splice(tabData.length, 0, tempData);\n+        }\n+        dispatch(\n+          setInlineTabShowMore({\n+            inlineTabWrapperId: `${windowId}_${tabId}_${docId}`,\n+            showMore: false,\n+          })\n+        );\n+      }\n+\n+      dispatch(\n+        setInlineTabWrapperData({\n+          inlineTabWrapperId: `${windowId}_${tabId}_${docId}`,\n+          data: tabData,\n+        })\n+      );\n+      /** when we don't have the rowId then we are in the case of the normal rendering, we set the flag to show more (if criteria is met) */\n+      !rowId &&\n+        dispatch(\n+          setInlineTabShowMore({\n+            inlineTabWrapperId: `${windowId}_${tabId}_${docId}`,\n+            showMore: tabData.length > INLINE_TAB_SHOW_MORE_FROM ? true : false,\n+          })\n+        );\n+    });\n+  };\n+}\n+\n+/*\n+ * @method getInlineTabLayoutAndData\n+ * @summary Action creator for fetching and updating the layout and data for the `inlineTab`\n+ *\n+ * @param {string} windowId\n+ * @param {string} tabId\n+ * @param {string} docId\n+ * @param {string} rowId\n+ */\n+export function getInlineTabLayoutAndData({ windowId, tabId, docId, rowId }) {\n+  return (dispatch) => {\n+    getLayout('window', windowId, tabId, null, null, false).then(\n+      ({ data: layoutData }) => {\n+        getData({\n+          entity: 'window',\n+          docType: windowId,\n+          docId,\n+          tabId,\n+          fetchAdvancedFields: false,\n+        }).then(({ data: respFields }) => {\n+          const { result } = respFields;\n+          const wantedData = result.filter((item) => item.rowId === rowId);\n+          dispatch(\n+            setInlineTabLayoutAndData({\n+              inlineTabId: `${windowId}_${tabId}_${rowId}`,\n+              data: { layout: layoutData, data: wantedData[0] },\n+            })\n+          );\n+        });\n+      }\n+    );\n+  };\n+}\n+\n+/**\n+ * @method inlineTabAfterGetLayout\n+ * @summary triggers post layout fetch actions that will update the inline tab layout and data and the inlineTab addNew sub-branch\n+ * @param {object} data - the layout fetched previously with getLayout\n+ * @param {object} disconnectedData - result from initWindow (add new case for inlineTab) - see in the WindowActions what it contains (for debug)\n+ */\n+export function inlineTabAfterGetLayout({ data, disconnectedData }) {\n+  return (dispatch) => {\n+    const inlineTabTargetId = `${disconnectedData.windowId}_${\n+      disconnectedData.tabId\n+    }_${disconnectedData.rowId}`;\n+    dispatch(\n+      setInlineTabLayoutAndData({\n+        inlineTabId: inlineTabTargetId,\n+        data: { layout: data, data: disconnectedData },\n+      })\n+    );\n+    dispatch(\n+      setInlineTabAddNew({", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72ae73b53cf0243bf5886ba2b8435dcabd6668d8"}, "originalPosition": 194}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg0MzE4MA==", "bodyText": "it sets in the inlineTab structure the addNew branch", "url": "https://github.com/metasfresh/metasfresh/pull/10301#discussion_r544843180", "createdAt": "2020-12-17T06:29:00Z", "author": {"login": "petrican"}, "path": "frontend/src/actions/InlineTabActions.js", "diffHunk": "@@ -0,0 +1,223 @@\n+import { fetchTab } from './WindowActions';\n+import { getLayout, getData } from '../api';\n+import { INLINE_TAB_SHOW_MORE_FROM } from '../constants/Constants';\n+import {\n+  UPDATE_INLINE_TAB_ITEM_FIELDS,\n+  UPDATE_INLINE_TAB_WRAPPER_FIELDS,\n+  SET_INLINE_TAB_WRAPPER_DATA,\n+  SET_INLINE_TAB_LAYOUT_AND_DATA,\n+  SET_INLINE_TAB_ADD_NEW,\n+  SET_INLINE_TAB_SHOW_MORE,\n+} from '../constants/ActionTypes';\n+\n+/*\n+ * @method updateInlineTabItemFields\n+ * @summary Action creator for updating the fields for the `InlineTab` Item\n+ *\n+ * @param {string} inlineTabId\n+ * @param {string} rowId\n+ * @param {object} fieldsByName\n+ */\n+export function updateInlineTabItemFields({ inlineTabId, fieldsByName }) {\n+  return {\n+    type: UPDATE_INLINE_TAB_ITEM_FIELDS,\n+    payload: { inlineTabId, fieldsByName },\n+  };\n+}\n+\n+/*\n+ * @method updateInlineTabWrapperFields\n+ * @summary Action creator for updating the fields for the `InlineTab` Wrapper\n+ *\n+ * @param {string} inlineTabWrapperId\n+ * @param {string} rowId\n+ * @param {object} fieldsByName\n+ */\n+export function updateInlineTabWrapperFields({\n+  inlineTabWrapperId,\n+  rowId,\n+  response,\n+}) {\n+  return {\n+    type: UPDATE_INLINE_TAB_WRAPPER_FIELDS,\n+    payload: { inlineTabWrapperId, rowId, response },\n+  };\n+}\n+\n+/*\n+ * Action creator called to set the inlineTabWrapper branch in the redux store with the data payload\n+ */\n+export function setInlineTabWrapperData({ inlineTabWrapperId, data }) {\n+  return {\n+    type: SET_INLINE_TAB_WRAPPER_DATA,\n+    payload: { inlineTabWrapperId, data },\n+  };\n+}\n+\n+/*\n+ * Action creator called to set the showMore value for the corresponding inlineTabWrapperId\n+ */\n+export function setInlineTabShowMore({ inlineTabWrapperId, showMore }) {\n+  return {\n+    type: SET_INLINE_TAB_SHOW_MORE,\n+    payload: { inlineTabWrapperId, showMore },\n+  };\n+}\n+\n+/*\n+ * Action creator called to set the inlineTab branch in the redux store with the data payload\n+ */\n+export function setInlineTabLayoutAndData({ inlineTabId, data }) {\n+  return {\n+    type: SET_INLINE_TAB_LAYOUT_AND_DATA,\n+    payload: { inlineTabId, data },\n+  };\n+}\n+\n+/*\n+ * Action creator called to set the inlineTab AddNew form related data in the store, visible is for toggling the visibility\n+ */\n+export function setInlineTabAddNew({ visible, windowId, tabId, rowId, docId }) {\n+  return {\n+    type: SET_INLINE_TAB_ADD_NEW,\n+    payload: { visible, windowId, tabId, rowId, docId },\n+  };\n+}\n+\n+/*\n+ * @method fetchInlineTabWrapperData\n+ * @summary Action creator for fetching the data for the `InlineTab` Wrapper (note: wrapper not the inline tab item!)\n+ *\n+ * @param {string} windowId\n+ * @param {string} tabId\n+ * @param {string} docId\n+ * @param {string} query\n+ */\n+export function fetchInlineTabWrapperData({\n+  windowId,\n+  tabId,\n+  docId,\n+  query,\n+  rowId,\n+  postDeletion,\n+}) {\n+  return (dispatch) => {\n+    dispatch(fetchTab({ tabId, windowId, docId, query })).then((tabData) => {\n+      /** - if we have the rowId it means we have a new record addition, so we put that at the end of the array - only if this doesn't happen as a result of deletion */\n+      if (rowId && !postDeletion) {\n+        const lastAdditionIndex = tabData.findIndex(\n+          (item) => item.rowId === rowId\n+        );\n+        if (lastAdditionIndex) {\n+          const tempData = tabData[lastAdditionIndex];\n+          tabData.splice(lastAdditionIndex, 1);\n+          tabData.splice(tabData.length, 0, tempData);\n+        }\n+        dispatch(\n+          setInlineTabShowMore({\n+            inlineTabWrapperId: `${windowId}_${tabId}_${docId}`,\n+            showMore: false,\n+          })\n+        );\n+      }\n+\n+      dispatch(\n+        setInlineTabWrapperData({\n+          inlineTabWrapperId: `${windowId}_${tabId}_${docId}`,\n+          data: tabData,\n+        })\n+      );\n+      /** when we don't have the rowId then we are in the case of the normal rendering, we set the flag to show more (if criteria is met) */\n+      !rowId &&\n+        dispatch(\n+          setInlineTabShowMore({\n+            inlineTabWrapperId: `${windowId}_${tabId}_${docId}`,\n+            showMore: tabData.length > INLINE_TAB_SHOW_MORE_FROM ? true : false,\n+          })\n+        );\n+    });\n+  };\n+}\n+\n+/*\n+ * @method getInlineTabLayoutAndData\n+ * @summary Action creator for fetching and updating the layout and data for the `inlineTab`\n+ *\n+ * @param {string} windowId\n+ * @param {string} tabId\n+ * @param {string} docId\n+ * @param {string} rowId\n+ */\n+export function getInlineTabLayoutAndData({ windowId, tabId, docId, rowId }) {\n+  return (dispatch) => {\n+    getLayout('window', windowId, tabId, null, null, false).then(\n+      ({ data: layoutData }) => {\n+        getData({\n+          entity: 'window',\n+          docType: windowId,\n+          docId,\n+          tabId,\n+          fetchAdvancedFields: false,\n+        }).then(({ data: respFields }) => {\n+          const { result } = respFields;\n+          const wantedData = result.filter((item) => item.rowId === rowId);\n+          dispatch(\n+            setInlineTabLayoutAndData({\n+              inlineTabId: `${windowId}_${tabId}_${rowId}`,\n+              data: { layout: layoutData, data: wantedData[0] },\n+            })\n+          );\n+        });\n+      }\n+    );\n+  };\n+}\n+\n+/**\n+ * @method inlineTabAfterGetLayout\n+ * @summary triggers post layout fetch actions that will update the inline tab layout and data and the inlineTab addNew sub-branch\n+ * @param {object} data - the layout fetched previously with getLayout\n+ * @param {object} disconnectedData - result from initWindow (add new case for inlineTab) - see in the WindowActions what it contains (for debug)\n+ */\n+export function inlineTabAfterGetLayout({ data, disconnectedData }) {\n+  return (dispatch) => {\n+    const inlineTabTargetId = `${disconnectedData.windowId}_${\n+      disconnectedData.tabId\n+    }_${disconnectedData.rowId}`;\n+    dispatch(\n+      setInlineTabLayoutAndData({\n+        inlineTabId: inlineTabTargetId,\n+        data: { layout: data, data: disconnectedData },\n+      })\n+    );\n+    dispatch(\n+      setInlineTabAddNew({", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzUyOTAxNg=="}, "originalCommit": {"oid": "72ae73b53cf0243bf5886ba2b8435dcabd6668d8"}, "originalPosition": 194}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNTI4NjA0OnYy", "diffSide": "RIGHT", "path": "frontend/src/actions/InlineTabActions.js", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNzoxMjo0NFrOIGWb4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwNjoyNzowNVrOIHmjAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzUyOTk1NA==", "bodyText": "This name also doesn't say much. It's not only passing layout but also rows data, so something like updateInlineTab would make more sense.", "url": "https://github.com/metasfresh/metasfresh/pull/10301#discussion_r543529954", "createdAt": "2020-12-15T17:12:44Z", "author": {"login": "siemiatj"}, "path": "frontend/src/actions/InlineTabActions.js", "diffHunk": "@@ -0,0 +1,223 @@\n+import { fetchTab } from './WindowActions';\n+import { getLayout, getData } from '../api';\n+import { INLINE_TAB_SHOW_MORE_FROM } from '../constants/Constants';\n+import {\n+  UPDATE_INLINE_TAB_ITEM_FIELDS,\n+  UPDATE_INLINE_TAB_WRAPPER_FIELDS,\n+  SET_INLINE_TAB_WRAPPER_DATA,\n+  SET_INLINE_TAB_LAYOUT_AND_DATA,\n+  SET_INLINE_TAB_ADD_NEW,\n+  SET_INLINE_TAB_SHOW_MORE,\n+} from '../constants/ActionTypes';\n+\n+/*\n+ * @method updateInlineTabItemFields\n+ * @summary Action creator for updating the fields for the `InlineTab` Item\n+ *\n+ * @param {string} inlineTabId\n+ * @param {string} rowId\n+ * @param {object} fieldsByName\n+ */\n+export function updateInlineTabItemFields({ inlineTabId, fieldsByName }) {\n+  return {\n+    type: UPDATE_INLINE_TAB_ITEM_FIELDS,\n+    payload: { inlineTabId, fieldsByName },\n+  };\n+}\n+\n+/*\n+ * @method updateInlineTabWrapperFields\n+ * @summary Action creator for updating the fields for the `InlineTab` Wrapper\n+ *\n+ * @param {string} inlineTabWrapperId\n+ * @param {string} rowId\n+ * @param {object} fieldsByName\n+ */\n+export function updateInlineTabWrapperFields({\n+  inlineTabWrapperId,\n+  rowId,\n+  response,\n+}) {\n+  return {\n+    type: UPDATE_INLINE_TAB_WRAPPER_FIELDS,\n+    payload: { inlineTabWrapperId, rowId, response },\n+  };\n+}\n+\n+/*\n+ * Action creator called to set the inlineTabWrapper branch in the redux store with the data payload\n+ */\n+export function setInlineTabWrapperData({ inlineTabWrapperId, data }) {\n+  return {\n+    type: SET_INLINE_TAB_WRAPPER_DATA,\n+    payload: { inlineTabWrapperId, data },\n+  };\n+}\n+\n+/*\n+ * Action creator called to set the showMore value for the corresponding inlineTabWrapperId\n+ */\n+export function setInlineTabShowMore({ inlineTabWrapperId, showMore }) {\n+  return {\n+    type: SET_INLINE_TAB_SHOW_MORE,\n+    payload: { inlineTabWrapperId, showMore },\n+  };\n+}\n+\n+/*\n+ * Action creator called to set the inlineTab branch in the redux store with the data payload\n+ */\n+export function setInlineTabLayoutAndData({ inlineTabId, data }) {\n+  return {\n+    type: SET_INLINE_TAB_LAYOUT_AND_DATA,\n+    payload: { inlineTabId, data },\n+  };\n+}\n+\n+/*\n+ * Action creator called to set the inlineTab AddNew form related data in the store, visible is for toggling the visibility\n+ */\n+export function setInlineTabAddNew({ visible, windowId, tabId, rowId, docId }) {\n+  return {\n+    type: SET_INLINE_TAB_ADD_NEW,\n+    payload: { visible, windowId, tabId, rowId, docId },\n+  };\n+}\n+\n+/*\n+ * @method fetchInlineTabWrapperData\n+ * @summary Action creator for fetching the data for the `InlineTab` Wrapper (note: wrapper not the inline tab item!)\n+ *\n+ * @param {string} windowId\n+ * @param {string} tabId\n+ * @param {string} docId\n+ * @param {string} query\n+ */\n+export function fetchInlineTabWrapperData({\n+  windowId,\n+  tabId,\n+  docId,\n+  query,\n+  rowId,\n+  postDeletion,\n+}) {\n+  return (dispatch) => {\n+    dispatch(fetchTab({ tabId, windowId, docId, query })).then((tabData) => {\n+      /** - if we have the rowId it means we have a new record addition, so we put that at the end of the array - only if this doesn't happen as a result of deletion */\n+      if (rowId && !postDeletion) {\n+        const lastAdditionIndex = tabData.findIndex(\n+          (item) => item.rowId === rowId\n+        );\n+        if (lastAdditionIndex) {\n+          const tempData = tabData[lastAdditionIndex];\n+          tabData.splice(lastAdditionIndex, 1);\n+          tabData.splice(tabData.length, 0, tempData);\n+        }\n+        dispatch(\n+          setInlineTabShowMore({\n+            inlineTabWrapperId: `${windowId}_${tabId}_${docId}`,\n+            showMore: false,\n+          })\n+        );\n+      }\n+\n+      dispatch(\n+        setInlineTabWrapperData({\n+          inlineTabWrapperId: `${windowId}_${tabId}_${docId}`,\n+          data: tabData,\n+        })\n+      );\n+      /** when we don't have the rowId then we are in the case of the normal rendering, we set the flag to show more (if criteria is met) */\n+      !rowId &&\n+        dispatch(\n+          setInlineTabShowMore({\n+            inlineTabWrapperId: `${windowId}_${tabId}_${docId}`,\n+            showMore: tabData.length > INLINE_TAB_SHOW_MORE_FROM ? true : false,\n+          })\n+        );\n+    });\n+  };\n+}\n+\n+/*\n+ * @method getInlineTabLayoutAndData\n+ * @summary Action creator for fetching and updating the layout and data for the `inlineTab`\n+ *\n+ * @param {string} windowId\n+ * @param {string} tabId\n+ * @param {string} docId\n+ * @param {string} rowId\n+ */\n+export function getInlineTabLayoutAndData({ windowId, tabId, docId, rowId }) {\n+  return (dispatch) => {\n+    getLayout('window', windowId, tabId, null, null, false).then(\n+      ({ data: layoutData }) => {\n+        getData({\n+          entity: 'window',\n+          docType: windowId,\n+          docId,\n+          tabId,\n+          fetchAdvancedFields: false,\n+        }).then(({ data: respFields }) => {\n+          const { result } = respFields;\n+          const wantedData = result.filter((item) => item.rowId === rowId);\n+          dispatch(\n+            setInlineTabLayoutAndData({\n+              inlineTabId: `${windowId}_${tabId}_${rowId}`,\n+              data: { layout: layoutData, data: wantedData[0] },\n+            })\n+          );\n+        });\n+      }\n+    );\n+  };\n+}\n+\n+/**\n+ * @method inlineTabAfterGetLayout\n+ * @summary triggers post layout fetch actions that will update the inline tab layout and data and the inlineTab addNew sub-branch\n+ * @param {object} data - the layout fetched previously with getLayout\n+ * @param {object} disconnectedData - result from initWindow (add new case for inlineTab) - see in the WindowActions what it contains (for debug)\n+ */\n+export function inlineTabAfterGetLayout({ data, disconnectedData }) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72ae73b53cf0243bf5886ba2b8435dcabd6668d8"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg0MjQ5Nw==", "bodyText": "This is refreshing the inlineTab after the Get Layout action happen( it is a post get layout action). Named like that to see it also in code what it does.", "url": "https://github.com/metasfresh/metasfresh/pull/10301#discussion_r544842497", "createdAt": "2020-12-17T06:27:05Z", "author": {"login": "petrican"}, "path": "frontend/src/actions/InlineTabActions.js", "diffHunk": "@@ -0,0 +1,223 @@\n+import { fetchTab } from './WindowActions';\n+import { getLayout, getData } from '../api';\n+import { INLINE_TAB_SHOW_MORE_FROM } from '../constants/Constants';\n+import {\n+  UPDATE_INLINE_TAB_ITEM_FIELDS,\n+  UPDATE_INLINE_TAB_WRAPPER_FIELDS,\n+  SET_INLINE_TAB_WRAPPER_DATA,\n+  SET_INLINE_TAB_LAYOUT_AND_DATA,\n+  SET_INLINE_TAB_ADD_NEW,\n+  SET_INLINE_TAB_SHOW_MORE,\n+} from '../constants/ActionTypes';\n+\n+/*\n+ * @method updateInlineTabItemFields\n+ * @summary Action creator for updating the fields for the `InlineTab` Item\n+ *\n+ * @param {string} inlineTabId\n+ * @param {string} rowId\n+ * @param {object} fieldsByName\n+ */\n+export function updateInlineTabItemFields({ inlineTabId, fieldsByName }) {\n+  return {\n+    type: UPDATE_INLINE_TAB_ITEM_FIELDS,\n+    payload: { inlineTabId, fieldsByName },\n+  };\n+}\n+\n+/*\n+ * @method updateInlineTabWrapperFields\n+ * @summary Action creator for updating the fields for the `InlineTab` Wrapper\n+ *\n+ * @param {string} inlineTabWrapperId\n+ * @param {string} rowId\n+ * @param {object} fieldsByName\n+ */\n+export function updateInlineTabWrapperFields({\n+  inlineTabWrapperId,\n+  rowId,\n+  response,\n+}) {\n+  return {\n+    type: UPDATE_INLINE_TAB_WRAPPER_FIELDS,\n+    payload: { inlineTabWrapperId, rowId, response },\n+  };\n+}\n+\n+/*\n+ * Action creator called to set the inlineTabWrapper branch in the redux store with the data payload\n+ */\n+export function setInlineTabWrapperData({ inlineTabWrapperId, data }) {\n+  return {\n+    type: SET_INLINE_TAB_WRAPPER_DATA,\n+    payload: { inlineTabWrapperId, data },\n+  };\n+}\n+\n+/*\n+ * Action creator called to set the showMore value for the corresponding inlineTabWrapperId\n+ */\n+export function setInlineTabShowMore({ inlineTabWrapperId, showMore }) {\n+  return {\n+    type: SET_INLINE_TAB_SHOW_MORE,\n+    payload: { inlineTabWrapperId, showMore },\n+  };\n+}\n+\n+/*\n+ * Action creator called to set the inlineTab branch in the redux store with the data payload\n+ */\n+export function setInlineTabLayoutAndData({ inlineTabId, data }) {\n+  return {\n+    type: SET_INLINE_TAB_LAYOUT_AND_DATA,\n+    payload: { inlineTabId, data },\n+  };\n+}\n+\n+/*\n+ * Action creator called to set the inlineTab AddNew form related data in the store, visible is for toggling the visibility\n+ */\n+export function setInlineTabAddNew({ visible, windowId, tabId, rowId, docId }) {\n+  return {\n+    type: SET_INLINE_TAB_ADD_NEW,\n+    payload: { visible, windowId, tabId, rowId, docId },\n+  };\n+}\n+\n+/*\n+ * @method fetchInlineTabWrapperData\n+ * @summary Action creator for fetching the data for the `InlineTab` Wrapper (note: wrapper not the inline tab item!)\n+ *\n+ * @param {string} windowId\n+ * @param {string} tabId\n+ * @param {string} docId\n+ * @param {string} query\n+ */\n+export function fetchInlineTabWrapperData({\n+  windowId,\n+  tabId,\n+  docId,\n+  query,\n+  rowId,\n+  postDeletion,\n+}) {\n+  return (dispatch) => {\n+    dispatch(fetchTab({ tabId, windowId, docId, query })).then((tabData) => {\n+      /** - if we have the rowId it means we have a new record addition, so we put that at the end of the array - only if this doesn't happen as a result of deletion */\n+      if (rowId && !postDeletion) {\n+        const lastAdditionIndex = tabData.findIndex(\n+          (item) => item.rowId === rowId\n+        );\n+        if (lastAdditionIndex) {\n+          const tempData = tabData[lastAdditionIndex];\n+          tabData.splice(lastAdditionIndex, 1);\n+          tabData.splice(tabData.length, 0, tempData);\n+        }\n+        dispatch(\n+          setInlineTabShowMore({\n+            inlineTabWrapperId: `${windowId}_${tabId}_${docId}`,\n+            showMore: false,\n+          })\n+        );\n+      }\n+\n+      dispatch(\n+        setInlineTabWrapperData({\n+          inlineTabWrapperId: `${windowId}_${tabId}_${docId}`,\n+          data: tabData,\n+        })\n+      );\n+      /** when we don't have the rowId then we are in the case of the normal rendering, we set the flag to show more (if criteria is met) */\n+      !rowId &&\n+        dispatch(\n+          setInlineTabShowMore({\n+            inlineTabWrapperId: `${windowId}_${tabId}_${docId}`,\n+            showMore: tabData.length > INLINE_TAB_SHOW_MORE_FROM ? true : false,\n+          })\n+        );\n+    });\n+  };\n+}\n+\n+/*\n+ * @method getInlineTabLayoutAndData\n+ * @summary Action creator for fetching and updating the layout and data for the `inlineTab`\n+ *\n+ * @param {string} windowId\n+ * @param {string} tabId\n+ * @param {string} docId\n+ * @param {string} rowId\n+ */\n+export function getInlineTabLayoutAndData({ windowId, tabId, docId, rowId }) {\n+  return (dispatch) => {\n+    getLayout('window', windowId, tabId, null, null, false).then(\n+      ({ data: layoutData }) => {\n+        getData({\n+          entity: 'window',\n+          docType: windowId,\n+          docId,\n+          tabId,\n+          fetchAdvancedFields: false,\n+        }).then(({ data: respFields }) => {\n+          const { result } = respFields;\n+          const wantedData = result.filter((item) => item.rowId === rowId);\n+          dispatch(\n+            setInlineTabLayoutAndData({\n+              inlineTabId: `${windowId}_${tabId}_${rowId}`,\n+              data: { layout: layoutData, data: wantedData[0] },\n+            })\n+          );\n+        });\n+      }\n+    );\n+  };\n+}\n+\n+/**\n+ * @method inlineTabAfterGetLayout\n+ * @summary triggers post layout fetch actions that will update the inline tab layout and data and the inlineTab addNew sub-branch\n+ * @param {object} data - the layout fetched previously with getLayout\n+ * @param {object} disconnectedData - result from initWindow (add new case for inlineTab) - see in the WindowActions what it contains (for debug)\n+ */\n+export function inlineTabAfterGetLayout({ data, disconnectedData }) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzUyOTk1NA=="}, "originalCommit": {"oid": "72ae73b53cf0243bf5886ba2b8435dcabd6668d8"}, "originalPosition": 182}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNTU3Mjk2OnYy", "diffSide": "RIGHT", "path": "frontend/src/components/widget/RawWidget.js", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxODoxMjo0MlrOIGZGxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwODo0MTozNFrOIHqfWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU3MzcwMw==", "bodyText": "Did we change the structure for Switch widgets ?", "url": "https://github.com/metasfresh/metasfresh/pull/10301#discussion_r543573703", "createdAt": "2020-12-15T18:12:42Z", "author": {"login": "siemiatj"}, "path": "frontend/src/components/widget/RawWidget.js", "diffHunk": "@@ -412,9 +413,11 @@ export class RawWidget extends PureComponent {\n     }\n \n     // TODO: API SHOULD RETURN THE SAME PROPERTIES FOR FILTERS\n-    const widgetField = filterWidget\n-      ? fields[0].parameterName\n-      : fields[0].field;\n+    let widgetField = filterWidget ? fields[0].parameterName : fields[0].field;\n+    if (!widgetField && this.props.widgetType === 'Switch') {\n+      widgetField = fields[0].fields[0].field;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72ae73b53cf0243bf5886ba2b8435dcabd6668d8"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDkwNzA5OA==", "bodyText": "Nope. It's just a safety check", "url": "https://github.com/metasfresh/metasfresh/pull/10301#discussion_r544907098", "createdAt": "2020-12-17T08:41:34Z", "author": {"login": "petrican"}, "path": "frontend/src/components/widget/RawWidget.js", "diffHunk": "@@ -412,9 +413,11 @@ export class RawWidget extends PureComponent {\n     }\n \n     // TODO: API SHOULD RETURN THE SAME PROPERTIES FOR FILTERS\n-    const widgetField = filterWidget\n-      ? fields[0].parameterName\n-      : fields[0].field;\n+    let widgetField = filterWidget ? fields[0].parameterName : fields[0].field;\n+    if (!widgetField && this.props.widgetType === 'Switch') {\n+      widgetField = fields[0].fields[0].field;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU3MzcwMw=="}, "originalCommit": {"oid": "72ae73b53cf0243bf5886ba2b8435dcabd6668d8"}, "originalPosition": 17}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1165, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}