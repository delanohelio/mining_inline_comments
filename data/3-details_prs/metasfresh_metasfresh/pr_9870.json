{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc2Mjk1MzMz", "number": 9870, "title": "9853 filters refactoring", "bodyText": "Related to #9853", "createdAt": "2020-08-31T13:21:44Z", "url": "https://github.com/metasfresh/metasfresh/pull/9870", "merged": true, "mergeCommit": {"oid": "6d547d8237186ebeb0c19fb392642ae25ab95009"}, "closed": true, "closedAt": "2020-10-07T11:15:39Z", "author": {"login": "petrican"}, "timelineItems": {"totalCount": 106, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdQG5rLgH2gAyNDc2Mjk1MzMzOmU3MmY1MDgzYTAzMDFmNmQ3MTJlNTZmZTIxMTAyMzQ5NzRmOGFjZDQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdQK1PxAH2gAyNDc2Mjk1MzMzOjc4MzQ0NGQ5NmMzMjg1MDNmNmZlYjJlNzZlOThjNDZmOWVjZTk4OTI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "e72f5083a0301f6d712e56fe2110234974f8acd4", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/e72f5083a0301f6d712e56fe2110234974f8acd4", "committedDate": "2020-10-07T06:22:27Z", "message": "Move allFilters and flatActiveFilterIds"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f88ea1c5465577fd54d1545f0f06e51e760f0c4e", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/f88ea1c5465577fd54d1545f0f06e51e760f0c4e", "committedDate": "2020-10-07T06:29:27Z", "message": "More cleanups"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "48da4f424cb98599939ecc6a672376defc5ee096", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/48da4f424cb98599939ecc6a672376defc5ee096", "committedDate": "2020-10-07T07:55:10Z", "message": "Fix for failing tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "727388c139b3976f52768316f852e03d1464463c", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/727388c139b3976f52768316f852e03d1464463c", "committedDate": "2020-10-07T09:13:08Z", "message": "Added cache selector"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAzNjkwMTYy", "url": "https://github.com/metasfresh/metasfresh/pull/9870#pullrequestreview-503690162", "createdAt": "2020-10-07T09:26:44Z", "commit": {"oid": "727388c139b3976f52768316f852e03d1464463c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "783444d96c328503f6feb2e76e98c46f9ece9892", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/783444d96c328503f6feb2e76e98c46f9ece9892", "committedDate": "2020-10-07T10:57:14Z", "message": "Small bug fix on Printing queue filters"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b35544165a199c916938b1f22a5e80ba02890066", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/b35544165a199c916938b1f22a5e80ba02890066", "committedDate": "2020-08-27T09:34:55Z", "message": "Rename file"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "81668697a6d9ece140093e0402dcc7fbb0afdb0c", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/81668697a6d9ece140093e0402dcc7fbb0afdb0c", "committedDate": "2020-08-27T11:50:35Z", "message": "Add getEntityRelatedId"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1079c937f84921fec4b78a231d0a0e5c5e758094", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/1079c937f84921fec4b78a231d0a0e5c5e758094", "committedDate": "2020-08-28T06:09:15Z", "message": "Create filter prerequisites"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "654862bfc043d308792765fa537a05da8914fd06", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/654862bfc043d308792765fa537a05da8914fd06", "committedDate": "2020-08-31T05:43:59Z", "message": "Merge branch 'master' into 9853-filtersRefactoring"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ae2c9f8af41c9b31e742b6b1d494c3bf678415a2", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/ae2c9f8af41c9b31e742b6b1d494c3bf678415a2", "committedDate": "2020-08-31T09:54:52Z", "message": "Delete filter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0a44084a3d8145e6fe21a745312a8c8dd7340b84", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/0a44084a3d8145e6fe21a745312a8c8dd7340b84", "committedDate": "2020-08-31T13:17:24Z", "message": "Move filterData to redux store"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ea899bf900e1c599183b85d762d9822933b18c4d", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/ea899bf900e1c599183b85d762d9822933b18c4d", "committedDate": "2020-08-31T13:22:46Z", "message": "remove debug lines"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "397e1c68e6ae59d3b84434e284f0ce2a5ad48daa", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/397e1c68e6ae59d3b84434e284f0ce2a5ad48daa", "committedDate": "2020-09-01T04:53:56Z", "message": "Merge branch 'master' into 9853-filtersRefactoring"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "affcd966629ab8596ef527c28f72d86c27a35c30", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/affcd966629ab8596ef527c28f72d86c27a35c30", "committedDate": "2020-09-01T06:57:16Z", "message": "Update filterActive"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0506b507ec58305251d407f23b2f78fe9c8a577a", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/0506b507ec58305251d407f23b2f78fe9c8a577a", "committedDate": "2020-09-01T09:01:12Z", "message": "Sync filters layout from the views"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "952718997b30f74e268b77bbce243bcb81ad7908", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/952718997b30f74e268b77bbce243bcb81ad7908", "committedDate": "2020-09-01T09:32:54Z", "message": "Sync active filters on new view creation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9ea31511eaa912bfc4bde1cef8616f3051c8b99e", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/9ea31511eaa912bfc4bde1cef8616f3051c8b99e", "committedDate": "2020-09-02T05:54:23Z", "message": "put raw data into redux store"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b056ac108591a1d8129813d86b7603c4bc9f9689", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/b056ac108591a1d8129813d86b7603c4bc9f9689", "committedDate": "2020-09-02T06:13:13Z", "message": "Merge branch 'master' into 9853-filtersRefactoring"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "26312e8f8fecc8ab45de039ef4d4b8887e85a79b", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/26312e8f8fecc8ab45de039ef4d4b8887e85a79b", "committedDate": "2020-09-02T09:30:37Z", "message": "Store the object exactly as they are retrieved from the BE"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "02f6d63f358dbe280e6e0be07e9514540d9444a5", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/02f6d63f358dbe280e6e0be07e9514540d9444a5", "committedDate": "2020-09-02T10:52:46Z", "message": "Removed unused drop"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1792a49348452444a30fe6544e717c9f33b6738c", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/1792a49348452444a30fe6544e717c9f33b6738c", "committedDate": "2020-09-02T12:28:32Z", "message": "Map filters from the store to local property"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f4610db2e08cdfe406b162dcdb5ce860f1523863", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/f4610db2e08cdfe406b162dcdb5ce860f1523863", "committedDate": "2020-09-02T12:57:39Z", "message": "Remove util function and put it in util file for diff date transformations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b146371c322d3bad4fbcf29b79d22986bc2f3b69", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/b146371c322d3bad4fbcf29b79d22986bc2f3b69", "committedDate": "2020-09-02T13:00:00Z", "message": "Fix import paths"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0898285c9dd2cac551aca2e18fc15e362b0ccba9", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/0898285c9dd2cac551aca2e18fc15e362b0ccba9", "committedDate": "2020-09-02T13:03:48Z", "message": "Import DATE_FIELDS from the constants"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "792cd02bfd7fa8d5e441df7bcb83231107b1d5b1", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/792cd02bfd7fa8d5e441df7bcb83231107b1d5b1", "committedDate": "2020-09-03T08:18:46Z", "message": "Put widgetShown into the redux store and adapt the logic in Filters"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "27eebea2c35979bb89eb956f2cf2486f4c5f9052", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/27eebea2c35979bb89eb956f2cf2486f4c5f9052", "committedDate": "2020-09-03T08:41:33Z", "message": "Merge branch 'master' into 9853-filtersRefactoring"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5111b99b294789622fad9df9449579b40c23ddbe", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/5111b99b294789622fad9df9449579b40c23ddbe", "committedDate": "2020-09-04T08:30:35Z", "message": "Merge branch 'master' into 9853-filtersRefactoring"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "73a604cd86ba2cb347052c83b6dfd38e794b2adf", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/73a604cd86ba2cb347052c83b6dfd38e794b2adf", "committedDate": "2020-09-09T06:45:04Z", "message": "Merge branch 'master' into 9853-filtersRefactoring"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "afecd27b5fd16190b6c7b5f85f3146e14271f88f", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/afecd27b5fd16190b6c7b5f85f3146e14271f88f", "committedDate": "2020-09-09T09:07:23Z", "message": "Replace filterData with the one from redux"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "50ce8f157c2da086ca85520921a6880ba4294604", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/50ce8f157c2da086ca85520921a6880ba4294604", "committedDate": "2020-09-09T09:35:27Z", "message": "Dont bother to render if no viewId"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4343df98bdd85a48afb5238dcf4161df3f401be3", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/4343df98bdd85a48afb5238dcf4161df3f401be3", "committedDate": "2020-09-09T13:23:05Z", "message": "Put flat filters map into redux store"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1612523968d1d8d433567ba6ba40481082f39831", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/1612523968d1d8d433567ba6ba40481082f39831", "committedDate": "2020-09-10T04:54:40Z", "message": "Merge branch 'master' into 9853-filtersRefactoring"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4e3f7729c36ab1ea54a0116f3393413e3fa59d8a", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/4e3f7729c36ab1ea54a0116f3393413e3fa59d8a", "committedDate": "2020-09-10T12:19:56Z", "message": "Merged master into local branch and fixed conflicts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "12cdef31f929c5efbd0a40bf1ce8bc1e77664d23", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/12cdef31f929c5efbd0a40bf1ce8bc1e77664d23", "committedDate": "2020-09-10T12:33:31Z", "message": "remove flatFiltersMap logic from local state"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "09eb427810a31339174ba04d9fa1dbd6c0f64d23", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/09eb427810a31339174ba04d9fa1dbd6c0f64d23", "committedDate": "2020-09-11T09:45:51Z", "message": "Attempt to ditch DocList state logic and use the data from the redux store"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "30dc558767bb0fa0d1ed6ce61fea3c8596a8cad5", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/30dc558767bb0fa0d1ed6ce61fea3c8596a8cad5", "committedDate": "2020-09-11T11:18:07Z", "message": "Remove more redundant code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "36d9a1a75e6f18ca62e5a3629cb48791df21bb85", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/36d9a1a75e6f18ca62e5a3629cb48791df21bb85", "committedDate": "2020-09-11T12:05:56Z", "message": "Fix activeFilters"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "469afe76a73b44ea3641f1754bf1d619bcd3f86d", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/469afe76a73b44ea3641f1754bf1d619bcd3f86d", "committedDate": "2020-09-14T04:40:52Z", "message": "Merge branch 'master' into 9853-filtersRefactoring"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "156b09dbf22133b8fbccd6a396df93500abc67df", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/156b09dbf22133b8fbccd6a396df93500abc67df", "committedDate": "2020-09-14T06:40:44Z", "message": "use filtersActive from the store"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "53fccf8de02fae0d5371733ae86ddad6e7fb3cdc", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/53fccf8de02fae0d5371733ae86ddad6e7fb3cdc", "committedDate": "2020-09-14T07:23:38Z", "message": "Move annotateFilters function to FiltersActions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bbfc0fb5bcf0c184e1998ccb30cf57312978f2de", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/bbfc0fb5bcf0c184e1998ccb30cf57312978f2de", "committedDate": "2020-09-14T09:18:04Z", "message": "Merge branch 'master' into 9853-filtersRefactoring"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a3c5ca159926fd51aeb74c409665361283ee780d", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/a3c5ca159926fd51aeb74c409665361283ee780d", "committedDate": "2020-09-14T10:00:03Z", "message": "Remove sortFilters function as it is not used"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d60c0d1f55a2a58ca896bce5d21a3a34eb94a314", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/d60c0d1f55a2a58ca896bce5d21a3a34eb94a314", "committedDate": "2020-09-14T10:04:31Z", "message": "Some cleanups"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "72d610c67a0466a2a48eed1f331cf04415fddb31", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/72d610c67a0466a2a48eed1f331cf04415fddb31", "committedDate": "2020-09-14T14:03:24Z", "message": "Add prereq for moving parseActiveFilters logic to actions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d5e33a20c2c2c1a8e1c9f9a2612dee0b38224b68", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/d5e33a20c2c2c1a8e1c9f9a2612dee0b38224b68", "committedDate": "2020-09-15T04:17:52Z", "message": "Merge branch 'master' into 9853-filtersRefactoring"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e1f1a364e84add71e749c90d6dabe6c8d1194f3f", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/e1f1a364e84add71e749c90d6dabe6c8d1194f3f", "committedDate": "2020-09-15T06:27:46Z", "message": "Completely remove activeFiltersCaptions from local state"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d3afa0dc5b578858a8910e2641408aa80edf7f73", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/d3afa0dc5b578858a8910e2641408aa80edf7f73", "committedDate": "2020-09-15T06:44:56Z", "message": "Ditch redundant code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "db9d387ab964176afcf9c2733a58593df7a7f313", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/db9d387ab964176afcf9c2733a58593df7a7f313", "committedDate": "2020-09-15T07:03:46Z", "message": " Move function to check filter validity to actions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2e65e3a8718f52bbbd6b1cd46f0a6e07d1d244c6", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/2e65e3a8718f52bbbd6b1cd46f0a6e07d1d244c6", "committedDate": "2020-09-15T08:16:39Z", "message": "Move last flag used in state to the redux store"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c0de0eefdf4c8bc04556e22bab08af956f162d06", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/c0de0eefdf4c8bc04556e22bab08af956f162d06", "committedDate": "2020-09-16T05:09:32Z", "message": "Merge branch 'master' into 9853-filtersRefactoring"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8465ba8db7f7793f11a7443bb9ebbe1e5b39f47d", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/8465ba8db7f7793f11a7443bb9ebbe1e5b39f47d", "committedDate": "2020-09-17T04:38:09Z", "message": "Merge branch 'master' into 9853-filtersRefactoring"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "44597d517d4723a71f6271ba1e08961fa0265efd", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/44597d517d4723a71f6271ba1e08961fa0265efd", "committedDate": "2020-09-18T11:47:50Z", "message": "ditch getFlatFiltersMap logic"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a1f0401841a7db3ad3791495b638b66146959e6d", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/a1f0401841a7db3ad3791495b638b66146959e6d", "committedDate": "2020-09-18T11:49:14Z", "message": "Merge branch 'master' into 9853-filtersRefactoring"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "09b1da53050a66d256fb57555ca6948306aef20c", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/09b1da53050a66d256fb57555ca6948306aef20c", "committedDate": "2020-09-18T12:12:37Z", "message": "Some cleanups in FiltersNotFrequent"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a72fe69c6453c9d8b2041c2f1b419c09710f5284", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/a72fe69c6453c9d8b2041c2f1b419c09710f5284", "committedDate": "2020-09-18T12:25:11Z", "message": "Some more cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b9d50ecddc26b8778a59adaec57b88ed08dbe262", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/b9d50ecddc26b8778a59adaec57b88ed08dbe262", "committedDate": "2020-09-23T05:07:16Z", "message": "Merged master into local branch"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2b2bb456d40004699616e77726a4902bcbc71d83", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/2b2bb456d40004699616e77726a4902bcbc71d83", "committedDate": "2020-09-23T05:08:20Z", "message": "Fix conflicts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "345fc2a3bbdb9fb623ba501716d821d9a61e6b32", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/345fc2a3bbdb9fb623ba501716d821d9a61e6b32", "committedDate": "2020-09-24T10:45:43Z", "message": "Merge branch 'master' into 9853-filtersRefactoring"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fd4fed0130129eb3e3b5bed08488bcb50fbe8dfd", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/fd4fed0130129eb3e3b5bed08488bcb50fbe8dfd", "committedDate": "2020-09-24T11:59:31Z", "message": "Merge branch 'master' into 9853-filtersRefactoring"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1d171656aab4009cc295a91b36814339f099b5d6", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/1d171656aab4009cc295a91b36814339f099b5d6", "committedDate": "2020-09-25T04:34:25Z", "message": "Fix conflicts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "379808bb798340d51f9d4aaf15c759f2b817515b", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/379808bb798340d51f9d4aaf15c759f2b817515b", "committedDate": "2020-09-25T10:05:55Z", "message": "Prerequisites for moving static logic filters"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2ca2d621bf6f95cd4594071925b31395fe729629", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/2ca2d621bf6f95cd4594071925b31395fe729629", "committedDate": "2020-09-25T10:47:11Z", "message": "Refactor static filters"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dedafa0f1d82c5eb9541349daa32004673d9a317", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/dedafa0f1d82c5eb9541349daa32004673d9a317", "committedDate": "2020-09-25T11:00:18Z", "message": "remove extra parameters"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fc3f2d59abea3ec756982f42b9721364ba7257e7", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/fc3f2d59abea3ec756982f42b9721364ba7257e7", "committedDate": "2020-09-28T07:03:36Z", "message": "Merge branch 'master' into 9853-filtersRefactoring"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d611ecae7539b973accaeee9d5a80b7e87fe42bf", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/d611ecae7539b973accaeee9d5a80b7e87fe42bf", "committedDate": "2020-09-29T11:25:12Z", "message": "Fix conflicts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "01d466b7f41c1fe411b0a3b727c213df362c16f8", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/01d466b7f41c1fe411b0a3b727c213df362c16f8", "committedDate": "2020-09-30T05:45:58Z", "message": "InlineFilterItem small updates as it is not in use"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2276c1a19fb4ea333e8e929c70c5d54e67e807fe", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/2276c1a19fb4ea333e8e929c70c5d54e67e807fe", "committedDate": "2020-09-30T10:40:16Z", "message": "Merge branch 'master' into 9853-filtersRefactoring"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "981b40a7ed61f70f8d41a21d69cbb541dc54d577", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/981b40a7ed61f70f8d41a21d69cbb541dc54d577", "committedDate": "2020-09-30T13:22:04Z", "message": "Fix Proptypes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e3ba30a47233a2b1e8913630269987382c096abb", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/e3ba30a47233a2b1e8913630269987382c096abb", "committedDate": "2020-10-01T07:40:32Z", "message": "Merge branch 'master' into 9853-filtersRefactoring"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aca6e4a591072da112d61083ebccc3a36f0e0724", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/aca6e4a591072da112d61083ebccc3a36f0e0724", "committedDate": "2020-10-01T11:22:10Z", "message": "Fix the issue with deepUnfreeze"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwMzYzOTc2", "url": "https://github.com/metasfresh/metasfresh/pull/9870#pullrequestreview-500363976", "createdAt": "2020-10-01T13:46:44Z", "commit": {"oid": "aca6e4a591072da112d61083ebccc3a36f0e0724"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxMzo0Njo0NFrOHbLLsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNToyNzowM1rOHbPzdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI1NjgxOA==", "bodyText": "Won't get(state, ['filters'], {}) work here ?", "url": "https://github.com/metasfresh/metasfresh/pull/9870#discussion_r498256818", "createdAt": "2020-10-01T13:46:44Z", "author": {"login": "siemiatj"}, "path": "frontend/src/utils/documentListHelper.js", "diffHunk": "@@ -142,7 +141,8 @@ const DLmapStateToProps = (state, props) => {\n     parentSelected: parentSelector(state, parentTableId),\n     modal: state.windowHandler.modal,\n     rawModalVisible: state.windowHandler.rawModal.visible,\n-    filters: state.filters,\n+    filters: windowId && viewId && state.filters ? state.filters[filterId] : {},", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aca6e4a591072da112d61083ebccc3a36f0e0724"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI4MDAwMA==", "bodyText": "Why we have this for filters only and not all widgets ?", "url": "https://github.com/metasfresh/metasfresh/pull/9870#discussion_r498280000", "createdAt": "2020-10-01T14:17:38Z", "author": {"login": "siemiatj"}, "path": "frontend/src/actions/FiltersActions.js", "diffHunk": "@@ -1,8 +1,357 @@\n-import { SET_CLEAR_ALL_FILTER } from '../constants/FilterTypes';\n+import * as types from '../constants/FilterTypes';\n+import { Map as iMap } from 'immutable';\n+import deepUnfreeze from 'deep-unfreeze';\n+import { fieldValueToString } from '../utils/tableHelpers';\n+import _ from 'lodash';\n \n-export function clearAllFilters(data) {\n+export function clearAllFilters({ id, data }) {\n   return {\n-    type: SET_CLEAR_ALL_FILTER,\n-    payload: data,\n+    type: types.CLEAR_ALL_FILTERS,\n+    payload: { id, data },\n   };\n }\n+\n+/**\n+ * @method createFilter\n+ * @summary Add a new filter entry to the redux store\n+ */\n+export function createFilter({ id, data }) {\n+  return {\n+    type: types.CREATE_FILTER,\n+    payload: { id, data },\n+  };\n+}\n+\n+/**\n+ * @method deleteFilter\n+ * @summary Remove the filter with specified `id` from the store\n+ */\n+export function deleteFilter(id) {\n+  return {\n+    type: types.DELETE_FILTER,\n+    payload: { id },\n+  };\n+}\n+\n+/**\n+ * @method updateNotValidFields\n+ * @summary updates in the store the notValidFields flag\n+ */\n+export function updateNotValidFields({ filterId, data }) {\n+  return {\n+    type: types.UPDATE_FLAG_NOTVALIDFIELDS,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aca6e4a591072da112d61083ebccc3a36f0e0724"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI4MDU4NA==", "bodyText": "Is this only for filters ? If yes it should have FILTER in the name so it won't confuse us next month :)", "url": "https://github.com/metasfresh/metasfresh/pull/9870#discussion_r498280584", "createdAt": "2020-10-01T14:18:21Z", "author": {"login": "siemiatj"}, "path": "frontend/src/actions/FiltersActions.js", "diffHunk": "@@ -1,8 +1,357 @@\n-import { SET_CLEAR_ALL_FILTER } from '../constants/FilterTypes';\n+import * as types from '../constants/FilterTypes';\n+import { Map as iMap } from 'immutable';\n+import deepUnfreeze from 'deep-unfreeze';\n+import { fieldValueToString } from '../utils/tableHelpers';\n+import _ from 'lodash';\n \n-export function clearAllFilters(data) {\n+export function clearAllFilters({ id, data }) {\n   return {\n-    type: SET_CLEAR_ALL_FILTER,\n-    payload: data,\n+    type: types.CLEAR_ALL_FILTERS,\n+    payload: { id, data },\n   };\n }\n+\n+/**\n+ * @method createFilter\n+ * @summary Add a new filter entry to the redux store\n+ */\n+export function createFilter({ id, data }) {\n+  return {\n+    type: types.CREATE_FILTER,\n+    payload: { id, data },\n+  };\n+}\n+\n+/**\n+ * @method deleteFilter\n+ * @summary Remove the filter with specified `id` from the store\n+ */\n+export function deleteFilter(id) {\n+  return {\n+    type: types.DELETE_FILTER,\n+    payload: { id },\n+  };\n+}\n+\n+/**\n+ * @method updateNotValidFields\n+ * @summary updates in the store the notValidFields flag\n+ */\n+export function updateNotValidFields({ filterId, data }) {\n+  return {\n+    type: types.UPDATE_FLAG_NOTVALIDFIELDS,\n+    payload: { filterId, data },\n+  };\n+}\n+\n+/**\n+ * @method updateActiveFilter\n+ * @summary Updates the activeFilter in the store for the corresponding entity id\n+ */\n+export function updateActiveFilter({ id, data }) {\n+  return {\n+    type: types.UPDATE_ACTIVE_FILTER,\n+    payload: { id, data },\n+  };\n+}\n+\n+/**\n+ * @method updateWidgetShown\n+ * @summary Updates the widgetShown in the store for the corresponding entity id with a boolean value\n+ */\n+export function updateWidgetShown({ id, data }) {\n+  return {\n+    type: types.UPDATE_WIDGET_SHOWN,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aca6e4a591072da112d61083ebccc3a36f0e0724"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI4MTIwOQ==", "bodyText": "actually the name suggests it gets parent filter out of somewhere :)", "url": "https://github.com/metasfresh/metasfresh/pull/9870#discussion_r498281209", "createdAt": "2020-10-01T14:19:08Z", "author": {"login": "siemiatj"}, "path": "frontend/src/actions/FiltersActions.js", "diffHunk": "@@ -1,8 +1,357 @@\n-import { SET_CLEAR_ALL_FILTER } from '../constants/FilterTypes';\n+import * as types from '../constants/FilterTypes';\n+import { Map as iMap } from 'immutable';\n+import deepUnfreeze from 'deep-unfreeze';\n+import { fieldValueToString } from '../utils/tableHelpers';\n+import _ from 'lodash';\n \n-export function clearAllFilters(data) {\n+export function clearAllFilters({ id, data }) {\n   return {\n-    type: SET_CLEAR_ALL_FILTER,\n-    payload: data,\n+    type: types.CLEAR_ALL_FILTERS,\n+    payload: { id, data },\n   };\n }\n+\n+/**\n+ * @method createFilter\n+ * @summary Add a new filter entry to the redux store\n+ */\n+export function createFilter({ id, data }) {\n+  return {\n+    type: types.CREATE_FILTER,\n+    payload: { id, data },\n+  };\n+}\n+\n+/**\n+ * @method deleteFilter\n+ * @summary Remove the filter with specified `id` from the store\n+ */\n+export function deleteFilter(id) {\n+  return {\n+    type: types.DELETE_FILTER,\n+    payload: { id },\n+  };\n+}\n+\n+/**\n+ * @method updateNotValidFields\n+ * @summary updates in the store the notValidFields flag\n+ */\n+export function updateNotValidFields({ filterId, data }) {\n+  return {\n+    type: types.UPDATE_FLAG_NOTVALIDFIELDS,\n+    payload: { filterId, data },\n+  };\n+}\n+\n+/**\n+ * @method updateActiveFilter\n+ * @summary Updates the activeFilter in the store for the corresponding entity id\n+ */\n+export function updateActiveFilter({ id, data }) {\n+  return {\n+    type: types.UPDATE_ACTIVE_FILTER,\n+    payload: { id, data },\n+  };\n+}\n+\n+/**\n+ * @method updateWidgetShown\n+ * @summary Updates the widgetShown in the store for the corresponding entity id with a boolean value\n+ */\n+export function updateWidgetShown({ id, data }) {\n+  return {\n+    type: types.UPDATE_WIDGET_SHOWN,\n+    payload: { id, data },\n+  };\n+}\n+\n+/**\n+ * @method clearStaticFilters\n+ * @summary Clears the existing static filters for a filter branch in the redux store\n+ */\n+export function clearStaticFilters({ filterId, data }) {\n+  return {\n+    type: types.CLEAR_STATIC_FILTERS,\n+    payload: { filterId, data },\n+  };\n+}\n+\n+/**\n+ * @method getParentFilter\n+ * @summary as the name suggests the function is retrieving the filter data by key from the filterData", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aca6e4a591072da112d61083ebccc3a36f0e0724"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI4Mjk1NA==", "bodyText": "It's not really obvious how is this different to filtersActiveContains. The parameter names are also misleading here.", "url": "https://github.com/metasfresh/metasfresh/pull/9870#discussion_r498282954", "createdAt": "2020-10-01T14:21:26Z", "author": {"login": "siemiatj"}, "path": "frontend/src/actions/FiltersActions.js", "diffHunk": "@@ -1,8 +1,357 @@\n-import { SET_CLEAR_ALL_FILTER } from '../constants/FilterTypes';\n+import * as types from '../constants/FilterTypes';\n+import { Map as iMap } from 'immutable';\n+import deepUnfreeze from 'deep-unfreeze';\n+import { fieldValueToString } from '../utils/tableHelpers';\n+import _ from 'lodash';\n \n-export function clearAllFilters(data) {\n+export function clearAllFilters({ id, data }) {\n   return {\n-    type: SET_CLEAR_ALL_FILTER,\n-    payload: data,\n+    type: types.CLEAR_ALL_FILTERS,\n+    payload: { id, data },\n   };\n }\n+\n+/**\n+ * @method createFilter\n+ * @summary Add a new filter entry to the redux store\n+ */\n+export function createFilter({ id, data }) {\n+  return {\n+    type: types.CREATE_FILTER,\n+    payload: { id, data },\n+  };\n+}\n+\n+/**\n+ * @method deleteFilter\n+ * @summary Remove the filter with specified `id` from the store\n+ */\n+export function deleteFilter(id) {\n+  return {\n+    type: types.DELETE_FILTER,\n+    payload: { id },\n+  };\n+}\n+\n+/**\n+ * @method updateNotValidFields\n+ * @summary updates in the store the notValidFields flag\n+ */\n+export function updateNotValidFields({ filterId, data }) {\n+  return {\n+    type: types.UPDATE_FLAG_NOTVALIDFIELDS,\n+    payload: { filterId, data },\n+  };\n+}\n+\n+/**\n+ * @method updateActiveFilter\n+ * @summary Updates the activeFilter in the store for the corresponding entity id\n+ */\n+export function updateActiveFilter({ id, data }) {\n+  return {\n+    type: types.UPDATE_ACTIVE_FILTER,\n+    payload: { id, data },\n+  };\n+}\n+\n+/**\n+ * @method updateWidgetShown\n+ * @summary Updates the widgetShown in the store for the corresponding entity id with a boolean value\n+ */\n+export function updateWidgetShown({ id, data }) {\n+  return {\n+    type: types.UPDATE_WIDGET_SHOWN,\n+    payload: { id, data },\n+  };\n+}\n+\n+/**\n+ * @method clearStaticFilters\n+ * @summary Clears the existing static filters for a filter branch in the redux store\n+ */\n+export function clearStaticFilters({ filterId, data }) {\n+  return {\n+    type: types.CLEAR_STATIC_FILTERS,\n+    payload: { filterId, data },\n+  };\n+}\n+\n+/**\n+ * @method getParentFilter\n+ * @summary as the name suggests the function is retrieving the filter data by key from the filterData\n+ * @param {string} filterId - key identifying the filter\n+ * @param {array} filterData array that contains all the filters as they are retrieved from the BE\n+ */\n+function getParentFilter({ filterId, filterData }) {\n+  let parentFilter = {};\n+  filterData.forEach((filter) => {\n+    if (filter.filterId && filter.filterId === filterId) {\n+      parentFilter = filter;\n+    }\n+    if (filter.includedFilters) {\n+      filter.includedFilters.forEach((incFilter) => {\n+        if (incFilter.filterId && incFilter.filterId === filterId) {\n+          parentFilter = incFilter;\n+        }\n+      });\n+    }\n+  });\n+  return parentFilter;\n+}\n+\n+/**\n+ * @method populateFiltersCaptions\n+ * @summary updates the filtersCaptions object for the corresponding filter branch id in the store\n+ * @param {string} id - filter id used as identifier for the filters branch\n+ * @param {object} data - object containing the captions\n+ */\n+export function populateFiltersCaptions(filters) {\n+  const filtersCaptions = {};\n+  if (!filters) return {};\n+  const { filterData, filtersActive } = filters;\n+  if (!filtersActive) return {};\n+\n+  if (filtersActive.length) {\n+    const removeDefault = {};\n+\n+    filtersActive.forEach((filter, filterId) => {\n+      let captionsArray = ['', ''];\n+\n+      if (filter.parameters && filter.parameters.length) {\n+        filter.parameters.forEach((filterParameter) => {\n+          const { value, parameterName, defaultValue } = filterParameter;\n+\n+          if (!defaultValue && filterData) {\n+            // we don't want to show captions, nor show filter button as active for default values\n+            removeDefault[filterId] = true;\n+            const parentFilter = getParentFilter({\n+              filterId: filter.filterId, // we pass the actual key not the index\n+              filterData,\n+            });\n+\n+            const filterParameter = parentFilter.parameters.find(\n+              (param) => param.parameterName === parameterName\n+            );\n+            let captionName = filterParameter.caption;\n+            let itemCaption = filterParameter.caption;\n+\n+            switch (filterParameter.widgetType) {\n+              case 'Text':\n+                captionName = value;\n+\n+                if (!value) {\n+                  captionName = '';\n+                  itemCaption = '';\n+                }\n+                break;\n+              case 'Lookup':\n+              case 'List':\n+                captionName = value && value.caption;\n+                break;\n+              case 'Labels':\n+                captionName = value.values.reduce((caption, item) => {\n+                  return `${caption}, ${item.caption}`;\n+                }, '');\n+                break;\n+              case 'YesNo':\n+                if (value === null) {\n+                  captionName = '';\n+                  itemCaption = '';\n+                }\n+                break;\n+              case 'Switch':\n+              default:\n+                if (!value) {\n+                  captionName = '';\n+                  itemCaption = '';\n+                }\n+                break;\n+            }\n+\n+            if (captionName) {\n+              captionsArray[0] = captionsArray[0]\n+                ? `${captionsArray[0]}, ${captionName}`\n+                : captionName;\n+            }\n+\n+            if (itemCaption) {\n+              captionsArray[1] = captionsArray[1]\n+                ? `${captionsArray[1]}, ${itemCaption}`\n+                : itemCaption;\n+            }\n+          }\n+        });\n+      } else {\n+        const originalFilter = filterData.filter(\n+          (item) => item.filterId === filterId\n+        );\n+        captionsArray = [originalFilter.caption, originalFilter.caption];\n+      }\n+\n+      if (captionsArray.join('').length) {\n+        filtersCaptions[filter.filterId] = captionsArray;\n+        filtersCaptions[filterId] = captionsArray;\n+      }\n+    });\n+  }\n+\n+  return filtersCaptions;\n+}\n+\n+/**\n+ * @method filtersToMap\n+ * @summary creates a map with the filters fetched from the layout request\n+ */\n+export function filtersToMap(filtersArray) {\n+  let filtersMap = iMap();\n+\n+  if (filtersArray && filtersArray.length) {\n+    filtersArray.forEach((filter) => {\n+      filtersMap = filtersMap.set(filter.filterId, filter);\n+    });\n+  }\n+  return filtersMap;\n+}\n+\n+/**\n+ * @method filtersActiveContains\n+ * @summary returns a boolean value depending on the presence of the key withing the activeFilters passed array\n+ */\n+export function filtersActiveContains({ filtersActive, key }) {\n+  if (filtersActive.lenght === 0) return false;\n+  const isPresent = filtersActive.filter((item) => item.filterId === key);\n+  return isPresent.length ? true : false;\n+}\n+\n+/**\n+ * @method setNewFiltersActive\n+ * @summary returns a new array with filters that are going to be the active ones\n+ */\n+export function setNewFiltersActive({ storeActiveFilters, filterToAdd }) {\n+  storeActiveFilters = deepUnfreeze(storeActiveFilters);\n+  if (\n+    !storeActiveFilters.length ||\n+    !foundAmongActiveFilters({ storeActiveFilters, filterToAdd })\n+  ) {\n+    storeActiveFilters.push(filterToAdd);\n+  } else {\n+    storeActiveFilters.forEach((activeFilter, index) => {\n+      if (activeFilter.filterId === filterToAdd.filterId) {\n+        storeActiveFilters[index] = filterToAdd;\n+      }\n+    });\n+  }\n+  return storeActiveFilters;\n+}\n+\n+/**\n+ * @method foundAmongActiveFilters\n+ * @summary checks that the filterToAdd is found among the storeActiveFilters\n+ */\n+function foundAmongActiveFilters({ storeActiveFilters, filterToAdd }) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aca6e4a591072da112d61083ebccc3a36f0e0724"}, "originalPosition": 256}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI4MzkzNA==", "bodyText": "Again, at first glance this is similar to filtersActiveContains. Can't they be merged together ?", "url": "https://github.com/metasfresh/metasfresh/pull/9870#discussion_r498283934", "createdAt": "2020-10-01T14:22:47Z", "author": {"login": "siemiatj"}, "path": "frontend/src/actions/FiltersActions.js", "diffHunk": "@@ -1,8 +1,357 @@\n-import { SET_CLEAR_ALL_FILTER } from '../constants/FilterTypes';\n+import * as types from '../constants/FilterTypes';\n+import { Map as iMap } from 'immutable';\n+import deepUnfreeze from 'deep-unfreeze';\n+import { fieldValueToString } from '../utils/tableHelpers';\n+import _ from 'lodash';\n \n-export function clearAllFilters(data) {\n+export function clearAllFilters({ id, data }) {\n   return {\n-    type: SET_CLEAR_ALL_FILTER,\n-    payload: data,\n+    type: types.CLEAR_ALL_FILTERS,\n+    payload: { id, data },\n   };\n }\n+\n+/**\n+ * @method createFilter\n+ * @summary Add a new filter entry to the redux store\n+ */\n+export function createFilter({ id, data }) {\n+  return {\n+    type: types.CREATE_FILTER,\n+    payload: { id, data },\n+  };\n+}\n+\n+/**\n+ * @method deleteFilter\n+ * @summary Remove the filter with specified `id` from the store\n+ */\n+export function deleteFilter(id) {\n+  return {\n+    type: types.DELETE_FILTER,\n+    payload: { id },\n+  };\n+}\n+\n+/**\n+ * @method updateNotValidFields\n+ * @summary updates in the store the notValidFields flag\n+ */\n+export function updateNotValidFields({ filterId, data }) {\n+  return {\n+    type: types.UPDATE_FLAG_NOTVALIDFIELDS,\n+    payload: { filterId, data },\n+  };\n+}\n+\n+/**\n+ * @method updateActiveFilter\n+ * @summary Updates the activeFilter in the store for the corresponding entity id\n+ */\n+export function updateActiveFilter({ id, data }) {\n+  return {\n+    type: types.UPDATE_ACTIVE_FILTER,\n+    payload: { id, data },\n+  };\n+}\n+\n+/**\n+ * @method updateWidgetShown\n+ * @summary Updates the widgetShown in the store for the corresponding entity id with a boolean value\n+ */\n+export function updateWidgetShown({ id, data }) {\n+  return {\n+    type: types.UPDATE_WIDGET_SHOWN,\n+    payload: { id, data },\n+  };\n+}\n+\n+/**\n+ * @method clearStaticFilters\n+ * @summary Clears the existing static filters for a filter branch in the redux store\n+ */\n+export function clearStaticFilters({ filterId, data }) {\n+  return {\n+    type: types.CLEAR_STATIC_FILTERS,\n+    payload: { filterId, data },\n+  };\n+}\n+\n+/**\n+ * @method getParentFilter\n+ * @summary as the name suggests the function is retrieving the filter data by key from the filterData\n+ * @param {string} filterId - key identifying the filter\n+ * @param {array} filterData array that contains all the filters as they are retrieved from the BE\n+ */\n+function getParentFilter({ filterId, filterData }) {\n+  let parentFilter = {};\n+  filterData.forEach((filter) => {\n+    if (filter.filterId && filter.filterId === filterId) {\n+      parentFilter = filter;\n+    }\n+    if (filter.includedFilters) {\n+      filter.includedFilters.forEach((incFilter) => {\n+        if (incFilter.filterId && incFilter.filterId === filterId) {\n+          parentFilter = incFilter;\n+        }\n+      });\n+    }\n+  });\n+  return parentFilter;\n+}\n+\n+/**\n+ * @method populateFiltersCaptions\n+ * @summary updates the filtersCaptions object for the corresponding filter branch id in the store\n+ * @param {string} id - filter id used as identifier for the filters branch\n+ * @param {object} data - object containing the captions\n+ */\n+export function populateFiltersCaptions(filters) {\n+  const filtersCaptions = {};\n+  if (!filters) return {};\n+  const { filterData, filtersActive } = filters;\n+  if (!filtersActive) return {};\n+\n+  if (filtersActive.length) {\n+    const removeDefault = {};\n+\n+    filtersActive.forEach((filter, filterId) => {\n+      let captionsArray = ['', ''];\n+\n+      if (filter.parameters && filter.parameters.length) {\n+        filter.parameters.forEach((filterParameter) => {\n+          const { value, parameterName, defaultValue } = filterParameter;\n+\n+          if (!defaultValue && filterData) {\n+            // we don't want to show captions, nor show filter button as active for default values\n+            removeDefault[filterId] = true;\n+            const parentFilter = getParentFilter({\n+              filterId: filter.filterId, // we pass the actual key not the index\n+              filterData,\n+            });\n+\n+            const filterParameter = parentFilter.parameters.find(\n+              (param) => param.parameterName === parameterName\n+            );\n+            let captionName = filterParameter.caption;\n+            let itemCaption = filterParameter.caption;\n+\n+            switch (filterParameter.widgetType) {\n+              case 'Text':\n+                captionName = value;\n+\n+                if (!value) {\n+                  captionName = '';\n+                  itemCaption = '';\n+                }\n+                break;\n+              case 'Lookup':\n+              case 'List':\n+                captionName = value && value.caption;\n+                break;\n+              case 'Labels':\n+                captionName = value.values.reduce((caption, item) => {\n+                  return `${caption}, ${item.caption}`;\n+                }, '');\n+                break;\n+              case 'YesNo':\n+                if (value === null) {\n+                  captionName = '';\n+                  itemCaption = '';\n+                }\n+                break;\n+              case 'Switch':\n+              default:\n+                if (!value) {\n+                  captionName = '';\n+                  itemCaption = '';\n+                }\n+                break;\n+            }\n+\n+            if (captionName) {\n+              captionsArray[0] = captionsArray[0]\n+                ? `${captionsArray[0]}, ${captionName}`\n+                : captionName;\n+            }\n+\n+            if (itemCaption) {\n+              captionsArray[1] = captionsArray[1]\n+                ? `${captionsArray[1]}, ${itemCaption}`\n+                : itemCaption;\n+            }\n+          }\n+        });\n+      } else {\n+        const originalFilter = filterData.filter(\n+          (item) => item.filterId === filterId\n+        );\n+        captionsArray = [originalFilter.caption, originalFilter.caption];\n+      }\n+\n+      if (captionsArray.join('').length) {\n+        filtersCaptions[filter.filterId] = captionsArray;\n+        filtersCaptions[filterId] = captionsArray;\n+      }\n+    });\n+  }\n+\n+  return filtersCaptions;\n+}\n+\n+/**\n+ * @method filtersToMap\n+ * @summary creates a map with the filters fetched from the layout request\n+ */\n+export function filtersToMap(filtersArray) {\n+  let filtersMap = iMap();\n+\n+  if (filtersArray && filtersArray.length) {\n+    filtersArray.forEach((filter) => {\n+      filtersMap = filtersMap.set(filter.filterId, filter);\n+    });\n+  }\n+  return filtersMap;\n+}\n+\n+/**\n+ * @method filtersActiveContains\n+ * @summary returns a boolean value depending on the presence of the key withing the activeFilters passed array\n+ */\n+export function filtersActiveContains({ filtersActive, key }) {\n+  if (filtersActive.lenght === 0) return false;\n+  const isPresent = filtersActive.filter((item) => item.filterId === key);\n+  return isPresent.length ? true : false;\n+}\n+\n+/**\n+ * @method setNewFiltersActive\n+ * @summary returns a new array with filters that are going to be the active ones\n+ */\n+export function setNewFiltersActive({ storeActiveFilters, filterToAdd }) {\n+  storeActiveFilters = deepUnfreeze(storeActiveFilters);\n+  if (\n+    !storeActiveFilters.length ||\n+    !foundAmongActiveFilters({ storeActiveFilters, filterToAdd })\n+  ) {\n+    storeActiveFilters.push(filterToAdd);\n+  } else {\n+    storeActiveFilters.forEach((activeFilter, index) => {\n+      if (activeFilter.filterId === filterToAdd.filterId) {\n+        storeActiveFilters[index] = filterToAdd;\n+      }\n+    });\n+  }\n+  return storeActiveFilters;\n+}\n+\n+/**\n+ * @method foundAmongActiveFilters\n+ * @summary checks that the filterToAdd is found among the storeActiveFilters\n+ */\n+function foundAmongActiveFilters({ storeActiveFilters, filterToAdd }) {\n+  let isPresent = false;\n+  storeActiveFilters.forEach((item) => {\n+    if (item.filterId === filterToAdd.filterId) isPresent = true;\n+  });\n+  return isPresent;\n+}\n+\n+/**\n+ * @method isFilterActive\n+ * @summary Check within the active filters array if filterId given as param is active\n+ * @param {string} filterId\n+ * @param {array} activeFilter\n+ */\n+export function isFilterActive({ filterId, filtersActive }) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aca6e4a591072da112d61083ebccc3a36f0e0724"}, "originalPosition": 270}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI4NTA1NQ==", "bodyText": "Just to be sure - filtersActive can be undefined/null, or an empty array ?", "url": "https://github.com/metasfresh/metasfresh/pull/9870#discussion_r498285055", "createdAt": "2020-10-01T14:24:09Z", "author": {"login": "siemiatj"}, "path": "frontend/src/actions/FiltersActions.js", "diffHunk": "@@ -1,8 +1,357 @@\n-import { SET_CLEAR_ALL_FILTER } from '../constants/FilterTypes';\n+import * as types from '../constants/FilterTypes';\n+import { Map as iMap } from 'immutable';\n+import deepUnfreeze from 'deep-unfreeze';\n+import { fieldValueToString } from '../utils/tableHelpers';\n+import _ from 'lodash';\n \n-export function clearAllFilters(data) {\n+export function clearAllFilters({ id, data }) {\n   return {\n-    type: SET_CLEAR_ALL_FILTER,\n-    payload: data,\n+    type: types.CLEAR_ALL_FILTERS,\n+    payload: { id, data },\n   };\n }\n+\n+/**\n+ * @method createFilter\n+ * @summary Add a new filter entry to the redux store\n+ */\n+export function createFilter({ id, data }) {\n+  return {\n+    type: types.CREATE_FILTER,\n+    payload: { id, data },\n+  };\n+}\n+\n+/**\n+ * @method deleteFilter\n+ * @summary Remove the filter with specified `id` from the store\n+ */\n+export function deleteFilter(id) {\n+  return {\n+    type: types.DELETE_FILTER,\n+    payload: { id },\n+  };\n+}\n+\n+/**\n+ * @method updateNotValidFields\n+ * @summary updates in the store the notValidFields flag\n+ */\n+export function updateNotValidFields({ filterId, data }) {\n+  return {\n+    type: types.UPDATE_FLAG_NOTVALIDFIELDS,\n+    payload: { filterId, data },\n+  };\n+}\n+\n+/**\n+ * @method updateActiveFilter\n+ * @summary Updates the activeFilter in the store for the corresponding entity id\n+ */\n+export function updateActiveFilter({ id, data }) {\n+  return {\n+    type: types.UPDATE_ACTIVE_FILTER,\n+    payload: { id, data },\n+  };\n+}\n+\n+/**\n+ * @method updateWidgetShown\n+ * @summary Updates the widgetShown in the store for the corresponding entity id with a boolean value\n+ */\n+export function updateWidgetShown({ id, data }) {\n+  return {\n+    type: types.UPDATE_WIDGET_SHOWN,\n+    payload: { id, data },\n+  };\n+}\n+\n+/**\n+ * @method clearStaticFilters\n+ * @summary Clears the existing static filters for a filter branch in the redux store\n+ */\n+export function clearStaticFilters({ filterId, data }) {\n+  return {\n+    type: types.CLEAR_STATIC_FILTERS,\n+    payload: { filterId, data },\n+  };\n+}\n+\n+/**\n+ * @method getParentFilter\n+ * @summary as the name suggests the function is retrieving the filter data by key from the filterData\n+ * @param {string} filterId - key identifying the filter\n+ * @param {array} filterData array that contains all the filters as they are retrieved from the BE\n+ */\n+function getParentFilter({ filterId, filterData }) {\n+  let parentFilter = {};\n+  filterData.forEach((filter) => {\n+    if (filter.filterId && filter.filterId === filterId) {\n+      parentFilter = filter;\n+    }\n+    if (filter.includedFilters) {\n+      filter.includedFilters.forEach((incFilter) => {\n+        if (incFilter.filterId && incFilter.filterId === filterId) {\n+          parentFilter = incFilter;\n+        }\n+      });\n+    }\n+  });\n+  return parentFilter;\n+}\n+\n+/**\n+ * @method populateFiltersCaptions\n+ * @summary updates the filtersCaptions object for the corresponding filter branch id in the store\n+ * @param {string} id - filter id used as identifier for the filters branch\n+ * @param {object} data - object containing the captions\n+ */\n+export function populateFiltersCaptions(filters) {\n+  const filtersCaptions = {};\n+  if (!filters) return {};\n+  const { filterData, filtersActive } = filters;\n+  if (!filtersActive) return {};\n+\n+  if (filtersActive.length) {\n+    const removeDefault = {};\n+\n+    filtersActive.forEach((filter, filterId) => {\n+      let captionsArray = ['', ''];\n+\n+      if (filter.parameters && filter.parameters.length) {\n+        filter.parameters.forEach((filterParameter) => {\n+          const { value, parameterName, defaultValue } = filterParameter;\n+\n+          if (!defaultValue && filterData) {\n+            // we don't want to show captions, nor show filter button as active for default values\n+            removeDefault[filterId] = true;\n+            const parentFilter = getParentFilter({\n+              filterId: filter.filterId, // we pass the actual key not the index\n+              filterData,\n+            });\n+\n+            const filterParameter = parentFilter.parameters.find(\n+              (param) => param.parameterName === parameterName\n+            );\n+            let captionName = filterParameter.caption;\n+            let itemCaption = filterParameter.caption;\n+\n+            switch (filterParameter.widgetType) {\n+              case 'Text':\n+                captionName = value;\n+\n+                if (!value) {\n+                  captionName = '';\n+                  itemCaption = '';\n+                }\n+                break;\n+              case 'Lookup':\n+              case 'List':\n+                captionName = value && value.caption;\n+                break;\n+              case 'Labels':\n+                captionName = value.values.reduce((caption, item) => {\n+                  return `${caption}, ${item.caption}`;\n+                }, '');\n+                break;\n+              case 'YesNo':\n+                if (value === null) {\n+                  captionName = '';\n+                  itemCaption = '';\n+                }\n+                break;\n+              case 'Switch':\n+              default:\n+                if (!value) {\n+                  captionName = '';\n+                  itemCaption = '';\n+                }\n+                break;\n+            }\n+\n+            if (captionName) {\n+              captionsArray[0] = captionsArray[0]\n+                ? `${captionsArray[0]}, ${captionName}`\n+                : captionName;\n+            }\n+\n+            if (itemCaption) {\n+              captionsArray[1] = captionsArray[1]\n+                ? `${captionsArray[1]}, ${itemCaption}`\n+                : itemCaption;\n+            }\n+          }\n+        });\n+      } else {\n+        const originalFilter = filterData.filter(\n+          (item) => item.filterId === filterId\n+        );\n+        captionsArray = [originalFilter.caption, originalFilter.caption];\n+      }\n+\n+      if (captionsArray.join('').length) {\n+        filtersCaptions[filter.filterId] = captionsArray;\n+        filtersCaptions[filterId] = captionsArray;\n+      }\n+    });\n+  }\n+\n+  return filtersCaptions;\n+}\n+\n+/**\n+ * @method filtersToMap\n+ * @summary creates a map with the filters fetched from the layout request\n+ */\n+export function filtersToMap(filtersArray) {\n+  let filtersMap = iMap();\n+\n+  if (filtersArray && filtersArray.length) {\n+    filtersArray.forEach((filter) => {\n+      filtersMap = filtersMap.set(filter.filterId, filter);\n+    });\n+  }\n+  return filtersMap;\n+}\n+\n+/**\n+ * @method filtersActiveContains\n+ * @summary returns a boolean value depending on the presence of the key withing the activeFilters passed array\n+ */\n+export function filtersActiveContains({ filtersActive, key }) {\n+  if (filtersActive.lenght === 0) return false;\n+  const isPresent = filtersActive.filter((item) => item.filterId === key);\n+  return isPresent.length ? true : false;\n+}\n+\n+/**\n+ * @method setNewFiltersActive\n+ * @summary returns a new array with filters that are going to be the active ones\n+ */\n+export function setNewFiltersActive({ storeActiveFilters, filterToAdd }) {\n+  storeActiveFilters = deepUnfreeze(storeActiveFilters);\n+  if (\n+    !storeActiveFilters.length ||\n+    !foundAmongActiveFilters({ storeActiveFilters, filterToAdd })\n+  ) {\n+    storeActiveFilters.push(filterToAdd);\n+  } else {\n+    storeActiveFilters.forEach((activeFilter, index) => {\n+      if (activeFilter.filterId === filterToAdd.filterId) {\n+        storeActiveFilters[index] = filterToAdd;\n+      }\n+    });\n+  }\n+  return storeActiveFilters;\n+}\n+\n+/**\n+ * @method foundAmongActiveFilters\n+ * @summary checks that the filterToAdd is found among the storeActiveFilters\n+ */\n+function foundAmongActiveFilters({ storeActiveFilters, filterToAdd }) {\n+  let isPresent = false;\n+  storeActiveFilters.forEach((item) => {\n+    if (item.filterId === filterToAdd.filterId) isPresent = true;\n+  });\n+  return isPresent;\n+}\n+\n+/**\n+ * @method isFilterActive\n+ * @summary Check within the active filters array if filterId given as param is active\n+ * @param {string} filterId\n+ * @param {array} activeFilter\n+ */\n+export function isFilterActive({ filterId, filtersActive }) {\n+  if (filtersActive) {\n+    // filters with only defaultValues shouldn't be set to active\n+    const active = filtersActive.find(\n+      (item) => item.filterId === filterId && !item.defaultVal\n+    );\n+\n+    return typeof active !== 'undefined';\n+  }\n+\n+  return false;\n+}\n+\n+/**\n+ * @method annotateFilters\n+ * @summary Creates caption for active filters to show when the widget is closed\n+ * @param {array} unannotatedFilters\n+ * @param {array} filtersActive\n+ */\n+export function annotateFilters({ unannotatedFilters, filtersActive }) {\n+  filtersActive = filtersActive ? filtersActive : [];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aca6e4a591072da112d61083ebccc3a36f0e0724"}, "originalPosition": 290}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMxODkwNg==", "bodyText": "As far as I understand this was divided into smaller functions. Comments were also carried over, right ?", "url": "https://github.com/metasfresh/metasfresh/pull/9870#discussion_r498318906", "createdAt": "2020-10-01T15:08:24Z", "author": {"login": "siemiatj"}, "path": "frontend/src/components/filters/Filters.js", "diffHunk": "@@ -2,604 +2,131 @@ import counterpart from 'counterpart';\n import PropTypes from 'prop-types';\n import React, { PureComponent } from 'react';\n import { connect } from 'react-redux';\n-// -- using iMap from immutable\n-import { Map as iMap } from 'immutable';\n-import _ from 'lodash';\n-\n-import { DATE_FIELDS } from '../../constants/Constants';\n import {\n-  generateMomentObj,\n-  getFormatForDateField,\n-} from '../widget/RawWidgetHelpers';\n-import { parseDateWithCurrentTimezone } from '../../utils/documentListHelper';\n-import { fieldValueToString } from '../../utils/tableHelpers';\n+  updateWidgetShown,\n+  setNewFiltersActive,\n+  updateActiveFilter,\n+  clearAllFilters,\n+  annotateFilters,\n+  isFilterValid,\n+  updateNotValidFields,\n+  parseToPatch,\n+} from '../../actions/FiltersActions';\n+\n import FiltersFrequent from './FiltersFrequent';\n import FiltersNotFrequent from './FiltersNotFrequent';\n-\n-/**\n- * @method parseDateToReadable\n- * @summary ToDo: Describe the method\n- * @param {*} widgetType\n- * @param {*} value\n- * @todo Write the documentation\n- */\n-export function parseDateToReadable(widgetType, value) {\n-  if (DATE_FIELDS.indexOf(widgetType) > -1) {\n-    return parseDateWithCurrentTimezone(value, widgetType);\n-  }\n-  return value;\n-}\n+import deepUnfreeze from 'deep-unfreeze';\n+import { getEntityRelatedId } from '../../reducers/filters';\n \n /**\n  * @file Class based component.\n  * @module Filters\n- * @extends Component\n+ * @extends PureComponent\n  */\n class Filters extends PureComponent {\n-  state = {\n-    activeFilter: null,\n-    activeFiltersCaptions: null,\n-    flatFiltersMap: null,\n-    notValidFields: null,\n-    widgetShown: false,\n-  };\n-\n-  /**\n-   * @method UNSAFE_componentWillReceiveProps\n-   * @summary ToDo: Describe the method\n-   */\n-  UNSAFE_componentWillReceiveProps() {\n-    this.parseActiveFilters();\n-  }\n-\n-  /**\n-   * @method componentDidMount\n-   * @summary ToDo: Describe the method\n-   */\n-  componentDidMount() {\n-    this.parseActiveFilters();\n-  }\n-\n-  /**\n-   * @method arrangeFilters\n-   * @summary combines the filters and also removes the other actives ones from same group\n-   */\n-  arrangeFilters = (filterData) => {\n-    let combinedFilters = [];\n-    for (const [key] of filterData.entries()) {\n-      let item = filterData.get(key);\n-      if (typeof item.includedFilters !== 'undefined') {\n-        combinedFilters.push(...item.includedFilters);\n-      } else {\n-        combinedFilters.push(item);\n-      }\n-    }\n-    let mappedFiltersData = new Map();\n-    combinedFilters.forEach((item) => {\n-      mappedFiltersData.set(item.filterId, item);\n-    });\n-    return mappedFiltersData;\n-  };\n-\n-  // PARSING FILTERS ---------------------------------------------------------\n-\n-  /*\n-   * parseActiveFilters - this function does three things:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aca6e4a591072da112d61083ebccc3a36f0e0724"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMxOTg2OQ==", "bodyText": "Well it doesn't really update the docList, since filters are in the store and DL should react automatically.", "url": "https://github.com/metasfresh/metasfresh/pull/9870#discussion_r498319869", "createdAt": "2020-10-01T15:09:44Z", "author": {"login": "siemiatj"}, "path": "frontend/src/components/filters/Filters.js", "diffHunk": "@@ -2,604 +2,131 @@ import counterpart from 'counterpart';\n import PropTypes from 'prop-types';\n import React, { PureComponent } from 'react';\n import { connect } from 'react-redux';\n-// -- using iMap from immutable\n-import { Map as iMap } from 'immutable';\n-import _ from 'lodash';\n-\n-import { DATE_FIELDS } from '../../constants/Constants';\n import {\n-  generateMomentObj,\n-  getFormatForDateField,\n-} from '../widget/RawWidgetHelpers';\n-import { parseDateWithCurrentTimezone } from '../../utils/documentListHelper';\n-import { fieldValueToString } from '../../utils/tableHelpers';\n+  updateWidgetShown,\n+  setNewFiltersActive,\n+  updateActiveFilter,\n+  clearAllFilters,\n+  annotateFilters,\n+  isFilterValid,\n+  updateNotValidFields,\n+  parseToPatch,\n+} from '../../actions/FiltersActions';\n+\n import FiltersFrequent from './FiltersFrequent';\n import FiltersNotFrequent from './FiltersNotFrequent';\n-\n-/**\n- * @method parseDateToReadable\n- * @summary ToDo: Describe the method\n- * @param {*} widgetType\n- * @param {*} value\n- * @todo Write the documentation\n- */\n-export function parseDateToReadable(widgetType, value) {\n-  if (DATE_FIELDS.indexOf(widgetType) > -1) {\n-    return parseDateWithCurrentTimezone(value, widgetType);\n-  }\n-  return value;\n-}\n+import deepUnfreeze from 'deep-unfreeze';\n+import { getEntityRelatedId } from '../../reducers/filters';\n \n /**\n  * @file Class based component.\n  * @module Filters\n- * @extends Component\n+ * @extends PureComponent\n  */\n class Filters extends PureComponent {\n-  state = {\n-    activeFilter: null,\n-    activeFiltersCaptions: null,\n-    flatFiltersMap: null,\n-    notValidFields: null,\n-    widgetShown: false,\n-  };\n-\n-  /**\n-   * @method UNSAFE_componentWillReceiveProps\n-   * @summary ToDo: Describe the method\n-   */\n-  UNSAFE_componentWillReceiveProps() {\n-    this.parseActiveFilters();\n-  }\n-\n-  /**\n-   * @method componentDidMount\n-   * @summary ToDo: Describe the method\n-   */\n-  componentDidMount() {\n-    this.parseActiveFilters();\n-  }\n-\n-  /**\n-   * @method arrangeFilters\n-   * @summary combines the filters and also removes the other actives ones from same group\n-   */\n-  arrangeFilters = (filterData) => {\n-    let combinedFilters = [];\n-    for (const [key] of filterData.entries()) {\n-      let item = filterData.get(key);\n-      if (typeof item.includedFilters !== 'undefined') {\n-        combinedFilters.push(...item.includedFilters);\n-      } else {\n-        combinedFilters.push(item);\n-      }\n-    }\n-    let mappedFiltersData = new Map();\n-    combinedFilters.forEach((item) => {\n-      mappedFiltersData.set(item.filterId, item);\n-    });\n-    return mappedFiltersData;\n-  };\n-\n-  // PARSING FILTERS ---------------------------------------------------------\n-\n-  /*\n-   * parseActiveFilters - this function does three things:\n-   *  - creates a flat map of existing filter fields to store the widgetType for\n-        further processing\n-   *  - creates a local copy of active filters object including filters that\n-   *    only have defaultValues set. `defaultVal` flag tells us, that this\n-   *    filter has only defaultValues, and no values set by the user. We need\n-   *    this to ble able to differentiate between filters that should be\n-   *    indicated as active on load, or not.\n-   *  - creates an object with captions of each active parameter per filter\n-   *\n-   * So first we traverse all filters data and perform actions in this order:\n-   *  - if filter is in active filters and parameter has no defaultValue,\n-   *    or defaultValue has been nullified by user's selection we add it\n-   *    local active filters and set the `defaultVal` flag to false\n-   *    (as it obviously was already set).\n-   *  - if filter is active check if current loop parameter is set in the\n-   *    active filters. If yes, do nothing as it'll always override the\n-   *    defaultValue\n-   *  - otherwise add parameter and filter to local active filters and set\n-   *    the `defaultVal` to true as apparently there are no values set  \n-   *  \n-   *    Update: 10 March 2020, removed the logic to set the default \n-   * \n-   */\n-  /**\n-   * @method parseActiveFilters\n-   * @summary ToDo: Describe the method\n-   */\n-  parseActiveFilters = () => {\n-    let { filtersActive, filterData, initialValuesNulled } = this.props;\n-    let activeFilters = _.cloneDeep(filtersActive);\n-\n-    // make new ES6 Map with the items from combined filters\n-    let mappedFiltersData = this.arrangeFilters(filterData);\n-    // put the resulted combined map of filters into the iMap and preserve existing functionality\n-    let filtersData = iMap(mappedFiltersData);\n-    const flatFiltersMap = {};\n-    const activeFiltersCaptions = {};\n-\n-    // find any filters with default values first and extend\n-    // activeFilters with them\n-    filtersData.forEach((filter, filterId) => {\n-      if (filter.parameters) {\n-        outerParameters: for (let parameter of filter.parameters) {\n-          const { defaultValue, parameterName, widgetType } = parameter;\n-          const nulledFilter = initialValuesNulled.get(filterId);\n-\n-          flatFiltersMap[`${filterId}-${parameterName}`] = {\n-            widgetType,\n-          };\n-\n-          const isActive = filtersActive.has(filterId);\n-\n-          if (\n-            !defaultValue ||\n-            (nulledFilter && nulledFilter.has(parameterName))\n-          ) {\n-            if (isActive) {\n-              activeFilters = activeFilters.set(filterId, {\n-                defaultVal: false,\n-                filterId,\n-                parameters: activeFilters.get(filterId).parameters,\n-              });\n-            }\n-            continue;\n-          }\n-\n-          if (isActive) {\n-            //look for existing parameterName in parameters array\n-            // skip if found as they override defaultValue ALWAYS\n-            const filterActive = activeFilters.get(filterId);\n-\n-            if (filterActive.parameters) {\n-              for (let activeParameter of filterActive.parameters) {\n-                if (activeParameter.parameterName === parameterName) {\n-                  continue outerParameters;\n-                }\n-              }\n-            }\n-          }\n-        }\n-      }\n-    });\n-\n-    if (activeFilters.size) {\n-      const removeDefault = {};\n-\n-      activeFilters.forEach((filter, filterId) => {\n-        let captionsArray = ['', ''];\n-\n-        if (filter.parameters && filter.parameters.length) {\n-          filter.parameters.forEach((filterParameter) => {\n-            const { value, parameterName, defaultValue } = filterParameter;\n-\n-            if (!defaultValue) {\n-              // we don't want to show captions, nor show filter button as active\n-              // for default values\n-              removeDefault[filterId] = true;\n-\n-              const parentFilter = filtersData.get(filterId);\n-              const filterParameter = parentFilter.parameters.find(\n-                (param) => param.parameterName === parameterName\n-              );\n-              let captionName = filterParameter.caption;\n-              let itemCaption = filterParameter.caption;\n-\n-              switch (filterParameter.widgetType) {\n-                case 'Text':\n-                  captionName = value;\n-\n-                  if (!value) {\n-                    captionName = '';\n-                    itemCaption = '';\n-                  }\n-                  break;\n-                case 'Lookup':\n-                case 'List':\n-                  captionName = value && value.caption;\n-                  break;\n-                case 'Labels':\n-                  captionName = value.values.reduce((caption, item) => {\n-                    return `${caption}, ${item.caption}`;\n-                  }, '');\n-                  break;\n-                case 'YesNo':\n-                  if (value === null) {\n-                    captionName = '';\n-                    itemCaption = '';\n-                  }\n-                  break;\n-                case 'Switch':\n-                default:\n-                  if (!value) {\n-                    captionName = '';\n-                    itemCaption = '';\n-                  }\n-                  break;\n-              }\n-\n-              if (captionName) {\n-                captionsArray[0] = captionsArray[0]\n-                  ? `${captionsArray[0]}, ${captionName}`\n-                  : captionName;\n-              }\n-\n-              if (itemCaption) {\n-                captionsArray[1] = captionsArray[1]\n-                  ? `${captionsArray[1]}, ${itemCaption}`\n-                  : itemCaption;\n-              }\n-            }\n-          });\n-        } else {\n-          const originalFilter = filtersData.get(filterId);\n-          captionsArray = [originalFilter.caption, originalFilter.caption];\n-        }\n-\n-        if (captionsArray.join('').length) {\n-          activeFiltersCaptions[filterId] = captionsArray;\n-        }\n-      });\n-\n-      // if filter has defaultValues but also some user defined ones,\n-      // we should still include it in active filters\n-      if (Object.keys(removeDefault).length) {\n-        for (let key of Object.keys(removeDefault)) {\n-          activeFilters = activeFilters.setIn([key, 'defaultVal'], false);\n-        }\n-      }\n-\n-      const cleanActiveFilter = this.cleanupActiveFilter(\n-        filterData.toIndexedSeq().toArray(),\n-        activeFilters.toIndexedSeq().toArray()\n-      );\n-\n-      this.setState({\n-        activeFilter: cleanActiveFilter,\n-        activeFiltersCaptions,\n-        flatFiltersMap,\n-      });\n-    } else {\n-      this.setState({\n-        activeFilter: null,\n-        activeFiltersCaptions: null,\n-        flatFiltersMap,\n-      });\n-    }\n-  };\n-\n-  cleanupActiveFilter = (allFilters, activeStateFilters) => {\n-    let filtersToRemove = [];\n-    activeStateFilters.forEach((activeStateFilter) => {\n-      allFilters.forEach((filterItem) => {\n-        if (Array.isArray(filterItem.includedFilters)) {\n-          let groupFilter = filterItem.includedFilters;\n-          let foundMatches = groupFilter.filter(\n-            (gFilterItem) => gFilterItem.filterId === activeStateFilter.filterId\n-          );\n-          if (foundMatches.length > 0) {\n-            filtersToRemove = groupFilter.filter(\n-              (toRemove) => toRemove.filterId !== activeStateFilter.filterId\n-            );\n-          }\n-        }\n-      });\n-    });\n-    return activeStateFilters.filter(\n-      (asFilterItem) =>\n-        !this.isBlacklisted(asFilterItem.filterId, filtersToRemove)\n-    );\n-  };\n-\n-  /**\n-   * @method isBlackListed\n-   * @summary Check if the filterId is found among the filters to remove array\n-   * @param {string filterId\n-   * @param {array} filtersToRemove\n-   */\n-  isBlacklisted = (filterId, filtersToRemove) => {\n-    let resultValue = false;\n-    filtersToRemove.forEach((filterItem) => {\n-      if (filterItem.filterId === filterId) {\n-        resultValue = true;\n-      }\n-    });\n-    return resultValue;\n-  };\n-\n-  /**\n-   * @method sortFilters\n-   * @summary ToDo: Describe the method\n-   * @param {array} data\n-   */\n-  sortFilters = (data) => {\n-    return {\n-      frequentFilters: this.annotateFilters(\n-        data\n-          .filter((filter) => filter.frequent)\n-          .toIndexedSeq()\n-          .toArray()\n-      ),\n-      notFrequentFilters: this.annotateFilters(\n-        data\n-          .filter((filter) => !filter.frequent && !filter.static)\n-          .toIndexedSeq()\n-          .toArray()\n-      ),\n-      staticFilters: this.annotateFilters(\n-        data.filter((filter) => filter.static)\n-      )\n-        .toIndexedSeq()\n-        .toArray(),\n-    };\n-  };\n-\n-  /**\n-   * @method isFilterValid\n-   * @summary ToDo: Describe the method\n-   * @param {*} filters\n-   */\n-  isFilterValid = (filters) => {\n-    if (filters.parameters) {\n-      return !filters.parameters.filter((item) => item.mandatory && !item.value)\n-        .length;\n-    }\n-\n-    return true;\n-  };\n-\n-  /**\n-   * @method isFilterActive\n-   * @summary ToDo: Describe the method\n-   * @param {*} filterId\n-   */\n-  isFilterActive = (filterId) => {\n-    const { activeFilter } = this.state;\n-\n-    if (activeFilter) {\n-      // filters with only defaultValues shouldn't be set to active\n-      const active = activeFilter.find(\n-        (item) => item.filterId === filterId && !item.defaultVal\n-      );\n-\n-      return typeof active !== 'undefined';\n-    }\n-\n-    return false;\n-  };\n-\n-  /**\n-   * @method parseToPatch\n-   * @summary ToDo: Describe the method\n-   * @param {*} params\n-   */\n-  parseToPatch = (params) => {\n-    return params.reduce((acc, param) => {\n-      if (\n-        // filters with only defaltValue shouldn't be sent to server\n-        !param.defaultValue ||\n-        JSON.stringify(param.defaultValue) !== JSON.stringify(param.value)\n-      ) {\n-        acc.push({\n-          ...param,\n-          value: param.value === '' ? null : param.value,\n-        });\n-      }\n-\n-      return acc;\n-    }, []);\n-  };\n-\n-  // SETTING FILTERS  --------------------------------------------------------\n   /**\n    * @method applyFilters\n    * @summary This method should update docList", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aca6e4a591072da112d61083ebccc3a36f0e0724"}, "originalPosition": 413}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMyMzU2OQ==", "bodyText": "is there a case, where we set new active filter without updating active filter ? Maybe setNewFiltersActive should call updateActiveFilter ?", "url": "https://github.com/metasfresh/metasfresh/pull/9870#discussion_r498323569", "createdAt": "2020-10-01T15:14:52Z", "author": {"login": "siemiatj"}, "path": "frontend/src/components/filters/Filters.js", "diffHunk": "@@ -2,604 +2,131 @@ import counterpart from 'counterpart';\n import PropTypes from 'prop-types';\n import React, { PureComponent } from 'react';\n import { connect } from 'react-redux';\n-// -- using iMap from immutable\n-import { Map as iMap } from 'immutable';\n-import _ from 'lodash';\n-\n-import { DATE_FIELDS } from '../../constants/Constants';\n import {\n-  generateMomentObj,\n-  getFormatForDateField,\n-} from '../widget/RawWidgetHelpers';\n-import { parseDateWithCurrentTimezone } from '../../utils/documentListHelper';\n-import { fieldValueToString } from '../../utils/tableHelpers';\n+  updateWidgetShown,\n+  setNewFiltersActive,\n+  updateActiveFilter,\n+  clearAllFilters,\n+  annotateFilters,\n+  isFilterValid,\n+  updateNotValidFields,\n+  parseToPatch,\n+} from '../../actions/FiltersActions';\n+\n import FiltersFrequent from './FiltersFrequent';\n import FiltersNotFrequent from './FiltersNotFrequent';\n-\n-/**\n- * @method parseDateToReadable\n- * @summary ToDo: Describe the method\n- * @param {*} widgetType\n- * @param {*} value\n- * @todo Write the documentation\n- */\n-export function parseDateToReadable(widgetType, value) {\n-  if (DATE_FIELDS.indexOf(widgetType) > -1) {\n-    return parseDateWithCurrentTimezone(value, widgetType);\n-  }\n-  return value;\n-}\n+import deepUnfreeze from 'deep-unfreeze';\n+import { getEntityRelatedId } from '../../reducers/filters';\n \n /**\n  * @file Class based component.\n  * @module Filters\n- * @extends Component\n+ * @extends PureComponent\n  */\n class Filters extends PureComponent {\n-  state = {\n-    activeFilter: null,\n-    activeFiltersCaptions: null,\n-    flatFiltersMap: null,\n-    notValidFields: null,\n-    widgetShown: false,\n-  };\n-\n-  /**\n-   * @method UNSAFE_componentWillReceiveProps\n-   * @summary ToDo: Describe the method\n-   */\n-  UNSAFE_componentWillReceiveProps() {\n-    this.parseActiveFilters();\n-  }\n-\n-  /**\n-   * @method componentDidMount\n-   * @summary ToDo: Describe the method\n-   */\n-  componentDidMount() {\n-    this.parseActiveFilters();\n-  }\n-\n-  /**\n-   * @method arrangeFilters\n-   * @summary combines the filters and also removes the other actives ones from same group\n-   */\n-  arrangeFilters = (filterData) => {\n-    let combinedFilters = [];\n-    for (const [key] of filterData.entries()) {\n-      let item = filterData.get(key);\n-      if (typeof item.includedFilters !== 'undefined') {\n-        combinedFilters.push(...item.includedFilters);\n-      } else {\n-        combinedFilters.push(item);\n-      }\n-    }\n-    let mappedFiltersData = new Map();\n-    combinedFilters.forEach((item) => {\n-      mappedFiltersData.set(item.filterId, item);\n-    });\n-    return mappedFiltersData;\n-  };\n-\n-  // PARSING FILTERS ---------------------------------------------------------\n-\n-  /*\n-   * parseActiveFilters - this function does three things:\n-   *  - creates a flat map of existing filter fields to store the widgetType for\n-        further processing\n-   *  - creates a local copy of active filters object including filters that\n-   *    only have defaultValues set. `defaultVal` flag tells us, that this\n-   *    filter has only defaultValues, and no values set by the user. We need\n-   *    this to ble able to differentiate between filters that should be\n-   *    indicated as active on load, or not.\n-   *  - creates an object with captions of each active parameter per filter\n-   *\n-   * So first we traverse all filters data and perform actions in this order:\n-   *  - if filter is in active filters and parameter has no defaultValue,\n-   *    or defaultValue has been nullified by user's selection we add it\n-   *    local active filters and set the `defaultVal` flag to false\n-   *    (as it obviously was already set).\n-   *  - if filter is active check if current loop parameter is set in the\n-   *    active filters. If yes, do nothing as it'll always override the\n-   *    defaultValue\n-   *  - otherwise add parameter and filter to local active filters and set\n-   *    the `defaultVal` to true as apparently there are no values set  \n-   *  \n-   *    Update: 10 March 2020, removed the logic to set the default \n-   * \n-   */\n-  /**\n-   * @method parseActiveFilters\n-   * @summary ToDo: Describe the method\n-   */\n-  parseActiveFilters = () => {\n-    let { filtersActive, filterData, initialValuesNulled } = this.props;\n-    let activeFilters = _.cloneDeep(filtersActive);\n-\n-    // make new ES6 Map with the items from combined filters\n-    let mappedFiltersData = this.arrangeFilters(filterData);\n-    // put the resulted combined map of filters into the iMap and preserve existing functionality\n-    let filtersData = iMap(mappedFiltersData);\n-    const flatFiltersMap = {};\n-    const activeFiltersCaptions = {};\n-\n-    // find any filters with default values first and extend\n-    // activeFilters with them\n-    filtersData.forEach((filter, filterId) => {\n-      if (filter.parameters) {\n-        outerParameters: for (let parameter of filter.parameters) {\n-          const { defaultValue, parameterName, widgetType } = parameter;\n-          const nulledFilter = initialValuesNulled.get(filterId);\n-\n-          flatFiltersMap[`${filterId}-${parameterName}`] = {\n-            widgetType,\n-          };\n-\n-          const isActive = filtersActive.has(filterId);\n-\n-          if (\n-            !defaultValue ||\n-            (nulledFilter && nulledFilter.has(parameterName))\n-          ) {\n-            if (isActive) {\n-              activeFilters = activeFilters.set(filterId, {\n-                defaultVal: false,\n-                filterId,\n-                parameters: activeFilters.get(filterId).parameters,\n-              });\n-            }\n-            continue;\n-          }\n-\n-          if (isActive) {\n-            //look for existing parameterName in parameters array\n-            // skip if found as they override defaultValue ALWAYS\n-            const filterActive = activeFilters.get(filterId);\n-\n-            if (filterActive.parameters) {\n-              for (let activeParameter of filterActive.parameters) {\n-                if (activeParameter.parameterName === parameterName) {\n-                  continue outerParameters;\n-                }\n-              }\n-            }\n-          }\n-        }\n-      }\n-    });\n-\n-    if (activeFilters.size) {\n-      const removeDefault = {};\n-\n-      activeFilters.forEach((filter, filterId) => {\n-        let captionsArray = ['', ''];\n-\n-        if (filter.parameters && filter.parameters.length) {\n-          filter.parameters.forEach((filterParameter) => {\n-            const { value, parameterName, defaultValue } = filterParameter;\n-\n-            if (!defaultValue) {\n-              // we don't want to show captions, nor show filter button as active\n-              // for default values\n-              removeDefault[filterId] = true;\n-\n-              const parentFilter = filtersData.get(filterId);\n-              const filterParameter = parentFilter.parameters.find(\n-                (param) => param.parameterName === parameterName\n-              );\n-              let captionName = filterParameter.caption;\n-              let itemCaption = filterParameter.caption;\n-\n-              switch (filterParameter.widgetType) {\n-                case 'Text':\n-                  captionName = value;\n-\n-                  if (!value) {\n-                    captionName = '';\n-                    itemCaption = '';\n-                  }\n-                  break;\n-                case 'Lookup':\n-                case 'List':\n-                  captionName = value && value.caption;\n-                  break;\n-                case 'Labels':\n-                  captionName = value.values.reduce((caption, item) => {\n-                    return `${caption}, ${item.caption}`;\n-                  }, '');\n-                  break;\n-                case 'YesNo':\n-                  if (value === null) {\n-                    captionName = '';\n-                    itemCaption = '';\n-                  }\n-                  break;\n-                case 'Switch':\n-                default:\n-                  if (!value) {\n-                    captionName = '';\n-                    itemCaption = '';\n-                  }\n-                  break;\n-              }\n-\n-              if (captionName) {\n-                captionsArray[0] = captionsArray[0]\n-                  ? `${captionsArray[0]}, ${captionName}`\n-                  : captionName;\n-              }\n-\n-              if (itemCaption) {\n-                captionsArray[1] = captionsArray[1]\n-                  ? `${captionsArray[1]}, ${itemCaption}`\n-                  : itemCaption;\n-              }\n-            }\n-          });\n-        } else {\n-          const originalFilter = filtersData.get(filterId);\n-          captionsArray = [originalFilter.caption, originalFilter.caption];\n-        }\n-\n-        if (captionsArray.join('').length) {\n-          activeFiltersCaptions[filterId] = captionsArray;\n-        }\n-      });\n-\n-      // if filter has defaultValues but also some user defined ones,\n-      // we should still include it in active filters\n-      if (Object.keys(removeDefault).length) {\n-        for (let key of Object.keys(removeDefault)) {\n-          activeFilters = activeFilters.setIn([key, 'defaultVal'], false);\n-        }\n-      }\n-\n-      const cleanActiveFilter = this.cleanupActiveFilter(\n-        filterData.toIndexedSeq().toArray(),\n-        activeFilters.toIndexedSeq().toArray()\n-      );\n-\n-      this.setState({\n-        activeFilter: cleanActiveFilter,\n-        activeFiltersCaptions,\n-        flatFiltersMap,\n-      });\n-    } else {\n-      this.setState({\n-        activeFilter: null,\n-        activeFiltersCaptions: null,\n-        flatFiltersMap,\n-      });\n-    }\n-  };\n-\n-  cleanupActiveFilter = (allFilters, activeStateFilters) => {\n-    let filtersToRemove = [];\n-    activeStateFilters.forEach((activeStateFilter) => {\n-      allFilters.forEach((filterItem) => {\n-        if (Array.isArray(filterItem.includedFilters)) {\n-          let groupFilter = filterItem.includedFilters;\n-          let foundMatches = groupFilter.filter(\n-            (gFilterItem) => gFilterItem.filterId === activeStateFilter.filterId\n-          );\n-          if (foundMatches.length > 0) {\n-            filtersToRemove = groupFilter.filter(\n-              (toRemove) => toRemove.filterId !== activeStateFilter.filterId\n-            );\n-          }\n-        }\n-      });\n-    });\n-    return activeStateFilters.filter(\n-      (asFilterItem) =>\n-        !this.isBlacklisted(asFilterItem.filterId, filtersToRemove)\n-    );\n-  };\n-\n-  /**\n-   * @method isBlackListed\n-   * @summary Check if the filterId is found among the filters to remove array\n-   * @param {string filterId\n-   * @param {array} filtersToRemove\n-   */\n-  isBlacklisted = (filterId, filtersToRemove) => {\n-    let resultValue = false;\n-    filtersToRemove.forEach((filterItem) => {\n-      if (filterItem.filterId === filterId) {\n-        resultValue = true;\n-      }\n-    });\n-    return resultValue;\n-  };\n-\n-  /**\n-   * @method sortFilters\n-   * @summary ToDo: Describe the method\n-   * @param {array} data\n-   */\n-  sortFilters = (data) => {\n-    return {\n-      frequentFilters: this.annotateFilters(\n-        data\n-          .filter((filter) => filter.frequent)\n-          .toIndexedSeq()\n-          .toArray()\n-      ),\n-      notFrequentFilters: this.annotateFilters(\n-        data\n-          .filter((filter) => !filter.frequent && !filter.static)\n-          .toIndexedSeq()\n-          .toArray()\n-      ),\n-      staticFilters: this.annotateFilters(\n-        data.filter((filter) => filter.static)\n-      )\n-        .toIndexedSeq()\n-        .toArray(),\n-    };\n-  };\n-\n-  /**\n-   * @method isFilterValid\n-   * @summary ToDo: Describe the method\n-   * @param {*} filters\n-   */\n-  isFilterValid = (filters) => {\n-    if (filters.parameters) {\n-      return !filters.parameters.filter((item) => item.mandatory && !item.value)\n-        .length;\n-    }\n-\n-    return true;\n-  };\n-\n-  /**\n-   * @method isFilterActive\n-   * @summary ToDo: Describe the method\n-   * @param {*} filterId\n-   */\n-  isFilterActive = (filterId) => {\n-    const { activeFilter } = this.state;\n-\n-    if (activeFilter) {\n-      // filters with only defaultValues shouldn't be set to active\n-      const active = activeFilter.find(\n-        (item) => item.filterId === filterId && !item.defaultVal\n-      );\n-\n-      return typeof active !== 'undefined';\n-    }\n-\n-    return false;\n-  };\n-\n-  /**\n-   * @method parseToPatch\n-   * @summary ToDo: Describe the method\n-   * @param {*} params\n-   */\n-  parseToPatch = (params) => {\n-    return params.reduce((acc, param) => {\n-      if (\n-        // filters with only defaltValue shouldn't be sent to server\n-        !param.defaultValue ||\n-        JSON.stringify(param.defaultValue) !== JSON.stringify(param.value)\n-      ) {\n-        acc.push({\n-          ...param,\n-          value: param.value === '' ? null : param.value,\n-        });\n-      }\n-\n-      return acc;\n-    }, []);\n-  };\n-\n-  // SETTING FILTERS  --------------------------------------------------------\n   /**\n    * @method applyFilters\n    * @summary This method should update docList\n-   * @param {*} isActive\n-   * @param {*} captionValue\n    * @param {object} filter\n-   * @param {*} cb\n-   */\n-  // eslint-disable-next-line no-unused-vars\n-  applyFilters = ({ isActive, captionValue, ...filter }, cb) => {\n-    const valid = this.isFilterValid(filter);\n-\n-    this.setState(\n-      {\n-        notValidFields: !valid,\n-      },\n-      () => {\n-        if (valid) {\n-          const parsedFilter = filter.parameters\n-            ? {\n-                ...filter,\n-                parameters: this.parseToPatch(filter.parameters),\n-              }\n-            : filter;\n+   * @param {function} cb - executed if filter is valid and after it was applied\n+   */\n+  applyFilters = ({ ...filter }, cb) => {\n+    const valid = isFilterValid(filter);\n+    const { updateNotValidFields, filterId } = this.props;\n+\n+    updateNotValidFields({ filterId, data: !valid });\n+    if (valid) {\n+      const parsedFilter = filter.parameters\n+        ? {\n+            ...filter,\n+            parameters: parseToPatch(filter.parameters),\n+          }\n+        : filter;\n \n-          this.setFilterActive(parsedFilter);\n+      this.setFilterActive(parsedFilter);\n \n-          cb && cb();\n-        }\n-      }\n-    );\n+      cb && cb();\n+    }\n   };\n \n   /**\n    * @method setFilterActive\n-   * @summary This function merges new filters that are to be activated with the existing\n-   *  active filters. Additionally we format date fields accordingly so that the backend\n-   *  accepts them.\n+   * @summary This function updates the active filters we set and then triggers the pre-existing\n+   *          logic from DocList that will fetch the filtered data\n    * @param {object} filterToAdd\n    */\n   setFilterActive = (filterToAdd) => {\n-    const { updateDocList } = this.props;\n-    let { filtersActive } = this.props;\n-    const { flatFiltersMap } = this.state;\n-    let activeFilters = iMap(filtersActive);\n-\n-    activeFilters = activeFilters.filter(\n-      (item, id) => id !== filterToAdd.filterId\n-    );\n-    activeFilters = activeFilters.set(filterToAdd.filterId, filterToAdd);\n-\n-    if (flatFiltersMap) {\n-      activeFilters = activeFilters.map((filter, filterId) => {\n-        filter.parameters &&\n-          filter.parameters.forEach((parameter) => {\n-            const { value, valueTo, parameterName } = parameter;\n-            const singleFilter = flatFiltersMap[`${filterId}-${parameterName}`];\n-\n-            if (\n-              singleFilter &&\n-              DATE_FIELDS.indexOf(singleFilter.widgetType) > -1\n-            ) {\n-              const format = getFormatForDateField(singleFilter.widgetType);\n-\n-              if (value) {\n-                parameter.value = generateMomentObj(value, format);\n-              }\n-              if (valueTo) {\n-                parameter.valueTo = generateMomentObj(valueTo, format);\n-              }\n-            }\n-          });\n+    const { updateDocList, filterId, updateActiveFilter } = this.props;\n+    const { filtersActive: storeActiveFilters } = this.props.filters;\n \n-        return filter;\n-      });\n-    }\n+    // updating the active filters from the redux store with the filter passed as param\n+    const newFiltersActive = setNewFiltersActive({", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aca6e4a591072da112d61083ebccc3a36f0e0724"}, "originalPosition": 509}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMyOTQxNQ==", "bodyText": "Why remove the proptypes comments ?", "url": "https://github.com/metasfresh/metasfresh/pull/9870#discussion_r498329415", "createdAt": "2020-10-01T15:22:52Z", "author": {"login": "siemiatj"}, "path": "frontend/src/components/filters/Filters.js", "diffHunk": "@@ -678,37 +206,43 @@ class Filters extends PureComponent {\n   }\n }\n \n-/**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aca6e4a591072da112d61083ebccc3a36f0e0724"}, "originalPosition": 701}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMzMDYzMg==", "bodyText": "Why not move logic from outsideClick here and remove it completely ?", "url": "https://github.com/metasfresh/metasfresh/pull/9870#discussion_r498330632", "createdAt": "2020-10-01T15:24:35Z", "author": {"login": "siemiatj"}, "path": "frontend/src/components/filters/FiltersFrequent.js", "diffHunk": "@@ -57,9 +50,7 @@ class FiltersFrequent extends PureComponent {\n    * @summary ToDo: Describe the method\n    * @todo Write the documentation\n    */\n-  handleClickOutside = () => {\n-    this.outsideClick();\n-  };\n+  handleClickOutside = () => this.outsideClick();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aca6e4a591072da112d61083ebccc3a36f0e0724"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMzMjUzNQ==", "bodyText": "?", "url": "https://github.com/metasfresh/metasfresh/pull/9870#discussion_r498332535", "createdAt": "2020-10-01T15:27:03Z", "author": {"login": "siemiatj"}, "path": "frontend/src/containers/DocumentList.js", "diffHunk": "@@ -1,3 +1,4 @@\n+/* eslint-disable prettier/prettier */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aca6e4a591072da112d61083ebccc3a36f0e0724"}, "originalPosition": 1}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fcb77b0c45466be1ed84b992f47cce3f86fe2b25", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/fcb77b0c45466be1ed84b992f47cce3f86fe2b25", "committedDate": "2020-10-02T05:50:25Z", "message": "Merge branch 'master' into 9853-filtersRefactoring"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fb63094d3deba4bab5c4397833cfa145587ba83f", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/fb63094d3deba4bab5c4397833cfa145587ba83f", "committedDate": "2020-10-02T06:12:42Z", "message": "Add FILTER in the naming to avoid future confusion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5616ae98d1fc9ace6dce91365f545ee9ed503a63", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/5616ae98d1fc9ace6dce91365f545ee9ed503a63", "committedDate": "2020-10-02T06:33:49Z", "message": "Remove prettier disabling in DocumentList"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "34b406f97bdfd62eb20262b3b60df22aead2f18d", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/34b406f97bdfd62eb20262b3b60df22aead2f18d", "committedDate": "2020-10-02T06:57:12Z", "message": "changed getParentFilter name"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "85bc8c348d81aa3e3f1b0e0e377da1ecaf0707c2", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/85bc8c348d81aa3e3f1b0e0e377da1ecaf0707c2", "committedDate": "2020-10-02T07:19:55Z", "message": "Remove outsideClick fnct"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e99ae7f56fd65ab12397fb9eeb40412eb895222d", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/e99ae7f56fd65ab12397fb9eeb40412eb895222d", "committedDate": "2020-10-02T07:32:27Z", "message": "Update the documentation of foundAmongActiveFilters fnct to avoid any confusion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8060a63e8978dba3931bc1771360ce36cb15319d", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/8060a63e8978dba3931bc1771360ce36cb15319d", "committedDate": "2020-10-02T07:44:50Z", "message": "Ditch the logic with filtersToMap"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ea105c6fa11f7117c2a3a3f847026f454222b001", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/ea105c6fa11f7117c2a3a3f847026f454222b001", "committedDate": "2020-10-02T07:46:14Z", "message": "rem immutable"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "58a7a59f35e7b4979caedfee3d2cca66ad4d1969", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/58a7a59f35e7b4979caedfee3d2cca66ad4d1969", "committedDate": "2020-10-02T09:47:37Z", "message": "Ditch more redundant code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ea3ac7ddf6eb143fb2fb7d6b87ad603131a0597f", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/ea3ac7ddf6eb143fb2fb7d6b87ad603131a0597f", "committedDate": "2020-10-02T12:18:26Z", "message": "Clear filter before applying in InlineFilterItem"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5a91045cfcf5cf40886d585b5188a498ed1af806", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/5a91045cfcf5cf40886d585b5188a498ed1af806", "committedDate": "2020-10-05T04:43:13Z", "message": "Merge branch 'master' into 9853-filtersRefactoring"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a785ec02fbeefd5f6734210b2f5fced31e7ea398", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/a785ec02fbeefd5f6734210b2f5fced31e7ea398", "committedDate": "2020-10-05T05:02:38Z", "message": "Remove comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a3de5b348a164fe24ebc650586d03748ebc6688a", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/a3de5b348a164fe24ebc650586d03748ebc6688a", "committedDate": "2020-10-05T06:37:04Z", "message": "Clean some code, rename, load fixtures for filters"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "83e86ffbfcda8fe9697a20af328b7823fd4b095b", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/83e86ffbfcda8fe9697a20af328b7823fd4b095b", "committedDate": "2020-10-05T06:47:34Z", "message": "filtersActive fixtures"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ac40f258d469a439f43bb30b3a65df3bd7a6674f", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/ac40f258d469a439f43bb30b3a65df3bd7a6674f", "committedDate": "2020-10-05T09:06:06Z", "message": "Updated the unit tests to pass mocked up data to the store"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e93d609d0e15b364ee23411d4e91c50927c75606", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/e93d609d0e15b364ee23411d4e91c50927c75606", "committedDate": "2020-10-05T09:12:32Z", "message": "Small cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c3c82c44a9857e72141287d6fba43f389eba0687", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/c3c82c44a9857e72141287d6fba43f389eba0687", "committedDate": "2020-10-05T09:42:07Z", "message": "Put an active filter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d71366cb8beb3128ce4375956450d2aa8ad6e1bd", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/d71366cb8beb3128ce4375956450d2aa8ad6e1bd", "committedDate": "2020-10-05T10:27:48Z", "message": "Remove debug line"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "05fe6b629200b380e9085fde7669d7db0a4f3b39", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/05fe6b629200b380e9085fde7669d7db0a4f3b39", "committedDate": "2020-10-05T12:14:43Z", "message": "Fix clear filters test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c16960f5c45ee6c16e30ab2f96ee1ad571f724cc", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/c16960f5c45ee6c16e30ab2f96ee1ad571f724cc", "committedDate": "2020-10-05T13:18:35Z", "message": "Sep stores for testing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "838933db6b1630a5f00f7bc201756981d696192f", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/838933db6b1630a5f00f7bc201756981d696192f", "committedDate": "2020-10-05T13:26:31Z", "message": "Prereq with 2nd store mockup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6586bfe2c35937a513d0b415b42a3f2fe55e9f97", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/6586bfe2c35937a513d0b415b42a3f2fe55e9f97", "committedDate": "2020-10-06T05:58:47Z", "message": "Update another test that failed under Filters.test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "25547bd59dc13011b44c2e4a6ee65cd1dee2dde6", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/25547bd59dc13011b44c2e4a6ee65cd1dee2dde6", "committedDate": "2020-10-06T06:08:31Z", "message": "Merge branch 'master' into 9853-filtersRefactoring"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "039d2a8e2b29c793b50d533bfdb0b3a3fb9936fc", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/039d2a8e2b29c793b50d533bfdb0b3a3fb9936fc", "committedDate": "2020-10-06T06:59:57Z", "message": "Adapted the last unit test to work"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "630747f64836b10c7f1219562a297829d4ad3ae3", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/630747f64836b10c7f1219562a297829d4ad3ae3", "committedDate": "2020-10-06T08:35:12Z", "message": "test dispatching CREATE_FILTER action"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0c98c16d5914882a0aca712a549c0ea7119f3d82", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/0c98c16d5914882a0aca712a549c0ea7119f3d82", "committedDate": "2020-10-06T09:14:54Z", "message": "Tests for CLEAR_ALL_FILTERS"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bc5651c6f34fefc01f408a96916a8ea4b38506dc", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/bc5651c6f34fefc01f408a96916a8ea4b38506dc", "committedDate": "2020-10-06T11:11:46Z", "message": "More unit tests for actions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f9bde0320bbe0e551781ccf049668b89b7b88177", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/f9bde0320bbe0e551781ccf049668b89b7b88177", "committedDate": "2020-10-06T11:48:49Z", "message": "Merge branch 'master' into 9853-filtersRefactoring"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a6f8c819c021f94395a7e18547c8eb53ca2fe20b", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/a6f8c819c021f94395a7e18547c8eb53ca2fe20b", "committedDate": "2020-10-06T12:26:39Z", "message": "Add test for updateFilterWidgetShown"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8853460af914a9c40ede88c46c173a4bd0bf2e2b", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/8853460af914a9c40ede88c46c173a4bd0bf2e2b", "committedDate": "2020-10-06T12:50:13Z", "message": "Add CLEAR_STATIC_FILTERS test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0ce95b512092885868ff785d02b76a4bf90452e5", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/0ce95b512092885868ff785d02b76a4bf90452e5", "committedDate": "2020-10-06T13:18:19Z", "message": "Add updateInlineFilter action test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyOTc5Mjcz", "url": "https://github.com/metasfresh/metasfresh/pull/9870#pullrequestreview-502979273", "createdAt": "2020-10-06T13:45:29Z", "commit": {"oid": "0ce95b512092885868ff785d02b76a4bf90452e5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxMzo0NToyOVrOHdHXFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxMzo0NToyOVrOHdHXFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDI5MTM1MA==", "bodyText": "tree ? :)", "url": "https://github.com/metasfresh/metasfresh/pull/9870#discussion_r500291350", "createdAt": "2020-10-06T13:45:29Z", "author": {"login": "siemiatj"}, "path": "frontend/src/__tests__/components/filters/Filters.test.js", "diffHunk": "@@ -269,6 +266,7 @@ describe('Filters tests', () => {\n             visible: false,\n           },\n         },\n+        filters: filtersStoreThree,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ce95b512092885868ff785d02b76a4bf90452e5"}, "originalPosition": 215}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAzMDIwNzQy", "url": "https://github.com/metasfresh/metasfresh/pull/9870#pullrequestreview-503020742", "createdAt": "2020-10-06T14:23:08Z", "commit": {"oid": "0ce95b512092885868ff785d02b76a4bf90452e5"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxNDoyMzowOFrOHdJlgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxNDozMzozNVrOHdKNdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDMyNzgwOA==", "bodyText": "Why can't this be handled by redux but instead we'll be calling this on each render and create a new js object ? Seems like we have everything we need in the filters prop.", "url": "https://github.com/metasfresh/metasfresh/pull/9870#discussion_r500327808", "createdAt": "2020-10-06T14:23:08Z", "author": {"login": "siemiatj"}, "path": "frontend/src/components/filters/Filters.js", "diffHunk": "@@ -2,604 +2,133 @@ import counterpart from 'counterpart';\n import PropTypes from 'prop-types';\n import React, { PureComponent } from 'react';\n import { connect } from 'react-redux';\n-// -- using iMap from immutable\n-import { Map as iMap } from 'immutable';\n-import _ from 'lodash';\n-\n-import { DATE_FIELDS } from '../../constants/Constants';\n import {\n-  generateMomentObj,\n-  getFormatForDateField,\n-} from '../widget/RawWidgetHelpers';\n-import { parseDateWithCurrentTimezone } from '../../utils/documentListHelper';\n-import { fieldValueToString } from '../../utils/tableHelpers';\n-import FiltersFrequent from './FiltersFrequent';\n-import FiltersNotFrequent from './FiltersNotFrequent';\n-\n-/**\n- * @method parseDateToReadable\n- * @summary ToDo: Describe the method\n- * @param {*} widgetType\n- * @param {*} value\n- * @todo Write the documentation\n- */\n-export function parseDateToReadable(widgetType, value) {\n-  if (DATE_FIELDS.indexOf(widgetType) > -1) {\n-    return parseDateWithCurrentTimezone(value, widgetType);\n-  }\n-  return value;\n-}\n+  updateFilterWidgetShown,\n+  setNewFiltersActive,\n+  updateActiveFilter,\n+  clearAllFilters,\n+  annotateFilters,\n+  isFilterValid,\n+  updateNotValidFields,\n+  parseToPatch,\n+} from '../../actions/FiltersActions';\n+\n+import FiltersNotIcluded from './FiltersNotIncluded';\n+import FiltersIncluded from './FiltersIncluded';\n+import deepUnfreeze from 'deep-unfreeze';\n+import { getEntityRelatedId } from '../../reducers/filters';\n \n /**\n  * @file Class based component.\n  * @module Filters\n- * @extends Component\n+ * @extends PureComponent\n  */\n class Filters extends PureComponent {\n-  state = {\n-    activeFilter: null,\n-    activeFiltersCaptions: null,\n-    flatFiltersMap: null,\n-    notValidFields: null,\n-    widgetShown: false,\n-  };\n-\n-  /**\n-   * @method UNSAFE_componentWillReceiveProps\n-   * @summary ToDo: Describe the method\n-   */\n-  UNSAFE_componentWillReceiveProps() {\n-    this.parseActiveFilters();\n-  }\n-\n-  /**\n-   * @method componentDidMount\n-   * @summary ToDo: Describe the method\n-   */\n-  componentDidMount() {\n-    this.parseActiveFilters();\n-  }\n-\n-  /**\n-   * @method arrangeFilters\n-   * @summary combines the filters and also removes the other actives ones from same group\n-   */\n-  arrangeFilters = (filterData) => {\n-    let combinedFilters = [];\n-    for (const [key] of filterData.entries()) {\n-      let item = filterData.get(key);\n-      if (typeof item.includedFilters !== 'undefined') {\n-        combinedFilters.push(...item.includedFilters);\n-      } else {\n-        combinedFilters.push(item);\n-      }\n-    }\n-    let mappedFiltersData = new Map();\n-    combinedFilters.forEach((item) => {\n-      mappedFiltersData.set(item.filterId, item);\n-    });\n-    return mappedFiltersData;\n-  };\n-\n-  // PARSING FILTERS ---------------------------------------------------------\n-\n-  /*\n-   * parseActiveFilters - this function does three things:\n-   *  - creates a flat map of existing filter fields to store the widgetType for\n-        further processing\n-   *  - creates a local copy of active filters object including filters that\n-   *    only have defaultValues set. `defaultVal` flag tells us, that this\n-   *    filter has only defaultValues, and no values set by the user. We need\n-   *    this to ble able to differentiate between filters that should be\n-   *    indicated as active on load, or not.\n-   *  - creates an object with captions of each active parameter per filter\n-   *\n-   * So first we traverse all filters data and perform actions in this order:\n-   *  - if filter is in active filters and parameter has no defaultValue,\n-   *    or defaultValue has been nullified by user's selection we add it\n-   *    local active filters and set the `defaultVal` flag to false\n-   *    (as it obviously was already set).\n-   *  - if filter is active check if current loop parameter is set in the\n-   *    active filters. If yes, do nothing as it'll always override the\n-   *    defaultValue\n-   *  - otherwise add parameter and filter to local active filters and set\n-   *    the `defaultVal` to true as apparently there are no values set  \n-   *  \n-   *    Update: 10 March 2020, removed the logic to set the default \n-   * \n-   */\n-  /**\n-   * @method parseActiveFilters\n-   * @summary ToDo: Describe the method\n-   */\n-  parseActiveFilters = () => {\n-    let { filtersActive, filterData, initialValuesNulled } = this.props;\n-    let activeFilters = _.cloneDeep(filtersActive);\n-\n-    // make new ES6 Map with the items from combined filters\n-    let mappedFiltersData = this.arrangeFilters(filterData);\n-    // put the resulted combined map of filters into the iMap and preserve existing functionality\n-    let filtersData = iMap(mappedFiltersData);\n-    const flatFiltersMap = {};\n-    const activeFiltersCaptions = {};\n-\n-    // find any filters with default values first and extend\n-    // activeFilters with them\n-    filtersData.forEach((filter, filterId) => {\n-      if (filter.parameters) {\n-        outerParameters: for (let parameter of filter.parameters) {\n-          const { defaultValue, parameterName, widgetType } = parameter;\n-          const nulledFilter = initialValuesNulled.get(filterId);\n-\n-          flatFiltersMap[`${filterId}-${parameterName}`] = {\n-            widgetType,\n-          };\n-\n-          const isActive = filtersActive.has(filterId);\n-\n-          if (\n-            !defaultValue ||\n-            (nulledFilter && nulledFilter.has(parameterName))\n-          ) {\n-            if (isActive) {\n-              activeFilters = activeFilters.set(filterId, {\n-                defaultVal: false,\n-                filterId,\n-                parameters: activeFilters.get(filterId).parameters,\n-              });\n-            }\n-            continue;\n-          }\n-\n-          if (isActive) {\n-            //look for existing parameterName in parameters array\n-            // skip if found as they override defaultValue ALWAYS\n-            const filterActive = activeFilters.get(filterId);\n-\n-            if (filterActive.parameters) {\n-              for (let activeParameter of filterActive.parameters) {\n-                if (activeParameter.parameterName === parameterName) {\n-                  continue outerParameters;\n-                }\n-              }\n-            }\n-          }\n-        }\n-      }\n-    });\n-\n-    if (activeFilters.size) {\n-      const removeDefault = {};\n-\n-      activeFilters.forEach((filter, filterId) => {\n-        let captionsArray = ['', ''];\n-\n-        if (filter.parameters && filter.parameters.length) {\n-          filter.parameters.forEach((filterParameter) => {\n-            const { value, parameterName, defaultValue } = filterParameter;\n-\n-            if (!defaultValue) {\n-              // we don't want to show captions, nor show filter button as active\n-              // for default values\n-              removeDefault[filterId] = true;\n-\n-              const parentFilter = filtersData.get(filterId);\n-              const filterParameter = parentFilter.parameters.find(\n-                (param) => param.parameterName === parameterName\n-              );\n-              let captionName = filterParameter.caption;\n-              let itemCaption = filterParameter.caption;\n-\n-              switch (filterParameter.widgetType) {\n-                case 'Text':\n-                  captionName = value;\n-\n-                  if (!value) {\n-                    captionName = '';\n-                    itemCaption = '';\n-                  }\n-                  break;\n-                case 'Lookup':\n-                case 'List':\n-                  captionName = value && value.caption;\n-                  break;\n-                case 'Labels':\n-                  captionName = value.values.reduce((caption, item) => {\n-                    return `${caption}, ${item.caption}`;\n-                  }, '');\n-                  break;\n-                case 'YesNo':\n-                  if (value === null) {\n-                    captionName = '';\n-                    itemCaption = '';\n-                  }\n-                  break;\n-                case 'Switch':\n-                default:\n-                  if (!value) {\n-                    captionName = '';\n-                    itemCaption = '';\n-                  }\n-                  break;\n-              }\n-\n-              if (captionName) {\n-                captionsArray[0] = captionsArray[0]\n-                  ? `${captionsArray[0]}, ${captionName}`\n-                  : captionName;\n-              }\n-\n-              if (itemCaption) {\n-                captionsArray[1] = captionsArray[1]\n-                  ? `${captionsArray[1]}, ${itemCaption}`\n-                  : itemCaption;\n-              }\n-            }\n-          });\n-        } else {\n-          const originalFilter = filtersData.get(filterId);\n-          captionsArray = [originalFilter.caption, originalFilter.caption];\n-        }\n-\n-        if (captionsArray.join('').length) {\n-          activeFiltersCaptions[filterId] = captionsArray;\n-        }\n-      });\n-\n-      // if filter has defaultValues but also some user defined ones,\n-      // we should still include it in active filters\n-      if (Object.keys(removeDefault).length) {\n-        for (let key of Object.keys(removeDefault)) {\n-          activeFilters = activeFilters.setIn([key, 'defaultVal'], false);\n-        }\n-      }\n-\n-      const cleanActiveFilter = this.cleanupActiveFilter(\n-        filterData.toIndexedSeq().toArray(),\n-        activeFilters.toIndexedSeq().toArray()\n-      );\n-\n-      this.setState({\n-        activeFilter: cleanActiveFilter,\n-        activeFiltersCaptions,\n-        flatFiltersMap,\n-      });\n-    } else {\n-      this.setState({\n-        activeFilter: null,\n-        activeFiltersCaptions: null,\n-        flatFiltersMap,\n-      });\n-    }\n-  };\n-\n-  cleanupActiveFilter = (allFilters, activeStateFilters) => {\n-    let filtersToRemove = [];\n-    activeStateFilters.forEach((activeStateFilter) => {\n-      allFilters.forEach((filterItem) => {\n-        if (Array.isArray(filterItem.includedFilters)) {\n-          let groupFilter = filterItem.includedFilters;\n-          let foundMatches = groupFilter.filter(\n-            (gFilterItem) => gFilterItem.filterId === activeStateFilter.filterId\n-          );\n-          if (foundMatches.length > 0) {\n-            filtersToRemove = groupFilter.filter(\n-              (toRemove) => toRemove.filterId !== activeStateFilter.filterId\n-            );\n-          }\n-        }\n-      });\n-    });\n-    return activeStateFilters.filter(\n-      (asFilterItem) =>\n-        !this.isBlacklisted(asFilterItem.filterId, filtersToRemove)\n-    );\n-  };\n-\n-  /**\n-   * @method isBlackListed\n-   * @summary Check if the filterId is found among the filters to remove array\n-   * @param {string filterId\n-   * @param {array} filtersToRemove\n-   */\n-  isBlacklisted = (filterId, filtersToRemove) => {\n-    let resultValue = false;\n-    filtersToRemove.forEach((filterItem) => {\n-      if (filterItem.filterId === filterId) {\n-        resultValue = true;\n-      }\n-    });\n-    return resultValue;\n-  };\n-\n-  /**\n-   * @method sortFilters\n-   * @summary ToDo: Describe the method\n-   * @param {array} data\n-   */\n-  sortFilters = (data) => {\n-    return {\n-      frequentFilters: this.annotateFilters(\n-        data\n-          .filter((filter) => filter.frequent)\n-          .toIndexedSeq()\n-          .toArray()\n-      ),\n-      notFrequentFilters: this.annotateFilters(\n-        data\n-          .filter((filter) => !filter.frequent && !filter.static)\n-          .toIndexedSeq()\n-          .toArray()\n-      ),\n-      staticFilters: this.annotateFilters(\n-        data.filter((filter) => filter.static)\n-      )\n-        .toIndexedSeq()\n-        .toArray(),\n-    };\n-  };\n-\n-  /**\n-   * @method isFilterValid\n-   * @summary ToDo: Describe the method\n-   * @param {*} filters\n-   */\n-  isFilterValid = (filters) => {\n-    if (filters.parameters) {\n-      return !filters.parameters.filter((item) => item.mandatory && !item.value)\n-        .length;\n-    }\n-\n-    return true;\n-  };\n-\n-  /**\n-   * @method isFilterActive\n-   * @summary ToDo: Describe the method\n-   * @param {*} filterId\n-   */\n-  isFilterActive = (filterId) => {\n-    const { activeFilter } = this.state;\n-\n-    if (activeFilter) {\n-      // filters with only defaultValues shouldn't be set to active\n-      const active = activeFilter.find(\n-        (item) => item.filterId === filterId && !item.defaultVal\n-      );\n-\n-      return typeof active !== 'undefined';\n-    }\n-\n-    return false;\n-  };\n-\n-  /**\n-   * @method parseToPatch\n-   * @summary ToDo: Describe the method\n-   * @param {*} params\n-   */\n-  parseToPatch = (params) => {\n-    return params.reduce((acc, param) => {\n-      if (\n-        // filters with only defaltValue shouldn't be sent to server\n-        !param.defaultValue ||\n-        JSON.stringify(param.defaultValue) !== JSON.stringify(param.value)\n-      ) {\n-        acc.push({\n-          ...param,\n-          value: param.value === '' ? null : param.value,\n-        });\n-      }\n-\n-      return acc;\n-    }, []);\n-  };\n-\n-  // SETTING FILTERS  --------------------------------------------------------\n   /**\n    * @method applyFilters\n-   * @summary This method should update docList\n-   * @param {*} isActive\n-   * @param {*} captionValue\n+   * @summary This method should update filters in the store and DL reacts automatically to the changes\n    * @param {object} filter\n-   * @param {*} cb\n-   */\n-  // eslint-disable-next-line no-unused-vars\n-  applyFilters = ({ isActive, captionValue, ...filter }, cb) => {\n-    const valid = this.isFilterValid(filter);\n-\n-    this.setState(\n-      {\n-        notValidFields: !valid,\n-      },\n-      () => {\n-        if (valid) {\n-          const parsedFilter = filter.parameters\n-            ? {\n-                ...filter,\n-                parameters: this.parseToPatch(filter.parameters),\n-              }\n-            : filter;\n+   * @param {function} cb - executed if filter is valid and after it was applied\n+   */\n+  applyFilters = ({ ...filter }, cb) => {\n+    const valid = isFilterValid(filter);\n+    const { updateNotValidFields, filterId } = this.props;\n+\n+    updateNotValidFields({ filterId, data: !valid });\n+    if (valid) {\n+      const parsedFilter = filter.parameters\n+        ? {\n+            ...filter,\n+            parameters: parseToPatch(filter.parameters),\n+          }\n+        : filter;\n \n-          this.setFilterActive(parsedFilter);\n+      this.setFilterActive(parsedFilter);\n \n-          cb && cb();\n-        }\n-      }\n-    );\n+      cb && cb();\n+    }\n   };\n \n   /**\n    * @method setFilterActive\n-   * @summary This function merges new filters that are to be activated with the existing\n-   *  active filters. Additionally we format date fields accordingly so that the backend\n-   *  accepts them.\n+   * @summary This function updates the active filters we set and then triggers the pre-existing\n+   *          logic from DocList that will fetch the filtered data\n    * @param {object} filterToAdd\n    */\n   setFilterActive = (filterToAdd) => {\n-    const { updateDocList } = this.props;\n-    let { filtersActive } = this.props;\n-    const { flatFiltersMap } = this.state;\n-    let activeFilters = iMap(filtersActive);\n-\n-    activeFilters = activeFilters.filter(\n-      (item, id) => id !== filterToAdd.filterId\n-    );\n-    activeFilters = activeFilters.set(filterToAdd.filterId, filterToAdd);\n+    const { updateDocList, filterId, updateActiveFilter } = this.props;\n+    const { filtersActive: storeActiveFilters } = this.props.filters;\n \n-    if (flatFiltersMap) {\n-      activeFilters = activeFilters.map((filter, filterId) => {\n-        filter.parameters &&\n-          filter.parameters.forEach((parameter) => {\n-            const { value, valueTo, parameterName } = parameter;\n-            const singleFilter = flatFiltersMap[`${filterId}-${parameterName}`];\n-\n-            if (\n-              singleFilter &&\n-              DATE_FIELDS.indexOf(singleFilter.widgetType) > -1\n-            ) {\n-              const format = getFormatForDateField(singleFilter.widgetType);\n-\n-              if (value) {\n-                parameter.value = generateMomentObj(value, format);\n-              }\n-              if (valueTo) {\n-                parameter.valueTo = generateMomentObj(valueTo, format);\n-              }\n-            }\n-          });\n-\n-        return filter;\n-      });\n-    }\n+    // updating the active filters from the redux store with the filter passed as param\n+    const newFiltersActive = setNewFiltersActive({\n+      storeActiveFilters,\n+      filterToAdd,\n+    });\n \n-    updateDocList(activeFilters);\n+    updateActiveFilter({ id: filterId, data: newFiltersActive }); // update in the store the filters\n+    updateDocList(newFiltersActive); // move on and update the page with the new filters via DocList\n   };\n \n   /**\n    * @method handleShow\n    * @summary Method to lock backdrop, to do not close on click onClickOutside\n-   *  widgets that are bigger than filter wrapper\n+   *          widgets that are bigger than filter wrapper\n    * @param {*} value\n    */\n   handleShow = (value) => {\n-    this.setState({\n-      widgetShown: value,\n-    });\n+    const { filterId, updateFilterWidgetShown } = this.props;\n+    updateFilterWidgetShown({ id: filterId, data: value });\n   };\n \n   /**\n    * @method clearFilters\n-   * @summary ToDo: Describe the method\n-   * @param {*} filterToClear\n+   * @summary Clears all the filters for a specified filter group\n+   * @param {object} filterToClear - object containing the filters\n    */\n-  clearFilters = (filterToClear, propertyName) => {\n-    const { updateDocList } = this.props;\n-    let { filtersActive } = this.props;\n-    let activeFilters = iMap(filtersActive);\n-\n-    if (filtersActive.size) {\n-      activeFilters = activeFilters.filter((item, id) => {\n-        if (id === filterToClear.filterId) {\n-          if (propertyName && item.parameters && item.parameters.length) {\n-            const parametersCopy = item.parameters.filter(\n-              (param) => param.parameterName !== propertyName\n-            );\n-\n-            if (parametersCopy.length > 0) {\n-              item.parameters = parametersCopy;\n-\n-              return item;\n-            }\n-            return false;\n-          }\n-          return false;\n-        }\n-        return item;\n-      });\n-      updateDocList(activeFilters);\n-    }\n+  clearFilters = (filterToClear) => {\n+    const { filterId, clearAllFilters, filters, updateDocList } = this.props;\n+    clearAllFilters({ id: filterId, data: filterToClear });\n+    // fetch again the doc content after filters were updated into the store\n+    updateDocList(filters.filtersActive);\n   };\n \n   /**\n    * @method dropdownToggled\n-   * @summary ToDo: Describe the method\n+   * @summary Resets notValidFields flag to false\n    */\n   dropdownToggled = () => {\n-    this.setState({\n-      notValidFields: false,\n-    });\n-  };\n-\n-  /**\n-   * @method annotateFilters\n-   * @summary I think it creates caption for active filters to show when the widget is closed - Kuba\n-   * @param {array} unannotatedFilters\n-   */\n-  annotateFilters = (unannotatedFilters) => {\n-    const { activeFilter } = this.state;\n-\n-    return unannotatedFilters.map((unannotatedFilter) => {\n-      const parameter =\n-        unannotatedFilter.parameters && unannotatedFilter.parameters[0];\n-      const isActive = this.isFilterActive(unannotatedFilter.filterId);\n-      const currentFilter = activeFilter\n-        ? activeFilter.find((f) => f.filterId === unannotatedFilter.filterId)\n-        : null;\n-      const activeParameter =\n-        parameter && isActive && currentFilter && currentFilter.parameters[0];\n-\n-      const filterType =\n-        unannotatedFilter.parameters && activeParameter\n-          ? unannotatedFilter.parameters.find(\n-              (filter) => filter.parameterName === activeParameter.parameterName\n-            )\n-          : parameter && parameter.widgetType;\n-\n-      const captionValue = activeParameter\n-        ? fieldValueToString({\n-            fieldValue: activeParameter.valueTo\n-              ? [activeParameter.value, activeParameter.valueTo]\n-              : activeParameter.value,\n-            fieldType: filterType,\n-          })\n-        : '';\n-\n-      return {\n-        ...unannotatedFilter,\n-        captionValue,\n-        isActive,\n-      };\n-    });\n+    const { updateNotValidFields, filterId } = this.props;\n+    updateNotValidFields({ filterId, data: false });\n   };\n \n-  // RENDERING FILTERS -------------------------------------------------------\n   /**\n    * @method render\n-   * @summary ToDo: Describe the method\n+   * @summary Main render function - renders the filters\n    */\n   render() {\n     const {\n-      filterData,\n       windowType,\n       viewId,\n       resetInitialValues,\n       allowOutsideClick,\n       modalVisible,\n+      filters,\n+      filterId,\n     } = this.props;\n \n-    const {\n-      notValidFields,\n-      widgetShown,\n-      activeFilter,\n-      activeFiltersCaptions,\n-    } = this.state;\n+    const widgetShown = filters ? filters.widgetShown : false;\n+    const notValidFields = filters ? filters.notValidFields : false;\n+\n+    if (!filters || !viewId || !filters.filterData) return false;\n+    const { filtersActive, filtersCaptions: activeFiltersCaptions } = filters;\n+\n+    const allFilters = annotateFilters({", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ce95b512092885868ff785d02b76a4bf90452e5"}, "originalPosition": 662}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDMyOTYwOQ==", "bodyText": "Same here - we'll be mapping over active filters on each render.", "url": "https://github.com/metasfresh/metasfresh/pull/9870#discussion_r500329609", "createdAt": "2020-10-06T14:24:57Z", "author": {"login": "siemiatj"}, "path": "frontend/src/components/filters/Filters.js", "diffHunk": "@@ -2,604 +2,133 @@ import counterpart from 'counterpart';\n import PropTypes from 'prop-types';\n import React, { PureComponent } from 'react';\n import { connect } from 'react-redux';\n-// -- using iMap from immutable\n-import { Map as iMap } from 'immutable';\n-import _ from 'lodash';\n-\n-import { DATE_FIELDS } from '../../constants/Constants';\n import {\n-  generateMomentObj,\n-  getFormatForDateField,\n-} from '../widget/RawWidgetHelpers';\n-import { parseDateWithCurrentTimezone } from '../../utils/documentListHelper';\n-import { fieldValueToString } from '../../utils/tableHelpers';\n-import FiltersFrequent from './FiltersFrequent';\n-import FiltersNotFrequent from './FiltersNotFrequent';\n-\n-/**\n- * @method parseDateToReadable\n- * @summary ToDo: Describe the method\n- * @param {*} widgetType\n- * @param {*} value\n- * @todo Write the documentation\n- */\n-export function parseDateToReadable(widgetType, value) {\n-  if (DATE_FIELDS.indexOf(widgetType) > -1) {\n-    return parseDateWithCurrentTimezone(value, widgetType);\n-  }\n-  return value;\n-}\n+  updateFilterWidgetShown,\n+  setNewFiltersActive,\n+  updateActiveFilter,\n+  clearAllFilters,\n+  annotateFilters,\n+  isFilterValid,\n+  updateNotValidFields,\n+  parseToPatch,\n+} from '../../actions/FiltersActions';\n+\n+import FiltersNotIcluded from './FiltersNotIncluded';\n+import FiltersIncluded from './FiltersIncluded';\n+import deepUnfreeze from 'deep-unfreeze';\n+import { getEntityRelatedId } from '../../reducers/filters';\n \n /**\n  * @file Class based component.\n  * @module Filters\n- * @extends Component\n+ * @extends PureComponent\n  */\n class Filters extends PureComponent {\n-  state = {\n-    activeFilter: null,\n-    activeFiltersCaptions: null,\n-    flatFiltersMap: null,\n-    notValidFields: null,\n-    widgetShown: false,\n-  };\n-\n-  /**\n-   * @method UNSAFE_componentWillReceiveProps\n-   * @summary ToDo: Describe the method\n-   */\n-  UNSAFE_componentWillReceiveProps() {\n-    this.parseActiveFilters();\n-  }\n-\n-  /**\n-   * @method componentDidMount\n-   * @summary ToDo: Describe the method\n-   */\n-  componentDidMount() {\n-    this.parseActiveFilters();\n-  }\n-\n-  /**\n-   * @method arrangeFilters\n-   * @summary combines the filters and also removes the other actives ones from same group\n-   */\n-  arrangeFilters = (filterData) => {\n-    let combinedFilters = [];\n-    for (const [key] of filterData.entries()) {\n-      let item = filterData.get(key);\n-      if (typeof item.includedFilters !== 'undefined') {\n-        combinedFilters.push(...item.includedFilters);\n-      } else {\n-        combinedFilters.push(item);\n-      }\n-    }\n-    let mappedFiltersData = new Map();\n-    combinedFilters.forEach((item) => {\n-      mappedFiltersData.set(item.filterId, item);\n-    });\n-    return mappedFiltersData;\n-  };\n-\n-  // PARSING FILTERS ---------------------------------------------------------\n-\n-  /*\n-   * parseActiveFilters - this function does three things:\n-   *  - creates a flat map of existing filter fields to store the widgetType for\n-        further processing\n-   *  - creates a local copy of active filters object including filters that\n-   *    only have defaultValues set. `defaultVal` flag tells us, that this\n-   *    filter has only defaultValues, and no values set by the user. We need\n-   *    this to ble able to differentiate between filters that should be\n-   *    indicated as active on load, or not.\n-   *  - creates an object with captions of each active parameter per filter\n-   *\n-   * So first we traverse all filters data and perform actions in this order:\n-   *  - if filter is in active filters and parameter has no defaultValue,\n-   *    or defaultValue has been nullified by user's selection we add it\n-   *    local active filters and set the `defaultVal` flag to false\n-   *    (as it obviously was already set).\n-   *  - if filter is active check if current loop parameter is set in the\n-   *    active filters. If yes, do nothing as it'll always override the\n-   *    defaultValue\n-   *  - otherwise add parameter and filter to local active filters and set\n-   *    the `defaultVal` to true as apparently there are no values set  \n-   *  \n-   *    Update: 10 March 2020, removed the logic to set the default \n-   * \n-   */\n-  /**\n-   * @method parseActiveFilters\n-   * @summary ToDo: Describe the method\n-   */\n-  parseActiveFilters = () => {\n-    let { filtersActive, filterData, initialValuesNulled } = this.props;\n-    let activeFilters = _.cloneDeep(filtersActive);\n-\n-    // make new ES6 Map with the items from combined filters\n-    let mappedFiltersData = this.arrangeFilters(filterData);\n-    // put the resulted combined map of filters into the iMap and preserve existing functionality\n-    let filtersData = iMap(mappedFiltersData);\n-    const flatFiltersMap = {};\n-    const activeFiltersCaptions = {};\n-\n-    // find any filters with default values first and extend\n-    // activeFilters with them\n-    filtersData.forEach((filter, filterId) => {\n-      if (filter.parameters) {\n-        outerParameters: for (let parameter of filter.parameters) {\n-          const { defaultValue, parameterName, widgetType } = parameter;\n-          const nulledFilter = initialValuesNulled.get(filterId);\n-\n-          flatFiltersMap[`${filterId}-${parameterName}`] = {\n-            widgetType,\n-          };\n-\n-          const isActive = filtersActive.has(filterId);\n-\n-          if (\n-            !defaultValue ||\n-            (nulledFilter && nulledFilter.has(parameterName))\n-          ) {\n-            if (isActive) {\n-              activeFilters = activeFilters.set(filterId, {\n-                defaultVal: false,\n-                filterId,\n-                parameters: activeFilters.get(filterId).parameters,\n-              });\n-            }\n-            continue;\n-          }\n-\n-          if (isActive) {\n-            //look for existing parameterName in parameters array\n-            // skip if found as they override defaultValue ALWAYS\n-            const filterActive = activeFilters.get(filterId);\n-\n-            if (filterActive.parameters) {\n-              for (let activeParameter of filterActive.parameters) {\n-                if (activeParameter.parameterName === parameterName) {\n-                  continue outerParameters;\n-                }\n-              }\n-            }\n-          }\n-        }\n-      }\n-    });\n-\n-    if (activeFilters.size) {\n-      const removeDefault = {};\n-\n-      activeFilters.forEach((filter, filterId) => {\n-        let captionsArray = ['', ''];\n-\n-        if (filter.parameters && filter.parameters.length) {\n-          filter.parameters.forEach((filterParameter) => {\n-            const { value, parameterName, defaultValue } = filterParameter;\n-\n-            if (!defaultValue) {\n-              // we don't want to show captions, nor show filter button as active\n-              // for default values\n-              removeDefault[filterId] = true;\n-\n-              const parentFilter = filtersData.get(filterId);\n-              const filterParameter = parentFilter.parameters.find(\n-                (param) => param.parameterName === parameterName\n-              );\n-              let captionName = filterParameter.caption;\n-              let itemCaption = filterParameter.caption;\n-\n-              switch (filterParameter.widgetType) {\n-                case 'Text':\n-                  captionName = value;\n-\n-                  if (!value) {\n-                    captionName = '';\n-                    itemCaption = '';\n-                  }\n-                  break;\n-                case 'Lookup':\n-                case 'List':\n-                  captionName = value && value.caption;\n-                  break;\n-                case 'Labels':\n-                  captionName = value.values.reduce((caption, item) => {\n-                    return `${caption}, ${item.caption}`;\n-                  }, '');\n-                  break;\n-                case 'YesNo':\n-                  if (value === null) {\n-                    captionName = '';\n-                    itemCaption = '';\n-                  }\n-                  break;\n-                case 'Switch':\n-                default:\n-                  if (!value) {\n-                    captionName = '';\n-                    itemCaption = '';\n-                  }\n-                  break;\n-              }\n-\n-              if (captionName) {\n-                captionsArray[0] = captionsArray[0]\n-                  ? `${captionsArray[0]}, ${captionName}`\n-                  : captionName;\n-              }\n-\n-              if (itemCaption) {\n-                captionsArray[1] = captionsArray[1]\n-                  ? `${captionsArray[1]}, ${itemCaption}`\n-                  : itemCaption;\n-              }\n-            }\n-          });\n-        } else {\n-          const originalFilter = filtersData.get(filterId);\n-          captionsArray = [originalFilter.caption, originalFilter.caption];\n-        }\n-\n-        if (captionsArray.join('').length) {\n-          activeFiltersCaptions[filterId] = captionsArray;\n-        }\n-      });\n-\n-      // if filter has defaultValues but also some user defined ones,\n-      // we should still include it in active filters\n-      if (Object.keys(removeDefault).length) {\n-        for (let key of Object.keys(removeDefault)) {\n-          activeFilters = activeFilters.setIn([key, 'defaultVal'], false);\n-        }\n-      }\n-\n-      const cleanActiveFilter = this.cleanupActiveFilter(\n-        filterData.toIndexedSeq().toArray(),\n-        activeFilters.toIndexedSeq().toArray()\n-      );\n-\n-      this.setState({\n-        activeFilter: cleanActiveFilter,\n-        activeFiltersCaptions,\n-        flatFiltersMap,\n-      });\n-    } else {\n-      this.setState({\n-        activeFilter: null,\n-        activeFiltersCaptions: null,\n-        flatFiltersMap,\n-      });\n-    }\n-  };\n-\n-  cleanupActiveFilter = (allFilters, activeStateFilters) => {\n-    let filtersToRemove = [];\n-    activeStateFilters.forEach((activeStateFilter) => {\n-      allFilters.forEach((filterItem) => {\n-        if (Array.isArray(filterItem.includedFilters)) {\n-          let groupFilter = filterItem.includedFilters;\n-          let foundMatches = groupFilter.filter(\n-            (gFilterItem) => gFilterItem.filterId === activeStateFilter.filterId\n-          );\n-          if (foundMatches.length > 0) {\n-            filtersToRemove = groupFilter.filter(\n-              (toRemove) => toRemove.filterId !== activeStateFilter.filterId\n-            );\n-          }\n-        }\n-      });\n-    });\n-    return activeStateFilters.filter(\n-      (asFilterItem) =>\n-        !this.isBlacklisted(asFilterItem.filterId, filtersToRemove)\n-    );\n-  };\n-\n-  /**\n-   * @method isBlackListed\n-   * @summary Check if the filterId is found among the filters to remove array\n-   * @param {string filterId\n-   * @param {array} filtersToRemove\n-   */\n-  isBlacklisted = (filterId, filtersToRemove) => {\n-    let resultValue = false;\n-    filtersToRemove.forEach((filterItem) => {\n-      if (filterItem.filterId === filterId) {\n-        resultValue = true;\n-      }\n-    });\n-    return resultValue;\n-  };\n-\n-  /**\n-   * @method sortFilters\n-   * @summary ToDo: Describe the method\n-   * @param {array} data\n-   */\n-  sortFilters = (data) => {\n-    return {\n-      frequentFilters: this.annotateFilters(\n-        data\n-          .filter((filter) => filter.frequent)\n-          .toIndexedSeq()\n-          .toArray()\n-      ),\n-      notFrequentFilters: this.annotateFilters(\n-        data\n-          .filter((filter) => !filter.frequent && !filter.static)\n-          .toIndexedSeq()\n-          .toArray()\n-      ),\n-      staticFilters: this.annotateFilters(\n-        data.filter((filter) => filter.static)\n-      )\n-        .toIndexedSeq()\n-        .toArray(),\n-    };\n-  };\n-\n-  /**\n-   * @method isFilterValid\n-   * @summary ToDo: Describe the method\n-   * @param {*} filters\n-   */\n-  isFilterValid = (filters) => {\n-    if (filters.parameters) {\n-      return !filters.parameters.filter((item) => item.mandatory && !item.value)\n-        .length;\n-    }\n-\n-    return true;\n-  };\n-\n-  /**\n-   * @method isFilterActive\n-   * @summary ToDo: Describe the method\n-   * @param {*} filterId\n-   */\n-  isFilterActive = (filterId) => {\n-    const { activeFilter } = this.state;\n-\n-    if (activeFilter) {\n-      // filters with only defaultValues shouldn't be set to active\n-      const active = activeFilter.find(\n-        (item) => item.filterId === filterId && !item.defaultVal\n-      );\n-\n-      return typeof active !== 'undefined';\n-    }\n-\n-    return false;\n-  };\n-\n-  /**\n-   * @method parseToPatch\n-   * @summary ToDo: Describe the method\n-   * @param {*} params\n-   */\n-  parseToPatch = (params) => {\n-    return params.reduce((acc, param) => {\n-      if (\n-        // filters with only defaltValue shouldn't be sent to server\n-        !param.defaultValue ||\n-        JSON.stringify(param.defaultValue) !== JSON.stringify(param.value)\n-      ) {\n-        acc.push({\n-          ...param,\n-          value: param.value === '' ? null : param.value,\n-        });\n-      }\n-\n-      return acc;\n-    }, []);\n-  };\n-\n-  // SETTING FILTERS  --------------------------------------------------------\n   /**\n    * @method applyFilters\n-   * @summary This method should update docList\n-   * @param {*} isActive\n-   * @param {*} captionValue\n+   * @summary This method should update filters in the store and DL reacts automatically to the changes\n    * @param {object} filter\n-   * @param {*} cb\n-   */\n-  // eslint-disable-next-line no-unused-vars\n-  applyFilters = ({ isActive, captionValue, ...filter }, cb) => {\n-    const valid = this.isFilterValid(filter);\n-\n-    this.setState(\n-      {\n-        notValidFields: !valid,\n-      },\n-      () => {\n-        if (valid) {\n-          const parsedFilter = filter.parameters\n-            ? {\n-                ...filter,\n-                parameters: this.parseToPatch(filter.parameters),\n-              }\n-            : filter;\n+   * @param {function} cb - executed if filter is valid and after it was applied\n+   */\n+  applyFilters = ({ ...filter }, cb) => {\n+    const valid = isFilterValid(filter);\n+    const { updateNotValidFields, filterId } = this.props;\n+\n+    updateNotValidFields({ filterId, data: !valid });\n+    if (valid) {\n+      const parsedFilter = filter.parameters\n+        ? {\n+            ...filter,\n+            parameters: parseToPatch(filter.parameters),\n+          }\n+        : filter;\n \n-          this.setFilterActive(parsedFilter);\n+      this.setFilterActive(parsedFilter);\n \n-          cb && cb();\n-        }\n-      }\n-    );\n+      cb && cb();\n+    }\n   };\n \n   /**\n    * @method setFilterActive\n-   * @summary This function merges new filters that are to be activated with the existing\n-   *  active filters. Additionally we format date fields accordingly so that the backend\n-   *  accepts them.\n+   * @summary This function updates the active filters we set and then triggers the pre-existing\n+   *          logic from DocList that will fetch the filtered data\n    * @param {object} filterToAdd\n    */\n   setFilterActive = (filterToAdd) => {\n-    const { updateDocList } = this.props;\n-    let { filtersActive } = this.props;\n-    const { flatFiltersMap } = this.state;\n-    let activeFilters = iMap(filtersActive);\n-\n-    activeFilters = activeFilters.filter(\n-      (item, id) => id !== filterToAdd.filterId\n-    );\n-    activeFilters = activeFilters.set(filterToAdd.filterId, filterToAdd);\n+    const { updateDocList, filterId, updateActiveFilter } = this.props;\n+    const { filtersActive: storeActiveFilters } = this.props.filters;\n \n-    if (flatFiltersMap) {\n-      activeFilters = activeFilters.map((filter, filterId) => {\n-        filter.parameters &&\n-          filter.parameters.forEach((parameter) => {\n-            const { value, valueTo, parameterName } = parameter;\n-            const singleFilter = flatFiltersMap[`${filterId}-${parameterName}`];\n-\n-            if (\n-              singleFilter &&\n-              DATE_FIELDS.indexOf(singleFilter.widgetType) > -1\n-            ) {\n-              const format = getFormatForDateField(singleFilter.widgetType);\n-\n-              if (value) {\n-                parameter.value = generateMomentObj(value, format);\n-              }\n-              if (valueTo) {\n-                parameter.valueTo = generateMomentObj(valueTo, format);\n-              }\n-            }\n-          });\n-\n-        return filter;\n-      });\n-    }\n+    // updating the active filters from the redux store with the filter passed as param\n+    const newFiltersActive = setNewFiltersActive({\n+      storeActiveFilters,\n+      filterToAdd,\n+    });\n \n-    updateDocList(activeFilters);\n+    updateActiveFilter({ id: filterId, data: newFiltersActive }); // update in the store the filters\n+    updateDocList(newFiltersActive); // move on and update the page with the new filters via DocList\n   };\n \n   /**\n    * @method handleShow\n    * @summary Method to lock backdrop, to do not close on click onClickOutside\n-   *  widgets that are bigger than filter wrapper\n+   *          widgets that are bigger than filter wrapper\n    * @param {*} value\n    */\n   handleShow = (value) => {\n-    this.setState({\n-      widgetShown: value,\n-    });\n+    const { filterId, updateFilterWidgetShown } = this.props;\n+    updateFilterWidgetShown({ id: filterId, data: value });\n   };\n \n   /**\n    * @method clearFilters\n-   * @summary ToDo: Describe the method\n-   * @param {*} filterToClear\n+   * @summary Clears all the filters for a specified filter group\n+   * @param {object} filterToClear - object containing the filters\n    */\n-  clearFilters = (filterToClear, propertyName) => {\n-    const { updateDocList } = this.props;\n-    let { filtersActive } = this.props;\n-    let activeFilters = iMap(filtersActive);\n-\n-    if (filtersActive.size) {\n-      activeFilters = activeFilters.filter((item, id) => {\n-        if (id === filterToClear.filterId) {\n-          if (propertyName && item.parameters && item.parameters.length) {\n-            const parametersCopy = item.parameters.filter(\n-              (param) => param.parameterName !== propertyName\n-            );\n-\n-            if (parametersCopy.length > 0) {\n-              item.parameters = parametersCopy;\n-\n-              return item;\n-            }\n-            return false;\n-          }\n-          return false;\n-        }\n-        return item;\n-      });\n-      updateDocList(activeFilters);\n-    }\n+  clearFilters = (filterToClear) => {\n+    const { filterId, clearAllFilters, filters, updateDocList } = this.props;\n+    clearAllFilters({ id: filterId, data: filterToClear });\n+    // fetch again the doc content after filters were updated into the store\n+    updateDocList(filters.filtersActive);\n   };\n \n   /**\n    * @method dropdownToggled\n-   * @summary ToDo: Describe the method\n+   * @summary Resets notValidFields flag to false\n    */\n   dropdownToggled = () => {\n-    this.setState({\n-      notValidFields: false,\n-    });\n-  };\n-\n-  /**\n-   * @method annotateFilters\n-   * @summary I think it creates caption for active filters to show when the widget is closed - Kuba\n-   * @param {array} unannotatedFilters\n-   */\n-  annotateFilters = (unannotatedFilters) => {\n-    const { activeFilter } = this.state;\n-\n-    return unannotatedFilters.map((unannotatedFilter) => {\n-      const parameter =\n-        unannotatedFilter.parameters && unannotatedFilter.parameters[0];\n-      const isActive = this.isFilterActive(unannotatedFilter.filterId);\n-      const currentFilter = activeFilter\n-        ? activeFilter.find((f) => f.filterId === unannotatedFilter.filterId)\n-        : null;\n-      const activeParameter =\n-        parameter && isActive && currentFilter && currentFilter.parameters[0];\n-\n-      const filterType =\n-        unannotatedFilter.parameters && activeParameter\n-          ? unannotatedFilter.parameters.find(\n-              (filter) => filter.parameterName === activeParameter.parameterName\n-            )\n-          : parameter && parameter.widgetType;\n-\n-      const captionValue = activeParameter\n-        ? fieldValueToString({\n-            fieldValue: activeParameter.valueTo\n-              ? [activeParameter.value, activeParameter.valueTo]\n-              : activeParameter.value,\n-            fieldType: filterType,\n-          })\n-        : '';\n-\n-      return {\n-        ...unannotatedFilter,\n-        captionValue,\n-        isActive,\n-      };\n-    });\n+    const { updateNotValidFields, filterId } = this.props;\n+    updateNotValidFields({ filterId, data: false });\n   };\n \n-  // RENDERING FILTERS -------------------------------------------------------\n   /**\n    * @method render\n-   * @summary ToDo: Describe the method\n+   * @summary Main render function - renders the filters\n    */\n   render() {\n     const {\n-      filterData,\n       windowType,\n       viewId,\n       resetInitialValues,\n       allowOutsideClick,\n       modalVisible,\n+      filters,\n+      filterId,\n     } = this.props;\n \n-    const {\n-      notValidFields,\n-      widgetShown,\n-      activeFilter,\n-      activeFiltersCaptions,\n-    } = this.state;\n+    const widgetShown = filters ? filters.widgetShown : false;\n+    const notValidFields = filters ? filters.notValidFields : false;\n+\n+    if (!filters || !viewId || !filters.filterData) return false;\n+    const { filtersActive, filtersCaptions: activeFiltersCaptions } = filters;\n+\n+    const allFilters = annotateFilters({\n+      unannotatedFilters: filters.filterData,\n+      filtersActive,\n+    });\n \n-    const allFilters = this.annotateFilters(\n-      filterData.toIndexedSeq().toArray()\n-    );\n     const flatActiveFilterIds =\n-      activeFilter !== null ? activeFilter.map((item) => item.filterId) : [];\n+      filtersActive !== null ? filtersActive.map((item) => item.filterId) : [];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ce95b512092885868ff785d02b76a4bf90452e5"}, "originalPosition": 672}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDMzMTQwNA==", "bodyText": "Any particular reason why it's sometimes id, and other times filterId ? It's a minor thing but if we're already using named params let's stick to one convention.", "url": "https://github.com/metasfresh/metasfresh/pull/9870#discussion_r500331404", "createdAt": "2020-10-06T14:26:36Z", "author": {"login": "siemiatj"}, "path": "frontend/src/actions/FiltersActions.js", "diffHunk": "@@ -1,8 +1,355 @@\n-import { SET_CLEAR_ALL_FILTER } from '../constants/FilterTypes';\n+import * as types from '../constants/FilterTypes';\n+import deepUnfreeze from 'deep-unfreeze';\n+import { fieldValueToString } from '../utils/tableHelpers';\n+import _ from 'lodash';\n \n-export function clearAllFilters(data) {\n+export function clearAllFilters({ id, data }) {\n   return {\n-    type: SET_CLEAR_ALL_FILTER,\n-    payload: data,\n+    type: types.CLEAR_ALL_FILTERS,\n+    payload: { id, data },\n   };\n }\n+\n+/**\n+ * @method createFilter\n+ * @summary Add a new filter entry to the redux store\n+ */\n+export function createFilter({ id, data }) {\n+  return {\n+    type: types.CREATE_FILTER,\n+    payload: { id, data },\n+  };\n+}\n+\n+/**\n+ * @method deleteFilter\n+ * @summary Remove the filter with specified `id` from the store\n+ */\n+export function deleteFilter(id) {\n+  return {\n+    type: types.DELETE_FILTER,\n+    payload: { id },\n+  };\n+}\n+\n+/**\n+ * @method updateNotValidFields\n+ * @summary updates in the store the notValidFields flag\n+ */\n+export function updateNotValidFields({ filterId, data }) {\n+  return {\n+    type: types.UPDATE_FLAG_NOTVALIDFIELDS,\n+    payload: { filterId, data },\n+  };\n+}\n+\n+/**\n+ * @method updateActiveFilter\n+ * @summary Updates the activeFilter in the store for the corresponding entity id\n+ */\n+export function updateActiveFilter({ id, data }) {\n+  return {\n+    type: types.UPDATE_ACTIVE_FILTER,\n+    payload: { id, data },\n+  };\n+}\n+\n+/**\n+ * @method updateInlineFilter\n+ * @summary Updates the InlineFilter value in the store for the corresponding entity id\n+ */\n+export function updateInlineFilter({ filterId, data }) {\n+  return {\n+    type: types.UPDATE_INLINE_FILTER,\n+    payload: { filterId, data },\n+  };\n+}\n+\n+/**\n+ * @method updateFilterWidgetShown\n+ * @summary Updates the widgetShown in the store for the corresponding entity id with a boolean value\n+ */\n+export function updateFilterWidgetShown({ id, data }) {\n+  return {\n+    type: types.FILTER_UPDATE_WIDGET_SHOWN,\n+    payload: { id, data },\n+  };\n+}\n+\n+/**\n+ * @method clearStaticFilters\n+ * @summary Clears the existing static filters for a filter branch in the redux store\n+ */\n+export function clearStaticFilters({ filterId, data }) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ce95b512092885868ff785d02b76a4bf90452e5"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDMzMjM3MQ==", "bodyText": "I think I've asked in another file, but why are we removing those ?", "url": "https://github.com/metasfresh/metasfresh/pull/9870#discussion_r500332371", "createdAt": "2020-10-06T14:27:38Z", "author": {"login": "siemiatj"}, "path": "frontend/src/components/filters/FiltersIncluded.js", "diffHunk": "@@ -202,26 +188,7 @@ class FiltersNotFrequent extends PureComponent {\n   }\n }\n \n-/**\n- * @typedef {object} Props Component props", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ce95b512092885868ff785d02b76a4bf90452e5"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDMzODAzNw==", "bodyText": "Only in case filters[filterId] exists. Otherwise we'll get undefined. I think it'd be best to have a cached selector here as filters might be a complicated object and hit us with unnecessary re-renders.", "url": "https://github.com/metasfresh/metasfresh/pull/9870#discussion_r500338037", "createdAt": "2020-10-06T14:33:35Z", "author": {"login": "siemiatj"}, "path": "frontend/src/utils/documentListHelper.js", "diffHunk": "@@ -142,7 +141,8 @@ const DLmapStateToProps = (state, props) => {\n     parentSelected: parentSelector(state, parentTableId),\n     modal: state.windowHandler.modal,\n     rawModalVisible: state.windowHandler.rawModal.visible,\n-    filters: state.filters,\n+    filters: windowId && viewId && state.filters ? state.filters[filterId] : {},", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI1NjgxOA=="}, "originalCommit": {"oid": "aca6e4a591072da112d61083ebccc3a36f0e0724"}, "originalPosition": 37}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "de9b9aa8a93e3a8d352e019f53601c3757452ece", "author": {"user": null}, "url": "https://github.com/metasfresh/metasfresh/commit/de9b9aa8a93e3a8d352e019f53601c3757452ece", "committedDate": "2020-10-07T05:13:36Z", "message": "Update param to filterId for actions"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3148, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}