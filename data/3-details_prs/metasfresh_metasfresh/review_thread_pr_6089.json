{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY3ODkzMDA5", "number": 6089, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQwNzo0NDoxNVrODb0oYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQxNTozMDoyMlrODdBV5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwNTAwNDQ4OnYy", "diffSide": "RIGHT", "path": "de.metas.banking/de.metas.banking.base/src/main/java/de/metas/banking/service/impl/BankStatementBL.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQwNzo0NDoxNVrOFjhwYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQwODozMjozOFrOFjizPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc5NzUzOQ==", "bodyText": "this check is kind of futile", "url": "https://github.com/metasfresh/metasfresh/pull/6089#discussion_r372797539", "createdAt": "2020-01-30T07:44:15Z", "author": {"login": "teosarca"}, "path": "de.metas.banking/de.metas.banking.base/src/main/java/de/metas/banking/service/impl/BankStatementBL.java", "diffHunk": "@@ -97,16 +111,133 @@ public void handleAfterComplete(final I_C_BankStatement bankStatement)\n \t\t{\n \t\t\tfinal I_C_BankStatementLine line = InterfaceWrapperHelper.create(linePO, I_C_BankStatementLine.class);\n \n-\t\t\tif (line.isMultiplePaymentOrInvoice() && line.isMultiplePayment())\n+\t\t\tfindOrCreateUnreconciledPaymentsAndLinkToBankStatementLine(line);\n+\t\t\treconcilePaymentsFromBankStatementLine_Ref(bankStatementDAO, line);\n+\t\t}\n+\t}\n+\n+\t@VisibleForTesting\n+\tvoid findOrCreateUnreconciledPaymentsAndLinkToBankStatementLine(final I_C_BankStatementLine line)\n+\t{\n+\t\tfindAndLinkPaymentToBankStatementLineIfPossible(line);\n+\n+\t\tsetOrCreateAndLinkPaymentToBankStatementLine(line, null);\n+\t}\n+\n+\t@Override\n+\tpublic Optional<PaymentId> setOrCreateAndLinkPaymentToBankStatementLine(@NonNull final I_C_BankStatementLine line, @Nullable final PaymentId paymentIdToSet)\n+\t{\n+\t\t// a payment is already linked\n+\t\tif (line.getC_Payment_ID() > 0)\n+\t\t{\n+\t\t\treturn Optional.of(PaymentId.ofRepoId(line.getC_Payment_ID()));\n+\t\t}\n+\n+\t\tif (paymentIdToSet != null)\n+\t\t{\n+\t\t\tline.setC_Payment_ID(paymentIdToSet.getRepoId());\n+\t\t\tInterfaceWrapperHelper.save(line);\n+\t\t\treturn Optional.of(paymentIdToSet);\n+\t\t}\n+\n+\t\tif (line.getC_BPartner_ID() <= 0)\n+\t\t{\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\n+\t\tfinal CurrencyId currencyId = CurrencyId.ofRepoId(line.getC_Currency_ID());\n+\t\tfinal BPartnerId bpartnerId = BPartnerId.ofRepoId(line.getC_BPartner_ID());\n+\t\tfinal OrgId orgId = OrgId.ofRepoId(line.getAD_Org_ID());\n+\t\tfinal LocalDate statementLineDate = TimeUtil.asLocalDate(line.getStatementLineDate());\n+\n+\t\tfinal Optional<BankAccountId> bankAccountIdOptional = Services.get(IBPBankAccountDAO.class).retrieveFirstIdByBPartnerAndCurrency(bpartnerId, currencyId);\n+\t\tif (!bankAccountIdOptional.isPresent())\n+\t\t{\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\n+\t\tfinal boolean isReceipt = line.getStmtAmt().signum() >= 0;\n+\t\tfinal BigDecimal payAmount = isReceipt ? line.getStmtAmt() : line.getStmtAmt().negate();\n+\n+\t\tfinal PaymentId createdPaymentId = createAndCompletePayment(bankAccountIdOptional.get(), statementLineDate, payAmount, isReceipt, orgId, bpartnerId, currencyId);\n+\t\tline.setC_Payment_ID(createdPaymentId.getRepoId());\n+\t\tInterfaceWrapperHelper.save(line);\n+\t\treturn Optional.of(createdPaymentId);\n+\t}\n+\n+\tprivate void findAndLinkPaymentToBankStatementLineIfPossible(final I_C_BankStatementLine line)\n+\t{\n+\t\t// a payment is already linked\n+\t\tif (line.getC_Payment_ID() > 0)\n+\t\t{\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tfinal boolean isReceipt = line.getStmtAmt().signum() >= 0;\n+\t\tfinal BigDecimal expectedPaymentAmount = isReceipt ? line.getStmtAmt() : line.getStmtAmt().negate();\n+\n+\t\tfinal ImmutableSet<PaymentId> possiblePayments = Services.get(IPaymentDAO.class).retrieveAllMatchingPayments(isReceipt, expectedPaymentAmount, CurrencyId.ofRepoId(line.getC_Currency_ID()), BPartnerId.ofRepoId(line.getC_BPartner_ID()));\n+\n+\t\t// don't create a new Payment and don't link any of the payments.\n+\t\t// the user must fix this case manually\n+\t\tif (possiblePayments.size() > 1)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e483c8455e73d08ebd4f2cb513890451b55d94f"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjgxNDY1Mw==", "bodyText": "that was a bug. fixed now.", "url": "https://github.com/metasfresh/metasfresh/pull/6089#discussion_r372814653", "createdAt": "2020-01-30T08:32:38Z", "author": {"login": "TheBestPessimist"}, "path": "de.metas.banking/de.metas.banking.base/src/main/java/de/metas/banking/service/impl/BankStatementBL.java", "diffHunk": "@@ -97,16 +111,133 @@ public void handleAfterComplete(final I_C_BankStatement bankStatement)\n \t\t{\n \t\t\tfinal I_C_BankStatementLine line = InterfaceWrapperHelper.create(linePO, I_C_BankStatementLine.class);\n \n-\t\t\tif (line.isMultiplePaymentOrInvoice() && line.isMultiplePayment())\n+\t\t\tfindOrCreateUnreconciledPaymentsAndLinkToBankStatementLine(line);\n+\t\t\treconcilePaymentsFromBankStatementLine_Ref(bankStatementDAO, line);\n+\t\t}\n+\t}\n+\n+\t@VisibleForTesting\n+\tvoid findOrCreateUnreconciledPaymentsAndLinkToBankStatementLine(final I_C_BankStatementLine line)\n+\t{\n+\t\tfindAndLinkPaymentToBankStatementLineIfPossible(line);\n+\n+\t\tsetOrCreateAndLinkPaymentToBankStatementLine(line, null);\n+\t}\n+\n+\t@Override\n+\tpublic Optional<PaymentId> setOrCreateAndLinkPaymentToBankStatementLine(@NonNull final I_C_BankStatementLine line, @Nullable final PaymentId paymentIdToSet)\n+\t{\n+\t\t// a payment is already linked\n+\t\tif (line.getC_Payment_ID() > 0)\n+\t\t{\n+\t\t\treturn Optional.of(PaymentId.ofRepoId(line.getC_Payment_ID()));\n+\t\t}\n+\n+\t\tif (paymentIdToSet != null)\n+\t\t{\n+\t\t\tline.setC_Payment_ID(paymentIdToSet.getRepoId());\n+\t\t\tInterfaceWrapperHelper.save(line);\n+\t\t\treturn Optional.of(paymentIdToSet);\n+\t\t}\n+\n+\t\tif (line.getC_BPartner_ID() <= 0)\n+\t\t{\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\n+\t\tfinal CurrencyId currencyId = CurrencyId.ofRepoId(line.getC_Currency_ID());\n+\t\tfinal BPartnerId bpartnerId = BPartnerId.ofRepoId(line.getC_BPartner_ID());\n+\t\tfinal OrgId orgId = OrgId.ofRepoId(line.getAD_Org_ID());\n+\t\tfinal LocalDate statementLineDate = TimeUtil.asLocalDate(line.getStatementLineDate());\n+\n+\t\tfinal Optional<BankAccountId> bankAccountIdOptional = Services.get(IBPBankAccountDAO.class).retrieveFirstIdByBPartnerAndCurrency(bpartnerId, currencyId);\n+\t\tif (!bankAccountIdOptional.isPresent())\n+\t\t{\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\n+\t\tfinal boolean isReceipt = line.getStmtAmt().signum() >= 0;\n+\t\tfinal BigDecimal payAmount = isReceipt ? line.getStmtAmt() : line.getStmtAmt().negate();\n+\n+\t\tfinal PaymentId createdPaymentId = createAndCompletePayment(bankAccountIdOptional.get(), statementLineDate, payAmount, isReceipt, orgId, bpartnerId, currencyId);\n+\t\tline.setC_Payment_ID(createdPaymentId.getRepoId());\n+\t\tInterfaceWrapperHelper.save(line);\n+\t\treturn Optional.of(createdPaymentId);\n+\t}\n+\n+\tprivate void findAndLinkPaymentToBankStatementLineIfPossible(final I_C_BankStatementLine line)\n+\t{\n+\t\t// a payment is already linked\n+\t\tif (line.getC_Payment_ID() > 0)\n+\t\t{\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tfinal boolean isReceipt = line.getStmtAmt().signum() >= 0;\n+\t\tfinal BigDecimal expectedPaymentAmount = isReceipt ? line.getStmtAmt() : line.getStmtAmt().negate();\n+\n+\t\tfinal ImmutableSet<PaymentId> possiblePayments = Services.get(IPaymentDAO.class).retrieveAllMatchingPayments(isReceipt, expectedPaymentAmount, CurrencyId.ofRepoId(line.getC_Currency_ID()), BPartnerId.ofRepoId(line.getC_BPartner_ID()));\n+\n+\t\t// don't create a new Payment and don't link any of the payments.\n+\t\t// the user must fix this case manually\n+\t\tif (possiblePayments.size() > 1)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc5NzUzOQ=="}, "originalCommit": {"oid": "8e483c8455e73d08ebd4f2cb513890451b55d94f"}, "originalPosition": 121}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwNTAwNjAxOnYy", "diffSide": "RIGHT", "path": "de.metas.banking/de.metas.banking.base/src/main/java/de/metas/banking/service/impl/BankStatementBL.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQwNzo0NDo1OFrOFjhxPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQwOToyNjo1OVrOFjkQRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc5Nzc1Nw==", "bodyText": "extract the IPaymentBL at least to a local variable", "url": "https://github.com/metasfresh/metasfresh/pull/6089#discussion_r372797757", "createdAt": "2020-01-30T07:44:58Z", "author": {"login": "teosarca"}, "path": "de.metas.banking/de.metas.banking.base/src/main/java/de/metas/banking/service/impl/BankStatementBL.java", "diffHunk": "@@ -97,16 +111,133 @@ public void handleAfterComplete(final I_C_BankStatement bankStatement)\n \t\t{\n \t\t\tfinal I_C_BankStatementLine line = InterfaceWrapperHelper.create(linePO, I_C_BankStatementLine.class);\n \n-\t\t\tif (line.isMultiplePaymentOrInvoice() && line.isMultiplePayment())\n+\t\t\tfindOrCreateUnreconciledPaymentsAndLinkToBankStatementLine(line);\n+\t\t\treconcilePaymentsFromBankStatementLine_Ref(bankStatementDAO, line);\n+\t\t}\n+\t}\n+\n+\t@VisibleForTesting\n+\tvoid findOrCreateUnreconciledPaymentsAndLinkToBankStatementLine(final I_C_BankStatementLine line)\n+\t{\n+\t\tfindAndLinkPaymentToBankStatementLineIfPossible(line);\n+\n+\t\tsetOrCreateAndLinkPaymentToBankStatementLine(line, null);\n+\t}\n+\n+\t@Override\n+\tpublic Optional<PaymentId> setOrCreateAndLinkPaymentToBankStatementLine(@NonNull final I_C_BankStatementLine line, @Nullable final PaymentId paymentIdToSet)\n+\t{\n+\t\t// a payment is already linked\n+\t\tif (line.getC_Payment_ID() > 0)\n+\t\t{\n+\t\t\treturn Optional.of(PaymentId.ofRepoId(line.getC_Payment_ID()));\n+\t\t}\n+\n+\t\tif (paymentIdToSet != null)\n+\t\t{\n+\t\t\tline.setC_Payment_ID(paymentIdToSet.getRepoId());\n+\t\t\tInterfaceWrapperHelper.save(line);\n+\t\t\treturn Optional.of(paymentIdToSet);\n+\t\t}\n+\n+\t\tif (line.getC_BPartner_ID() <= 0)\n+\t\t{\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\n+\t\tfinal CurrencyId currencyId = CurrencyId.ofRepoId(line.getC_Currency_ID());\n+\t\tfinal BPartnerId bpartnerId = BPartnerId.ofRepoId(line.getC_BPartner_ID());\n+\t\tfinal OrgId orgId = OrgId.ofRepoId(line.getAD_Org_ID());\n+\t\tfinal LocalDate statementLineDate = TimeUtil.asLocalDate(line.getStatementLineDate());\n+\n+\t\tfinal Optional<BankAccountId> bankAccountIdOptional = Services.get(IBPBankAccountDAO.class).retrieveFirstIdByBPartnerAndCurrency(bpartnerId, currencyId);\n+\t\tif (!bankAccountIdOptional.isPresent())\n+\t\t{\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\n+\t\tfinal boolean isReceipt = line.getStmtAmt().signum() >= 0;\n+\t\tfinal BigDecimal payAmount = isReceipt ? line.getStmtAmt() : line.getStmtAmt().negate();\n+\n+\t\tfinal PaymentId createdPaymentId = createAndCompletePayment(bankAccountIdOptional.get(), statementLineDate, payAmount, isReceipt, orgId, bpartnerId, currencyId);\n+\t\tline.setC_Payment_ID(createdPaymentId.getRepoId());\n+\t\tInterfaceWrapperHelper.save(line);\n+\t\treturn Optional.of(createdPaymentId);\n+\t}\n+\n+\tprivate void findAndLinkPaymentToBankStatementLineIfPossible(final I_C_BankStatementLine line)\n+\t{\n+\t\t// a payment is already linked\n+\t\tif (line.getC_Payment_ID() > 0)\n+\t\t{\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tfinal boolean isReceipt = line.getStmtAmt().signum() >= 0;\n+\t\tfinal BigDecimal expectedPaymentAmount = isReceipt ? line.getStmtAmt() : line.getStmtAmt().negate();\n+\n+\t\tfinal ImmutableSet<PaymentId> possiblePayments = Services.get(IPaymentDAO.class).retrieveAllMatchingPayments(isReceipt, expectedPaymentAmount, CurrencyId.ofRepoId(line.getC_Currency_ID()), BPartnerId.ofRepoId(line.getC_BPartner_ID()));\n+\n+\t\t// don't create a new Payment and don't link any of the payments.\n+\t\t// the user must fix this case manually\n+\t\tif (possiblePayments.size() > 1)\n+\t\t{\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tif (possiblePayments.size() == 1)\n+\t\t{\n+\t\t\tline.setC_Payment_ID(possiblePayments.iterator().next().getRepoId());\n+\t\t\tInterfaceWrapperHelper.save(line);\n+\t\t}\n+\t}\n+\n+\tprivate PaymentId createAndCompletePayment(\n+\t\t\t@NonNull final BankAccountId bankAccountId,\n+\t\t\t@NonNull final LocalDate dateAcct,\n+\t\t\t@NonNull final BigDecimal payAmt,\n+\t\t\tfinal boolean isReceipt,\n+\t\t\t@NonNull final OrgId adOrgId,\n+\t\t\t@NonNull final BPartnerId bpartnerId,\n+\t\t\t@NonNull final CurrencyId currencyId)\n+\t{\n+\t\tfinal DefaultPaymentBuilder paymentBuilder;\n+\n+\t\tif (isReceipt)\n+\t\t{\n+\t\t\tpaymentBuilder = Services.get(IPaymentBL.class).newInboundReceiptBuilder();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e483c8455e73d08ebd4f2cb513890451b55d94f"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjgzODQ3MQ==", "bodyText": "done", "url": "https://github.com/metasfresh/metasfresh/pull/6089#discussion_r372838471", "createdAt": "2020-01-30T09:26:59Z", "author": {"login": "TheBestPessimist"}, "path": "de.metas.banking/de.metas.banking.base/src/main/java/de/metas/banking/service/impl/BankStatementBL.java", "diffHunk": "@@ -97,16 +111,133 @@ public void handleAfterComplete(final I_C_BankStatement bankStatement)\n \t\t{\n \t\t\tfinal I_C_BankStatementLine line = InterfaceWrapperHelper.create(linePO, I_C_BankStatementLine.class);\n \n-\t\t\tif (line.isMultiplePaymentOrInvoice() && line.isMultiplePayment())\n+\t\t\tfindOrCreateUnreconciledPaymentsAndLinkToBankStatementLine(line);\n+\t\t\treconcilePaymentsFromBankStatementLine_Ref(bankStatementDAO, line);\n+\t\t}\n+\t}\n+\n+\t@VisibleForTesting\n+\tvoid findOrCreateUnreconciledPaymentsAndLinkToBankStatementLine(final I_C_BankStatementLine line)\n+\t{\n+\t\tfindAndLinkPaymentToBankStatementLineIfPossible(line);\n+\n+\t\tsetOrCreateAndLinkPaymentToBankStatementLine(line, null);\n+\t}\n+\n+\t@Override\n+\tpublic Optional<PaymentId> setOrCreateAndLinkPaymentToBankStatementLine(@NonNull final I_C_BankStatementLine line, @Nullable final PaymentId paymentIdToSet)\n+\t{\n+\t\t// a payment is already linked\n+\t\tif (line.getC_Payment_ID() > 0)\n+\t\t{\n+\t\t\treturn Optional.of(PaymentId.ofRepoId(line.getC_Payment_ID()));\n+\t\t}\n+\n+\t\tif (paymentIdToSet != null)\n+\t\t{\n+\t\t\tline.setC_Payment_ID(paymentIdToSet.getRepoId());\n+\t\t\tInterfaceWrapperHelper.save(line);\n+\t\t\treturn Optional.of(paymentIdToSet);\n+\t\t}\n+\n+\t\tif (line.getC_BPartner_ID() <= 0)\n+\t\t{\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\n+\t\tfinal CurrencyId currencyId = CurrencyId.ofRepoId(line.getC_Currency_ID());\n+\t\tfinal BPartnerId bpartnerId = BPartnerId.ofRepoId(line.getC_BPartner_ID());\n+\t\tfinal OrgId orgId = OrgId.ofRepoId(line.getAD_Org_ID());\n+\t\tfinal LocalDate statementLineDate = TimeUtil.asLocalDate(line.getStatementLineDate());\n+\n+\t\tfinal Optional<BankAccountId> bankAccountIdOptional = Services.get(IBPBankAccountDAO.class).retrieveFirstIdByBPartnerAndCurrency(bpartnerId, currencyId);\n+\t\tif (!bankAccountIdOptional.isPresent())\n+\t\t{\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\n+\t\tfinal boolean isReceipt = line.getStmtAmt().signum() >= 0;\n+\t\tfinal BigDecimal payAmount = isReceipt ? line.getStmtAmt() : line.getStmtAmt().negate();\n+\n+\t\tfinal PaymentId createdPaymentId = createAndCompletePayment(bankAccountIdOptional.get(), statementLineDate, payAmount, isReceipt, orgId, bpartnerId, currencyId);\n+\t\tline.setC_Payment_ID(createdPaymentId.getRepoId());\n+\t\tInterfaceWrapperHelper.save(line);\n+\t\treturn Optional.of(createdPaymentId);\n+\t}\n+\n+\tprivate void findAndLinkPaymentToBankStatementLineIfPossible(final I_C_BankStatementLine line)\n+\t{\n+\t\t// a payment is already linked\n+\t\tif (line.getC_Payment_ID() > 0)\n+\t\t{\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tfinal boolean isReceipt = line.getStmtAmt().signum() >= 0;\n+\t\tfinal BigDecimal expectedPaymentAmount = isReceipt ? line.getStmtAmt() : line.getStmtAmt().negate();\n+\n+\t\tfinal ImmutableSet<PaymentId> possiblePayments = Services.get(IPaymentDAO.class).retrieveAllMatchingPayments(isReceipt, expectedPaymentAmount, CurrencyId.ofRepoId(line.getC_Currency_ID()), BPartnerId.ofRepoId(line.getC_BPartner_ID()));\n+\n+\t\t// don't create a new Payment and don't link any of the payments.\n+\t\t// the user must fix this case manually\n+\t\tif (possiblePayments.size() > 1)\n+\t\t{\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tif (possiblePayments.size() == 1)\n+\t\t{\n+\t\t\tline.setC_Payment_ID(possiblePayments.iterator().next().getRepoId());\n+\t\t\tInterfaceWrapperHelper.save(line);\n+\t\t}\n+\t}\n+\n+\tprivate PaymentId createAndCompletePayment(\n+\t\t\t@NonNull final BankAccountId bankAccountId,\n+\t\t\t@NonNull final LocalDate dateAcct,\n+\t\t\t@NonNull final BigDecimal payAmt,\n+\t\t\tfinal boolean isReceipt,\n+\t\t\t@NonNull final OrgId adOrgId,\n+\t\t\t@NonNull final BPartnerId bpartnerId,\n+\t\t\t@NonNull final CurrencyId currencyId)\n+\t{\n+\t\tfinal DefaultPaymentBuilder paymentBuilder;\n+\n+\t\tif (isReceipt)\n+\t\t{\n+\t\t\tpaymentBuilder = Services.get(IPaymentBL.class).newInboundReceiptBuilder();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc5Nzc1Nw=="}, "originalCommit": {"oid": "8e483c8455e73d08ebd4f2cb513890451b55d94f"}, "originalPosition": 146}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwNTAyMDA5OnYy", "diffSide": "RIGHT", "path": "de.metas.business/src/main/java/de/metas/payment/api/IPaymentDAO.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQwNzo1MTo1MFrOFjh58A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQwOTozMTo0MlrOFjkZaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc5OTk4NA==", "bodyText": "use Money instead of BigDecimal paymentAmount  and CurrencyId currencyId,", "url": "https://github.com/metasfresh/metasfresh/pull/6089#discussion_r372799984", "createdAt": "2020-01-30T07:51:50Z", "author": {"login": "teosarca"}, "path": "de.metas.business/src/main/java/de/metas/payment/api/IPaymentDAO.java", "diffHunk": "@@ -113,4 +99,6 @@\n \t * Updates the discount and the payment based on DateTrx and the payment term policy.\n \t */\n \tvoid updateDiscountAndPayment(I_C_Payment payment, int c_Invoice_ID, I_C_DocType c_DocType);\n+\n+\tImmutableSet<PaymentId> retrieveAllMatchingPayments(boolean isReceipt, @NonNull BigDecimal paymentAmount, @NonNull CurrencyId currencyId, @NonNull BPartnerId bPartnerId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e483c8455e73d08ebd4f2cb513890451b55d94f"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg0MDgwOQ==", "bodyText": "done", "url": "https://github.com/metasfresh/metasfresh/pull/6089#discussion_r372840809", "createdAt": "2020-01-30T09:31:42Z", "author": {"login": "TheBestPessimist"}, "path": "de.metas.business/src/main/java/de/metas/payment/api/IPaymentDAO.java", "diffHunk": "@@ -113,4 +99,6 @@\n \t * Updates the discount and the payment based on DateTrx and the payment term policy.\n \t */\n \tvoid updateDiscountAndPayment(I_C_Payment payment, int c_Invoice_ID, I_C_DocType c_DocType);\n+\n+\tImmutableSet<PaymentId> retrieveAllMatchingPayments(boolean isReceipt, @NonNull BigDecimal paymentAmount, @NonNull CurrencyId currencyId, @NonNull BPartnerId bPartnerId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc5OTk4NA=="}, "originalCommit": {"oid": "8e483c8455e73d08ebd4f2cb513890451b55d94f"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwNTAyMTI0OnYy", "diffSide": "RIGHT", "path": "de.metas.business/src/main/java/de/metas/payment/api/impl/AbstractPaymentDAO.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQwNzo1MjoyMlrOFjh6pg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQwOTozMjowMFrOFjkaAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjgwMDE2Ng==", "bodyText": "again, use  Money", "url": "https://github.com/metasfresh/metasfresh/pull/6089#discussion_r372800166", "createdAt": "2020-01-30T07:52:22Z", "author": {"login": "teosarca"}, "path": "de.metas.business/src/main/java/de/metas/payment/api/impl/AbstractPaymentDAO.java", "diffHunk": "@@ -217,4 +219,20 @@ public BigDecimal getInvoiceOpenAmount(I_C_Payment payment, final boolean credit\n \t */\n \t@Override\n \tpublic abstract void updateDiscountAndPayment(I_C_Payment payment, int c_Invoice_ID, I_C_DocType c_DocType);\n+\n+\t@Override\n+\tpublic ImmutableSet<PaymentId> retrieveAllMatchingPayments(final boolean isReceipt, @NonNull final BigDecimal paymentAmount, @NonNull final CurrencyId currencyId, @NonNull final BPartnerId bPartnerId)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e483c8455e73d08ebd4f2cb513890451b55d94f"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg0MDk2MA==", "bodyText": "done", "url": "https://github.com/metasfresh/metasfresh/pull/6089#discussion_r372840960", "createdAt": "2020-01-30T09:32:00Z", "author": {"login": "TheBestPessimist"}, "path": "de.metas.business/src/main/java/de/metas/payment/api/impl/AbstractPaymentDAO.java", "diffHunk": "@@ -217,4 +219,20 @@ public BigDecimal getInvoiceOpenAmount(I_C_Payment payment, final boolean credit\n \t */\n \t@Override\n \tpublic abstract void updateDiscountAndPayment(I_C_Payment payment, int c_Invoice_ID, I_C_DocType c_DocType);\n+\n+\t@Override\n+\tpublic ImmutableSet<PaymentId> retrieveAllMatchingPayments(final boolean isReceipt, @NonNull final BigDecimal paymentAmount, @NonNull final CurrencyId currencyId, @NonNull final BPartnerId bPartnerId)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjgwMDE2Ng=="}, "originalCommit": {"oid": "8e483c8455e73d08ebd4f2cb513890451b55d94f"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxNzEyOTQ3OnYy", "diffSide": "RIGHT", "path": "de.metas.banking/de.metas.banking.base/src/main/java/de/metas/banking/impexp/BankStatementImportTableSqlUpdater.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQxMzozNTo0OFrOFlUMYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQwNjoyMjowN1rOFls4Og==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDY3MjQ4MA==", "bodyText": "bankStatementDate shall be LocalDate.", "url": "https://github.com/metasfresh/metasfresh/pull/6089#discussion_r374672480", "createdAt": "2020-02-04T13:35:48Z", "author": {"login": "teosarca"}, "path": "de.metas.banking/de.metas.banking.base/src/main/java/de/metas/banking/impexp/BankStatementImportTableSqlUpdater.java", "diffHunk": "@@ -79,11 +94,24 @@ private void updateName(final ImportRecordsSelection selection)\n \t\t\t\t.append(\" AND i.I_IsImported<>'Y' \")\n \t\t\t\t.append(selection.toSqlWhereClause(\"i\"));\n \t\tDB.executeUpdateEx(sql.toString(), ITrx.TRXNAME_ThreadInherited);\n-\n \t}\n \n-\tprivate void updateStatementDate(final ImportRecordsSelection selection)\n+\tprivate void updateStatementDate(final ImportRecordsSelection selection, @Nullable final Timestamp bankStatementDate)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d27ed29d5195fe90cee62eed0a1ba932ba9c1cd"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTA3NjkyMg==", "bodyText": "done", "url": "https://github.com/metasfresh/metasfresh/pull/6089#discussion_r375076922", "createdAt": "2020-02-05T06:22:07Z", "author": {"login": "TheBestPessimist"}, "path": "de.metas.banking/de.metas.banking.base/src/main/java/de/metas/banking/impexp/BankStatementImportTableSqlUpdater.java", "diffHunk": "@@ -79,11 +94,24 @@ private void updateName(final ImportRecordsSelection selection)\n \t\t\t\t.append(\" AND i.I_IsImported<>'Y' \")\n \t\t\t\t.append(selection.toSqlWhereClause(\"i\"));\n \t\tDB.executeUpdateEx(sql.toString(), ITrx.TRXNAME_ThreadInherited);\n-\n \t}\n \n-\tprivate void updateStatementDate(final ImportRecordsSelection selection)\n+\tprivate void updateStatementDate(final ImportRecordsSelection selection, @Nullable final Timestamp bankStatementDate)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDY3MjQ4MA=="}, "originalCommit": {"oid": "9d27ed29d5195fe90cee62eed0a1ba932ba9c1cd"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxNzEzMzkwOnYy", "diffSide": "RIGHT", "path": "de.metas.banking/de.metas.banking.base/src/main/java/de/metas/banking/impexp/BankStatementImportTableSqlUpdater.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQxMzozNzoxNFrOFlUPEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQwNzowNzowNFrOFltkNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDY3MzE3MA==", "bodyText": "use DB.TO_DATE(LocalDate) (u have to introduce it :) )", "url": "https://github.com/metasfresh/metasfresh/pull/6089#discussion_r374673170", "createdAt": "2020-02-04T13:37:14Z", "author": {"login": "teosarca"}, "path": "de.metas.banking/de.metas.banking.base/src/main/java/de/metas/banking/impexp/BankStatementImportTableSqlUpdater.java", "diffHunk": "@@ -79,11 +94,24 @@ private void updateName(final ImportRecordsSelection selection)\n \t\t\t\t.append(\" AND i.I_IsImported<>'Y' \")\n \t\t\t\t.append(selection.toSqlWhereClause(\"i\"));\n \t\tDB.executeUpdateEx(sql.toString(), ITrx.TRXNAME_ThreadInherited);\n-\n \t}\n \n-\tprivate void updateStatementDate(final ImportRecordsSelection selection)\n+\tprivate void updateStatementDate(final ImportRecordsSelection selection, @Nullable final Timestamp bankStatementDate)\n \t{\n+\t\tif (bankStatementDate != null)\n+\t\t{\n+\t\t\tfinal StringBuilder sql = new StringBuilder(\"UPDATE \")\n+\t\t\t\t\t.append(I_I_BankStatement.Table_Name + \" i \")\n+\t\t\t\t\t.append(\" SET \"\n+\t\t\t\t\t\t\t+ I_I_BankStatement.COLUMNNAME_StatementDate\n+\t\t\t\t\t\t\t+ \" = '\" + bankStatementDate.toString() + \"':: timestamp without time zone\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d27ed29d5195fe90cee62eed0a1ba932ba9c1cd"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTA4ODE4MA==", "bodyText": "done", "url": "https://github.com/metasfresh/metasfresh/pull/6089#discussion_r375088180", "createdAt": "2020-02-05T07:07:04Z", "author": {"login": "TheBestPessimist"}, "path": "de.metas.banking/de.metas.banking.base/src/main/java/de/metas/banking/impexp/BankStatementImportTableSqlUpdater.java", "diffHunk": "@@ -79,11 +94,24 @@ private void updateName(final ImportRecordsSelection selection)\n \t\t\t\t.append(\" AND i.I_IsImported<>'Y' \")\n \t\t\t\t.append(selection.toSqlWhereClause(\"i\"));\n \t\tDB.executeUpdateEx(sql.toString(), ITrx.TRXNAME_ThreadInherited);\n-\n \t}\n \n-\tprivate void updateStatementDate(final ImportRecordsSelection selection)\n+\tprivate void updateStatementDate(final ImportRecordsSelection selection, @Nullable final Timestamp bankStatementDate)\n \t{\n+\t\tif (bankStatementDate != null)\n+\t\t{\n+\t\t\tfinal StringBuilder sql = new StringBuilder(\"UPDATE \")\n+\t\t\t\t\t.append(I_I_BankStatement.Table_Name + \" i \")\n+\t\t\t\t\t.append(\" SET \"\n+\t\t\t\t\t\t\t+ I_I_BankStatement.COLUMNNAME_StatementDate\n+\t\t\t\t\t\t\t+ \" = '\" + bankStatementDate.toString() + \"':: timestamp without time zone\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDY3MzE3MA=="}, "originalCommit": {"oid": "9d27ed29d5195fe90cee62eed0a1ba932ba9c1cd"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxNzUxNDc5OnYy", "diffSide": "RIGHT", "path": "de.metas.banking/de.metas.banking.base/src/main/java/de/metas/banking/payment/impl/BankStatmentPaymentBL.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQxNToxNzozMVrOFlX46g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQwNzowOTo1OFrOFltnJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDczMzAzNA==", "bodyText": "consider saving the payment  in some payment DAO/repo class", "url": "https://github.com/metasfresh/metasfresh/pull/6089#discussion_r374733034", "createdAt": "2020-02-04T15:17:31Z", "author": {"login": "teosarca"}, "path": "de.metas.banking/de.metas.banking.base/src/main/java/de/metas/banking/payment/impl/BankStatmentPaymentBL.java", "diffHunk": "@@ -102,23 +113,150 @@ public void setC_Payment(IBankStatementLineOrRef lineOrRef, I_C_Payment payment)\n \t\t// Bank Statement Line specific:\n \t\tif (lineOrRef instanceof org.compiere.model.I_C_BankStatementLine)\n \t\t{\n-\t\t\torg.compiere.model.I_C_BankStatementLine bsl = (org.compiere.model.I_C_BankStatementLine)lineOrRef;\n+\t\t\tfinal org.compiere.model.I_C_BankStatementLine bsl = (org.compiere.model.I_C_BankStatementLine)lineOrRef;\n \t\t\tbsl.setDescription(payment.getDescription());\n \t\t}\n \t}\n \n-\tpublic void setPayAmt(IBankStatementLineOrRef lineOrRef, BigDecimal payAmt)\n+\t@Override\n+\tpublic void findOrCreateUnreconciledPaymentsAndLinkToBankStatementLine(final de.metas.banking.model.I_C_BankStatementLine line)\n+\t{\n+\t\tfinal boolean manualActionRequired = findAndLinkPaymentToBankStatementLineIfPossible(line);\n+\n+\t\tif (!manualActionRequired)\n+\t\t{\n+\t\t\tsetOrCreateAndLinkPaymentToBankStatementLine(line, null);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * @return true if the automatic flow should STOP as manual action is required; false if the automatic flow should continue\n+\t */\n+\tprivate boolean findAndLinkPaymentToBankStatementLineIfPossible(final de.metas.banking.model.I_C_BankStatementLine line)\n+\t{\n+\t\t// a payment is already linked\n+\t\tif (line.getC_Payment_ID() > 0)\n+\t\t{\n+\t\t\treturn true;\n+\t\t}\n+\t\tif (line.getC_BPartner_ID() <= 0)\n+\t\t{\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tfinal boolean isReceipt = line.getStmtAmt().signum() >= 0;\n+\t\tfinal BigDecimal expectedPaymentAmount = isReceipt ? line.getStmtAmt() : line.getStmtAmt().negate();\n+\n+\t\tfinal Money money = Money.of(expectedPaymentAmount, CurrencyId.ofRepoId(line.getC_Currency_ID()));\n+\t\tfinal BPartnerId bPartnerId = BPartnerId.ofRepoId(line.getC_BPartner_ID());\n+\t\tfinal ImmutableSet<PaymentId> possiblePayments = Services.get(IPaymentDAO.class).retrieveAllMatchingPayments(isReceipt, bPartnerId, money);\n+\n+\t\t// Don't create a new Payment and don't link any of the existing payments if there are multiple payments found.\n+\t\t// The user must fix this case manually by choosing the correct Payment\n+\t\tif (possiblePayments.size() > 1)\n+\t\t{\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tif (possiblePayments.size() == 1)\n+\t\t{\n+\t\t\tline.setC_Payment_ID(possiblePayments.iterator().next().getRepoId());\n+\t\t\tInterfaceWrapperHelper.save(line);\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\t@Override\n+\tpublic Optional<PaymentId> setOrCreateAndLinkPaymentToBankStatementLine(@NonNull final de.metas.banking.model.I_C_BankStatementLine line, @Nullable final PaymentId paymentIdToSet)\n+\t{\n+\t\t// a payment is already linked\n+\t\tif (line.getC_Payment_ID() > 0)\n+\t\t{\n+\t\t\treturn Optional.of(PaymentId.ofRepoId(line.getC_Payment_ID()));\n+\t\t}\n+\n+\t\tif (paymentIdToSet != null)\n+\t\t{\n+\t\t\tfinal I_C_Payment payment = Services.get(IPaymentDAO.class).getById(paymentIdToSet);\n+\t\t\tsetC_Payment(line, payment);\n+\n+\t\t\tInterfaceWrapperHelper.save(line);\n+\t\t\tInterfaceWrapperHelper.save(payment);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d27ed29d5195fe90cee62eed0a1ba932ba9c1cd"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTA4ODkzMw==", "bodyText": "done", "url": "https://github.com/metasfresh/metasfresh/pull/6089#discussion_r375088933", "createdAt": "2020-02-05T07:09:58Z", "author": {"login": "TheBestPessimist"}, "path": "de.metas.banking/de.metas.banking.base/src/main/java/de/metas/banking/payment/impl/BankStatmentPaymentBL.java", "diffHunk": "@@ -102,23 +113,150 @@ public void setC_Payment(IBankStatementLineOrRef lineOrRef, I_C_Payment payment)\n \t\t// Bank Statement Line specific:\n \t\tif (lineOrRef instanceof org.compiere.model.I_C_BankStatementLine)\n \t\t{\n-\t\t\torg.compiere.model.I_C_BankStatementLine bsl = (org.compiere.model.I_C_BankStatementLine)lineOrRef;\n+\t\t\tfinal org.compiere.model.I_C_BankStatementLine bsl = (org.compiere.model.I_C_BankStatementLine)lineOrRef;\n \t\t\tbsl.setDescription(payment.getDescription());\n \t\t}\n \t}\n \n-\tpublic void setPayAmt(IBankStatementLineOrRef lineOrRef, BigDecimal payAmt)\n+\t@Override\n+\tpublic void findOrCreateUnreconciledPaymentsAndLinkToBankStatementLine(final de.metas.banking.model.I_C_BankStatementLine line)\n+\t{\n+\t\tfinal boolean manualActionRequired = findAndLinkPaymentToBankStatementLineIfPossible(line);\n+\n+\t\tif (!manualActionRequired)\n+\t\t{\n+\t\t\tsetOrCreateAndLinkPaymentToBankStatementLine(line, null);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * @return true if the automatic flow should STOP as manual action is required; false if the automatic flow should continue\n+\t */\n+\tprivate boolean findAndLinkPaymentToBankStatementLineIfPossible(final de.metas.banking.model.I_C_BankStatementLine line)\n+\t{\n+\t\t// a payment is already linked\n+\t\tif (line.getC_Payment_ID() > 0)\n+\t\t{\n+\t\t\treturn true;\n+\t\t}\n+\t\tif (line.getC_BPartner_ID() <= 0)\n+\t\t{\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tfinal boolean isReceipt = line.getStmtAmt().signum() >= 0;\n+\t\tfinal BigDecimal expectedPaymentAmount = isReceipt ? line.getStmtAmt() : line.getStmtAmt().negate();\n+\n+\t\tfinal Money money = Money.of(expectedPaymentAmount, CurrencyId.ofRepoId(line.getC_Currency_ID()));\n+\t\tfinal BPartnerId bPartnerId = BPartnerId.ofRepoId(line.getC_BPartner_ID());\n+\t\tfinal ImmutableSet<PaymentId> possiblePayments = Services.get(IPaymentDAO.class).retrieveAllMatchingPayments(isReceipt, bPartnerId, money);\n+\n+\t\t// Don't create a new Payment and don't link any of the existing payments if there are multiple payments found.\n+\t\t// The user must fix this case manually by choosing the correct Payment\n+\t\tif (possiblePayments.size() > 1)\n+\t\t{\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tif (possiblePayments.size() == 1)\n+\t\t{\n+\t\t\tline.setC_Payment_ID(possiblePayments.iterator().next().getRepoId());\n+\t\t\tInterfaceWrapperHelper.save(line);\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\t@Override\n+\tpublic Optional<PaymentId> setOrCreateAndLinkPaymentToBankStatementLine(@NonNull final de.metas.banking.model.I_C_BankStatementLine line, @Nullable final PaymentId paymentIdToSet)\n+\t{\n+\t\t// a payment is already linked\n+\t\tif (line.getC_Payment_ID() > 0)\n+\t\t{\n+\t\t\treturn Optional.of(PaymentId.ofRepoId(line.getC_Payment_ID()));\n+\t\t}\n+\n+\t\tif (paymentIdToSet != null)\n+\t\t{\n+\t\t\tfinal I_C_Payment payment = Services.get(IPaymentDAO.class).getById(paymentIdToSet);\n+\t\t\tsetC_Payment(line, payment);\n+\n+\t\t\tInterfaceWrapperHelper.save(line);\n+\t\t\tInterfaceWrapperHelper.save(payment);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDczMzAzNA=="}, "originalCommit": {"oid": "9d27ed29d5195fe90cee62eed0a1ba932ba9c1cd"}, "originalPosition": 160}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxNzU0MDIzOnYy", "diffSide": "RIGHT", "path": "de.metas.banking/de.metas.banking.base/src/main/java/de/metas/banking/process/C_BankStatement_ImportAttachment.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQxNToyMjo0NlrOFlYIKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQwNzoxNzozM1rOFltwJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDczNjkzNw==", "bodyText": "pls deprecated getSelectedModel method\npls use IBankStatementDAO.getById", "url": "https://github.com/metasfresh/metasfresh/pull/6089#discussion_r374736937", "createdAt": "2020-02-04T15:22:46Z", "author": {"login": "teosarca"}, "path": "de.metas.banking/de.metas.banking.base/src/main/java/de/metas/banking/process/C_BankStatement_ImportAttachment.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * #%L\n+ * de.metas.banking.base\n+ * %%\n+ * Copyright (C) 2019 metas GmbH\n+ * %%\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as\n+ * published by the Free Software Foundation, either version 2 of the\n+ * License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public\n+ * License along with this program. If not, see\n+ * <http://www.gnu.org/licenses/gpl-2.0.html>.\n+ * #L%\n+ */\n+\n+package de.metas.banking.process;\n+\n+import com.google.common.collect.ImmutableMap;\n+import de.metas.attachments.AttachmentEntryDataResource;\n+import de.metas.attachments.AttachmentEntryId;\n+import de.metas.attachments.AttachmentEntryService;\n+import de.metas.banking.model.I_C_BankStatement;\n+import de.metas.banking.service.IBankStatementDAO;\n+import de.metas.document.engine.DocStatus;\n+import de.metas.i18n.IMsgBL;\n+import de.metas.impexp.DataImportRequest;\n+import de.metas.impexp.DataImportService;\n+import de.metas.impexp.config.DataImportConfigId;\n+import de.metas.process.IProcessPrecondition;\n+import de.metas.process.IProcessPreconditionsContext;\n+import de.metas.process.JavaProcess;\n+import de.metas.process.Param;\n+import de.metas.process.ProcessPreconditionsResolution;\n+import de.metas.process.RunOutOfTrx;\n+import de.metas.util.Services;\n+import lombok.NonNull;\n+import org.adempiere.util.api.Params;\n+import org.compiere.SpringContextHolder;\n+import org.compiere.model.I_AD_AttachmentEntry;\n+import org.compiere.model.I_I_BankStatement;\n+\n+public class C_BankStatement_ImportAttachment extends JavaProcess implements IProcessPrecondition\n+{\n+\t/*\n+\tHaving DataImportConfigId hardcoded is fine.\n+\tWe could use a sysconfig, but what shall we store there? the ID? the InternalName? (internal name is editable by user). That won't change/fix anything.\n+\tIf you have a better suggestion, please ping me.\n+\t */\n+\tpublic static final DataImportConfigId HARDCODED_BANK_STATEMENT_DATA_IMPORT_REPO_ID = DataImportConfigId.ofRepoId(540009);\n+\n+\t@Param(parameterName = I_AD_AttachmentEntry.COLUMNNAME_AD_AttachmentEntry_ID, mandatory = true)\n+\tprivate AttachmentEntryId p_AD_AttachmentEntry_ID;\n+\n+\tprivate static final String BANK_STATEMENT_MUST_BE_IN_PROGRESS_MSG = \"Bank Statement must be in progress.\";\n+\n+\tprivate final IMsgBL iMsgBL = Services.get(IMsgBL.class);\n+\tprivate final AttachmentEntryService attachmentEntryService = SpringContextHolder.instance.getBean(AttachmentEntryService.class);\n+\tprivate final transient DataImportService dataImportService = SpringContextHolder.instance.getBean(DataImportService.class);\n+\n+\t@Override\n+\tpublic ProcessPreconditionsResolution checkPreconditionsApplicable(@NonNull final IProcessPreconditionsContext context)\n+\t{\n+\t\tif (context.isNoSelection())\n+\t\t{\n+\t\t\treturn ProcessPreconditionsResolution.rejectBecauseNoSelection();\n+\t\t}\n+\n+\t\tif (!context.isSingleSelection())\n+\t\t{\n+\t\t\treturn ProcessPreconditionsResolution.rejectBecauseNotSingleSelection();\n+\t\t}\n+\n+\t\tfinal I_C_BankStatement selectedBankStatement = context.getSelectedModel(I_C_BankStatement.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d27ed29d5195fe90cee62eed0a1ba932ba9c1cd"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTA5MTIzOA==", "bodyText": "done.\ni see that context.getSelectedModel is replaced by context.getSingleSelectedRecordId(), but what about context.getSelectedModels()? i see no replacement which returns a set of IDs.", "url": "https://github.com/metasfresh/metasfresh/pull/6089#discussion_r375091238", "createdAt": "2020-02-05T07:17:33Z", "author": {"login": "TheBestPessimist"}, "path": "de.metas.banking/de.metas.banking.base/src/main/java/de/metas/banking/process/C_BankStatement_ImportAttachment.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * #%L\n+ * de.metas.banking.base\n+ * %%\n+ * Copyright (C) 2019 metas GmbH\n+ * %%\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as\n+ * published by the Free Software Foundation, either version 2 of the\n+ * License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public\n+ * License along with this program. If not, see\n+ * <http://www.gnu.org/licenses/gpl-2.0.html>.\n+ * #L%\n+ */\n+\n+package de.metas.banking.process;\n+\n+import com.google.common.collect.ImmutableMap;\n+import de.metas.attachments.AttachmentEntryDataResource;\n+import de.metas.attachments.AttachmentEntryId;\n+import de.metas.attachments.AttachmentEntryService;\n+import de.metas.banking.model.I_C_BankStatement;\n+import de.metas.banking.service.IBankStatementDAO;\n+import de.metas.document.engine.DocStatus;\n+import de.metas.i18n.IMsgBL;\n+import de.metas.impexp.DataImportRequest;\n+import de.metas.impexp.DataImportService;\n+import de.metas.impexp.config.DataImportConfigId;\n+import de.metas.process.IProcessPrecondition;\n+import de.metas.process.IProcessPreconditionsContext;\n+import de.metas.process.JavaProcess;\n+import de.metas.process.Param;\n+import de.metas.process.ProcessPreconditionsResolution;\n+import de.metas.process.RunOutOfTrx;\n+import de.metas.util.Services;\n+import lombok.NonNull;\n+import org.adempiere.util.api.Params;\n+import org.compiere.SpringContextHolder;\n+import org.compiere.model.I_AD_AttachmentEntry;\n+import org.compiere.model.I_I_BankStatement;\n+\n+public class C_BankStatement_ImportAttachment extends JavaProcess implements IProcessPrecondition\n+{\n+\t/*\n+\tHaving DataImportConfigId hardcoded is fine.\n+\tWe could use a sysconfig, but what shall we store there? the ID? the InternalName? (internal name is editable by user). That won't change/fix anything.\n+\tIf you have a better suggestion, please ping me.\n+\t */\n+\tpublic static final DataImportConfigId HARDCODED_BANK_STATEMENT_DATA_IMPORT_REPO_ID = DataImportConfigId.ofRepoId(540009);\n+\n+\t@Param(parameterName = I_AD_AttachmentEntry.COLUMNNAME_AD_AttachmentEntry_ID, mandatory = true)\n+\tprivate AttachmentEntryId p_AD_AttachmentEntry_ID;\n+\n+\tprivate static final String BANK_STATEMENT_MUST_BE_IN_PROGRESS_MSG = \"Bank Statement must be in progress.\";\n+\n+\tprivate final IMsgBL iMsgBL = Services.get(IMsgBL.class);\n+\tprivate final AttachmentEntryService attachmentEntryService = SpringContextHolder.instance.getBean(AttachmentEntryService.class);\n+\tprivate final transient DataImportService dataImportService = SpringContextHolder.instance.getBean(DataImportService.class);\n+\n+\t@Override\n+\tpublic ProcessPreconditionsResolution checkPreconditionsApplicable(@NonNull final IProcessPreconditionsContext context)\n+\t{\n+\t\tif (context.isNoSelection())\n+\t\t{\n+\t\t\treturn ProcessPreconditionsResolution.rejectBecauseNoSelection();\n+\t\t}\n+\n+\t\tif (!context.isSingleSelection())\n+\t\t{\n+\t\t\treturn ProcessPreconditionsResolution.rejectBecauseNotSingleSelection();\n+\t\t}\n+\n+\t\tfinal I_C_BankStatement selectedBankStatement = context.getSelectedModel(I_C_BankStatement.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDczNjkzNw=="}, "originalCommit": {"oid": "9d27ed29d5195fe90cee62eed0a1ba932ba9c1cd"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxNzU0NjAzOnYy", "diffSide": "RIGHT", "path": "de.metas.banking/de.metas.banking.base/src/main/java/de/metas/banking/process/C_BankStatement_ImportAttachment.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQxNToyNDowN1rOFlYLtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQwNzoxNzo0OFrOFltwXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDczNzg0Nw==", "bodyText": "introduce Services.get(IBankStatementDAO.class) as a field.\nNote u will need it in checkPreconditionsApplicable too", "url": "https://github.com/metasfresh/metasfresh/pull/6089#discussion_r374737847", "createdAt": "2020-02-04T15:24:07Z", "author": {"login": "teosarca"}, "path": "de.metas.banking/de.metas.banking.base/src/main/java/de/metas/banking/process/C_BankStatement_ImportAttachment.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * #%L\n+ * de.metas.banking.base\n+ * %%\n+ * Copyright (C) 2019 metas GmbH\n+ * %%\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as\n+ * published by the Free Software Foundation, either version 2 of the\n+ * License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public\n+ * License along with this program. If not, see\n+ * <http://www.gnu.org/licenses/gpl-2.0.html>.\n+ * #L%\n+ */\n+\n+package de.metas.banking.process;\n+\n+import com.google.common.collect.ImmutableMap;\n+import de.metas.attachments.AttachmentEntryDataResource;\n+import de.metas.attachments.AttachmentEntryId;\n+import de.metas.attachments.AttachmentEntryService;\n+import de.metas.banking.model.I_C_BankStatement;\n+import de.metas.banking.service.IBankStatementDAO;\n+import de.metas.document.engine.DocStatus;\n+import de.metas.i18n.IMsgBL;\n+import de.metas.impexp.DataImportRequest;\n+import de.metas.impexp.DataImportService;\n+import de.metas.impexp.config.DataImportConfigId;\n+import de.metas.process.IProcessPrecondition;\n+import de.metas.process.IProcessPreconditionsContext;\n+import de.metas.process.JavaProcess;\n+import de.metas.process.Param;\n+import de.metas.process.ProcessPreconditionsResolution;\n+import de.metas.process.RunOutOfTrx;\n+import de.metas.util.Services;\n+import lombok.NonNull;\n+import org.adempiere.util.api.Params;\n+import org.compiere.SpringContextHolder;\n+import org.compiere.model.I_AD_AttachmentEntry;\n+import org.compiere.model.I_I_BankStatement;\n+\n+public class C_BankStatement_ImportAttachment extends JavaProcess implements IProcessPrecondition\n+{\n+\t/*\n+\tHaving DataImportConfigId hardcoded is fine.\n+\tWe could use a sysconfig, but what shall we store there? the ID? the InternalName? (internal name is editable by user). That won't change/fix anything.\n+\tIf you have a better suggestion, please ping me.\n+\t */\n+\tpublic static final DataImportConfigId HARDCODED_BANK_STATEMENT_DATA_IMPORT_REPO_ID = DataImportConfigId.ofRepoId(540009);\n+\n+\t@Param(parameterName = I_AD_AttachmentEntry.COLUMNNAME_AD_AttachmentEntry_ID, mandatory = true)\n+\tprivate AttachmentEntryId p_AD_AttachmentEntry_ID;\n+\n+\tprivate static final String BANK_STATEMENT_MUST_BE_IN_PROGRESS_MSG = \"Bank Statement must be in progress.\";\n+\n+\tprivate final IMsgBL iMsgBL = Services.get(IMsgBL.class);\n+\tprivate final AttachmentEntryService attachmentEntryService = SpringContextHolder.instance.getBean(AttachmentEntryService.class);\n+\tprivate final transient DataImportService dataImportService = SpringContextHolder.instance.getBean(DataImportService.class);\n+\n+\t@Override\n+\tpublic ProcessPreconditionsResolution checkPreconditionsApplicable(@NonNull final IProcessPreconditionsContext context)\n+\t{\n+\t\tif (context.isNoSelection())\n+\t\t{\n+\t\t\treturn ProcessPreconditionsResolution.rejectBecauseNoSelection();\n+\t\t}\n+\n+\t\tif (!context.isSingleSelection())\n+\t\t{\n+\t\t\treturn ProcessPreconditionsResolution.rejectBecauseNotSingleSelection();\n+\t\t}\n+\n+\t\tfinal I_C_BankStatement selectedBankStatement = context.getSelectedModel(I_C_BankStatement.class);\n+\t\tfinal DocStatus docStatus = DocStatus.ofCode(selectedBankStatement.getDocStatus());\n+\t\tif (!docStatus.isDraftedOrInProgress())\n+\t\t{\n+\t\t\treturn ProcessPreconditionsResolution.reject(iMsgBL.getTranslatableMsgText(BANK_STATEMENT_MUST_BE_IN_PROGRESS_MSG));\n+\t\t}\n+\n+\t\treturn ProcessPreconditionsResolution.accept();\n+\t}\n+\n+\t@RunOutOfTrx\n+\t@Override\n+\tprotected String doIt() throws Exception\n+\t{\n+\t\tfinal AttachmentEntryDataResource data = attachmentEntryService.retrieveDataResource(getAttachmentEntryId());\n+\n+\t\tdataImportService.importData(DataImportRequest.builder()\n+\t\t\t\t.data(data)\n+\t\t\t\t.dataImportConfigId(HARDCODED_BANK_STATEMENT_DATA_IMPORT_REPO_ID)\n+\t\t\t\t.clientId(getClientId())\n+\t\t\t\t.orgId(getOrgId())\n+\t\t\t\t.userId(getUserId())\n+\t\t\t\t.additionalParameters(computeImportProcessParams())\n+\t\t\t\t.build());\n+\n+\t\treturn MSG_OK;\n+\t}\n+\n+\tprivate Params computeImportProcessParams()\n+\t{\n+\t\tfinal I_C_BankStatement bankStatement = Services.get(IBankStatementDAO.class).getById(getRecord_ID());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d27ed29d5195fe90cee62eed0a1ba932ba9c1cd"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTA5MTI5NA==", "bodyText": "done", "url": "https://github.com/metasfresh/metasfresh/pull/6089#discussion_r375091294", "createdAt": "2020-02-05T07:17:48Z", "author": {"login": "TheBestPessimist"}, "path": "de.metas.banking/de.metas.banking.base/src/main/java/de/metas/banking/process/C_BankStatement_ImportAttachment.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * #%L\n+ * de.metas.banking.base\n+ * %%\n+ * Copyright (C) 2019 metas GmbH\n+ * %%\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as\n+ * published by the Free Software Foundation, either version 2 of the\n+ * License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public\n+ * License along with this program. If not, see\n+ * <http://www.gnu.org/licenses/gpl-2.0.html>.\n+ * #L%\n+ */\n+\n+package de.metas.banking.process;\n+\n+import com.google.common.collect.ImmutableMap;\n+import de.metas.attachments.AttachmentEntryDataResource;\n+import de.metas.attachments.AttachmentEntryId;\n+import de.metas.attachments.AttachmentEntryService;\n+import de.metas.banking.model.I_C_BankStatement;\n+import de.metas.banking.service.IBankStatementDAO;\n+import de.metas.document.engine.DocStatus;\n+import de.metas.i18n.IMsgBL;\n+import de.metas.impexp.DataImportRequest;\n+import de.metas.impexp.DataImportService;\n+import de.metas.impexp.config.DataImportConfigId;\n+import de.metas.process.IProcessPrecondition;\n+import de.metas.process.IProcessPreconditionsContext;\n+import de.metas.process.JavaProcess;\n+import de.metas.process.Param;\n+import de.metas.process.ProcessPreconditionsResolution;\n+import de.metas.process.RunOutOfTrx;\n+import de.metas.util.Services;\n+import lombok.NonNull;\n+import org.adempiere.util.api.Params;\n+import org.compiere.SpringContextHolder;\n+import org.compiere.model.I_AD_AttachmentEntry;\n+import org.compiere.model.I_I_BankStatement;\n+\n+public class C_BankStatement_ImportAttachment extends JavaProcess implements IProcessPrecondition\n+{\n+\t/*\n+\tHaving DataImportConfigId hardcoded is fine.\n+\tWe could use a sysconfig, but what shall we store there? the ID? the InternalName? (internal name is editable by user). That won't change/fix anything.\n+\tIf you have a better suggestion, please ping me.\n+\t */\n+\tpublic static final DataImportConfigId HARDCODED_BANK_STATEMENT_DATA_IMPORT_REPO_ID = DataImportConfigId.ofRepoId(540009);\n+\n+\t@Param(parameterName = I_AD_AttachmentEntry.COLUMNNAME_AD_AttachmentEntry_ID, mandatory = true)\n+\tprivate AttachmentEntryId p_AD_AttachmentEntry_ID;\n+\n+\tprivate static final String BANK_STATEMENT_MUST_BE_IN_PROGRESS_MSG = \"Bank Statement must be in progress.\";\n+\n+\tprivate final IMsgBL iMsgBL = Services.get(IMsgBL.class);\n+\tprivate final AttachmentEntryService attachmentEntryService = SpringContextHolder.instance.getBean(AttachmentEntryService.class);\n+\tprivate final transient DataImportService dataImportService = SpringContextHolder.instance.getBean(DataImportService.class);\n+\n+\t@Override\n+\tpublic ProcessPreconditionsResolution checkPreconditionsApplicable(@NonNull final IProcessPreconditionsContext context)\n+\t{\n+\t\tif (context.isNoSelection())\n+\t\t{\n+\t\t\treturn ProcessPreconditionsResolution.rejectBecauseNoSelection();\n+\t\t}\n+\n+\t\tif (!context.isSingleSelection())\n+\t\t{\n+\t\t\treturn ProcessPreconditionsResolution.rejectBecauseNotSingleSelection();\n+\t\t}\n+\n+\t\tfinal I_C_BankStatement selectedBankStatement = context.getSelectedModel(I_C_BankStatement.class);\n+\t\tfinal DocStatus docStatus = DocStatus.ofCode(selectedBankStatement.getDocStatus());\n+\t\tif (!docStatus.isDraftedOrInProgress())\n+\t\t{\n+\t\t\treturn ProcessPreconditionsResolution.reject(iMsgBL.getTranslatableMsgText(BANK_STATEMENT_MUST_BE_IN_PROGRESS_MSG));\n+\t\t}\n+\n+\t\treturn ProcessPreconditionsResolution.accept();\n+\t}\n+\n+\t@RunOutOfTrx\n+\t@Override\n+\tprotected String doIt() throws Exception\n+\t{\n+\t\tfinal AttachmentEntryDataResource data = attachmentEntryService.retrieveDataResource(getAttachmentEntryId());\n+\n+\t\tdataImportService.importData(DataImportRequest.builder()\n+\t\t\t\t.data(data)\n+\t\t\t\t.dataImportConfigId(HARDCODED_BANK_STATEMENT_DATA_IMPORT_REPO_ID)\n+\t\t\t\t.clientId(getClientId())\n+\t\t\t\t.orgId(getOrgId())\n+\t\t\t\t.userId(getUserId())\n+\t\t\t\t.additionalParameters(computeImportProcessParams())\n+\t\t\t\t.build());\n+\n+\t\treturn MSG_OK;\n+\t}\n+\n+\tprivate Params computeImportProcessParams()\n+\t{\n+\t\tfinal I_C_BankStatement bankStatement = Services.get(IBankStatementDAO.class).getById(getRecord_ID());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDczNzg0Nw=="}, "originalCommit": {"oid": "9d27ed29d5195fe90cee62eed0a1ba932ba9c1cd"}, "originalPosition": 110}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxNzU1OTUyOnYy", "diffSide": "RIGHT", "path": "de.metas.banking/de.metas.banking.base/src/main/java/de/metas/banking/payment/impl/BankStatmentPaymentBL.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQxNToyNzoxOVrOFlYT_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQwNzo1NDo1MVrOFlueDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDczOTk2Ng==", "bodyText": "consider saving the line in BankStatementDAO  (basically in the same class which retrieved it)", "url": "https://github.com/metasfresh/metasfresh/pull/6089#discussion_r374739966", "createdAt": "2020-02-04T15:27:19Z", "author": {"login": "teosarca"}, "path": "de.metas.banking/de.metas.banking.base/src/main/java/de/metas/banking/payment/impl/BankStatmentPaymentBL.java", "diffHunk": "@@ -102,23 +113,150 @@ public void setC_Payment(IBankStatementLineOrRef lineOrRef, I_C_Payment payment)\n \t\t// Bank Statement Line specific:\n \t\tif (lineOrRef instanceof org.compiere.model.I_C_BankStatementLine)\n \t\t{\n-\t\t\torg.compiere.model.I_C_BankStatementLine bsl = (org.compiere.model.I_C_BankStatementLine)lineOrRef;\n+\t\t\tfinal org.compiere.model.I_C_BankStatementLine bsl = (org.compiere.model.I_C_BankStatementLine)lineOrRef;\n \t\t\tbsl.setDescription(payment.getDescription());\n \t\t}\n \t}\n \n-\tpublic void setPayAmt(IBankStatementLineOrRef lineOrRef, BigDecimal payAmt)\n+\t@Override\n+\tpublic void findOrCreateUnreconciledPaymentsAndLinkToBankStatementLine(final de.metas.banking.model.I_C_BankStatementLine line)\n+\t{\n+\t\tfinal boolean manualActionRequired = findAndLinkPaymentToBankStatementLineIfPossible(line);\n+\n+\t\tif (!manualActionRequired)\n+\t\t{\n+\t\t\tsetOrCreateAndLinkPaymentToBankStatementLine(line, null);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * @return true if the automatic flow should STOP as manual action is required; false if the automatic flow should continue\n+\t */\n+\tprivate boolean findAndLinkPaymentToBankStatementLineIfPossible(final de.metas.banking.model.I_C_BankStatementLine line)\n+\t{\n+\t\t// a payment is already linked\n+\t\tif (line.getC_Payment_ID() > 0)\n+\t\t{\n+\t\t\treturn true;\n+\t\t}\n+\t\tif (line.getC_BPartner_ID() <= 0)\n+\t\t{\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tfinal boolean isReceipt = line.getStmtAmt().signum() >= 0;\n+\t\tfinal BigDecimal expectedPaymentAmount = isReceipt ? line.getStmtAmt() : line.getStmtAmt().negate();\n+\n+\t\tfinal Money money = Money.of(expectedPaymentAmount, CurrencyId.ofRepoId(line.getC_Currency_ID()));\n+\t\tfinal BPartnerId bPartnerId = BPartnerId.ofRepoId(line.getC_BPartner_ID());\n+\t\tfinal ImmutableSet<PaymentId> possiblePayments = Services.get(IPaymentDAO.class).retrieveAllMatchingPayments(isReceipt, bPartnerId, money);\n+\n+\t\t// Don't create a new Payment and don't link any of the existing payments if there are multiple payments found.\n+\t\t// The user must fix this case manually by choosing the correct Payment\n+\t\tif (possiblePayments.size() > 1)\n+\t\t{\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tif (possiblePayments.size() == 1)\n+\t\t{\n+\t\t\tline.setC_Payment_ID(possiblePayments.iterator().next().getRepoId());\n+\t\t\tInterfaceWrapperHelper.save(line);\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\t@Override\n+\tpublic Optional<PaymentId> setOrCreateAndLinkPaymentToBankStatementLine(@NonNull final de.metas.banking.model.I_C_BankStatementLine line, @Nullable final PaymentId paymentIdToSet)\n+\t{\n+\t\t// a payment is already linked\n+\t\tif (line.getC_Payment_ID() > 0)\n+\t\t{\n+\t\t\treturn Optional.of(PaymentId.ofRepoId(line.getC_Payment_ID()));\n+\t\t}\n+\n+\t\tif (paymentIdToSet != null)\n+\t\t{\n+\t\t\tfinal I_C_Payment payment = Services.get(IPaymentDAO.class).getById(paymentIdToSet);\n+\t\t\tsetC_Payment(line, payment);\n+\n+\t\t\tInterfaceWrapperHelper.save(line);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d27ed29d5195fe90cee62eed0a1ba932ba9c1cd"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTEwMjk4OQ==", "bodyText": "done", "url": "https://github.com/metasfresh/metasfresh/pull/6089#discussion_r375102989", "createdAt": "2020-02-05T07:54:51Z", "author": {"login": "TheBestPessimist"}, "path": "de.metas.banking/de.metas.banking.base/src/main/java/de/metas/banking/payment/impl/BankStatmentPaymentBL.java", "diffHunk": "@@ -102,23 +113,150 @@ public void setC_Payment(IBankStatementLineOrRef lineOrRef, I_C_Payment payment)\n \t\t// Bank Statement Line specific:\n \t\tif (lineOrRef instanceof org.compiere.model.I_C_BankStatementLine)\n \t\t{\n-\t\t\torg.compiere.model.I_C_BankStatementLine bsl = (org.compiere.model.I_C_BankStatementLine)lineOrRef;\n+\t\t\tfinal org.compiere.model.I_C_BankStatementLine bsl = (org.compiere.model.I_C_BankStatementLine)lineOrRef;\n \t\t\tbsl.setDescription(payment.getDescription());\n \t\t}\n \t}\n \n-\tpublic void setPayAmt(IBankStatementLineOrRef lineOrRef, BigDecimal payAmt)\n+\t@Override\n+\tpublic void findOrCreateUnreconciledPaymentsAndLinkToBankStatementLine(final de.metas.banking.model.I_C_BankStatementLine line)\n+\t{\n+\t\tfinal boolean manualActionRequired = findAndLinkPaymentToBankStatementLineIfPossible(line);\n+\n+\t\tif (!manualActionRequired)\n+\t\t{\n+\t\t\tsetOrCreateAndLinkPaymentToBankStatementLine(line, null);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * @return true if the automatic flow should STOP as manual action is required; false if the automatic flow should continue\n+\t */\n+\tprivate boolean findAndLinkPaymentToBankStatementLineIfPossible(final de.metas.banking.model.I_C_BankStatementLine line)\n+\t{\n+\t\t// a payment is already linked\n+\t\tif (line.getC_Payment_ID() > 0)\n+\t\t{\n+\t\t\treturn true;\n+\t\t}\n+\t\tif (line.getC_BPartner_ID() <= 0)\n+\t\t{\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tfinal boolean isReceipt = line.getStmtAmt().signum() >= 0;\n+\t\tfinal BigDecimal expectedPaymentAmount = isReceipt ? line.getStmtAmt() : line.getStmtAmt().negate();\n+\n+\t\tfinal Money money = Money.of(expectedPaymentAmount, CurrencyId.ofRepoId(line.getC_Currency_ID()));\n+\t\tfinal BPartnerId bPartnerId = BPartnerId.ofRepoId(line.getC_BPartner_ID());\n+\t\tfinal ImmutableSet<PaymentId> possiblePayments = Services.get(IPaymentDAO.class).retrieveAllMatchingPayments(isReceipt, bPartnerId, money);\n+\n+\t\t// Don't create a new Payment and don't link any of the existing payments if there are multiple payments found.\n+\t\t// The user must fix this case manually by choosing the correct Payment\n+\t\tif (possiblePayments.size() > 1)\n+\t\t{\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tif (possiblePayments.size() == 1)\n+\t\t{\n+\t\t\tline.setC_Payment_ID(possiblePayments.iterator().next().getRepoId());\n+\t\t\tInterfaceWrapperHelper.save(line);\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\t@Override\n+\tpublic Optional<PaymentId> setOrCreateAndLinkPaymentToBankStatementLine(@NonNull final de.metas.banking.model.I_C_BankStatementLine line, @Nullable final PaymentId paymentIdToSet)\n+\t{\n+\t\t// a payment is already linked\n+\t\tif (line.getC_Payment_ID() > 0)\n+\t\t{\n+\t\t\treturn Optional.of(PaymentId.ofRepoId(line.getC_Payment_ID()));\n+\t\t}\n+\n+\t\tif (paymentIdToSet != null)\n+\t\t{\n+\t\t\tfinal I_C_Payment payment = Services.get(IPaymentDAO.class).getById(paymentIdToSet);\n+\t\t\tsetC_Payment(line, payment);\n+\n+\t\t\tInterfaceWrapperHelper.save(line);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDczOTk2Ng=="}, "originalCommit": {"oid": "9d27ed29d5195fe90cee62eed0a1ba932ba9c1cd"}, "originalPosition": 159}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxNzU3Mjg0OnYy", "diffSide": "RIGHT", "path": "de.metas.banking/de.metas.banking.base/src/test/java/de/metas/banking/service/impl/BankStatementPaymentBLTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQxNTozMDoyMlrOFlYcRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQwNjoxODozM1rOFls0vg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc0MjA4Nw==", "bodyText": "what's the status here.\nbasically implement it or delete it.", "url": "https://github.com/metasfresh/metasfresh/pull/6089#discussion_r374742087", "createdAt": "2020-02-04T15:30:22Z", "author": {"login": "teosarca"}, "path": "de.metas.banking/de.metas.banking.base/src/test/java/de/metas/banking/service/impl/BankStatementPaymentBLTest.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * #%L\n+ * de.metas.banking.base\n+ * %%\n+ * Copyright (C) 2019 metas GmbH\n+ * %%\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as\n+ * published by the Free Software Foundation, either version 2 of the\n+ * License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public\n+ * License along with this program. If not, see\n+ * <http://www.gnu.org/licenses/gpl-2.0.html>.\n+ * #L%\n+ */\n+\n+package de.metas.banking.service.impl;\n+\n+import de.metas.banking.BankStatementTestHelper;\n+import de.metas.banking.api.BankAccountId;\n+import de.metas.banking.model.BankStatementId;\n+import de.metas.banking.model.I_C_BankStatement;\n+import de.metas.banking.model.I_C_BankStatementLine;\n+import de.metas.banking.model.I_C_Payment;\n+import de.metas.banking.model.validator.C_BankStatement;\n+import de.metas.banking.model.validator.C_BankStatementLine;\n+import de.metas.banking.model.validator.C_BankStatementLine_Ref;\n+import de.metas.banking.payment.impl.BankStatmentPaymentBL;\n+import de.metas.bpartner.BPartnerId;\n+import de.metas.business.BusinessTestHelper;\n+import de.metas.document.engine.DocStatus;\n+import de.metas.money.CurrencyId;\n+import de.metas.organization.OrgId;\n+import de.metas.payment.TenderType;\n+import de.metas.payment.api.IPaymentBL;\n+import de.metas.util.Services;\n+import de.metas.util.time.SystemTime;\n+import org.adempiere.ad.modelvalidator.IModelInterceptorRegistry;\n+import org.adempiere.model.InterfaceWrapperHelper;\n+import org.adempiere.test.AdempiereTestHelper;\n+import org.compiere.model.I_C_BP_BankAccount;\n+import org.compiere.model.I_C_BPartner;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+\n+import java.math.BigDecimal;\n+import java.sql.Timestamp;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class BankStatementPaymentBLTest\n+{\n+\tprivate final Timestamp statementDate = SystemTime.asTimestamp();\n+\tprivate final String metasfreshIban = \"123456\";\n+\n+\tprivate final Timestamp valutaDate = SystemTime.asTimestamp();\n+\n+\t@BeforeEach\n+\tvoid setUp()\n+\t{\n+\t\tAdempiereTestHelper.get().init();\n+\n+\t\tfinal IModelInterceptorRegistry modelInterceptorRegistry = Services.get(IModelInterceptorRegistry.class);\n+\t\tmodelInterceptorRegistry.addModelInterceptor(C_BankStatementLine_Ref.instance);\n+\t\tmodelInterceptorRegistry.addModelInterceptor(C_BankStatement.instance);\n+\t\tmodelInterceptorRegistry.addModelInterceptor(C_BankStatementLine.instance);\n+\t}\n+\n+\tprivate void paymentChecks(final BigDecimal expectedPayAmt, final int expectedC_payment_id, final boolean expectedIsReceipt, final int expectedC_BP_BankAccount_ID)\n+\t{\n+\t\tfinal I_C_Payment payment = InterfaceWrapperHelper.load(expectedC_payment_id, I_C_Payment.class);\n+\t\tassertNotNull(payment);\n+\t\tassertEquals(expectedPayAmt, payment.getPayAmt());\n+\t\tassertTrue(payment.isReconciled());\n+\t\tassertEquals(expectedIsReceipt, payment.isReceipt());\n+\t\tassertEquals(DocStatus.Completed, DocStatus.ofCode(payment.getDocStatus()));\n+\t\tassertEquals(expectedC_BP_BankAccount_ID, payment.getC_BP_BankAccount_ID());\n+\n+\t\t// can't test `payment.getC_DocType_ID()` as it is set by `PaymentsForInvoicesCreator`, and during test there's no DocTypes\n+\t}\n+\n+\t@Nested\n+\tclass ExistingPayments\n+\t{\n+\t\t@Test\n+\t\tvoid vendorOneMatchingPaymentExists_DifferentInvoiceOnBSL()\n+\t\t{\n+\t\t\t// TODO tbp: check with mark in a followup task about this usecase.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d27ed29d5195fe90cee62eed0a1ba932ba9c1cd"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTA3NjAzMA==", "bodyText": "Since there will be a followup task, i will do neither now. After we decide how we do the matching of invoices, i will implement this test.\nIf i will implement it now, it will always fail until we complete the followup task, and this is something i don't approve of.", "url": "https://github.com/metasfresh/metasfresh/pull/6089#discussion_r375076030", "createdAt": "2020-02-05T06:18:33Z", "author": {"login": "TheBestPessimist"}, "path": "de.metas.banking/de.metas.banking.base/src/test/java/de/metas/banking/service/impl/BankStatementPaymentBLTest.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * #%L\n+ * de.metas.banking.base\n+ * %%\n+ * Copyright (C) 2019 metas GmbH\n+ * %%\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as\n+ * published by the Free Software Foundation, either version 2 of the\n+ * License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public\n+ * License along with this program. If not, see\n+ * <http://www.gnu.org/licenses/gpl-2.0.html>.\n+ * #L%\n+ */\n+\n+package de.metas.banking.service.impl;\n+\n+import de.metas.banking.BankStatementTestHelper;\n+import de.metas.banking.api.BankAccountId;\n+import de.metas.banking.model.BankStatementId;\n+import de.metas.banking.model.I_C_BankStatement;\n+import de.metas.banking.model.I_C_BankStatementLine;\n+import de.metas.banking.model.I_C_Payment;\n+import de.metas.banking.model.validator.C_BankStatement;\n+import de.metas.banking.model.validator.C_BankStatementLine;\n+import de.metas.banking.model.validator.C_BankStatementLine_Ref;\n+import de.metas.banking.payment.impl.BankStatmentPaymentBL;\n+import de.metas.bpartner.BPartnerId;\n+import de.metas.business.BusinessTestHelper;\n+import de.metas.document.engine.DocStatus;\n+import de.metas.money.CurrencyId;\n+import de.metas.organization.OrgId;\n+import de.metas.payment.TenderType;\n+import de.metas.payment.api.IPaymentBL;\n+import de.metas.util.Services;\n+import de.metas.util.time.SystemTime;\n+import org.adempiere.ad.modelvalidator.IModelInterceptorRegistry;\n+import org.adempiere.model.InterfaceWrapperHelper;\n+import org.adempiere.test.AdempiereTestHelper;\n+import org.compiere.model.I_C_BP_BankAccount;\n+import org.compiere.model.I_C_BPartner;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+\n+import java.math.BigDecimal;\n+import java.sql.Timestamp;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class BankStatementPaymentBLTest\n+{\n+\tprivate final Timestamp statementDate = SystemTime.asTimestamp();\n+\tprivate final String metasfreshIban = \"123456\";\n+\n+\tprivate final Timestamp valutaDate = SystemTime.asTimestamp();\n+\n+\t@BeforeEach\n+\tvoid setUp()\n+\t{\n+\t\tAdempiereTestHelper.get().init();\n+\n+\t\tfinal IModelInterceptorRegistry modelInterceptorRegistry = Services.get(IModelInterceptorRegistry.class);\n+\t\tmodelInterceptorRegistry.addModelInterceptor(C_BankStatementLine_Ref.instance);\n+\t\tmodelInterceptorRegistry.addModelInterceptor(C_BankStatement.instance);\n+\t\tmodelInterceptorRegistry.addModelInterceptor(C_BankStatementLine.instance);\n+\t}\n+\n+\tprivate void paymentChecks(final BigDecimal expectedPayAmt, final int expectedC_payment_id, final boolean expectedIsReceipt, final int expectedC_BP_BankAccount_ID)\n+\t{\n+\t\tfinal I_C_Payment payment = InterfaceWrapperHelper.load(expectedC_payment_id, I_C_Payment.class);\n+\t\tassertNotNull(payment);\n+\t\tassertEquals(expectedPayAmt, payment.getPayAmt());\n+\t\tassertTrue(payment.isReconciled());\n+\t\tassertEquals(expectedIsReceipt, payment.isReceipt());\n+\t\tassertEquals(DocStatus.Completed, DocStatus.ofCode(payment.getDocStatus()));\n+\t\tassertEquals(expectedC_BP_BankAccount_ID, payment.getC_BP_BankAccount_ID());\n+\n+\t\t// can't test `payment.getC_DocType_ID()` as it is set by `PaymentsForInvoicesCreator`, and during test there's no DocTypes\n+\t}\n+\n+\t@Nested\n+\tclass ExistingPayments\n+\t{\n+\t\t@Test\n+\t\tvoid vendorOneMatchingPaymentExists_DifferentInvoiceOnBSL()\n+\t\t{\n+\t\t\t// TODO tbp: check with mark in a followup task about this usecase.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc0MjA4Nw=="}, "originalCommit": {"oid": "9d27ed29d5195fe90cee62eed0a1ba932ba9c1cd"}, "originalPosition": 98}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1566, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}