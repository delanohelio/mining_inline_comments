{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIyNjczMTU4", "number": 6728, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxMjozMToyNlrOD_Xo8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQwODoyNDo0MlrOD_koEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3Nzc0MTk0OnYy", "diffSide": "RIGHT", "path": "backend/de.metas.business/src/main/java/de/metas/invoice/service/impl/CreditMemoInvoiceCopyHandler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxMjozMToyNlrOGZ_pMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxMzo1Mzo1NVrOGaB5Qw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTkxMDMyMg==", "bodyText": "avoid string concatenation", "url": "https://github.com/metasfresh/metasfresh/pull/6728#discussion_r429910322", "createdAt": "2020-05-25T12:31:26Z", "author": {"login": "teosarca"}, "path": "backend/de.metas.business/src/main/java/de/metas/invoice/service/impl/CreditMemoInvoiceCopyHandler.java", "diffHunk": "@@ -114,161 +110,167 @@ private void handlePartialRequests(final de.metas.adempiere.model.I_C_Invoice in\n \t\t\t// skip non-partial lines (a line is partially allocated if the allocated amount is not null or 0)\n \t\t\treturn;\n \t\t}\n-\n-\t\t// task 08927: we won't be able to re-invoice partial credit memos because we will set the invoiceLines' QtyInvoiced to 1,\n-\t\t// so we won't know the exact qtys to re-invoice.\n-\t\tcreditMemo.setIsCreditedInvoiceReinvoicable(false);\n-\n-\t\t// CreditMemo lines shall be including tax. This makes our life easier further below\n-\t\tcreditMemo.setIsTaxIncluded(true);\n-\n-\t\t// get our currency precision and the smallest possible amount (in most currencies this is 0.01)\n-\t\tfinal CurrencyId currencyId = CurrencyId.ofRepoId(invoice.getC_Currency_ID());\n-\t\tfinal CurrencyPrecision precision = Services.get(ICurrencyDAO.class).getStdPrecision(currencyId);\n-\t\tfinal BigDecimal smallestAmtInCurrency = ONE.setScale(precision.toInt(), RoundingMode.HALF_UP).divide(BigDecimal.TEN.pow(precision.toInt()));\n-\n-\t\t// Compute the factor we can use to get the credit memo amounts from their respective invoice amounts.\n-\t\t// Note that by rounding to \"floor\", the rounded value won't ever be greater than the \"correct\" value\n-\t\tfinal BigDecimal openfraction = openAmt\n-\t\t\t\t// gh #448: make sure to choose openfraction's scale such that it's length after the decimal point (it is generally <=1) is in the same order as the size of the numbers which we divide.\n-\t\t\t\t// this is important to guarantee that the rounding error is not bigger than 'smallestAmtInCurrency'\n-\t\t\t\t.setScale(openAmt.precision() + invoice.getGrandTotal().precision(), BigDecimal.ROUND_HALF_UP)\n-\t\t\t\t.divide(invoice.getGrandTotal(), RoundingMode.FLOOR);\n-\n-\t\tfinal IInvoiceDAO invoicePA = Services.get(IInvoiceDAO.class);\n-\n-\t\t//\n-\t\t// Get the C_InvoiceTax records of 'invoice' taxes, ordered by tax rate, with the biggest tax rate first\n-\t\tfinal List<I_C_InvoiceTax> invoiceTaxes = invoicePA.retrieveTaxes(invoice);\n-\t\tCollections.sort(invoiceTaxes, (o1, o2) -> o1.getC_Tax().getRate().compareTo(o2.getC_Tax().getRate()) * -1);\n-\n-\t\tBigDecimal creditMemoGrandTotal = BigDecimal.ZERO;\n-\t\tfinal Map<I_C_InvoiceTax, BigDecimal> newTaxAmounts = new IdentityHashMap<>();\n-\n-\t\t//\n-\t\t// For every I_C_InvoiceTax of 'invoice', we get the fraction of the tax amount that shall be credited\n-\t\tfinal Map<Integer, I_C_InvoiceTax> taxId2Invoicetax = new HashMap<>();\n-\t\tfor (final I_C_InvoiceTax invoiceTax : invoiceTaxes)\n+\t\telse\n \t\t{\n-\t\t\tfinal BigDecimal taxGrossAmt = invoiceTax.getTaxBaseAmt().add(invoiceTax.getTaxAmt());\n-\n-\t\t\t// Note that once again, we round to \"floor\", so the rounded value won't be greater than the \"correct\" value\n-\t\t\t// Also note that if 'creditTaxGrossAmt' is less than the \"correct\" value, the difference is never bigger than than 'smallestAmtInCurrency'.\n-\t\t\tfinal BigDecimal creditTaxGrossAmt = taxGrossAmt.multiply(openfraction).setScale(precision.toInt(), RoundingMode.FLOOR);\n-\t\t\tcreditMemoGrandTotal = creditMemoGrandTotal.add(creditTaxGrossAmt);\n+\t\t\tlogger.warn(\"The credit memo \" + creditMemo + \" should be a partial allocation of invoice \" + invoice);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5901ffe3a3c079201f2a2aed2a7d9537d47998e3"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTk0NzIwMw==", "bodyText": "done", "url": "https://github.com/metasfresh/metasfresh/pull/6728#discussion_r429947203", "createdAt": "2020-05-25T13:53:55Z", "author": {"login": "metas-rc"}, "path": "backend/de.metas.business/src/main/java/de/metas/invoice/service/impl/CreditMemoInvoiceCopyHandler.java", "diffHunk": "@@ -114,161 +110,167 @@ private void handlePartialRequests(final de.metas.adempiere.model.I_C_Invoice in\n \t\t\t// skip non-partial lines (a line is partially allocated if the allocated amount is not null or 0)\n \t\t\treturn;\n \t\t}\n-\n-\t\t// task 08927: we won't be able to re-invoice partial credit memos because we will set the invoiceLines' QtyInvoiced to 1,\n-\t\t// so we won't know the exact qtys to re-invoice.\n-\t\tcreditMemo.setIsCreditedInvoiceReinvoicable(false);\n-\n-\t\t// CreditMemo lines shall be including tax. This makes our life easier further below\n-\t\tcreditMemo.setIsTaxIncluded(true);\n-\n-\t\t// get our currency precision and the smallest possible amount (in most currencies this is 0.01)\n-\t\tfinal CurrencyId currencyId = CurrencyId.ofRepoId(invoice.getC_Currency_ID());\n-\t\tfinal CurrencyPrecision precision = Services.get(ICurrencyDAO.class).getStdPrecision(currencyId);\n-\t\tfinal BigDecimal smallestAmtInCurrency = ONE.setScale(precision.toInt(), RoundingMode.HALF_UP).divide(BigDecimal.TEN.pow(precision.toInt()));\n-\n-\t\t// Compute the factor we can use to get the credit memo amounts from their respective invoice amounts.\n-\t\t// Note that by rounding to \"floor\", the rounded value won't ever be greater than the \"correct\" value\n-\t\tfinal BigDecimal openfraction = openAmt\n-\t\t\t\t// gh #448: make sure to choose openfraction's scale such that it's length after the decimal point (it is generally <=1) is in the same order as the size of the numbers which we divide.\n-\t\t\t\t// this is important to guarantee that the rounding error is not bigger than 'smallestAmtInCurrency'\n-\t\t\t\t.setScale(openAmt.precision() + invoice.getGrandTotal().precision(), BigDecimal.ROUND_HALF_UP)\n-\t\t\t\t.divide(invoice.getGrandTotal(), RoundingMode.FLOOR);\n-\n-\t\tfinal IInvoiceDAO invoicePA = Services.get(IInvoiceDAO.class);\n-\n-\t\t//\n-\t\t// Get the C_InvoiceTax records of 'invoice' taxes, ordered by tax rate, with the biggest tax rate first\n-\t\tfinal List<I_C_InvoiceTax> invoiceTaxes = invoicePA.retrieveTaxes(invoice);\n-\t\tCollections.sort(invoiceTaxes, (o1, o2) -> o1.getC_Tax().getRate().compareTo(o2.getC_Tax().getRate()) * -1);\n-\n-\t\tBigDecimal creditMemoGrandTotal = BigDecimal.ZERO;\n-\t\tfinal Map<I_C_InvoiceTax, BigDecimal> newTaxAmounts = new IdentityHashMap<>();\n-\n-\t\t//\n-\t\t// For every I_C_InvoiceTax of 'invoice', we get the fraction of the tax amount that shall be credited\n-\t\tfinal Map<Integer, I_C_InvoiceTax> taxId2Invoicetax = new HashMap<>();\n-\t\tfor (final I_C_InvoiceTax invoiceTax : invoiceTaxes)\n+\t\telse\n \t\t{\n-\t\t\tfinal BigDecimal taxGrossAmt = invoiceTax.getTaxBaseAmt().add(invoiceTax.getTaxAmt());\n-\n-\t\t\t// Note that once again, we round to \"floor\", so the rounded value won't be greater than the \"correct\" value\n-\t\t\t// Also note that if 'creditTaxGrossAmt' is less than the \"correct\" value, the difference is never bigger than than 'smallestAmtInCurrency'.\n-\t\t\tfinal BigDecimal creditTaxGrossAmt = taxGrossAmt.multiply(openfraction).setScale(precision.toInt(), RoundingMode.FLOOR);\n-\t\t\tcreditMemoGrandTotal = creditMemoGrandTotal.add(creditTaxGrossAmt);\n+\t\t\tlogger.warn(\"The credit memo \" + creditMemo + \" should be a partial allocation of invoice \" + invoice);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTkxMDMyMg=="}, "originalCommit": {"oid": "5901ffe3a3c079201f2a2aed2a7d9537d47998e3"}, "originalPosition": 114}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3Nzc0Mjg0OnYy", "diffSide": "RIGHT", "path": "backend/de.metas.business/src/main/java/de/metas/invoice/service/impl/CreditMemoInvoiceCopyHandler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxMjozMTo0OVrOGZ_pwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxMzo1NDowMFrOGaB5bg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTkxMDQ2Ng==", "bodyText": "remove this huge commented code chunk.", "url": "https://github.com/metasfresh/metasfresh/pull/6728#discussion_r429910466", "createdAt": "2020-05-25T12:31:49Z", "author": {"login": "teosarca"}, "path": "backend/de.metas.business/src/main/java/de/metas/invoice/service/impl/CreditMemoInvoiceCopyHandler.java", "diffHunk": "@@ -114,161 +110,167 @@ private void handlePartialRequests(final de.metas.adempiere.model.I_C_Invoice in\n \t\t\t// skip non-partial lines (a line is partially allocated if the allocated amount is not null or 0)\n \t\t\treturn;\n \t\t}\n-\n-\t\t// task 08927: we won't be able to re-invoice partial credit memos because we will set the invoiceLines' QtyInvoiced to 1,\n-\t\t// so we won't know the exact qtys to re-invoice.\n-\t\tcreditMemo.setIsCreditedInvoiceReinvoicable(false);\n-\n-\t\t// CreditMemo lines shall be including tax. This makes our life easier further below\n-\t\tcreditMemo.setIsTaxIncluded(true);\n-\n-\t\t// get our currency precision and the smallest possible amount (in most currencies this is 0.01)\n-\t\tfinal CurrencyId currencyId = CurrencyId.ofRepoId(invoice.getC_Currency_ID());\n-\t\tfinal CurrencyPrecision precision = Services.get(ICurrencyDAO.class).getStdPrecision(currencyId);\n-\t\tfinal BigDecimal smallestAmtInCurrency = ONE.setScale(precision.toInt(), RoundingMode.HALF_UP).divide(BigDecimal.TEN.pow(precision.toInt()));\n-\n-\t\t// Compute the factor we can use to get the credit memo amounts from their respective invoice amounts.\n-\t\t// Note that by rounding to \"floor\", the rounded value won't ever be greater than the \"correct\" value\n-\t\tfinal BigDecimal openfraction = openAmt\n-\t\t\t\t// gh #448: make sure to choose openfraction's scale such that it's length after the decimal point (it is generally <=1) is in the same order as the size of the numbers which we divide.\n-\t\t\t\t// this is important to guarantee that the rounding error is not bigger than 'smallestAmtInCurrency'\n-\t\t\t\t.setScale(openAmt.precision() + invoice.getGrandTotal().precision(), BigDecimal.ROUND_HALF_UP)\n-\t\t\t\t.divide(invoice.getGrandTotal(), RoundingMode.FLOOR);\n-\n-\t\tfinal IInvoiceDAO invoicePA = Services.get(IInvoiceDAO.class);\n-\n-\t\t//\n-\t\t// Get the C_InvoiceTax records of 'invoice' taxes, ordered by tax rate, with the biggest tax rate first\n-\t\tfinal List<I_C_InvoiceTax> invoiceTaxes = invoicePA.retrieveTaxes(invoice);\n-\t\tCollections.sort(invoiceTaxes, (o1, o2) -> o1.getC_Tax().getRate().compareTo(o2.getC_Tax().getRate()) * -1);\n-\n-\t\tBigDecimal creditMemoGrandTotal = BigDecimal.ZERO;\n-\t\tfinal Map<I_C_InvoiceTax, BigDecimal> newTaxAmounts = new IdentityHashMap<>();\n-\n-\t\t//\n-\t\t// For every I_C_InvoiceTax of 'invoice', we get the fraction of the tax amount that shall be credited\n-\t\tfinal Map<Integer, I_C_InvoiceTax> taxId2Invoicetax = new HashMap<>();\n-\t\tfor (final I_C_InvoiceTax invoiceTax : invoiceTaxes)\n+\t\telse\n \t\t{\n-\t\t\tfinal BigDecimal taxGrossAmt = invoiceTax.getTaxBaseAmt().add(invoiceTax.getTaxAmt());\n-\n-\t\t\t// Note that once again, we round to \"floor\", so the rounded value won't be greater than the \"correct\" value\n-\t\t\t// Also note that if 'creditTaxGrossAmt' is less than the \"correct\" value, the difference is never bigger than than 'smallestAmtInCurrency'.\n-\t\t\tfinal BigDecimal creditTaxGrossAmt = taxGrossAmt.multiply(openfraction).setScale(precision.toInt(), RoundingMode.FLOOR);\n-\t\t\tcreditMemoGrandTotal = creditMemoGrandTotal.add(creditTaxGrossAmt);\n+\t\t\tlogger.warn(\"The credit memo \" + creditMemo + \" should be a partial allocation of invoice \" + invoice);\n \n-\t\t\tnewTaxAmounts.put(invoiceTax, creditTaxGrossAmt);\n-\t\t\ttaxId2Invoicetax.put(invoiceTax.getC_Tax_ID(), invoiceTax);\n+\t\t\treturn;\n \t\t}\n \n+\t\t// // task 08927: we won't be able to re-invoice partial credit memos because we will set the invoiceLines' QtyInvoiced to 1,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5901ffe3a3c079201f2a2aed2a7d9537d47998e3"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTk0NzI0Ng==", "bodyText": "done", "url": "https://github.com/metasfresh/metasfresh/pull/6728#discussion_r429947246", "createdAt": "2020-05-25T13:54:00Z", "author": {"login": "metas-rc"}, "path": "backend/de.metas.business/src/main/java/de/metas/invoice/service/impl/CreditMemoInvoiceCopyHandler.java", "diffHunk": "@@ -114,161 +110,167 @@ private void handlePartialRequests(final de.metas.adempiere.model.I_C_Invoice in\n \t\t\t// skip non-partial lines (a line is partially allocated if the allocated amount is not null or 0)\n \t\t\treturn;\n \t\t}\n-\n-\t\t// task 08927: we won't be able to re-invoice partial credit memos because we will set the invoiceLines' QtyInvoiced to 1,\n-\t\t// so we won't know the exact qtys to re-invoice.\n-\t\tcreditMemo.setIsCreditedInvoiceReinvoicable(false);\n-\n-\t\t// CreditMemo lines shall be including tax. This makes our life easier further below\n-\t\tcreditMemo.setIsTaxIncluded(true);\n-\n-\t\t// get our currency precision and the smallest possible amount (in most currencies this is 0.01)\n-\t\tfinal CurrencyId currencyId = CurrencyId.ofRepoId(invoice.getC_Currency_ID());\n-\t\tfinal CurrencyPrecision precision = Services.get(ICurrencyDAO.class).getStdPrecision(currencyId);\n-\t\tfinal BigDecimal smallestAmtInCurrency = ONE.setScale(precision.toInt(), RoundingMode.HALF_UP).divide(BigDecimal.TEN.pow(precision.toInt()));\n-\n-\t\t// Compute the factor we can use to get the credit memo amounts from their respective invoice amounts.\n-\t\t// Note that by rounding to \"floor\", the rounded value won't ever be greater than the \"correct\" value\n-\t\tfinal BigDecimal openfraction = openAmt\n-\t\t\t\t// gh #448: make sure to choose openfraction's scale such that it's length after the decimal point (it is generally <=1) is in the same order as the size of the numbers which we divide.\n-\t\t\t\t// this is important to guarantee that the rounding error is not bigger than 'smallestAmtInCurrency'\n-\t\t\t\t.setScale(openAmt.precision() + invoice.getGrandTotal().precision(), BigDecimal.ROUND_HALF_UP)\n-\t\t\t\t.divide(invoice.getGrandTotal(), RoundingMode.FLOOR);\n-\n-\t\tfinal IInvoiceDAO invoicePA = Services.get(IInvoiceDAO.class);\n-\n-\t\t//\n-\t\t// Get the C_InvoiceTax records of 'invoice' taxes, ordered by tax rate, with the biggest tax rate first\n-\t\tfinal List<I_C_InvoiceTax> invoiceTaxes = invoicePA.retrieveTaxes(invoice);\n-\t\tCollections.sort(invoiceTaxes, (o1, o2) -> o1.getC_Tax().getRate().compareTo(o2.getC_Tax().getRate()) * -1);\n-\n-\t\tBigDecimal creditMemoGrandTotal = BigDecimal.ZERO;\n-\t\tfinal Map<I_C_InvoiceTax, BigDecimal> newTaxAmounts = new IdentityHashMap<>();\n-\n-\t\t//\n-\t\t// For every I_C_InvoiceTax of 'invoice', we get the fraction of the tax amount that shall be credited\n-\t\tfinal Map<Integer, I_C_InvoiceTax> taxId2Invoicetax = new HashMap<>();\n-\t\tfor (final I_C_InvoiceTax invoiceTax : invoiceTaxes)\n+\t\telse\n \t\t{\n-\t\t\tfinal BigDecimal taxGrossAmt = invoiceTax.getTaxBaseAmt().add(invoiceTax.getTaxAmt());\n-\n-\t\t\t// Note that once again, we round to \"floor\", so the rounded value won't be greater than the \"correct\" value\n-\t\t\t// Also note that if 'creditTaxGrossAmt' is less than the \"correct\" value, the difference is never bigger than than 'smallestAmtInCurrency'.\n-\t\t\tfinal BigDecimal creditTaxGrossAmt = taxGrossAmt.multiply(openfraction).setScale(precision.toInt(), RoundingMode.FLOOR);\n-\t\t\tcreditMemoGrandTotal = creditMemoGrandTotal.add(creditTaxGrossAmt);\n+\t\t\tlogger.warn(\"The credit memo \" + creditMemo + \" should be a partial allocation of invoice \" + invoice);\n \n-\t\t\tnewTaxAmounts.put(invoiceTax, creditTaxGrossAmt);\n-\t\t\ttaxId2Invoicetax.put(invoiceTax.getC_Tax_ID(), invoiceTax);\n+\t\t\treturn;\n \t\t}\n \n+\t\t// // task 08927: we won't be able to re-invoice partial credit memos because we will set the invoiceLines' QtyInvoiced to 1,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTkxMDQ2Ng=="}, "originalCommit": {"oid": "5901ffe3a3c079201f2a2aed2a7d9537d47998e3"}, "originalPosition": 121}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3OTg2NzkwOnYy", "diffSide": "RIGHT", "path": "backend/de.metas.business/src/main/java/de/metas/invoice/service/impl/CreditMemoInvoiceCopyHandler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQwODoyNDoxMVrOGaTvmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQwODo0MzoyM1rOGaUcTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDIzOTY0Mg==", "bodyText": "What the purpose of this warning?\nI mean, whom is it for? and what shall the recipient do with it?\nI think if we want to make the system more supportable, then debug is enough.\n\"Warn\" messages should imho be actionably", "url": "https://github.com/metasfresh/metasfresh/pull/6728#discussion_r430239642", "createdAt": "2020-05-26T08:24:11Z", "author": {"login": "metas-ts"}, "path": "backend/de.metas.business/src/main/java/de/metas/invoice/service/impl/CreditMemoInvoiceCopyHandler.java", "diffHunk": "@@ -114,178 +110,24 @@ private void handlePartialRequests(final de.metas.adempiere.model.I_C_Invoice in\n \t\t\t// skip non-partial lines (a line is partially allocated if the allocated amount is not null or 0)\n \t\t\treturn;\n \t\t}\n-\n-\t\t// task 08927: we won't be able to re-invoice partial credit memos because we will set the invoiceLines' QtyInvoiced to 1,\n-\t\t// so we won't know the exact qtys to re-invoice.\n-\t\tcreditMemo.setIsCreditedInvoiceReinvoicable(false);\n-\n-\t\t// CreditMemo lines shall be including tax. This makes our life easier further below\n-\t\tcreditMemo.setIsTaxIncluded(true);\n-\n-\t\t// get our currency precision and the smallest possible amount (in most currencies this is 0.01)\n-\t\tfinal CurrencyId currencyId = CurrencyId.ofRepoId(invoice.getC_Currency_ID());\n-\t\tfinal CurrencyPrecision precision = Services.get(ICurrencyDAO.class).getStdPrecision(currencyId);\n-\t\tfinal BigDecimal smallestAmtInCurrency = ONE.setScale(precision.toInt(), RoundingMode.HALF_UP).divide(BigDecimal.TEN.pow(precision.toInt()));\n-\n-\t\t// Compute the factor we can use to get the credit memo amounts from their respective invoice amounts.\n-\t\t// Note that by rounding to \"floor\", the rounded value won't ever be greater than the \"correct\" value\n-\t\tfinal BigDecimal openfraction = openAmt\n-\t\t\t\t// gh #448: make sure to choose openfraction's scale such that it's length after the decimal point (it is generally <=1) is in the same order as the size of the numbers which we divide.\n-\t\t\t\t// this is important to guarantee that the rounding error is not bigger than 'smallestAmtInCurrency'\n-\t\t\t\t.setScale(openAmt.precision() + invoice.getGrandTotal().precision(), BigDecimal.ROUND_HALF_UP)\n-\t\t\t\t.divide(invoice.getGrandTotal(), RoundingMode.FLOOR);\n-\n-\t\tfinal IInvoiceDAO invoicePA = Services.get(IInvoiceDAO.class);\n-\n-\t\t//\n-\t\t// Get the C_InvoiceTax records of 'invoice' taxes, ordered by tax rate, with the biggest tax rate first\n-\t\tfinal List<I_C_InvoiceTax> invoiceTaxes = invoicePA.retrieveTaxes(invoice);\n-\t\tCollections.sort(invoiceTaxes, (o1, o2) -> o1.getC_Tax().getRate().compareTo(o2.getC_Tax().getRate()) * -1);\n-\n-\t\tBigDecimal creditMemoGrandTotal = BigDecimal.ZERO;\n-\t\tfinal Map<I_C_InvoiceTax, BigDecimal> newTaxAmounts = new IdentityHashMap<>();\n-\n-\t\t//\n-\t\t// For every I_C_InvoiceTax of 'invoice', we get the fraction of the tax amount that shall be credited\n-\t\tfinal Map<Integer, I_C_InvoiceTax> taxId2Invoicetax = new HashMap<>();\n-\t\tfor (final I_C_InvoiceTax invoiceTax : invoiceTaxes)\n-\t\t{\n-\t\t\tfinal BigDecimal taxGrossAmt = invoiceTax.getTaxBaseAmt().add(invoiceTax.getTaxAmt());\n-\n-\t\t\t// Note that once again, we round to \"floor\", so the rounded value won't be greater than the \"correct\" value\n-\t\t\t// Also note that if 'creditTaxGrossAmt' is less than the \"correct\" value, the difference is never bigger than than 'smallestAmtInCurrency'.\n-\t\t\tfinal BigDecimal creditTaxGrossAmt = taxGrossAmt.multiply(openfraction).setScale(precision.toInt(), RoundingMode.FLOOR);\n-\t\t\tcreditMemoGrandTotal = creditMemoGrandTotal.add(creditTaxGrossAmt);\n-\n-\t\t\tnewTaxAmounts.put(invoiceTax, creditTaxGrossAmt);\n-\t\t\ttaxId2Invoicetax.put(invoiceTax.getC_Tax_ID(), invoiceTax);\n-\t\t}\n-\n-\t\t//\n-\t\t// Now we check for rounding errors and correct the amounts if necessary.\n-\t\t// Note that our amounts can't be too big but only too small (by one 'smallestAmt' for each I_C_InvoiceTax).\n-\t\t// Also note that due to the ordering of 'invoiceTaxes' we correct the invoiceTax with the biggest rate first\n-\t\tfor (final I_C_InvoiceTax invoiceTax : invoiceTaxes)\n-\t\t{\n-\t\t\tif (creditMemoGrandTotal.compareTo(openAmt) == 0)\n-\t\t\t{\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t\tif (creditMemoGrandTotal.compareTo(openAmt) < 0)\n-\t\t\t{\n-\t\t\t\tnewTaxAmounts.put(invoiceTax,\n-\t\t\t\t\t\tnewTaxAmounts.get(invoiceTax).add(smallestAmtInCurrency));\n-\t\t\t\tcreditMemoGrandTotal = creditMemoGrandTotal.add(smallestAmtInCurrency);\n-\t\t\t}\n-\t\t\telse\n-\t\t\t{\n-\t\t\t\tCheck.errorIf(true, \"On evaluating {}, we have creditMemoGrandTotal={} and openAmt={}\", invoiceTax, creditMemoGrandTotal, openAmt);\n-\t\t\t}\n-\t\t}\n-\n-\t\t// gh #448: in the past this error occurred when openfraction's scale was two low.\n-\t\tCheck.errorIf(creditMemoGrandTotal.compareTo(openAmt) != 0, \"creditMemoGrandTotal={} is different from openAmt={}; openfraction={}\", creditMemoGrandTotal, openAmt, openfraction);\n-\n-\t\t//\n-\t\t// Now that we have computed the tax values where we need to end up with our credit memo,\n-\t\t// We do basically the same on invoice line level. The credit memo lines were copied from the invoice lines, so they still contain the original amounts which we can use\n-\t\tfinal Map<I_C_InvoiceTax, List<I_C_InvoiceLine>> tax2lines = new IdentityHashMap<>();\n-\n-\t\tfinal List<de.metas.adempiere.model.I_C_InvoiceLine> lines = invoicePA.retrieveLines(creditMemo, trxName);\n-\t\tfor (final I_C_InvoiceLine creditMemoLine : lines)\n-\t\t{\n-\t\t\tif (creditMemoLine.isDescription())\n-\t\t\t{\n-\t\t\t\tcontinue; // not changing description lines\n-\t\t\t}\n-\t\t\tfinal I_C_InvoiceTax invoiceTax = taxId2Invoicetax.get(creditMemoLine.getC_Tax_ID());\n-\t\t\tList<I_C_InvoiceLine> linesForInvoiceTax = tax2lines.get(invoiceTax);\n-\t\t\tif (linesForInvoiceTax == null)\n-\t\t\t{\n-\t\t\t\tlinesForInvoiceTax = new ArrayList<>();\n-\t\t\t\ttax2lines.put(invoiceTax, linesForInvoiceTax);\n-\n-\t\t\t}\n-\t\t\tlinesForInvoiceTax.add(creditMemoLine);\n-\t\t}\n-\n-\t\tfinal Map<I_C_InvoiceLine, BigDecimal> line2newLineGrossAmt = new IdentityHashMap<>();\n-\t\tfor (final I_C_InvoiceTax invoiceTax : invoiceTaxes)\n-\t\t{\n-\t\t\tBigDecimal sumPerTax = BigDecimal.ZERO;\n-\t\t\tfor (final I_C_InvoiceLine creditMemoLine : tax2lines.get(invoiceTax))\n-\t\t\t{\n-\t\t\t\tfinal BigDecimal newLineNetAmt = creditMemoLine.getLineNetAmt().multiply(openfraction);\n-\t\t\t\tfinal BigDecimal newLineGrossAmt;\n-\t\t\t\tif (invoiceTax.isTaxIncluded())\n-\t\t\t\t{\n-\t\t\t\t\tnewLineGrossAmt = newLineNetAmt.setScale(precision.toInt(), RoundingMode.FLOOR);\n-\t\t\t\t}\n-\t\t\t\telse\n-\t\t\t\t{\n-\t\t\t\t\tnewLineGrossAmt = newLineNetAmt\n-\t\t\t\t\t\t\t.multiply(invoiceTax.getC_Tax().getRate()\n-\t\t\t\t\t\t\t\t\t.add(Env.ONEHUNDRED)\n-\t\t\t\t\t\t\t\t\t.divide(Env.ONEHUNDRED))\n-\t\t\t\t\t\t\t.setScale(precision.toInt(), RoundingMode.FLOOR);\n-\t\t\t\t}\n-\t\t\t\tline2newLineGrossAmt.put(creditMemoLine, newLineGrossAmt);\n-\t\t\t\tsumPerTax = sumPerTax.add(newLineGrossAmt);\n-\t\t\t}\n-\n-\t\t\tfor (final I_C_InvoiceLine creditMemoLine : tax2lines.get(invoiceTax))\n-\t\t\t{\n-\t\t\t\tfinal BigDecimal targetSum = newTaxAmounts.get(invoiceTax);\n-\t\t\t\tif (sumPerTax.compareTo(targetSum) == 0)\n-\t\t\t\t{\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t\tif (sumPerTax.compareTo(targetSum) < 0)\n-\t\t\t\t{\n-\t\t\t\t\tline2newLineGrossAmt.put(creditMemoLine, line2newLineGrossAmt.get(creditMemoLine).add(smallestAmtInCurrency));\n-\t\t\t\t\tsumPerTax = sumPerTax.add(smallestAmtInCurrency);\n-\t\t\t\t}\n-\t\t\t\telse\n-\t\t\t\t{\n-\t\t\t\t\tCheck.errorIf(true, \"invoiceTax {} has has targetSum={}, but the credit memo lines for this tax have sumPerTax={} (difference may not be more than {})\",\n-\t\t\t\t\t\t\tinvoiceTax, targetSum, sumPerTax, smallestAmtInCurrency);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\tfor (final I_C_InvoiceLine creditMemoLine : lines)\n+\t\telse\n \t\t{\n-\t\t\tcreditMemoLine.setQtyEntered(ONE);\n-\t\t\tcreditMemoLine.setQtyInvoiced(ONE);\n-\t\t\tcreditMemoLine.setPriceEntered(line2newLineGrossAmt.get(creditMemoLine));\n-\t\t\tcreditMemoLine.setPriceActual(line2newLineGrossAmt.get(creditMemoLine));\n-\n-\t\t\t// 07090: setting priceUOM to 0, because we set the Qty to 1, and the priceUOM only makes sense in the context of the original Qty (but this is a partial-ammount credit memo)\n-\t\t\tInterfaceWrapperHelper.create(creditMemoLine, de.metas.adempiere.model.I_C_InvoiceLine.class).setPrice_UOM_ID(0);\n+\t\t\tlogger.warn(\"The credit memo {} should be a partial allocation of invoice {}.\", creditMemo, invoice);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d2800d36522913ddff31494281b68c38c4c64ee"}, "originalPosition": 220}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDI1MTA4NQ==", "bodyText": "I dropped de.metas.invoice.service.impl.CreditMemoInvoiceCopyHandler.handlePartialRequests(I_C_Invoice, I_C_Invoice) as discussed.", "url": "https://github.com/metasfresh/metasfresh/pull/6728#discussion_r430251085", "createdAt": "2020-05-26T08:43:23Z", "author": {"login": "metas-rc"}, "path": "backend/de.metas.business/src/main/java/de/metas/invoice/service/impl/CreditMemoInvoiceCopyHandler.java", "diffHunk": "@@ -114,178 +110,24 @@ private void handlePartialRequests(final de.metas.adempiere.model.I_C_Invoice in\n \t\t\t// skip non-partial lines (a line is partially allocated if the allocated amount is not null or 0)\n \t\t\treturn;\n \t\t}\n-\n-\t\t// task 08927: we won't be able to re-invoice partial credit memos because we will set the invoiceLines' QtyInvoiced to 1,\n-\t\t// so we won't know the exact qtys to re-invoice.\n-\t\tcreditMemo.setIsCreditedInvoiceReinvoicable(false);\n-\n-\t\t// CreditMemo lines shall be including tax. This makes our life easier further below\n-\t\tcreditMemo.setIsTaxIncluded(true);\n-\n-\t\t// get our currency precision and the smallest possible amount (in most currencies this is 0.01)\n-\t\tfinal CurrencyId currencyId = CurrencyId.ofRepoId(invoice.getC_Currency_ID());\n-\t\tfinal CurrencyPrecision precision = Services.get(ICurrencyDAO.class).getStdPrecision(currencyId);\n-\t\tfinal BigDecimal smallestAmtInCurrency = ONE.setScale(precision.toInt(), RoundingMode.HALF_UP).divide(BigDecimal.TEN.pow(precision.toInt()));\n-\n-\t\t// Compute the factor we can use to get the credit memo amounts from their respective invoice amounts.\n-\t\t// Note that by rounding to \"floor\", the rounded value won't ever be greater than the \"correct\" value\n-\t\tfinal BigDecimal openfraction = openAmt\n-\t\t\t\t// gh #448: make sure to choose openfraction's scale such that it's length after the decimal point (it is generally <=1) is in the same order as the size of the numbers which we divide.\n-\t\t\t\t// this is important to guarantee that the rounding error is not bigger than 'smallestAmtInCurrency'\n-\t\t\t\t.setScale(openAmt.precision() + invoice.getGrandTotal().precision(), BigDecimal.ROUND_HALF_UP)\n-\t\t\t\t.divide(invoice.getGrandTotal(), RoundingMode.FLOOR);\n-\n-\t\tfinal IInvoiceDAO invoicePA = Services.get(IInvoiceDAO.class);\n-\n-\t\t//\n-\t\t// Get the C_InvoiceTax records of 'invoice' taxes, ordered by tax rate, with the biggest tax rate first\n-\t\tfinal List<I_C_InvoiceTax> invoiceTaxes = invoicePA.retrieveTaxes(invoice);\n-\t\tCollections.sort(invoiceTaxes, (o1, o2) -> o1.getC_Tax().getRate().compareTo(o2.getC_Tax().getRate()) * -1);\n-\n-\t\tBigDecimal creditMemoGrandTotal = BigDecimal.ZERO;\n-\t\tfinal Map<I_C_InvoiceTax, BigDecimal> newTaxAmounts = new IdentityHashMap<>();\n-\n-\t\t//\n-\t\t// For every I_C_InvoiceTax of 'invoice', we get the fraction of the tax amount that shall be credited\n-\t\tfinal Map<Integer, I_C_InvoiceTax> taxId2Invoicetax = new HashMap<>();\n-\t\tfor (final I_C_InvoiceTax invoiceTax : invoiceTaxes)\n-\t\t{\n-\t\t\tfinal BigDecimal taxGrossAmt = invoiceTax.getTaxBaseAmt().add(invoiceTax.getTaxAmt());\n-\n-\t\t\t// Note that once again, we round to \"floor\", so the rounded value won't be greater than the \"correct\" value\n-\t\t\t// Also note that if 'creditTaxGrossAmt' is less than the \"correct\" value, the difference is never bigger than than 'smallestAmtInCurrency'.\n-\t\t\tfinal BigDecimal creditTaxGrossAmt = taxGrossAmt.multiply(openfraction).setScale(precision.toInt(), RoundingMode.FLOOR);\n-\t\t\tcreditMemoGrandTotal = creditMemoGrandTotal.add(creditTaxGrossAmt);\n-\n-\t\t\tnewTaxAmounts.put(invoiceTax, creditTaxGrossAmt);\n-\t\t\ttaxId2Invoicetax.put(invoiceTax.getC_Tax_ID(), invoiceTax);\n-\t\t}\n-\n-\t\t//\n-\t\t// Now we check for rounding errors and correct the amounts if necessary.\n-\t\t// Note that our amounts can't be too big but only too small (by one 'smallestAmt' for each I_C_InvoiceTax).\n-\t\t// Also note that due to the ordering of 'invoiceTaxes' we correct the invoiceTax with the biggest rate first\n-\t\tfor (final I_C_InvoiceTax invoiceTax : invoiceTaxes)\n-\t\t{\n-\t\t\tif (creditMemoGrandTotal.compareTo(openAmt) == 0)\n-\t\t\t{\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t\tif (creditMemoGrandTotal.compareTo(openAmt) < 0)\n-\t\t\t{\n-\t\t\t\tnewTaxAmounts.put(invoiceTax,\n-\t\t\t\t\t\tnewTaxAmounts.get(invoiceTax).add(smallestAmtInCurrency));\n-\t\t\t\tcreditMemoGrandTotal = creditMemoGrandTotal.add(smallestAmtInCurrency);\n-\t\t\t}\n-\t\t\telse\n-\t\t\t{\n-\t\t\t\tCheck.errorIf(true, \"On evaluating {}, we have creditMemoGrandTotal={} and openAmt={}\", invoiceTax, creditMemoGrandTotal, openAmt);\n-\t\t\t}\n-\t\t}\n-\n-\t\t// gh #448: in the past this error occurred when openfraction's scale was two low.\n-\t\tCheck.errorIf(creditMemoGrandTotal.compareTo(openAmt) != 0, \"creditMemoGrandTotal={} is different from openAmt={}; openfraction={}\", creditMemoGrandTotal, openAmt, openfraction);\n-\n-\t\t//\n-\t\t// Now that we have computed the tax values where we need to end up with our credit memo,\n-\t\t// We do basically the same on invoice line level. The credit memo lines were copied from the invoice lines, so they still contain the original amounts which we can use\n-\t\tfinal Map<I_C_InvoiceTax, List<I_C_InvoiceLine>> tax2lines = new IdentityHashMap<>();\n-\n-\t\tfinal List<de.metas.adempiere.model.I_C_InvoiceLine> lines = invoicePA.retrieveLines(creditMemo, trxName);\n-\t\tfor (final I_C_InvoiceLine creditMemoLine : lines)\n-\t\t{\n-\t\t\tif (creditMemoLine.isDescription())\n-\t\t\t{\n-\t\t\t\tcontinue; // not changing description lines\n-\t\t\t}\n-\t\t\tfinal I_C_InvoiceTax invoiceTax = taxId2Invoicetax.get(creditMemoLine.getC_Tax_ID());\n-\t\t\tList<I_C_InvoiceLine> linesForInvoiceTax = tax2lines.get(invoiceTax);\n-\t\t\tif (linesForInvoiceTax == null)\n-\t\t\t{\n-\t\t\t\tlinesForInvoiceTax = new ArrayList<>();\n-\t\t\t\ttax2lines.put(invoiceTax, linesForInvoiceTax);\n-\n-\t\t\t}\n-\t\t\tlinesForInvoiceTax.add(creditMemoLine);\n-\t\t}\n-\n-\t\tfinal Map<I_C_InvoiceLine, BigDecimal> line2newLineGrossAmt = new IdentityHashMap<>();\n-\t\tfor (final I_C_InvoiceTax invoiceTax : invoiceTaxes)\n-\t\t{\n-\t\t\tBigDecimal sumPerTax = BigDecimal.ZERO;\n-\t\t\tfor (final I_C_InvoiceLine creditMemoLine : tax2lines.get(invoiceTax))\n-\t\t\t{\n-\t\t\t\tfinal BigDecimal newLineNetAmt = creditMemoLine.getLineNetAmt().multiply(openfraction);\n-\t\t\t\tfinal BigDecimal newLineGrossAmt;\n-\t\t\t\tif (invoiceTax.isTaxIncluded())\n-\t\t\t\t{\n-\t\t\t\t\tnewLineGrossAmt = newLineNetAmt.setScale(precision.toInt(), RoundingMode.FLOOR);\n-\t\t\t\t}\n-\t\t\t\telse\n-\t\t\t\t{\n-\t\t\t\t\tnewLineGrossAmt = newLineNetAmt\n-\t\t\t\t\t\t\t.multiply(invoiceTax.getC_Tax().getRate()\n-\t\t\t\t\t\t\t\t\t.add(Env.ONEHUNDRED)\n-\t\t\t\t\t\t\t\t\t.divide(Env.ONEHUNDRED))\n-\t\t\t\t\t\t\t.setScale(precision.toInt(), RoundingMode.FLOOR);\n-\t\t\t\t}\n-\t\t\t\tline2newLineGrossAmt.put(creditMemoLine, newLineGrossAmt);\n-\t\t\t\tsumPerTax = sumPerTax.add(newLineGrossAmt);\n-\t\t\t}\n-\n-\t\t\tfor (final I_C_InvoiceLine creditMemoLine : tax2lines.get(invoiceTax))\n-\t\t\t{\n-\t\t\t\tfinal BigDecimal targetSum = newTaxAmounts.get(invoiceTax);\n-\t\t\t\tif (sumPerTax.compareTo(targetSum) == 0)\n-\t\t\t\t{\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t\tif (sumPerTax.compareTo(targetSum) < 0)\n-\t\t\t\t{\n-\t\t\t\t\tline2newLineGrossAmt.put(creditMemoLine, line2newLineGrossAmt.get(creditMemoLine).add(smallestAmtInCurrency));\n-\t\t\t\t\tsumPerTax = sumPerTax.add(smallestAmtInCurrency);\n-\t\t\t\t}\n-\t\t\t\telse\n-\t\t\t\t{\n-\t\t\t\t\tCheck.errorIf(true, \"invoiceTax {} has has targetSum={}, but the credit memo lines for this tax have sumPerTax={} (difference may not be more than {})\",\n-\t\t\t\t\t\t\tinvoiceTax, targetSum, sumPerTax, smallestAmtInCurrency);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\tfor (final I_C_InvoiceLine creditMemoLine : lines)\n+\t\telse\n \t\t{\n-\t\t\tcreditMemoLine.setQtyEntered(ONE);\n-\t\t\tcreditMemoLine.setQtyInvoiced(ONE);\n-\t\t\tcreditMemoLine.setPriceEntered(line2newLineGrossAmt.get(creditMemoLine));\n-\t\t\tcreditMemoLine.setPriceActual(line2newLineGrossAmt.get(creditMemoLine));\n-\n-\t\t\t// 07090: setting priceUOM to 0, because we set the Qty to 1, and the priceUOM only makes sense in the context of the original Qty (but this is a partial-ammount credit memo)\n-\t\t\tInterfaceWrapperHelper.create(creditMemoLine, de.metas.adempiere.model.I_C_InvoiceLine.class).setPrice_UOM_ID(0);\n+\t\t\tlogger.warn(\"The credit memo {} should be a partial allocation of invoice {}.\", creditMemo, invoice);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDIzOTY0Mg=="}, "originalCommit": {"oid": "8d2800d36522913ddff31494281b68c38c4c64ee"}, "originalPosition": 220}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3OTg2OTYwOnYy", "diffSide": "RIGHT", "path": "backend/de.metas.business/src/main/java/de/metas/invoice/service/impl/CreditMemoInvoiceCopyHandler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQwODoyNDo0MlrOGaTwoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQwODo0NDo0N1rOGaUfvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDIzOTkwNQ==", "bodyText": "`why do we need this when it's unused? pls remove or add a quick comment to explain", "url": "https://github.com/metasfresh/metasfresh/pull/6728#discussion_r430239905", "createdAt": "2020-05-26T08:24:42Z", "author": {"login": "metas-ts"}, "path": "backend/de.metas.business/src/main/java/de/metas/invoice/service/impl/CreditMemoInvoiceCopyHandler.java", "diffHunk": "@@ -63,8 +50,12 @@\n {\n \tprivate final InvoiceCreditContext creditCtx;\n \tprivate final BigDecimal openAmt;\n+\n+\t@SuppressWarnings(\"unused\")\n \tprivate final String trxName;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d2800d36522913ddff31494281b68c38c4c64ee"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDI1MTk2NQ==", "bodyText": "This was added when I thought we should keep the code commented out. And ofc I didn't see it when I deleted the code, because it had a suppress warning \ud83e\udd26\nThanks for finding it. Cleaned up now.", "url": "https://github.com/metasfresh/metasfresh/pull/6728#discussion_r430251965", "createdAt": "2020-05-26T08:44:47Z", "author": {"login": "metas-rc"}, "path": "backend/de.metas.business/src/main/java/de/metas/invoice/service/impl/CreditMemoInvoiceCopyHandler.java", "diffHunk": "@@ -63,8 +50,12 @@\n {\n \tprivate final InvoiceCreditContext creditCtx;\n \tprivate final BigDecimal openAmt;\n+\n+\t@SuppressWarnings(\"unused\")\n \tprivate final String trxName;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDIzOTkwNQ=="}, "originalCommit": {"oid": "8d2800d36522913ddff31494281b68c38c4c64ee"}, "originalPosition": 48}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1558, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}