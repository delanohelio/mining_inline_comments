{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc2Mjk1MzMz", "number": 9870, "reviewThreads": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxMzo0Njo0NFrOEpe38g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxNDoyNzozOFrOEqw2fQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExOTMyOTE0OnYy", "diffSide": "RIGHT", "path": "frontend/src/utils/documentListHelper.js", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxMzo0Njo0NFrOHbLLsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxNDozMzozNVrOHdKNdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI1NjgxOA==", "bodyText": "Won't get(state, ['filters'], {}) work here ?", "url": "https://github.com/metasfresh/metasfresh/pull/9870#discussion_r498256818", "createdAt": "2020-10-01T13:46:44Z", "author": {"login": "siemiatj"}, "path": "frontend/src/utils/documentListHelper.js", "diffHunk": "@@ -142,7 +141,8 @@ const DLmapStateToProps = (state, props) => {\n     parentSelected: parentSelector(state, parentTableId),\n     modal: state.windowHandler.modal,\n     rawModalVisible: state.windowHandler.rawModal.visible,\n-    filters: state.filters,\n+    filters: windowId && viewId && state.filters ? state.filters[filterId] : {},", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aca6e4a591072da112d61083ebccc3a36f0e0724"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODY0MzU1OQ==", "bodyText": "Hmm. Not sure. This is faster", "url": "https://github.com/metasfresh/metasfresh/pull/9870#discussion_r498643559", "createdAt": "2020-10-02T06:52:53Z", "author": {"login": "petrican"}, "path": "frontend/src/utils/documentListHelper.js", "diffHunk": "@@ -142,7 +141,8 @@ const DLmapStateToProps = (state, props) => {\n     parentSelected: parentSelector(state, parentTableId),\n     modal: state.windowHandler.modal,\n     rawModalVisible: state.windowHandler.rawModal.visible,\n-    filters: state.filters,\n+    filters: windowId && viewId && state.filters ? state.filters[filterId] : {},", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI1NjgxOA=="}, "originalCommit": {"oid": "aca6e4a591072da112d61083ebccc3a36f0e0724"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDMzODAzNw==", "bodyText": "Only in case filters[filterId] exists. Otherwise we'll get undefined. I think it'd be best to have a cached selector here as filters might be a complicated object and hit us with unnecessary re-renders.", "url": "https://github.com/metasfresh/metasfresh/pull/9870#discussion_r500338037", "createdAt": "2020-10-06T14:33:35Z", "author": {"login": "siemiatj"}, "path": "frontend/src/utils/documentListHelper.js", "diffHunk": "@@ -142,7 +141,8 @@ const DLmapStateToProps = (state, props) => {\n     parentSelected: parentSelector(state, parentTableId),\n     modal: state.windowHandler.modal,\n     rawModalVisible: state.windowHandler.rawModal.visible,\n-    filters: state.filters,\n+    filters: windowId && viewId && state.filters ? state.filters[filterId] : {},", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI1NjgxOA=="}, "originalCommit": {"oid": "aca6e4a591072da112d61083ebccc3a36f0e0724"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExOTQ3MzkyOnYy", "diffSide": "RIGHT", "path": "frontend/src/actions/FiltersActions.js", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNDoxNzozOFrOHbMmQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQwNjoyMDowNFrOHbiNKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI4MDAwMA==", "bodyText": "Why we have this for filters only and not all widgets ?", "url": "https://github.com/metasfresh/metasfresh/pull/9870#discussion_r498280000", "createdAt": "2020-10-01T14:17:38Z", "author": {"login": "siemiatj"}, "path": "frontend/src/actions/FiltersActions.js", "diffHunk": "@@ -1,8 +1,357 @@\n-import { SET_CLEAR_ALL_FILTER } from '../constants/FilterTypes';\n+import * as types from '../constants/FilterTypes';\n+import { Map as iMap } from 'immutable';\n+import deepUnfreeze from 'deep-unfreeze';\n+import { fieldValueToString } from '../utils/tableHelpers';\n+import _ from 'lodash';\n \n-export function clearAllFilters(data) {\n+export function clearAllFilters({ id, data }) {\n   return {\n-    type: SET_CLEAR_ALL_FILTER,\n-    payload: data,\n+    type: types.CLEAR_ALL_FILTERS,\n+    payload: { id, data },\n   };\n }\n+\n+/**\n+ * @method createFilter\n+ * @summary Add a new filter entry to the redux store\n+ */\n+export function createFilter({ id, data }) {\n+  return {\n+    type: types.CREATE_FILTER,\n+    payload: { id, data },\n+  };\n+}\n+\n+/**\n+ * @method deleteFilter\n+ * @summary Remove the filter with specified `id` from the store\n+ */\n+export function deleteFilter(id) {\n+  return {\n+    type: types.DELETE_FILTER,\n+    payload: { id },\n+  };\n+}\n+\n+/**\n+ * @method updateNotValidFields\n+ * @summary updates in the store the notValidFields flag\n+ */\n+export function updateNotValidFields({ filterId, data }) {\n+  return {\n+    type: types.UPDATE_FLAG_NOTVALIDFIELDS,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aca6e4a591072da112d61083ebccc3a36f0e0724"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODYzNDAyNg==", "bodyText": "because filters were designed with this logic and was not in the plan to have it for all widgets. We can add such logic with the widget refactoring.", "url": "https://github.com/metasfresh/metasfresh/pull/9870#discussion_r498634026", "createdAt": "2020-10-02T06:20:04Z", "author": {"login": "petrican"}, "path": "frontend/src/actions/FiltersActions.js", "diffHunk": "@@ -1,8 +1,357 @@\n-import { SET_CLEAR_ALL_FILTER } from '../constants/FilterTypes';\n+import * as types from '../constants/FilterTypes';\n+import { Map as iMap } from 'immutable';\n+import deepUnfreeze from 'deep-unfreeze';\n+import { fieldValueToString } from '../utils/tableHelpers';\n+import _ from 'lodash';\n \n-export function clearAllFilters(data) {\n+export function clearAllFilters({ id, data }) {\n   return {\n-    type: SET_CLEAR_ALL_FILTER,\n-    payload: data,\n+    type: types.CLEAR_ALL_FILTERS,\n+    payload: { id, data },\n   };\n }\n+\n+/**\n+ * @method createFilter\n+ * @summary Add a new filter entry to the redux store\n+ */\n+export function createFilter({ id, data }) {\n+  return {\n+    type: types.CREATE_FILTER,\n+    payload: { id, data },\n+  };\n+}\n+\n+/**\n+ * @method deleteFilter\n+ * @summary Remove the filter with specified `id` from the store\n+ */\n+export function deleteFilter(id) {\n+  return {\n+    type: types.DELETE_FILTER,\n+    payload: { id },\n+  };\n+}\n+\n+/**\n+ * @method updateNotValidFields\n+ * @summary updates in the store the notValidFields flag\n+ */\n+export function updateNotValidFields({ filterId, data }) {\n+  return {\n+    type: types.UPDATE_FLAG_NOTVALIDFIELDS,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI4MDAwMA=="}, "originalCommit": {"oid": "aca6e4a591072da112d61083ebccc3a36f0e0724"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExOTQ3NzQ5OnYy", "diffSide": "RIGHT", "path": "frontend/src/actions/FiltersActions.js", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNDoxODoyMVrOHbMoiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQwNjoxMjo1NFrOHbiF_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI4MDU4NA==", "bodyText": "Is this only for filters ? If yes it should have FILTER in the name so it won't confuse us next month :)", "url": "https://github.com/metasfresh/metasfresh/pull/9870#discussion_r498280584", "createdAt": "2020-10-01T14:18:21Z", "author": {"login": "siemiatj"}, "path": "frontend/src/actions/FiltersActions.js", "diffHunk": "@@ -1,8 +1,357 @@\n-import { SET_CLEAR_ALL_FILTER } from '../constants/FilterTypes';\n+import * as types from '../constants/FilterTypes';\n+import { Map as iMap } from 'immutable';\n+import deepUnfreeze from 'deep-unfreeze';\n+import { fieldValueToString } from '../utils/tableHelpers';\n+import _ from 'lodash';\n \n-export function clearAllFilters(data) {\n+export function clearAllFilters({ id, data }) {\n   return {\n-    type: SET_CLEAR_ALL_FILTER,\n-    payload: data,\n+    type: types.CLEAR_ALL_FILTERS,\n+    payload: { id, data },\n   };\n }\n+\n+/**\n+ * @method createFilter\n+ * @summary Add a new filter entry to the redux store\n+ */\n+export function createFilter({ id, data }) {\n+  return {\n+    type: types.CREATE_FILTER,\n+    payload: { id, data },\n+  };\n+}\n+\n+/**\n+ * @method deleteFilter\n+ * @summary Remove the filter with specified `id` from the store\n+ */\n+export function deleteFilter(id) {\n+  return {\n+    type: types.DELETE_FILTER,\n+    payload: { id },\n+  };\n+}\n+\n+/**\n+ * @method updateNotValidFields\n+ * @summary updates in the store the notValidFields flag\n+ */\n+export function updateNotValidFields({ filterId, data }) {\n+  return {\n+    type: types.UPDATE_FLAG_NOTVALIDFIELDS,\n+    payload: { filterId, data },\n+  };\n+}\n+\n+/**\n+ * @method updateActiveFilter\n+ * @summary Updates the activeFilter in the store for the corresponding entity id\n+ */\n+export function updateActiveFilter({ id, data }) {\n+  return {\n+    type: types.UPDATE_ACTIVE_FILTER,\n+    payload: { id, data },\n+  };\n+}\n+\n+/**\n+ * @method updateWidgetShown\n+ * @summary Updates the widgetShown in the store for the corresponding entity id with a boolean value\n+ */\n+export function updateWidgetShown({ id, data }) {\n+  return {\n+    type: types.UPDATE_WIDGET_SHOWN,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aca6e4a591072da112d61083ebccc3a36f0e0724"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODYzMjE5MA==", "bodyText": "Done", "url": "https://github.com/metasfresh/metasfresh/pull/9870#discussion_r498632190", "createdAt": "2020-10-02T06:12:54Z", "author": {"login": "petrican"}, "path": "frontend/src/actions/FiltersActions.js", "diffHunk": "@@ -1,8 +1,357 @@\n-import { SET_CLEAR_ALL_FILTER } from '../constants/FilterTypes';\n+import * as types from '../constants/FilterTypes';\n+import { Map as iMap } from 'immutable';\n+import deepUnfreeze from 'deep-unfreeze';\n+import { fieldValueToString } from '../utils/tableHelpers';\n+import _ from 'lodash';\n \n-export function clearAllFilters(data) {\n+export function clearAllFilters({ id, data }) {\n   return {\n-    type: SET_CLEAR_ALL_FILTER,\n-    payload: data,\n+    type: types.CLEAR_ALL_FILTERS,\n+    payload: { id, data },\n   };\n }\n+\n+/**\n+ * @method createFilter\n+ * @summary Add a new filter entry to the redux store\n+ */\n+export function createFilter({ id, data }) {\n+  return {\n+    type: types.CREATE_FILTER,\n+    payload: { id, data },\n+  };\n+}\n+\n+/**\n+ * @method deleteFilter\n+ * @summary Remove the filter with specified `id` from the store\n+ */\n+export function deleteFilter(id) {\n+  return {\n+    type: types.DELETE_FILTER,\n+    payload: { id },\n+  };\n+}\n+\n+/**\n+ * @method updateNotValidFields\n+ * @summary updates in the store the notValidFields flag\n+ */\n+export function updateNotValidFields({ filterId, data }) {\n+  return {\n+    type: types.UPDATE_FLAG_NOTVALIDFIELDS,\n+    payload: { filterId, data },\n+  };\n+}\n+\n+/**\n+ * @method updateActiveFilter\n+ * @summary Updates the activeFilter in the store for the corresponding entity id\n+ */\n+export function updateActiveFilter({ id, data }) {\n+  return {\n+    type: types.UPDATE_ACTIVE_FILTER,\n+    payload: { id, data },\n+  };\n+}\n+\n+/**\n+ * @method updateWidgetShown\n+ * @summary Updates the widgetShown in the store for the corresponding entity id with a boolean value\n+ */\n+export function updateWidgetShown({ id, data }) {\n+  return {\n+    type: types.UPDATE_WIDGET_SHOWN,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI4MDU4NA=="}, "originalCommit": {"oid": "aca6e4a591072da112d61083ebccc3a36f0e0724"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExOTQ4MTQzOnYy", "diffSide": "RIGHT", "path": "frontend/src/actions/FiltersActions.js", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNDoxOTowOFrOHbMq-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQwNjo1NzoxOVrOHbi4CA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI4MTIwOQ==", "bodyText": "actually the name suggests it gets parent filter out of somewhere :)", "url": "https://github.com/metasfresh/metasfresh/pull/9870#discussion_r498281209", "createdAt": "2020-10-01T14:19:08Z", "author": {"login": "siemiatj"}, "path": "frontend/src/actions/FiltersActions.js", "diffHunk": "@@ -1,8 +1,357 @@\n-import { SET_CLEAR_ALL_FILTER } from '../constants/FilterTypes';\n+import * as types from '../constants/FilterTypes';\n+import { Map as iMap } from 'immutable';\n+import deepUnfreeze from 'deep-unfreeze';\n+import { fieldValueToString } from '../utils/tableHelpers';\n+import _ from 'lodash';\n \n-export function clearAllFilters(data) {\n+export function clearAllFilters({ id, data }) {\n   return {\n-    type: SET_CLEAR_ALL_FILTER,\n-    payload: data,\n+    type: types.CLEAR_ALL_FILTERS,\n+    payload: { id, data },\n   };\n }\n+\n+/**\n+ * @method createFilter\n+ * @summary Add a new filter entry to the redux store\n+ */\n+export function createFilter({ id, data }) {\n+  return {\n+    type: types.CREATE_FILTER,\n+    payload: { id, data },\n+  };\n+}\n+\n+/**\n+ * @method deleteFilter\n+ * @summary Remove the filter with specified `id` from the store\n+ */\n+export function deleteFilter(id) {\n+  return {\n+    type: types.DELETE_FILTER,\n+    payload: { id },\n+  };\n+}\n+\n+/**\n+ * @method updateNotValidFields\n+ * @summary updates in the store the notValidFields flag\n+ */\n+export function updateNotValidFields({ filterId, data }) {\n+  return {\n+    type: types.UPDATE_FLAG_NOTVALIDFIELDS,\n+    payload: { filterId, data },\n+  };\n+}\n+\n+/**\n+ * @method updateActiveFilter\n+ * @summary Updates the activeFilter in the store for the corresponding entity id\n+ */\n+export function updateActiveFilter({ id, data }) {\n+  return {\n+    type: types.UPDATE_ACTIVE_FILTER,\n+    payload: { id, data },\n+  };\n+}\n+\n+/**\n+ * @method updateWidgetShown\n+ * @summary Updates the widgetShown in the store for the corresponding entity id with a boolean value\n+ */\n+export function updateWidgetShown({ id, data }) {\n+  return {\n+    type: types.UPDATE_WIDGET_SHOWN,\n+    payload: { id, data },\n+  };\n+}\n+\n+/**\n+ * @method clearStaticFilters\n+ * @summary Clears the existing static filters for a filter branch in the redux store\n+ */\n+export function clearStaticFilters({ filterId, data }) {\n+  return {\n+    type: types.CLEAR_STATIC_FILTERS,\n+    payload: { filterId, data },\n+  };\n+}\n+\n+/**\n+ * @method getParentFilter\n+ * @summary as the name suggests the function is retrieving the filter data by key from the filterData", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aca6e4a591072da112d61083ebccc3a36f0e0724"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODY0NTAwMA==", "bodyText": "Updated", "url": "https://github.com/metasfresh/metasfresh/pull/9870#discussion_r498645000", "createdAt": "2020-10-02T06:57:19Z", "author": {"login": "petrican"}, "path": "frontend/src/actions/FiltersActions.js", "diffHunk": "@@ -1,8 +1,357 @@\n-import { SET_CLEAR_ALL_FILTER } from '../constants/FilterTypes';\n+import * as types from '../constants/FilterTypes';\n+import { Map as iMap } from 'immutable';\n+import deepUnfreeze from 'deep-unfreeze';\n+import { fieldValueToString } from '../utils/tableHelpers';\n+import _ from 'lodash';\n \n-export function clearAllFilters(data) {\n+export function clearAllFilters({ id, data }) {\n   return {\n-    type: SET_CLEAR_ALL_FILTER,\n-    payload: data,\n+    type: types.CLEAR_ALL_FILTERS,\n+    payload: { id, data },\n   };\n }\n+\n+/**\n+ * @method createFilter\n+ * @summary Add a new filter entry to the redux store\n+ */\n+export function createFilter({ id, data }) {\n+  return {\n+    type: types.CREATE_FILTER,\n+    payload: { id, data },\n+  };\n+}\n+\n+/**\n+ * @method deleteFilter\n+ * @summary Remove the filter with specified `id` from the store\n+ */\n+export function deleteFilter(id) {\n+  return {\n+    type: types.DELETE_FILTER,\n+    payload: { id },\n+  };\n+}\n+\n+/**\n+ * @method updateNotValidFields\n+ * @summary updates in the store the notValidFields flag\n+ */\n+export function updateNotValidFields({ filterId, data }) {\n+  return {\n+    type: types.UPDATE_FLAG_NOTVALIDFIELDS,\n+    payload: { filterId, data },\n+  };\n+}\n+\n+/**\n+ * @method updateActiveFilter\n+ * @summary Updates the activeFilter in the store for the corresponding entity id\n+ */\n+export function updateActiveFilter({ id, data }) {\n+  return {\n+    type: types.UPDATE_ACTIVE_FILTER,\n+    payload: { id, data },\n+  };\n+}\n+\n+/**\n+ * @method updateWidgetShown\n+ * @summary Updates the widgetShown in the store for the corresponding entity id with a boolean value\n+ */\n+export function updateWidgetShown({ id, data }) {\n+  return {\n+    type: types.UPDATE_WIDGET_SHOWN,\n+    payload: { id, data },\n+  };\n+}\n+\n+/**\n+ * @method clearStaticFilters\n+ * @summary Clears the existing static filters for a filter branch in the redux store\n+ */\n+export function clearStaticFilters({ filterId, data }) {\n+  return {\n+    type: types.CLEAR_STATIC_FILTERS,\n+    payload: { filterId, data },\n+  };\n+}\n+\n+/**\n+ * @method getParentFilter\n+ * @summary as the name suggests the function is retrieving the filter data by key from the filterData", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI4MTIwOQ=="}, "originalCommit": {"oid": "aca6e4a591072da112d61083ebccc3a36f0e0724"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExOTQ5MTk3OnYy", "diffSide": "RIGHT", "path": "frontend/src/actions/FiltersActions.js", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNDoyMToyNlrOHbMxyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQwNzozNTozMFrOHbjv0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI4Mjk1NA==", "bodyText": "It's not really obvious how is this different to filtersActiveContains. The parameter names are also misleading here.", "url": "https://github.com/metasfresh/metasfresh/pull/9870#discussion_r498282954", "createdAt": "2020-10-01T14:21:26Z", "author": {"login": "siemiatj"}, "path": "frontend/src/actions/FiltersActions.js", "diffHunk": "@@ -1,8 +1,357 @@\n-import { SET_CLEAR_ALL_FILTER } from '../constants/FilterTypes';\n+import * as types from '../constants/FilterTypes';\n+import { Map as iMap } from 'immutable';\n+import deepUnfreeze from 'deep-unfreeze';\n+import { fieldValueToString } from '../utils/tableHelpers';\n+import _ from 'lodash';\n \n-export function clearAllFilters(data) {\n+export function clearAllFilters({ id, data }) {\n   return {\n-    type: SET_CLEAR_ALL_FILTER,\n-    payload: data,\n+    type: types.CLEAR_ALL_FILTERS,\n+    payload: { id, data },\n   };\n }\n+\n+/**\n+ * @method createFilter\n+ * @summary Add a new filter entry to the redux store\n+ */\n+export function createFilter({ id, data }) {\n+  return {\n+    type: types.CREATE_FILTER,\n+    payload: { id, data },\n+  };\n+}\n+\n+/**\n+ * @method deleteFilter\n+ * @summary Remove the filter with specified `id` from the store\n+ */\n+export function deleteFilter(id) {\n+  return {\n+    type: types.DELETE_FILTER,\n+    payload: { id },\n+  };\n+}\n+\n+/**\n+ * @method updateNotValidFields\n+ * @summary updates in the store the notValidFields flag\n+ */\n+export function updateNotValidFields({ filterId, data }) {\n+  return {\n+    type: types.UPDATE_FLAG_NOTVALIDFIELDS,\n+    payload: { filterId, data },\n+  };\n+}\n+\n+/**\n+ * @method updateActiveFilter\n+ * @summary Updates the activeFilter in the store for the corresponding entity id\n+ */\n+export function updateActiveFilter({ id, data }) {\n+  return {\n+    type: types.UPDATE_ACTIVE_FILTER,\n+    payload: { id, data },\n+  };\n+}\n+\n+/**\n+ * @method updateWidgetShown\n+ * @summary Updates the widgetShown in the store for the corresponding entity id with a boolean value\n+ */\n+export function updateWidgetShown({ id, data }) {\n+  return {\n+    type: types.UPDATE_WIDGET_SHOWN,\n+    payload: { id, data },\n+  };\n+}\n+\n+/**\n+ * @method clearStaticFilters\n+ * @summary Clears the existing static filters for a filter branch in the redux store\n+ */\n+export function clearStaticFilters({ filterId, data }) {\n+  return {\n+    type: types.CLEAR_STATIC_FILTERS,\n+    payload: { filterId, data },\n+  };\n+}\n+\n+/**\n+ * @method getParentFilter\n+ * @summary as the name suggests the function is retrieving the filter data by key from the filterData\n+ * @param {string} filterId - key identifying the filter\n+ * @param {array} filterData array that contains all the filters as they are retrieved from the BE\n+ */\n+function getParentFilter({ filterId, filterData }) {\n+  let parentFilter = {};\n+  filterData.forEach((filter) => {\n+    if (filter.filterId && filter.filterId === filterId) {\n+      parentFilter = filter;\n+    }\n+    if (filter.includedFilters) {\n+      filter.includedFilters.forEach((incFilter) => {\n+        if (incFilter.filterId && incFilter.filterId === filterId) {\n+          parentFilter = incFilter;\n+        }\n+      });\n+    }\n+  });\n+  return parentFilter;\n+}\n+\n+/**\n+ * @method populateFiltersCaptions\n+ * @summary updates the filtersCaptions object for the corresponding filter branch id in the store\n+ * @param {string} id - filter id used as identifier for the filters branch\n+ * @param {object} data - object containing the captions\n+ */\n+export function populateFiltersCaptions(filters) {\n+  const filtersCaptions = {};\n+  if (!filters) return {};\n+  const { filterData, filtersActive } = filters;\n+  if (!filtersActive) return {};\n+\n+  if (filtersActive.length) {\n+    const removeDefault = {};\n+\n+    filtersActive.forEach((filter, filterId) => {\n+      let captionsArray = ['', ''];\n+\n+      if (filter.parameters && filter.parameters.length) {\n+        filter.parameters.forEach((filterParameter) => {\n+          const { value, parameterName, defaultValue } = filterParameter;\n+\n+          if (!defaultValue && filterData) {\n+            // we don't want to show captions, nor show filter button as active for default values\n+            removeDefault[filterId] = true;\n+            const parentFilter = getParentFilter({\n+              filterId: filter.filterId, // we pass the actual key not the index\n+              filterData,\n+            });\n+\n+            const filterParameter = parentFilter.parameters.find(\n+              (param) => param.parameterName === parameterName\n+            );\n+            let captionName = filterParameter.caption;\n+            let itemCaption = filterParameter.caption;\n+\n+            switch (filterParameter.widgetType) {\n+              case 'Text':\n+                captionName = value;\n+\n+                if (!value) {\n+                  captionName = '';\n+                  itemCaption = '';\n+                }\n+                break;\n+              case 'Lookup':\n+              case 'List':\n+                captionName = value && value.caption;\n+                break;\n+              case 'Labels':\n+                captionName = value.values.reduce((caption, item) => {\n+                  return `${caption}, ${item.caption}`;\n+                }, '');\n+                break;\n+              case 'YesNo':\n+                if (value === null) {\n+                  captionName = '';\n+                  itemCaption = '';\n+                }\n+                break;\n+              case 'Switch':\n+              default:\n+                if (!value) {\n+                  captionName = '';\n+                  itemCaption = '';\n+                }\n+                break;\n+            }\n+\n+            if (captionName) {\n+              captionsArray[0] = captionsArray[0]\n+                ? `${captionsArray[0]}, ${captionName}`\n+                : captionName;\n+            }\n+\n+            if (itemCaption) {\n+              captionsArray[1] = captionsArray[1]\n+                ? `${captionsArray[1]}, ${itemCaption}`\n+                : itemCaption;\n+            }\n+          }\n+        });\n+      } else {\n+        const originalFilter = filterData.filter(\n+          (item) => item.filterId === filterId\n+        );\n+        captionsArray = [originalFilter.caption, originalFilter.caption];\n+      }\n+\n+      if (captionsArray.join('').length) {\n+        filtersCaptions[filter.filterId] = captionsArray;\n+        filtersCaptions[filterId] = captionsArray;\n+      }\n+    });\n+  }\n+\n+  return filtersCaptions;\n+}\n+\n+/**\n+ * @method filtersToMap\n+ * @summary creates a map with the filters fetched from the layout request\n+ */\n+export function filtersToMap(filtersArray) {\n+  let filtersMap = iMap();\n+\n+  if (filtersArray && filtersArray.length) {\n+    filtersArray.forEach((filter) => {\n+      filtersMap = filtersMap.set(filter.filterId, filter);\n+    });\n+  }\n+  return filtersMap;\n+}\n+\n+/**\n+ * @method filtersActiveContains\n+ * @summary returns a boolean value depending on the presence of the key withing the activeFilters passed array\n+ */\n+export function filtersActiveContains({ filtersActive, key }) {\n+  if (filtersActive.lenght === 0) return false;\n+  const isPresent = filtersActive.filter((item) => item.filterId === key);\n+  return isPresent.length ? true : false;\n+}\n+\n+/**\n+ * @method setNewFiltersActive\n+ * @summary returns a new array with filters that are going to be the active ones\n+ */\n+export function setNewFiltersActive({ storeActiveFilters, filterToAdd }) {\n+  storeActiveFilters = deepUnfreeze(storeActiveFilters);\n+  if (\n+    !storeActiveFilters.length ||\n+    !foundAmongActiveFilters({ storeActiveFilters, filterToAdd })\n+  ) {\n+    storeActiveFilters.push(filterToAdd);\n+  } else {\n+    storeActiveFilters.forEach((activeFilter, index) => {\n+      if (activeFilter.filterId === filterToAdd.filterId) {\n+        storeActiveFilters[index] = filterToAdd;\n+      }\n+    });\n+  }\n+  return storeActiveFilters;\n+}\n+\n+/**\n+ * @method foundAmongActiveFilters\n+ * @summary checks that the filterToAdd is found among the storeActiveFilters\n+ */\n+function foundAmongActiveFilters({ storeActiveFilters, filterToAdd }) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aca6e4a591072da112d61083ebccc3a36f0e0724"}, "originalPosition": 256}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODY1OTI4Mg==", "bodyText": "updated the doc to avoid confusion", "url": "https://github.com/metasfresh/metasfresh/pull/9870#discussion_r498659282", "createdAt": "2020-10-02T07:35:30Z", "author": {"login": "petrican"}, "path": "frontend/src/actions/FiltersActions.js", "diffHunk": "@@ -1,8 +1,357 @@\n-import { SET_CLEAR_ALL_FILTER } from '../constants/FilterTypes';\n+import * as types from '../constants/FilterTypes';\n+import { Map as iMap } from 'immutable';\n+import deepUnfreeze from 'deep-unfreeze';\n+import { fieldValueToString } from '../utils/tableHelpers';\n+import _ from 'lodash';\n \n-export function clearAllFilters(data) {\n+export function clearAllFilters({ id, data }) {\n   return {\n-    type: SET_CLEAR_ALL_FILTER,\n-    payload: data,\n+    type: types.CLEAR_ALL_FILTERS,\n+    payload: { id, data },\n   };\n }\n+\n+/**\n+ * @method createFilter\n+ * @summary Add a new filter entry to the redux store\n+ */\n+export function createFilter({ id, data }) {\n+  return {\n+    type: types.CREATE_FILTER,\n+    payload: { id, data },\n+  };\n+}\n+\n+/**\n+ * @method deleteFilter\n+ * @summary Remove the filter with specified `id` from the store\n+ */\n+export function deleteFilter(id) {\n+  return {\n+    type: types.DELETE_FILTER,\n+    payload: { id },\n+  };\n+}\n+\n+/**\n+ * @method updateNotValidFields\n+ * @summary updates in the store the notValidFields flag\n+ */\n+export function updateNotValidFields({ filterId, data }) {\n+  return {\n+    type: types.UPDATE_FLAG_NOTVALIDFIELDS,\n+    payload: { filterId, data },\n+  };\n+}\n+\n+/**\n+ * @method updateActiveFilter\n+ * @summary Updates the activeFilter in the store for the corresponding entity id\n+ */\n+export function updateActiveFilter({ id, data }) {\n+  return {\n+    type: types.UPDATE_ACTIVE_FILTER,\n+    payload: { id, data },\n+  };\n+}\n+\n+/**\n+ * @method updateWidgetShown\n+ * @summary Updates the widgetShown in the store for the corresponding entity id with a boolean value\n+ */\n+export function updateWidgetShown({ id, data }) {\n+  return {\n+    type: types.UPDATE_WIDGET_SHOWN,\n+    payload: { id, data },\n+  };\n+}\n+\n+/**\n+ * @method clearStaticFilters\n+ * @summary Clears the existing static filters for a filter branch in the redux store\n+ */\n+export function clearStaticFilters({ filterId, data }) {\n+  return {\n+    type: types.CLEAR_STATIC_FILTERS,\n+    payload: { filterId, data },\n+  };\n+}\n+\n+/**\n+ * @method getParentFilter\n+ * @summary as the name suggests the function is retrieving the filter data by key from the filterData\n+ * @param {string} filterId - key identifying the filter\n+ * @param {array} filterData array that contains all the filters as they are retrieved from the BE\n+ */\n+function getParentFilter({ filterId, filterData }) {\n+  let parentFilter = {};\n+  filterData.forEach((filter) => {\n+    if (filter.filterId && filter.filterId === filterId) {\n+      parentFilter = filter;\n+    }\n+    if (filter.includedFilters) {\n+      filter.includedFilters.forEach((incFilter) => {\n+        if (incFilter.filterId && incFilter.filterId === filterId) {\n+          parentFilter = incFilter;\n+        }\n+      });\n+    }\n+  });\n+  return parentFilter;\n+}\n+\n+/**\n+ * @method populateFiltersCaptions\n+ * @summary updates the filtersCaptions object for the corresponding filter branch id in the store\n+ * @param {string} id - filter id used as identifier for the filters branch\n+ * @param {object} data - object containing the captions\n+ */\n+export function populateFiltersCaptions(filters) {\n+  const filtersCaptions = {};\n+  if (!filters) return {};\n+  const { filterData, filtersActive } = filters;\n+  if (!filtersActive) return {};\n+\n+  if (filtersActive.length) {\n+    const removeDefault = {};\n+\n+    filtersActive.forEach((filter, filterId) => {\n+      let captionsArray = ['', ''];\n+\n+      if (filter.parameters && filter.parameters.length) {\n+        filter.parameters.forEach((filterParameter) => {\n+          const { value, parameterName, defaultValue } = filterParameter;\n+\n+          if (!defaultValue && filterData) {\n+            // we don't want to show captions, nor show filter button as active for default values\n+            removeDefault[filterId] = true;\n+            const parentFilter = getParentFilter({\n+              filterId: filter.filterId, // we pass the actual key not the index\n+              filterData,\n+            });\n+\n+            const filterParameter = parentFilter.parameters.find(\n+              (param) => param.parameterName === parameterName\n+            );\n+            let captionName = filterParameter.caption;\n+            let itemCaption = filterParameter.caption;\n+\n+            switch (filterParameter.widgetType) {\n+              case 'Text':\n+                captionName = value;\n+\n+                if (!value) {\n+                  captionName = '';\n+                  itemCaption = '';\n+                }\n+                break;\n+              case 'Lookup':\n+              case 'List':\n+                captionName = value && value.caption;\n+                break;\n+              case 'Labels':\n+                captionName = value.values.reduce((caption, item) => {\n+                  return `${caption}, ${item.caption}`;\n+                }, '');\n+                break;\n+              case 'YesNo':\n+                if (value === null) {\n+                  captionName = '';\n+                  itemCaption = '';\n+                }\n+                break;\n+              case 'Switch':\n+              default:\n+                if (!value) {\n+                  captionName = '';\n+                  itemCaption = '';\n+                }\n+                break;\n+            }\n+\n+            if (captionName) {\n+              captionsArray[0] = captionsArray[0]\n+                ? `${captionsArray[0]}, ${captionName}`\n+                : captionName;\n+            }\n+\n+            if (itemCaption) {\n+              captionsArray[1] = captionsArray[1]\n+                ? `${captionsArray[1]}, ${itemCaption}`\n+                : itemCaption;\n+            }\n+          }\n+        });\n+      } else {\n+        const originalFilter = filterData.filter(\n+          (item) => item.filterId === filterId\n+        );\n+        captionsArray = [originalFilter.caption, originalFilter.caption];\n+      }\n+\n+      if (captionsArray.join('').length) {\n+        filtersCaptions[filter.filterId] = captionsArray;\n+        filtersCaptions[filterId] = captionsArray;\n+      }\n+    });\n+  }\n+\n+  return filtersCaptions;\n+}\n+\n+/**\n+ * @method filtersToMap\n+ * @summary creates a map with the filters fetched from the layout request\n+ */\n+export function filtersToMap(filtersArray) {\n+  let filtersMap = iMap();\n+\n+  if (filtersArray && filtersArray.length) {\n+    filtersArray.forEach((filter) => {\n+      filtersMap = filtersMap.set(filter.filterId, filter);\n+    });\n+  }\n+  return filtersMap;\n+}\n+\n+/**\n+ * @method filtersActiveContains\n+ * @summary returns a boolean value depending on the presence of the key withing the activeFilters passed array\n+ */\n+export function filtersActiveContains({ filtersActive, key }) {\n+  if (filtersActive.lenght === 0) return false;\n+  const isPresent = filtersActive.filter((item) => item.filterId === key);\n+  return isPresent.length ? true : false;\n+}\n+\n+/**\n+ * @method setNewFiltersActive\n+ * @summary returns a new array with filters that are going to be the active ones\n+ */\n+export function setNewFiltersActive({ storeActiveFilters, filterToAdd }) {\n+  storeActiveFilters = deepUnfreeze(storeActiveFilters);\n+  if (\n+    !storeActiveFilters.length ||\n+    !foundAmongActiveFilters({ storeActiveFilters, filterToAdd })\n+  ) {\n+    storeActiveFilters.push(filterToAdd);\n+  } else {\n+    storeActiveFilters.forEach((activeFilter, index) => {\n+      if (activeFilter.filterId === filterToAdd.filterId) {\n+        storeActiveFilters[index] = filterToAdd;\n+      }\n+    });\n+  }\n+  return storeActiveFilters;\n+}\n+\n+/**\n+ * @method foundAmongActiveFilters\n+ * @summary checks that the filterToAdd is found among the storeActiveFilters\n+ */\n+function foundAmongActiveFilters({ storeActiveFilters, filterToAdd }) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI4Mjk1NA=="}, "originalCommit": {"oid": "aca6e4a591072da112d61083ebccc3a36f0e0724"}, "originalPosition": 256}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExOTQ5NzQ4OnYy", "diffSide": "RIGHT", "path": "frontend/src/actions/FiltersActions.js", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNDoyMjo0N1rOHbM1ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNDoyMjo0N1rOHbM1ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI4MzkzNA==", "bodyText": "Again, at first glance this is similar to filtersActiveContains. Can't they be merged together ?", "url": "https://github.com/metasfresh/metasfresh/pull/9870#discussion_r498283934", "createdAt": "2020-10-01T14:22:47Z", "author": {"login": "siemiatj"}, "path": "frontend/src/actions/FiltersActions.js", "diffHunk": "@@ -1,8 +1,357 @@\n-import { SET_CLEAR_ALL_FILTER } from '../constants/FilterTypes';\n+import * as types from '../constants/FilterTypes';\n+import { Map as iMap } from 'immutable';\n+import deepUnfreeze from 'deep-unfreeze';\n+import { fieldValueToString } from '../utils/tableHelpers';\n+import _ from 'lodash';\n \n-export function clearAllFilters(data) {\n+export function clearAllFilters({ id, data }) {\n   return {\n-    type: SET_CLEAR_ALL_FILTER,\n-    payload: data,\n+    type: types.CLEAR_ALL_FILTERS,\n+    payload: { id, data },\n   };\n }\n+\n+/**\n+ * @method createFilter\n+ * @summary Add a new filter entry to the redux store\n+ */\n+export function createFilter({ id, data }) {\n+  return {\n+    type: types.CREATE_FILTER,\n+    payload: { id, data },\n+  };\n+}\n+\n+/**\n+ * @method deleteFilter\n+ * @summary Remove the filter with specified `id` from the store\n+ */\n+export function deleteFilter(id) {\n+  return {\n+    type: types.DELETE_FILTER,\n+    payload: { id },\n+  };\n+}\n+\n+/**\n+ * @method updateNotValidFields\n+ * @summary updates in the store the notValidFields flag\n+ */\n+export function updateNotValidFields({ filterId, data }) {\n+  return {\n+    type: types.UPDATE_FLAG_NOTVALIDFIELDS,\n+    payload: { filterId, data },\n+  };\n+}\n+\n+/**\n+ * @method updateActiveFilter\n+ * @summary Updates the activeFilter in the store for the corresponding entity id\n+ */\n+export function updateActiveFilter({ id, data }) {\n+  return {\n+    type: types.UPDATE_ACTIVE_FILTER,\n+    payload: { id, data },\n+  };\n+}\n+\n+/**\n+ * @method updateWidgetShown\n+ * @summary Updates the widgetShown in the store for the corresponding entity id with a boolean value\n+ */\n+export function updateWidgetShown({ id, data }) {\n+  return {\n+    type: types.UPDATE_WIDGET_SHOWN,\n+    payload: { id, data },\n+  };\n+}\n+\n+/**\n+ * @method clearStaticFilters\n+ * @summary Clears the existing static filters for a filter branch in the redux store\n+ */\n+export function clearStaticFilters({ filterId, data }) {\n+  return {\n+    type: types.CLEAR_STATIC_FILTERS,\n+    payload: { filterId, data },\n+  };\n+}\n+\n+/**\n+ * @method getParentFilter\n+ * @summary as the name suggests the function is retrieving the filter data by key from the filterData\n+ * @param {string} filterId - key identifying the filter\n+ * @param {array} filterData array that contains all the filters as they are retrieved from the BE\n+ */\n+function getParentFilter({ filterId, filterData }) {\n+  let parentFilter = {};\n+  filterData.forEach((filter) => {\n+    if (filter.filterId && filter.filterId === filterId) {\n+      parentFilter = filter;\n+    }\n+    if (filter.includedFilters) {\n+      filter.includedFilters.forEach((incFilter) => {\n+        if (incFilter.filterId && incFilter.filterId === filterId) {\n+          parentFilter = incFilter;\n+        }\n+      });\n+    }\n+  });\n+  return parentFilter;\n+}\n+\n+/**\n+ * @method populateFiltersCaptions\n+ * @summary updates the filtersCaptions object for the corresponding filter branch id in the store\n+ * @param {string} id - filter id used as identifier for the filters branch\n+ * @param {object} data - object containing the captions\n+ */\n+export function populateFiltersCaptions(filters) {\n+  const filtersCaptions = {};\n+  if (!filters) return {};\n+  const { filterData, filtersActive } = filters;\n+  if (!filtersActive) return {};\n+\n+  if (filtersActive.length) {\n+    const removeDefault = {};\n+\n+    filtersActive.forEach((filter, filterId) => {\n+      let captionsArray = ['', ''];\n+\n+      if (filter.parameters && filter.parameters.length) {\n+        filter.parameters.forEach((filterParameter) => {\n+          const { value, parameterName, defaultValue } = filterParameter;\n+\n+          if (!defaultValue && filterData) {\n+            // we don't want to show captions, nor show filter button as active for default values\n+            removeDefault[filterId] = true;\n+            const parentFilter = getParentFilter({\n+              filterId: filter.filterId, // we pass the actual key not the index\n+              filterData,\n+            });\n+\n+            const filterParameter = parentFilter.parameters.find(\n+              (param) => param.parameterName === parameterName\n+            );\n+            let captionName = filterParameter.caption;\n+            let itemCaption = filterParameter.caption;\n+\n+            switch (filterParameter.widgetType) {\n+              case 'Text':\n+                captionName = value;\n+\n+                if (!value) {\n+                  captionName = '';\n+                  itemCaption = '';\n+                }\n+                break;\n+              case 'Lookup':\n+              case 'List':\n+                captionName = value && value.caption;\n+                break;\n+              case 'Labels':\n+                captionName = value.values.reduce((caption, item) => {\n+                  return `${caption}, ${item.caption}`;\n+                }, '');\n+                break;\n+              case 'YesNo':\n+                if (value === null) {\n+                  captionName = '';\n+                  itemCaption = '';\n+                }\n+                break;\n+              case 'Switch':\n+              default:\n+                if (!value) {\n+                  captionName = '';\n+                  itemCaption = '';\n+                }\n+                break;\n+            }\n+\n+            if (captionName) {\n+              captionsArray[0] = captionsArray[0]\n+                ? `${captionsArray[0]}, ${captionName}`\n+                : captionName;\n+            }\n+\n+            if (itemCaption) {\n+              captionsArray[1] = captionsArray[1]\n+                ? `${captionsArray[1]}, ${itemCaption}`\n+                : itemCaption;\n+            }\n+          }\n+        });\n+      } else {\n+        const originalFilter = filterData.filter(\n+          (item) => item.filterId === filterId\n+        );\n+        captionsArray = [originalFilter.caption, originalFilter.caption];\n+      }\n+\n+      if (captionsArray.join('').length) {\n+        filtersCaptions[filter.filterId] = captionsArray;\n+        filtersCaptions[filterId] = captionsArray;\n+      }\n+    });\n+  }\n+\n+  return filtersCaptions;\n+}\n+\n+/**\n+ * @method filtersToMap\n+ * @summary creates a map with the filters fetched from the layout request\n+ */\n+export function filtersToMap(filtersArray) {\n+  let filtersMap = iMap();\n+\n+  if (filtersArray && filtersArray.length) {\n+    filtersArray.forEach((filter) => {\n+      filtersMap = filtersMap.set(filter.filterId, filter);\n+    });\n+  }\n+  return filtersMap;\n+}\n+\n+/**\n+ * @method filtersActiveContains\n+ * @summary returns a boolean value depending on the presence of the key withing the activeFilters passed array\n+ */\n+export function filtersActiveContains({ filtersActive, key }) {\n+  if (filtersActive.lenght === 0) return false;\n+  const isPresent = filtersActive.filter((item) => item.filterId === key);\n+  return isPresent.length ? true : false;\n+}\n+\n+/**\n+ * @method setNewFiltersActive\n+ * @summary returns a new array with filters that are going to be the active ones\n+ */\n+export function setNewFiltersActive({ storeActiveFilters, filterToAdd }) {\n+  storeActiveFilters = deepUnfreeze(storeActiveFilters);\n+  if (\n+    !storeActiveFilters.length ||\n+    !foundAmongActiveFilters({ storeActiveFilters, filterToAdd })\n+  ) {\n+    storeActiveFilters.push(filterToAdd);\n+  } else {\n+    storeActiveFilters.forEach((activeFilter, index) => {\n+      if (activeFilter.filterId === filterToAdd.filterId) {\n+        storeActiveFilters[index] = filterToAdd;\n+      }\n+    });\n+  }\n+  return storeActiveFilters;\n+}\n+\n+/**\n+ * @method foundAmongActiveFilters\n+ * @summary checks that the filterToAdd is found among the storeActiveFilters\n+ */\n+function foundAmongActiveFilters({ storeActiveFilters, filterToAdd }) {\n+  let isPresent = false;\n+  storeActiveFilters.forEach((item) => {\n+    if (item.filterId === filterToAdd.filterId) isPresent = true;\n+  });\n+  return isPresent;\n+}\n+\n+/**\n+ * @method isFilterActive\n+ * @summary Check within the active filters array if filterId given as param is active\n+ * @param {string} filterId\n+ * @param {array} activeFilter\n+ */\n+export function isFilterActive({ filterId, filtersActive }) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aca6e4a591072da112d61083ebccc3a36f0e0724"}, "originalPosition": 270}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExOTUwNDIzOnYy", "diffSide": "RIGHT", "path": "frontend/src/actions/FiltersActions.js", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNDoyNDowOVrOHbM5_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNDoyNDowOVrOHbM5_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI4NTA1NQ==", "bodyText": "Just to be sure - filtersActive can be undefined/null, or an empty array ?", "url": "https://github.com/metasfresh/metasfresh/pull/9870#discussion_r498285055", "createdAt": "2020-10-01T14:24:09Z", "author": {"login": "siemiatj"}, "path": "frontend/src/actions/FiltersActions.js", "diffHunk": "@@ -1,8 +1,357 @@\n-import { SET_CLEAR_ALL_FILTER } from '../constants/FilterTypes';\n+import * as types from '../constants/FilterTypes';\n+import { Map as iMap } from 'immutable';\n+import deepUnfreeze from 'deep-unfreeze';\n+import { fieldValueToString } from '../utils/tableHelpers';\n+import _ from 'lodash';\n \n-export function clearAllFilters(data) {\n+export function clearAllFilters({ id, data }) {\n   return {\n-    type: SET_CLEAR_ALL_FILTER,\n-    payload: data,\n+    type: types.CLEAR_ALL_FILTERS,\n+    payload: { id, data },\n   };\n }\n+\n+/**\n+ * @method createFilter\n+ * @summary Add a new filter entry to the redux store\n+ */\n+export function createFilter({ id, data }) {\n+  return {\n+    type: types.CREATE_FILTER,\n+    payload: { id, data },\n+  };\n+}\n+\n+/**\n+ * @method deleteFilter\n+ * @summary Remove the filter with specified `id` from the store\n+ */\n+export function deleteFilter(id) {\n+  return {\n+    type: types.DELETE_FILTER,\n+    payload: { id },\n+  };\n+}\n+\n+/**\n+ * @method updateNotValidFields\n+ * @summary updates in the store the notValidFields flag\n+ */\n+export function updateNotValidFields({ filterId, data }) {\n+  return {\n+    type: types.UPDATE_FLAG_NOTVALIDFIELDS,\n+    payload: { filterId, data },\n+  };\n+}\n+\n+/**\n+ * @method updateActiveFilter\n+ * @summary Updates the activeFilter in the store for the corresponding entity id\n+ */\n+export function updateActiveFilter({ id, data }) {\n+  return {\n+    type: types.UPDATE_ACTIVE_FILTER,\n+    payload: { id, data },\n+  };\n+}\n+\n+/**\n+ * @method updateWidgetShown\n+ * @summary Updates the widgetShown in the store for the corresponding entity id with a boolean value\n+ */\n+export function updateWidgetShown({ id, data }) {\n+  return {\n+    type: types.UPDATE_WIDGET_SHOWN,\n+    payload: { id, data },\n+  };\n+}\n+\n+/**\n+ * @method clearStaticFilters\n+ * @summary Clears the existing static filters for a filter branch in the redux store\n+ */\n+export function clearStaticFilters({ filterId, data }) {\n+  return {\n+    type: types.CLEAR_STATIC_FILTERS,\n+    payload: { filterId, data },\n+  };\n+}\n+\n+/**\n+ * @method getParentFilter\n+ * @summary as the name suggests the function is retrieving the filter data by key from the filterData\n+ * @param {string} filterId - key identifying the filter\n+ * @param {array} filterData array that contains all the filters as they are retrieved from the BE\n+ */\n+function getParentFilter({ filterId, filterData }) {\n+  let parentFilter = {};\n+  filterData.forEach((filter) => {\n+    if (filter.filterId && filter.filterId === filterId) {\n+      parentFilter = filter;\n+    }\n+    if (filter.includedFilters) {\n+      filter.includedFilters.forEach((incFilter) => {\n+        if (incFilter.filterId && incFilter.filterId === filterId) {\n+          parentFilter = incFilter;\n+        }\n+      });\n+    }\n+  });\n+  return parentFilter;\n+}\n+\n+/**\n+ * @method populateFiltersCaptions\n+ * @summary updates the filtersCaptions object for the corresponding filter branch id in the store\n+ * @param {string} id - filter id used as identifier for the filters branch\n+ * @param {object} data - object containing the captions\n+ */\n+export function populateFiltersCaptions(filters) {\n+  const filtersCaptions = {};\n+  if (!filters) return {};\n+  const { filterData, filtersActive } = filters;\n+  if (!filtersActive) return {};\n+\n+  if (filtersActive.length) {\n+    const removeDefault = {};\n+\n+    filtersActive.forEach((filter, filterId) => {\n+      let captionsArray = ['', ''];\n+\n+      if (filter.parameters && filter.parameters.length) {\n+        filter.parameters.forEach((filterParameter) => {\n+          const { value, parameterName, defaultValue } = filterParameter;\n+\n+          if (!defaultValue && filterData) {\n+            // we don't want to show captions, nor show filter button as active for default values\n+            removeDefault[filterId] = true;\n+            const parentFilter = getParentFilter({\n+              filterId: filter.filterId, // we pass the actual key not the index\n+              filterData,\n+            });\n+\n+            const filterParameter = parentFilter.parameters.find(\n+              (param) => param.parameterName === parameterName\n+            );\n+            let captionName = filterParameter.caption;\n+            let itemCaption = filterParameter.caption;\n+\n+            switch (filterParameter.widgetType) {\n+              case 'Text':\n+                captionName = value;\n+\n+                if (!value) {\n+                  captionName = '';\n+                  itemCaption = '';\n+                }\n+                break;\n+              case 'Lookup':\n+              case 'List':\n+                captionName = value && value.caption;\n+                break;\n+              case 'Labels':\n+                captionName = value.values.reduce((caption, item) => {\n+                  return `${caption}, ${item.caption}`;\n+                }, '');\n+                break;\n+              case 'YesNo':\n+                if (value === null) {\n+                  captionName = '';\n+                  itemCaption = '';\n+                }\n+                break;\n+              case 'Switch':\n+              default:\n+                if (!value) {\n+                  captionName = '';\n+                  itemCaption = '';\n+                }\n+                break;\n+            }\n+\n+            if (captionName) {\n+              captionsArray[0] = captionsArray[0]\n+                ? `${captionsArray[0]}, ${captionName}`\n+                : captionName;\n+            }\n+\n+            if (itemCaption) {\n+              captionsArray[1] = captionsArray[1]\n+                ? `${captionsArray[1]}, ${itemCaption}`\n+                : itemCaption;\n+            }\n+          }\n+        });\n+      } else {\n+        const originalFilter = filterData.filter(\n+          (item) => item.filterId === filterId\n+        );\n+        captionsArray = [originalFilter.caption, originalFilter.caption];\n+      }\n+\n+      if (captionsArray.join('').length) {\n+        filtersCaptions[filter.filterId] = captionsArray;\n+        filtersCaptions[filterId] = captionsArray;\n+      }\n+    });\n+  }\n+\n+  return filtersCaptions;\n+}\n+\n+/**\n+ * @method filtersToMap\n+ * @summary creates a map with the filters fetched from the layout request\n+ */\n+export function filtersToMap(filtersArray) {\n+  let filtersMap = iMap();\n+\n+  if (filtersArray && filtersArray.length) {\n+    filtersArray.forEach((filter) => {\n+      filtersMap = filtersMap.set(filter.filterId, filter);\n+    });\n+  }\n+  return filtersMap;\n+}\n+\n+/**\n+ * @method filtersActiveContains\n+ * @summary returns a boolean value depending on the presence of the key withing the activeFilters passed array\n+ */\n+export function filtersActiveContains({ filtersActive, key }) {\n+  if (filtersActive.lenght === 0) return false;\n+  const isPresent = filtersActive.filter((item) => item.filterId === key);\n+  return isPresent.length ? true : false;\n+}\n+\n+/**\n+ * @method setNewFiltersActive\n+ * @summary returns a new array with filters that are going to be the active ones\n+ */\n+export function setNewFiltersActive({ storeActiveFilters, filterToAdd }) {\n+  storeActiveFilters = deepUnfreeze(storeActiveFilters);\n+  if (\n+    !storeActiveFilters.length ||\n+    !foundAmongActiveFilters({ storeActiveFilters, filterToAdd })\n+  ) {\n+    storeActiveFilters.push(filterToAdd);\n+  } else {\n+    storeActiveFilters.forEach((activeFilter, index) => {\n+      if (activeFilter.filterId === filterToAdd.filterId) {\n+        storeActiveFilters[index] = filterToAdd;\n+      }\n+    });\n+  }\n+  return storeActiveFilters;\n+}\n+\n+/**\n+ * @method foundAmongActiveFilters\n+ * @summary checks that the filterToAdd is found among the storeActiveFilters\n+ */\n+function foundAmongActiveFilters({ storeActiveFilters, filterToAdd }) {\n+  let isPresent = false;\n+  storeActiveFilters.forEach((item) => {\n+    if (item.filterId === filterToAdd.filterId) isPresent = true;\n+  });\n+  return isPresent;\n+}\n+\n+/**\n+ * @method isFilterActive\n+ * @summary Check within the active filters array if filterId given as param is active\n+ * @param {string} filterId\n+ * @param {array} activeFilter\n+ */\n+export function isFilterActive({ filterId, filtersActive }) {\n+  if (filtersActive) {\n+    // filters with only defaultValues shouldn't be set to active\n+    const active = filtersActive.find(\n+      (item) => item.filterId === filterId && !item.defaultVal\n+    );\n+\n+    return typeof active !== 'undefined';\n+  }\n+\n+  return false;\n+}\n+\n+/**\n+ * @method annotateFilters\n+ * @summary Creates caption for active filters to show when the widget is closed\n+ * @param {array} unannotatedFilters\n+ * @param {array} filtersActive\n+ */\n+export function annotateFilters({ unannotatedFilters, filtersActive }) {\n+  filtersActive = filtersActive ? filtersActive : [];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aca6e4a591072da112d61083ebccc3a36f0e0724"}, "originalPosition": 290}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExOTcxNTg0OnYy", "diffSide": "LEFT", "path": "frontend/src/components/filters/Filters.js", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNTowODoyNFrOHbO-Og==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNTowODoyNFrOHbO-Og==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMxODkwNg==", "bodyText": "As far as I understand this was divided into smaller functions. Comments were also carried over, right ?", "url": "https://github.com/metasfresh/metasfresh/pull/9870#discussion_r498318906", "createdAt": "2020-10-01T15:08:24Z", "author": {"login": "siemiatj"}, "path": "frontend/src/components/filters/Filters.js", "diffHunk": "@@ -2,604 +2,131 @@ import counterpart from 'counterpart';\n import PropTypes from 'prop-types';\n import React, { PureComponent } from 'react';\n import { connect } from 'react-redux';\n-// -- using iMap from immutable\n-import { Map as iMap } from 'immutable';\n-import _ from 'lodash';\n-\n-import { DATE_FIELDS } from '../../constants/Constants';\n import {\n-  generateMomentObj,\n-  getFormatForDateField,\n-} from '../widget/RawWidgetHelpers';\n-import { parseDateWithCurrentTimezone } from '../../utils/documentListHelper';\n-import { fieldValueToString } from '../../utils/tableHelpers';\n+  updateWidgetShown,\n+  setNewFiltersActive,\n+  updateActiveFilter,\n+  clearAllFilters,\n+  annotateFilters,\n+  isFilterValid,\n+  updateNotValidFields,\n+  parseToPatch,\n+} from '../../actions/FiltersActions';\n+\n import FiltersFrequent from './FiltersFrequent';\n import FiltersNotFrequent from './FiltersNotFrequent';\n-\n-/**\n- * @method parseDateToReadable\n- * @summary ToDo: Describe the method\n- * @param {*} widgetType\n- * @param {*} value\n- * @todo Write the documentation\n- */\n-export function parseDateToReadable(widgetType, value) {\n-  if (DATE_FIELDS.indexOf(widgetType) > -1) {\n-    return parseDateWithCurrentTimezone(value, widgetType);\n-  }\n-  return value;\n-}\n+import deepUnfreeze from 'deep-unfreeze';\n+import { getEntityRelatedId } from '../../reducers/filters';\n \n /**\n  * @file Class based component.\n  * @module Filters\n- * @extends Component\n+ * @extends PureComponent\n  */\n class Filters extends PureComponent {\n-  state = {\n-    activeFilter: null,\n-    activeFiltersCaptions: null,\n-    flatFiltersMap: null,\n-    notValidFields: null,\n-    widgetShown: false,\n-  };\n-\n-  /**\n-   * @method UNSAFE_componentWillReceiveProps\n-   * @summary ToDo: Describe the method\n-   */\n-  UNSAFE_componentWillReceiveProps() {\n-    this.parseActiveFilters();\n-  }\n-\n-  /**\n-   * @method componentDidMount\n-   * @summary ToDo: Describe the method\n-   */\n-  componentDidMount() {\n-    this.parseActiveFilters();\n-  }\n-\n-  /**\n-   * @method arrangeFilters\n-   * @summary combines the filters and also removes the other actives ones from same group\n-   */\n-  arrangeFilters = (filterData) => {\n-    let combinedFilters = [];\n-    for (const [key] of filterData.entries()) {\n-      let item = filterData.get(key);\n-      if (typeof item.includedFilters !== 'undefined') {\n-        combinedFilters.push(...item.includedFilters);\n-      } else {\n-        combinedFilters.push(item);\n-      }\n-    }\n-    let mappedFiltersData = new Map();\n-    combinedFilters.forEach((item) => {\n-      mappedFiltersData.set(item.filterId, item);\n-    });\n-    return mappedFiltersData;\n-  };\n-\n-  // PARSING FILTERS ---------------------------------------------------------\n-\n-  /*\n-   * parseActiveFilters - this function does three things:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aca6e4a591072da112d61083ebccc3a36f0e0724"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExOTcyMTkwOnYy", "diffSide": "RIGHT", "path": "frontend/src/components/filters/Filters.js", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNTowOTo0NFrOHbPB_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNTowOTo0NFrOHbPB_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMxOTg2OQ==", "bodyText": "Well it doesn't really update the docList, since filters are in the store and DL should react automatically.", "url": "https://github.com/metasfresh/metasfresh/pull/9870#discussion_r498319869", "createdAt": "2020-10-01T15:09:44Z", "author": {"login": "siemiatj"}, "path": "frontend/src/components/filters/Filters.js", "diffHunk": "@@ -2,604 +2,131 @@ import counterpart from 'counterpart';\n import PropTypes from 'prop-types';\n import React, { PureComponent } from 'react';\n import { connect } from 'react-redux';\n-// -- using iMap from immutable\n-import { Map as iMap } from 'immutable';\n-import _ from 'lodash';\n-\n-import { DATE_FIELDS } from '../../constants/Constants';\n import {\n-  generateMomentObj,\n-  getFormatForDateField,\n-} from '../widget/RawWidgetHelpers';\n-import { parseDateWithCurrentTimezone } from '../../utils/documentListHelper';\n-import { fieldValueToString } from '../../utils/tableHelpers';\n+  updateWidgetShown,\n+  setNewFiltersActive,\n+  updateActiveFilter,\n+  clearAllFilters,\n+  annotateFilters,\n+  isFilterValid,\n+  updateNotValidFields,\n+  parseToPatch,\n+} from '../../actions/FiltersActions';\n+\n import FiltersFrequent from './FiltersFrequent';\n import FiltersNotFrequent from './FiltersNotFrequent';\n-\n-/**\n- * @method parseDateToReadable\n- * @summary ToDo: Describe the method\n- * @param {*} widgetType\n- * @param {*} value\n- * @todo Write the documentation\n- */\n-export function parseDateToReadable(widgetType, value) {\n-  if (DATE_FIELDS.indexOf(widgetType) > -1) {\n-    return parseDateWithCurrentTimezone(value, widgetType);\n-  }\n-  return value;\n-}\n+import deepUnfreeze from 'deep-unfreeze';\n+import { getEntityRelatedId } from '../../reducers/filters';\n \n /**\n  * @file Class based component.\n  * @module Filters\n- * @extends Component\n+ * @extends PureComponent\n  */\n class Filters extends PureComponent {\n-  state = {\n-    activeFilter: null,\n-    activeFiltersCaptions: null,\n-    flatFiltersMap: null,\n-    notValidFields: null,\n-    widgetShown: false,\n-  };\n-\n-  /**\n-   * @method UNSAFE_componentWillReceiveProps\n-   * @summary ToDo: Describe the method\n-   */\n-  UNSAFE_componentWillReceiveProps() {\n-    this.parseActiveFilters();\n-  }\n-\n-  /**\n-   * @method componentDidMount\n-   * @summary ToDo: Describe the method\n-   */\n-  componentDidMount() {\n-    this.parseActiveFilters();\n-  }\n-\n-  /**\n-   * @method arrangeFilters\n-   * @summary combines the filters and also removes the other actives ones from same group\n-   */\n-  arrangeFilters = (filterData) => {\n-    let combinedFilters = [];\n-    for (const [key] of filterData.entries()) {\n-      let item = filterData.get(key);\n-      if (typeof item.includedFilters !== 'undefined') {\n-        combinedFilters.push(...item.includedFilters);\n-      } else {\n-        combinedFilters.push(item);\n-      }\n-    }\n-    let mappedFiltersData = new Map();\n-    combinedFilters.forEach((item) => {\n-      mappedFiltersData.set(item.filterId, item);\n-    });\n-    return mappedFiltersData;\n-  };\n-\n-  // PARSING FILTERS ---------------------------------------------------------\n-\n-  /*\n-   * parseActiveFilters - this function does three things:\n-   *  - creates a flat map of existing filter fields to store the widgetType for\n-        further processing\n-   *  - creates a local copy of active filters object including filters that\n-   *    only have defaultValues set. `defaultVal` flag tells us, that this\n-   *    filter has only defaultValues, and no values set by the user. We need\n-   *    this to ble able to differentiate between filters that should be\n-   *    indicated as active on load, or not.\n-   *  - creates an object with captions of each active parameter per filter\n-   *\n-   * So first we traverse all filters data and perform actions in this order:\n-   *  - if filter is in active filters and parameter has no defaultValue,\n-   *    or defaultValue has been nullified by user's selection we add it\n-   *    local active filters and set the `defaultVal` flag to false\n-   *    (as it obviously was already set).\n-   *  - if filter is active check if current loop parameter is set in the\n-   *    active filters. If yes, do nothing as it'll always override the\n-   *    defaultValue\n-   *  - otherwise add parameter and filter to local active filters and set\n-   *    the `defaultVal` to true as apparently there are no values set  \n-   *  \n-   *    Update: 10 March 2020, removed the logic to set the default \n-   * \n-   */\n-  /**\n-   * @method parseActiveFilters\n-   * @summary ToDo: Describe the method\n-   */\n-  parseActiveFilters = () => {\n-    let { filtersActive, filterData, initialValuesNulled } = this.props;\n-    let activeFilters = _.cloneDeep(filtersActive);\n-\n-    // make new ES6 Map with the items from combined filters\n-    let mappedFiltersData = this.arrangeFilters(filterData);\n-    // put the resulted combined map of filters into the iMap and preserve existing functionality\n-    let filtersData = iMap(mappedFiltersData);\n-    const flatFiltersMap = {};\n-    const activeFiltersCaptions = {};\n-\n-    // find any filters with default values first and extend\n-    // activeFilters with them\n-    filtersData.forEach((filter, filterId) => {\n-      if (filter.parameters) {\n-        outerParameters: for (let parameter of filter.parameters) {\n-          const { defaultValue, parameterName, widgetType } = parameter;\n-          const nulledFilter = initialValuesNulled.get(filterId);\n-\n-          flatFiltersMap[`${filterId}-${parameterName}`] = {\n-            widgetType,\n-          };\n-\n-          const isActive = filtersActive.has(filterId);\n-\n-          if (\n-            !defaultValue ||\n-            (nulledFilter && nulledFilter.has(parameterName))\n-          ) {\n-            if (isActive) {\n-              activeFilters = activeFilters.set(filterId, {\n-                defaultVal: false,\n-                filterId,\n-                parameters: activeFilters.get(filterId).parameters,\n-              });\n-            }\n-            continue;\n-          }\n-\n-          if (isActive) {\n-            //look for existing parameterName in parameters array\n-            // skip if found as they override defaultValue ALWAYS\n-            const filterActive = activeFilters.get(filterId);\n-\n-            if (filterActive.parameters) {\n-              for (let activeParameter of filterActive.parameters) {\n-                if (activeParameter.parameterName === parameterName) {\n-                  continue outerParameters;\n-                }\n-              }\n-            }\n-          }\n-        }\n-      }\n-    });\n-\n-    if (activeFilters.size) {\n-      const removeDefault = {};\n-\n-      activeFilters.forEach((filter, filterId) => {\n-        let captionsArray = ['', ''];\n-\n-        if (filter.parameters && filter.parameters.length) {\n-          filter.parameters.forEach((filterParameter) => {\n-            const { value, parameterName, defaultValue } = filterParameter;\n-\n-            if (!defaultValue) {\n-              // we don't want to show captions, nor show filter button as active\n-              // for default values\n-              removeDefault[filterId] = true;\n-\n-              const parentFilter = filtersData.get(filterId);\n-              const filterParameter = parentFilter.parameters.find(\n-                (param) => param.parameterName === parameterName\n-              );\n-              let captionName = filterParameter.caption;\n-              let itemCaption = filterParameter.caption;\n-\n-              switch (filterParameter.widgetType) {\n-                case 'Text':\n-                  captionName = value;\n-\n-                  if (!value) {\n-                    captionName = '';\n-                    itemCaption = '';\n-                  }\n-                  break;\n-                case 'Lookup':\n-                case 'List':\n-                  captionName = value && value.caption;\n-                  break;\n-                case 'Labels':\n-                  captionName = value.values.reduce((caption, item) => {\n-                    return `${caption}, ${item.caption}`;\n-                  }, '');\n-                  break;\n-                case 'YesNo':\n-                  if (value === null) {\n-                    captionName = '';\n-                    itemCaption = '';\n-                  }\n-                  break;\n-                case 'Switch':\n-                default:\n-                  if (!value) {\n-                    captionName = '';\n-                    itemCaption = '';\n-                  }\n-                  break;\n-              }\n-\n-              if (captionName) {\n-                captionsArray[0] = captionsArray[0]\n-                  ? `${captionsArray[0]}, ${captionName}`\n-                  : captionName;\n-              }\n-\n-              if (itemCaption) {\n-                captionsArray[1] = captionsArray[1]\n-                  ? `${captionsArray[1]}, ${itemCaption}`\n-                  : itemCaption;\n-              }\n-            }\n-          });\n-        } else {\n-          const originalFilter = filtersData.get(filterId);\n-          captionsArray = [originalFilter.caption, originalFilter.caption];\n-        }\n-\n-        if (captionsArray.join('').length) {\n-          activeFiltersCaptions[filterId] = captionsArray;\n-        }\n-      });\n-\n-      // if filter has defaultValues but also some user defined ones,\n-      // we should still include it in active filters\n-      if (Object.keys(removeDefault).length) {\n-        for (let key of Object.keys(removeDefault)) {\n-          activeFilters = activeFilters.setIn([key, 'defaultVal'], false);\n-        }\n-      }\n-\n-      const cleanActiveFilter = this.cleanupActiveFilter(\n-        filterData.toIndexedSeq().toArray(),\n-        activeFilters.toIndexedSeq().toArray()\n-      );\n-\n-      this.setState({\n-        activeFilter: cleanActiveFilter,\n-        activeFiltersCaptions,\n-        flatFiltersMap,\n-      });\n-    } else {\n-      this.setState({\n-        activeFilter: null,\n-        activeFiltersCaptions: null,\n-        flatFiltersMap,\n-      });\n-    }\n-  };\n-\n-  cleanupActiveFilter = (allFilters, activeStateFilters) => {\n-    let filtersToRemove = [];\n-    activeStateFilters.forEach((activeStateFilter) => {\n-      allFilters.forEach((filterItem) => {\n-        if (Array.isArray(filterItem.includedFilters)) {\n-          let groupFilter = filterItem.includedFilters;\n-          let foundMatches = groupFilter.filter(\n-            (gFilterItem) => gFilterItem.filterId === activeStateFilter.filterId\n-          );\n-          if (foundMatches.length > 0) {\n-            filtersToRemove = groupFilter.filter(\n-              (toRemove) => toRemove.filterId !== activeStateFilter.filterId\n-            );\n-          }\n-        }\n-      });\n-    });\n-    return activeStateFilters.filter(\n-      (asFilterItem) =>\n-        !this.isBlacklisted(asFilterItem.filterId, filtersToRemove)\n-    );\n-  };\n-\n-  /**\n-   * @method isBlackListed\n-   * @summary Check if the filterId is found among the filters to remove array\n-   * @param {string filterId\n-   * @param {array} filtersToRemove\n-   */\n-  isBlacklisted = (filterId, filtersToRemove) => {\n-    let resultValue = false;\n-    filtersToRemove.forEach((filterItem) => {\n-      if (filterItem.filterId === filterId) {\n-        resultValue = true;\n-      }\n-    });\n-    return resultValue;\n-  };\n-\n-  /**\n-   * @method sortFilters\n-   * @summary ToDo: Describe the method\n-   * @param {array} data\n-   */\n-  sortFilters = (data) => {\n-    return {\n-      frequentFilters: this.annotateFilters(\n-        data\n-          .filter((filter) => filter.frequent)\n-          .toIndexedSeq()\n-          .toArray()\n-      ),\n-      notFrequentFilters: this.annotateFilters(\n-        data\n-          .filter((filter) => !filter.frequent && !filter.static)\n-          .toIndexedSeq()\n-          .toArray()\n-      ),\n-      staticFilters: this.annotateFilters(\n-        data.filter((filter) => filter.static)\n-      )\n-        .toIndexedSeq()\n-        .toArray(),\n-    };\n-  };\n-\n-  /**\n-   * @method isFilterValid\n-   * @summary ToDo: Describe the method\n-   * @param {*} filters\n-   */\n-  isFilterValid = (filters) => {\n-    if (filters.parameters) {\n-      return !filters.parameters.filter((item) => item.mandatory && !item.value)\n-        .length;\n-    }\n-\n-    return true;\n-  };\n-\n-  /**\n-   * @method isFilterActive\n-   * @summary ToDo: Describe the method\n-   * @param {*} filterId\n-   */\n-  isFilterActive = (filterId) => {\n-    const { activeFilter } = this.state;\n-\n-    if (activeFilter) {\n-      // filters with only defaultValues shouldn't be set to active\n-      const active = activeFilter.find(\n-        (item) => item.filterId === filterId && !item.defaultVal\n-      );\n-\n-      return typeof active !== 'undefined';\n-    }\n-\n-    return false;\n-  };\n-\n-  /**\n-   * @method parseToPatch\n-   * @summary ToDo: Describe the method\n-   * @param {*} params\n-   */\n-  parseToPatch = (params) => {\n-    return params.reduce((acc, param) => {\n-      if (\n-        // filters with only defaltValue shouldn't be sent to server\n-        !param.defaultValue ||\n-        JSON.stringify(param.defaultValue) !== JSON.stringify(param.value)\n-      ) {\n-        acc.push({\n-          ...param,\n-          value: param.value === '' ? null : param.value,\n-        });\n-      }\n-\n-      return acc;\n-    }, []);\n-  };\n-\n-  // SETTING FILTERS  --------------------------------------------------------\n   /**\n    * @method applyFilters\n    * @summary This method should update docList", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aca6e4a591072da112d61083ebccc3a36f0e0724"}, "originalPosition": 413}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExOTc0NDk3OnYy", "diffSide": "RIGHT", "path": "frontend/src/components/filters/Filters.js", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNToxNDo1MlrOHbPQcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQwNzowOTo1NVrOHbjJDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMyMzU2OQ==", "bodyText": "is there a case, where we set new active filter without updating active filter ? Maybe setNewFiltersActive should call updateActiveFilter ?", "url": "https://github.com/metasfresh/metasfresh/pull/9870#discussion_r498323569", "createdAt": "2020-10-01T15:14:52Z", "author": {"login": "siemiatj"}, "path": "frontend/src/components/filters/Filters.js", "diffHunk": "@@ -2,604 +2,131 @@ import counterpart from 'counterpart';\n import PropTypes from 'prop-types';\n import React, { PureComponent } from 'react';\n import { connect } from 'react-redux';\n-// -- using iMap from immutable\n-import { Map as iMap } from 'immutable';\n-import _ from 'lodash';\n-\n-import { DATE_FIELDS } from '../../constants/Constants';\n import {\n-  generateMomentObj,\n-  getFormatForDateField,\n-} from '../widget/RawWidgetHelpers';\n-import { parseDateWithCurrentTimezone } from '../../utils/documentListHelper';\n-import { fieldValueToString } from '../../utils/tableHelpers';\n+  updateWidgetShown,\n+  setNewFiltersActive,\n+  updateActiveFilter,\n+  clearAllFilters,\n+  annotateFilters,\n+  isFilterValid,\n+  updateNotValidFields,\n+  parseToPatch,\n+} from '../../actions/FiltersActions';\n+\n import FiltersFrequent from './FiltersFrequent';\n import FiltersNotFrequent from './FiltersNotFrequent';\n-\n-/**\n- * @method parseDateToReadable\n- * @summary ToDo: Describe the method\n- * @param {*} widgetType\n- * @param {*} value\n- * @todo Write the documentation\n- */\n-export function parseDateToReadable(widgetType, value) {\n-  if (DATE_FIELDS.indexOf(widgetType) > -1) {\n-    return parseDateWithCurrentTimezone(value, widgetType);\n-  }\n-  return value;\n-}\n+import deepUnfreeze from 'deep-unfreeze';\n+import { getEntityRelatedId } from '../../reducers/filters';\n \n /**\n  * @file Class based component.\n  * @module Filters\n- * @extends Component\n+ * @extends PureComponent\n  */\n class Filters extends PureComponent {\n-  state = {\n-    activeFilter: null,\n-    activeFiltersCaptions: null,\n-    flatFiltersMap: null,\n-    notValidFields: null,\n-    widgetShown: false,\n-  };\n-\n-  /**\n-   * @method UNSAFE_componentWillReceiveProps\n-   * @summary ToDo: Describe the method\n-   */\n-  UNSAFE_componentWillReceiveProps() {\n-    this.parseActiveFilters();\n-  }\n-\n-  /**\n-   * @method componentDidMount\n-   * @summary ToDo: Describe the method\n-   */\n-  componentDidMount() {\n-    this.parseActiveFilters();\n-  }\n-\n-  /**\n-   * @method arrangeFilters\n-   * @summary combines the filters and also removes the other actives ones from same group\n-   */\n-  arrangeFilters = (filterData) => {\n-    let combinedFilters = [];\n-    for (const [key] of filterData.entries()) {\n-      let item = filterData.get(key);\n-      if (typeof item.includedFilters !== 'undefined') {\n-        combinedFilters.push(...item.includedFilters);\n-      } else {\n-        combinedFilters.push(item);\n-      }\n-    }\n-    let mappedFiltersData = new Map();\n-    combinedFilters.forEach((item) => {\n-      mappedFiltersData.set(item.filterId, item);\n-    });\n-    return mappedFiltersData;\n-  };\n-\n-  // PARSING FILTERS ---------------------------------------------------------\n-\n-  /*\n-   * parseActiveFilters - this function does three things:\n-   *  - creates a flat map of existing filter fields to store the widgetType for\n-        further processing\n-   *  - creates a local copy of active filters object including filters that\n-   *    only have defaultValues set. `defaultVal` flag tells us, that this\n-   *    filter has only defaultValues, and no values set by the user. We need\n-   *    this to ble able to differentiate between filters that should be\n-   *    indicated as active on load, or not.\n-   *  - creates an object with captions of each active parameter per filter\n-   *\n-   * So first we traverse all filters data and perform actions in this order:\n-   *  - if filter is in active filters and parameter has no defaultValue,\n-   *    or defaultValue has been nullified by user's selection we add it\n-   *    local active filters and set the `defaultVal` flag to false\n-   *    (as it obviously was already set).\n-   *  - if filter is active check if current loop parameter is set in the\n-   *    active filters. If yes, do nothing as it'll always override the\n-   *    defaultValue\n-   *  - otherwise add parameter and filter to local active filters and set\n-   *    the `defaultVal` to true as apparently there are no values set  \n-   *  \n-   *    Update: 10 March 2020, removed the logic to set the default \n-   * \n-   */\n-  /**\n-   * @method parseActiveFilters\n-   * @summary ToDo: Describe the method\n-   */\n-  parseActiveFilters = () => {\n-    let { filtersActive, filterData, initialValuesNulled } = this.props;\n-    let activeFilters = _.cloneDeep(filtersActive);\n-\n-    // make new ES6 Map with the items from combined filters\n-    let mappedFiltersData = this.arrangeFilters(filterData);\n-    // put the resulted combined map of filters into the iMap and preserve existing functionality\n-    let filtersData = iMap(mappedFiltersData);\n-    const flatFiltersMap = {};\n-    const activeFiltersCaptions = {};\n-\n-    // find any filters with default values first and extend\n-    // activeFilters with them\n-    filtersData.forEach((filter, filterId) => {\n-      if (filter.parameters) {\n-        outerParameters: for (let parameter of filter.parameters) {\n-          const { defaultValue, parameterName, widgetType } = parameter;\n-          const nulledFilter = initialValuesNulled.get(filterId);\n-\n-          flatFiltersMap[`${filterId}-${parameterName}`] = {\n-            widgetType,\n-          };\n-\n-          const isActive = filtersActive.has(filterId);\n-\n-          if (\n-            !defaultValue ||\n-            (nulledFilter && nulledFilter.has(parameterName))\n-          ) {\n-            if (isActive) {\n-              activeFilters = activeFilters.set(filterId, {\n-                defaultVal: false,\n-                filterId,\n-                parameters: activeFilters.get(filterId).parameters,\n-              });\n-            }\n-            continue;\n-          }\n-\n-          if (isActive) {\n-            //look for existing parameterName in parameters array\n-            // skip if found as they override defaultValue ALWAYS\n-            const filterActive = activeFilters.get(filterId);\n-\n-            if (filterActive.parameters) {\n-              for (let activeParameter of filterActive.parameters) {\n-                if (activeParameter.parameterName === parameterName) {\n-                  continue outerParameters;\n-                }\n-              }\n-            }\n-          }\n-        }\n-      }\n-    });\n-\n-    if (activeFilters.size) {\n-      const removeDefault = {};\n-\n-      activeFilters.forEach((filter, filterId) => {\n-        let captionsArray = ['', ''];\n-\n-        if (filter.parameters && filter.parameters.length) {\n-          filter.parameters.forEach((filterParameter) => {\n-            const { value, parameterName, defaultValue } = filterParameter;\n-\n-            if (!defaultValue) {\n-              // we don't want to show captions, nor show filter button as active\n-              // for default values\n-              removeDefault[filterId] = true;\n-\n-              const parentFilter = filtersData.get(filterId);\n-              const filterParameter = parentFilter.parameters.find(\n-                (param) => param.parameterName === parameterName\n-              );\n-              let captionName = filterParameter.caption;\n-              let itemCaption = filterParameter.caption;\n-\n-              switch (filterParameter.widgetType) {\n-                case 'Text':\n-                  captionName = value;\n-\n-                  if (!value) {\n-                    captionName = '';\n-                    itemCaption = '';\n-                  }\n-                  break;\n-                case 'Lookup':\n-                case 'List':\n-                  captionName = value && value.caption;\n-                  break;\n-                case 'Labels':\n-                  captionName = value.values.reduce((caption, item) => {\n-                    return `${caption}, ${item.caption}`;\n-                  }, '');\n-                  break;\n-                case 'YesNo':\n-                  if (value === null) {\n-                    captionName = '';\n-                    itemCaption = '';\n-                  }\n-                  break;\n-                case 'Switch':\n-                default:\n-                  if (!value) {\n-                    captionName = '';\n-                    itemCaption = '';\n-                  }\n-                  break;\n-              }\n-\n-              if (captionName) {\n-                captionsArray[0] = captionsArray[0]\n-                  ? `${captionsArray[0]}, ${captionName}`\n-                  : captionName;\n-              }\n-\n-              if (itemCaption) {\n-                captionsArray[1] = captionsArray[1]\n-                  ? `${captionsArray[1]}, ${itemCaption}`\n-                  : itemCaption;\n-              }\n-            }\n-          });\n-        } else {\n-          const originalFilter = filtersData.get(filterId);\n-          captionsArray = [originalFilter.caption, originalFilter.caption];\n-        }\n-\n-        if (captionsArray.join('').length) {\n-          activeFiltersCaptions[filterId] = captionsArray;\n-        }\n-      });\n-\n-      // if filter has defaultValues but also some user defined ones,\n-      // we should still include it in active filters\n-      if (Object.keys(removeDefault).length) {\n-        for (let key of Object.keys(removeDefault)) {\n-          activeFilters = activeFilters.setIn([key, 'defaultVal'], false);\n-        }\n-      }\n-\n-      const cleanActiveFilter = this.cleanupActiveFilter(\n-        filterData.toIndexedSeq().toArray(),\n-        activeFilters.toIndexedSeq().toArray()\n-      );\n-\n-      this.setState({\n-        activeFilter: cleanActiveFilter,\n-        activeFiltersCaptions,\n-        flatFiltersMap,\n-      });\n-    } else {\n-      this.setState({\n-        activeFilter: null,\n-        activeFiltersCaptions: null,\n-        flatFiltersMap,\n-      });\n-    }\n-  };\n-\n-  cleanupActiveFilter = (allFilters, activeStateFilters) => {\n-    let filtersToRemove = [];\n-    activeStateFilters.forEach((activeStateFilter) => {\n-      allFilters.forEach((filterItem) => {\n-        if (Array.isArray(filterItem.includedFilters)) {\n-          let groupFilter = filterItem.includedFilters;\n-          let foundMatches = groupFilter.filter(\n-            (gFilterItem) => gFilterItem.filterId === activeStateFilter.filterId\n-          );\n-          if (foundMatches.length > 0) {\n-            filtersToRemove = groupFilter.filter(\n-              (toRemove) => toRemove.filterId !== activeStateFilter.filterId\n-            );\n-          }\n-        }\n-      });\n-    });\n-    return activeStateFilters.filter(\n-      (asFilterItem) =>\n-        !this.isBlacklisted(asFilterItem.filterId, filtersToRemove)\n-    );\n-  };\n-\n-  /**\n-   * @method isBlackListed\n-   * @summary Check if the filterId is found among the filters to remove array\n-   * @param {string filterId\n-   * @param {array} filtersToRemove\n-   */\n-  isBlacklisted = (filterId, filtersToRemove) => {\n-    let resultValue = false;\n-    filtersToRemove.forEach((filterItem) => {\n-      if (filterItem.filterId === filterId) {\n-        resultValue = true;\n-      }\n-    });\n-    return resultValue;\n-  };\n-\n-  /**\n-   * @method sortFilters\n-   * @summary ToDo: Describe the method\n-   * @param {array} data\n-   */\n-  sortFilters = (data) => {\n-    return {\n-      frequentFilters: this.annotateFilters(\n-        data\n-          .filter((filter) => filter.frequent)\n-          .toIndexedSeq()\n-          .toArray()\n-      ),\n-      notFrequentFilters: this.annotateFilters(\n-        data\n-          .filter((filter) => !filter.frequent && !filter.static)\n-          .toIndexedSeq()\n-          .toArray()\n-      ),\n-      staticFilters: this.annotateFilters(\n-        data.filter((filter) => filter.static)\n-      )\n-        .toIndexedSeq()\n-        .toArray(),\n-    };\n-  };\n-\n-  /**\n-   * @method isFilterValid\n-   * @summary ToDo: Describe the method\n-   * @param {*} filters\n-   */\n-  isFilterValid = (filters) => {\n-    if (filters.parameters) {\n-      return !filters.parameters.filter((item) => item.mandatory && !item.value)\n-        .length;\n-    }\n-\n-    return true;\n-  };\n-\n-  /**\n-   * @method isFilterActive\n-   * @summary ToDo: Describe the method\n-   * @param {*} filterId\n-   */\n-  isFilterActive = (filterId) => {\n-    const { activeFilter } = this.state;\n-\n-    if (activeFilter) {\n-      // filters with only defaultValues shouldn't be set to active\n-      const active = activeFilter.find(\n-        (item) => item.filterId === filterId && !item.defaultVal\n-      );\n-\n-      return typeof active !== 'undefined';\n-    }\n-\n-    return false;\n-  };\n-\n-  /**\n-   * @method parseToPatch\n-   * @summary ToDo: Describe the method\n-   * @param {*} params\n-   */\n-  parseToPatch = (params) => {\n-    return params.reduce((acc, param) => {\n-      if (\n-        // filters with only defaltValue shouldn't be sent to server\n-        !param.defaultValue ||\n-        JSON.stringify(param.defaultValue) !== JSON.stringify(param.value)\n-      ) {\n-        acc.push({\n-          ...param,\n-          value: param.value === '' ? null : param.value,\n-        });\n-      }\n-\n-      return acc;\n-    }, []);\n-  };\n-\n-  // SETTING FILTERS  --------------------------------------------------------\n   /**\n    * @method applyFilters\n    * @summary This method should update docList\n-   * @param {*} isActive\n-   * @param {*} captionValue\n    * @param {object} filter\n-   * @param {*} cb\n-   */\n-  // eslint-disable-next-line no-unused-vars\n-  applyFilters = ({ isActive, captionValue, ...filter }, cb) => {\n-    const valid = this.isFilterValid(filter);\n-\n-    this.setState(\n-      {\n-        notValidFields: !valid,\n-      },\n-      () => {\n-        if (valid) {\n-          const parsedFilter = filter.parameters\n-            ? {\n-                ...filter,\n-                parameters: this.parseToPatch(filter.parameters),\n-              }\n-            : filter;\n+   * @param {function} cb - executed if filter is valid and after it was applied\n+   */\n+  applyFilters = ({ ...filter }, cb) => {\n+    const valid = isFilterValid(filter);\n+    const { updateNotValidFields, filterId } = this.props;\n+\n+    updateNotValidFields({ filterId, data: !valid });\n+    if (valid) {\n+      const parsedFilter = filter.parameters\n+        ? {\n+            ...filter,\n+            parameters: parseToPatch(filter.parameters),\n+          }\n+        : filter;\n \n-          this.setFilterActive(parsedFilter);\n+      this.setFilterActive(parsedFilter);\n \n-          cb && cb();\n-        }\n-      }\n-    );\n+      cb && cb();\n+    }\n   };\n \n   /**\n    * @method setFilterActive\n-   * @summary This function merges new filters that are to be activated with the existing\n-   *  active filters. Additionally we format date fields accordingly so that the backend\n-   *  accepts them.\n+   * @summary This function updates the active filters we set and then triggers the pre-existing\n+   *          logic from DocList that will fetch the filtered data\n    * @param {object} filterToAdd\n    */\n   setFilterActive = (filterToAdd) => {\n-    const { updateDocList } = this.props;\n-    let { filtersActive } = this.props;\n-    const { flatFiltersMap } = this.state;\n-    let activeFilters = iMap(filtersActive);\n-\n-    activeFilters = activeFilters.filter(\n-      (item, id) => id !== filterToAdd.filterId\n-    );\n-    activeFilters = activeFilters.set(filterToAdd.filterId, filterToAdd);\n-\n-    if (flatFiltersMap) {\n-      activeFilters = activeFilters.map((filter, filterId) => {\n-        filter.parameters &&\n-          filter.parameters.forEach((parameter) => {\n-            const { value, valueTo, parameterName } = parameter;\n-            const singleFilter = flatFiltersMap[`${filterId}-${parameterName}`];\n-\n-            if (\n-              singleFilter &&\n-              DATE_FIELDS.indexOf(singleFilter.widgetType) > -1\n-            ) {\n-              const format = getFormatForDateField(singleFilter.widgetType);\n-\n-              if (value) {\n-                parameter.value = generateMomentObj(value, format);\n-              }\n-              if (valueTo) {\n-                parameter.valueTo = generateMomentObj(valueTo, format);\n-              }\n-            }\n-          });\n+    const { updateDocList, filterId, updateActiveFilter } = this.props;\n+    const { filtersActive: storeActiveFilters } = this.props.filters;\n \n-        return filter;\n-      });\n-    }\n+    // updating the active filters from the redux store with the filter passed as param\n+    const newFiltersActive = setNewFiltersActive({", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aca6e4a591072da112d61083ebccc3a36f0e0724"}, "originalPosition": 509}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODY0OTM1Ng==", "bodyText": "we already have updateActiveFilter (main action that updates the active filter in the redux store with the newFiltersActive that we have set with the newFiltesActive value)", "url": "https://github.com/metasfresh/metasfresh/pull/9870#discussion_r498649356", "createdAt": "2020-10-02T07:09:55Z", "author": {"login": "petrican"}, "path": "frontend/src/components/filters/Filters.js", "diffHunk": "@@ -2,604 +2,131 @@ import counterpart from 'counterpart';\n import PropTypes from 'prop-types';\n import React, { PureComponent } from 'react';\n import { connect } from 'react-redux';\n-// -- using iMap from immutable\n-import { Map as iMap } from 'immutable';\n-import _ from 'lodash';\n-\n-import { DATE_FIELDS } from '../../constants/Constants';\n import {\n-  generateMomentObj,\n-  getFormatForDateField,\n-} from '../widget/RawWidgetHelpers';\n-import { parseDateWithCurrentTimezone } from '../../utils/documentListHelper';\n-import { fieldValueToString } from '../../utils/tableHelpers';\n+  updateWidgetShown,\n+  setNewFiltersActive,\n+  updateActiveFilter,\n+  clearAllFilters,\n+  annotateFilters,\n+  isFilterValid,\n+  updateNotValidFields,\n+  parseToPatch,\n+} from '../../actions/FiltersActions';\n+\n import FiltersFrequent from './FiltersFrequent';\n import FiltersNotFrequent from './FiltersNotFrequent';\n-\n-/**\n- * @method parseDateToReadable\n- * @summary ToDo: Describe the method\n- * @param {*} widgetType\n- * @param {*} value\n- * @todo Write the documentation\n- */\n-export function parseDateToReadable(widgetType, value) {\n-  if (DATE_FIELDS.indexOf(widgetType) > -1) {\n-    return parseDateWithCurrentTimezone(value, widgetType);\n-  }\n-  return value;\n-}\n+import deepUnfreeze from 'deep-unfreeze';\n+import { getEntityRelatedId } from '../../reducers/filters';\n \n /**\n  * @file Class based component.\n  * @module Filters\n- * @extends Component\n+ * @extends PureComponent\n  */\n class Filters extends PureComponent {\n-  state = {\n-    activeFilter: null,\n-    activeFiltersCaptions: null,\n-    flatFiltersMap: null,\n-    notValidFields: null,\n-    widgetShown: false,\n-  };\n-\n-  /**\n-   * @method UNSAFE_componentWillReceiveProps\n-   * @summary ToDo: Describe the method\n-   */\n-  UNSAFE_componentWillReceiveProps() {\n-    this.parseActiveFilters();\n-  }\n-\n-  /**\n-   * @method componentDidMount\n-   * @summary ToDo: Describe the method\n-   */\n-  componentDidMount() {\n-    this.parseActiveFilters();\n-  }\n-\n-  /**\n-   * @method arrangeFilters\n-   * @summary combines the filters and also removes the other actives ones from same group\n-   */\n-  arrangeFilters = (filterData) => {\n-    let combinedFilters = [];\n-    for (const [key] of filterData.entries()) {\n-      let item = filterData.get(key);\n-      if (typeof item.includedFilters !== 'undefined') {\n-        combinedFilters.push(...item.includedFilters);\n-      } else {\n-        combinedFilters.push(item);\n-      }\n-    }\n-    let mappedFiltersData = new Map();\n-    combinedFilters.forEach((item) => {\n-      mappedFiltersData.set(item.filterId, item);\n-    });\n-    return mappedFiltersData;\n-  };\n-\n-  // PARSING FILTERS ---------------------------------------------------------\n-\n-  /*\n-   * parseActiveFilters - this function does three things:\n-   *  - creates a flat map of existing filter fields to store the widgetType for\n-        further processing\n-   *  - creates a local copy of active filters object including filters that\n-   *    only have defaultValues set. `defaultVal` flag tells us, that this\n-   *    filter has only defaultValues, and no values set by the user. We need\n-   *    this to ble able to differentiate between filters that should be\n-   *    indicated as active on load, or not.\n-   *  - creates an object with captions of each active parameter per filter\n-   *\n-   * So first we traverse all filters data and perform actions in this order:\n-   *  - if filter is in active filters and parameter has no defaultValue,\n-   *    or defaultValue has been nullified by user's selection we add it\n-   *    local active filters and set the `defaultVal` flag to false\n-   *    (as it obviously was already set).\n-   *  - if filter is active check if current loop parameter is set in the\n-   *    active filters. If yes, do nothing as it'll always override the\n-   *    defaultValue\n-   *  - otherwise add parameter and filter to local active filters and set\n-   *    the `defaultVal` to true as apparently there are no values set  \n-   *  \n-   *    Update: 10 March 2020, removed the logic to set the default \n-   * \n-   */\n-  /**\n-   * @method parseActiveFilters\n-   * @summary ToDo: Describe the method\n-   */\n-  parseActiveFilters = () => {\n-    let { filtersActive, filterData, initialValuesNulled } = this.props;\n-    let activeFilters = _.cloneDeep(filtersActive);\n-\n-    // make new ES6 Map with the items from combined filters\n-    let mappedFiltersData = this.arrangeFilters(filterData);\n-    // put the resulted combined map of filters into the iMap and preserve existing functionality\n-    let filtersData = iMap(mappedFiltersData);\n-    const flatFiltersMap = {};\n-    const activeFiltersCaptions = {};\n-\n-    // find any filters with default values first and extend\n-    // activeFilters with them\n-    filtersData.forEach((filter, filterId) => {\n-      if (filter.parameters) {\n-        outerParameters: for (let parameter of filter.parameters) {\n-          const { defaultValue, parameterName, widgetType } = parameter;\n-          const nulledFilter = initialValuesNulled.get(filterId);\n-\n-          flatFiltersMap[`${filterId}-${parameterName}`] = {\n-            widgetType,\n-          };\n-\n-          const isActive = filtersActive.has(filterId);\n-\n-          if (\n-            !defaultValue ||\n-            (nulledFilter && nulledFilter.has(parameterName))\n-          ) {\n-            if (isActive) {\n-              activeFilters = activeFilters.set(filterId, {\n-                defaultVal: false,\n-                filterId,\n-                parameters: activeFilters.get(filterId).parameters,\n-              });\n-            }\n-            continue;\n-          }\n-\n-          if (isActive) {\n-            //look for existing parameterName in parameters array\n-            // skip if found as they override defaultValue ALWAYS\n-            const filterActive = activeFilters.get(filterId);\n-\n-            if (filterActive.parameters) {\n-              for (let activeParameter of filterActive.parameters) {\n-                if (activeParameter.parameterName === parameterName) {\n-                  continue outerParameters;\n-                }\n-              }\n-            }\n-          }\n-        }\n-      }\n-    });\n-\n-    if (activeFilters.size) {\n-      const removeDefault = {};\n-\n-      activeFilters.forEach((filter, filterId) => {\n-        let captionsArray = ['', ''];\n-\n-        if (filter.parameters && filter.parameters.length) {\n-          filter.parameters.forEach((filterParameter) => {\n-            const { value, parameterName, defaultValue } = filterParameter;\n-\n-            if (!defaultValue) {\n-              // we don't want to show captions, nor show filter button as active\n-              // for default values\n-              removeDefault[filterId] = true;\n-\n-              const parentFilter = filtersData.get(filterId);\n-              const filterParameter = parentFilter.parameters.find(\n-                (param) => param.parameterName === parameterName\n-              );\n-              let captionName = filterParameter.caption;\n-              let itemCaption = filterParameter.caption;\n-\n-              switch (filterParameter.widgetType) {\n-                case 'Text':\n-                  captionName = value;\n-\n-                  if (!value) {\n-                    captionName = '';\n-                    itemCaption = '';\n-                  }\n-                  break;\n-                case 'Lookup':\n-                case 'List':\n-                  captionName = value && value.caption;\n-                  break;\n-                case 'Labels':\n-                  captionName = value.values.reduce((caption, item) => {\n-                    return `${caption}, ${item.caption}`;\n-                  }, '');\n-                  break;\n-                case 'YesNo':\n-                  if (value === null) {\n-                    captionName = '';\n-                    itemCaption = '';\n-                  }\n-                  break;\n-                case 'Switch':\n-                default:\n-                  if (!value) {\n-                    captionName = '';\n-                    itemCaption = '';\n-                  }\n-                  break;\n-              }\n-\n-              if (captionName) {\n-                captionsArray[0] = captionsArray[0]\n-                  ? `${captionsArray[0]}, ${captionName}`\n-                  : captionName;\n-              }\n-\n-              if (itemCaption) {\n-                captionsArray[1] = captionsArray[1]\n-                  ? `${captionsArray[1]}, ${itemCaption}`\n-                  : itemCaption;\n-              }\n-            }\n-          });\n-        } else {\n-          const originalFilter = filtersData.get(filterId);\n-          captionsArray = [originalFilter.caption, originalFilter.caption];\n-        }\n-\n-        if (captionsArray.join('').length) {\n-          activeFiltersCaptions[filterId] = captionsArray;\n-        }\n-      });\n-\n-      // if filter has defaultValues but also some user defined ones,\n-      // we should still include it in active filters\n-      if (Object.keys(removeDefault).length) {\n-        for (let key of Object.keys(removeDefault)) {\n-          activeFilters = activeFilters.setIn([key, 'defaultVal'], false);\n-        }\n-      }\n-\n-      const cleanActiveFilter = this.cleanupActiveFilter(\n-        filterData.toIndexedSeq().toArray(),\n-        activeFilters.toIndexedSeq().toArray()\n-      );\n-\n-      this.setState({\n-        activeFilter: cleanActiveFilter,\n-        activeFiltersCaptions,\n-        flatFiltersMap,\n-      });\n-    } else {\n-      this.setState({\n-        activeFilter: null,\n-        activeFiltersCaptions: null,\n-        flatFiltersMap,\n-      });\n-    }\n-  };\n-\n-  cleanupActiveFilter = (allFilters, activeStateFilters) => {\n-    let filtersToRemove = [];\n-    activeStateFilters.forEach((activeStateFilter) => {\n-      allFilters.forEach((filterItem) => {\n-        if (Array.isArray(filterItem.includedFilters)) {\n-          let groupFilter = filterItem.includedFilters;\n-          let foundMatches = groupFilter.filter(\n-            (gFilterItem) => gFilterItem.filterId === activeStateFilter.filterId\n-          );\n-          if (foundMatches.length > 0) {\n-            filtersToRemove = groupFilter.filter(\n-              (toRemove) => toRemove.filterId !== activeStateFilter.filterId\n-            );\n-          }\n-        }\n-      });\n-    });\n-    return activeStateFilters.filter(\n-      (asFilterItem) =>\n-        !this.isBlacklisted(asFilterItem.filterId, filtersToRemove)\n-    );\n-  };\n-\n-  /**\n-   * @method isBlackListed\n-   * @summary Check if the filterId is found among the filters to remove array\n-   * @param {string filterId\n-   * @param {array} filtersToRemove\n-   */\n-  isBlacklisted = (filterId, filtersToRemove) => {\n-    let resultValue = false;\n-    filtersToRemove.forEach((filterItem) => {\n-      if (filterItem.filterId === filterId) {\n-        resultValue = true;\n-      }\n-    });\n-    return resultValue;\n-  };\n-\n-  /**\n-   * @method sortFilters\n-   * @summary ToDo: Describe the method\n-   * @param {array} data\n-   */\n-  sortFilters = (data) => {\n-    return {\n-      frequentFilters: this.annotateFilters(\n-        data\n-          .filter((filter) => filter.frequent)\n-          .toIndexedSeq()\n-          .toArray()\n-      ),\n-      notFrequentFilters: this.annotateFilters(\n-        data\n-          .filter((filter) => !filter.frequent && !filter.static)\n-          .toIndexedSeq()\n-          .toArray()\n-      ),\n-      staticFilters: this.annotateFilters(\n-        data.filter((filter) => filter.static)\n-      )\n-        .toIndexedSeq()\n-        .toArray(),\n-    };\n-  };\n-\n-  /**\n-   * @method isFilterValid\n-   * @summary ToDo: Describe the method\n-   * @param {*} filters\n-   */\n-  isFilterValid = (filters) => {\n-    if (filters.parameters) {\n-      return !filters.parameters.filter((item) => item.mandatory && !item.value)\n-        .length;\n-    }\n-\n-    return true;\n-  };\n-\n-  /**\n-   * @method isFilterActive\n-   * @summary ToDo: Describe the method\n-   * @param {*} filterId\n-   */\n-  isFilterActive = (filterId) => {\n-    const { activeFilter } = this.state;\n-\n-    if (activeFilter) {\n-      // filters with only defaultValues shouldn't be set to active\n-      const active = activeFilter.find(\n-        (item) => item.filterId === filterId && !item.defaultVal\n-      );\n-\n-      return typeof active !== 'undefined';\n-    }\n-\n-    return false;\n-  };\n-\n-  /**\n-   * @method parseToPatch\n-   * @summary ToDo: Describe the method\n-   * @param {*} params\n-   */\n-  parseToPatch = (params) => {\n-    return params.reduce((acc, param) => {\n-      if (\n-        // filters with only defaltValue shouldn't be sent to server\n-        !param.defaultValue ||\n-        JSON.stringify(param.defaultValue) !== JSON.stringify(param.value)\n-      ) {\n-        acc.push({\n-          ...param,\n-          value: param.value === '' ? null : param.value,\n-        });\n-      }\n-\n-      return acc;\n-    }, []);\n-  };\n-\n-  // SETTING FILTERS  --------------------------------------------------------\n   /**\n    * @method applyFilters\n    * @summary This method should update docList\n-   * @param {*} isActive\n-   * @param {*} captionValue\n    * @param {object} filter\n-   * @param {*} cb\n-   */\n-  // eslint-disable-next-line no-unused-vars\n-  applyFilters = ({ isActive, captionValue, ...filter }, cb) => {\n-    const valid = this.isFilterValid(filter);\n-\n-    this.setState(\n-      {\n-        notValidFields: !valid,\n-      },\n-      () => {\n-        if (valid) {\n-          const parsedFilter = filter.parameters\n-            ? {\n-                ...filter,\n-                parameters: this.parseToPatch(filter.parameters),\n-              }\n-            : filter;\n+   * @param {function} cb - executed if filter is valid and after it was applied\n+   */\n+  applyFilters = ({ ...filter }, cb) => {\n+    const valid = isFilterValid(filter);\n+    const { updateNotValidFields, filterId } = this.props;\n+\n+    updateNotValidFields({ filterId, data: !valid });\n+    if (valid) {\n+      const parsedFilter = filter.parameters\n+        ? {\n+            ...filter,\n+            parameters: parseToPatch(filter.parameters),\n+          }\n+        : filter;\n \n-          this.setFilterActive(parsedFilter);\n+      this.setFilterActive(parsedFilter);\n \n-          cb && cb();\n-        }\n-      }\n-    );\n+      cb && cb();\n+    }\n   };\n \n   /**\n    * @method setFilterActive\n-   * @summary This function merges new filters that are to be activated with the existing\n-   *  active filters. Additionally we format date fields accordingly so that the backend\n-   *  accepts them.\n+   * @summary This function updates the active filters we set and then triggers the pre-existing\n+   *          logic from DocList that will fetch the filtered data\n    * @param {object} filterToAdd\n    */\n   setFilterActive = (filterToAdd) => {\n-    const { updateDocList } = this.props;\n-    let { filtersActive } = this.props;\n-    const { flatFiltersMap } = this.state;\n-    let activeFilters = iMap(filtersActive);\n-\n-    activeFilters = activeFilters.filter(\n-      (item, id) => id !== filterToAdd.filterId\n-    );\n-    activeFilters = activeFilters.set(filterToAdd.filterId, filterToAdd);\n-\n-    if (flatFiltersMap) {\n-      activeFilters = activeFilters.map((filter, filterId) => {\n-        filter.parameters &&\n-          filter.parameters.forEach((parameter) => {\n-            const { value, valueTo, parameterName } = parameter;\n-            const singleFilter = flatFiltersMap[`${filterId}-${parameterName}`];\n-\n-            if (\n-              singleFilter &&\n-              DATE_FIELDS.indexOf(singleFilter.widgetType) > -1\n-            ) {\n-              const format = getFormatForDateField(singleFilter.widgetType);\n-\n-              if (value) {\n-                parameter.value = generateMomentObj(value, format);\n-              }\n-              if (valueTo) {\n-                parameter.valueTo = generateMomentObj(valueTo, format);\n-              }\n-            }\n-          });\n+    const { updateDocList, filterId, updateActiveFilter } = this.props;\n+    const { filtersActive: storeActiveFilters } = this.props.filters;\n \n-        return filter;\n-      });\n-    }\n+    // updating the active filters from the redux store with the filter passed as param\n+    const newFiltersActive = setNewFiltersActive({", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMyMzU2OQ=="}, "originalCommit": {"oid": "aca6e4a591072da112d61083ebccc3a36f0e0724"}, "originalPosition": 509}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExOTc4MjU0OnYy", "diffSide": "LEFT", "path": "frontend/src/components/filters/Filters.js", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNToyMjo1MlrOHbPnRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQwNjozMDoxMlrOHbiYFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMyOTQxNQ==", "bodyText": "Why remove the proptypes comments ?", "url": "https://github.com/metasfresh/metasfresh/pull/9870#discussion_r498329415", "createdAt": "2020-10-01T15:22:52Z", "author": {"login": "siemiatj"}, "path": "frontend/src/components/filters/Filters.js", "diffHunk": "@@ -678,37 +206,43 @@ class Filters extends PureComponent {\n   }\n }\n \n-/**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aca6e4a591072da112d61083ebccc3a36f0e0724"}, "originalPosition": 701}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODYzNjgyMA==", "bodyText": "I believe those are kind of redundant since Proptypes itself is pretty much self-explanatory for every field since you have the type. If you have 20 params there will be extra 20 lines. If for some special param like an object you want to add details you can put comment but if you just put @param {object} someObject then I believe is redundant.. since someObject: Proptype.object, is obvious what it is.", "url": "https://github.com/metasfresh/metasfresh/pull/9870#discussion_r498636820", "createdAt": "2020-10-02T06:30:12Z", "author": {"login": "petrican"}, "path": "frontend/src/components/filters/Filters.js", "diffHunk": "@@ -678,37 +206,43 @@ class Filters extends PureComponent {\n   }\n }\n \n-/**", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMyOTQxNQ=="}, "originalCommit": {"oid": "aca6e4a591072da112d61083ebccc3a36f0e0724"}, "originalPosition": 701}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExOTc4OTk2OnYy", "diffSide": "RIGHT", "path": "frontend/src/components/filters/FiltersFrequent.js", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNToyNDozNVrOHbPsCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQwNzoxMjo0MFrOHbjNHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMzMDYzMg==", "bodyText": "Why not move logic from outsideClick here and remove it completely ?", "url": "https://github.com/metasfresh/metasfresh/pull/9870#discussion_r498330632", "createdAt": "2020-10-01T15:24:35Z", "author": {"login": "siemiatj"}, "path": "frontend/src/components/filters/FiltersFrequent.js", "diffHunk": "@@ -57,9 +50,7 @@ class FiltersFrequent extends PureComponent {\n    * @summary ToDo: Describe the method\n    * @todo Write the documentation\n    */\n-  handleClickOutside = () => {\n-    this.outsideClick();\n-  };\n+  handleClickOutside = () => this.outsideClick();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aca6e4a591072da112d61083ebccc3a36f0e0724"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODY1MDM5Ng==", "bodyText": "Good point. I'll consider it. Thanks!", "url": "https://github.com/metasfresh/metasfresh/pull/9870#discussion_r498650396", "createdAt": "2020-10-02T07:12:40Z", "author": {"login": "petrican"}, "path": "frontend/src/components/filters/FiltersFrequent.js", "diffHunk": "@@ -57,9 +50,7 @@ class FiltersFrequent extends PureComponent {\n    * @summary ToDo: Describe the method\n    * @todo Write the documentation\n    */\n-  handleClickOutside = () => {\n-    this.outsideClick();\n-  };\n+  handleClickOutside = () => this.outsideClick();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMzMDYzMg=="}, "originalCommit": {"oid": "aca6e4a591072da112d61083ebccc3a36f0e0724"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExOTgwMTk4OnYy", "diffSide": "RIGHT", "path": "frontend/src/containers/DocumentList.js", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNToyNzowM1rOHbPzdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQwNjozMzo1OFrOHbicIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMzMjUzNQ==", "bodyText": "?", "url": "https://github.com/metasfresh/metasfresh/pull/9870#discussion_r498332535", "createdAt": "2020-10-01T15:27:03Z", "author": {"login": "siemiatj"}, "path": "frontend/src/containers/DocumentList.js", "diffHunk": "@@ -1,3 +1,4 @@\n+/* eslint-disable prettier/prettier */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aca6e4a591072da112d61083ebccc3a36f0e0724"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODYzNzg1Ng==", "bodyText": "Pfff. This must have been added somehow automatically by the editor. Thanks. Removed", "url": "https://github.com/metasfresh/metasfresh/pull/9870#discussion_r498637856", "createdAt": "2020-10-02T06:33:58Z", "author": {"login": "petrican"}, "path": "frontend/src/containers/DocumentList.js", "diffHunk": "@@ -1,3 +1,4 @@\n+/* eslint-disable prettier/prettier */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMzMjUzNQ=="}, "originalCommit": {"oid": "aca6e4a591072da112d61083ebccc3a36f0e0724"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzMjUwMTI5OnYy", "diffSide": "RIGHT", "path": "frontend/src/__tests__/components/filters/Filters.test.js", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxMzo0NToyOVrOHdHXFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxMzo1MToyMVrOHdHtMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDI5MTM1MA==", "bodyText": "tree ? :)", "url": "https://github.com/metasfresh/metasfresh/pull/9870#discussion_r500291350", "createdAt": "2020-10-06T13:45:29Z", "author": {"login": "siemiatj"}, "path": "frontend/src/__tests__/components/filters/Filters.test.js", "diffHunk": "@@ -269,6 +266,7 @@ describe('Filters tests', () => {\n             visible: false,\n           },\n         },\n+        filters: filtersStoreThree,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ce95b512092885868ff785d02b76a4bf90452e5"}, "originalPosition": 215}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDI5NzAwOQ==", "bodyText": "No no. It's the no of the filtersStore snapshot. Used diff snapshots and named them One, Two, Three", "url": "https://github.com/metasfresh/metasfresh/pull/9870#discussion_r500297009", "createdAt": "2020-10-06T13:51:21Z", "author": {"login": "petrican"}, "path": "frontend/src/__tests__/components/filters/Filters.test.js", "diffHunk": "@@ -269,6 +266,7 @@ describe('Filters tests', () => {\n             visible: false,\n           },\n         },\n+        filters: filtersStoreThree,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDI5MTM1MA=="}, "originalCommit": {"oid": "0ce95b512092885868ff785d02b76a4bf90452e5"}, "originalPosition": 215}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzMjczMTM2OnYy", "diffSide": "RIGHT", "path": "frontend/src/components/filters/Filters.js", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxNDoyMzowOFrOHdJlgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwOToxNToyN1rOHdqHTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDMyNzgwOA==", "bodyText": "Why can't this be handled by redux but instead we'll be calling this on each render and create a new js object ? Seems like we have everything we need in the filters prop.", "url": "https://github.com/metasfresh/metasfresh/pull/9870#discussion_r500327808", "createdAt": "2020-10-06T14:23:08Z", "author": {"login": "siemiatj"}, "path": "frontend/src/components/filters/Filters.js", "diffHunk": "@@ -2,604 +2,133 @@ import counterpart from 'counterpart';\n import PropTypes from 'prop-types';\n import React, { PureComponent } from 'react';\n import { connect } from 'react-redux';\n-// -- using iMap from immutable\n-import { Map as iMap } from 'immutable';\n-import _ from 'lodash';\n-\n-import { DATE_FIELDS } from '../../constants/Constants';\n import {\n-  generateMomentObj,\n-  getFormatForDateField,\n-} from '../widget/RawWidgetHelpers';\n-import { parseDateWithCurrentTimezone } from '../../utils/documentListHelper';\n-import { fieldValueToString } from '../../utils/tableHelpers';\n-import FiltersFrequent from './FiltersFrequent';\n-import FiltersNotFrequent from './FiltersNotFrequent';\n-\n-/**\n- * @method parseDateToReadable\n- * @summary ToDo: Describe the method\n- * @param {*} widgetType\n- * @param {*} value\n- * @todo Write the documentation\n- */\n-export function parseDateToReadable(widgetType, value) {\n-  if (DATE_FIELDS.indexOf(widgetType) > -1) {\n-    return parseDateWithCurrentTimezone(value, widgetType);\n-  }\n-  return value;\n-}\n+  updateFilterWidgetShown,\n+  setNewFiltersActive,\n+  updateActiveFilter,\n+  clearAllFilters,\n+  annotateFilters,\n+  isFilterValid,\n+  updateNotValidFields,\n+  parseToPatch,\n+} from '../../actions/FiltersActions';\n+\n+import FiltersNotIcluded from './FiltersNotIncluded';\n+import FiltersIncluded from './FiltersIncluded';\n+import deepUnfreeze from 'deep-unfreeze';\n+import { getEntityRelatedId } from '../../reducers/filters';\n \n /**\n  * @file Class based component.\n  * @module Filters\n- * @extends Component\n+ * @extends PureComponent\n  */\n class Filters extends PureComponent {\n-  state = {\n-    activeFilter: null,\n-    activeFiltersCaptions: null,\n-    flatFiltersMap: null,\n-    notValidFields: null,\n-    widgetShown: false,\n-  };\n-\n-  /**\n-   * @method UNSAFE_componentWillReceiveProps\n-   * @summary ToDo: Describe the method\n-   */\n-  UNSAFE_componentWillReceiveProps() {\n-    this.parseActiveFilters();\n-  }\n-\n-  /**\n-   * @method componentDidMount\n-   * @summary ToDo: Describe the method\n-   */\n-  componentDidMount() {\n-    this.parseActiveFilters();\n-  }\n-\n-  /**\n-   * @method arrangeFilters\n-   * @summary combines the filters and also removes the other actives ones from same group\n-   */\n-  arrangeFilters = (filterData) => {\n-    let combinedFilters = [];\n-    for (const [key] of filterData.entries()) {\n-      let item = filterData.get(key);\n-      if (typeof item.includedFilters !== 'undefined') {\n-        combinedFilters.push(...item.includedFilters);\n-      } else {\n-        combinedFilters.push(item);\n-      }\n-    }\n-    let mappedFiltersData = new Map();\n-    combinedFilters.forEach((item) => {\n-      mappedFiltersData.set(item.filterId, item);\n-    });\n-    return mappedFiltersData;\n-  };\n-\n-  // PARSING FILTERS ---------------------------------------------------------\n-\n-  /*\n-   * parseActiveFilters - this function does three things:\n-   *  - creates a flat map of existing filter fields to store the widgetType for\n-        further processing\n-   *  - creates a local copy of active filters object including filters that\n-   *    only have defaultValues set. `defaultVal` flag tells us, that this\n-   *    filter has only defaultValues, and no values set by the user. We need\n-   *    this to ble able to differentiate between filters that should be\n-   *    indicated as active on load, or not.\n-   *  - creates an object with captions of each active parameter per filter\n-   *\n-   * So first we traverse all filters data and perform actions in this order:\n-   *  - if filter is in active filters and parameter has no defaultValue,\n-   *    or defaultValue has been nullified by user's selection we add it\n-   *    local active filters and set the `defaultVal` flag to false\n-   *    (as it obviously was already set).\n-   *  - if filter is active check if current loop parameter is set in the\n-   *    active filters. If yes, do nothing as it'll always override the\n-   *    defaultValue\n-   *  - otherwise add parameter and filter to local active filters and set\n-   *    the `defaultVal` to true as apparently there are no values set  \n-   *  \n-   *    Update: 10 March 2020, removed the logic to set the default \n-   * \n-   */\n-  /**\n-   * @method parseActiveFilters\n-   * @summary ToDo: Describe the method\n-   */\n-  parseActiveFilters = () => {\n-    let { filtersActive, filterData, initialValuesNulled } = this.props;\n-    let activeFilters = _.cloneDeep(filtersActive);\n-\n-    // make new ES6 Map with the items from combined filters\n-    let mappedFiltersData = this.arrangeFilters(filterData);\n-    // put the resulted combined map of filters into the iMap and preserve existing functionality\n-    let filtersData = iMap(mappedFiltersData);\n-    const flatFiltersMap = {};\n-    const activeFiltersCaptions = {};\n-\n-    // find any filters with default values first and extend\n-    // activeFilters with them\n-    filtersData.forEach((filter, filterId) => {\n-      if (filter.parameters) {\n-        outerParameters: for (let parameter of filter.parameters) {\n-          const { defaultValue, parameterName, widgetType } = parameter;\n-          const nulledFilter = initialValuesNulled.get(filterId);\n-\n-          flatFiltersMap[`${filterId}-${parameterName}`] = {\n-            widgetType,\n-          };\n-\n-          const isActive = filtersActive.has(filterId);\n-\n-          if (\n-            !defaultValue ||\n-            (nulledFilter && nulledFilter.has(parameterName))\n-          ) {\n-            if (isActive) {\n-              activeFilters = activeFilters.set(filterId, {\n-                defaultVal: false,\n-                filterId,\n-                parameters: activeFilters.get(filterId).parameters,\n-              });\n-            }\n-            continue;\n-          }\n-\n-          if (isActive) {\n-            //look for existing parameterName in parameters array\n-            // skip if found as they override defaultValue ALWAYS\n-            const filterActive = activeFilters.get(filterId);\n-\n-            if (filterActive.parameters) {\n-              for (let activeParameter of filterActive.parameters) {\n-                if (activeParameter.parameterName === parameterName) {\n-                  continue outerParameters;\n-                }\n-              }\n-            }\n-          }\n-        }\n-      }\n-    });\n-\n-    if (activeFilters.size) {\n-      const removeDefault = {};\n-\n-      activeFilters.forEach((filter, filterId) => {\n-        let captionsArray = ['', ''];\n-\n-        if (filter.parameters && filter.parameters.length) {\n-          filter.parameters.forEach((filterParameter) => {\n-            const { value, parameterName, defaultValue } = filterParameter;\n-\n-            if (!defaultValue) {\n-              // we don't want to show captions, nor show filter button as active\n-              // for default values\n-              removeDefault[filterId] = true;\n-\n-              const parentFilter = filtersData.get(filterId);\n-              const filterParameter = parentFilter.parameters.find(\n-                (param) => param.parameterName === parameterName\n-              );\n-              let captionName = filterParameter.caption;\n-              let itemCaption = filterParameter.caption;\n-\n-              switch (filterParameter.widgetType) {\n-                case 'Text':\n-                  captionName = value;\n-\n-                  if (!value) {\n-                    captionName = '';\n-                    itemCaption = '';\n-                  }\n-                  break;\n-                case 'Lookup':\n-                case 'List':\n-                  captionName = value && value.caption;\n-                  break;\n-                case 'Labels':\n-                  captionName = value.values.reduce((caption, item) => {\n-                    return `${caption}, ${item.caption}`;\n-                  }, '');\n-                  break;\n-                case 'YesNo':\n-                  if (value === null) {\n-                    captionName = '';\n-                    itemCaption = '';\n-                  }\n-                  break;\n-                case 'Switch':\n-                default:\n-                  if (!value) {\n-                    captionName = '';\n-                    itemCaption = '';\n-                  }\n-                  break;\n-              }\n-\n-              if (captionName) {\n-                captionsArray[0] = captionsArray[0]\n-                  ? `${captionsArray[0]}, ${captionName}`\n-                  : captionName;\n-              }\n-\n-              if (itemCaption) {\n-                captionsArray[1] = captionsArray[1]\n-                  ? `${captionsArray[1]}, ${itemCaption}`\n-                  : itemCaption;\n-              }\n-            }\n-          });\n-        } else {\n-          const originalFilter = filtersData.get(filterId);\n-          captionsArray = [originalFilter.caption, originalFilter.caption];\n-        }\n-\n-        if (captionsArray.join('').length) {\n-          activeFiltersCaptions[filterId] = captionsArray;\n-        }\n-      });\n-\n-      // if filter has defaultValues but also some user defined ones,\n-      // we should still include it in active filters\n-      if (Object.keys(removeDefault).length) {\n-        for (let key of Object.keys(removeDefault)) {\n-          activeFilters = activeFilters.setIn([key, 'defaultVal'], false);\n-        }\n-      }\n-\n-      const cleanActiveFilter = this.cleanupActiveFilter(\n-        filterData.toIndexedSeq().toArray(),\n-        activeFilters.toIndexedSeq().toArray()\n-      );\n-\n-      this.setState({\n-        activeFilter: cleanActiveFilter,\n-        activeFiltersCaptions,\n-        flatFiltersMap,\n-      });\n-    } else {\n-      this.setState({\n-        activeFilter: null,\n-        activeFiltersCaptions: null,\n-        flatFiltersMap,\n-      });\n-    }\n-  };\n-\n-  cleanupActiveFilter = (allFilters, activeStateFilters) => {\n-    let filtersToRemove = [];\n-    activeStateFilters.forEach((activeStateFilter) => {\n-      allFilters.forEach((filterItem) => {\n-        if (Array.isArray(filterItem.includedFilters)) {\n-          let groupFilter = filterItem.includedFilters;\n-          let foundMatches = groupFilter.filter(\n-            (gFilterItem) => gFilterItem.filterId === activeStateFilter.filterId\n-          );\n-          if (foundMatches.length > 0) {\n-            filtersToRemove = groupFilter.filter(\n-              (toRemove) => toRemove.filterId !== activeStateFilter.filterId\n-            );\n-          }\n-        }\n-      });\n-    });\n-    return activeStateFilters.filter(\n-      (asFilterItem) =>\n-        !this.isBlacklisted(asFilterItem.filterId, filtersToRemove)\n-    );\n-  };\n-\n-  /**\n-   * @method isBlackListed\n-   * @summary Check if the filterId is found among the filters to remove array\n-   * @param {string filterId\n-   * @param {array} filtersToRemove\n-   */\n-  isBlacklisted = (filterId, filtersToRemove) => {\n-    let resultValue = false;\n-    filtersToRemove.forEach((filterItem) => {\n-      if (filterItem.filterId === filterId) {\n-        resultValue = true;\n-      }\n-    });\n-    return resultValue;\n-  };\n-\n-  /**\n-   * @method sortFilters\n-   * @summary ToDo: Describe the method\n-   * @param {array} data\n-   */\n-  sortFilters = (data) => {\n-    return {\n-      frequentFilters: this.annotateFilters(\n-        data\n-          .filter((filter) => filter.frequent)\n-          .toIndexedSeq()\n-          .toArray()\n-      ),\n-      notFrequentFilters: this.annotateFilters(\n-        data\n-          .filter((filter) => !filter.frequent && !filter.static)\n-          .toIndexedSeq()\n-          .toArray()\n-      ),\n-      staticFilters: this.annotateFilters(\n-        data.filter((filter) => filter.static)\n-      )\n-        .toIndexedSeq()\n-        .toArray(),\n-    };\n-  };\n-\n-  /**\n-   * @method isFilterValid\n-   * @summary ToDo: Describe the method\n-   * @param {*} filters\n-   */\n-  isFilterValid = (filters) => {\n-    if (filters.parameters) {\n-      return !filters.parameters.filter((item) => item.mandatory && !item.value)\n-        .length;\n-    }\n-\n-    return true;\n-  };\n-\n-  /**\n-   * @method isFilterActive\n-   * @summary ToDo: Describe the method\n-   * @param {*} filterId\n-   */\n-  isFilterActive = (filterId) => {\n-    const { activeFilter } = this.state;\n-\n-    if (activeFilter) {\n-      // filters with only defaultValues shouldn't be set to active\n-      const active = activeFilter.find(\n-        (item) => item.filterId === filterId && !item.defaultVal\n-      );\n-\n-      return typeof active !== 'undefined';\n-    }\n-\n-    return false;\n-  };\n-\n-  /**\n-   * @method parseToPatch\n-   * @summary ToDo: Describe the method\n-   * @param {*} params\n-   */\n-  parseToPatch = (params) => {\n-    return params.reduce((acc, param) => {\n-      if (\n-        // filters with only defaltValue shouldn't be sent to server\n-        !param.defaultValue ||\n-        JSON.stringify(param.defaultValue) !== JSON.stringify(param.value)\n-      ) {\n-        acc.push({\n-          ...param,\n-          value: param.value === '' ? null : param.value,\n-        });\n-      }\n-\n-      return acc;\n-    }, []);\n-  };\n-\n-  // SETTING FILTERS  --------------------------------------------------------\n   /**\n    * @method applyFilters\n-   * @summary This method should update docList\n-   * @param {*} isActive\n-   * @param {*} captionValue\n+   * @summary This method should update filters in the store and DL reacts automatically to the changes\n    * @param {object} filter\n-   * @param {*} cb\n-   */\n-  // eslint-disable-next-line no-unused-vars\n-  applyFilters = ({ isActive, captionValue, ...filter }, cb) => {\n-    const valid = this.isFilterValid(filter);\n-\n-    this.setState(\n-      {\n-        notValidFields: !valid,\n-      },\n-      () => {\n-        if (valid) {\n-          const parsedFilter = filter.parameters\n-            ? {\n-                ...filter,\n-                parameters: this.parseToPatch(filter.parameters),\n-              }\n-            : filter;\n+   * @param {function} cb - executed if filter is valid and after it was applied\n+   */\n+  applyFilters = ({ ...filter }, cb) => {\n+    const valid = isFilterValid(filter);\n+    const { updateNotValidFields, filterId } = this.props;\n+\n+    updateNotValidFields({ filterId, data: !valid });\n+    if (valid) {\n+      const parsedFilter = filter.parameters\n+        ? {\n+            ...filter,\n+            parameters: parseToPatch(filter.parameters),\n+          }\n+        : filter;\n \n-          this.setFilterActive(parsedFilter);\n+      this.setFilterActive(parsedFilter);\n \n-          cb && cb();\n-        }\n-      }\n-    );\n+      cb && cb();\n+    }\n   };\n \n   /**\n    * @method setFilterActive\n-   * @summary This function merges new filters that are to be activated with the existing\n-   *  active filters. Additionally we format date fields accordingly so that the backend\n-   *  accepts them.\n+   * @summary This function updates the active filters we set and then triggers the pre-existing\n+   *          logic from DocList that will fetch the filtered data\n    * @param {object} filterToAdd\n    */\n   setFilterActive = (filterToAdd) => {\n-    const { updateDocList } = this.props;\n-    let { filtersActive } = this.props;\n-    const { flatFiltersMap } = this.state;\n-    let activeFilters = iMap(filtersActive);\n-\n-    activeFilters = activeFilters.filter(\n-      (item, id) => id !== filterToAdd.filterId\n-    );\n-    activeFilters = activeFilters.set(filterToAdd.filterId, filterToAdd);\n+    const { updateDocList, filterId, updateActiveFilter } = this.props;\n+    const { filtersActive: storeActiveFilters } = this.props.filters;\n \n-    if (flatFiltersMap) {\n-      activeFilters = activeFilters.map((filter, filterId) => {\n-        filter.parameters &&\n-          filter.parameters.forEach((parameter) => {\n-            const { value, valueTo, parameterName } = parameter;\n-            const singleFilter = flatFiltersMap[`${filterId}-${parameterName}`];\n-\n-            if (\n-              singleFilter &&\n-              DATE_FIELDS.indexOf(singleFilter.widgetType) > -1\n-            ) {\n-              const format = getFormatForDateField(singleFilter.widgetType);\n-\n-              if (value) {\n-                parameter.value = generateMomentObj(value, format);\n-              }\n-              if (valueTo) {\n-                parameter.valueTo = generateMomentObj(valueTo, format);\n-              }\n-            }\n-          });\n-\n-        return filter;\n-      });\n-    }\n+    // updating the active filters from the redux store with the filter passed as param\n+    const newFiltersActive = setNewFiltersActive({\n+      storeActiveFilters,\n+      filterToAdd,\n+    });\n \n-    updateDocList(activeFilters);\n+    updateActiveFilter({ id: filterId, data: newFiltersActive }); // update in the store the filters\n+    updateDocList(newFiltersActive); // move on and update the page with the new filters via DocList\n   };\n \n   /**\n    * @method handleShow\n    * @summary Method to lock backdrop, to do not close on click onClickOutside\n-   *  widgets that are bigger than filter wrapper\n+   *          widgets that are bigger than filter wrapper\n    * @param {*} value\n    */\n   handleShow = (value) => {\n-    this.setState({\n-      widgetShown: value,\n-    });\n+    const { filterId, updateFilterWidgetShown } = this.props;\n+    updateFilterWidgetShown({ id: filterId, data: value });\n   };\n \n   /**\n    * @method clearFilters\n-   * @summary ToDo: Describe the method\n-   * @param {*} filterToClear\n+   * @summary Clears all the filters for a specified filter group\n+   * @param {object} filterToClear - object containing the filters\n    */\n-  clearFilters = (filterToClear, propertyName) => {\n-    const { updateDocList } = this.props;\n-    let { filtersActive } = this.props;\n-    let activeFilters = iMap(filtersActive);\n-\n-    if (filtersActive.size) {\n-      activeFilters = activeFilters.filter((item, id) => {\n-        if (id === filterToClear.filterId) {\n-          if (propertyName && item.parameters && item.parameters.length) {\n-            const parametersCopy = item.parameters.filter(\n-              (param) => param.parameterName !== propertyName\n-            );\n-\n-            if (parametersCopy.length > 0) {\n-              item.parameters = parametersCopy;\n-\n-              return item;\n-            }\n-            return false;\n-          }\n-          return false;\n-        }\n-        return item;\n-      });\n-      updateDocList(activeFilters);\n-    }\n+  clearFilters = (filterToClear) => {\n+    const { filterId, clearAllFilters, filters, updateDocList } = this.props;\n+    clearAllFilters({ id: filterId, data: filterToClear });\n+    // fetch again the doc content after filters were updated into the store\n+    updateDocList(filters.filtersActive);\n   };\n \n   /**\n    * @method dropdownToggled\n-   * @summary ToDo: Describe the method\n+   * @summary Resets notValidFields flag to false\n    */\n   dropdownToggled = () => {\n-    this.setState({\n-      notValidFields: false,\n-    });\n-  };\n-\n-  /**\n-   * @method annotateFilters\n-   * @summary I think it creates caption for active filters to show when the widget is closed - Kuba\n-   * @param {array} unannotatedFilters\n-   */\n-  annotateFilters = (unannotatedFilters) => {\n-    const { activeFilter } = this.state;\n-\n-    return unannotatedFilters.map((unannotatedFilter) => {\n-      const parameter =\n-        unannotatedFilter.parameters && unannotatedFilter.parameters[0];\n-      const isActive = this.isFilterActive(unannotatedFilter.filterId);\n-      const currentFilter = activeFilter\n-        ? activeFilter.find((f) => f.filterId === unannotatedFilter.filterId)\n-        : null;\n-      const activeParameter =\n-        parameter && isActive && currentFilter && currentFilter.parameters[0];\n-\n-      const filterType =\n-        unannotatedFilter.parameters && activeParameter\n-          ? unannotatedFilter.parameters.find(\n-              (filter) => filter.parameterName === activeParameter.parameterName\n-            )\n-          : parameter && parameter.widgetType;\n-\n-      const captionValue = activeParameter\n-        ? fieldValueToString({\n-            fieldValue: activeParameter.valueTo\n-              ? [activeParameter.value, activeParameter.valueTo]\n-              : activeParameter.value,\n-            fieldType: filterType,\n-          })\n-        : '';\n-\n-      return {\n-        ...unannotatedFilter,\n-        captionValue,\n-        isActive,\n-      };\n-    });\n+    const { updateNotValidFields, filterId } = this.props;\n+    updateNotValidFields({ filterId, data: false });\n   };\n \n-  // RENDERING FILTERS -------------------------------------------------------\n   /**\n    * @method render\n-   * @summary ToDo: Describe the method\n+   * @summary Main render function - renders the filters\n    */\n   render() {\n     const {\n-      filterData,\n       windowType,\n       viewId,\n       resetInitialValues,\n       allowOutsideClick,\n       modalVisible,\n+      filters,\n+      filterId,\n     } = this.props;\n \n-    const {\n-      notValidFields,\n-      widgetShown,\n-      activeFilter,\n-      activeFiltersCaptions,\n-    } = this.state;\n+    const widgetShown = filters ? filters.widgetShown : false;\n+    const notValidFields = filters ? filters.notValidFields : false;\n+\n+    if (!filters || !viewId || !filters.filterData) return false;\n+    const { filtersActive, filtersCaptions: activeFiltersCaptions } = filters;\n+\n+    const allFilters = annotateFilters({", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ce95b512092885868ff785d02b76a4bf90452e5"}, "originalPosition": 662}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc4MjEzOQ==", "bodyText": "I have them mapped in the mapStateToProps but once I do that I get a DocList unit test failing :(", "url": "https://github.com/metasfresh/metasfresh/pull/9870#discussion_r500782139", "createdAt": "2020-10-07T07:04:52Z", "author": {"login": "petrican"}, "path": "frontend/src/components/filters/Filters.js", "diffHunk": "@@ -2,604 +2,133 @@ import counterpart from 'counterpart';\n import PropTypes from 'prop-types';\n import React, { PureComponent } from 'react';\n import { connect } from 'react-redux';\n-// -- using iMap from immutable\n-import { Map as iMap } from 'immutable';\n-import _ from 'lodash';\n-\n-import { DATE_FIELDS } from '../../constants/Constants';\n import {\n-  generateMomentObj,\n-  getFormatForDateField,\n-} from '../widget/RawWidgetHelpers';\n-import { parseDateWithCurrentTimezone } from '../../utils/documentListHelper';\n-import { fieldValueToString } from '../../utils/tableHelpers';\n-import FiltersFrequent from './FiltersFrequent';\n-import FiltersNotFrequent from './FiltersNotFrequent';\n-\n-/**\n- * @method parseDateToReadable\n- * @summary ToDo: Describe the method\n- * @param {*} widgetType\n- * @param {*} value\n- * @todo Write the documentation\n- */\n-export function parseDateToReadable(widgetType, value) {\n-  if (DATE_FIELDS.indexOf(widgetType) > -1) {\n-    return parseDateWithCurrentTimezone(value, widgetType);\n-  }\n-  return value;\n-}\n+  updateFilterWidgetShown,\n+  setNewFiltersActive,\n+  updateActiveFilter,\n+  clearAllFilters,\n+  annotateFilters,\n+  isFilterValid,\n+  updateNotValidFields,\n+  parseToPatch,\n+} from '../../actions/FiltersActions';\n+\n+import FiltersNotIcluded from './FiltersNotIncluded';\n+import FiltersIncluded from './FiltersIncluded';\n+import deepUnfreeze from 'deep-unfreeze';\n+import { getEntityRelatedId } from '../../reducers/filters';\n \n /**\n  * @file Class based component.\n  * @module Filters\n- * @extends Component\n+ * @extends PureComponent\n  */\n class Filters extends PureComponent {\n-  state = {\n-    activeFilter: null,\n-    activeFiltersCaptions: null,\n-    flatFiltersMap: null,\n-    notValidFields: null,\n-    widgetShown: false,\n-  };\n-\n-  /**\n-   * @method UNSAFE_componentWillReceiveProps\n-   * @summary ToDo: Describe the method\n-   */\n-  UNSAFE_componentWillReceiveProps() {\n-    this.parseActiveFilters();\n-  }\n-\n-  /**\n-   * @method componentDidMount\n-   * @summary ToDo: Describe the method\n-   */\n-  componentDidMount() {\n-    this.parseActiveFilters();\n-  }\n-\n-  /**\n-   * @method arrangeFilters\n-   * @summary combines the filters and also removes the other actives ones from same group\n-   */\n-  arrangeFilters = (filterData) => {\n-    let combinedFilters = [];\n-    for (const [key] of filterData.entries()) {\n-      let item = filterData.get(key);\n-      if (typeof item.includedFilters !== 'undefined') {\n-        combinedFilters.push(...item.includedFilters);\n-      } else {\n-        combinedFilters.push(item);\n-      }\n-    }\n-    let mappedFiltersData = new Map();\n-    combinedFilters.forEach((item) => {\n-      mappedFiltersData.set(item.filterId, item);\n-    });\n-    return mappedFiltersData;\n-  };\n-\n-  // PARSING FILTERS ---------------------------------------------------------\n-\n-  /*\n-   * parseActiveFilters - this function does three things:\n-   *  - creates a flat map of existing filter fields to store the widgetType for\n-        further processing\n-   *  - creates a local copy of active filters object including filters that\n-   *    only have defaultValues set. `defaultVal` flag tells us, that this\n-   *    filter has only defaultValues, and no values set by the user. We need\n-   *    this to ble able to differentiate between filters that should be\n-   *    indicated as active on load, or not.\n-   *  - creates an object with captions of each active parameter per filter\n-   *\n-   * So first we traverse all filters data and perform actions in this order:\n-   *  - if filter is in active filters and parameter has no defaultValue,\n-   *    or defaultValue has been nullified by user's selection we add it\n-   *    local active filters and set the `defaultVal` flag to false\n-   *    (as it obviously was already set).\n-   *  - if filter is active check if current loop parameter is set in the\n-   *    active filters. If yes, do nothing as it'll always override the\n-   *    defaultValue\n-   *  - otherwise add parameter and filter to local active filters and set\n-   *    the `defaultVal` to true as apparently there are no values set  \n-   *  \n-   *    Update: 10 March 2020, removed the logic to set the default \n-   * \n-   */\n-  /**\n-   * @method parseActiveFilters\n-   * @summary ToDo: Describe the method\n-   */\n-  parseActiveFilters = () => {\n-    let { filtersActive, filterData, initialValuesNulled } = this.props;\n-    let activeFilters = _.cloneDeep(filtersActive);\n-\n-    // make new ES6 Map with the items from combined filters\n-    let mappedFiltersData = this.arrangeFilters(filterData);\n-    // put the resulted combined map of filters into the iMap and preserve existing functionality\n-    let filtersData = iMap(mappedFiltersData);\n-    const flatFiltersMap = {};\n-    const activeFiltersCaptions = {};\n-\n-    // find any filters with default values first and extend\n-    // activeFilters with them\n-    filtersData.forEach((filter, filterId) => {\n-      if (filter.parameters) {\n-        outerParameters: for (let parameter of filter.parameters) {\n-          const { defaultValue, parameterName, widgetType } = parameter;\n-          const nulledFilter = initialValuesNulled.get(filterId);\n-\n-          flatFiltersMap[`${filterId}-${parameterName}`] = {\n-            widgetType,\n-          };\n-\n-          const isActive = filtersActive.has(filterId);\n-\n-          if (\n-            !defaultValue ||\n-            (nulledFilter && nulledFilter.has(parameterName))\n-          ) {\n-            if (isActive) {\n-              activeFilters = activeFilters.set(filterId, {\n-                defaultVal: false,\n-                filterId,\n-                parameters: activeFilters.get(filterId).parameters,\n-              });\n-            }\n-            continue;\n-          }\n-\n-          if (isActive) {\n-            //look for existing parameterName in parameters array\n-            // skip if found as they override defaultValue ALWAYS\n-            const filterActive = activeFilters.get(filterId);\n-\n-            if (filterActive.parameters) {\n-              for (let activeParameter of filterActive.parameters) {\n-                if (activeParameter.parameterName === parameterName) {\n-                  continue outerParameters;\n-                }\n-              }\n-            }\n-          }\n-        }\n-      }\n-    });\n-\n-    if (activeFilters.size) {\n-      const removeDefault = {};\n-\n-      activeFilters.forEach((filter, filterId) => {\n-        let captionsArray = ['', ''];\n-\n-        if (filter.parameters && filter.parameters.length) {\n-          filter.parameters.forEach((filterParameter) => {\n-            const { value, parameterName, defaultValue } = filterParameter;\n-\n-            if (!defaultValue) {\n-              // we don't want to show captions, nor show filter button as active\n-              // for default values\n-              removeDefault[filterId] = true;\n-\n-              const parentFilter = filtersData.get(filterId);\n-              const filterParameter = parentFilter.parameters.find(\n-                (param) => param.parameterName === parameterName\n-              );\n-              let captionName = filterParameter.caption;\n-              let itemCaption = filterParameter.caption;\n-\n-              switch (filterParameter.widgetType) {\n-                case 'Text':\n-                  captionName = value;\n-\n-                  if (!value) {\n-                    captionName = '';\n-                    itemCaption = '';\n-                  }\n-                  break;\n-                case 'Lookup':\n-                case 'List':\n-                  captionName = value && value.caption;\n-                  break;\n-                case 'Labels':\n-                  captionName = value.values.reduce((caption, item) => {\n-                    return `${caption}, ${item.caption}`;\n-                  }, '');\n-                  break;\n-                case 'YesNo':\n-                  if (value === null) {\n-                    captionName = '';\n-                    itemCaption = '';\n-                  }\n-                  break;\n-                case 'Switch':\n-                default:\n-                  if (!value) {\n-                    captionName = '';\n-                    itemCaption = '';\n-                  }\n-                  break;\n-              }\n-\n-              if (captionName) {\n-                captionsArray[0] = captionsArray[0]\n-                  ? `${captionsArray[0]}, ${captionName}`\n-                  : captionName;\n-              }\n-\n-              if (itemCaption) {\n-                captionsArray[1] = captionsArray[1]\n-                  ? `${captionsArray[1]}, ${itemCaption}`\n-                  : itemCaption;\n-              }\n-            }\n-          });\n-        } else {\n-          const originalFilter = filtersData.get(filterId);\n-          captionsArray = [originalFilter.caption, originalFilter.caption];\n-        }\n-\n-        if (captionsArray.join('').length) {\n-          activeFiltersCaptions[filterId] = captionsArray;\n-        }\n-      });\n-\n-      // if filter has defaultValues but also some user defined ones,\n-      // we should still include it in active filters\n-      if (Object.keys(removeDefault).length) {\n-        for (let key of Object.keys(removeDefault)) {\n-          activeFilters = activeFilters.setIn([key, 'defaultVal'], false);\n-        }\n-      }\n-\n-      const cleanActiveFilter = this.cleanupActiveFilter(\n-        filterData.toIndexedSeq().toArray(),\n-        activeFilters.toIndexedSeq().toArray()\n-      );\n-\n-      this.setState({\n-        activeFilter: cleanActiveFilter,\n-        activeFiltersCaptions,\n-        flatFiltersMap,\n-      });\n-    } else {\n-      this.setState({\n-        activeFilter: null,\n-        activeFiltersCaptions: null,\n-        flatFiltersMap,\n-      });\n-    }\n-  };\n-\n-  cleanupActiveFilter = (allFilters, activeStateFilters) => {\n-    let filtersToRemove = [];\n-    activeStateFilters.forEach((activeStateFilter) => {\n-      allFilters.forEach((filterItem) => {\n-        if (Array.isArray(filterItem.includedFilters)) {\n-          let groupFilter = filterItem.includedFilters;\n-          let foundMatches = groupFilter.filter(\n-            (gFilterItem) => gFilterItem.filterId === activeStateFilter.filterId\n-          );\n-          if (foundMatches.length > 0) {\n-            filtersToRemove = groupFilter.filter(\n-              (toRemove) => toRemove.filterId !== activeStateFilter.filterId\n-            );\n-          }\n-        }\n-      });\n-    });\n-    return activeStateFilters.filter(\n-      (asFilterItem) =>\n-        !this.isBlacklisted(asFilterItem.filterId, filtersToRemove)\n-    );\n-  };\n-\n-  /**\n-   * @method isBlackListed\n-   * @summary Check if the filterId is found among the filters to remove array\n-   * @param {string filterId\n-   * @param {array} filtersToRemove\n-   */\n-  isBlacklisted = (filterId, filtersToRemove) => {\n-    let resultValue = false;\n-    filtersToRemove.forEach((filterItem) => {\n-      if (filterItem.filterId === filterId) {\n-        resultValue = true;\n-      }\n-    });\n-    return resultValue;\n-  };\n-\n-  /**\n-   * @method sortFilters\n-   * @summary ToDo: Describe the method\n-   * @param {array} data\n-   */\n-  sortFilters = (data) => {\n-    return {\n-      frequentFilters: this.annotateFilters(\n-        data\n-          .filter((filter) => filter.frequent)\n-          .toIndexedSeq()\n-          .toArray()\n-      ),\n-      notFrequentFilters: this.annotateFilters(\n-        data\n-          .filter((filter) => !filter.frequent && !filter.static)\n-          .toIndexedSeq()\n-          .toArray()\n-      ),\n-      staticFilters: this.annotateFilters(\n-        data.filter((filter) => filter.static)\n-      )\n-        .toIndexedSeq()\n-        .toArray(),\n-    };\n-  };\n-\n-  /**\n-   * @method isFilterValid\n-   * @summary ToDo: Describe the method\n-   * @param {*} filters\n-   */\n-  isFilterValid = (filters) => {\n-    if (filters.parameters) {\n-      return !filters.parameters.filter((item) => item.mandatory && !item.value)\n-        .length;\n-    }\n-\n-    return true;\n-  };\n-\n-  /**\n-   * @method isFilterActive\n-   * @summary ToDo: Describe the method\n-   * @param {*} filterId\n-   */\n-  isFilterActive = (filterId) => {\n-    const { activeFilter } = this.state;\n-\n-    if (activeFilter) {\n-      // filters with only defaultValues shouldn't be set to active\n-      const active = activeFilter.find(\n-        (item) => item.filterId === filterId && !item.defaultVal\n-      );\n-\n-      return typeof active !== 'undefined';\n-    }\n-\n-    return false;\n-  };\n-\n-  /**\n-   * @method parseToPatch\n-   * @summary ToDo: Describe the method\n-   * @param {*} params\n-   */\n-  parseToPatch = (params) => {\n-    return params.reduce((acc, param) => {\n-      if (\n-        // filters with only defaltValue shouldn't be sent to server\n-        !param.defaultValue ||\n-        JSON.stringify(param.defaultValue) !== JSON.stringify(param.value)\n-      ) {\n-        acc.push({\n-          ...param,\n-          value: param.value === '' ? null : param.value,\n-        });\n-      }\n-\n-      return acc;\n-    }, []);\n-  };\n-\n-  // SETTING FILTERS  --------------------------------------------------------\n   /**\n    * @method applyFilters\n-   * @summary This method should update docList\n-   * @param {*} isActive\n-   * @param {*} captionValue\n+   * @summary This method should update filters in the store and DL reacts automatically to the changes\n    * @param {object} filter\n-   * @param {*} cb\n-   */\n-  // eslint-disable-next-line no-unused-vars\n-  applyFilters = ({ isActive, captionValue, ...filter }, cb) => {\n-    const valid = this.isFilterValid(filter);\n-\n-    this.setState(\n-      {\n-        notValidFields: !valid,\n-      },\n-      () => {\n-        if (valid) {\n-          const parsedFilter = filter.parameters\n-            ? {\n-                ...filter,\n-                parameters: this.parseToPatch(filter.parameters),\n-              }\n-            : filter;\n+   * @param {function} cb - executed if filter is valid and after it was applied\n+   */\n+  applyFilters = ({ ...filter }, cb) => {\n+    const valid = isFilterValid(filter);\n+    const { updateNotValidFields, filterId } = this.props;\n+\n+    updateNotValidFields({ filterId, data: !valid });\n+    if (valid) {\n+      const parsedFilter = filter.parameters\n+        ? {\n+            ...filter,\n+            parameters: parseToPatch(filter.parameters),\n+          }\n+        : filter;\n \n-          this.setFilterActive(parsedFilter);\n+      this.setFilterActive(parsedFilter);\n \n-          cb && cb();\n-        }\n-      }\n-    );\n+      cb && cb();\n+    }\n   };\n \n   /**\n    * @method setFilterActive\n-   * @summary This function merges new filters that are to be activated with the existing\n-   *  active filters. Additionally we format date fields accordingly so that the backend\n-   *  accepts them.\n+   * @summary This function updates the active filters we set and then triggers the pre-existing\n+   *          logic from DocList that will fetch the filtered data\n    * @param {object} filterToAdd\n    */\n   setFilterActive = (filterToAdd) => {\n-    const { updateDocList } = this.props;\n-    let { filtersActive } = this.props;\n-    const { flatFiltersMap } = this.state;\n-    let activeFilters = iMap(filtersActive);\n-\n-    activeFilters = activeFilters.filter(\n-      (item, id) => id !== filterToAdd.filterId\n-    );\n-    activeFilters = activeFilters.set(filterToAdd.filterId, filterToAdd);\n+    const { updateDocList, filterId, updateActiveFilter } = this.props;\n+    const { filtersActive: storeActiveFilters } = this.props.filters;\n \n-    if (flatFiltersMap) {\n-      activeFilters = activeFilters.map((filter, filterId) => {\n-        filter.parameters &&\n-          filter.parameters.forEach((parameter) => {\n-            const { value, valueTo, parameterName } = parameter;\n-            const singleFilter = flatFiltersMap[`${filterId}-${parameterName}`];\n-\n-            if (\n-              singleFilter &&\n-              DATE_FIELDS.indexOf(singleFilter.widgetType) > -1\n-            ) {\n-              const format = getFormatForDateField(singleFilter.widgetType);\n-\n-              if (value) {\n-                parameter.value = generateMomentObj(value, format);\n-              }\n-              if (valueTo) {\n-                parameter.valueTo = generateMomentObj(valueTo, format);\n-              }\n-            }\n-          });\n-\n-        return filter;\n-      });\n-    }\n+    // updating the active filters from the redux store with the filter passed as param\n+    const newFiltersActive = setNewFiltersActive({\n+      storeActiveFilters,\n+      filterToAdd,\n+    });\n \n-    updateDocList(activeFilters);\n+    updateActiveFilter({ id: filterId, data: newFiltersActive }); // update in the store the filters\n+    updateDocList(newFiltersActive); // move on and update the page with the new filters via DocList\n   };\n \n   /**\n    * @method handleShow\n    * @summary Method to lock backdrop, to do not close on click onClickOutside\n-   *  widgets that are bigger than filter wrapper\n+   *          widgets that are bigger than filter wrapper\n    * @param {*} value\n    */\n   handleShow = (value) => {\n-    this.setState({\n-      widgetShown: value,\n-    });\n+    const { filterId, updateFilterWidgetShown } = this.props;\n+    updateFilterWidgetShown({ id: filterId, data: value });\n   };\n \n   /**\n    * @method clearFilters\n-   * @summary ToDo: Describe the method\n-   * @param {*} filterToClear\n+   * @summary Clears all the filters for a specified filter group\n+   * @param {object} filterToClear - object containing the filters\n    */\n-  clearFilters = (filterToClear, propertyName) => {\n-    const { updateDocList } = this.props;\n-    let { filtersActive } = this.props;\n-    let activeFilters = iMap(filtersActive);\n-\n-    if (filtersActive.size) {\n-      activeFilters = activeFilters.filter((item, id) => {\n-        if (id === filterToClear.filterId) {\n-          if (propertyName && item.parameters && item.parameters.length) {\n-            const parametersCopy = item.parameters.filter(\n-              (param) => param.parameterName !== propertyName\n-            );\n-\n-            if (parametersCopy.length > 0) {\n-              item.parameters = parametersCopy;\n-\n-              return item;\n-            }\n-            return false;\n-          }\n-          return false;\n-        }\n-        return item;\n-      });\n-      updateDocList(activeFilters);\n-    }\n+  clearFilters = (filterToClear) => {\n+    const { filterId, clearAllFilters, filters, updateDocList } = this.props;\n+    clearAllFilters({ id: filterId, data: filterToClear });\n+    // fetch again the doc content after filters were updated into the store\n+    updateDocList(filters.filtersActive);\n   };\n \n   /**\n    * @method dropdownToggled\n-   * @summary ToDo: Describe the method\n+   * @summary Resets notValidFields flag to false\n    */\n   dropdownToggled = () => {\n-    this.setState({\n-      notValidFields: false,\n-    });\n-  };\n-\n-  /**\n-   * @method annotateFilters\n-   * @summary I think it creates caption for active filters to show when the widget is closed - Kuba\n-   * @param {array} unannotatedFilters\n-   */\n-  annotateFilters = (unannotatedFilters) => {\n-    const { activeFilter } = this.state;\n-\n-    return unannotatedFilters.map((unannotatedFilter) => {\n-      const parameter =\n-        unannotatedFilter.parameters && unannotatedFilter.parameters[0];\n-      const isActive = this.isFilterActive(unannotatedFilter.filterId);\n-      const currentFilter = activeFilter\n-        ? activeFilter.find((f) => f.filterId === unannotatedFilter.filterId)\n-        : null;\n-      const activeParameter =\n-        parameter && isActive && currentFilter && currentFilter.parameters[0];\n-\n-      const filterType =\n-        unannotatedFilter.parameters && activeParameter\n-          ? unannotatedFilter.parameters.find(\n-              (filter) => filter.parameterName === activeParameter.parameterName\n-            )\n-          : parameter && parameter.widgetType;\n-\n-      const captionValue = activeParameter\n-        ? fieldValueToString({\n-            fieldValue: activeParameter.valueTo\n-              ? [activeParameter.value, activeParameter.valueTo]\n-              : activeParameter.value,\n-            fieldType: filterType,\n-          })\n-        : '';\n-\n-      return {\n-        ...unannotatedFilter,\n-        captionValue,\n-        isActive,\n-      };\n-    });\n+    const { updateNotValidFields, filterId } = this.props;\n+    updateNotValidFields({ filterId, data: false });\n   };\n \n-  // RENDERING FILTERS -------------------------------------------------------\n   /**\n    * @method render\n-   * @summary ToDo: Describe the method\n+   * @summary Main render function - renders the filters\n    */\n   render() {\n     const {\n-      filterData,\n       windowType,\n       viewId,\n       resetInitialValues,\n       allowOutsideClick,\n       modalVisible,\n+      filters,\n+      filterId,\n     } = this.props;\n \n-    const {\n-      notValidFields,\n-      widgetShown,\n-      activeFilter,\n-      activeFiltersCaptions,\n-    } = this.state;\n+    const widgetShown = filters ? filters.widgetShown : false;\n+    const notValidFields = filters ? filters.notValidFields : false;\n+\n+    if (!filters || !viewId || !filters.filterData) return false;\n+    const { filtersActive, filtersCaptions: activeFiltersCaptions } = filters;\n+\n+    const allFilters = annotateFilters({", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDMyNzgwOA=="}, "originalCommit": {"oid": "0ce95b512092885868ff785d02b76a4bf90452e5"}, "originalPosition": 662}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDg2MDc1MQ==", "bodyText": "Thanks for the help in fixing this @siemiatj", "url": "https://github.com/metasfresh/metasfresh/pull/9870#discussion_r500860751", "createdAt": "2020-10-07T09:15:27Z", "author": {"login": "petrican"}, "path": "frontend/src/components/filters/Filters.js", "diffHunk": "@@ -2,604 +2,133 @@ import counterpart from 'counterpart';\n import PropTypes from 'prop-types';\n import React, { PureComponent } from 'react';\n import { connect } from 'react-redux';\n-// -- using iMap from immutable\n-import { Map as iMap } from 'immutable';\n-import _ from 'lodash';\n-\n-import { DATE_FIELDS } from '../../constants/Constants';\n import {\n-  generateMomentObj,\n-  getFormatForDateField,\n-} from '../widget/RawWidgetHelpers';\n-import { parseDateWithCurrentTimezone } from '../../utils/documentListHelper';\n-import { fieldValueToString } from '../../utils/tableHelpers';\n-import FiltersFrequent from './FiltersFrequent';\n-import FiltersNotFrequent from './FiltersNotFrequent';\n-\n-/**\n- * @method parseDateToReadable\n- * @summary ToDo: Describe the method\n- * @param {*} widgetType\n- * @param {*} value\n- * @todo Write the documentation\n- */\n-export function parseDateToReadable(widgetType, value) {\n-  if (DATE_FIELDS.indexOf(widgetType) > -1) {\n-    return parseDateWithCurrentTimezone(value, widgetType);\n-  }\n-  return value;\n-}\n+  updateFilterWidgetShown,\n+  setNewFiltersActive,\n+  updateActiveFilter,\n+  clearAllFilters,\n+  annotateFilters,\n+  isFilterValid,\n+  updateNotValidFields,\n+  parseToPatch,\n+} from '../../actions/FiltersActions';\n+\n+import FiltersNotIcluded from './FiltersNotIncluded';\n+import FiltersIncluded from './FiltersIncluded';\n+import deepUnfreeze from 'deep-unfreeze';\n+import { getEntityRelatedId } from '../../reducers/filters';\n \n /**\n  * @file Class based component.\n  * @module Filters\n- * @extends Component\n+ * @extends PureComponent\n  */\n class Filters extends PureComponent {\n-  state = {\n-    activeFilter: null,\n-    activeFiltersCaptions: null,\n-    flatFiltersMap: null,\n-    notValidFields: null,\n-    widgetShown: false,\n-  };\n-\n-  /**\n-   * @method UNSAFE_componentWillReceiveProps\n-   * @summary ToDo: Describe the method\n-   */\n-  UNSAFE_componentWillReceiveProps() {\n-    this.parseActiveFilters();\n-  }\n-\n-  /**\n-   * @method componentDidMount\n-   * @summary ToDo: Describe the method\n-   */\n-  componentDidMount() {\n-    this.parseActiveFilters();\n-  }\n-\n-  /**\n-   * @method arrangeFilters\n-   * @summary combines the filters and also removes the other actives ones from same group\n-   */\n-  arrangeFilters = (filterData) => {\n-    let combinedFilters = [];\n-    for (const [key] of filterData.entries()) {\n-      let item = filterData.get(key);\n-      if (typeof item.includedFilters !== 'undefined') {\n-        combinedFilters.push(...item.includedFilters);\n-      } else {\n-        combinedFilters.push(item);\n-      }\n-    }\n-    let mappedFiltersData = new Map();\n-    combinedFilters.forEach((item) => {\n-      mappedFiltersData.set(item.filterId, item);\n-    });\n-    return mappedFiltersData;\n-  };\n-\n-  // PARSING FILTERS ---------------------------------------------------------\n-\n-  /*\n-   * parseActiveFilters - this function does three things:\n-   *  - creates a flat map of existing filter fields to store the widgetType for\n-        further processing\n-   *  - creates a local copy of active filters object including filters that\n-   *    only have defaultValues set. `defaultVal` flag tells us, that this\n-   *    filter has only defaultValues, and no values set by the user. We need\n-   *    this to ble able to differentiate between filters that should be\n-   *    indicated as active on load, or not.\n-   *  - creates an object with captions of each active parameter per filter\n-   *\n-   * So first we traverse all filters data and perform actions in this order:\n-   *  - if filter is in active filters and parameter has no defaultValue,\n-   *    or defaultValue has been nullified by user's selection we add it\n-   *    local active filters and set the `defaultVal` flag to false\n-   *    (as it obviously was already set).\n-   *  - if filter is active check if current loop parameter is set in the\n-   *    active filters. If yes, do nothing as it'll always override the\n-   *    defaultValue\n-   *  - otherwise add parameter and filter to local active filters and set\n-   *    the `defaultVal` to true as apparently there are no values set  \n-   *  \n-   *    Update: 10 March 2020, removed the logic to set the default \n-   * \n-   */\n-  /**\n-   * @method parseActiveFilters\n-   * @summary ToDo: Describe the method\n-   */\n-  parseActiveFilters = () => {\n-    let { filtersActive, filterData, initialValuesNulled } = this.props;\n-    let activeFilters = _.cloneDeep(filtersActive);\n-\n-    // make new ES6 Map with the items from combined filters\n-    let mappedFiltersData = this.arrangeFilters(filterData);\n-    // put the resulted combined map of filters into the iMap and preserve existing functionality\n-    let filtersData = iMap(mappedFiltersData);\n-    const flatFiltersMap = {};\n-    const activeFiltersCaptions = {};\n-\n-    // find any filters with default values first and extend\n-    // activeFilters with them\n-    filtersData.forEach((filter, filterId) => {\n-      if (filter.parameters) {\n-        outerParameters: for (let parameter of filter.parameters) {\n-          const { defaultValue, parameterName, widgetType } = parameter;\n-          const nulledFilter = initialValuesNulled.get(filterId);\n-\n-          flatFiltersMap[`${filterId}-${parameterName}`] = {\n-            widgetType,\n-          };\n-\n-          const isActive = filtersActive.has(filterId);\n-\n-          if (\n-            !defaultValue ||\n-            (nulledFilter && nulledFilter.has(parameterName))\n-          ) {\n-            if (isActive) {\n-              activeFilters = activeFilters.set(filterId, {\n-                defaultVal: false,\n-                filterId,\n-                parameters: activeFilters.get(filterId).parameters,\n-              });\n-            }\n-            continue;\n-          }\n-\n-          if (isActive) {\n-            //look for existing parameterName in parameters array\n-            // skip if found as they override defaultValue ALWAYS\n-            const filterActive = activeFilters.get(filterId);\n-\n-            if (filterActive.parameters) {\n-              for (let activeParameter of filterActive.parameters) {\n-                if (activeParameter.parameterName === parameterName) {\n-                  continue outerParameters;\n-                }\n-              }\n-            }\n-          }\n-        }\n-      }\n-    });\n-\n-    if (activeFilters.size) {\n-      const removeDefault = {};\n-\n-      activeFilters.forEach((filter, filterId) => {\n-        let captionsArray = ['', ''];\n-\n-        if (filter.parameters && filter.parameters.length) {\n-          filter.parameters.forEach((filterParameter) => {\n-            const { value, parameterName, defaultValue } = filterParameter;\n-\n-            if (!defaultValue) {\n-              // we don't want to show captions, nor show filter button as active\n-              // for default values\n-              removeDefault[filterId] = true;\n-\n-              const parentFilter = filtersData.get(filterId);\n-              const filterParameter = parentFilter.parameters.find(\n-                (param) => param.parameterName === parameterName\n-              );\n-              let captionName = filterParameter.caption;\n-              let itemCaption = filterParameter.caption;\n-\n-              switch (filterParameter.widgetType) {\n-                case 'Text':\n-                  captionName = value;\n-\n-                  if (!value) {\n-                    captionName = '';\n-                    itemCaption = '';\n-                  }\n-                  break;\n-                case 'Lookup':\n-                case 'List':\n-                  captionName = value && value.caption;\n-                  break;\n-                case 'Labels':\n-                  captionName = value.values.reduce((caption, item) => {\n-                    return `${caption}, ${item.caption}`;\n-                  }, '');\n-                  break;\n-                case 'YesNo':\n-                  if (value === null) {\n-                    captionName = '';\n-                    itemCaption = '';\n-                  }\n-                  break;\n-                case 'Switch':\n-                default:\n-                  if (!value) {\n-                    captionName = '';\n-                    itemCaption = '';\n-                  }\n-                  break;\n-              }\n-\n-              if (captionName) {\n-                captionsArray[0] = captionsArray[0]\n-                  ? `${captionsArray[0]}, ${captionName}`\n-                  : captionName;\n-              }\n-\n-              if (itemCaption) {\n-                captionsArray[1] = captionsArray[1]\n-                  ? `${captionsArray[1]}, ${itemCaption}`\n-                  : itemCaption;\n-              }\n-            }\n-          });\n-        } else {\n-          const originalFilter = filtersData.get(filterId);\n-          captionsArray = [originalFilter.caption, originalFilter.caption];\n-        }\n-\n-        if (captionsArray.join('').length) {\n-          activeFiltersCaptions[filterId] = captionsArray;\n-        }\n-      });\n-\n-      // if filter has defaultValues but also some user defined ones,\n-      // we should still include it in active filters\n-      if (Object.keys(removeDefault).length) {\n-        for (let key of Object.keys(removeDefault)) {\n-          activeFilters = activeFilters.setIn([key, 'defaultVal'], false);\n-        }\n-      }\n-\n-      const cleanActiveFilter = this.cleanupActiveFilter(\n-        filterData.toIndexedSeq().toArray(),\n-        activeFilters.toIndexedSeq().toArray()\n-      );\n-\n-      this.setState({\n-        activeFilter: cleanActiveFilter,\n-        activeFiltersCaptions,\n-        flatFiltersMap,\n-      });\n-    } else {\n-      this.setState({\n-        activeFilter: null,\n-        activeFiltersCaptions: null,\n-        flatFiltersMap,\n-      });\n-    }\n-  };\n-\n-  cleanupActiveFilter = (allFilters, activeStateFilters) => {\n-    let filtersToRemove = [];\n-    activeStateFilters.forEach((activeStateFilter) => {\n-      allFilters.forEach((filterItem) => {\n-        if (Array.isArray(filterItem.includedFilters)) {\n-          let groupFilter = filterItem.includedFilters;\n-          let foundMatches = groupFilter.filter(\n-            (gFilterItem) => gFilterItem.filterId === activeStateFilter.filterId\n-          );\n-          if (foundMatches.length > 0) {\n-            filtersToRemove = groupFilter.filter(\n-              (toRemove) => toRemove.filterId !== activeStateFilter.filterId\n-            );\n-          }\n-        }\n-      });\n-    });\n-    return activeStateFilters.filter(\n-      (asFilterItem) =>\n-        !this.isBlacklisted(asFilterItem.filterId, filtersToRemove)\n-    );\n-  };\n-\n-  /**\n-   * @method isBlackListed\n-   * @summary Check if the filterId is found among the filters to remove array\n-   * @param {string filterId\n-   * @param {array} filtersToRemove\n-   */\n-  isBlacklisted = (filterId, filtersToRemove) => {\n-    let resultValue = false;\n-    filtersToRemove.forEach((filterItem) => {\n-      if (filterItem.filterId === filterId) {\n-        resultValue = true;\n-      }\n-    });\n-    return resultValue;\n-  };\n-\n-  /**\n-   * @method sortFilters\n-   * @summary ToDo: Describe the method\n-   * @param {array} data\n-   */\n-  sortFilters = (data) => {\n-    return {\n-      frequentFilters: this.annotateFilters(\n-        data\n-          .filter((filter) => filter.frequent)\n-          .toIndexedSeq()\n-          .toArray()\n-      ),\n-      notFrequentFilters: this.annotateFilters(\n-        data\n-          .filter((filter) => !filter.frequent && !filter.static)\n-          .toIndexedSeq()\n-          .toArray()\n-      ),\n-      staticFilters: this.annotateFilters(\n-        data.filter((filter) => filter.static)\n-      )\n-        .toIndexedSeq()\n-        .toArray(),\n-    };\n-  };\n-\n-  /**\n-   * @method isFilterValid\n-   * @summary ToDo: Describe the method\n-   * @param {*} filters\n-   */\n-  isFilterValid = (filters) => {\n-    if (filters.parameters) {\n-      return !filters.parameters.filter((item) => item.mandatory && !item.value)\n-        .length;\n-    }\n-\n-    return true;\n-  };\n-\n-  /**\n-   * @method isFilterActive\n-   * @summary ToDo: Describe the method\n-   * @param {*} filterId\n-   */\n-  isFilterActive = (filterId) => {\n-    const { activeFilter } = this.state;\n-\n-    if (activeFilter) {\n-      // filters with only defaultValues shouldn't be set to active\n-      const active = activeFilter.find(\n-        (item) => item.filterId === filterId && !item.defaultVal\n-      );\n-\n-      return typeof active !== 'undefined';\n-    }\n-\n-    return false;\n-  };\n-\n-  /**\n-   * @method parseToPatch\n-   * @summary ToDo: Describe the method\n-   * @param {*} params\n-   */\n-  parseToPatch = (params) => {\n-    return params.reduce((acc, param) => {\n-      if (\n-        // filters with only defaltValue shouldn't be sent to server\n-        !param.defaultValue ||\n-        JSON.stringify(param.defaultValue) !== JSON.stringify(param.value)\n-      ) {\n-        acc.push({\n-          ...param,\n-          value: param.value === '' ? null : param.value,\n-        });\n-      }\n-\n-      return acc;\n-    }, []);\n-  };\n-\n-  // SETTING FILTERS  --------------------------------------------------------\n   /**\n    * @method applyFilters\n-   * @summary This method should update docList\n-   * @param {*} isActive\n-   * @param {*} captionValue\n+   * @summary This method should update filters in the store and DL reacts automatically to the changes\n    * @param {object} filter\n-   * @param {*} cb\n-   */\n-  // eslint-disable-next-line no-unused-vars\n-  applyFilters = ({ isActive, captionValue, ...filter }, cb) => {\n-    const valid = this.isFilterValid(filter);\n-\n-    this.setState(\n-      {\n-        notValidFields: !valid,\n-      },\n-      () => {\n-        if (valid) {\n-          const parsedFilter = filter.parameters\n-            ? {\n-                ...filter,\n-                parameters: this.parseToPatch(filter.parameters),\n-              }\n-            : filter;\n+   * @param {function} cb - executed if filter is valid and after it was applied\n+   */\n+  applyFilters = ({ ...filter }, cb) => {\n+    const valid = isFilterValid(filter);\n+    const { updateNotValidFields, filterId } = this.props;\n+\n+    updateNotValidFields({ filterId, data: !valid });\n+    if (valid) {\n+      const parsedFilter = filter.parameters\n+        ? {\n+            ...filter,\n+            parameters: parseToPatch(filter.parameters),\n+          }\n+        : filter;\n \n-          this.setFilterActive(parsedFilter);\n+      this.setFilterActive(parsedFilter);\n \n-          cb && cb();\n-        }\n-      }\n-    );\n+      cb && cb();\n+    }\n   };\n \n   /**\n    * @method setFilterActive\n-   * @summary This function merges new filters that are to be activated with the existing\n-   *  active filters. Additionally we format date fields accordingly so that the backend\n-   *  accepts them.\n+   * @summary This function updates the active filters we set and then triggers the pre-existing\n+   *          logic from DocList that will fetch the filtered data\n    * @param {object} filterToAdd\n    */\n   setFilterActive = (filterToAdd) => {\n-    const { updateDocList } = this.props;\n-    let { filtersActive } = this.props;\n-    const { flatFiltersMap } = this.state;\n-    let activeFilters = iMap(filtersActive);\n-\n-    activeFilters = activeFilters.filter(\n-      (item, id) => id !== filterToAdd.filterId\n-    );\n-    activeFilters = activeFilters.set(filterToAdd.filterId, filterToAdd);\n+    const { updateDocList, filterId, updateActiveFilter } = this.props;\n+    const { filtersActive: storeActiveFilters } = this.props.filters;\n \n-    if (flatFiltersMap) {\n-      activeFilters = activeFilters.map((filter, filterId) => {\n-        filter.parameters &&\n-          filter.parameters.forEach((parameter) => {\n-            const { value, valueTo, parameterName } = parameter;\n-            const singleFilter = flatFiltersMap[`${filterId}-${parameterName}`];\n-\n-            if (\n-              singleFilter &&\n-              DATE_FIELDS.indexOf(singleFilter.widgetType) > -1\n-            ) {\n-              const format = getFormatForDateField(singleFilter.widgetType);\n-\n-              if (value) {\n-                parameter.value = generateMomentObj(value, format);\n-              }\n-              if (valueTo) {\n-                parameter.valueTo = generateMomentObj(valueTo, format);\n-              }\n-            }\n-          });\n-\n-        return filter;\n-      });\n-    }\n+    // updating the active filters from the redux store with the filter passed as param\n+    const newFiltersActive = setNewFiltersActive({\n+      storeActiveFilters,\n+      filterToAdd,\n+    });\n \n-    updateDocList(activeFilters);\n+    updateActiveFilter({ id: filterId, data: newFiltersActive }); // update in the store the filters\n+    updateDocList(newFiltersActive); // move on and update the page with the new filters via DocList\n   };\n \n   /**\n    * @method handleShow\n    * @summary Method to lock backdrop, to do not close on click onClickOutside\n-   *  widgets that are bigger than filter wrapper\n+   *          widgets that are bigger than filter wrapper\n    * @param {*} value\n    */\n   handleShow = (value) => {\n-    this.setState({\n-      widgetShown: value,\n-    });\n+    const { filterId, updateFilterWidgetShown } = this.props;\n+    updateFilterWidgetShown({ id: filterId, data: value });\n   };\n \n   /**\n    * @method clearFilters\n-   * @summary ToDo: Describe the method\n-   * @param {*} filterToClear\n+   * @summary Clears all the filters for a specified filter group\n+   * @param {object} filterToClear - object containing the filters\n    */\n-  clearFilters = (filterToClear, propertyName) => {\n-    const { updateDocList } = this.props;\n-    let { filtersActive } = this.props;\n-    let activeFilters = iMap(filtersActive);\n-\n-    if (filtersActive.size) {\n-      activeFilters = activeFilters.filter((item, id) => {\n-        if (id === filterToClear.filterId) {\n-          if (propertyName && item.parameters && item.parameters.length) {\n-            const parametersCopy = item.parameters.filter(\n-              (param) => param.parameterName !== propertyName\n-            );\n-\n-            if (parametersCopy.length > 0) {\n-              item.parameters = parametersCopy;\n-\n-              return item;\n-            }\n-            return false;\n-          }\n-          return false;\n-        }\n-        return item;\n-      });\n-      updateDocList(activeFilters);\n-    }\n+  clearFilters = (filterToClear) => {\n+    const { filterId, clearAllFilters, filters, updateDocList } = this.props;\n+    clearAllFilters({ id: filterId, data: filterToClear });\n+    // fetch again the doc content after filters were updated into the store\n+    updateDocList(filters.filtersActive);\n   };\n \n   /**\n    * @method dropdownToggled\n-   * @summary ToDo: Describe the method\n+   * @summary Resets notValidFields flag to false\n    */\n   dropdownToggled = () => {\n-    this.setState({\n-      notValidFields: false,\n-    });\n-  };\n-\n-  /**\n-   * @method annotateFilters\n-   * @summary I think it creates caption for active filters to show when the widget is closed - Kuba\n-   * @param {array} unannotatedFilters\n-   */\n-  annotateFilters = (unannotatedFilters) => {\n-    const { activeFilter } = this.state;\n-\n-    return unannotatedFilters.map((unannotatedFilter) => {\n-      const parameter =\n-        unannotatedFilter.parameters && unannotatedFilter.parameters[0];\n-      const isActive = this.isFilterActive(unannotatedFilter.filterId);\n-      const currentFilter = activeFilter\n-        ? activeFilter.find((f) => f.filterId === unannotatedFilter.filterId)\n-        : null;\n-      const activeParameter =\n-        parameter && isActive && currentFilter && currentFilter.parameters[0];\n-\n-      const filterType =\n-        unannotatedFilter.parameters && activeParameter\n-          ? unannotatedFilter.parameters.find(\n-              (filter) => filter.parameterName === activeParameter.parameterName\n-            )\n-          : parameter && parameter.widgetType;\n-\n-      const captionValue = activeParameter\n-        ? fieldValueToString({\n-            fieldValue: activeParameter.valueTo\n-              ? [activeParameter.value, activeParameter.valueTo]\n-              : activeParameter.value,\n-            fieldType: filterType,\n-          })\n-        : '';\n-\n-      return {\n-        ...unannotatedFilter,\n-        captionValue,\n-        isActive,\n-      };\n-    });\n+    const { updateNotValidFields, filterId } = this.props;\n+    updateNotValidFields({ filterId, data: false });\n   };\n \n-  // RENDERING FILTERS -------------------------------------------------------\n   /**\n    * @method render\n-   * @summary ToDo: Describe the method\n+   * @summary Main render function - renders the filters\n    */\n   render() {\n     const {\n-      filterData,\n       windowType,\n       viewId,\n       resetInitialValues,\n       allowOutsideClick,\n       modalVisible,\n+      filters,\n+      filterId,\n     } = this.props;\n \n-    const {\n-      notValidFields,\n-      widgetShown,\n-      activeFilter,\n-      activeFiltersCaptions,\n-    } = this.state;\n+    const widgetShown = filters ? filters.widgetShown : false;\n+    const notValidFields = filters ? filters.notValidFields : false;\n+\n+    if (!filters || !viewId || !filters.filterData) return false;\n+    const { filtersActive, filtersCaptions: activeFiltersCaptions } = filters;\n+\n+    const allFilters = annotateFilters({", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDMyNzgwOA=="}, "originalCommit": {"oid": "0ce95b512092885868ff785d02b76a4bf90452e5"}, "originalPosition": 662}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzMjc0MjM0OnYy", "diffSide": "RIGHT", "path": "frontend/src/components/filters/Filters.js", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxNDoyNDo1N1rOHdJsiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxNDoyNDo1N1rOHdJsiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDMyOTYwOQ==", "bodyText": "Same here - we'll be mapping over active filters on each render.", "url": "https://github.com/metasfresh/metasfresh/pull/9870#discussion_r500329609", "createdAt": "2020-10-06T14:24:57Z", "author": {"login": "siemiatj"}, "path": "frontend/src/components/filters/Filters.js", "diffHunk": "@@ -2,604 +2,133 @@ import counterpart from 'counterpart';\n import PropTypes from 'prop-types';\n import React, { PureComponent } from 'react';\n import { connect } from 'react-redux';\n-// -- using iMap from immutable\n-import { Map as iMap } from 'immutable';\n-import _ from 'lodash';\n-\n-import { DATE_FIELDS } from '../../constants/Constants';\n import {\n-  generateMomentObj,\n-  getFormatForDateField,\n-} from '../widget/RawWidgetHelpers';\n-import { parseDateWithCurrentTimezone } from '../../utils/documentListHelper';\n-import { fieldValueToString } from '../../utils/tableHelpers';\n-import FiltersFrequent from './FiltersFrequent';\n-import FiltersNotFrequent from './FiltersNotFrequent';\n-\n-/**\n- * @method parseDateToReadable\n- * @summary ToDo: Describe the method\n- * @param {*} widgetType\n- * @param {*} value\n- * @todo Write the documentation\n- */\n-export function parseDateToReadable(widgetType, value) {\n-  if (DATE_FIELDS.indexOf(widgetType) > -1) {\n-    return parseDateWithCurrentTimezone(value, widgetType);\n-  }\n-  return value;\n-}\n+  updateFilterWidgetShown,\n+  setNewFiltersActive,\n+  updateActiveFilter,\n+  clearAllFilters,\n+  annotateFilters,\n+  isFilterValid,\n+  updateNotValidFields,\n+  parseToPatch,\n+} from '../../actions/FiltersActions';\n+\n+import FiltersNotIcluded from './FiltersNotIncluded';\n+import FiltersIncluded from './FiltersIncluded';\n+import deepUnfreeze from 'deep-unfreeze';\n+import { getEntityRelatedId } from '../../reducers/filters';\n \n /**\n  * @file Class based component.\n  * @module Filters\n- * @extends Component\n+ * @extends PureComponent\n  */\n class Filters extends PureComponent {\n-  state = {\n-    activeFilter: null,\n-    activeFiltersCaptions: null,\n-    flatFiltersMap: null,\n-    notValidFields: null,\n-    widgetShown: false,\n-  };\n-\n-  /**\n-   * @method UNSAFE_componentWillReceiveProps\n-   * @summary ToDo: Describe the method\n-   */\n-  UNSAFE_componentWillReceiveProps() {\n-    this.parseActiveFilters();\n-  }\n-\n-  /**\n-   * @method componentDidMount\n-   * @summary ToDo: Describe the method\n-   */\n-  componentDidMount() {\n-    this.parseActiveFilters();\n-  }\n-\n-  /**\n-   * @method arrangeFilters\n-   * @summary combines the filters and also removes the other actives ones from same group\n-   */\n-  arrangeFilters = (filterData) => {\n-    let combinedFilters = [];\n-    for (const [key] of filterData.entries()) {\n-      let item = filterData.get(key);\n-      if (typeof item.includedFilters !== 'undefined') {\n-        combinedFilters.push(...item.includedFilters);\n-      } else {\n-        combinedFilters.push(item);\n-      }\n-    }\n-    let mappedFiltersData = new Map();\n-    combinedFilters.forEach((item) => {\n-      mappedFiltersData.set(item.filterId, item);\n-    });\n-    return mappedFiltersData;\n-  };\n-\n-  // PARSING FILTERS ---------------------------------------------------------\n-\n-  /*\n-   * parseActiveFilters - this function does three things:\n-   *  - creates a flat map of existing filter fields to store the widgetType for\n-        further processing\n-   *  - creates a local copy of active filters object including filters that\n-   *    only have defaultValues set. `defaultVal` flag tells us, that this\n-   *    filter has only defaultValues, and no values set by the user. We need\n-   *    this to ble able to differentiate between filters that should be\n-   *    indicated as active on load, or not.\n-   *  - creates an object with captions of each active parameter per filter\n-   *\n-   * So first we traverse all filters data and perform actions in this order:\n-   *  - if filter is in active filters and parameter has no defaultValue,\n-   *    or defaultValue has been nullified by user's selection we add it\n-   *    local active filters and set the `defaultVal` flag to false\n-   *    (as it obviously was already set).\n-   *  - if filter is active check if current loop parameter is set in the\n-   *    active filters. If yes, do nothing as it'll always override the\n-   *    defaultValue\n-   *  - otherwise add parameter and filter to local active filters and set\n-   *    the `defaultVal` to true as apparently there are no values set  \n-   *  \n-   *    Update: 10 March 2020, removed the logic to set the default \n-   * \n-   */\n-  /**\n-   * @method parseActiveFilters\n-   * @summary ToDo: Describe the method\n-   */\n-  parseActiveFilters = () => {\n-    let { filtersActive, filterData, initialValuesNulled } = this.props;\n-    let activeFilters = _.cloneDeep(filtersActive);\n-\n-    // make new ES6 Map with the items from combined filters\n-    let mappedFiltersData = this.arrangeFilters(filterData);\n-    // put the resulted combined map of filters into the iMap and preserve existing functionality\n-    let filtersData = iMap(mappedFiltersData);\n-    const flatFiltersMap = {};\n-    const activeFiltersCaptions = {};\n-\n-    // find any filters with default values first and extend\n-    // activeFilters with them\n-    filtersData.forEach((filter, filterId) => {\n-      if (filter.parameters) {\n-        outerParameters: for (let parameter of filter.parameters) {\n-          const { defaultValue, parameterName, widgetType } = parameter;\n-          const nulledFilter = initialValuesNulled.get(filterId);\n-\n-          flatFiltersMap[`${filterId}-${parameterName}`] = {\n-            widgetType,\n-          };\n-\n-          const isActive = filtersActive.has(filterId);\n-\n-          if (\n-            !defaultValue ||\n-            (nulledFilter && nulledFilter.has(parameterName))\n-          ) {\n-            if (isActive) {\n-              activeFilters = activeFilters.set(filterId, {\n-                defaultVal: false,\n-                filterId,\n-                parameters: activeFilters.get(filterId).parameters,\n-              });\n-            }\n-            continue;\n-          }\n-\n-          if (isActive) {\n-            //look for existing parameterName in parameters array\n-            // skip if found as they override defaultValue ALWAYS\n-            const filterActive = activeFilters.get(filterId);\n-\n-            if (filterActive.parameters) {\n-              for (let activeParameter of filterActive.parameters) {\n-                if (activeParameter.parameterName === parameterName) {\n-                  continue outerParameters;\n-                }\n-              }\n-            }\n-          }\n-        }\n-      }\n-    });\n-\n-    if (activeFilters.size) {\n-      const removeDefault = {};\n-\n-      activeFilters.forEach((filter, filterId) => {\n-        let captionsArray = ['', ''];\n-\n-        if (filter.parameters && filter.parameters.length) {\n-          filter.parameters.forEach((filterParameter) => {\n-            const { value, parameterName, defaultValue } = filterParameter;\n-\n-            if (!defaultValue) {\n-              // we don't want to show captions, nor show filter button as active\n-              // for default values\n-              removeDefault[filterId] = true;\n-\n-              const parentFilter = filtersData.get(filterId);\n-              const filterParameter = parentFilter.parameters.find(\n-                (param) => param.parameterName === parameterName\n-              );\n-              let captionName = filterParameter.caption;\n-              let itemCaption = filterParameter.caption;\n-\n-              switch (filterParameter.widgetType) {\n-                case 'Text':\n-                  captionName = value;\n-\n-                  if (!value) {\n-                    captionName = '';\n-                    itemCaption = '';\n-                  }\n-                  break;\n-                case 'Lookup':\n-                case 'List':\n-                  captionName = value && value.caption;\n-                  break;\n-                case 'Labels':\n-                  captionName = value.values.reduce((caption, item) => {\n-                    return `${caption}, ${item.caption}`;\n-                  }, '');\n-                  break;\n-                case 'YesNo':\n-                  if (value === null) {\n-                    captionName = '';\n-                    itemCaption = '';\n-                  }\n-                  break;\n-                case 'Switch':\n-                default:\n-                  if (!value) {\n-                    captionName = '';\n-                    itemCaption = '';\n-                  }\n-                  break;\n-              }\n-\n-              if (captionName) {\n-                captionsArray[0] = captionsArray[0]\n-                  ? `${captionsArray[0]}, ${captionName}`\n-                  : captionName;\n-              }\n-\n-              if (itemCaption) {\n-                captionsArray[1] = captionsArray[1]\n-                  ? `${captionsArray[1]}, ${itemCaption}`\n-                  : itemCaption;\n-              }\n-            }\n-          });\n-        } else {\n-          const originalFilter = filtersData.get(filterId);\n-          captionsArray = [originalFilter.caption, originalFilter.caption];\n-        }\n-\n-        if (captionsArray.join('').length) {\n-          activeFiltersCaptions[filterId] = captionsArray;\n-        }\n-      });\n-\n-      // if filter has defaultValues but also some user defined ones,\n-      // we should still include it in active filters\n-      if (Object.keys(removeDefault).length) {\n-        for (let key of Object.keys(removeDefault)) {\n-          activeFilters = activeFilters.setIn([key, 'defaultVal'], false);\n-        }\n-      }\n-\n-      const cleanActiveFilter = this.cleanupActiveFilter(\n-        filterData.toIndexedSeq().toArray(),\n-        activeFilters.toIndexedSeq().toArray()\n-      );\n-\n-      this.setState({\n-        activeFilter: cleanActiveFilter,\n-        activeFiltersCaptions,\n-        flatFiltersMap,\n-      });\n-    } else {\n-      this.setState({\n-        activeFilter: null,\n-        activeFiltersCaptions: null,\n-        flatFiltersMap,\n-      });\n-    }\n-  };\n-\n-  cleanupActiveFilter = (allFilters, activeStateFilters) => {\n-    let filtersToRemove = [];\n-    activeStateFilters.forEach((activeStateFilter) => {\n-      allFilters.forEach((filterItem) => {\n-        if (Array.isArray(filterItem.includedFilters)) {\n-          let groupFilter = filterItem.includedFilters;\n-          let foundMatches = groupFilter.filter(\n-            (gFilterItem) => gFilterItem.filterId === activeStateFilter.filterId\n-          );\n-          if (foundMatches.length > 0) {\n-            filtersToRemove = groupFilter.filter(\n-              (toRemove) => toRemove.filterId !== activeStateFilter.filterId\n-            );\n-          }\n-        }\n-      });\n-    });\n-    return activeStateFilters.filter(\n-      (asFilterItem) =>\n-        !this.isBlacklisted(asFilterItem.filterId, filtersToRemove)\n-    );\n-  };\n-\n-  /**\n-   * @method isBlackListed\n-   * @summary Check if the filterId is found among the filters to remove array\n-   * @param {string filterId\n-   * @param {array} filtersToRemove\n-   */\n-  isBlacklisted = (filterId, filtersToRemove) => {\n-    let resultValue = false;\n-    filtersToRemove.forEach((filterItem) => {\n-      if (filterItem.filterId === filterId) {\n-        resultValue = true;\n-      }\n-    });\n-    return resultValue;\n-  };\n-\n-  /**\n-   * @method sortFilters\n-   * @summary ToDo: Describe the method\n-   * @param {array} data\n-   */\n-  sortFilters = (data) => {\n-    return {\n-      frequentFilters: this.annotateFilters(\n-        data\n-          .filter((filter) => filter.frequent)\n-          .toIndexedSeq()\n-          .toArray()\n-      ),\n-      notFrequentFilters: this.annotateFilters(\n-        data\n-          .filter((filter) => !filter.frequent && !filter.static)\n-          .toIndexedSeq()\n-          .toArray()\n-      ),\n-      staticFilters: this.annotateFilters(\n-        data.filter((filter) => filter.static)\n-      )\n-        .toIndexedSeq()\n-        .toArray(),\n-    };\n-  };\n-\n-  /**\n-   * @method isFilterValid\n-   * @summary ToDo: Describe the method\n-   * @param {*} filters\n-   */\n-  isFilterValid = (filters) => {\n-    if (filters.parameters) {\n-      return !filters.parameters.filter((item) => item.mandatory && !item.value)\n-        .length;\n-    }\n-\n-    return true;\n-  };\n-\n-  /**\n-   * @method isFilterActive\n-   * @summary ToDo: Describe the method\n-   * @param {*} filterId\n-   */\n-  isFilterActive = (filterId) => {\n-    const { activeFilter } = this.state;\n-\n-    if (activeFilter) {\n-      // filters with only defaultValues shouldn't be set to active\n-      const active = activeFilter.find(\n-        (item) => item.filterId === filterId && !item.defaultVal\n-      );\n-\n-      return typeof active !== 'undefined';\n-    }\n-\n-    return false;\n-  };\n-\n-  /**\n-   * @method parseToPatch\n-   * @summary ToDo: Describe the method\n-   * @param {*} params\n-   */\n-  parseToPatch = (params) => {\n-    return params.reduce((acc, param) => {\n-      if (\n-        // filters with only defaltValue shouldn't be sent to server\n-        !param.defaultValue ||\n-        JSON.stringify(param.defaultValue) !== JSON.stringify(param.value)\n-      ) {\n-        acc.push({\n-          ...param,\n-          value: param.value === '' ? null : param.value,\n-        });\n-      }\n-\n-      return acc;\n-    }, []);\n-  };\n-\n-  // SETTING FILTERS  --------------------------------------------------------\n   /**\n    * @method applyFilters\n-   * @summary This method should update docList\n-   * @param {*} isActive\n-   * @param {*} captionValue\n+   * @summary This method should update filters in the store and DL reacts automatically to the changes\n    * @param {object} filter\n-   * @param {*} cb\n-   */\n-  // eslint-disable-next-line no-unused-vars\n-  applyFilters = ({ isActive, captionValue, ...filter }, cb) => {\n-    const valid = this.isFilterValid(filter);\n-\n-    this.setState(\n-      {\n-        notValidFields: !valid,\n-      },\n-      () => {\n-        if (valid) {\n-          const parsedFilter = filter.parameters\n-            ? {\n-                ...filter,\n-                parameters: this.parseToPatch(filter.parameters),\n-              }\n-            : filter;\n+   * @param {function} cb - executed if filter is valid and after it was applied\n+   */\n+  applyFilters = ({ ...filter }, cb) => {\n+    const valid = isFilterValid(filter);\n+    const { updateNotValidFields, filterId } = this.props;\n+\n+    updateNotValidFields({ filterId, data: !valid });\n+    if (valid) {\n+      const parsedFilter = filter.parameters\n+        ? {\n+            ...filter,\n+            parameters: parseToPatch(filter.parameters),\n+          }\n+        : filter;\n \n-          this.setFilterActive(parsedFilter);\n+      this.setFilterActive(parsedFilter);\n \n-          cb && cb();\n-        }\n-      }\n-    );\n+      cb && cb();\n+    }\n   };\n \n   /**\n    * @method setFilterActive\n-   * @summary This function merges new filters that are to be activated with the existing\n-   *  active filters. Additionally we format date fields accordingly so that the backend\n-   *  accepts them.\n+   * @summary This function updates the active filters we set and then triggers the pre-existing\n+   *          logic from DocList that will fetch the filtered data\n    * @param {object} filterToAdd\n    */\n   setFilterActive = (filterToAdd) => {\n-    const { updateDocList } = this.props;\n-    let { filtersActive } = this.props;\n-    const { flatFiltersMap } = this.state;\n-    let activeFilters = iMap(filtersActive);\n-\n-    activeFilters = activeFilters.filter(\n-      (item, id) => id !== filterToAdd.filterId\n-    );\n-    activeFilters = activeFilters.set(filterToAdd.filterId, filterToAdd);\n+    const { updateDocList, filterId, updateActiveFilter } = this.props;\n+    const { filtersActive: storeActiveFilters } = this.props.filters;\n \n-    if (flatFiltersMap) {\n-      activeFilters = activeFilters.map((filter, filterId) => {\n-        filter.parameters &&\n-          filter.parameters.forEach((parameter) => {\n-            const { value, valueTo, parameterName } = parameter;\n-            const singleFilter = flatFiltersMap[`${filterId}-${parameterName}`];\n-\n-            if (\n-              singleFilter &&\n-              DATE_FIELDS.indexOf(singleFilter.widgetType) > -1\n-            ) {\n-              const format = getFormatForDateField(singleFilter.widgetType);\n-\n-              if (value) {\n-                parameter.value = generateMomentObj(value, format);\n-              }\n-              if (valueTo) {\n-                parameter.valueTo = generateMomentObj(valueTo, format);\n-              }\n-            }\n-          });\n-\n-        return filter;\n-      });\n-    }\n+    // updating the active filters from the redux store with the filter passed as param\n+    const newFiltersActive = setNewFiltersActive({\n+      storeActiveFilters,\n+      filterToAdd,\n+    });\n \n-    updateDocList(activeFilters);\n+    updateActiveFilter({ id: filterId, data: newFiltersActive }); // update in the store the filters\n+    updateDocList(newFiltersActive); // move on and update the page with the new filters via DocList\n   };\n \n   /**\n    * @method handleShow\n    * @summary Method to lock backdrop, to do not close on click onClickOutside\n-   *  widgets that are bigger than filter wrapper\n+   *          widgets that are bigger than filter wrapper\n    * @param {*} value\n    */\n   handleShow = (value) => {\n-    this.setState({\n-      widgetShown: value,\n-    });\n+    const { filterId, updateFilterWidgetShown } = this.props;\n+    updateFilterWidgetShown({ id: filterId, data: value });\n   };\n \n   /**\n    * @method clearFilters\n-   * @summary ToDo: Describe the method\n-   * @param {*} filterToClear\n+   * @summary Clears all the filters for a specified filter group\n+   * @param {object} filterToClear - object containing the filters\n    */\n-  clearFilters = (filterToClear, propertyName) => {\n-    const { updateDocList } = this.props;\n-    let { filtersActive } = this.props;\n-    let activeFilters = iMap(filtersActive);\n-\n-    if (filtersActive.size) {\n-      activeFilters = activeFilters.filter((item, id) => {\n-        if (id === filterToClear.filterId) {\n-          if (propertyName && item.parameters && item.parameters.length) {\n-            const parametersCopy = item.parameters.filter(\n-              (param) => param.parameterName !== propertyName\n-            );\n-\n-            if (parametersCopy.length > 0) {\n-              item.parameters = parametersCopy;\n-\n-              return item;\n-            }\n-            return false;\n-          }\n-          return false;\n-        }\n-        return item;\n-      });\n-      updateDocList(activeFilters);\n-    }\n+  clearFilters = (filterToClear) => {\n+    const { filterId, clearAllFilters, filters, updateDocList } = this.props;\n+    clearAllFilters({ id: filterId, data: filterToClear });\n+    // fetch again the doc content after filters were updated into the store\n+    updateDocList(filters.filtersActive);\n   };\n \n   /**\n    * @method dropdownToggled\n-   * @summary ToDo: Describe the method\n+   * @summary Resets notValidFields flag to false\n    */\n   dropdownToggled = () => {\n-    this.setState({\n-      notValidFields: false,\n-    });\n-  };\n-\n-  /**\n-   * @method annotateFilters\n-   * @summary I think it creates caption for active filters to show when the widget is closed - Kuba\n-   * @param {array} unannotatedFilters\n-   */\n-  annotateFilters = (unannotatedFilters) => {\n-    const { activeFilter } = this.state;\n-\n-    return unannotatedFilters.map((unannotatedFilter) => {\n-      const parameter =\n-        unannotatedFilter.parameters && unannotatedFilter.parameters[0];\n-      const isActive = this.isFilterActive(unannotatedFilter.filterId);\n-      const currentFilter = activeFilter\n-        ? activeFilter.find((f) => f.filterId === unannotatedFilter.filterId)\n-        : null;\n-      const activeParameter =\n-        parameter && isActive && currentFilter && currentFilter.parameters[0];\n-\n-      const filterType =\n-        unannotatedFilter.parameters && activeParameter\n-          ? unannotatedFilter.parameters.find(\n-              (filter) => filter.parameterName === activeParameter.parameterName\n-            )\n-          : parameter && parameter.widgetType;\n-\n-      const captionValue = activeParameter\n-        ? fieldValueToString({\n-            fieldValue: activeParameter.valueTo\n-              ? [activeParameter.value, activeParameter.valueTo]\n-              : activeParameter.value,\n-            fieldType: filterType,\n-          })\n-        : '';\n-\n-      return {\n-        ...unannotatedFilter,\n-        captionValue,\n-        isActive,\n-      };\n-    });\n+    const { updateNotValidFields, filterId } = this.props;\n+    updateNotValidFields({ filterId, data: false });\n   };\n \n-  // RENDERING FILTERS -------------------------------------------------------\n   /**\n    * @method render\n-   * @summary ToDo: Describe the method\n+   * @summary Main render function - renders the filters\n    */\n   render() {\n     const {\n-      filterData,\n       windowType,\n       viewId,\n       resetInitialValues,\n       allowOutsideClick,\n       modalVisible,\n+      filters,\n+      filterId,\n     } = this.props;\n \n-    const {\n-      notValidFields,\n-      widgetShown,\n-      activeFilter,\n-      activeFiltersCaptions,\n-    } = this.state;\n+    const widgetShown = filters ? filters.widgetShown : false;\n+    const notValidFields = filters ? filters.notValidFields : false;\n+\n+    if (!filters || !viewId || !filters.filterData) return false;\n+    const { filtersActive, filtersCaptions: activeFiltersCaptions } = filters;\n+\n+    const allFilters = annotateFilters({\n+      unannotatedFilters: filters.filterData,\n+      filtersActive,\n+    });\n \n-    const allFilters = this.annotateFilters(\n-      filterData.toIndexedSeq().toArray()\n-    );\n     const flatActiveFilterIds =\n-      activeFilter !== null ? activeFilter.map((item) => item.filterId) : [];\n+      filtersActive !== null ? filtersActive.map((item) => item.filterId) : [];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ce95b512092885868ff785d02b76a4bf90452e5"}, "originalPosition": 672}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzMjc1NDIzOnYy", "diffSide": "RIGHT", "path": "frontend/src/actions/FiltersActions.js", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxNDoyNjozNlrOHdJzjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwNToxMzoxNlrOHdi13Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDMzMTQwNA==", "bodyText": "Any particular reason why it's sometimes id, and other times filterId ? It's a minor thing but if we're already using named params let's stick to one convention.", "url": "https://github.com/metasfresh/metasfresh/pull/9870#discussion_r500331404", "createdAt": "2020-10-06T14:26:36Z", "author": {"login": "siemiatj"}, "path": "frontend/src/actions/FiltersActions.js", "diffHunk": "@@ -1,8 +1,355 @@\n-import { SET_CLEAR_ALL_FILTER } from '../constants/FilterTypes';\n+import * as types from '../constants/FilterTypes';\n+import deepUnfreeze from 'deep-unfreeze';\n+import { fieldValueToString } from '../utils/tableHelpers';\n+import _ from 'lodash';\n \n-export function clearAllFilters(data) {\n+export function clearAllFilters({ id, data }) {\n   return {\n-    type: SET_CLEAR_ALL_FILTER,\n-    payload: data,\n+    type: types.CLEAR_ALL_FILTERS,\n+    payload: { id, data },\n   };\n }\n+\n+/**\n+ * @method createFilter\n+ * @summary Add a new filter entry to the redux store\n+ */\n+export function createFilter({ id, data }) {\n+  return {\n+    type: types.CREATE_FILTER,\n+    payload: { id, data },\n+  };\n+}\n+\n+/**\n+ * @method deleteFilter\n+ * @summary Remove the filter with specified `id` from the store\n+ */\n+export function deleteFilter(id) {\n+  return {\n+    type: types.DELETE_FILTER,\n+    payload: { id },\n+  };\n+}\n+\n+/**\n+ * @method updateNotValidFields\n+ * @summary updates in the store the notValidFields flag\n+ */\n+export function updateNotValidFields({ filterId, data }) {\n+  return {\n+    type: types.UPDATE_FLAG_NOTVALIDFIELDS,\n+    payload: { filterId, data },\n+  };\n+}\n+\n+/**\n+ * @method updateActiveFilter\n+ * @summary Updates the activeFilter in the store for the corresponding entity id\n+ */\n+export function updateActiveFilter({ id, data }) {\n+  return {\n+    type: types.UPDATE_ACTIVE_FILTER,\n+    payload: { id, data },\n+  };\n+}\n+\n+/**\n+ * @method updateInlineFilter\n+ * @summary Updates the InlineFilter value in the store for the corresponding entity id\n+ */\n+export function updateInlineFilter({ filterId, data }) {\n+  return {\n+    type: types.UPDATE_INLINE_FILTER,\n+    payload: { filterId, data },\n+  };\n+}\n+\n+/**\n+ * @method updateFilterWidgetShown\n+ * @summary Updates the widgetShown in the store for the corresponding entity id with a boolean value\n+ */\n+export function updateFilterWidgetShown({ id, data }) {\n+  return {\n+    type: types.FILTER_UPDATE_WIDGET_SHOWN,\n+    payload: { id, data },\n+  };\n+}\n+\n+/**\n+ * @method clearStaticFilters\n+ * @summary Clears the existing static filters for a filter branch in the redux store\n+ */\n+export function clearStaticFilters({ filterId, data }) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ce95b512092885868ff785d02b76a4bf90452e5"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc0MTU5Nw==", "bodyText": "Agree. Updated to filterId all over. Thanks", "url": "https://github.com/metasfresh/metasfresh/pull/9870#discussion_r500741597", "createdAt": "2020-10-07T05:13:16Z", "author": {"login": "petrican"}, "path": "frontend/src/actions/FiltersActions.js", "diffHunk": "@@ -1,8 +1,355 @@\n-import { SET_CLEAR_ALL_FILTER } from '../constants/FilterTypes';\n+import * as types from '../constants/FilterTypes';\n+import deepUnfreeze from 'deep-unfreeze';\n+import { fieldValueToString } from '../utils/tableHelpers';\n+import _ from 'lodash';\n \n-export function clearAllFilters(data) {\n+export function clearAllFilters({ id, data }) {\n   return {\n-    type: SET_CLEAR_ALL_FILTER,\n-    payload: data,\n+    type: types.CLEAR_ALL_FILTERS,\n+    payload: { id, data },\n   };\n }\n+\n+/**\n+ * @method createFilter\n+ * @summary Add a new filter entry to the redux store\n+ */\n+export function createFilter({ id, data }) {\n+  return {\n+    type: types.CREATE_FILTER,\n+    payload: { id, data },\n+  };\n+}\n+\n+/**\n+ * @method deleteFilter\n+ * @summary Remove the filter with specified `id` from the store\n+ */\n+export function deleteFilter(id) {\n+  return {\n+    type: types.DELETE_FILTER,\n+    payload: { id },\n+  };\n+}\n+\n+/**\n+ * @method updateNotValidFields\n+ * @summary updates in the store the notValidFields flag\n+ */\n+export function updateNotValidFields({ filterId, data }) {\n+  return {\n+    type: types.UPDATE_FLAG_NOTVALIDFIELDS,\n+    payload: { filterId, data },\n+  };\n+}\n+\n+/**\n+ * @method updateActiveFilter\n+ * @summary Updates the activeFilter in the store for the corresponding entity id\n+ */\n+export function updateActiveFilter({ id, data }) {\n+  return {\n+    type: types.UPDATE_ACTIVE_FILTER,\n+    payload: { id, data },\n+  };\n+}\n+\n+/**\n+ * @method updateInlineFilter\n+ * @summary Updates the InlineFilter value in the store for the corresponding entity id\n+ */\n+export function updateInlineFilter({ filterId, data }) {\n+  return {\n+    type: types.UPDATE_INLINE_FILTER,\n+    payload: { filterId, data },\n+  };\n+}\n+\n+/**\n+ * @method updateFilterWidgetShown\n+ * @summary Updates the widgetShown in the store for the corresponding entity id with a boolean value\n+ */\n+export function updateFilterWidgetShown({ id, data }) {\n+  return {\n+    type: types.FILTER_UPDATE_WIDGET_SHOWN,\n+    payload: { id, data },\n+  };\n+}\n+\n+/**\n+ * @method clearStaticFilters\n+ * @summary Clears the existing static filters for a filter branch in the redux store\n+ */\n+export function clearStaticFilters({ filterId, data }) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDMzMTQwNA=="}, "originalCommit": {"oid": "0ce95b512092885868ff785d02b76a4bf90452e5"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzMjc2MDI5OnYy", "diffSide": "LEFT", "path": "frontend/src/components/filters/FiltersIncluded.js", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxNDoyNzozOFrOHdJ3Uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwNTowMzowMVrOHdirnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDMzMjM3MQ==", "bodyText": "I think I've asked in another file, but why are we removing those ?", "url": "https://github.com/metasfresh/metasfresh/pull/9870#discussion_r500332371", "createdAt": "2020-10-06T14:27:38Z", "author": {"login": "siemiatj"}, "path": "frontend/src/components/filters/FiltersIncluded.js", "diffHunk": "@@ -202,26 +188,7 @@ class FiltersNotFrequent extends PureComponent {\n   }\n }\n \n-/**\n- * @typedef {object} Props Component props", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ce95b512092885868ff785d02b76a4bf90452e5"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDczODk3Mg==", "bodyText": "It's just because the format of the Proptypes is self-explanatory of what the param is and what type it has. I am for having these comments but only when is needed. In this case this would just add extra lines to the component that deliver the same information that exist in the Proptypes and that I found to be redundant.", "url": "https://github.com/metasfresh/metasfresh/pull/9870#discussion_r500738972", "createdAt": "2020-10-07T05:03:01Z", "author": {"login": "petrican"}, "path": "frontend/src/components/filters/FiltersIncluded.js", "diffHunk": "@@ -202,26 +188,7 @@ class FiltersNotFrequent extends PureComponent {\n   }\n }\n \n-/**\n- * @typedef {object} Props Component props", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDMzMjM3MQ=="}, "originalCommit": {"oid": "0ce95b512092885868ff785d02b76a4bf90452e5"}, "originalPosition": 84}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1264, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}