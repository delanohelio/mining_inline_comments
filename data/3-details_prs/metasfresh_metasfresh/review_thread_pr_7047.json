{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU1MDc2NzAz", "number": 7047, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxNToyNTowNVrOERGNoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxNToyNzoxNFrOERGRbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MzYzMDQwOnYy", "diffSide": "RIGHT", "path": "backend/de.metas.swat/de.metas.swat.base/src/main/java/de/metas/inoutcandidate/api/impl/ReceiptSchedulePA.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxNToyNTowNVrOG1nqNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxNToyNTowNVrOG1nqNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODg3NzQ5NQ==", "bodyText": "useless comments", "url": "https://github.com/metasfresh/metasfresh/pull/7047#discussion_r458877495", "createdAt": "2020-07-22T15:25:05Z", "author": {"login": "metas-ts"}, "path": "backend/de.metas.swat/de.metas.swat.base/src/main/java/de/metas/inoutcandidate/api/impl/ReceiptSchedulePA.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * #%L\n+ * de.metas.swat.base\n+ * %%\n+ * Copyright (C) 2020 metas GmbH\n+ * %%\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as\n+ * published by the Free Software Foundation, either version 2 of the\n+ * License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public\n+ * License along with this program. If not, see\n+ * <http://www.gnu.org/licenses/gpl-2.0.html>.\n+ * #L%\n+ */\n+\n+package de.metas.inoutcandidate.api.impl;\n+\n+import com.google.common.collect.ImmutableSet;\n+import de.metas.cache.CacheMgt;\n+import de.metas.cache.model.CacheInvalidateMultiRequest;\n+import de.metas.inoutcandidate.ReceiptScheduleId;\n+import de.metas.inoutcandidate.api.IReceiptSchedulePA;\n+import de.metas.inoutcandidate.exportaudit.APIExportStatus;\n+import de.metas.inoutcandidate.model.I_M_ReceiptSchedule;\n+import de.metas.order.OrderId;\n+import de.metas.process.PInstanceId;\n+import de.metas.util.Services;\n+import lombok.NonNull;\n+import org.adempiere.ad.dao.IQueryBL;\n+import org.adempiere.ad.dao.IQueryBuilder;\n+import org.adempiere.ad.dao.IQueryFilter;\n+import org.adempiere.ad.dao.impl.ModelColumnNameValue;\n+import org.adempiere.ad.trx.api.ITrx;\n+\n+import java.util.Properties;\n+\n+public class ReceiptSchedulePA implements IReceiptSchedulePA\n+{\n+\tprivate final IQueryBL queryBL = Services.get(IQueryBL.class);\n+\n+\t/**\n+\t * When mass cache invalidation, above this threshold we will invalidate ALL shipment schedule records instead of particular IDS\n+\t */\n+\tprivate static final int CACHE_INVALIDATE_ALL_THRESHOLD = 200;\n+\n+\t@Override\n+\tpublic IQueryBuilder<I_M_ReceiptSchedule> createQueryForShipmentScheduleSelection(final Properties ctx, final IQueryFilter<I_M_ReceiptSchedule> userSelectionFilter)\n+\t{\n+\t\tfinal IQueryBuilder<I_M_ReceiptSchedule> queryBuilder = queryBL\n+\t\t\t\t.createQueryBuilder(I_M_ReceiptSchedule.class, ctx, ITrx.TRXNAME_None)\n+\t\t\t\t.filter(userSelectionFilter)\n+\t\t\t\t.addEqualsFilter(I_M_ReceiptSchedule.COLUMNNAME_Processed, false)\n+\t\t\t\t.addOnlyActiveRecordsFilter()\n+\t\t\t\t.addOnlyContextClient();\n+\n+\t\treturn queryBuilder;\n+\t}\n+\n+\t@Override\n+\tpublic boolean existsExportedReceiptScheduleForOrder(final @NonNull OrderId orderId)\n+\t{\n+\t\treturn queryBL\n+\t\t\t\t.createQueryBuilder(I_M_ReceiptSchedule.class)\n+\t\t\t\t.addOnlyActiveRecordsFilter()\n+\t\t\t\t.addEqualsFilter(I_M_ReceiptSchedule.COLUMNNAME_C_Order_ID, orderId)\n+\t\t\t\t.addEqualsFilter(I_M_ReceiptSchedule.COLUMNNAME_Processed, false)\n+\t\t\t\t.addInArrayFilter(I_M_ReceiptSchedule.COLUMNNAME_ExportStatus, APIExportStatus.EXPORTED_STATES)\n+\t\t\t\t.create()\n+\t\t\t\t.anyMatch();\n+\t}\n+\n+\t@Override\n+\tpublic void updateExportStatus(final String exportStatus, final PInstanceId pinstanceId)\n+\t{\n+\t\tupdateColumnForSelection(\n+\t\t\t\tI_M_ReceiptSchedule.COLUMNNAME_ExportStatus,\n+\t\t\t\texportStatus,\n+\t\t\t\tfalse /* updateOnlyIfNull */,\n+\t\t\t\tpinstanceId\n+\t\t);\n+\t}\n+\n+\t/**\n+\t * Mass-update a given shipment schedule column.\n+\t * <p>\n+\t * If there were any changes and the invalidate parameter is on true, those shipment schedules will be invalidated.\n+\t *\n+\t * @param inoutCandidateColumnName {@link I_M_ReceiptSchedule}'s column to update\n+\t * @param value                    value to set (you can also use {@link ModelColumnNameValue})\n+\t * @param updateOnlyIfNull         if true then it will update only if column value is null (not set)\n+\t * @param selectionId              ShipmentSchedule selection (AD_PInstance_ID)\n+\t * @param trxName\n+\t */\n+\tprivate final <ValueType> void updateColumnForSelection(\n+\t\t\tfinal String inoutCandidateColumnName,\n+\t\t\tfinal ValueType value,\n+\t\t\tfinal boolean updateOnlyIfNull,\n+\t\t\tfinal PInstanceId selectionId\n+\t)\n+\t{\n+\t\t//\n+\t\t// Create the selection which we will need to update\n+\t\tfinal IQueryBuilder<I_M_ReceiptSchedule> selectionQueryBuilder = queryBL\n+\t\t\t\t.createQueryBuilder(I_M_ReceiptSchedule.class)\n+\t\t\t\t.setOnlySelection(selectionId)\n+\t\t\t\t.addEqualsFilter(I_M_ReceiptSchedule.COLUMNNAME_Processed, false) // do not touch the processed shipment schedules\n+\t\t\t\t;\n+\n+\t\tif (updateOnlyIfNull)\n+\t\t{\n+\t\t\tselectionQueryBuilder.addEqualsFilter(inoutCandidateColumnName, null);\n+\t\t}\n+\t\tfinal PInstanceId selectionToUpdateId = selectionQueryBuilder.create().createSelection();\n+\t\tif (selectionToUpdateId == null)\n+\t\t{\n+\t\t\t// nothing to update\n+\t\t\treturn;\n+\t\t}\n+\n+\t\t//\n+\t\t// Update our new selection\n+\t\tfinal int countUpdated = queryBL.createQueryBuilder(I_M_ReceiptSchedule.class)\n+\t\t\t\t.setOnlySelection(selectionToUpdateId)\n+\t\t\t\t.create()\n+\t\t\t\t.updateDirectly()\n+\t\t\t\t.addSetColumnValue(inoutCandidateColumnName, value)\n+\t\t\t\t.execute();\n+\n+\t\t//\n+\t\t// Cache invalidate\n+\t\t// We have to do this even if invalidate=false", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc13e8989ce94e620802e16398eb7a830605cf9a"}, "originalPosition": 138}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MzYzMzcyOnYy", "diffSide": "RIGHT", "path": "backend/de.metas.swat/de.metas.swat.base/src/main/java/de/metas/inoutcandidate/api/IReceiptSchedulePA.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxNToyNTo0N1rOG1nsRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxNToyNTo0N1rOG1nsRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODg3ODAyMg==", "bodyText": "(as written in the concept review, please go with the existing IReceiptScheduleDAO instead)", "url": "https://github.com/metasfresh/metasfresh/pull/7047#discussion_r458878022", "createdAt": "2020-07-22T15:25:47Z", "author": {"login": "metas-ts"}, "path": "backend/de.metas.swat/de.metas.swat.base/src/main/java/de/metas/inoutcandidate/api/IReceiptSchedulePA.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * #%L\n+ * de.metas.swat.base\n+ * %%\n+ * Copyright (C) 2020 metas GmbH\n+ * %%\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as\n+ * published by the Free Software Foundation, either version 2 of the\n+ * License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public\n+ * License along with this program. If not, see\n+ * <http://www.gnu.org/licenses/gpl-2.0.html>.\n+ * #L%\n+ */\n+\n+package de.metas.inoutcandidate.api;\n+\n+import de.metas.inoutcandidate.model.I_M_ReceiptSchedule;\n+import de.metas.order.OrderId;\n+import de.metas.process.PInstanceId;\n+import de.metas.util.ISingletonService;\n+import lombok.NonNull;\n+import org.adempiere.ad.dao.IQueryBuilder;\n+import org.adempiere.ad.dao.IQueryFilter;\n+\n+import java.util.Properties;\n+\n+/**\n+ * Implementers give database access to {@link I_M_ReceiptSchedule} instances (DAO).\n+ *\n+ * @author dp\n+ */\n+\n+public interface IReceiptSchedulePA extends ISingletonService", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc13e8989ce94e620802e16398eb7a830605cf9a"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MzY0MDEyOnYy", "diffSide": "RIGHT", "path": "backend/de.metas.swat/de.metas.swat.base/src/main/java/de/metas/inoutcandidate/api/impl/ReceiptSchedulePA.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxNToyNzoxNFrOG1nwVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxNToyNzoxNFrOG1nwVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODg3OTA2Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\tfinal ImmutableSet<ReceiptScheduleId> shipmentScheduleIds = queryBL.createQueryBuilder(I_M_ReceiptSchedule.class)\n          \n          \n            \n            \t\t\tfinal ImmutableSet<ReceiptScheduleId> receiptScheduleIds = queryBL.createQueryBuilder(I_M_ReceiptSchedule.class)", "url": "https://github.com/metasfresh/metasfresh/pull/7047#discussion_r458879062", "createdAt": "2020-07-22T15:27:14Z", "author": {"login": "metas-ts"}, "path": "backend/de.metas.swat/de.metas.swat.base/src/main/java/de/metas/inoutcandidate/api/impl/ReceiptSchedulePA.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * #%L\n+ * de.metas.swat.base\n+ * %%\n+ * Copyright (C) 2020 metas GmbH\n+ * %%\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as\n+ * published by the Free Software Foundation, either version 2 of the\n+ * License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public\n+ * License along with this program. If not, see\n+ * <http://www.gnu.org/licenses/gpl-2.0.html>.\n+ * #L%\n+ */\n+\n+package de.metas.inoutcandidate.api.impl;\n+\n+import com.google.common.collect.ImmutableSet;\n+import de.metas.cache.CacheMgt;\n+import de.metas.cache.model.CacheInvalidateMultiRequest;\n+import de.metas.inoutcandidate.ReceiptScheduleId;\n+import de.metas.inoutcandidate.api.IReceiptSchedulePA;\n+import de.metas.inoutcandidate.exportaudit.APIExportStatus;\n+import de.metas.inoutcandidate.model.I_M_ReceiptSchedule;\n+import de.metas.order.OrderId;\n+import de.metas.process.PInstanceId;\n+import de.metas.util.Services;\n+import lombok.NonNull;\n+import org.adempiere.ad.dao.IQueryBL;\n+import org.adempiere.ad.dao.IQueryBuilder;\n+import org.adempiere.ad.dao.IQueryFilter;\n+import org.adempiere.ad.dao.impl.ModelColumnNameValue;\n+import org.adempiere.ad.trx.api.ITrx;\n+\n+import java.util.Properties;\n+\n+public class ReceiptSchedulePA implements IReceiptSchedulePA\n+{\n+\tprivate final IQueryBL queryBL = Services.get(IQueryBL.class);\n+\n+\t/**\n+\t * When mass cache invalidation, above this threshold we will invalidate ALL shipment schedule records instead of particular IDS\n+\t */\n+\tprivate static final int CACHE_INVALIDATE_ALL_THRESHOLD = 200;\n+\n+\t@Override\n+\tpublic IQueryBuilder<I_M_ReceiptSchedule> createQueryForShipmentScheduleSelection(final Properties ctx, final IQueryFilter<I_M_ReceiptSchedule> userSelectionFilter)\n+\t{\n+\t\tfinal IQueryBuilder<I_M_ReceiptSchedule> queryBuilder = queryBL\n+\t\t\t\t.createQueryBuilder(I_M_ReceiptSchedule.class, ctx, ITrx.TRXNAME_None)\n+\t\t\t\t.filter(userSelectionFilter)\n+\t\t\t\t.addEqualsFilter(I_M_ReceiptSchedule.COLUMNNAME_Processed, false)\n+\t\t\t\t.addOnlyActiveRecordsFilter()\n+\t\t\t\t.addOnlyContextClient();\n+\n+\t\treturn queryBuilder;\n+\t}\n+\n+\t@Override\n+\tpublic boolean existsExportedReceiptScheduleForOrder(final @NonNull OrderId orderId)\n+\t{\n+\t\treturn queryBL\n+\t\t\t\t.createQueryBuilder(I_M_ReceiptSchedule.class)\n+\t\t\t\t.addOnlyActiveRecordsFilter()\n+\t\t\t\t.addEqualsFilter(I_M_ReceiptSchedule.COLUMNNAME_C_Order_ID, orderId)\n+\t\t\t\t.addEqualsFilter(I_M_ReceiptSchedule.COLUMNNAME_Processed, false)\n+\t\t\t\t.addInArrayFilter(I_M_ReceiptSchedule.COLUMNNAME_ExportStatus, APIExportStatus.EXPORTED_STATES)\n+\t\t\t\t.create()\n+\t\t\t\t.anyMatch();\n+\t}\n+\n+\t@Override\n+\tpublic void updateExportStatus(final String exportStatus, final PInstanceId pinstanceId)\n+\t{\n+\t\tupdateColumnForSelection(\n+\t\t\t\tI_M_ReceiptSchedule.COLUMNNAME_ExportStatus,\n+\t\t\t\texportStatus,\n+\t\t\t\tfalse /* updateOnlyIfNull */,\n+\t\t\t\tpinstanceId\n+\t\t);\n+\t}\n+\n+\t/**\n+\t * Mass-update a given shipment schedule column.\n+\t * <p>\n+\t * If there were any changes and the invalidate parameter is on true, those shipment schedules will be invalidated.\n+\t *\n+\t * @param inoutCandidateColumnName {@link I_M_ReceiptSchedule}'s column to update\n+\t * @param value                    value to set (you can also use {@link ModelColumnNameValue})\n+\t * @param updateOnlyIfNull         if true then it will update only if column value is null (not set)\n+\t * @param selectionId              ShipmentSchedule selection (AD_PInstance_ID)\n+\t * @param trxName\n+\t */\n+\tprivate final <ValueType> void updateColumnForSelection(\n+\t\t\tfinal String inoutCandidateColumnName,\n+\t\t\tfinal ValueType value,\n+\t\t\tfinal boolean updateOnlyIfNull,\n+\t\t\tfinal PInstanceId selectionId\n+\t)\n+\t{\n+\t\t//\n+\t\t// Create the selection which we will need to update\n+\t\tfinal IQueryBuilder<I_M_ReceiptSchedule> selectionQueryBuilder = queryBL\n+\t\t\t\t.createQueryBuilder(I_M_ReceiptSchedule.class)\n+\t\t\t\t.setOnlySelection(selectionId)\n+\t\t\t\t.addEqualsFilter(I_M_ReceiptSchedule.COLUMNNAME_Processed, false) // do not touch the processed shipment schedules\n+\t\t\t\t;\n+\n+\t\tif (updateOnlyIfNull)\n+\t\t{\n+\t\t\tselectionQueryBuilder.addEqualsFilter(inoutCandidateColumnName, null);\n+\t\t}\n+\t\tfinal PInstanceId selectionToUpdateId = selectionQueryBuilder.create().createSelection();\n+\t\tif (selectionToUpdateId == null)\n+\t\t{\n+\t\t\t// nothing to update\n+\t\t\treturn;\n+\t\t}\n+\n+\t\t//\n+\t\t// Update our new selection\n+\t\tfinal int countUpdated = queryBL.createQueryBuilder(I_M_ReceiptSchedule.class)\n+\t\t\t\t.setOnlySelection(selectionToUpdateId)\n+\t\t\t\t.create()\n+\t\t\t\t.updateDirectly()\n+\t\t\t\t.addSetColumnValue(inoutCandidateColumnName, value)\n+\t\t\t\t.execute();\n+\n+\t\t//\n+\t\t// Cache invalidate\n+\t\t// We have to do this even if invalidate=false\n+\t\tcacheInvalidateBySelectionId(selectionToUpdateId, countUpdated);\n+\t}\n+\n+\tprivate void cacheInvalidateBySelectionId(\n+\t\t\t@NonNull final PInstanceId selectionId,\n+\t\t\tfinal long estimatedSize)\n+\t{\n+\t\tfinal CacheInvalidateMultiRequest request;\n+\t\tif (estimatedSize < 0)\n+\t\t{\n+\t\t\t// unknown estimated size\n+\t\t\trequest = CacheInvalidateMultiRequest.allRecordsForTable(I_M_ReceiptSchedule.Table_Name);\n+\t\t}\n+\t\telse if (estimatedSize == 0)\n+\t\t{\n+\t\t\t// no records\n+\t\t\t// unknown estimated size\n+\t\t\trequest = null;\n+\t\t}\n+\t\telse if (estimatedSize <= CACHE_INVALIDATE_ALL_THRESHOLD)\n+\t\t{\n+\t\t\t// relatively small amount of records\n+\t\t\t// => fetch and reset individually\n+\t\t\tfinal ImmutableSet<ReceiptScheduleId> shipmentScheduleIds = queryBL.createQueryBuilder(I_M_ReceiptSchedule.class)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc13e8989ce94e620802e16398eb7a830605cf9a"}, "originalPosition": 162}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1328, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}