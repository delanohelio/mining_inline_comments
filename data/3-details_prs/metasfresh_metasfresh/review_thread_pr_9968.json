{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg5MDk0MDcx", "number": 9968, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQxMDozODoyMlrOEk6dZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQxMjoxOTo0MVrOEk8klg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3MTQxOTg4OnYy", "diffSide": "RIGHT", "path": "backend/de.metas.business/src/main/java/de/metas/product/impl/ProductPlanningSchemaBL.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQxMDozODoyMlrOHUHnLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQxMToxNjoyOFrOHUIxzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg1ODI4NA==", "bodyText": "it's not a great deal, just asking; do you know if we can't teach intellij to put the annotations before the final?", "url": "https://github.com/metasfresh/metasfresh/pull/9968#discussion_r490858284", "createdAt": "2020-09-18T10:38:22Z", "author": {"login": "metas-ts"}, "path": "backend/de.metas.business/src/main/java/de/metas/product/impl/ProductPlanningSchemaBL.java", "diffHunk": "@@ -61,28 +65,30 @@\n \t\t\t\t.collect(ImmutableList.toImmutableList());\n \t}\n \n-\tprivate List<I_PP_Product_Planning> createOrUpdateProductPlanningsForProductSelector(final I_M_Product product)\n+\tprivate List<I_PP_Product_Planning> createOrUpdateProductPlanningsForProductSelector(@NonNull final I_M_Product product)\n \t{\n \t\tfinal ProductId productId = ProductId.ofRepoId(product.getM_Product_ID());\n+\t\tfinal OrgId orgId = OrgId.ofRepoId(product.getAD_Org_ID());\n \t\tfinal ProductPlanningSchemaSelector selector = ProductPlanningSchemaSelector.ofNullableCode(product.getM_ProductPlanningSchema_Selector());\n \t\tif (selector == null)\n \t\t{\n \t\t\treturn ImmutableList.of();\n \t\t}\n \n-\t\treturn createOrUpdateProductPlanningsForSelector(productId, selector);\n+\t\treturn createOrUpdateProductPlanningsForSelector(productId, orgId, selector);\n \t}\n \n \t@Override\n \tpublic List<I_PP_Product_Planning> createOrUpdateProductPlanningsForSelector(\n-\t\t\t@NonNull final ProductId productId,\n-\t\t\t@NonNull final ProductPlanningSchemaSelector selector)\n+\t\t\tfinal @NonNull ProductId productId,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "163afedbb41d01d8b1f5251803bca2ae46bd39f5"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg3NzM5MA==", "bodyText": "unfortunately not available, but there is a feature request (with duplicates): https://youtrack.jetbrains.com/issue/IDEA-168035", "url": "https://github.com/metasfresh/metasfresh/pull/9968#discussion_r490877390", "createdAt": "2020-09-18T11:16:28Z", "author": {"login": "TheBestPessimist"}, "path": "backend/de.metas.business/src/main/java/de/metas/product/impl/ProductPlanningSchemaBL.java", "diffHunk": "@@ -61,28 +65,30 @@\n \t\t\t\t.collect(ImmutableList.toImmutableList());\n \t}\n \n-\tprivate List<I_PP_Product_Planning> createOrUpdateProductPlanningsForProductSelector(final I_M_Product product)\n+\tprivate List<I_PP_Product_Planning> createOrUpdateProductPlanningsForProductSelector(@NonNull final I_M_Product product)\n \t{\n \t\tfinal ProductId productId = ProductId.ofRepoId(product.getM_Product_ID());\n+\t\tfinal OrgId orgId = OrgId.ofRepoId(product.getAD_Org_ID());\n \t\tfinal ProductPlanningSchemaSelector selector = ProductPlanningSchemaSelector.ofNullableCode(product.getM_ProductPlanningSchema_Selector());\n \t\tif (selector == null)\n \t\t{\n \t\t\treturn ImmutableList.of();\n \t\t}\n \n-\t\treturn createOrUpdateProductPlanningsForSelector(productId, selector);\n+\t\treturn createOrUpdateProductPlanningsForSelector(productId, orgId, selector);\n \t}\n \n \t@Override\n \tpublic List<I_PP_Product_Planning> createOrUpdateProductPlanningsForSelector(\n-\t\t\t@NonNull final ProductId productId,\n-\t\t\t@NonNull final ProductPlanningSchemaSelector selector)\n+\t\t\tfinal @NonNull ProductId productId,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg1ODI4NA=="}, "originalCommit": {"oid": "163afedbb41d01d8b1f5251803bca2ae46bd39f5"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3MTU0NjMyOnYy", "diffSide": "RIGHT", "path": "backend/de.metas.business/src/main/java-legacy/org/compiere/model/MProduct.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQxMToxNTo0MFrOHUIv_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQwODo1Njo1OFrOHVGUJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg3NjkyNQ==", "bodyText": "i would suggest to extract that code in an model interceptor.\nAs a side benefit we will not wire\"private final IProductPlanningSchemaBL productPlanningSchemaBL\"  service each time a product is loaded.", "url": "https://github.com/metasfresh/metasfresh/pull/9968#discussion_r490876925", "createdAt": "2020-09-18T11:15:40Z", "author": {"login": "teosarca"}, "path": "backend/de.metas.business/src/main/java-legacy/org/compiere/model/MProduct.java", "diffHunk": "@@ -335,9 +342,9 @@ private void createOrUpdateProductPlanningsForSelector()\n \t\t}\n \t\t\n \t\tfinal ProductId productId = ProductId.ofRepoId(getM_Product_ID());\n+\t\tfinal OrgId orgId = OrgId.ofRepoId(getAD_Org_ID());\n \n-\t\tfinal IProductPlanningSchemaBL productPlanningSchemaBL = Services.get(IProductPlanningSchemaBL.class);\n-\t\tproductPlanningSchemaBL.createOrUpdateProductPlanningsForSelector(productId, productPlanningSchemaSelector);\n+\t\tproductPlanningSchemaBL.createOrUpdateProductPlanningsForSelector(productId, orgId, productPlanningSchemaSelector);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3f7f1987eaf6b846d940827120cc798dd958b7e"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg3ODgwNQ==", "bodyText": "This code is called only once after the product was created, afaiu from\n\t@Override\n    protected boolean MProduct.afterSave(boolean newRecord, boolean success) {\n    [...]\n\tif(newRecord)\n\t\t{\n\t\t\tcreateOrUpdateProductPlanningsForSelector();\n\t\t}\nso isnt' this already in Product's model interceptor?\n\nAs a side benefit we will not wire\"private final IProductPlanningSchemaBL productPlanningSchemaBL\" service each time a product is loaded.\n\nShould i make productPlanningSchemaBL local to the function instead of a class field?", "url": "https://github.com/metasfresh/metasfresh/pull/9968#discussion_r490878805", "createdAt": "2020-09-18T11:19:35Z", "author": {"login": "TheBestPessimist"}, "path": "backend/de.metas.business/src/main/java-legacy/org/compiere/model/MProduct.java", "diffHunk": "@@ -335,9 +342,9 @@ private void createOrUpdateProductPlanningsForSelector()\n \t\t}\n \t\t\n \t\tfinal ProductId productId = ProductId.ofRepoId(getM_Product_ID());\n+\t\tfinal OrgId orgId = OrgId.ofRepoId(getAD_Org_ID());\n \n-\t\tfinal IProductPlanningSchemaBL productPlanningSchemaBL = Services.get(IProductPlanningSchemaBL.class);\n-\t\tproductPlanningSchemaBL.createOrUpdateProductPlanningsForSelector(productId, productPlanningSchemaSelector);\n+\t\tproductPlanningSchemaBL.createOrUpdateProductPlanningsForSelector(productId, orgId, productPlanningSchemaSelector);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg3NjkyNQ=="}, "originalCommit": {"oid": "a3f7f1987eaf6b846d940827120cc798dd958b7e"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTg4NTYwNA==", "bodyText": "done", "url": "https://github.com/metasfresh/metasfresh/pull/9968#discussion_r491885604", "createdAt": "2020-09-21T08:56:58Z", "author": {"login": "TheBestPessimist"}, "path": "backend/de.metas.business/src/main/java-legacy/org/compiere/model/MProduct.java", "diffHunk": "@@ -335,9 +342,9 @@ private void createOrUpdateProductPlanningsForSelector()\n \t\t}\n \t\t\n \t\tfinal ProductId productId = ProductId.ofRepoId(getM_Product_ID());\n+\t\tfinal OrgId orgId = OrgId.ofRepoId(getAD_Org_ID());\n \n-\t\tfinal IProductPlanningSchemaBL productPlanningSchemaBL = Services.get(IProductPlanningSchemaBL.class);\n-\t\tproductPlanningSchemaBL.createOrUpdateProductPlanningsForSelector(productId, productPlanningSchemaSelector);\n+\t\tproductPlanningSchemaBL.createOrUpdateProductPlanningsForSelector(productId, orgId, productPlanningSchemaSelector);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg3NjkyNQ=="}, "originalCommit": {"oid": "a3f7f1987eaf6b846d940827120cc798dd958b7e"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3MTU4MDQ1OnYy", "diffSide": "RIGHT", "path": "backend/de.metas.business/src/main/java/de/metas/product/impl/ProductPlanningSchemaDAO.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQxMToyNTo1MlrOHUJEBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxMDo1Mzo1NFrOHVKWdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg4MjA1Mw==", "bodyText": "this is too fragile IMHO", "url": "https://github.com/metasfresh/metasfresh/pull/9968#discussion_r490882053", "createdAt": "2020-09-18T11:25:52Z", "author": {"login": "teosarca"}, "path": "backend/de.metas.business/src/main/java/de/metas/product/impl/ProductPlanningSchemaDAO.java", "diffHunk": "@@ -70,23 +80,82 @@ public static ProductPlanningSchema getById(@NonNull final ProductPlanningSchema\n \t}\n \n \t/**\n-\t * @return All the active Product Planning Schema entries with the given Product Planning Schema Selector\n+\t * Returns the Product Planning Schema entries with the given Product Planning Schema Selector and Org. If the org does not match, fallback to org *.\n+\t * If there are 2 identical Product Planning Schemas, one for orgParam and one for *, we shall return only the one for orgParam.\n \t */\n-\tpublic static List<ProductPlanningSchema> retrieveSchemasForSelector(\n-\t\t\t@NonNull final ProductPlanningSchemaSelector productPlanningSchemaSelector)\n+\t@NonNull\n+\tpublic static ImmutableSet<ProductPlanningSchema> retrieveSchemasForSelectorAndOrg(\n+\t\t\t@NonNull final ProductPlanningSchemaSelector productPlanningSchemaSelector,\n+\t\t\t@NonNull final OrgId orgId)\n \t{\n-\t\treturn Services.get(IQueryBL.class)\n+\t\tfinal ImmutableMap<ProductPlanningSchemaId, ProductPlanningSchema> schemasWithDuplicateOrgs = Services.get(IQueryBL.class)\n \t\t\t\t.createQueryBuilder(I_M_Product_PlanningSchema.class)\n \t\t\t\t.addOnlyActiveRecordsFilter()\n \t\t\t\t.addOnlyContextClient()\n \t\t\t\t.addEqualsFilter(I_M_Product_PlanningSchema.COLUMNNAME_M_ProductPlanningSchema_Selector, productPlanningSchemaSelector)\n+\t\t\t\t.addInArrayFilter(I_M_Product_PlanningSchema.COLUMNNAME_AD_Org_ID, orgId, OrgId.ANY)\n \t\t\t\t.create()\n+\t\t\t\t.list()\n \t\t\t\t.stream()\n-\t\t\t\t.map(record -> toProductPlanningSchema(record))\n-\t\t\t\t.collect(ImmutableList.toImmutableList());\n+\t\t\t\t.map(ProductPlanningSchemaDAO::toProductPlanningSchema)\n+\t\t\t\t.collect(ImmutableMap.toImmutableMap(ProductPlanningSchema::getId, Function.identity()));\n+\n+\t\t// remove duplicates where everything is the same, except the org, and repoId\n+\t\t// Technical: I am using the set.add property that if an object already exists in a set, the duplicate will not be inserted but skipped.\n+\t\tfinal Set<ProductPlanningSchemaIgnoringOrgAndId> schemasNoDuplicateOrgs = schemasWithDuplicateOrgs.values().stream()\n+\t\t\t\t.sorted(Comparator.comparing(ProductPlanningSchema::getOrgId).reversed()) // * org remains last\n+\t\t\t\t.map(ProductPlanningSchemaIgnoringOrgAndId::new)\n+\t\t\t\t.collect(GuavaCollectors.toImmutableSet());\n+\n+\t\tfinal ImmutableSet.Builder<ProductPlanningSchema> result = ImmutableSet.builder();\n+\t\tfor (final ProductPlanningSchemaIgnoringOrgAndId s : schemasNoDuplicateOrgs)\n+\t\t{\n+\t\t\tresult.add(schemasWithDuplicateOrgs.get(s.getSchema().getId()));\n+\t\t}\n+\n+\t\treturn result.build();\n \t}\n \n-\tprivate static ProductPlanningSchema toProductPlanningSchema(final I_M_Product_PlanningSchema record)\n+\t/**\n+\t * Used as a delegate to ProductPlanningSchema, to calculate if 2 schemas are equals, ignoring only their ID and Org\n+\t */\n+\n+\t@Value\n+\tprivate static class ProductPlanningSchemaIgnoringOrgAndId\n+\t{\n+\t\tProductPlanningSchema schema;\n+\n+\t\t@Override\n+\t\tpublic boolean equals(final Object o)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3f7f1987eaf6b846d940827120cc798dd958b7e"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDkwNDYwOQ==", "bodyText": "what do you mean? Why is it fragile?", "url": "https://github.com/metasfresh/metasfresh/pull/9968#discussion_r490904609", "createdAt": "2020-09-18T12:08:11Z", "author": {"login": "TheBestPessimist"}, "path": "backend/de.metas.business/src/main/java/de/metas/product/impl/ProductPlanningSchemaDAO.java", "diffHunk": "@@ -70,23 +80,82 @@ public static ProductPlanningSchema getById(@NonNull final ProductPlanningSchema\n \t}\n \n \t/**\n-\t * @return All the active Product Planning Schema entries with the given Product Planning Schema Selector\n+\t * Returns the Product Planning Schema entries with the given Product Planning Schema Selector and Org. If the org does not match, fallback to org *.\n+\t * If there are 2 identical Product Planning Schemas, one for orgParam and one for *, we shall return only the one for orgParam.\n \t */\n-\tpublic static List<ProductPlanningSchema> retrieveSchemasForSelector(\n-\t\t\t@NonNull final ProductPlanningSchemaSelector productPlanningSchemaSelector)\n+\t@NonNull\n+\tpublic static ImmutableSet<ProductPlanningSchema> retrieveSchemasForSelectorAndOrg(\n+\t\t\t@NonNull final ProductPlanningSchemaSelector productPlanningSchemaSelector,\n+\t\t\t@NonNull final OrgId orgId)\n \t{\n-\t\treturn Services.get(IQueryBL.class)\n+\t\tfinal ImmutableMap<ProductPlanningSchemaId, ProductPlanningSchema> schemasWithDuplicateOrgs = Services.get(IQueryBL.class)\n \t\t\t\t.createQueryBuilder(I_M_Product_PlanningSchema.class)\n \t\t\t\t.addOnlyActiveRecordsFilter()\n \t\t\t\t.addOnlyContextClient()\n \t\t\t\t.addEqualsFilter(I_M_Product_PlanningSchema.COLUMNNAME_M_ProductPlanningSchema_Selector, productPlanningSchemaSelector)\n+\t\t\t\t.addInArrayFilter(I_M_Product_PlanningSchema.COLUMNNAME_AD_Org_ID, orgId, OrgId.ANY)\n \t\t\t\t.create()\n+\t\t\t\t.list()\n \t\t\t\t.stream()\n-\t\t\t\t.map(record -> toProductPlanningSchema(record))\n-\t\t\t\t.collect(ImmutableList.toImmutableList());\n+\t\t\t\t.map(ProductPlanningSchemaDAO::toProductPlanningSchema)\n+\t\t\t\t.collect(ImmutableMap.toImmutableMap(ProductPlanningSchema::getId, Function.identity()));\n+\n+\t\t// remove duplicates where everything is the same, except the org, and repoId\n+\t\t// Technical: I am using the set.add property that if an object already exists in a set, the duplicate will not be inserted but skipped.\n+\t\tfinal Set<ProductPlanningSchemaIgnoringOrgAndId> schemasNoDuplicateOrgs = schemasWithDuplicateOrgs.values().stream()\n+\t\t\t\t.sorted(Comparator.comparing(ProductPlanningSchema::getOrgId).reversed()) // * org remains last\n+\t\t\t\t.map(ProductPlanningSchemaIgnoringOrgAndId::new)\n+\t\t\t\t.collect(GuavaCollectors.toImmutableSet());\n+\n+\t\tfinal ImmutableSet.Builder<ProductPlanningSchema> result = ImmutableSet.builder();\n+\t\tfor (final ProductPlanningSchemaIgnoringOrgAndId s : schemasNoDuplicateOrgs)\n+\t\t{\n+\t\t\tresult.add(schemasWithDuplicateOrgs.get(s.getSchema().getId()));\n+\t\t}\n+\n+\t\treturn result.build();\n \t}\n \n-\tprivate static ProductPlanningSchema toProductPlanningSchema(final I_M_Product_PlanningSchema record)\n+\t/**\n+\t * Used as a delegate to ProductPlanningSchema, to calculate if 2 schemas are equals, ignoring only their ID and Org\n+\t */\n+\n+\t@Value\n+\tprivate static class ProductPlanningSchemaIgnoringOrgAndId\n+\t{\n+\t\tProductPlanningSchema schema;\n+\n+\t\t@Override\n+\t\tpublic boolean equals(final Object o)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg4MjA1Mw=="}, "originalCommit": {"oid": "a3f7f1987eaf6b846d940827120cc798dd958b7e"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk1MTczNA==", "bodyText": "updated after functional change.", "url": "https://github.com/metasfresh/metasfresh/pull/9968#discussion_r491951734", "createdAt": "2020-09-21T10:53:54Z", "author": {"login": "TheBestPessimist"}, "path": "backend/de.metas.business/src/main/java/de/metas/product/impl/ProductPlanningSchemaDAO.java", "diffHunk": "@@ -70,23 +80,82 @@ public static ProductPlanningSchema getById(@NonNull final ProductPlanningSchema\n \t}\n \n \t/**\n-\t * @return All the active Product Planning Schema entries with the given Product Planning Schema Selector\n+\t * Returns the Product Planning Schema entries with the given Product Planning Schema Selector and Org. If the org does not match, fallback to org *.\n+\t * If there are 2 identical Product Planning Schemas, one for orgParam and one for *, we shall return only the one for orgParam.\n \t */\n-\tpublic static List<ProductPlanningSchema> retrieveSchemasForSelector(\n-\t\t\t@NonNull final ProductPlanningSchemaSelector productPlanningSchemaSelector)\n+\t@NonNull\n+\tpublic static ImmutableSet<ProductPlanningSchema> retrieveSchemasForSelectorAndOrg(\n+\t\t\t@NonNull final ProductPlanningSchemaSelector productPlanningSchemaSelector,\n+\t\t\t@NonNull final OrgId orgId)\n \t{\n-\t\treturn Services.get(IQueryBL.class)\n+\t\tfinal ImmutableMap<ProductPlanningSchemaId, ProductPlanningSchema> schemasWithDuplicateOrgs = Services.get(IQueryBL.class)\n \t\t\t\t.createQueryBuilder(I_M_Product_PlanningSchema.class)\n \t\t\t\t.addOnlyActiveRecordsFilter()\n \t\t\t\t.addOnlyContextClient()\n \t\t\t\t.addEqualsFilter(I_M_Product_PlanningSchema.COLUMNNAME_M_ProductPlanningSchema_Selector, productPlanningSchemaSelector)\n+\t\t\t\t.addInArrayFilter(I_M_Product_PlanningSchema.COLUMNNAME_AD_Org_ID, orgId, OrgId.ANY)\n \t\t\t\t.create()\n+\t\t\t\t.list()\n \t\t\t\t.stream()\n-\t\t\t\t.map(record -> toProductPlanningSchema(record))\n-\t\t\t\t.collect(ImmutableList.toImmutableList());\n+\t\t\t\t.map(ProductPlanningSchemaDAO::toProductPlanningSchema)\n+\t\t\t\t.collect(ImmutableMap.toImmutableMap(ProductPlanningSchema::getId, Function.identity()));\n+\n+\t\t// remove duplicates where everything is the same, except the org, and repoId\n+\t\t// Technical: I am using the set.add property that if an object already exists in a set, the duplicate will not be inserted but skipped.\n+\t\tfinal Set<ProductPlanningSchemaIgnoringOrgAndId> schemasNoDuplicateOrgs = schemasWithDuplicateOrgs.values().stream()\n+\t\t\t\t.sorted(Comparator.comparing(ProductPlanningSchema::getOrgId).reversed()) // * org remains last\n+\t\t\t\t.map(ProductPlanningSchemaIgnoringOrgAndId::new)\n+\t\t\t\t.collect(GuavaCollectors.toImmutableSet());\n+\n+\t\tfinal ImmutableSet.Builder<ProductPlanningSchema> result = ImmutableSet.builder();\n+\t\tfor (final ProductPlanningSchemaIgnoringOrgAndId s : schemasNoDuplicateOrgs)\n+\t\t{\n+\t\t\tresult.add(schemasWithDuplicateOrgs.get(s.getSchema().getId()));\n+\t\t}\n+\n+\t\treturn result.build();\n \t}\n \n-\tprivate static ProductPlanningSchema toProductPlanningSchema(final I_M_Product_PlanningSchema record)\n+\t/**\n+\t * Used as a delegate to ProductPlanningSchema, to calculate if 2 schemas are equals, ignoring only their ID and Org\n+\t */\n+\n+\t@Value\n+\tprivate static class ProductPlanningSchemaIgnoringOrgAndId\n+\t{\n+\t\tProductPlanningSchema schema;\n+\n+\t\t@Override\n+\t\tpublic boolean equals(final Object o)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg4MjA1Mw=="}, "originalCommit": {"oid": "a3f7f1987eaf6b846d940827120cc798dd958b7e"}, "originalPosition": 146}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3MTc2NTk4OnYy", "diffSide": "RIGHT", "path": "backend/de.metas.business/src/main/java/de/metas/product/impl/ProductPlanningSchemaDAO.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQxMjoxOTo0MVrOHUKxvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQwODo0ODowNVrOHVGATA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDkxMDE0Mg==", "bodyText": "consider moving this method to ProductDAO", "url": "https://github.com/metasfresh/metasfresh/pull/9968#discussion_r490910142", "createdAt": "2020-09-18T12:19:41Z", "author": {"login": "teosarca"}, "path": "backend/de.metas.business/src/main/java/de/metas/product/impl/ProductPlanningSchemaDAO.java", "diffHunk": "@@ -154,7 +223,7 @@ public static void save(@NonNull final ProductPlanningSchema schema)\n \t/**\n \t * @return All the active products with the given product planning schema selector\n \t */\n-\tpublic static Set<ProductId> retrieveProductIdsForSchemaSelector(\n+\tpublic static Set<ImmutablePair<ProductId, OrgId>> retrieveProductIdsForSchemaSelector(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3f7f1987eaf6b846d940827120cc798dd958b7e"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTg4MDUyNA==", "bodyText": "done", "url": "https://github.com/metasfresh/metasfresh/pull/9968#discussion_r491880524", "createdAt": "2020-09-21T08:48:05Z", "author": {"login": "TheBestPessimist"}, "path": "backend/de.metas.business/src/main/java/de/metas/product/impl/ProductPlanningSchemaDAO.java", "diffHunk": "@@ -154,7 +223,7 @@ public static void save(@NonNull final ProductPlanningSchema schema)\n \t/**\n \t * @return All the active products with the given product planning schema selector\n \t */\n-\tpublic static Set<ProductId> retrieveProductIdsForSchemaSelector(\n+\tpublic static Set<ImmutablePair<ProductId, OrgId>> retrieveProductIdsForSchemaSelector(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDkxMDE0Mg=="}, "originalCommit": {"oid": "a3f7f1987eaf6b846d940827120cc798dd958b7e"}, "originalPosition": 184}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1303, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}