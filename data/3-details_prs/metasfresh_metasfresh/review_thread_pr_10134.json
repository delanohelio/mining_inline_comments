{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA2OTYzODc0", "number": 10134, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwNzoyODo1MFrOExFflg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwNzo1NDoyMFrOExGB6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5OTA1Njg2OnYy", "diffSide": "RIGHT", "path": "frontend/src/components/table/TableRow.js", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwNzoyODo1MFrOHnB7DQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwNzoyODo1MFrOHnB7DQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY4ODAxMw==", "bodyText": "const newState = {   activeCellName: property  };", "url": "https://github.com/metasfresh/metasfresh/pull/10134#discussion_r510688013", "createdAt": "2020-10-23T07:28:50Z", "author": {"login": "petrican"}, "path": "frontend/src/components/table/TableRow.js", "diffHunk": "@@ -400,22 +408,21 @@ class TableRow extends PureComponent {\n    * @param {function} [cb] - callback function\n    */\n   _focusCell = (property, cb) => {\n-    const { activeCell } = this.state;\n+    const { activeCell, activeCellName } = this.state;\n     const elem = document.activeElement;\n \n-    if (\n-      (activeCell !== elem && !elem.className.includes('js-input-field')) ||\n-      cb\n-    ) {\n-      this.setState(\n-        {\n-          activeCell: elem,\n-          activeCellName: property,\n-        },\n-        () => {\n-          cb && cb();\n-        }\n-      );\n+    if (property !== activeCellName || cb) {\n+      const newState = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe016765f9489e37e751eb58465acf112728d7e3"}, "originalPosition": 122}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5OTA2NTY4OnYy", "diffSide": "RIGHT", "path": "frontend/src/components/widget/Lookup/Lookup.js", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwNzozMToyM1rOHnCAUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwNzozMToyM1rOHnCAUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY4OTM2MA==", "bodyText": "rm debug comments", "url": "https://github.com/metasfresh/metasfresh/pull/10134#discussion_r510689360", "createdAt": "2020-10-23T07:31:23Z", "author": {"login": "petrican"}, "path": "frontend/src/components/widget/Lookup/Lookup.js", "diffHunk": "@@ -238,6 +238,8 @@ class Lookup extends Component {\n   };\n \n   handleListBlur = (field) => {\n+    // console.log('handleListBlur: ', field)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe016765f9489e37e751eb58465acf112728d7e3"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5OTA3MTE5OnYy", "diffSide": "RIGHT", "path": "frontend/src/components/widget/MasterWidget.js", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwNzozMzoxMlrOHnCDqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwNzozMzoxMlrOHnCDqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY5MDIxNg==", "bodyText": "componentDidMount = () => (this.mounted = true);", "url": "https://github.com/metasfresh/metasfresh/pull/10134#discussion_r510690216", "createdAt": "2020-10-23T07:33:12Z", "author": {"login": "petrican"}, "path": "frontend/src/components/widget/MasterWidget.js", "diffHunk": "@@ -34,6 +36,14 @@ class MasterWidget extends PureComponent {\n     };\n   }\n \n+  componentDidMount = () => {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe016765f9489e37e751eb58465acf112728d7e3"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5OTA3MjUzOnYy", "diffSide": "RIGHT", "path": "frontend/src/components/widget/MasterWidget.js", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwNzozMzozN1rOHnCEbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwNzozMzozN1rOHnCEbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY5MDQxMw==", "bodyText": "componentWillMount = () => (this.mounted = false);", "url": "https://github.com/metasfresh/metasfresh/pull/10134#discussion_r510690413", "createdAt": "2020-10-23T07:33:37Z", "author": {"login": "petrican"}, "path": "frontend/src/components/widget/MasterWidget.js", "diffHunk": "@@ -34,6 +36,14 @@ class MasterWidget extends PureComponent {\n     };\n   }\n \n+  componentDidMount = () => {\n+    this.mounted = true;\n+  };\n+\n+  componentWillUnmount = () => {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe016765f9489e37e751eb58465acf112728d7e3"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5OTA3NzA2OnYy", "diffSide": "RIGHT", "path": "frontend/src/components/widget/MasterWidget.js", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwNzozNTowMVrOHnCHOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwNzozNTowMVrOHnCHOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY5MTEyOA==", "bodyText": "handleBackDropLock && handleBackdropLock(val);", "url": "https://github.com/metasfresh/metasfresh/pull/10134#discussion_r510691128", "createdAt": "2020-10-23T07:35:01Z", "author": {"login": "petrican"}, "path": "frontend/src/components/widget/MasterWidget.js", "diffHunk": "@@ -232,24 +244,30 @@ class MasterWidget extends PureComponent {\n     onBlurWidget && onBlurWidget(fieldName);\n   };\n \n-  /**\n-   * @method render\n-   * @summary ToDo: Describe the method.\n-   */\n+  handleFocus = () => this.handleFocusFn(true);\n+\n+  handleBlur = () => this.handleFocusFn(false);\n+\n+  handleFocusFn = (val) => {\n+    const { handleBackdropLock } = this.props;\n+\n+    if (handleBackdropLock) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe016765f9489e37e751eb58465acf112728d7e3"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5OTA5NTIwOnYy", "diffSide": "RIGHT", "path": "frontend/src/components/widget/RawWidget.js", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwNzo0MDoyNlrOHnCSBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwNzo0MDoyNlrOHnCSBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY5Mzg5Mw==", "bodyText": "This is dup. See line 183-185. I would add this in a function", "url": "https://github.com/metasfresh/metasfresh/pull/10134#discussion_r510693893", "createdAt": "2020-10-23T07:40:26Z", "author": {"login": "petrican"}, "path": "frontend/src/components/widget/RawWidget.js", "diffHunk": "@@ -210,22 +195,30 @@ export class RawWidget extends Component {\n   updateTypedCharacters = (typedText) => {\n     const { fieldName } = this.props;\n     let existingCharsTyped = { ...this.state.charsTyped };\n+\n     existingCharsTyped[fieldName] = typedText.length;\n     this.setState({ charsTyped: existingCharsTyped });\n-    return true;\n   };\n \n   /**\n    * @method handleKeyDown\n    * @summary key handler for the widgets. For number fields we're suppressing up/down\n    *          arrows to enable table row navigation\n-   * @param {*} e\n-   * @param {*} property\n-   * @param {*} value\n+   * @param {*} e - DOM event\n    */\n-  handleKeyDown = (e, property, value) => {\n-    const { lastFormField, widgetType, closeTableField } = this.props;\n+  handleKeyDown = (e) => {\n+    const {\n+      lastFormField,\n+      widgetType,\n+      filterWidget,\n+      fields,\n+      closeTableField,\n+    } = this.props;\n+    const value = e.target.value;\n     const { key } = e;\n+    const widgetField = filterWidget", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe016765f9489e37e751eb58465acf112728d7e3"}, "originalPosition": 250}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5OTA5ODcxOnYy", "diffSide": "RIGHT", "path": "frontend/src/components/widget/RawWidget.js", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwNzo0MToyNlrOHnCUGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwNzo0MToyNlrOHnCUGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY5NDQyNw==", "bodyText": "return (key === 'Tab') ? this.handleBlur(e) : this.handlePatch(widgetField, value);", "url": "https://github.com/metasfresh/metasfresh/pull/10134#discussion_r510694427", "createdAt": "2020-10-23T07:41:26Z", "author": {"login": "petrican"}, "path": "frontend/src/components/widget/RawWidget.js", "diffHunk": "@@ -244,53 +237,37 @@ export class RawWidget extends Component {\n       closeTableField();\n       e.preventDefault();\n \n-      this.handleBlur();\n-\n-      return this.handlePatch(property, value, null, null, true);\n+      return this.handlePatch(widgetField, value, null, null, true);\n     }\n \n     if ((key === 'Enter' || key === 'Tab') && !e.shiftKey) {\n       if (key === 'Enter' && !lastFormField) {\n         e.preventDefault();\n       }\n-      return this.handlePatch(property, value);\n+\n+      if (key === 'Tab') {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe016765f9489e37e751eb58465acf112728d7e3"}, "originalPosition": 272}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5OTEwMzEyOnYy", "diffSide": "RIGHT", "path": "frontend/src/components/widget/RawWidget.js", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwNzo0MjozNVrOHnCWtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwNzo0MjozNVrOHnCWtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY5NTA5Mg==", "bodyText": "here too I would use one single fnct with params to avoid dup code. Shrinks the overall file code", "url": "https://github.com/metasfresh/metasfresh/pull/10134#discussion_r510695092", "createdAt": "2020-10-23T07:42:35Z", "author": {"login": "petrican"}, "path": "frontend/src/components/widget/RawWidget.js", "diffHunk": "@@ -244,53 +237,37 @@ export class RawWidget extends Component {\n       closeTableField();\n       e.preventDefault();\n \n-      this.handleBlur();\n-\n-      return this.handlePatch(property, value, null, null, true);\n+      return this.handlePatch(widgetField, value, null, null, true);\n     }\n \n     if ((key === 'Enter' || key === 'Tab') && !e.shiftKey) {\n       if (key === 'Enter' && !lastFormField) {\n         e.preventDefault();\n       }\n-      return this.handlePatch(property, value);\n+\n+      if (key === 'Tab') {\n+        return this.handleBlur(e);\n+      } else {\n+        return this.handlePatch(widgetField, value);\n+      }\n     }\n   };\n \n   /**\n-   * @method willPatch\n-   * @summary Checks if the value has actually changed between what was cached before.\n-   * @param {*} property\n-   * @param {*} value\n-   * @param {*} valueTo\n+   * @method handleChange\n+   * @summary onChange event handler\n+   * @param {*} e - DOM event\n    */\n-  willPatch = (property, value, valueTo) => {\n-    const { widgetData } = this.props;\n-    const { cachedValue } = this.state;\n-\n-    // if there's no widget value, then nothing could've changed. Unless\n-    // it's a widget for actions (think ActionButton)\n-    const isValue =\n-      widgetData[0].value !== undefined ||\n-      (widgetData[0].status && widgetData[0].status.value !== undefined);\n-    let fieldData = widgetData.find((widget) => widget.field === property);\n-    if (!fieldData) {\n-      fieldData = widgetData[0];\n-    }\n-\n-    let allowPatching =\n-      (isValue &&\n-        (JSON.stringify(fieldData.value) != JSON.stringify(value) ||\n-          JSON.stringify(fieldData.valueTo) != JSON.stringify(valueTo))) ||\n-      JSON.stringify(cachedValue) != JSON.stringify(value) ||\n-      // clear field that had it's cachedValue nulled before\n-      (cachedValue === null && value === null);\n+  handleChange = (e) => {\n+    const { handleChange, filterWidget, fields } = this.props;\n+    const widgetField = filterWidget", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe016765f9489e37e751eb58465acf112728d7e3"}, "originalPosition": 313}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5OTExNDA5OnYy", "diffSide": "RIGHT", "path": "frontend/src/components/widget/RawWidget.js", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwNzo0NTo0M1rOHnCdOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwNzo0NTo0M1rOHnCdOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY5Njc2Mw==", "bodyText": "showErrorPopup = () => this.setState({ errorPopup: true });", "url": "https://github.com/metasfresh/metasfresh/pull/10134#discussion_r510696763", "createdAt": "2020-10-23T07:45:43Z", "author": {"login": "petrican"}, "path": "frontend/src/components/widget/RawWidget.js", "diffHunk": "@@ -353,19 +343,38 @@ export class RawWidget extends Component {\n   };\n \n   /**\n-   * @method handleErrorPopup\n-   * @summary ToDo: Describe the method.\n-   * @param {*} value\n+   * @method setWidgetType\n+   * @summary used for password fields, when user wants to reveal the typed password\n+   *\n+   * @param {string} type - toggles between text/password\n+   */\n+  setWidgetType = (type) => {\n+    this.rawWidget.type = type;\n+  };\n+\n+  /**\n+   * @method showErrorPopup\n+   * @summary shows error message on mouse over\n    */\n-  handleErrorPopup = (value) => {\n+  showErrorPopup = () => {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe016765f9489e37e751eb58465acf112728d7e3"}, "originalPosition": 373}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5OTExODgyOnYy", "diffSide": "RIGHT", "path": "frontend/src/components/widget/RawWidget.js", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwNzo0Njo1OFrOHnCgCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwNzo0Njo1OFrOHnCgCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY5NzQ4MQ==", "bodyText": "hideErrorPopup = () => this.setState({ errorPopup: false });", "url": "https://github.com/metasfresh/metasfresh/pull/10134#discussion_r510697481", "createdAt": "2020-10-23T07:46:58Z", "author": {"login": "petrican"}, "path": "frontend/src/components/widget/RawWidget.js", "diffHunk": "@@ -353,19 +343,38 @@ export class RawWidget extends Component {\n   };\n \n   /**\n-   * @method handleErrorPopup\n-   * @summary ToDo: Describe the method.\n-   * @param {*} value\n+   * @method setWidgetType\n+   * @summary used for password fields, when user wants to reveal the typed password\n+   *\n+   * @param {string} type - toggles between text/password\n+   */\n+  setWidgetType = (type) => {\n+    this.rawWidget.type = type;\n+  };\n+\n+  /**\n+   * @method showErrorPopup\n+   * @summary shows error message on mouse over\n    */\n-  handleErrorPopup = (value) => {\n+  showErrorPopup = () => {\n     this.setState({\n-      errorPopup: value,\n+      errorPopup: true,\n+    });\n+  };\n+\n+  /**\n+   * @method hideErrorPopup\n+   * @summary hides error message on mouse out\n+   */\n+  hideErrorPopup = () => {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe016765f9489e37e751eb58465acf112728d7e3"}, "originalPosition": 384}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5OTE0NDcyOnYy", "diffSide": "RIGHT", "path": "frontend/src/components/widget/WidgetRenderer.js", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwNzo1NDoyMFrOHnCv2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwODoxNzo1OFrOHnDiSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDcwMTUzMA==", "bodyText": "I would put this in a separate  component", "url": "https://github.com/metasfresh/metasfresh/pull/10134#discussion_r510701530", "createdAt": "2020-10-23T07:54:20Z", "author": {"login": "petrican"}, "path": "frontend/src/components/widget/WidgetRenderer.js", "diffHunk": "@@ -0,0 +1,640 @@\n+import React, { Fragment, PureComponent } from 'react';\n+import Moment from 'moment';\n+import classnames from 'classnames';\n+import { get } from 'lodash';\n+\n+import {\n+  DATE_FORMAT,\n+  TIME_FORMAT,\n+  DATE_TIMEZONE_FORMAT,\n+  DATE_FIELD_FORMATS,\n+} from '../../constants/Constants';\n+import { getClassNames, getFormattedDate } from '../../utils/widgetHelpers';\n+import { WidgetRendererPropTypes } from './PropTypes';\n+import { withForwardedRef } from '../hoc/WithRouterAndRef';\n+\n+import ActionButton from './ActionButton';\n+import Attributes from './Attributes/Attributes';\n+import Checkbox from './Checkbox';\n+import DatePicker from './DatePicker';\n+import DatetimeRange from './DatetimeRange';\n+import DevicesWidget from './Devices/DevicesWidget';\n+import Image from './Image';\n+import Labels from './Labels';\n+import Link from './Link';\n+import CharacterLimitInfo from './CharacterLimitInfo';\n+import List from './List/List';\n+import Lookup from './Lookup/Lookup';\n+\n+class WidgetRenderer extends PureComponent {\n+  constructor(props) {\n+    super(props);\n+\n+    this.getClassNames = getClassNames.bind(this);\n+    this.getFormattedDate = getFormattedDate.bind(this);\n+  }\n+\n+  /**\n+   * @method handleDateChange\n+   * @summary calls `handleChange` prop function for date fields, to avoid\n+   * unnecessary anonymous functions\n+   *\n+   * @param {date} date - toggles between text/password\n+   */\n+  handleDateChange = (date) => {\n+    const { widgetField, handleChange } = this.props;\n+    handleChange(widgetField, date);\n+  };\n+\n+  render() {\n+    const {\n+      handleChange,\n+      updated,\n+      isModal,\n+      filterWidget,\n+      filterId,\n+      id,\n+      range,\n+      onHide,\n+      handleBackdropLock,\n+      subentity,\n+      widgetType,\n+      subentityId,\n+      dropdownOpenCallback,\n+      autoFocus,\n+      fullScreen,\n+      fields,\n+      windowType,\n+      dataId,\n+      type,\n+      widgetData,\n+      rowId,\n+      tabId,\n+      docId,\n+      activeTab,\n+      icon,\n+      gridAlign,\n+      entity,\n+      onShow,\n+      caption,\n+      viewId,\n+      listenOnKeys,\n+      listenOnKeysFalse,\n+      closeTableField,\n+      handleZoomInto,\n+      attribute,\n+      allowShowPassword,\n+      onBlurWidget,\n+      isOpenDatePicker,\n+      dateFormat,\n+      initialFocus,\n+      timeZone,\n+      maxLength,\n+      updateHeight,\n+      rowIndex,\n+      onClickOutside,\n+      emptyText,\n+      forceFullWidth,\n+      forceHeight,\n+\n+      // from `renderWidget`\n+      isMultiselect,\n+      widgetField,\n+      widgetProperties,\n+      showErrorBorder,\n+      isFocused,\n+      charsTyped,\n+      readonly,\n+      onPatch,\n+      onListFocus,\n+      onBlurWithParams,\n+      onSetWidgetType,\n+      onHandleProcess,\n+      forwardedRef,\n+    } = this.props;\n+    const { tabIndex, onFocus } = widgetProperties;\n+    const widgetValue = get(widgetProperties, ['value'], null);\n+    widgetProperties.ref = forwardedRef;\n+\n+    const selectedValue = widgetData[0].value\n+      ? widgetData[0].value\n+      : widgetData[0].defaultValue;\n+\n+    const listAndLookupsProps = {\n+      dataId,\n+      attribute,\n+      entity,\n+      subentity,\n+      subentityId,\n+      windowType,\n+      readonly,\n+      updated,\n+      filterWidget,\n+      filterId,\n+      tabId,\n+      rowId,\n+      tabIndex,\n+      viewId,\n+      autoFocus,\n+      onFocus: onListFocus,\n+      onBlur: onBlurWithParams,\n+      align: gridAlign,\n+      mandatory: widgetData[0].mandatory,\n+      parameterName: fields[0].parameterName,\n+      validStatus: widgetData[0].validStatus,\n+      onChange: onPatch,\n+    };\n+    const dateProps = {\n+      field: widgetField,\n+      key: 1,\n+      handleChange,\n+      handleBackdropLock,\n+      inputProps: {\n+        placeholder: fields[0].emptyText,\n+        disabled: readonly,\n+        tabIndex: tabIndex,\n+      },\n+      onChange: this.handleDateChange,\n+    };\n+    const dateRangeProps = {\n+      mandatory: widgetData[0].mandatory,\n+      validStatus: widgetData[0].validStatus,\n+      value: widgetData[0].value,\n+      valueTo: widgetData[0].valueTo,\n+      tabIndex,\n+      onShow,\n+      onHide,\n+    };\n+    const attributesProps = {\n+      entity,\n+      fields,\n+      dataId,\n+      widgetData: widgetData[0],\n+      docType: windowType,\n+      tabId,\n+      rowId,\n+      fieldName: widgetField,\n+      handleBackdropLock,\n+      patch: (option) => onPatch(widgetField, option),\n+      tabIndex,\n+      autoFocus,\n+      readonly,\n+    };\n+\n+    switch (widgetType) {\n+      case 'Date':\n+        if (range) {\n+          // TODO: Watch out! The datetimerange widget as exception,\n+          // is non-controlled input! For further usage, needs\n+          // upgrade.\n+          return (\n+            <DatetimeRange\n+              {...dateRangeProps}\n+              onChange={(value, valueTo) =>\n+                onPatch(\n+                  widgetField,\n+                  value ? Moment(value).format(DATE_FORMAT) : null,\n+                  null,\n+                  valueTo ? Moment(valueTo).format(DATE_FORMAT) : null\n+                )\n+              }\n+              field={widgetField}\n+              timeZone={timeZone}\n+            />\n+          );\n+        } else {\n+          return (\n+            <div className={this.getClassNames({ icon: true })}>\n+              <DatePicker\n+                {...dateProps}\n+                timeFormat={false}\n+                dateFormat={dateFormat || true}\n+                value={widgetValue || widgetData[0].value}\n+                patch={(date) =>\n+                  onPatch(\n+                    widgetField,\n+                    this.getFormattedDate(date, DATE_FORMAT),\n+                    null,\n+                    null,\n+                    true\n+                  )\n+                }\n+                {...{\n+                  isOpenDatePicker,\n+                  timeZone,\n+                }}\n+              />\n+            </div>\n+          );\n+        }\n+      case 'ZonedDateTime':\n+        return (\n+          <div className={this.getClassNames({ icon: true })}>\n+            <DatePicker\n+              {...dateProps}\n+              timeFormat={true}\n+              dateFormat={dateFormat || true}\n+              hasTimeZone={true}\n+              value={widgetValue || widgetData[0].value}\n+              patch={(date) =>\n+                onPatch(\n+                  widgetField,\n+                  this.getFormattedDate(date, DATE_TIMEZONE_FORMAT),\n+                  null,\n+                  null,\n+                  true\n+                )\n+              }\n+              {...{\n+                isOpenDatePicker,\n+                timeZone,\n+              }}\n+            />\n+          </div>\n+        );\n+      case 'Time':\n+        return (\n+          <div className={this.getClassNames({ icon: true })}>\n+            <DatePicker\n+              {...dateProps}\n+              timeFormat={TIME_FORMAT}\n+              dateFormat={false}\n+              value={this.getFormattedDate(widgetValue, TIME_FORMAT)}\n+              patch={(date) =>\n+                onPatch(\n+                  widgetField,\n+                  this.getFormattedDate(date, TIME_FORMAT),\n+                  null,\n+                  null,\n+                  true\n+                )\n+              }\n+              tabIndex={tabIndex}\n+            />\n+          </div>\n+        );\n+      case 'Timestamp':\n+        return (\n+          <div className={this.getClassNames({ icon: true })}>\n+            <DatePicker\n+              {...dateProps}\n+              timeFormat={false}\n+              dateFormat={DATE_FIELD_FORMATS[widgetType]}\n+              value={widgetValue}\n+              patch={(date) =>\n+                onPatch(\n+                  widgetField,\n+                  this.getFormattedDate(date, `x`),\n+                  null,\n+                  null,\n+                  true\n+                )\n+              }\n+              tabIndex={tabIndex}\n+            />\n+          </div>\n+        );\n+      case 'DateRange': {\n+        return (\n+          <DatetimeRange\n+            {...dateRangeProps}\n+            onChange={(value, valueTo) => {\n+              const val = Moment(value).format(DATE_FORMAT);\n+              const valTo = Moment(valueTo).format(DATE_FORMAT);\n+\n+              onPatch(widgetField, {\n+                ...(val && { value: val }),\n+                ...(valTo && { valueTo: valTo }),\n+              });\n+            }}\n+          />\n+        );\n+      }\n+      case 'Lookup':\n+        return (\n+          <Lookup\n+            {...listAndLookupsProps}\n+            properties={fields}\n+            widgetData={widgetData}\n+            placeholder={emptyText ? emptyText : fields[0].emptyText}\n+            rank={type}\n+            isModal={isModal}\n+            selected={widgetValue}\n+            initialFocus={initialFocus}\n+            forceFullWidth={forceFullWidth}\n+            forceHeight={forceHeight}\n+            newRecordCaption={fields[0].newRecordCaption}\n+            newRecordWindowId={fields[0].newRecordWindowId}\n+            listenOnKeys={listenOnKeys}\n+            listenOnKeysFalse={listenOnKeysFalse}\n+            closeTableField={closeTableField}\n+            onBlurWidget={onBlurWidget}\n+            onClickOutside={onClickOutside}\n+          />\n+        );\n+      case 'List':\n+      case 'MultiListValue': {\n+        const commonProps = {\n+          ...listAndLookupsProps,\n+          widgetField,\n+          defaultValue: fields[0].emptyText,\n+          properties: fields[0],\n+          emptyText: fields[0].emptyText,\n+        };\n+        const typeProps = {};\n+\n+        if (widgetType === 'List') {\n+          typeProps.selected = selectedValue;\n+          typeProps.isMultiselect = isMultiselect;\n+        } else {\n+          typeProps.selected = widgetData[0].value || null;\n+          typeProps.isMultiselect = true;\n+        }\n+\n+        return <List {...commonProps} {...typeProps} />;\n+      }\n+      case 'Link':\n+        return (\n+          <Link\n+            getClassNames={() => this.getClassNames({ icon: true })}\n+            {...{\n+              isFocused,\n+              widgetProperties,\n+              icon,\n+              widgetData,\n+              tabIndex,\n+              fullScreen,\n+            }}\n+          />\n+        );\n+      case 'Text':\n+      case 'LongText': {\n+        const classNameParams = { icon: true };\n+        let renderContent = null;\n+\n+        if (widgetType === 'Text') {\n+          renderContent = (\n+            <Fragment>\n+              <input {...widgetProperties} type=\"text\" />\n+              {icon && <i className=\"meta-icon-edit input-icon-right\" />}\n+            </Fragment>\n+          );\n+        } else {\n+          classNameParams.forcedPrimary = true;\n+          renderContent = <textarea {...widgetProperties} />;\n+        }\n+        return (\n+          <div>\n+            <div\n+              className={classnames(this.getClassNames(classNameParams), {\n+                'border-danger': showErrorBorder,\n+              })}\n+            >\n+              {renderContent}\n+            </div>\n+            {charsTyped && charsTyped >= 0 ? (\n+              <CharacterLimitInfo\n+                charsTyped={charsTyped}\n+                maxLength={maxLength}\n+              />\n+            ) : null}\n+          </div>\n+        );\n+      }\n+      case 'Password':\n+        return (", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe016765f9489e37e751eb58465acf112728d7e3"}, "originalPosition": 405}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDcxNDQ0Mg==", "bodyText": "Actually not a bad idea to extract those components, that are still using html elements directly", "url": "https://github.com/metasfresh/metasfresh/pull/10134#discussion_r510714442", "createdAt": "2020-10-23T08:17:58Z", "author": {"login": "siemiatj"}, "path": "frontend/src/components/widget/WidgetRenderer.js", "diffHunk": "@@ -0,0 +1,640 @@\n+import React, { Fragment, PureComponent } from 'react';\n+import Moment from 'moment';\n+import classnames from 'classnames';\n+import { get } from 'lodash';\n+\n+import {\n+  DATE_FORMAT,\n+  TIME_FORMAT,\n+  DATE_TIMEZONE_FORMAT,\n+  DATE_FIELD_FORMATS,\n+} from '../../constants/Constants';\n+import { getClassNames, getFormattedDate } from '../../utils/widgetHelpers';\n+import { WidgetRendererPropTypes } from './PropTypes';\n+import { withForwardedRef } from '../hoc/WithRouterAndRef';\n+\n+import ActionButton from './ActionButton';\n+import Attributes from './Attributes/Attributes';\n+import Checkbox from './Checkbox';\n+import DatePicker from './DatePicker';\n+import DatetimeRange from './DatetimeRange';\n+import DevicesWidget from './Devices/DevicesWidget';\n+import Image from './Image';\n+import Labels from './Labels';\n+import Link from './Link';\n+import CharacterLimitInfo from './CharacterLimitInfo';\n+import List from './List/List';\n+import Lookup from './Lookup/Lookup';\n+\n+class WidgetRenderer extends PureComponent {\n+  constructor(props) {\n+    super(props);\n+\n+    this.getClassNames = getClassNames.bind(this);\n+    this.getFormattedDate = getFormattedDate.bind(this);\n+  }\n+\n+  /**\n+   * @method handleDateChange\n+   * @summary calls `handleChange` prop function for date fields, to avoid\n+   * unnecessary anonymous functions\n+   *\n+   * @param {date} date - toggles between text/password\n+   */\n+  handleDateChange = (date) => {\n+    const { widgetField, handleChange } = this.props;\n+    handleChange(widgetField, date);\n+  };\n+\n+  render() {\n+    const {\n+      handleChange,\n+      updated,\n+      isModal,\n+      filterWidget,\n+      filterId,\n+      id,\n+      range,\n+      onHide,\n+      handleBackdropLock,\n+      subentity,\n+      widgetType,\n+      subentityId,\n+      dropdownOpenCallback,\n+      autoFocus,\n+      fullScreen,\n+      fields,\n+      windowType,\n+      dataId,\n+      type,\n+      widgetData,\n+      rowId,\n+      tabId,\n+      docId,\n+      activeTab,\n+      icon,\n+      gridAlign,\n+      entity,\n+      onShow,\n+      caption,\n+      viewId,\n+      listenOnKeys,\n+      listenOnKeysFalse,\n+      closeTableField,\n+      handleZoomInto,\n+      attribute,\n+      allowShowPassword,\n+      onBlurWidget,\n+      isOpenDatePicker,\n+      dateFormat,\n+      initialFocus,\n+      timeZone,\n+      maxLength,\n+      updateHeight,\n+      rowIndex,\n+      onClickOutside,\n+      emptyText,\n+      forceFullWidth,\n+      forceHeight,\n+\n+      // from `renderWidget`\n+      isMultiselect,\n+      widgetField,\n+      widgetProperties,\n+      showErrorBorder,\n+      isFocused,\n+      charsTyped,\n+      readonly,\n+      onPatch,\n+      onListFocus,\n+      onBlurWithParams,\n+      onSetWidgetType,\n+      onHandleProcess,\n+      forwardedRef,\n+    } = this.props;\n+    const { tabIndex, onFocus } = widgetProperties;\n+    const widgetValue = get(widgetProperties, ['value'], null);\n+    widgetProperties.ref = forwardedRef;\n+\n+    const selectedValue = widgetData[0].value\n+      ? widgetData[0].value\n+      : widgetData[0].defaultValue;\n+\n+    const listAndLookupsProps = {\n+      dataId,\n+      attribute,\n+      entity,\n+      subentity,\n+      subentityId,\n+      windowType,\n+      readonly,\n+      updated,\n+      filterWidget,\n+      filterId,\n+      tabId,\n+      rowId,\n+      tabIndex,\n+      viewId,\n+      autoFocus,\n+      onFocus: onListFocus,\n+      onBlur: onBlurWithParams,\n+      align: gridAlign,\n+      mandatory: widgetData[0].mandatory,\n+      parameterName: fields[0].parameterName,\n+      validStatus: widgetData[0].validStatus,\n+      onChange: onPatch,\n+    };\n+    const dateProps = {\n+      field: widgetField,\n+      key: 1,\n+      handleChange,\n+      handleBackdropLock,\n+      inputProps: {\n+        placeholder: fields[0].emptyText,\n+        disabled: readonly,\n+        tabIndex: tabIndex,\n+      },\n+      onChange: this.handleDateChange,\n+    };\n+    const dateRangeProps = {\n+      mandatory: widgetData[0].mandatory,\n+      validStatus: widgetData[0].validStatus,\n+      value: widgetData[0].value,\n+      valueTo: widgetData[0].valueTo,\n+      tabIndex,\n+      onShow,\n+      onHide,\n+    };\n+    const attributesProps = {\n+      entity,\n+      fields,\n+      dataId,\n+      widgetData: widgetData[0],\n+      docType: windowType,\n+      tabId,\n+      rowId,\n+      fieldName: widgetField,\n+      handleBackdropLock,\n+      patch: (option) => onPatch(widgetField, option),\n+      tabIndex,\n+      autoFocus,\n+      readonly,\n+    };\n+\n+    switch (widgetType) {\n+      case 'Date':\n+        if (range) {\n+          // TODO: Watch out! The datetimerange widget as exception,\n+          // is non-controlled input! For further usage, needs\n+          // upgrade.\n+          return (\n+            <DatetimeRange\n+              {...dateRangeProps}\n+              onChange={(value, valueTo) =>\n+                onPatch(\n+                  widgetField,\n+                  value ? Moment(value).format(DATE_FORMAT) : null,\n+                  null,\n+                  valueTo ? Moment(valueTo).format(DATE_FORMAT) : null\n+                )\n+              }\n+              field={widgetField}\n+              timeZone={timeZone}\n+            />\n+          );\n+        } else {\n+          return (\n+            <div className={this.getClassNames({ icon: true })}>\n+              <DatePicker\n+                {...dateProps}\n+                timeFormat={false}\n+                dateFormat={dateFormat || true}\n+                value={widgetValue || widgetData[0].value}\n+                patch={(date) =>\n+                  onPatch(\n+                    widgetField,\n+                    this.getFormattedDate(date, DATE_FORMAT),\n+                    null,\n+                    null,\n+                    true\n+                  )\n+                }\n+                {...{\n+                  isOpenDatePicker,\n+                  timeZone,\n+                }}\n+              />\n+            </div>\n+          );\n+        }\n+      case 'ZonedDateTime':\n+        return (\n+          <div className={this.getClassNames({ icon: true })}>\n+            <DatePicker\n+              {...dateProps}\n+              timeFormat={true}\n+              dateFormat={dateFormat || true}\n+              hasTimeZone={true}\n+              value={widgetValue || widgetData[0].value}\n+              patch={(date) =>\n+                onPatch(\n+                  widgetField,\n+                  this.getFormattedDate(date, DATE_TIMEZONE_FORMAT),\n+                  null,\n+                  null,\n+                  true\n+                )\n+              }\n+              {...{\n+                isOpenDatePicker,\n+                timeZone,\n+              }}\n+            />\n+          </div>\n+        );\n+      case 'Time':\n+        return (\n+          <div className={this.getClassNames({ icon: true })}>\n+            <DatePicker\n+              {...dateProps}\n+              timeFormat={TIME_FORMAT}\n+              dateFormat={false}\n+              value={this.getFormattedDate(widgetValue, TIME_FORMAT)}\n+              patch={(date) =>\n+                onPatch(\n+                  widgetField,\n+                  this.getFormattedDate(date, TIME_FORMAT),\n+                  null,\n+                  null,\n+                  true\n+                )\n+              }\n+              tabIndex={tabIndex}\n+            />\n+          </div>\n+        );\n+      case 'Timestamp':\n+        return (\n+          <div className={this.getClassNames({ icon: true })}>\n+            <DatePicker\n+              {...dateProps}\n+              timeFormat={false}\n+              dateFormat={DATE_FIELD_FORMATS[widgetType]}\n+              value={widgetValue}\n+              patch={(date) =>\n+                onPatch(\n+                  widgetField,\n+                  this.getFormattedDate(date, `x`),\n+                  null,\n+                  null,\n+                  true\n+                )\n+              }\n+              tabIndex={tabIndex}\n+            />\n+          </div>\n+        );\n+      case 'DateRange': {\n+        return (\n+          <DatetimeRange\n+            {...dateRangeProps}\n+            onChange={(value, valueTo) => {\n+              const val = Moment(value).format(DATE_FORMAT);\n+              const valTo = Moment(valueTo).format(DATE_FORMAT);\n+\n+              onPatch(widgetField, {\n+                ...(val && { value: val }),\n+                ...(valTo && { valueTo: valTo }),\n+              });\n+            }}\n+          />\n+        );\n+      }\n+      case 'Lookup':\n+        return (\n+          <Lookup\n+            {...listAndLookupsProps}\n+            properties={fields}\n+            widgetData={widgetData}\n+            placeholder={emptyText ? emptyText : fields[0].emptyText}\n+            rank={type}\n+            isModal={isModal}\n+            selected={widgetValue}\n+            initialFocus={initialFocus}\n+            forceFullWidth={forceFullWidth}\n+            forceHeight={forceHeight}\n+            newRecordCaption={fields[0].newRecordCaption}\n+            newRecordWindowId={fields[0].newRecordWindowId}\n+            listenOnKeys={listenOnKeys}\n+            listenOnKeysFalse={listenOnKeysFalse}\n+            closeTableField={closeTableField}\n+            onBlurWidget={onBlurWidget}\n+            onClickOutside={onClickOutside}\n+          />\n+        );\n+      case 'List':\n+      case 'MultiListValue': {\n+        const commonProps = {\n+          ...listAndLookupsProps,\n+          widgetField,\n+          defaultValue: fields[0].emptyText,\n+          properties: fields[0],\n+          emptyText: fields[0].emptyText,\n+        };\n+        const typeProps = {};\n+\n+        if (widgetType === 'List') {\n+          typeProps.selected = selectedValue;\n+          typeProps.isMultiselect = isMultiselect;\n+        } else {\n+          typeProps.selected = widgetData[0].value || null;\n+          typeProps.isMultiselect = true;\n+        }\n+\n+        return <List {...commonProps} {...typeProps} />;\n+      }\n+      case 'Link':\n+        return (\n+          <Link\n+            getClassNames={() => this.getClassNames({ icon: true })}\n+            {...{\n+              isFocused,\n+              widgetProperties,\n+              icon,\n+              widgetData,\n+              tabIndex,\n+              fullScreen,\n+            }}\n+          />\n+        );\n+      case 'Text':\n+      case 'LongText': {\n+        const classNameParams = { icon: true };\n+        let renderContent = null;\n+\n+        if (widgetType === 'Text') {\n+          renderContent = (\n+            <Fragment>\n+              <input {...widgetProperties} type=\"text\" />\n+              {icon && <i className=\"meta-icon-edit input-icon-right\" />}\n+            </Fragment>\n+          );\n+        } else {\n+          classNameParams.forcedPrimary = true;\n+          renderContent = <textarea {...widgetProperties} />;\n+        }\n+        return (\n+          <div>\n+            <div\n+              className={classnames(this.getClassNames(classNameParams), {\n+                'border-danger': showErrorBorder,\n+              })}\n+            >\n+              {renderContent}\n+            </div>\n+            {charsTyped && charsTyped >= 0 ? (\n+              <CharacterLimitInfo\n+                charsTyped={charsTyped}\n+                maxLength={maxLength}\n+              />\n+            ) : null}\n+          </div>\n+        );\n+      }\n+      case 'Password':\n+        return (", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDcwMTUzMA=="}, "originalCommit": {"oid": "fe016765f9489e37e751eb58465acf112728d7e3"}, "originalPosition": 405}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1227, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}