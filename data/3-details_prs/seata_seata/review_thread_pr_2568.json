{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA0ODk1MzI0", "number": 2568, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwMjoxNToyMFrOEAu9BQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNjo1OToyNlrOEAxu5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MjA0NzQxOnYy", "diffSide": "RIGHT", "path": "spring/src/main/java/io/seata/spring/util/GlobalTransactionalCheck.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwMjoxNToyMFrOGcMnrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwMjoxNToyMFrOGcMnrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIyMDA3OQ==", "bodyText": "Why change to public?", "url": "https://github.com/seata/seata/pull/2568#discussion_r432220079", "createdAt": "2020-05-29T02:15:20Z", "author": {"login": "l81893521"}, "path": "spring/src/main/java/io/seata/spring/util/GlobalTransactionalCheck.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.spring.util;\n+\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import io.seata.common.thread.NamedThreadFactory;\n+import io.seata.config.ConfigurationChangeEvent;\n+import io.seata.config.ConfigurationChangeListener;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.tm.TransactionManagerHolder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+import static io.seata.core.constants.DefaultValues.DEFAULT_DISABLE_GLOBAL_TRANSACTION;\n+import static io.seata.core.constants.DefaultValues.DEFAULT_TM_DEGRADE_CHECK;\n+import static io.seata.core.constants.DefaultValues.DEFAULT_TM_DEGRADE_CHECK_ALLOW_TIMES;\n+import static io.seata.core.constants.DefaultValues.DEFAULT_TM_DEGRADE_CHECK_PERIOD;\n+\n+/**\n+ * service dynamic processing center\n+ *\n+ * @author funkye\n+ */\n+public class GlobalTransactionalCheck implements ConfigurationChangeListener {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(GlobalTransactionalCheck.class);\n+    private static int degradeCheckPeriod;\n+    private static volatile boolean degradeCheck;\n+    private static int degradeCheckAllowTimes;\n+    private static volatile Integer degradeNum = 0;\n+    private static volatile Integer reachNum = 0;\n+    private static volatile boolean disable;\n+    private static ScheduledThreadPoolExecutor executor =\n+        new ScheduledThreadPoolExecutor(1, new NamedThreadFactory(\"degradeCheckWorker\", 1, true));\n+\n+    public GlobalTransactionalCheck() {\n+        disable = ConfigurationFactory.getInstance().getBoolean(ConfigurationKeys.DISABLE_GLOBAL_TRANSACTION,\n+            DEFAULT_DISABLE_GLOBAL_TRANSACTION);\n+        degradeCheck = ConfigurationFactory.getInstance().getBoolean(ConfigurationKeys.CLIENT_DEGRADE_CHECK,\n+            DEFAULT_TM_DEGRADE_CHECK);\n+        if (degradeCheck) {\n+            degradeCheckPeriod = ConfigurationFactory.getInstance()\n+                .getInt(ConfigurationKeys.CLIENT_DEGRADE_CHECK_PERIOD, DEFAULT_TM_DEGRADE_CHECK_PERIOD);\n+            degradeCheckAllowTimes = ConfigurationFactory.getInstance()\n+                .getInt(ConfigurationKeys.CLIENT_DEGRADE_CHECK_ALLOW_TIMES, DEFAULT_TM_DEGRADE_CHECK_ALLOW_TIMES);\n+            if (degradeCheckPeriod > 0 && degradeCheckAllowTimes > 0) {\n+                startDegradeCheck();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * auto upgrade service detection\n+     */\n+    private static void startDegradeCheck() {\n+        executor.scheduleAtFixedRate(() -> {\n+            if (degradeCheck) {\n+                try {\n+                    String xid = TransactionManagerHolder.get().begin(null, null, \"degradeCheck\", 60000);\n+                    TransactionManagerHolder.get().commit(xid);\n+                    onDegradeCheck(true);\n+                } catch (Exception e) {\n+                    onDegradeCheck(false);\n+                }\n+            }\n+        }, degradeCheckPeriod, degradeCheckPeriod, TimeUnit.MILLISECONDS);\n+    }\n+\n+    public static synchronized void onDegradeCheck(boolean succeed) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dde6fb8b0c4a75c4dba40fd4b6a7b871349869d5"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MjA5MDAxOnYy", "diffSide": "RIGHT", "path": "spring/src/main/java/io/seata/spring/util/GlobalTransactionalCheck.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwMjo0NDowNFrOGcNBhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNToxNToyMVrOGcPB2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIyNjY5NQ==", "bodyText": "I think degradeCheck always true in here.", "url": "https://github.com/seata/seata/pull/2568#discussion_r432226695", "createdAt": "2020-05-29T02:44:04Z", "author": {"login": "l81893521"}, "path": "spring/src/main/java/io/seata/spring/util/GlobalTransactionalCheck.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.spring.util;\n+\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import io.seata.common.thread.NamedThreadFactory;\n+import io.seata.config.ConfigurationChangeEvent;\n+import io.seata.config.ConfigurationChangeListener;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.tm.TransactionManagerHolder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+import static io.seata.core.constants.DefaultValues.DEFAULT_DISABLE_GLOBAL_TRANSACTION;\n+import static io.seata.core.constants.DefaultValues.DEFAULT_TM_DEGRADE_CHECK;\n+import static io.seata.core.constants.DefaultValues.DEFAULT_TM_DEGRADE_CHECK_ALLOW_TIMES;\n+import static io.seata.core.constants.DefaultValues.DEFAULT_TM_DEGRADE_CHECK_PERIOD;\n+\n+/**\n+ * service dynamic processing center\n+ *\n+ * @author funkye\n+ */\n+public class GlobalTransactionalCheck implements ConfigurationChangeListener {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(GlobalTransactionalCheck.class);\n+    private static int degradeCheckPeriod;\n+    private static volatile boolean degradeCheck;\n+    private static int degradeCheckAllowTimes;\n+    private static volatile Integer degradeNum = 0;\n+    private static volatile Integer reachNum = 0;\n+    private static volatile boolean disable;\n+    private static ScheduledThreadPoolExecutor executor =\n+        new ScheduledThreadPoolExecutor(1, new NamedThreadFactory(\"degradeCheckWorker\", 1, true));\n+\n+    public GlobalTransactionalCheck() {\n+        disable = ConfigurationFactory.getInstance().getBoolean(ConfigurationKeys.DISABLE_GLOBAL_TRANSACTION,\n+            DEFAULT_DISABLE_GLOBAL_TRANSACTION);\n+        degradeCheck = ConfigurationFactory.getInstance().getBoolean(ConfigurationKeys.CLIENT_DEGRADE_CHECK,\n+            DEFAULT_TM_DEGRADE_CHECK);\n+        if (degradeCheck) {\n+            degradeCheckPeriod = ConfigurationFactory.getInstance()\n+                .getInt(ConfigurationKeys.CLIENT_DEGRADE_CHECK_PERIOD, DEFAULT_TM_DEGRADE_CHECK_PERIOD);\n+            degradeCheckAllowTimes = ConfigurationFactory.getInstance()\n+                .getInt(ConfigurationKeys.CLIENT_DEGRADE_CHECK_ALLOW_TIMES, DEFAULT_TM_DEGRADE_CHECK_ALLOW_TIMES);\n+            if (degradeCheckPeriod > 0 && degradeCheckAllowTimes > 0) {\n+                startDegradeCheck();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * auto upgrade service detection\n+     */\n+    private static void startDegradeCheck() {\n+        executor.scheduleAtFixedRate(() -> {\n+            if (degradeCheck) {\n+                try {\n+                    String xid = TransactionManagerHolder.get().begin(null, null, \"degradeCheck\", 60000);\n+                    TransactionManagerHolder.get().commit(xid);\n+                    onDegradeCheck(true);\n+                } catch (Exception e) {\n+                    onDegradeCheck(false);\n+                }\n+            }\n+        }, degradeCheckPeriod, degradeCheckPeriod, TimeUnit.MILLISECONDS);\n+    }\n+\n+    public static synchronized void onDegradeCheck(boolean succeed) {\n+        if (succeed) {\n+            if (degradeNum >= degradeCheckAllowTimes) {\n+                reachNum++;\n+                if (reachNum >= degradeCheckAllowTimes) {\n+                    reachNum = 0;\n+                    degradeNum = 0;\n+                    if (LOGGER.isInfoEnabled()) {\n+                        LOGGER.info(\"the current global transaction has been restored\");\n+                    }\n+                }\n+            } else if (degradeNum != 0) {\n+                degradeNum = 0;\n+            }\n+        } else {\n+            if (degradeNum < degradeCheckAllowTimes) {\n+                degradeNum++;\n+                if (degradeNum >= degradeCheckAllowTimes) {\n+                    if (LOGGER.isWarnEnabled()) {\n+                        LOGGER.warn(\"the current global transaction has been automatically downgraded\");\n+                    }\n+                }\n+            } else if (reachNum != 0) {\n+                reachNum = 0;\n+            }\n+        }\n+    }\n+\n+    public static boolean getStatus() {\n+        if (!degradeCheck) {\n+            return disable;\n+        }\n+        return disable || (degradeCheck && degradeNum >= degradeCheckAllowTimes);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dde6fb8b0c4a75c4dba40fd4b6a7b871349869d5"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI1OTU0Nw==", "bodyText": "PTAL", "url": "https://github.com/seata/seata/pull/2568#discussion_r432259547", "createdAt": "2020-05-29T05:15:21Z", "author": {"login": "a364176773"}, "path": "spring/src/main/java/io/seata/spring/util/GlobalTransactionalCheck.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.spring.util;\n+\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import io.seata.common.thread.NamedThreadFactory;\n+import io.seata.config.ConfigurationChangeEvent;\n+import io.seata.config.ConfigurationChangeListener;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.tm.TransactionManagerHolder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+import static io.seata.core.constants.DefaultValues.DEFAULT_DISABLE_GLOBAL_TRANSACTION;\n+import static io.seata.core.constants.DefaultValues.DEFAULT_TM_DEGRADE_CHECK;\n+import static io.seata.core.constants.DefaultValues.DEFAULT_TM_DEGRADE_CHECK_ALLOW_TIMES;\n+import static io.seata.core.constants.DefaultValues.DEFAULT_TM_DEGRADE_CHECK_PERIOD;\n+\n+/**\n+ * service dynamic processing center\n+ *\n+ * @author funkye\n+ */\n+public class GlobalTransactionalCheck implements ConfigurationChangeListener {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(GlobalTransactionalCheck.class);\n+    private static int degradeCheckPeriod;\n+    private static volatile boolean degradeCheck;\n+    private static int degradeCheckAllowTimes;\n+    private static volatile Integer degradeNum = 0;\n+    private static volatile Integer reachNum = 0;\n+    private static volatile boolean disable;\n+    private static ScheduledThreadPoolExecutor executor =\n+        new ScheduledThreadPoolExecutor(1, new NamedThreadFactory(\"degradeCheckWorker\", 1, true));\n+\n+    public GlobalTransactionalCheck() {\n+        disable = ConfigurationFactory.getInstance().getBoolean(ConfigurationKeys.DISABLE_GLOBAL_TRANSACTION,\n+            DEFAULT_DISABLE_GLOBAL_TRANSACTION);\n+        degradeCheck = ConfigurationFactory.getInstance().getBoolean(ConfigurationKeys.CLIENT_DEGRADE_CHECK,\n+            DEFAULT_TM_DEGRADE_CHECK);\n+        if (degradeCheck) {\n+            degradeCheckPeriod = ConfigurationFactory.getInstance()\n+                .getInt(ConfigurationKeys.CLIENT_DEGRADE_CHECK_PERIOD, DEFAULT_TM_DEGRADE_CHECK_PERIOD);\n+            degradeCheckAllowTimes = ConfigurationFactory.getInstance()\n+                .getInt(ConfigurationKeys.CLIENT_DEGRADE_CHECK_ALLOW_TIMES, DEFAULT_TM_DEGRADE_CHECK_ALLOW_TIMES);\n+            if (degradeCheckPeriod > 0 && degradeCheckAllowTimes > 0) {\n+                startDegradeCheck();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * auto upgrade service detection\n+     */\n+    private static void startDegradeCheck() {\n+        executor.scheduleAtFixedRate(() -> {\n+            if (degradeCheck) {\n+                try {\n+                    String xid = TransactionManagerHolder.get().begin(null, null, \"degradeCheck\", 60000);\n+                    TransactionManagerHolder.get().commit(xid);\n+                    onDegradeCheck(true);\n+                } catch (Exception e) {\n+                    onDegradeCheck(false);\n+                }\n+            }\n+        }, degradeCheckPeriod, degradeCheckPeriod, TimeUnit.MILLISECONDS);\n+    }\n+\n+    public static synchronized void onDegradeCheck(boolean succeed) {\n+        if (succeed) {\n+            if (degradeNum >= degradeCheckAllowTimes) {\n+                reachNum++;\n+                if (reachNum >= degradeCheckAllowTimes) {\n+                    reachNum = 0;\n+                    degradeNum = 0;\n+                    if (LOGGER.isInfoEnabled()) {\n+                        LOGGER.info(\"the current global transaction has been restored\");\n+                    }\n+                }\n+            } else if (degradeNum != 0) {\n+                degradeNum = 0;\n+            }\n+        } else {\n+            if (degradeNum < degradeCheckAllowTimes) {\n+                degradeNum++;\n+                if (degradeNum >= degradeCheckAllowTimes) {\n+                    if (LOGGER.isWarnEnabled()) {\n+                        LOGGER.warn(\"the current global transaction has been automatically downgraded\");\n+                    }\n+                }\n+            } else if (reachNum != 0) {\n+                reachNum = 0;\n+            }\n+        }\n+    }\n+\n+    public static boolean getStatus() {\n+        if (!degradeCheck) {\n+            return disable;\n+        }\n+        return disable || (degradeCheck && degradeNum >= degradeCheckAllowTimes);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIyNjY5NQ=="}, "originalCommit": {"oid": "dde6fb8b0c4a75c4dba40fd4b6a7b871349869d5"}, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MjA5NDM0OnYy", "diffSide": "RIGHT", "path": "spring/src/main/java/io/seata/spring/util/GlobalTransactionalCheck.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwMjo0Njo1OFrOGcNEGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNDo0MjozNFrOGcOljA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIyNzM1NA==", "bodyText": "I think maybe change the method name, it will be more readable. like\nlocalDisable()", "url": "https://github.com/seata/seata/pull/2568#discussion_r432227354", "createdAt": "2020-05-29T02:46:58Z", "author": {"login": "l81893521"}, "path": "spring/src/main/java/io/seata/spring/util/GlobalTransactionalCheck.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.spring.util;\n+\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import io.seata.common.thread.NamedThreadFactory;\n+import io.seata.config.ConfigurationChangeEvent;\n+import io.seata.config.ConfigurationChangeListener;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.tm.TransactionManagerHolder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+import static io.seata.core.constants.DefaultValues.DEFAULT_DISABLE_GLOBAL_TRANSACTION;\n+import static io.seata.core.constants.DefaultValues.DEFAULT_TM_DEGRADE_CHECK;\n+import static io.seata.core.constants.DefaultValues.DEFAULT_TM_DEGRADE_CHECK_ALLOW_TIMES;\n+import static io.seata.core.constants.DefaultValues.DEFAULT_TM_DEGRADE_CHECK_PERIOD;\n+\n+/**\n+ * service dynamic processing center\n+ *\n+ * @author funkye\n+ */\n+public class GlobalTransactionalCheck implements ConfigurationChangeListener {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(GlobalTransactionalCheck.class);\n+    private static int degradeCheckPeriod;\n+    private static volatile boolean degradeCheck;\n+    private static int degradeCheckAllowTimes;\n+    private static volatile Integer degradeNum = 0;\n+    private static volatile Integer reachNum = 0;\n+    private static volatile boolean disable;\n+    private static ScheduledThreadPoolExecutor executor =\n+        new ScheduledThreadPoolExecutor(1, new NamedThreadFactory(\"degradeCheckWorker\", 1, true));\n+\n+    public GlobalTransactionalCheck() {\n+        disable = ConfigurationFactory.getInstance().getBoolean(ConfigurationKeys.DISABLE_GLOBAL_TRANSACTION,\n+            DEFAULT_DISABLE_GLOBAL_TRANSACTION);\n+        degradeCheck = ConfigurationFactory.getInstance().getBoolean(ConfigurationKeys.CLIENT_DEGRADE_CHECK,\n+            DEFAULT_TM_DEGRADE_CHECK);\n+        if (degradeCheck) {\n+            degradeCheckPeriod = ConfigurationFactory.getInstance()\n+                .getInt(ConfigurationKeys.CLIENT_DEGRADE_CHECK_PERIOD, DEFAULT_TM_DEGRADE_CHECK_PERIOD);\n+            degradeCheckAllowTimes = ConfigurationFactory.getInstance()\n+                .getInt(ConfigurationKeys.CLIENT_DEGRADE_CHECK_ALLOW_TIMES, DEFAULT_TM_DEGRADE_CHECK_ALLOW_TIMES);\n+            if (degradeCheckPeriod > 0 && degradeCheckAllowTimes > 0) {\n+                startDegradeCheck();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * auto upgrade service detection\n+     */\n+    private static void startDegradeCheck() {\n+        executor.scheduleAtFixedRate(() -> {\n+            if (degradeCheck) {\n+                try {\n+                    String xid = TransactionManagerHolder.get().begin(null, null, \"degradeCheck\", 60000);\n+                    TransactionManagerHolder.get().commit(xid);\n+                    onDegradeCheck(true);\n+                } catch (Exception e) {\n+                    onDegradeCheck(false);\n+                }\n+            }\n+        }, degradeCheckPeriod, degradeCheckPeriod, TimeUnit.MILLISECONDS);\n+    }\n+\n+    public static synchronized void onDegradeCheck(boolean succeed) {\n+        if (succeed) {\n+            if (degradeNum >= degradeCheckAllowTimes) {\n+                reachNum++;\n+                if (reachNum >= degradeCheckAllowTimes) {\n+                    reachNum = 0;\n+                    degradeNum = 0;\n+                    if (LOGGER.isInfoEnabled()) {\n+                        LOGGER.info(\"the current global transaction has been restored\");\n+                    }\n+                }\n+            } else if (degradeNum != 0) {\n+                degradeNum = 0;\n+            }\n+        } else {\n+            if (degradeNum < degradeCheckAllowTimes) {\n+                degradeNum++;\n+                if (degradeNum >= degradeCheckAllowTimes) {\n+                    if (LOGGER.isWarnEnabled()) {\n+                        LOGGER.warn(\"the current global transaction has been automatically downgraded\");\n+                    }\n+                }\n+            } else if (reachNum != 0) {\n+                reachNum = 0;\n+            }\n+        }\n+    }\n+\n+    public static boolean getStatus() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dde6fb8b0c4a75c4dba40fd4b6a7b871349869d5"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI1MjMwMA==", "bodyText": "I think maybe change the method name, it will be more readable. like\nlocalDisable()\n\n\nok", "url": "https://github.com/seata/seata/pull/2568#discussion_r432252300", "createdAt": "2020-05-29T04:42:34Z", "author": {"login": "a364176773"}, "path": "spring/src/main/java/io/seata/spring/util/GlobalTransactionalCheck.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.spring.util;\n+\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import io.seata.common.thread.NamedThreadFactory;\n+import io.seata.config.ConfigurationChangeEvent;\n+import io.seata.config.ConfigurationChangeListener;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.tm.TransactionManagerHolder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+import static io.seata.core.constants.DefaultValues.DEFAULT_DISABLE_GLOBAL_TRANSACTION;\n+import static io.seata.core.constants.DefaultValues.DEFAULT_TM_DEGRADE_CHECK;\n+import static io.seata.core.constants.DefaultValues.DEFAULT_TM_DEGRADE_CHECK_ALLOW_TIMES;\n+import static io.seata.core.constants.DefaultValues.DEFAULT_TM_DEGRADE_CHECK_PERIOD;\n+\n+/**\n+ * service dynamic processing center\n+ *\n+ * @author funkye\n+ */\n+public class GlobalTransactionalCheck implements ConfigurationChangeListener {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(GlobalTransactionalCheck.class);\n+    private static int degradeCheckPeriod;\n+    private static volatile boolean degradeCheck;\n+    private static int degradeCheckAllowTimes;\n+    private static volatile Integer degradeNum = 0;\n+    private static volatile Integer reachNum = 0;\n+    private static volatile boolean disable;\n+    private static ScheduledThreadPoolExecutor executor =\n+        new ScheduledThreadPoolExecutor(1, new NamedThreadFactory(\"degradeCheckWorker\", 1, true));\n+\n+    public GlobalTransactionalCheck() {\n+        disable = ConfigurationFactory.getInstance().getBoolean(ConfigurationKeys.DISABLE_GLOBAL_TRANSACTION,\n+            DEFAULT_DISABLE_GLOBAL_TRANSACTION);\n+        degradeCheck = ConfigurationFactory.getInstance().getBoolean(ConfigurationKeys.CLIENT_DEGRADE_CHECK,\n+            DEFAULT_TM_DEGRADE_CHECK);\n+        if (degradeCheck) {\n+            degradeCheckPeriod = ConfigurationFactory.getInstance()\n+                .getInt(ConfigurationKeys.CLIENT_DEGRADE_CHECK_PERIOD, DEFAULT_TM_DEGRADE_CHECK_PERIOD);\n+            degradeCheckAllowTimes = ConfigurationFactory.getInstance()\n+                .getInt(ConfigurationKeys.CLIENT_DEGRADE_CHECK_ALLOW_TIMES, DEFAULT_TM_DEGRADE_CHECK_ALLOW_TIMES);\n+            if (degradeCheckPeriod > 0 && degradeCheckAllowTimes > 0) {\n+                startDegradeCheck();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * auto upgrade service detection\n+     */\n+    private static void startDegradeCheck() {\n+        executor.scheduleAtFixedRate(() -> {\n+            if (degradeCheck) {\n+                try {\n+                    String xid = TransactionManagerHolder.get().begin(null, null, \"degradeCheck\", 60000);\n+                    TransactionManagerHolder.get().commit(xid);\n+                    onDegradeCheck(true);\n+                } catch (Exception e) {\n+                    onDegradeCheck(false);\n+                }\n+            }\n+        }, degradeCheckPeriod, degradeCheckPeriod, TimeUnit.MILLISECONDS);\n+    }\n+\n+    public static synchronized void onDegradeCheck(boolean succeed) {\n+        if (succeed) {\n+            if (degradeNum >= degradeCheckAllowTimes) {\n+                reachNum++;\n+                if (reachNum >= degradeCheckAllowTimes) {\n+                    reachNum = 0;\n+                    degradeNum = 0;\n+                    if (LOGGER.isInfoEnabled()) {\n+                        LOGGER.info(\"the current global transaction has been restored\");\n+                    }\n+                }\n+            } else if (degradeNum != 0) {\n+                degradeNum = 0;\n+            }\n+        } else {\n+            if (degradeNum < degradeCheckAllowTimes) {\n+                degradeNum++;\n+                if (degradeNum >= degradeCheckAllowTimes) {\n+                    if (LOGGER.isWarnEnabled()) {\n+                        LOGGER.warn(\"the current global transaction has been automatically downgraded\");\n+                    }\n+                }\n+            } else if (reachNum != 0) {\n+                reachNum = 0;\n+            }\n+        }\n+    }\n+\n+    public static boolean getStatus() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIyNzM1NA=="}, "originalCommit": {"oid": "dde6fb8b0c4a75c4dba40fd4b6a7b871349869d5"}, "originalPosition": 113}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MjUwMjc3OnYy", "diffSide": "RIGHT", "path": "spring/src/main/java/io/seata/spring/annotation/HandleGlobalTransaction.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNjo1OToyNlrOGcQ9yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwOTo0OTo1MVrOGcWOjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI5MTI3NQ==", "bodyText": "Why remove the degrade check?", "url": "https://github.com/seata/seata/pull/2568#discussion_r432291275", "createdAt": "2020-05-29T06:59:26Z", "author": {"login": "l81893521"}, "path": "spring/src/main/java/io/seata/spring/annotation/HandleGlobalTransaction.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.spring.annotation;\n+\n+import java.lang.reflect.Method;\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+\n+import org.aopalliance.intercept.MethodInvocation;\n+\n+import io.seata.common.exception.ShouldNeverHappenException;\n+import io.seata.common.util.StringUtils;\n+import io.seata.tm.api.FailureHandler;\n+import io.seata.tm.api.TransactionalExecutor;\n+import io.seata.tm.api.TransactionalTemplate;\n+import io.seata.tm.api.transaction.NoRollbackRule;\n+import io.seata.tm.api.transaction.RollbackRule;\n+import io.seata.tm.api.transaction.TransactionInfo;\n+\n+/**\n+ * @author funkye\n+ * @date 2020/4/17\n+ */\n+public class HandleGlobalTransaction {\n+\n+    public Object runTransaction(final MethodInvocation methodInvocation, final Object globalTrxAnno,\n+        final FailureHandler failureHandler, final TransactionalTemplate transactionalTemplate) throws Throwable {\n+        try {\n+            return transactionalTemplate.execute(new TransactionalExecutor() {\n+                @Override\n+                public Object execute() throws Throwable {\n+                    return methodInvocation.proceed();\n+                }\n+\n+                @Override\n+                public TransactionInfo getTransactionInfo() {\n+                    return getInfo(globalTrxAnno, methodInvocation.getMethod());\n+                }\n+\n+            });\n+        } catch (TransactionalExecutor.ExecutionException e) {\n+            throw switchExecutionException(e, failureHandler);\n+        }\n+    }\n+\n+    private TransactionInfo getInfo(Object globalTrxAnno, Method method) {\n+        TransactionInfo transactionInfo = new TransactionInfo();\n+        AtTransactional globalTrx = convertAtTransactional(globalTrxAnno);\n+        transactionInfo.setTimeOut(globalTrx.getTimeoutMills());\n+        String name = globalTrx.getName();\n+        if (StringUtils.isNullOrEmpty(name)) {\n+            name = formatMethod(method);\n+        }\n+        transactionInfo.setName(name);\n+        transactionInfo.setPropagation(globalTrx.getPropagation());\n+        Set<RollbackRule> rollbackRules = new LinkedHashSet<>();\n+        for (Class<?> rbRule : globalTrx.getRollbackFor()) {\n+            rollbackRules.add(new RollbackRule(rbRule));\n+        }\n+        for (String rbRule : globalTrx.getRollbackForClassName()) {\n+            rollbackRules.add(new RollbackRule(rbRule));\n+        }\n+        for (Class<?> rbRule : globalTrx.getNoRollbackFor()) {\n+            rollbackRules.add(new NoRollbackRule(rbRule));\n+        }\n+        for (String rbRule : globalTrx.getNoRollbackForClassName()) {\n+            rollbackRules.add(new NoRollbackRule(rbRule));\n+        }\n+        transactionInfo.setRollbackRules(rollbackRules);\n+        return transactionInfo;\n+    }\n+\n+    private Throwable switchExecutionException(TransactionalExecutor.ExecutionException e,\n+        FailureHandler failureHandler) throws Throwable {\n+        TransactionalExecutor.Code code = e.getCode();\n+        switch (code) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c9322c22eaeb1a14eca80bbf7181546774033361"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM3NzQ4Ng==", "bodyText": "Why remove the degrade check?\n\nPTAL", "url": "https://github.com/seata/seata/pull/2568#discussion_r432377486", "createdAt": "2020-05-29T09:49:51Z", "author": {"login": "a364176773"}, "path": "spring/src/main/java/io/seata/spring/annotation/HandleGlobalTransaction.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.spring.annotation;\n+\n+import java.lang.reflect.Method;\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+\n+import org.aopalliance.intercept.MethodInvocation;\n+\n+import io.seata.common.exception.ShouldNeverHappenException;\n+import io.seata.common.util.StringUtils;\n+import io.seata.tm.api.FailureHandler;\n+import io.seata.tm.api.TransactionalExecutor;\n+import io.seata.tm.api.TransactionalTemplate;\n+import io.seata.tm.api.transaction.NoRollbackRule;\n+import io.seata.tm.api.transaction.RollbackRule;\n+import io.seata.tm.api.transaction.TransactionInfo;\n+\n+/**\n+ * @author funkye\n+ * @date 2020/4/17\n+ */\n+public class HandleGlobalTransaction {\n+\n+    public Object runTransaction(final MethodInvocation methodInvocation, final Object globalTrxAnno,\n+        final FailureHandler failureHandler, final TransactionalTemplate transactionalTemplate) throws Throwable {\n+        try {\n+            return transactionalTemplate.execute(new TransactionalExecutor() {\n+                @Override\n+                public Object execute() throws Throwable {\n+                    return methodInvocation.proceed();\n+                }\n+\n+                @Override\n+                public TransactionInfo getTransactionInfo() {\n+                    return getInfo(globalTrxAnno, methodInvocation.getMethod());\n+                }\n+\n+            });\n+        } catch (TransactionalExecutor.ExecutionException e) {\n+            throw switchExecutionException(e, failureHandler);\n+        }\n+    }\n+\n+    private TransactionInfo getInfo(Object globalTrxAnno, Method method) {\n+        TransactionInfo transactionInfo = new TransactionInfo();\n+        AtTransactional globalTrx = convertAtTransactional(globalTrxAnno);\n+        transactionInfo.setTimeOut(globalTrx.getTimeoutMills());\n+        String name = globalTrx.getName();\n+        if (StringUtils.isNullOrEmpty(name)) {\n+            name = formatMethod(method);\n+        }\n+        transactionInfo.setName(name);\n+        transactionInfo.setPropagation(globalTrx.getPropagation());\n+        Set<RollbackRule> rollbackRules = new LinkedHashSet<>();\n+        for (Class<?> rbRule : globalTrx.getRollbackFor()) {\n+            rollbackRules.add(new RollbackRule(rbRule));\n+        }\n+        for (String rbRule : globalTrx.getRollbackForClassName()) {\n+            rollbackRules.add(new RollbackRule(rbRule));\n+        }\n+        for (Class<?> rbRule : globalTrx.getNoRollbackFor()) {\n+            rollbackRules.add(new NoRollbackRule(rbRule));\n+        }\n+        for (String rbRule : globalTrx.getNoRollbackForClassName()) {\n+            rollbackRules.add(new NoRollbackRule(rbRule));\n+        }\n+        transactionInfo.setRollbackRules(rollbackRules);\n+        return transactionInfo;\n+    }\n+\n+    private Throwable switchExecutionException(TransactionalExecutor.ExecutionException e,\n+        FailureHandler failureHandler) throws Throwable {\n+        TransactionalExecutor.Code code = e.getCode();\n+        switch (code) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI5MTI3NQ=="}, "originalCommit": {"oid": "c9322c22eaeb1a14eca80bbf7181546774033361"}, "originalPosition": 89}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1548, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}