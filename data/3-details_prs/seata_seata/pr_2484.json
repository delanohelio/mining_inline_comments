{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk1NDMyODg4", "number": 2484, "title": "feature: store mode add redis realize", "bodyText": "\u2160. Describe what this PR did\nstore mode add redis realize\n\u2161. Does this pull request fix one issue?\n\n\u2162. Why don't you add test cases (unit test/integration test)?\n\u2163. Describe how to verify it\n\u2164. Special notes for reviews", "createdAt": "2020-03-30T06:21:50Z", "url": "https://github.com/seata/seata/pull/2484", "merged": true, "mergeCommit": {"oid": "5443e151d21f7c9ad0161dd63f8f37ca807b3499"}, "closed": true, "closedAt": "2020-06-03T04:26:35Z", "author": {"login": "a364176773"}, "timelineItems": {"totalCount": 84, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcSoPf5gH2gAyMzk1NDMyODg4OmQyZTM0YWM0ZTg0NzcxMTUwNTFjOTgzZDFjMDg5Mzg3MzEyZjA4ZTA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcnhuGcgFqTQyMzIwOTI1Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "d2e34ac4e8477115051c983d1c089387312f08e0", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/d2e34ac4e8477115051c983d1c089387312f08e0", "committedDate": "2020-03-30T06:09:51Z", "message": "store mode add redis realize"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "19b563e61617a4e9d70dac6a50ae48e9c4c2a241", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/19b563e61617a4e9d70dac6a50ae48e9c4c2a241", "committedDate": "2020-03-30T06:20:03Z", "message": "optimize branch transaction deletion logic"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "40a44f5f84582676b17ed1f0312fe0115c65eed3", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/40a44f5f84582676b17ed1f0312fe0115c65eed3", "committedDate": "2020-03-30T06:34:37Z", "message": "supplement config txt"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "29776c9567e2ff35ca3b832b08e741a6097ed24a", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/29776c9567e2ff35ca3b832b08e741a6097ed24a", "committedDate": "2020-03-30T06:58:27Z", "message": "optimize the redis lock"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "602d31394b8daa6db4419a1cf1d2da528d9ac2b8", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/602d31394b8daa6db4419a1cf1d2da528d9ac2b8", "committedDate": "2020-03-31T02:41:15Z", "message": "add test cases"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3b5f444bb80cf3d3d793ab204429c3bc2bb4d326", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/3b5f444bb80cf3d3d793ab204429c3bc2bb4d326", "committedDate": "2020-03-31T05:29:30Z", "message": "add mock-jedis used for jedis testing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7f6c3dd9c5263ec4647a6ff1d5288bddbb61e80f", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/7f6c3dd9c5263ec4647a6ff1d5288bddbb61e80f", "committedDate": "2020-03-31T05:43:58Z", "message": "add mock-jedis used for jedis testing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f4fffd761830031053467b9ae2c5dca9d984ac57", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/f4fffd761830031053467b9ae2c5dca9d984ac57", "committedDate": "2020-03-31T06:43:09Z", "message": "modify the test cases"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "14cb9b51ad20ef1cb60af3317492e45f8beb413a", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/14cb9b51ad20ef1cb60af3317492e45f8beb413a", "committedDate": "2020-03-31T06:49:57Z", "message": "Merge remote-tracking branch 'seata-develop/develop' into store_mode_redis"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "da00ecfcea4ce0c8260cc15a0f1adf097018ee3c", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/da00ecfcea4ce0c8260cc15a0f1adf097018ee3c", "committedDate": "2020-03-31T09:35:55Z", "message": "Merge branch 'develop' into store_mode_redis"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0f05f8f98438414a2eefa46a1b79f04c390fb344", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/0f05f8f98438414a2eefa46a1b79f04c390fb344", "committedDate": "2020-04-01T01:35:35Z", "message": "Merge branch 'develop' into store_mode_redis"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "95feb53a68924a89a6b9ec74e06a942e799fe377", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/95feb53a68924a89a6b9ec74e06a942e799fe377", "committedDate": "2020-04-01T05:49:00Z", "message": "Merge branch 'develop' into store_mode_redis"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "24e0025d70965874ddcf7823330a66ef67bc2c21", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/24e0025d70965874ddcf7823330a66ef67bc2c21", "committedDate": "2020-04-01T08:10:32Z", "message": "Merge branch 'develop' into store_mode_redis"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f217afa32ddc336268dc8fe71cd59e83d3efa05d", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/f217afa32ddc336268dc8fe71cd59e83d3efa05d", "committedDate": "2020-04-03T09:04:15Z", "message": "Merge branch 'develop' into store_mode_redis"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b9943de3030b292f2546490c2f3fa2b7afeaef46", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/b9943de3030b292f2546490c2f3fa2b7afeaef46", "committedDate": "2020-04-03T09:40:40Z", "message": "added redis transaction"}, "afterCommit": {"oid": "f217afa32ddc336268dc8fe71cd59e83d3efa05d", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/f217afa32ddc336268dc8fe71cd59e83d3efa05d", "committedDate": "2020-04-03T09:04:15Z", "message": "Merge branch 'develop' into store_mode_redis"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f672061fbc7184ef4adc9a7d42b0977519cfa1a6", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/f672061fbc7184ef4adc9a7d42b0977519cfa1a6", "committedDate": "2020-04-07T01:39:23Z", "message": "Merge branch 'develop' into store_mode_redis"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6d51b8a44cf313ce5593fe1d26f3c1debd57fbc5", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/6d51b8a44cf313ce5593fe1d26f3c1debd57fbc5", "committedDate": "2020-04-08T05:21:02Z", "message": "Merge branch 'develop' into store_mode_redis"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7a62d35a433609655548ffdef53ec22cea68a770", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/7a62d35a433609655548ffdef53ec22cea68a770", "committedDate": "2020-04-08T05:53:03Z", "message": "fix bug"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1f36bb96eeaf590168c3d9d683f5679949d06517", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/1f36bb96eeaf590168c3d9d683f5679949d06517", "committedDate": "2020-04-10T03:18:53Z", "message": "Merge branch 'develop' into store_mode_redis"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c6e1038e6b3ce788a23a058bddd8d4a402e9ee93", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/c6e1038e6b3ce788a23a058bddd8d4a402e9ee93", "committedDate": "2020-04-10T09:15:17Z", "message": "Merge branch 'develop' into store_mode_redis"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "47676712f84cf5b52607cf627014cc95170d224b", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/47676712f84cf5b52607cf627014cc95170d224b", "committedDate": "2020-04-26T12:00:57Z", "message": "resolve conflict"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a0af6faed8042c4b2fea88d1a6445fa0d44b5adf", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/a0af6faed8042c4b2fea88d1a6445fa0d44b5adf", "committedDate": "2020-04-29T07:21:31Z", "message": "optimize code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "44e380055eb2d7b242e0a9f7622c330f8a45e5a2", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/44e380055eb2d7b242e0a9f7622c330f8a45e5a2", "committedDate": "2020-05-04T06:50:14Z", "message": "Merge branch 'develop' into store_mode_redis"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5ee3146c2cd4c9fd88ba81b0ad21c16a51b4f3ec", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/5ee3146c2cd4c9fd88ba81b0ad21c16a51b4f3ec", "committedDate": "2020-05-05T03:34:41Z", "message": "Merge branch 'develop' into store_mode_redis"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6492264df0ede284ba8a93257b695f3fa1b82a03", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/6492264df0ede284ba8a93257b695f3fa1b82a03", "committedDate": "2020-05-05T04:20:05Z", "message": "fix bug"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "77fe9d3764b96d49d1d0c22794daf047871101e6", "author": {"user": {"login": "jsbxyyx", "name": "jsbxyyx"}}, "url": "https://github.com/seata/seata/commit/77fe9d3764b96d49d1d0c22794daf047871101e6", "committedDate": "2020-05-06T01:28:00Z", "message": "Merge branch 'develop' into store_mode_redis"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c7ce49fdab71fa46f0d1a5b94a554928fb78ff25", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/c7ce49fdab71fa46f0d1a5b94a554928fb78ff25", "committedDate": "2020-05-06T12:21:23Z", "message": "Merge branch 'develop' into store_mode_redis"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d72ab3bcbc115985ff0aa2e253b8be6d327e4f65", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/d72ab3bcbc115985ff0aa2e253b8be6d327e4f65", "committedDate": "2020-05-08T08:08:22Z", "message": "resolve conflicts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a0d1a49a78008deca406bfaa8f218950be3f0b5a", "author": {"user": {"login": "jsbxyyx", "name": "jsbxyyx"}}, "url": "https://github.com/seata/seata/commit/a0d1a49a78008deca406bfaa8f218950be3f0b5a", "committedDate": "2020-05-09T09:47:42Z", "message": "Merge branch 'develop' into store_mode_redis"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA5MDAyNTk5", "url": "https://github.com/seata/seata/pull/2484#pullrequestreview-409002599", "createdAt": "2020-05-11T09:21:03Z", "commit": {"oid": "a0d1a49a78008deca406bfaa8f218950be3f0b5a"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQwOToyMTowM1rOGTT8vw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQwOToyMToyNlrOGTT9qg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjkwMjk3NQ==", "bodyText": "why 100?", "url": "https://github.com/seata/seata/pull/2484#discussion_r422902975", "createdAt": "2020-05-11T09:21:03Z", "author": {"login": "jsbxyyx"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.lock;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import com.alibaba.fastjson.JSON;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.core.lock.AbstractLocker;\n+import io.seata.core.lock.RowLock;\n+import io.seata.core.store.LockDO;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import redis.clients.jedis.Jedis;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisLocker extends AbstractLocker {\n+\n+    private static final Integer DEFAULT_SECONDS = 30;\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_PREFIX = \"SEATA_LOCK_\";\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX = \"SEATA_LOCK_XID_\";\n+\n+    /**\n+     * Instantiates a new Redis locker.\n+     *\n+     */\n+    public RedisLocker() {}\n+\n+    @Override\n+    public boolean acquireLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        List<String> successList = new ArrayList<>();\n+        long status = 0;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<LockDO> locks = convertToLockDO(rowLocks);\n+            for (LockDO lock : locks) {\n+                String key = DEFAULT_REDIS_SEATA_LOCK_PREFIX + lock.getRowKey();\n+                status = jedis.setnx(key, JSON.toJSONString(lock));\n+                if (status == 1) {\n+                    successList.add(key);\n+                    jedis.lpush(DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX + lock.getXid(), key);\n+                    jedis.expire(key, DEFAULT_SECONDS);\n+                } else {\n+                    break;\n+                }\n+            }\n+            if (status != 1) {\n+                String[] rms = successList.toArray(new String[successList.size()]);\n+                if (rms.length > 0) {\n+                    jedis.del(rms);\n+                }\n+                return false;\n+            } else {\n+                return true;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        String[] keys = new String[rowLocks.size()];\n+        List<LockDO> locks = convertToLockDO(rowLocks);\n+        for (int i = 0; i < locks.size(); i++) {\n+            String key = DEFAULT_REDIS_SEATA_LOCK_PREFIX + locks.get(i).getRowKey();\n+            keys[i] = key;\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            jedis.del(keys);\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(String xid, List<Long> branchIds) {\n+        if (CollectionUtils.isEmpty(branchIds)) {\n+            // no lock\n+            return true;\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String lockListKey = DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX + xid;\n+            List<String> keys = jedis.lrange(lockListKey, 0, 100);\n+            if (null != keys && keys.size() > 0) {\n+                Iterator<String> it = keys.iterator();\n+                while (it.hasNext()) {\n+                    String key = it.next();\n+                    LockDO lock = JSON.parseObject(jedis.get(key), LockDO.class);\n+                    for (int i = 0; i < branchIds.size(); i++) {\n+                        if (lock.getBranchId().equals(branchIds.get(i))) {\n+                            jedis.del(key);\n+                            jedis.lrem(lockListKey, 0, key);\n+                            it.remove();\n+                        }\n+                    }\n+                }\n+                if (keys.size() == 0) {\n+                    jedis.del(lockListKey);\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(String xid, Long branchId) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String lockListKey = DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX + xid;\n+            List<String> keys = jedis.lrange(lockListKey, 0, 100);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a0d1a49a78008deca406bfaa8f218950be3f0b5a"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjkwMzIxMA==", "bodyText": "why 100?", "url": "https://github.com/seata/seata/pull/2484#discussion_r422903210", "createdAt": "2020-05-11T09:21:26Z", "author": {"login": "jsbxyyx"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.lock;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import com.alibaba.fastjson.JSON;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.core.lock.AbstractLocker;\n+import io.seata.core.lock.RowLock;\n+import io.seata.core.store.LockDO;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import redis.clients.jedis.Jedis;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisLocker extends AbstractLocker {\n+\n+    private static final Integer DEFAULT_SECONDS = 30;\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_PREFIX = \"SEATA_LOCK_\";\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX = \"SEATA_LOCK_XID_\";\n+\n+    /**\n+     * Instantiates a new Redis locker.\n+     *\n+     */\n+    public RedisLocker() {}\n+\n+    @Override\n+    public boolean acquireLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        List<String> successList = new ArrayList<>();\n+        long status = 0;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<LockDO> locks = convertToLockDO(rowLocks);\n+            for (LockDO lock : locks) {\n+                String key = DEFAULT_REDIS_SEATA_LOCK_PREFIX + lock.getRowKey();\n+                status = jedis.setnx(key, JSON.toJSONString(lock));\n+                if (status == 1) {\n+                    successList.add(key);\n+                    jedis.lpush(DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX + lock.getXid(), key);\n+                    jedis.expire(key, DEFAULT_SECONDS);\n+                } else {\n+                    break;\n+                }\n+            }\n+            if (status != 1) {\n+                String[] rms = successList.toArray(new String[successList.size()]);\n+                if (rms.length > 0) {\n+                    jedis.del(rms);\n+                }\n+                return false;\n+            } else {\n+                return true;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        String[] keys = new String[rowLocks.size()];\n+        List<LockDO> locks = convertToLockDO(rowLocks);\n+        for (int i = 0; i < locks.size(); i++) {\n+            String key = DEFAULT_REDIS_SEATA_LOCK_PREFIX + locks.get(i).getRowKey();\n+            keys[i] = key;\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            jedis.del(keys);\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(String xid, List<Long> branchIds) {\n+        if (CollectionUtils.isEmpty(branchIds)) {\n+            // no lock\n+            return true;\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String lockListKey = DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX + xid;\n+            List<String> keys = jedis.lrange(lockListKey, 0, 100);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a0d1a49a78008deca406bfaa8f218950be3f0b5a"}, "originalPosition": 106}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "03c91a2cc629642102ba7bf3b631fa4c16421720", "author": {"user": {"login": "jsbxyyx", "name": "jsbxyyx"}}, "url": "https://github.com/seata/seata/commit/03c91a2cc629642102ba7bf3b631fa4c16421720", "committedDate": "2020-05-11T09:22:07Z", "message": "Merge branch 'develop' into store_mode_redis"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7fc4858e47f9c20bbf41dcb7ad507edbc44dadc5", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/7fc4858e47f9c20bbf41dcb7ad507edbc44dadc5", "committedDate": "2020-05-11T09:54:09Z", "message": "optimize code and fix bug"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f950e0f640fa052576566e290fe9cc547f90ab33", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/f950e0f640fa052576566e290fe9cc547f90ab33", "committedDate": "2020-05-11T09:55:04Z", "message": "Merge branch 'store_mode_redis' of https://github.com/a364176773/seata into store_mode_redis"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1b8076a4d18384adbefd191dd28c197f3aae7b41", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/1b8076a4d18384adbefd191dd28c197f3aae7b41", "committedDate": "2020-05-11T15:04:48Z", "message": "bug fix"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA5NjQyMTYw", "url": "https://github.com/seata/seata/pull/2484#pullrequestreview-409642160", "createdAt": "2020-05-12T01:39:11Z", "commit": {"oid": "1b8076a4d18384adbefd191dd28c197f3aae7b41"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwMTozOToxMVrOGTzIZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwMTozOToxMVrOGTzIZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQxMzg2Mw==", "bodyText": "Objects.equals() ?", "url": "https://github.com/seata/seata/pull/2484#discussion_r423413863", "createdAt": "2020-05-12T01:39:11Z", "author": {"login": "jsbxyyx"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -135,7 +135,7 @@ public boolean releaseLock(String xid, Long branchId) {\n                 while (it.hasNext()) {\n                     String key = it.next();\n                     LockDO lock = JSON.parseObject(jedis.get(key), LockDO.class);\n-                    if (null != lock && lock.getBranchId().equals(branchId)) {\n+                    if (null != lock && branchId.equals(lock.getBranchId())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b8076a4d18384adbefd191dd28c197f3aae7b41"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "49abe6e61f1365055f1fbc3cf36483f2800a5988", "author": {"user": {"login": "jsbxyyx", "name": "jsbxyyx"}}, "url": "https://github.com/seata/seata/commit/49abe6e61f1365055f1fbc3cf36483f2800a5988", "committedDate": "2020-05-12T01:39:30Z", "message": "Merge branch 'develop' into store_mode_redis"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0bc1079cc93e931d37dcf88fd73cd40417138632", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/0bc1079cc93e931d37dcf88fd73cd40417138632", "committedDate": "2020-05-12T02:04:23Z", "message": "optimize code and fix bug"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "63ceb3b9d11e072de6a71ba8d7cc73b7499d3803", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/63ceb3b9d11e072de6a71ba8d7cc73b7499d3803", "committedDate": "2020-05-12T02:18:38Z", "message": "optimize code and fix bug"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0e29bee7096efbeb9ed66d5c98a659cf43cdb29f", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/0e29bee7096efbeb9ed66d5c98a659cf43cdb29f", "committedDate": "2020-05-12T06:30:50Z", "message": "optimized code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0fcac9ecdd2fc52cdeb2465f823305a08790adec", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/0fcac9ecdd2fc52cdeb2465f823305a08790adec", "committedDate": "2020-05-12T06:35:01Z", "message": "Merge branch 'develop' into store_mode_redis"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "25085db6ba7d9a1efcbecfa1d7483569bd0e3bcf", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/25085db6ba7d9a1efcbecfa1d7483569bd0e3bcf", "committedDate": "2020-05-13T05:51:08Z", "message": "bug fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "34bb3e1a86383a254ee4b33148f8b842518214e6", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/34bb3e1a86383a254ee4b33148f8b842518214e6", "committedDate": "2020-05-13T05:59:39Z", "message": "optimize code"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEwNjczNTg2", "url": "https://github.com/seata/seata/pull/2484#pullrequestreview-410673586", "createdAt": "2020-05-13T07:53:02Z", "commit": {"oid": "34bb3e1a86383a254ee4b33148f8b842518214e6"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwNzo1MzowMlrOGUlpzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwNzo1NDoxMlrOGUlshQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI0MTYxNQ==", "bodyText": "100 need change.", "url": "https://github.com/seata/seata/pull/2484#discussion_r424241615", "createdAt": "2020-05-13T07:53:02Z", "author": {"login": "jsbxyyx"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.lock;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.core.lock.AbstractLocker;\n+import io.seata.core.lock.RowLock;\n+import io.seata.core.store.LockDO;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import redis.clients.jedis.Jedis;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisLocker extends AbstractLocker {\n+\n+    private static final Integer DEFAULT_SECONDS = 30;\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_PREFIX = \"SEATA_LOCK_\";\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX = \"SEATA_LOCK_XID_\";\n+\n+    /**\n+     * Instantiates a new Redis locker.\n+     *\n+     */\n+    public RedisLocker() {}\n+\n+    @Override\n+    public boolean acquireLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        List<String> successList = new ArrayList<>();\n+        long status = 0;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<LockDO> locks = convertToLockDO(rowLocks);\n+            for (LockDO lock : locks) {\n+                String key = DEFAULT_REDIS_SEATA_LOCK_PREFIX + lock.getRowKey();\n+                status = jedis.setnx(key, JSON.toJSONString(lock));\n+                if (status == 1) {\n+                    successList.add(key);\n+                    jedis.lpush(DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX + lock.getXid(), key);\n+                    jedis.expire(key, DEFAULT_SECONDS);\n+                } else {\n+                    break;\n+                }\n+            }\n+            if (status != 1) {\n+                String[] rms = successList.toArray(new String[successList.size()]);\n+                if (rms.length > 0) {\n+                    jedis.del(rms);\n+                }\n+                return false;\n+            } else {\n+                return true;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        String[] keys = new String[rowLocks.size()];\n+        List<LockDO> locks = convertToLockDO(rowLocks);\n+        for (int i = 0; i < locks.size(); i++) {\n+            String key = DEFAULT_REDIS_SEATA_LOCK_PREFIX + locks.get(i).getRowKey();\n+            keys[i] = key;\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            jedis.del(keys);\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(String xid, List<Long> branchIds) {\n+        if (CollectionUtils.isEmpty(branchIds)) {\n+            // no lock\n+            return true;\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String lockListKey = DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX + xid;\n+            Set<String> keys = new HashSet<>();\n+            List<String> redisLockJson = null;\n+            int start = 0;\n+            do {\n+                redisLockJson = jedis.lrange(lockListKey, start, 100);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34bb3e1a86383a254ee4b33148f8b842518214e6"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI0MTcyMg==", "bodyText": "100 need change.", "url": "https://github.com/seata/seata/pull/2484#discussion_r424241722", "createdAt": "2020-05-13T07:53:13Z", "author": {"login": "jsbxyyx"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.lock;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.core.lock.AbstractLocker;\n+import io.seata.core.lock.RowLock;\n+import io.seata.core.store.LockDO;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import redis.clients.jedis.Jedis;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisLocker extends AbstractLocker {\n+\n+    private static final Integer DEFAULT_SECONDS = 30;\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_PREFIX = \"SEATA_LOCK_\";\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX = \"SEATA_LOCK_XID_\";\n+\n+    /**\n+     * Instantiates a new Redis locker.\n+     *\n+     */\n+    public RedisLocker() {}\n+\n+    @Override\n+    public boolean acquireLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        List<String> successList = new ArrayList<>();\n+        long status = 0;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<LockDO> locks = convertToLockDO(rowLocks);\n+            for (LockDO lock : locks) {\n+                String key = DEFAULT_REDIS_SEATA_LOCK_PREFIX + lock.getRowKey();\n+                status = jedis.setnx(key, JSON.toJSONString(lock));\n+                if (status == 1) {\n+                    successList.add(key);\n+                    jedis.lpush(DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX + lock.getXid(), key);\n+                    jedis.expire(key, DEFAULT_SECONDS);\n+                } else {\n+                    break;\n+                }\n+            }\n+            if (status != 1) {\n+                String[] rms = successList.toArray(new String[successList.size()]);\n+                if (rms.length > 0) {\n+                    jedis.del(rms);\n+                }\n+                return false;\n+            } else {\n+                return true;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        String[] keys = new String[rowLocks.size()];\n+        List<LockDO> locks = convertToLockDO(rowLocks);\n+        for (int i = 0; i < locks.size(); i++) {\n+            String key = DEFAULT_REDIS_SEATA_LOCK_PREFIX + locks.get(i).getRowKey();\n+            keys[i] = key;\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            jedis.del(keys);\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(String xid, List<Long> branchIds) {\n+        if (CollectionUtils.isEmpty(branchIds)) {\n+            // no lock\n+            return true;\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String lockListKey = DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX + xid;\n+            Set<String> keys = new HashSet<>();\n+            List<String> redisLockJson = null;\n+            int start = 0;\n+            do {\n+                redisLockJson = jedis.lrange(lockListKey, start, 100);\n+                if (null != redisLockJson) {\n+                    keys.addAll(redisLockJson);\n+                    start = keys.size();\n+                }\n+            } while (null != redisLockJson && redisLockJson.size() >= 100);\n+            if (null != keys && keys.size() > 0) {\n+                Iterator<String> it = keys.iterator();\n+                while (it.hasNext()) {\n+                    String key = it.next();\n+                    LockDO lock = JSON.parseObject(jedis.get(key), LockDO.class);\n+                    for (int i = 0; i < branchIds.size(); i++) {\n+                        if (null != lock && Objects.equals(lock.getBranchId(), branchIds.get(i))) {\n+                            jedis.del(key);\n+                            jedis.lrem(lockListKey, 0, key);\n+                            it.remove();\n+                        }\n+                    }\n+                }\n+                if (keys.size() == 0) {\n+                    jedis.del(lockListKey);\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(String xid, Long branchId) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String lockListKey = DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX + xid;\n+            Set<String> keys = new HashSet<>();\n+            List<String> redisLockJson = null;\n+            int start = 0;\n+            do {\n+                redisLockJson = jedis.lrange(lockListKey, start, 100);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34bb3e1a86383a254ee4b33148f8b842518214e6"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI0MTkzNg==", "bodyText": "100 need change.", "url": "https://github.com/seata/seata/pull/2484#discussion_r424241936", "createdAt": "2020-05-13T07:53:34Z", "author": {"login": "jsbxyyx"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,428 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO convertBranchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String branchsKey = DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + convertBranchTransactionDO.getXid();\n+            Set<String> branchs = new HashSet<>();\n+            List<String> redisBranchJson = null;\n+            int start = 0;\n+            do {\n+                redisBranchJson = jedis.lrange(branchsKey, start, 100);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34bb3e1a86383a254ee4b33148f8b842518214e6"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI0MjA1NQ==", "bodyText": "100 need change.", "url": "https://github.com/seata/seata/pull/2484#discussion_r424242055", "createdAt": "2020-05-13T07:53:46Z", "author": {"login": "jsbxyyx"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,428 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO convertBranchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String branchsKey = DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + convertBranchTransactionDO.getXid();\n+            Set<String> branchs = new HashSet<>();\n+            List<String> redisBranchJson = null;\n+            int start = 0;\n+            do {\n+                redisBranchJson = jedis.lrange(branchsKey, start, 100);\n+                if (null != redisBranchJson) {\n+                    branchs.addAll(redisBranchJson);\n+                    start = branchs.size();\n+                }\n+            } while (null != redisBranchJson && redisBranchJson.size() >= 100);\n+            if (null != branchs && branchs.size() > 0) {\n+                String key = DEFAULT_REDIS_SEATA_BRANCH_PREFIX + convertBranchTransactionDO.getBranchId();\n+                Iterator<String> it = branchs.iterator();\n+                while (it.hasNext()) {\n+                    String s = it.next();\n+                    if (Objects.equals(s, key)) {\n+                        it.remove();\n+                        jedis.del(key);\n+                        jedis.lrem(branchsKey, 0, key);\n+                        break;\n+                    }\n+                }\n+                if (branchs.size() == 0) {\n+                    jedis.del(branchsKey);\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO convertBranchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = DEFAULT_REDIS_SEATA_BRANCH_PREFIX + convertBranchTransactionDO.getBranchId();\n+            if (jedis.get(key) == null) {\n+                jedis.lpush(DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + convertBranchTransactionDO.getXid(), key);\n+            }\n+            jedis.set(key, JSON.toJSONString(convertBranchTransactionDO));\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String[] keys = new String[3];\n+            keys[0] = DEFAULT_REDIS_SEATA_GLOBAL_PREFIX + convertGlobalTransactionDO.getXid();\n+            keys[1] = DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX + convertGlobalTransactionDO.getTransactionId();\n+            String branchsKey = DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + convertGlobalTransactionDO.getXid();\n+            List<String> redisBranchs = jedis.lrange(branchsKey, 0, 1);\n+            if (null == redisBranchs || redisBranchs.size() <= 0) {\n+                keys[2] = branchsKey;\n+            }\n+            jedis.del(keys);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String keys = DEFAULT_REDIS_SEATA_GLOBAL_PREFIX + convertGlobalTransactionDO.getXid();\n+            jedis.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            keys = DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX + convertGlobalTransactionDO.getTransactionId();\n+            jedis.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @param withBranchSessions\n+     *            the withBranchSessions\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid, boolean withBranchSessions) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            globalSessionJson = jedis.get(DEFAULT_REDIS_SEATA_GLOBAL_PREFIX + xid);\n+            if (StringUtils.isBlank(globalSessionJson)) {\n+                return null;\n+            }\n+            // global transaction\n+            GlobalTransactionDO globalTransactionDO = JSON.parseObject(globalSessionJson, GlobalTransactionDO.class);\n+            if (globalTransactionDO == null) {\n+                return null;\n+            }\n+            // branch transactions\n+            List<BranchTransactionDO> branchTransactionDOs = null;\n+            // reduce rpc with db when branchRegister and getGlobalStatus\n+            if (withBranchSessions) {\n+                Set<String> branchJson = new HashSet<>();\n+                int start = 0;\n+                List<String> redisBranchJson = null;\n+                do {\n+                    redisBranchJson =\n+                        jedis.lrange(DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + globalTransactionDO.getXid(), start, 100);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34bb3e1a86383a254ee4b33148f8b842518214e6"}, "originalPosition": 201}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI0MjE3Mw==", "bodyText": "100 need change.", "url": "https://github.com/seata/seata/pull/2484#discussion_r424242173", "createdAt": "2020-05-13T07:53:57Z", "author": {"login": "jsbxyyx"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,428 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO convertBranchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String branchsKey = DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + convertBranchTransactionDO.getXid();\n+            Set<String> branchs = new HashSet<>();\n+            List<String> redisBranchJson = null;\n+            int start = 0;\n+            do {\n+                redisBranchJson = jedis.lrange(branchsKey, start, 100);\n+                if (null != redisBranchJson) {\n+                    branchs.addAll(redisBranchJson);\n+                    start = branchs.size();\n+                }\n+            } while (null != redisBranchJson && redisBranchJson.size() >= 100);\n+            if (null != branchs && branchs.size() > 0) {\n+                String key = DEFAULT_REDIS_SEATA_BRANCH_PREFIX + convertBranchTransactionDO.getBranchId();\n+                Iterator<String> it = branchs.iterator();\n+                while (it.hasNext()) {\n+                    String s = it.next();\n+                    if (Objects.equals(s, key)) {\n+                        it.remove();\n+                        jedis.del(key);\n+                        jedis.lrem(branchsKey, 0, key);\n+                        break;\n+                    }\n+                }\n+                if (branchs.size() == 0) {\n+                    jedis.del(branchsKey);\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO convertBranchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = DEFAULT_REDIS_SEATA_BRANCH_PREFIX + convertBranchTransactionDO.getBranchId();\n+            if (jedis.get(key) == null) {\n+                jedis.lpush(DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + convertBranchTransactionDO.getXid(), key);\n+            }\n+            jedis.set(key, JSON.toJSONString(convertBranchTransactionDO));\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String[] keys = new String[3];\n+            keys[0] = DEFAULT_REDIS_SEATA_GLOBAL_PREFIX + convertGlobalTransactionDO.getXid();\n+            keys[1] = DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX + convertGlobalTransactionDO.getTransactionId();\n+            String branchsKey = DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + convertGlobalTransactionDO.getXid();\n+            List<String> redisBranchs = jedis.lrange(branchsKey, 0, 1);\n+            if (null == redisBranchs || redisBranchs.size() <= 0) {\n+                keys[2] = branchsKey;\n+            }\n+            jedis.del(keys);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String keys = DEFAULT_REDIS_SEATA_GLOBAL_PREFIX + convertGlobalTransactionDO.getXid();\n+            jedis.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            keys = DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX + convertGlobalTransactionDO.getTransactionId();\n+            jedis.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @param withBranchSessions\n+     *            the withBranchSessions\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid, boolean withBranchSessions) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            globalSessionJson = jedis.get(DEFAULT_REDIS_SEATA_GLOBAL_PREFIX + xid);\n+            if (StringUtils.isBlank(globalSessionJson)) {\n+                return null;\n+            }\n+            // global transaction\n+            GlobalTransactionDO globalTransactionDO = JSON.parseObject(globalSessionJson, GlobalTransactionDO.class);\n+            if (globalTransactionDO == null) {\n+                return null;\n+            }\n+            // branch transactions\n+            List<BranchTransactionDO> branchTransactionDOs = null;\n+            // reduce rpc with db when branchRegister and getGlobalStatus\n+            if (withBranchSessions) {\n+                Set<String> branchJson = new HashSet<>();\n+                int start = 0;\n+                List<String> redisBranchJson = null;\n+                do {\n+                    redisBranchJson =\n+                        jedis.lrange(DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + globalTransactionDO.getXid(), start, 100);\n+                    if (null != redisBranchJson) {\n+                        branchJson.addAll(redisBranchJson);\n+                        start = branchJson.size();\n+                    }\n+                } while (null != redisBranchJson && redisBranchJson.size() >= 100);\n+                if (null != branchJson && branchJson.size() > 0) {\n+                    branchTransactionDOs = new ArrayList<>();\n+                    for (String s : branchJson) {\n+                        branchTransactionDOs.add(JSON.parseObject(jedis.get(s), BranchTransactionDO.class));\n+                    }\n+                }\n+            }\n+            return getGlobalSession(globalTransactionDO, branchTransactionDOs);\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid) {\n+        return this.readSession(xid, true);\n+    }\n+\n+    /**\n+     * Read session list.\n+     *\n+     * @param statuses\n+     *            the statuses\n+     * @return the list\n+     */\n+    public List<GlobalSession> readSession(GlobalStatus[] statuses) {\n+        List<Integer> states = new ArrayList<>();\n+        for (int i = 0; i < statuses.length; i++) {\n+            states.add(statuses[i].getCode());\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Set<String> keys = new HashSet<>();\n+            String cursor = \"0\";\n+            ScanParams params = new ScanParams();\n+            params.count(100);\n+            params.match(DEFAULT_REDIS_SEATA_GLOBAL_PREFIX + \"*\");\n+            ScanResult<String> scans;\n+            do {\n+                scans = jedis.scan(cursor, params);\n+                keys.addAll(scans.getResult().stream().collect(Collectors.toSet()));\n+                cursor = scans.getCursor();\n+            } while (!cursor.equalsIgnoreCase(\"0\"));\n+            if (null != keys && keys.size() > 0) {\n+                List<GlobalTransactionDO> globalTransactionDOs = new ArrayList<>();\n+                for (String globalKey : keys) {\n+                    GlobalTransactionDO globalTransactionDO =\n+                        JSON.parseObject(jedis.get(globalKey), GlobalTransactionDO.class);\n+                    if (null != globalTransactionDO && states.contains(globalTransactionDO.getStatus())) {\n+                        globalTransactionDOs.add(globalTransactionDO);\n+                    }\n+                }\n+                if (globalTransactionDOs.size() > 0) {\n+                    List<String> xids =\n+                        globalTransactionDOs.stream().map(GlobalTransactionDO::getXid).collect(Collectors.toList());\n+                    List<BranchTransactionDO> branchTransactionDOs = new ArrayList<>();\n+                    for (String xid : xids) {\n+                        Set<String> branchs = new HashSet<>();\n+                        int start = 0;\n+                        List<String> redisBranchs = null;\n+                        do {\n+                            redisBranchs = jedis.lrange(DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + xid, start, 100);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34bb3e1a86383a254ee4b33148f8b842518214e6"}, "originalPosition": 272}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI0MjMwOQ==", "bodyText": "100 need change.", "url": "https://github.com/seata/seata/pull/2484#discussion_r424242309", "createdAt": "2020-05-13T07:54:12Z", "author": {"login": "jsbxyyx"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,428 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO convertBranchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String branchsKey = DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + convertBranchTransactionDO.getXid();\n+            Set<String> branchs = new HashSet<>();\n+            List<String> redisBranchJson = null;\n+            int start = 0;\n+            do {\n+                redisBranchJson = jedis.lrange(branchsKey, start, 100);\n+                if (null != redisBranchJson) {\n+                    branchs.addAll(redisBranchJson);\n+                    start = branchs.size();\n+                }\n+            } while (null != redisBranchJson && redisBranchJson.size() >= 100);\n+            if (null != branchs && branchs.size() > 0) {\n+                String key = DEFAULT_REDIS_SEATA_BRANCH_PREFIX + convertBranchTransactionDO.getBranchId();\n+                Iterator<String> it = branchs.iterator();\n+                while (it.hasNext()) {\n+                    String s = it.next();\n+                    if (Objects.equals(s, key)) {\n+                        it.remove();\n+                        jedis.del(key);\n+                        jedis.lrem(branchsKey, 0, key);\n+                        break;\n+                    }\n+                }\n+                if (branchs.size() == 0) {\n+                    jedis.del(branchsKey);\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO convertBranchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = DEFAULT_REDIS_SEATA_BRANCH_PREFIX + convertBranchTransactionDO.getBranchId();\n+            if (jedis.get(key) == null) {\n+                jedis.lpush(DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + convertBranchTransactionDO.getXid(), key);\n+            }\n+            jedis.set(key, JSON.toJSONString(convertBranchTransactionDO));\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String[] keys = new String[3];\n+            keys[0] = DEFAULT_REDIS_SEATA_GLOBAL_PREFIX + convertGlobalTransactionDO.getXid();\n+            keys[1] = DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX + convertGlobalTransactionDO.getTransactionId();\n+            String branchsKey = DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + convertGlobalTransactionDO.getXid();\n+            List<String> redisBranchs = jedis.lrange(branchsKey, 0, 1);\n+            if (null == redisBranchs || redisBranchs.size() <= 0) {\n+                keys[2] = branchsKey;\n+            }\n+            jedis.del(keys);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String keys = DEFAULT_REDIS_SEATA_GLOBAL_PREFIX + convertGlobalTransactionDO.getXid();\n+            jedis.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            keys = DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX + convertGlobalTransactionDO.getTransactionId();\n+            jedis.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @param withBranchSessions\n+     *            the withBranchSessions\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid, boolean withBranchSessions) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            globalSessionJson = jedis.get(DEFAULT_REDIS_SEATA_GLOBAL_PREFIX + xid);\n+            if (StringUtils.isBlank(globalSessionJson)) {\n+                return null;\n+            }\n+            // global transaction\n+            GlobalTransactionDO globalTransactionDO = JSON.parseObject(globalSessionJson, GlobalTransactionDO.class);\n+            if (globalTransactionDO == null) {\n+                return null;\n+            }\n+            // branch transactions\n+            List<BranchTransactionDO> branchTransactionDOs = null;\n+            // reduce rpc with db when branchRegister and getGlobalStatus\n+            if (withBranchSessions) {\n+                Set<String> branchJson = new HashSet<>();\n+                int start = 0;\n+                List<String> redisBranchJson = null;\n+                do {\n+                    redisBranchJson =\n+                        jedis.lrange(DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + globalTransactionDO.getXid(), start, 100);\n+                    if (null != redisBranchJson) {\n+                        branchJson.addAll(redisBranchJson);\n+                        start = branchJson.size();\n+                    }\n+                } while (null != redisBranchJson && redisBranchJson.size() >= 100);\n+                if (null != branchJson && branchJson.size() > 0) {\n+                    branchTransactionDOs = new ArrayList<>();\n+                    for (String s : branchJson) {\n+                        branchTransactionDOs.add(JSON.parseObject(jedis.get(s), BranchTransactionDO.class));\n+                    }\n+                }\n+            }\n+            return getGlobalSession(globalTransactionDO, branchTransactionDOs);\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid) {\n+        return this.readSession(xid, true);\n+    }\n+\n+    /**\n+     * Read session list.\n+     *\n+     * @param statuses\n+     *            the statuses\n+     * @return the list\n+     */\n+    public List<GlobalSession> readSession(GlobalStatus[] statuses) {\n+        List<Integer> states = new ArrayList<>();\n+        for (int i = 0; i < statuses.length; i++) {\n+            states.add(statuses[i].getCode());\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Set<String> keys = new HashSet<>();\n+            String cursor = \"0\";\n+            ScanParams params = new ScanParams();\n+            params.count(100);\n+            params.match(DEFAULT_REDIS_SEATA_GLOBAL_PREFIX + \"*\");\n+            ScanResult<String> scans;\n+            do {\n+                scans = jedis.scan(cursor, params);\n+                keys.addAll(scans.getResult().stream().collect(Collectors.toSet()));\n+                cursor = scans.getCursor();\n+            } while (!cursor.equalsIgnoreCase(\"0\"));\n+            if (null != keys && keys.size() > 0) {\n+                List<GlobalTransactionDO> globalTransactionDOs = new ArrayList<>();\n+                for (String globalKey : keys) {\n+                    GlobalTransactionDO globalTransactionDO =\n+                        JSON.parseObject(jedis.get(globalKey), GlobalTransactionDO.class);\n+                    if (null != globalTransactionDO && states.contains(globalTransactionDO.getStatus())) {\n+                        globalTransactionDOs.add(globalTransactionDO);\n+                    }\n+                }\n+                if (globalTransactionDOs.size() > 0) {\n+                    List<String> xids =\n+                        globalTransactionDOs.stream().map(GlobalTransactionDO::getXid).collect(Collectors.toList());\n+                    List<BranchTransactionDO> branchTransactionDOs = new ArrayList<>();\n+                    for (String xid : xids) {\n+                        Set<String> branchs = new HashSet<>();\n+                        int start = 0;\n+                        List<String> redisBranchs = null;\n+                        do {\n+                            redisBranchs = jedis.lrange(DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + xid, start, 100);\n+                            if (null != redisBranchs) {\n+                                branchs.addAll(redisBranchs);\n+                                start = branchs.size();\n+                            }\n+                        } while (null != redisBranchs && redisBranchs.size() >= 100);\n+                        if (null != branchs && branchs.size() > 0) {\n+                            for (String branchKey : branchs) {\n+                                String branchJson = jedis.get(branchKey);\n+                                if (StringUtils.isNotBlank(branchJson)) {\n+                                    branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                                }\n+                            }\n+                        }\n+                    }\n+                    Map<String, List<BranchTransactionDO>> branchTransactionDOsMap =\n+                        branchTransactionDOs.stream().collect(Collectors.groupingBy(BranchTransactionDO::getXid,\n+                            LinkedHashMap::new, Collectors.toList()));\n+                    return globalTransactionDOs.stream()\n+                        .map(globalTransactionDO -> getGlobalSession(globalTransactionDO,\n+                            branchTransactionDOsMap.get(globalTransactionDO.getXid())))\n+                        .collect(Collectors.toList());\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public List<GlobalSession> readSession(SessionCondition sessionCondition) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            if (StringUtils.isNotBlank(sessionCondition.getXid())) {\n+                globalSessionJson = jedis.get(DEFAULT_REDIS_SEATA_GLOBAL_PREFIX + sessionCondition.getXid());\n+                if (StringUtils.isNotBlank(globalSessionJson)) {\n+                    GlobalSession session =\n+                        convertGlobalSession(JSON.parseObject(globalSessionJson, GlobalTransactionDO.class));\n+                    List<GlobalSession> globalSessions = new ArrayList<>();\n+                    globalSessions.add(session);\n+                    return globalSessions;\n+                }\n+            } else if (sessionCondition.getTransactionId() != null) {\n+                String global =\n+                    jedis.get(DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX + sessionCondition.getTransactionId());\n+                if (StringUtils.isBlank(global)) {\n+                    return null;\n+                }\n+                GlobalTransactionDO globalTransactionDO = JSON.parseObject(global, GlobalTransactionDO.class);\n+                String branchsKey = DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + globalTransactionDO.getXid();\n+                int start = 0;\n+                Set<String> branchJson = new HashSet<>();\n+                List<String> redisBranchJson = null;\n+                do {\n+                    redisBranchJson = jedis.lrange(branchsKey, start, 100);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34bb3e1a86383a254ee4b33148f8b842518214e6"}, "originalPosition": 325}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ca2b7108ef7d688e386b8e3c808d5eff19180024", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/ca2b7108ef7d688e386b8e3c808d5eff19180024", "committedDate": "2020-05-13T08:09:36Z", "message": "bug fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1c4737498cd04bf1d73a2bdff0581cec774e4852", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/1c4737498cd04bf1d73a2bdff0581cec774e4852", "committedDate": "2020-05-13T08:21:12Z", "message": "Merge branch 'develop' into store_mode_redis"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0MTUyMzk4", "url": "https://github.com/seata/seata/pull/2484#pullrequestreview-414152398", "createdAt": "2020-05-19T06:59:06Z", "commit": {"oid": "1c4737498cd04bf1d73a2bdff0581cec774e4852"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwNjo1OTowNlrOGXSYxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwNzowNTowM1rOGXSjVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA3MTY4Ng==", "bodyText": "100 define constant?", "url": "https://github.com/seata/seata/pull/2484#discussion_r427071686", "createdAt": "2020-05-19T06:59:06Z", "author": {"login": "jsbxyyx"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.lock;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.core.lock.AbstractLocker;\n+import io.seata.core.lock.RowLock;\n+import io.seata.core.store.LockDO;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import redis.clients.jedis.Jedis;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisLocker extends AbstractLocker {\n+\n+    private static final Integer DEFAULT_SECONDS = 30;\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_PREFIX = \"SEATA_LOCK_\";\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX = \"SEATA_LOCK_XID_\";\n+\n+    /**\n+     * Instantiates a new Redis locker.\n+     *\n+     */\n+    public RedisLocker() {}\n+\n+    @Override\n+    public boolean acquireLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        List<String> successList = new ArrayList<>();\n+        long status = 0;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<LockDO> locks = convertToLockDO(rowLocks);\n+            for (LockDO lock : locks) {\n+                String key = DEFAULT_REDIS_SEATA_LOCK_PREFIX + lock.getRowKey();\n+                status = jedis.setnx(key, JSON.toJSONString(lock));\n+                if (status == 1) {\n+                    successList.add(key);\n+                    jedis.lpush(DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX + lock.getXid(), key);\n+                    jedis.expire(key, DEFAULT_SECONDS);\n+                } else {\n+                    break;\n+                }\n+            }\n+            if (status != 1) {\n+                String[] rms = successList.toArray(new String[successList.size()]);\n+                if (rms.length > 0) {\n+                    jedis.del(rms);\n+                }\n+                return false;\n+            } else {\n+                return true;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        String[] keys = new String[rowLocks.size()];\n+        List<LockDO> locks = convertToLockDO(rowLocks);\n+        for (int i = 0; i < locks.size(); i++) {\n+            String key = DEFAULT_REDIS_SEATA_LOCK_PREFIX + locks.get(i).getRowKey();\n+            keys[i] = key;\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            jedis.del(keys);\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(String xid, List<Long> branchIds) {\n+        if (CollectionUtils.isEmpty(branchIds)) {\n+            // no lock\n+            return true;\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String lockListKey = DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX + xid;\n+            Set<String> keys = new HashSet<>();\n+            List<String> redisLockJson = null;\n+            int start = 0;\n+            int stop = 100;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c4737498cd04bf1d73a2bdff0581cec774e4852"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA3MjAxMQ==", "bodyText": "above.", "url": "https://github.com/seata/seata/pull/2484#discussion_r427072011", "createdAt": "2020-05-19T06:59:47Z", "author": {"login": "jsbxyyx"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.lock;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.core.lock.AbstractLocker;\n+import io.seata.core.lock.RowLock;\n+import io.seata.core.store.LockDO;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import redis.clients.jedis.Jedis;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisLocker extends AbstractLocker {\n+\n+    private static final Integer DEFAULT_SECONDS = 30;\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_PREFIX = \"SEATA_LOCK_\";\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX = \"SEATA_LOCK_XID_\";\n+\n+    /**\n+     * Instantiates a new Redis locker.\n+     *\n+     */\n+    public RedisLocker() {}\n+\n+    @Override\n+    public boolean acquireLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        List<String> successList = new ArrayList<>();\n+        long status = 0;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<LockDO> locks = convertToLockDO(rowLocks);\n+            for (LockDO lock : locks) {\n+                String key = DEFAULT_REDIS_SEATA_LOCK_PREFIX + lock.getRowKey();\n+                status = jedis.setnx(key, JSON.toJSONString(lock));\n+                if (status == 1) {\n+                    successList.add(key);\n+                    jedis.lpush(DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX + lock.getXid(), key);\n+                    jedis.expire(key, DEFAULT_SECONDS);\n+                } else {\n+                    break;\n+                }\n+            }\n+            if (status != 1) {\n+                String[] rms = successList.toArray(new String[successList.size()]);\n+                if (rms.length > 0) {\n+                    jedis.del(rms);\n+                }\n+                return false;\n+            } else {\n+                return true;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        String[] keys = new String[rowLocks.size()];\n+        List<LockDO> locks = convertToLockDO(rowLocks);\n+        for (int i = 0; i < locks.size(); i++) {\n+            String key = DEFAULT_REDIS_SEATA_LOCK_PREFIX + locks.get(i).getRowKey();\n+            keys[i] = key;\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            jedis.del(keys);\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(String xid, List<Long> branchIds) {\n+        if (CollectionUtils.isEmpty(branchIds)) {\n+            // no lock\n+            return true;\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String lockListKey = DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX + xid;\n+            Set<String> keys = new HashSet<>();\n+            List<String> redisLockJson = null;\n+            int start = 0;\n+            int stop = 100;\n+            for (;;) {\n+                redisLockJson = jedis.lrange(lockListKey, start, stop);\n+                if (null != redisLockJson) {\n+                    keys.addAll(redisLockJson);\n+                    start = keys.size();\n+                    stop = start + 100;\n+                } else {\n+                    break;\n+                }\n+            }\n+            if (null != keys && keys.size() > 0) {\n+                Iterator<String> it = keys.iterator();\n+                while (it.hasNext()) {\n+                    String key = it.next();\n+                    LockDO lock = JSON.parseObject(jedis.get(key), LockDO.class);\n+                    for (int i = 0; i < branchIds.size(); i++) {\n+                        if (null != lock && Objects.equals(lock.getBranchId(), branchIds.get(i))) {\n+                            jedis.del(key);\n+                            jedis.lrem(lockListKey, 0, key);\n+                            it.remove();\n+                        }\n+                    }\n+                }\n+                if (keys.size() == 0) {\n+                    jedis.del(lockListKey);\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(String xid, Long branchId) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String lockListKey = DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX + xid;\n+            Set<String> keys = new HashSet<>();\n+            List<String> redisLockJson = null;\n+            int start = 0;\n+            int stop = 100;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c4737498cd04bf1d73a2bdff0581cec774e4852"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA3MjU3Ng==", "bodyText": "above.", "url": "https://github.com/seata/seata/pull/2484#discussion_r427072576", "createdAt": "2020-05-19T07:00:59Z", "author": {"login": "jsbxyyx"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,443 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO convertBranchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String branchsKey = DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + convertBranchTransactionDO.getXid();\n+            Set<String> branchs = new HashSet<>();\n+            List<String> redisBranchJson = null;\n+            int start = 0;\n+            int stop = 100;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c4737498cd04bf1d73a2bdff0581cec774e4852"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA3MzA0Mw==", "bodyText": "extract common get key method?", "url": "https://github.com/seata/seata/pull/2484#discussion_r427073043", "createdAt": "2020-05-19T07:02:00Z", "author": {"login": "jsbxyyx"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,443 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO convertBranchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String branchsKey = DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + convertBranchTransactionDO.getXid();\n+            Set<String> branchs = new HashSet<>();\n+            List<String> redisBranchJson = null;\n+            int start = 0;\n+            int stop = 100;\n+            for (;;) {\n+                redisBranchJson = jedis.lrange(branchsKey, start, stop);\n+                if (null != redisBranchJson) {\n+                    branchs.addAll(redisBranchJson);\n+                    start = branchs.size();\n+                    stop = start + 100;\n+                } else {\n+                    break;\n+                }\n+            }\n+            if (null != branchs && branchs.size() > 0) {\n+                String key = DEFAULT_REDIS_SEATA_BRANCH_PREFIX + convertBranchTransactionDO.getBranchId();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c4737498cd04bf1d73a2bdff0581cec774e4852"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA3MzIyMA==", "bodyText": "extract common get key method?", "url": "https://github.com/seata/seata/pull/2484#discussion_r427073220", "createdAt": "2020-05-19T07:02:22Z", "author": {"login": "jsbxyyx"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,443 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO convertBranchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String branchsKey = DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + convertBranchTransactionDO.getXid();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c4737498cd04bf1d73a2bdff0581cec774e4852"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA3Mzc0Mw==", "bodyText": "extract define constant?", "url": "https://github.com/seata/seata/pull/2484#discussion_r427073743", "createdAt": "2020-05-19T07:03:33Z", "author": {"login": "jsbxyyx"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,443 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO convertBranchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String branchsKey = DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + convertBranchTransactionDO.getXid();\n+            Set<String> branchs = new HashSet<>();\n+            List<String> redisBranchJson = null;\n+            int start = 0;\n+            int stop = 100;\n+            for (;;) {\n+                redisBranchJson = jedis.lrange(branchsKey, start, stop);\n+                if (null != redisBranchJson) {\n+                    branchs.addAll(redisBranchJson);\n+                    start = branchs.size();\n+                    stop = start + 100;\n+                } else {\n+                    break;\n+                }\n+            }\n+            if (null != branchs && branchs.size() > 0) {\n+                String key = DEFAULT_REDIS_SEATA_BRANCH_PREFIX + convertBranchTransactionDO.getBranchId();\n+                Iterator<String> it = branchs.iterator();\n+                while (it.hasNext()) {\n+                    String s = it.next();\n+                    if (Objects.equals(s, key)) {\n+                        it.remove();\n+                        jedis.del(key);\n+                        jedis.lrem(branchsKey, 0, key);\n+                        break;\n+                    }\n+                }\n+                if (branchs.size() == 0) {\n+                    jedis.del(branchsKey);\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO convertBranchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = DEFAULT_REDIS_SEATA_BRANCH_PREFIX + convertBranchTransactionDO.getBranchId();\n+            if (jedis.get(key) == null) {\n+                jedis.lpush(DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + convertBranchTransactionDO.getXid(), key);\n+            }\n+            jedis.set(key, JSON.toJSONString(convertBranchTransactionDO));\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String[] keys = new String[3];\n+            keys[0] = DEFAULT_REDIS_SEATA_GLOBAL_PREFIX + convertGlobalTransactionDO.getXid();\n+            keys[1] = DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX + convertGlobalTransactionDO.getTransactionId();\n+            String branchsKey = DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + convertGlobalTransactionDO.getXid();\n+            List<String> redisBranchs = jedis.lrange(branchsKey, 0, 1);\n+            if (null == redisBranchs || redisBranchs.size() <= 0) {\n+                keys[2] = branchsKey;\n+            }\n+            jedis.del(keys);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String keys = DEFAULT_REDIS_SEATA_GLOBAL_PREFIX + convertGlobalTransactionDO.getXid();\n+            jedis.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            keys = DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX + convertGlobalTransactionDO.getTransactionId();\n+            jedis.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @param withBranchSessions\n+     *            the withBranchSessions\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid, boolean withBranchSessions) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            globalSessionJson = jedis.get(DEFAULT_REDIS_SEATA_GLOBAL_PREFIX + xid);\n+            if (StringUtils.isBlank(globalSessionJson)) {\n+                return null;\n+            }\n+            // global transaction\n+            GlobalTransactionDO globalTransactionDO = JSON.parseObject(globalSessionJson, GlobalTransactionDO.class);\n+            if (globalTransactionDO == null) {\n+                return null;\n+            }\n+            // branch transactions\n+            List<BranchTransactionDO> branchTransactionDOs = null;\n+            // reduce rpc with db when branchRegister and getGlobalStatus\n+            if (withBranchSessions) {\n+                Set<String> branchJson = new HashSet<>();\n+                int start = 0;\n+                List<String> redisBranchJson = null;\n+                int stop = 100;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c4737498cd04bf1d73a2bdff0581cec774e4852"}, "originalPosition": 203}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA3Mzk1Mg==", "bodyText": "extract define constant?", "url": "https://github.com/seata/seata/pull/2484#discussion_r427073952", "createdAt": "2020-05-19T07:04:03Z", "author": {"login": "jsbxyyx"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,443 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO convertBranchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String branchsKey = DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + convertBranchTransactionDO.getXid();\n+            Set<String> branchs = new HashSet<>();\n+            List<String> redisBranchJson = null;\n+            int start = 0;\n+            int stop = 100;\n+            for (;;) {\n+                redisBranchJson = jedis.lrange(branchsKey, start, stop);\n+                if (null != redisBranchJson) {\n+                    branchs.addAll(redisBranchJson);\n+                    start = branchs.size();\n+                    stop = start + 100;\n+                } else {\n+                    break;\n+                }\n+            }\n+            if (null != branchs && branchs.size() > 0) {\n+                String key = DEFAULT_REDIS_SEATA_BRANCH_PREFIX + convertBranchTransactionDO.getBranchId();\n+                Iterator<String> it = branchs.iterator();\n+                while (it.hasNext()) {\n+                    String s = it.next();\n+                    if (Objects.equals(s, key)) {\n+                        it.remove();\n+                        jedis.del(key);\n+                        jedis.lrem(branchsKey, 0, key);\n+                        break;\n+                    }\n+                }\n+                if (branchs.size() == 0) {\n+                    jedis.del(branchsKey);\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO convertBranchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = DEFAULT_REDIS_SEATA_BRANCH_PREFIX + convertBranchTransactionDO.getBranchId();\n+            if (jedis.get(key) == null) {\n+                jedis.lpush(DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + convertBranchTransactionDO.getXid(), key);\n+            }\n+            jedis.set(key, JSON.toJSONString(convertBranchTransactionDO));\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String[] keys = new String[3];\n+            keys[0] = DEFAULT_REDIS_SEATA_GLOBAL_PREFIX + convertGlobalTransactionDO.getXid();\n+            keys[1] = DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX + convertGlobalTransactionDO.getTransactionId();\n+            String branchsKey = DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + convertGlobalTransactionDO.getXid();\n+            List<String> redisBranchs = jedis.lrange(branchsKey, 0, 1);\n+            if (null == redisBranchs || redisBranchs.size() <= 0) {\n+                keys[2] = branchsKey;\n+            }\n+            jedis.del(keys);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String keys = DEFAULT_REDIS_SEATA_GLOBAL_PREFIX + convertGlobalTransactionDO.getXid();\n+            jedis.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            keys = DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX + convertGlobalTransactionDO.getTransactionId();\n+            jedis.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @param withBranchSessions\n+     *            the withBranchSessions\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid, boolean withBranchSessions) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            globalSessionJson = jedis.get(DEFAULT_REDIS_SEATA_GLOBAL_PREFIX + xid);\n+            if (StringUtils.isBlank(globalSessionJson)) {\n+                return null;\n+            }\n+            // global transaction\n+            GlobalTransactionDO globalTransactionDO = JSON.parseObject(globalSessionJson, GlobalTransactionDO.class);\n+            if (globalTransactionDO == null) {\n+                return null;\n+            }\n+            // branch transactions\n+            List<BranchTransactionDO> branchTransactionDOs = null;\n+            // reduce rpc with db when branchRegister and getGlobalStatus\n+            if (withBranchSessions) {\n+                Set<String> branchJson = new HashSet<>();\n+                int start = 0;\n+                List<String> redisBranchJson = null;\n+                int stop = 100;\n+                for (;;) {\n+                    redisBranchJson = jedis.lrange(DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + globalTransactionDO.getXid(), start, stop);\n+                    if (null != redisBranchJson) {\n+                        branchJson.addAll(redisBranchJson);\n+                        start = branchJson.size();\n+                        stop = start + 100;\n+                    } else {\n+                        break;\n+                    }\n+                }\n+                if (null != branchJson && branchJson.size() > 0) {\n+                    branchTransactionDOs = new ArrayList<>();\n+                    for (String s : branchJson) {\n+                        branchTransactionDOs.add(JSON.parseObject(jedis.get(s), BranchTransactionDO.class));\n+                    }\n+                }\n+            }\n+            return getGlobalSession(globalTransactionDO, branchTransactionDOs);\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid) {\n+        return this.readSession(xid, true);\n+    }\n+\n+    /**\n+     * Read session list.\n+     *\n+     * @param statuses\n+     *            the statuses\n+     * @return the list\n+     */\n+    public List<GlobalSession> readSession(GlobalStatus[] statuses) {\n+        List<Integer> states = new ArrayList<>();\n+        for (int i = 0; i < statuses.length; i++) {\n+            states.add(statuses[i].getCode());\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Set<String> keys = new HashSet<>();\n+            String cursor = \"0\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c4737498cd04bf1d73a2bdff0581cec774e4852"}, "originalPosition": 251}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA3NDA3OA==", "bodyText": "extract define constant?", "url": "https://github.com/seata/seata/pull/2484#discussion_r427074078", "createdAt": "2020-05-19T07:04:19Z", "author": {"login": "jsbxyyx"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,443 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO convertBranchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String branchsKey = DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + convertBranchTransactionDO.getXid();\n+            Set<String> branchs = new HashSet<>();\n+            List<String> redisBranchJson = null;\n+            int start = 0;\n+            int stop = 100;\n+            for (;;) {\n+                redisBranchJson = jedis.lrange(branchsKey, start, stop);\n+                if (null != redisBranchJson) {\n+                    branchs.addAll(redisBranchJson);\n+                    start = branchs.size();\n+                    stop = start + 100;\n+                } else {\n+                    break;\n+                }\n+            }\n+            if (null != branchs && branchs.size() > 0) {\n+                String key = DEFAULT_REDIS_SEATA_BRANCH_PREFIX + convertBranchTransactionDO.getBranchId();\n+                Iterator<String> it = branchs.iterator();\n+                while (it.hasNext()) {\n+                    String s = it.next();\n+                    if (Objects.equals(s, key)) {\n+                        it.remove();\n+                        jedis.del(key);\n+                        jedis.lrem(branchsKey, 0, key);\n+                        break;\n+                    }\n+                }\n+                if (branchs.size() == 0) {\n+                    jedis.del(branchsKey);\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO convertBranchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = DEFAULT_REDIS_SEATA_BRANCH_PREFIX + convertBranchTransactionDO.getBranchId();\n+            if (jedis.get(key) == null) {\n+                jedis.lpush(DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + convertBranchTransactionDO.getXid(), key);\n+            }\n+            jedis.set(key, JSON.toJSONString(convertBranchTransactionDO));\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String[] keys = new String[3];\n+            keys[0] = DEFAULT_REDIS_SEATA_GLOBAL_PREFIX + convertGlobalTransactionDO.getXid();\n+            keys[1] = DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX + convertGlobalTransactionDO.getTransactionId();\n+            String branchsKey = DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + convertGlobalTransactionDO.getXid();\n+            List<String> redisBranchs = jedis.lrange(branchsKey, 0, 1);\n+            if (null == redisBranchs || redisBranchs.size() <= 0) {\n+                keys[2] = branchsKey;\n+            }\n+            jedis.del(keys);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String keys = DEFAULT_REDIS_SEATA_GLOBAL_PREFIX + convertGlobalTransactionDO.getXid();\n+            jedis.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            keys = DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX + convertGlobalTransactionDO.getTransactionId();\n+            jedis.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @param withBranchSessions\n+     *            the withBranchSessions\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid, boolean withBranchSessions) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            globalSessionJson = jedis.get(DEFAULT_REDIS_SEATA_GLOBAL_PREFIX + xid);\n+            if (StringUtils.isBlank(globalSessionJson)) {\n+                return null;\n+            }\n+            // global transaction\n+            GlobalTransactionDO globalTransactionDO = JSON.parseObject(globalSessionJson, GlobalTransactionDO.class);\n+            if (globalTransactionDO == null) {\n+                return null;\n+            }\n+            // branch transactions\n+            List<BranchTransactionDO> branchTransactionDOs = null;\n+            // reduce rpc with db when branchRegister and getGlobalStatus\n+            if (withBranchSessions) {\n+                Set<String> branchJson = new HashSet<>();\n+                int start = 0;\n+                List<String> redisBranchJson = null;\n+                int stop = 100;\n+                for (;;) {\n+                    redisBranchJson = jedis.lrange(DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + globalTransactionDO.getXid(), start, stop);\n+                    if (null != redisBranchJson) {\n+                        branchJson.addAll(redisBranchJson);\n+                        start = branchJson.size();\n+                        stop = start + 100;\n+                    } else {\n+                        break;\n+                    }\n+                }\n+                if (null != branchJson && branchJson.size() > 0) {\n+                    branchTransactionDOs = new ArrayList<>();\n+                    for (String s : branchJson) {\n+                        branchTransactionDOs.add(JSON.parseObject(jedis.get(s), BranchTransactionDO.class));\n+                    }\n+                }\n+            }\n+            return getGlobalSession(globalTransactionDO, branchTransactionDOs);\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid) {\n+        return this.readSession(xid, true);\n+    }\n+\n+    /**\n+     * Read session list.\n+     *\n+     * @param statuses\n+     *            the statuses\n+     * @return the list\n+     */\n+    public List<GlobalSession> readSession(GlobalStatus[] statuses) {\n+        List<Integer> states = new ArrayList<>();\n+        for (int i = 0; i < statuses.length; i++) {\n+            states.add(statuses[i].getCode());\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Set<String> keys = new HashSet<>();\n+            String cursor = \"0\";\n+            ScanParams params = new ScanParams();\n+            params.count(100);\n+            params.match(DEFAULT_REDIS_SEATA_GLOBAL_PREFIX + \"*\");\n+            ScanResult<String> scans;\n+            do {\n+                scans = jedis.scan(cursor, params);\n+                keys.addAll(scans.getResult().stream().collect(Collectors.toSet()));\n+                cursor = scans.getCursor();\n+            } while (!cursor.equalsIgnoreCase(\"0\"));\n+            if (null != keys && keys.size() > 0) {\n+                List<GlobalTransactionDO> globalTransactionDOs = new ArrayList<>();\n+                for (String globalKey : keys) {\n+                    GlobalTransactionDO globalTransactionDO =\n+                        JSON.parseObject(jedis.get(globalKey), GlobalTransactionDO.class);\n+                    if (null != globalTransactionDO && states.contains(globalTransactionDO.getStatus())) {\n+                        globalTransactionDOs.add(globalTransactionDO);\n+                    }\n+                }\n+                if (globalTransactionDOs.size() > 0) {\n+                    List<String> xids =\n+                        globalTransactionDOs.stream().map(GlobalTransactionDO::getXid).collect(Collectors.toList());\n+                    List<BranchTransactionDO> branchTransactionDOs = new ArrayList<>();\n+                    for (String xid : xids) {\n+                        Set<String> branchs = new HashSet<>();\n+                        int start = 0;\n+                        int stop = 100;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c4737498cd04bf1d73a2bdff0581cec774e4852"}, "originalPosition": 277}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA3NDM5MA==", "bodyText": "extract common method?", "url": "https://github.com/seata/seata/pull/2484#discussion_r427074390", "createdAt": "2020-05-19T07:05:03Z", "author": {"login": "jsbxyyx"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,443 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO convertBranchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String branchsKey = DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + convertBranchTransactionDO.getXid();\n+            Set<String> branchs = new HashSet<>();\n+            List<String> redisBranchJson = null;\n+            int start = 0;\n+            int stop = 100;\n+            for (;;) {\n+                redisBranchJson = jedis.lrange(branchsKey, start, stop);\n+                if (null != redisBranchJson) {\n+                    branchs.addAll(redisBranchJson);\n+                    start = branchs.size();\n+                    stop = start + 100;\n+                } else {\n+                    break;\n+                }\n+            }\n+            if (null != branchs && branchs.size() > 0) {\n+                String key = DEFAULT_REDIS_SEATA_BRANCH_PREFIX + convertBranchTransactionDO.getBranchId();\n+                Iterator<String> it = branchs.iterator();\n+                while (it.hasNext()) {\n+                    String s = it.next();\n+                    if (Objects.equals(s, key)) {\n+                        it.remove();\n+                        jedis.del(key);\n+                        jedis.lrem(branchsKey, 0, key);\n+                        break;\n+                    }\n+                }\n+                if (branchs.size() == 0) {\n+                    jedis.del(branchsKey);\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO convertBranchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = DEFAULT_REDIS_SEATA_BRANCH_PREFIX + convertBranchTransactionDO.getBranchId();\n+            if (jedis.get(key) == null) {\n+                jedis.lpush(DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + convertBranchTransactionDO.getXid(), key);\n+            }\n+            jedis.set(key, JSON.toJSONString(convertBranchTransactionDO));\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String[] keys = new String[3];\n+            keys[0] = DEFAULT_REDIS_SEATA_GLOBAL_PREFIX + convertGlobalTransactionDO.getXid();\n+            keys[1] = DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX + convertGlobalTransactionDO.getTransactionId();\n+            String branchsKey = DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + convertGlobalTransactionDO.getXid();\n+            List<String> redisBranchs = jedis.lrange(branchsKey, 0, 1);\n+            if (null == redisBranchs || redisBranchs.size() <= 0) {\n+                keys[2] = branchsKey;\n+            }\n+            jedis.del(keys);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String keys = DEFAULT_REDIS_SEATA_GLOBAL_PREFIX + convertGlobalTransactionDO.getXid();\n+            jedis.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            keys = DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX + convertGlobalTransactionDO.getTransactionId();\n+            jedis.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @param withBranchSessions\n+     *            the withBranchSessions\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid, boolean withBranchSessions) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            globalSessionJson = jedis.get(DEFAULT_REDIS_SEATA_GLOBAL_PREFIX + xid);\n+            if (StringUtils.isBlank(globalSessionJson)) {\n+                return null;\n+            }\n+            // global transaction\n+            GlobalTransactionDO globalTransactionDO = JSON.parseObject(globalSessionJson, GlobalTransactionDO.class);\n+            if (globalTransactionDO == null) {\n+                return null;\n+            }\n+            // branch transactions\n+            List<BranchTransactionDO> branchTransactionDOs = null;\n+            // reduce rpc with db when branchRegister and getGlobalStatus\n+            if (withBranchSessions) {\n+                Set<String> branchJson = new HashSet<>();\n+                int start = 0;\n+                List<String> redisBranchJson = null;\n+                int stop = 100;\n+                for (;;) {\n+                    redisBranchJson = jedis.lrange(DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + globalTransactionDO.getXid(), start, stop);\n+                    if (null != redisBranchJson) {\n+                        branchJson.addAll(redisBranchJson);\n+                        start = branchJson.size();\n+                        stop = start + 100;\n+                    } else {\n+                        break;\n+                    }\n+                }\n+                if (null != branchJson && branchJson.size() > 0) {\n+                    branchTransactionDOs = new ArrayList<>();\n+                    for (String s : branchJson) {\n+                        branchTransactionDOs.add(JSON.parseObject(jedis.get(s), BranchTransactionDO.class));\n+                    }\n+                }\n+            }\n+            return getGlobalSession(globalTransactionDO, branchTransactionDOs);\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid) {\n+        return this.readSession(xid, true);\n+    }\n+\n+    /**\n+     * Read session list.\n+     *\n+     * @param statuses\n+     *            the statuses\n+     * @return the list\n+     */\n+    public List<GlobalSession> readSession(GlobalStatus[] statuses) {\n+        List<Integer> states = new ArrayList<>();\n+        for (int i = 0; i < statuses.length; i++) {\n+            states.add(statuses[i].getCode());\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Set<String> keys = new HashSet<>();\n+            String cursor = \"0\";\n+            ScanParams params = new ScanParams();\n+            params.count(100);\n+            params.match(DEFAULT_REDIS_SEATA_GLOBAL_PREFIX + \"*\");\n+            ScanResult<String> scans;\n+            do {\n+                scans = jedis.scan(cursor, params);\n+                keys.addAll(scans.getResult().stream().collect(Collectors.toSet()));\n+                cursor = scans.getCursor();\n+            } while (!cursor.equalsIgnoreCase(\"0\"));\n+            if (null != keys && keys.size() > 0) {\n+                List<GlobalTransactionDO> globalTransactionDOs = new ArrayList<>();\n+                for (String globalKey : keys) {\n+                    GlobalTransactionDO globalTransactionDO =\n+                        JSON.parseObject(jedis.get(globalKey), GlobalTransactionDO.class);\n+                    if (null != globalTransactionDO && states.contains(globalTransactionDO.getStatus())) {\n+                        globalTransactionDOs.add(globalTransactionDO);\n+                    }\n+                }\n+                if (globalTransactionDOs.size() > 0) {\n+                    List<String> xids =\n+                        globalTransactionDOs.stream().map(GlobalTransactionDO::getXid).collect(Collectors.toList());\n+                    List<BranchTransactionDO> branchTransactionDOs = new ArrayList<>();\n+                    for (String xid : xids) {\n+                        Set<String> branchs = new HashSet<>();\n+                        int start = 0;\n+                        int stop = 100;\n+                        List<String> redisBranchs = null;\n+                        for (;;) {\n+                            redisBranchs = jedis.lrange(DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + xid, start, stop);\n+                            if (null != redisBranchs) {\n+                                branchs.addAll(redisBranchs);\n+                                start = branchs.size();\n+                                stop = start + 100;\n+                            } else {\n+                                break;\n+                            }\n+                        }\n+                        if (null != branchs && branchs.size() > 0) {\n+                            for (String branchKey : branchs) {\n+                                String branchJson = jedis.get(branchKey);\n+                                if (StringUtils.isNotBlank(branchJson)) {\n+                                    branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                                }\n+                            }\n+                        }\n+                    }\n+                    Map<String, List<BranchTransactionDO>> branchTransactionDOsMap =\n+                        branchTransactionDOs.stream().collect(Collectors.groupingBy(BranchTransactionDO::getXid,\n+                            LinkedHashMap::new, Collectors.toList()));\n+                    return globalTransactionDOs.stream()\n+                        .map(globalTransactionDO -> getGlobalSession(globalTransactionDO,\n+                            branchTransactionDOsMap.get(globalTransactionDO.getXid())))\n+                        .collect(Collectors.toList());\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public List<GlobalSession> readSession(SessionCondition sessionCondition) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            if (StringUtils.isNotBlank(sessionCondition.getXid())) {\n+                globalSessionJson = jedis.get(DEFAULT_REDIS_SEATA_GLOBAL_PREFIX + sessionCondition.getXid());\n+                if (StringUtils.isNotBlank(globalSessionJson)) {\n+                    GlobalSession session =\n+                        convertGlobalSession(JSON.parseObject(globalSessionJson, GlobalTransactionDO.class));\n+                    List<GlobalSession> globalSessions = new ArrayList<>();\n+                    globalSessions.add(session);\n+                    return globalSessions;\n+                }\n+            } else if (sessionCondition.getTransactionId() != null) {\n+                String global =\n+                    jedis.get(DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX + sessionCondition.getTransactionId());\n+                if (StringUtils.isBlank(global)) {\n+                    return null;\n+                }\n+                GlobalTransactionDO globalTransactionDO = JSON.parseObject(global, GlobalTransactionDO.class);\n+                String branchsKey = DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + globalTransactionDO.getXid();\n+                Set<String> branchJson = new HashSet<>();\n+                List<String> redisBranchJson = null;\n+                int start = 0;\n+                int stop = 100;\n+                for (;;) {\n+                    redisBranchJson = jedis.lrange(branchsKey, start, stop);\n+                    if (null != redisBranchJson) {\n+                        branchJson.addAll(redisBranchJson);\n+                        start = branchJson.size();\n+                        stop = start + 100;\n+                    } else {\n+                        break;\n+                    }\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c4737498cd04bf1d73a2bdff0581cec774e4852"}, "originalPosition": 345}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5d9984f5f496ff027d0fd9c47eacd4301e65a366", "author": {"user": null}, "url": "https://github.com/seata/seata/commit/5d9984f5f496ff027d0fd9c47eacd4301e65a366", "committedDate": "2020-05-19T07:06:29Z", "message": "Merge branch 'develop' into store_mode_redis"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3bfee07c08d436dba621627255d67f80a2a0f120", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/3bfee07c08d436dba621627255d67f80a2a0f120", "committedDate": "2020-05-19T08:44:23Z", "message": "optimize code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "260af8e665010e371e9420148f02e49133821738", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/260af8e665010e371e9420148f02e49133821738", "committedDate": "2020-05-19T09:55:30Z", "message": "optimize code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e07074f694e0ead1227fcbf210a508b9622fb45b", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/e07074f694e0ead1227fcbf210a508b9622fb45b", "committedDate": "2020-05-19T10:00:16Z", "message": "optimize code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a48cadd9b279e972e7d066f40b4fb09f7cde6d73", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/a48cadd9b279e972e7d066f40b4fb09f7cde6d73", "committedDate": "2020-05-19T13:59:14Z", "message": "optimized code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ec4e72c31ca798c846edfbdf262ff7fb2b70563a", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/ec4e72c31ca798c846edfbdf262ff7fb2b70563a", "committedDate": "2020-05-19T14:48:30Z", "message": "optimized code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "233e6f5238ec40b612df955cba1fc0ae6978ec0b", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/233e6f5238ec40b612df955cba1fc0ae6978ec0b", "committedDate": "2020-05-19T15:11:06Z", "message": "bug fix"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0MjQ0NDAy", "url": "https://github.com/seata/seata/pull/2484#pullrequestreview-414244402", "createdAt": "2020-05-19T09:01:19Z", "commit": {"oid": "3bfee07c08d436dba621627255d67f80a2a0f120"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwOTowMToxOVrOGXWzAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwMToyNDo0N1rOGX4G1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE0MzkzNg==", "bodyText": "do {} while(); ?", "url": "https://github.com/seata/seata/pull/2484#discussion_r427143936", "createdAt": "2020-05-19T09:01:19Z", "author": {"login": "jsbxyyx"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -227,4 +199,30 @@ public boolean isLockable(List<RowLock> rowLocks) {\n         return lockDOs;\n     }\n \n+    private Set<String> lRange(Jedis jedis, String Key) {\n+        Set<String> keys = new HashSet<>();\n+        List<String> redisLockJson = null;\n+        int start = 0;\n+        int stop = 100;\n+        for (;;) {\n+            redisLockJson = jedis.lrange(Key, start, stop);\n+            if (null != redisLockJson) {\n+                keys.addAll(redisLockJson);\n+                start = keys.size();\n+                stop = start + 100;\n+            } else {\n+                break;\n+            }\n+        }\n+        return keys;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3bfee07c08d436dba621627255d67f80a2a0f120"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY4NjgxMg==", "bodyText": "do {} while(!CollectionUtils.isEmpty(redisLockJson))?", "url": "https://github.com/seata/seata/pull/2484#discussion_r427686812", "createdAt": "2020-05-20T01:13:29Z", "author": {"login": "jsbxyyx"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.lock;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.lock.AbstractLocker;\n+import io.seata.core.lock.RowLock;\n+import io.seata.core.store.LockDO;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import redis.clients.jedis.Jedis;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisLocker extends AbstractLocker {\n+\n+    private static final Integer DEFAULT_SECONDS = 30;\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_PREFIX = \"SEATA_LOCK_\";\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX = \"SEATA_LOCK_XID_\";\n+\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    /**\n+     * Instantiates a new Redis locker.\n+     *\n+     */\n+    public RedisLocker() {\n+        logQueryLimit = ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, 100);\n+    }\n+\n+    @Override\n+    public boolean acquireLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        List<String> successList = new ArrayList<>();\n+        long status = 0;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<LockDO> locks = convertToLockDO(rowLocks);\n+            for (LockDO lock : locks) {\n+                String key = getLockKey(lock.getRowKey());\n+                status = jedis.setnx(key, JSON.toJSONString(lock));\n+                if (status == 1) {\n+                    successList.add(key);\n+                    jedis.lpush(getXidLockKey(lock.getXid()), key);\n+                    jedis.expire(key, DEFAULT_SECONDS);\n+                } else {\n+                    break;\n+                }\n+            }\n+            if (status != 1) {\n+                String[] rms = successList.toArray(new String[successList.size()]);\n+                if (rms.length > 0) {\n+                    jedis.del(rms);\n+                }\n+                return false;\n+            } else {\n+                return true;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        String[] keys = new String[rowLocks.size()];\n+        List<LockDO> locks = convertToLockDO(rowLocks);\n+        for (int i = 0; i < locks.size(); i++) {\n+            String key = getLockKey(locks.get(i).getRowKey());\n+            keys[i] = key;\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            jedis.del(keys);\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(String xid, List<Long> branchIds) {\n+        if (CollectionUtils.isEmpty(branchIds)) {\n+            // no lock\n+            return true;\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String lockListKey = getXidLockKey(xid);\n+            Set<String> keys = lRange(jedis, lockListKey);\n+            if (null != keys && keys.size() > 0) {\n+                Iterator<String> it = keys.iterator();\n+                while (it.hasNext()) {\n+                    String key = it.next();\n+                    LockDO lock = JSON.parseObject(jedis.get(key), LockDO.class);\n+                    for (int i = 0; i < branchIds.size(); i++) {\n+                        if (null != lock && Objects.equals(lock.getBranchId(), branchIds.get(i))) {\n+                            jedis.del(key);\n+                            jedis.lrem(lockListKey, 0, key);\n+                            it.remove();\n+                        }\n+                    }\n+                }\n+                if (keys.size() == 0) {\n+                    jedis.del(lockListKey);\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(String xid, Long branchId) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String lockListKey = getXidLockKey(xid);\n+            Set<String> keys = lRange(jedis, lockListKey);\n+            if (null != keys && keys.size() > 0) {\n+                Iterator<String> it = keys.iterator();\n+                while (it.hasNext()) {\n+                    String key = it.next();\n+                    LockDO lock = JSON.parseObject(jedis.get(key), LockDO.class);\n+                    if (null != lock && Objects.equals(branchId, lock.getBranchId())) {\n+                        jedis.del(key);\n+                        jedis.lrem(lockListKey, 0, key);\n+                        it.remove();\n+                    }\n+                }\n+                if (keys.size() == 0) {\n+                    jedis.del(lockListKey);\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public boolean isLockable(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<LockDO> locks = convertToLockDO(rowLocks);\n+            for (LockDO rowlock : locks) {\n+                String rowlockJson = jedis.get(getLockKey(rowlock.getRowKey()));\n+                if (StringUtils.isNotBlank(rowlockJson)) {\n+                    LockDO lock = JSON.parseObject(rowlockJson, LockDO.class);\n+                    if (null != lock && !Objects.equals(lock.getXid(), rowlock.getXid())) {\n+                        return false;\n+                    }\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Convert to lock do list.\n+     *\n+     * @param locks\n+     *            the locks\n+     * @return the list\n+     */\n+    protected List<LockDO> convertToLockDO(List<RowLock> locks) {\n+        List<LockDO> lockDOs = new ArrayList<>();\n+        if (CollectionUtils.isEmpty(locks)) {\n+            return lockDOs;\n+        }\n+        for (RowLock rowLock : locks) {\n+            LockDO lockDO = new LockDO();\n+            lockDO.setBranchId(rowLock.getBranchId());\n+            lockDO.setPk(rowLock.getPk());\n+            lockDO.setResourceId(rowLock.getResourceId());\n+            lockDO.setRowKey(getRowKey(rowLock.getResourceId(), rowLock.getTableName(), rowLock.getPk()));\n+            lockDO.setXid(rowLock.getXid());\n+            lockDO.setTransactionId(rowLock.getTransactionId());\n+            lockDO.setTableName(rowLock.getTableName());\n+            lockDOs.add(lockDO);\n+        }\n+        return lockDOs;\n+    }\n+\n+    private Set<String> lRange(Jedis jedis, String key) {\n+        Set<String> keys = new HashSet<>();\n+        List<String> redisLockJson;\n+        int start = 0;\n+        int stop = logQueryLimit;\n+        for (;;) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "233e6f5238ec40b612df955cba1fc0ae6978ec0b"}, "originalPosition": 218}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY4NzE2Mg==", "bodyText": "do {} while(!CollectionUtils.isEmpty(redisBranchJson)) ?", "url": "https://github.com/seata/seata/pull/2484#discussion_r427687162", "createdAt": "2020-05-20T01:14:58Z", "author": {"login": "jsbxyyx"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,436 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    private static final String INITIAL_CURSOR = \"0\";\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    public RedisTransactionStoreManager() {\n+        logQueryLimit = ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, 100);\n+    }\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO convertBranchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String branchesKey = getBranchListKeyByXid(convertBranchTransactionDO.getXid());\n+            Set<String> keys = lRange(jedis, branchesKey);\n+            if (null != keys && keys.size() > 0) {\n+                String key = getBranchKey(convertBranchTransactionDO.getBranchId());\n+                Iterator<String> it = keys.iterator();\n+                while (it.hasNext()) {\n+                    String s = it.next();\n+                    if (Objects.equals(s, key)) {\n+                        it.remove();\n+                        jedis.del(key);\n+                        jedis.lrem(branchesKey, 0, key);\n+                        break;\n+                    }\n+                }\n+                if (keys.size() == 0) {\n+                    jedis.del(branchesKey);\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO convertBranchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(convertBranchTransactionDO.getBranchId());\n+            if (jedis.get(key) == null) {\n+                jedis.lpush(getBranchListKeyByXid(convertBranchTransactionDO.getXid()), key);\n+            }\n+            jedis.set(key, JSON.toJSONString(convertBranchTransactionDO));\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String[] keys = new String[3];\n+            keys[0] = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n+            keys[1] = getGlobalKeyByTransactionId(convertGlobalTransactionDO.getTransactionId());\n+            String branchesKey = getBranchListKeyByXid(convertGlobalTransactionDO.getXid());\n+            List<String> redisBranches = jedis.lrange(branchesKey, 0, 1);\n+            if (null == redisBranches || redisBranches.size() <= 0) {\n+                keys[2] = branchesKey;\n+            }\n+            jedis.del(keys);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String keys = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n+            jedis.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            keys = getGlobalKeyByTransactionId(convertGlobalTransactionDO.getTransactionId());\n+            jedis.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @param withBranchSessions\n+     *            the withBranchSessions\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid, boolean withBranchSessions) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            globalSessionJson = jedis.get(getGlobalKeyByXid(xid));\n+            if (StringUtils.isBlank(globalSessionJson)) {\n+                return null;\n+            }\n+            // global transaction\n+            GlobalTransactionDO globalTransactionDO = JSON.parseObject(globalSessionJson, GlobalTransactionDO.class);\n+            if (globalTransactionDO == null) {\n+                return null;\n+            }\n+            // branch transactions\n+            List<BranchTransactionDO> branchTransactionDOs = null;\n+            // reduce rpc with db when branchRegister and getGlobalStatus\n+            if (withBranchSessions) {\n+                Set<String> keys = lRange(jedis, getBranchListKeyByXid(globalTransactionDO.getXid()));\n+                if (null != keys && keys.size() > 0) {\n+                    branchTransactionDOs = new ArrayList<>();\n+                    for (String s : keys) {\n+                        branchTransactionDOs.add(JSON.parseObject(jedis.get(s), BranchTransactionDO.class));\n+                    }\n+                }\n+            }\n+            return getGlobalSession(globalTransactionDO, branchTransactionDOs);\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid) {\n+        return this.readSession(xid, true);\n+    }\n+\n+    /**\n+     * Read session list.\n+     *\n+     * @param statuses\n+     *            the statuses\n+     * @return the list\n+     */\n+    public List<GlobalSession> readSession(GlobalStatus[] statuses) {\n+        List<Integer> states = new ArrayList<>();\n+        for (int i = 0; i < statuses.length; i++) {\n+            states.add(statuses[i].getCode());\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Set<String> keys = new HashSet<>();\n+            String cursor = INITIAL_CURSOR;\n+            ScanParams params = new ScanParams();\n+            params.count(logQueryLimit);\n+            params.match(getGlobalKeyByXid(\"*\"));\n+            ScanResult<String> scans;\n+            do {\n+                scans = jedis.scan(cursor, params);\n+                keys.addAll(scans.getResult().stream().collect(Collectors.toSet()));\n+                cursor = scans.getCursor();\n+            } while (!cursor.equalsIgnoreCase(INITIAL_CURSOR));\n+            if (null != keys && keys.size() > 0) {\n+                List<GlobalTransactionDO> globalTransactionDOs = new ArrayList<>();\n+                for (String globalKey : keys) {\n+                    GlobalTransactionDO globalTransactionDO =\n+                        JSON.parseObject(jedis.get(globalKey), GlobalTransactionDO.class);\n+                    if (null != globalTransactionDO && states.contains(globalTransactionDO.getStatus())) {\n+                        globalTransactionDOs.add(globalTransactionDO);\n+                    }\n+                }\n+                if (globalTransactionDOs.size() > 0) {\n+                    List<String> xids =\n+                        globalTransactionDOs.stream().map(GlobalTransactionDO::getXid).collect(Collectors.toList());\n+                    List<BranchTransactionDO> branchTransactionDOs = new ArrayList<>();\n+                    for (String xid : xids) {\n+                        Set<String> branches = lRange(jedis, getBranchListKeyByXid(xid));\n+                        if (null != branches && branches.size() > 0) {\n+                            for (String branchKey : branches) {\n+                                String branchJson = jedis.get(branchKey);\n+                                if (StringUtils.isNotBlank(branchJson)) {\n+                                    branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                                }\n+                            }\n+                        }\n+                    }\n+                    Map<String, List<BranchTransactionDO>> branchTransactionDOsMap =\n+                        branchTransactionDOs.stream().collect(Collectors.groupingBy(BranchTransactionDO::getXid,\n+                            LinkedHashMap::new, Collectors.toList()));\n+                    return globalTransactionDOs.stream()\n+                        .map(globalTransactionDO -> getGlobalSession(globalTransactionDO,\n+                            branchTransactionDOsMap.get(globalTransactionDO.getXid())))\n+                        .collect(Collectors.toList());\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public List<GlobalSession> readSession(SessionCondition sessionCondition) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            if (StringUtils.isNotBlank(sessionCondition.getXid())) {\n+                globalSessionJson = jedis.get(getGlobalKeyByXid(sessionCondition.getXid()));\n+                if (StringUtils.isNotBlank(globalSessionJson)) {\n+                    GlobalSession session =\n+                        convertGlobalSession(JSON.parseObject(globalSessionJson, GlobalTransactionDO.class));\n+                    List<GlobalSession> globalSessions = new ArrayList<>();\n+                    globalSessions.add(session);\n+                    return globalSessions;\n+                }\n+            } else if (sessionCondition.getTransactionId() != null) {\n+                String global = jedis.get(getGlobalKeyByTransactionId(sessionCondition.getTransactionId()));\n+                if (StringUtils.isBlank(global)) {\n+                    return null;\n+                }\n+                GlobalTransactionDO globalTransactionDO = JSON.parseObject(global, GlobalTransactionDO.class);\n+                String branchKey = getBranchListKeyByXid(globalTransactionDO.getXid());\n+                Set<String> keys = lRange(jedis, branchKey);\n+                List<BranchTransactionDO> branchTransactionDOS = new ArrayList<>();\n+                if (null != keys && keys.size() > 0) {\n+                    for (String s : keys) {\n+                        branchTransactionDOS.add(JSON.parseObject(jedis.get(s), BranchTransactionDO.class));\n+                    }\n+                    GlobalSession globalSession = getGlobalSession(globalTransactionDO, branchTransactionDOS);\n+                    if (globalSession != null) {\n+                        List<GlobalSession> globalSessions = new ArrayList<>();\n+                        globalSessions.add(globalSession);\n+                        return globalSessions;\n+                    }\n+                }\n+            } else if (CollectionUtils.isNotEmpty(sessionCondition.getStatuses())) {\n+                return readSession(sessionCondition.getStatuses());\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private GlobalTransactionDO convertGlobalTransactionDO(SessionStorable session) {\n+        if (session == null || !(session instanceof GlobalSession)) {\n+            throw new IllegalArgumentException(\n+                \"the parameter of SessionStorable is not available, SessionStorable:\" + StringUtils.toString(session));\n+        }\n+        GlobalSession globalSession = (GlobalSession)session;\n+\n+        GlobalTransactionDO globalTransactionDO = new GlobalTransactionDO();\n+        globalTransactionDO.setXid(globalSession.getXid());\n+        globalTransactionDO.setStatus(globalSession.getStatus().getCode());\n+        globalTransactionDO.setApplicationId(globalSession.getApplicationId());\n+        globalTransactionDO.setBeginTime(globalSession.getBeginTime());\n+        globalTransactionDO.setTimeout(globalSession.getTimeout());\n+        globalTransactionDO.setTransactionId(globalSession.getTransactionId());\n+        globalTransactionDO.setTransactionName(globalSession.getTransactionName());\n+        globalTransactionDO.setTransactionServiceGroup(globalSession.getTransactionServiceGroup());\n+        globalTransactionDO.setApplicationData(globalSession.getApplicationData());\n+        return globalTransactionDO;\n+    }\n+\n+    private BranchTransactionDO convertBranchTransactionDO(SessionStorable session) {\n+        if (session == null || !(session instanceof BranchSession)) {\n+            throw new IllegalArgumentException(\n+                \"the parameter of SessionStorable is not available, SessionStorable:\" + StringUtils.toString(session));\n+        }\n+        BranchSession branchSession = (BranchSession)session;\n+\n+        BranchTransactionDO branchTransactionDO = new BranchTransactionDO();\n+        branchTransactionDO.setXid(branchSession.getXid());\n+        branchTransactionDO.setBranchId(branchSession.getBranchId());\n+        branchTransactionDO.setBranchType(branchSession.getBranchType().name());\n+        branchTransactionDO.setClientId(branchSession.getClientId());\n+        branchTransactionDO.setResourceGroupId(branchSession.getResourceGroupId());\n+        branchTransactionDO.setTransactionId(branchSession.getTransactionId());\n+        branchTransactionDO.setApplicationData(branchSession.getApplicationData());\n+        branchTransactionDO.setResourceId(branchSession.getResourceId());\n+        branchTransactionDO.setStatus(branchSession.getStatus().getCode());\n+        return branchTransactionDO;\n+    }\n+\n+    private GlobalSession convertGlobalSession(GlobalTransactionDO globalTransactionDO) {\n+        GlobalSession session =\n+            new GlobalSession(globalTransactionDO.getApplicationId(), globalTransactionDO.getTransactionServiceGroup(),\n+                globalTransactionDO.getTransactionName(), globalTransactionDO.getTimeout());\n+        session.setTransactionId(globalTransactionDO.getTransactionId());\n+        session.setXid(globalTransactionDO.getXid());\n+        session.setStatus(GlobalStatus.get(globalTransactionDO.getStatus()));\n+        session.setApplicationData(globalTransactionDO.getApplicationData());\n+        session.setBeginTime(globalTransactionDO.getBeginTime());\n+        return session;\n+    }\n+\n+    private BranchSession convertBranchSession(BranchTransactionDO branchTransactionDO) {\n+        BranchSession branchSession = new BranchSession();\n+        branchSession.setXid(branchTransactionDO.getXid());\n+        branchSession.setTransactionId(branchTransactionDO.getTransactionId());\n+        branchSession.setApplicationData(branchTransactionDO.getApplicationData());\n+        branchSession.setBranchId(branchTransactionDO.getBranchId());\n+        branchSession.setBranchType(BranchType.valueOf(branchTransactionDO.getBranchType()));\n+        branchSession.setResourceId(branchTransactionDO.getResourceId());\n+        branchSession.setClientId(branchTransactionDO.getClientId());\n+        branchSession.setResourceGroupId(branchTransactionDO.getResourceGroupId());\n+        branchSession.setStatus(BranchStatus.get(branchTransactionDO.getStatus()));\n+        return branchSession;\n+    }\n+\n+    private GlobalSession getGlobalSession(GlobalTransactionDO globalTransactionDO,\n+        List<BranchTransactionDO> branchTransactionDOs) {\n+        GlobalSession globalSession = convertGlobalSession(globalTransactionDO);\n+        // branch transactions\n+        if (branchTransactionDOs != null && branchTransactionDOs.size() > 0) {\n+            for (BranchTransactionDO branchTransactionDO : branchTransactionDOs) {\n+                globalSession.add(convertBranchSession(branchTransactionDO));\n+            }\n+        }\n+        return globalSession;\n+    }\n+\n+    private Set<String> lRange(Jedis jedis, String key) {\n+        Set<String> keys = new HashSet<>();\n+        List<String> redisBranchJson;\n+        int start = 0;\n+        int stop = logQueryLimit;\n+        for (;;) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "233e6f5238ec40b612df955cba1fc0ae6978ec0b"}, "originalPosition": 407}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY4NzM2OA==", "bodyText": "defaultValue define constant?", "url": "https://github.com/seata/seata/pull/2484#discussion_r427687368", "createdAt": "2020-05-20T01:15:52Z", "author": {"login": "jsbxyyx"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.lock;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.lock.AbstractLocker;\n+import io.seata.core.lock.RowLock;\n+import io.seata.core.store.LockDO;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import redis.clients.jedis.Jedis;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisLocker extends AbstractLocker {\n+\n+    private static final Integer DEFAULT_SECONDS = 30;\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_PREFIX = \"SEATA_LOCK_\";\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX = \"SEATA_LOCK_XID_\";\n+\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    /**\n+     * Instantiates a new Redis locker.\n+     *\n+     */\n+    public RedisLocker() {\n+        logQueryLimit = ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, 100);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "233e6f5238ec40b612df955cba1fc0ae6978ec0b"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY4OTY4NQ==", "bodyText": "like db distinct by rowkey?", "url": "https://github.com/seata/seata/pull/2484#discussion_r427689685", "createdAt": "2020-05-20T01:24:47Z", "author": {"login": "jsbxyyx"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.lock;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.lock.AbstractLocker;\n+import io.seata.core.lock.RowLock;\n+import io.seata.core.store.LockDO;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import redis.clients.jedis.Jedis;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisLocker extends AbstractLocker {\n+\n+    private static final Integer DEFAULT_SECONDS = 30;\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_PREFIX = \"SEATA_LOCK_\";\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX = \"SEATA_LOCK_XID_\";\n+\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    /**\n+     * Instantiates a new Redis locker.\n+     *\n+     */\n+    public RedisLocker() {\n+        logQueryLimit = ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, 100);\n+    }\n+\n+    @Override\n+    public boolean acquireLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        List<String> successList = new ArrayList<>();\n+        long status = 0;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<LockDO> locks = convertToLockDO(rowLocks);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "233e6f5238ec40b612df955cba1fc0ae6978ec0b"}, "originalPosition": 70}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5f803b48a80118220fc10462177c78e395c1e948", "author": {"user": null}, "url": "https://github.com/seata/seata/commit/5f803b48a80118220fc10462177c78e395c1e948", "committedDate": "2020-05-20T01:38:55Z", "message": "Merge branch 'develop' into store_mode_redis"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "248cd06b5b20a85eb8f47ebd2c98d04437fa8132", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/248cd06b5b20a85eb8f47ebd2c98d04437fa8132", "committedDate": "2020-05-20T01:39:25Z", "message": "optimize code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "76d15b284447ecac45ae80a067f206f3221676ed", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/76d15b284447ecac45ae80a067f206f3221676ed", "committedDate": "2020-05-20T01:42:50Z", "message": "Merge branch 'store_mode_redis' of https://github.com/a364176773/seata into store_mode_redis"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f7c80535241a9846c7b4e7c05476efad45292836", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/f7c80535241a9846c7b4e7c05476efad45292836", "committedDate": "2020-05-20T02:02:40Z", "message": "optimize code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "14c9f720b60fe37d3ec79c748d25d87960ca2281", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/14c9f720b60fe37d3ec79c748d25d87960ca2281", "committedDate": "2020-05-20T02:58:01Z", "message": "optimize code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3e9e7572cf863c8df368885f692ed08e109e0305", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/3e9e7572cf863c8df368885f692ed08e109e0305", "committedDate": "2020-05-20T03:31:25Z", "message": "formatting code"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE1MDkwMjE5", "url": "https://github.com/seata/seata/pull/2484#pullrequestreview-415090219", "createdAt": "2020-05-20T08:09:27Z", "commit": {"oid": "3e9e7572cf863c8df368885f692ed08e109e0305"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwODowOToyN1rOGYACbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwODoxMzoyN1rOGYALkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgxOTYyOA==", "bodyText": "break?", "url": "https://github.com/seata/seata/pull/2484#discussion_r427819628", "createdAt": "2020-05-20T08:09:27Z", "author": {"login": "jsbxyyx"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -0,0 +1,256 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.lock;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.LambdaUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.lock.AbstractLocker;\n+import io.seata.core.lock.RowLock;\n+import io.seata.core.store.LockDO;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisLocker extends AbstractLocker {\n+\n+    private static final Integer DEFAULT_SECONDS = 30;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_PREFIX = \"SEATA_LOCK_\";\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX = \"SEATA_LOCK_XID_\";\n+\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    /**\n+     * Instantiates a new Redis locker.\n+     *\n+     */\n+    public RedisLocker() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    @Override\n+    public boolean acquireLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        List<String> successList = new ArrayList<>();\n+        long status = 1;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<LockDO> locks = convertToLockDO(rowLocks);\n+            if (locks.size() > 1) {\n+                locks =\n+                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            }\n+            Pipeline pipeline = jedis.pipelined();\n+            for (LockDO lock : locks) {\n+                String key = getLockKey(lock.getRowKey());\n+                pipeline.setnx(key, JSON.toJSONString(lock));\n+            }\n+            List<Object> results = pipeline.syncAndReturnAll();\n+            for (int i = 0; i < results.size(); i++) {\n+                Long result = (long)results.get(i);\n+                String key = getLockKey(locks.get(i).getRowKey());\n+                if (result != 1) {\n+                    status = result;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e9e7572cf863c8df368885f692ed08e109e0305"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgyMDE2Mg==", "bodyText": "judge result if success?", "url": "https://github.com/seata/seata/pull/2484#discussion_r427820162", "createdAt": "2020-05-20T08:10:23Z", "author": {"login": "jsbxyyx"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -0,0 +1,256 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.lock;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.LambdaUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.lock.AbstractLocker;\n+import io.seata.core.lock.RowLock;\n+import io.seata.core.store.LockDO;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisLocker extends AbstractLocker {\n+\n+    private static final Integer DEFAULT_SECONDS = 30;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_PREFIX = \"SEATA_LOCK_\";\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX = \"SEATA_LOCK_XID_\";\n+\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    /**\n+     * Instantiates a new Redis locker.\n+     *\n+     */\n+    public RedisLocker() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    @Override\n+    public boolean acquireLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        List<String> successList = new ArrayList<>();\n+        long status = 1;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<LockDO> locks = convertToLockDO(rowLocks);\n+            if (locks.size() > 1) {\n+                locks =\n+                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            }\n+            Pipeline pipeline = jedis.pipelined();\n+            for (LockDO lock : locks) {\n+                String key = getLockKey(lock.getRowKey());\n+                pipeline.setnx(key, JSON.toJSONString(lock));\n+            }\n+            List<Object> results = pipeline.syncAndReturnAll();\n+            for (int i = 0; i < results.size(); i++) {\n+                Long result = (long)results.get(i);\n+                String key = getLockKey(locks.get(i).getRowKey());\n+                if (result != 1) {\n+                    status = result;\n+                } else {\n+                    successList.add(key);\n+                }\n+            }\n+            if (status != 1) {\n+                String[] rms = successList.toArray(new String[successList.size()]);\n+                if (rms.length > 0) {\n+                    jedis.del(rms);\n+                }\n+                return false;\n+            } else {\n+                for (LockDO lock : locks) {\n+                    pipeline = jedis.pipelined();\n+                    String key = getLockKey(lock.getRowKey());\n+                    pipeline.lpush(getXidLockKey(lock.getXid()), key);\n+                    pipeline.expire(key, DEFAULT_SECONDS);\n+                }\n+                pipeline.syncAndReturnAll();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e9e7572cf863c8df368885f692ed08e109e0305"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgyMDk4Mg==", "bodyText": "call releaseLock(String xid, List branchIds)??", "url": "https://github.com/seata/seata/pull/2484#discussion_r427820982", "createdAt": "2020-05-20T08:11:50Z", "author": {"login": "jsbxyyx"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -0,0 +1,256 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.lock;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.LambdaUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.lock.AbstractLocker;\n+import io.seata.core.lock.RowLock;\n+import io.seata.core.store.LockDO;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisLocker extends AbstractLocker {\n+\n+    private static final Integer DEFAULT_SECONDS = 30;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_PREFIX = \"SEATA_LOCK_\";\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX = \"SEATA_LOCK_XID_\";\n+\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    /**\n+     * Instantiates a new Redis locker.\n+     *\n+     */\n+    public RedisLocker() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    @Override\n+    public boolean acquireLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        List<String> successList = new ArrayList<>();\n+        long status = 1;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<LockDO> locks = convertToLockDO(rowLocks);\n+            if (locks.size() > 1) {\n+                locks =\n+                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            }\n+            Pipeline pipeline = jedis.pipelined();\n+            for (LockDO lock : locks) {\n+                String key = getLockKey(lock.getRowKey());\n+                pipeline.setnx(key, JSON.toJSONString(lock));\n+            }\n+            List<Object> results = pipeline.syncAndReturnAll();\n+            for (int i = 0; i < results.size(); i++) {\n+                Long result = (long)results.get(i);\n+                String key = getLockKey(locks.get(i).getRowKey());\n+                if (result != 1) {\n+                    status = result;\n+                } else {\n+                    successList.add(key);\n+                }\n+            }\n+            if (status != 1) {\n+                String[] rms = successList.toArray(new String[successList.size()]);\n+                if (rms.length > 0) {\n+                    jedis.del(rms);\n+                }\n+                return false;\n+            } else {\n+                for (LockDO lock : locks) {\n+                    pipeline = jedis.pipelined();\n+                    String key = getLockKey(lock.getRowKey());\n+                    pipeline.lpush(getXidLockKey(lock.getXid()), key);\n+                    pipeline.expire(key, DEFAULT_SECONDS);\n+                }\n+                pipeline.syncAndReturnAll();\n+                return true;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        String[] keys = new String[rowLocks.size()];\n+        List<LockDO> locks = convertToLockDO(rowLocks);\n+        for (int i = 0; i < locks.size(); i++) {\n+            String key = getLockKey(locks.get(i).getRowKey());\n+            keys[i] = key;\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            jedis.del(keys);\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(String xid, List<Long> branchIds) {\n+        if (CollectionUtils.isEmpty(branchIds)) {\n+            // no lock\n+            return true;\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String lockListKey = getXidLockKey(xid);\n+            Set<String> keys = lRange(jedis, lockListKey);\n+            if (CollectionUtils.isNotEmpty(keys)) {\n+                Iterator<String> it = keys.iterator();\n+                while (it.hasNext()) {\n+                    String key = it.next();\n+                    LockDO lock = JSON.parseObject(jedis.get(key), LockDO.class);\n+                    for (int i = 0; i < branchIds.size(); i++) {\n+                        if (null != lock && Objects.equals(lock.getBranchId(), branchIds.get(i))) {\n+                            jedis.del(key);\n+                            jedis.lrem(lockListKey, 0, key);\n+                            it.remove();\n+                        }\n+                    }\n+                }\n+                if (keys.size() == 0) {\n+                    jedis.del(lockListKey);\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(String xid, Long branchId) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String lockListKey = getXidLockKey(xid);\n+            Set<String> keys = lRange(jedis, lockListKey);\n+            if (CollectionUtils.isNotEmpty(keys)) {\n+                Iterator<String> it = keys.iterator();\n+                while (it.hasNext()) {\n+                    String key = it.next();\n+                    LockDO lock = JSON.parseObject(jedis.get(key), LockDO.class);\n+                    if (null != lock && Objects.equals(branchId, lock.getBranchId())) {\n+                        jedis.del(key);\n+                        jedis.lrem(lockListKey, 0, key);\n+                        it.remove();\n+                    }\n+                }\n+                if (keys.size() == 0) {\n+                    jedis.del(lockListKey);\n+                }\n+            }\n+            return true;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e9e7572cf863c8df368885f692ed08e109e0305"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgyMTk3MA==", "bodyText": "equalsIgnoreCase to equals ?", "url": "https://github.com/seata/seata/pull/2484#discussion_r427821970", "createdAt": "2020-05-20T08:13:27Z", "author": {"login": "jsbxyyx"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,440 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String INITIAL_CURSOR = \"0\";\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    public RedisTransactionStoreManager() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO convertBranchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String branchesKey = getBranchListKeyByXid(convertBranchTransactionDO.getXid());\n+            Set<String> keys = lRange(jedis, branchesKey);\n+            if (CollectionUtils.isNotEmpty(keys)) {\n+                String key = getBranchKey(convertBranchTransactionDO.getBranchId());\n+                Iterator<String> it = keys.iterator();\n+                while (it.hasNext()) {\n+                    String s = it.next();\n+                    if (Objects.equals(s, key)) {\n+                        it.remove();\n+                        jedis.del(key);\n+                        jedis.lrem(branchesKey, 0, key);\n+                        break;\n+                    }\n+                }\n+                if (keys.size() == 0) {\n+                    jedis.del(branchesKey);\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO convertBranchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(convertBranchTransactionDO.getBranchId());\n+            Pipeline pipeline = jedis.pipelined();\n+            if (jedis.get(key) == null) {\n+                pipeline.lpush(getBranchListKeyByXid(convertBranchTransactionDO.getXid()), key);\n+            }\n+            pipeline.set(key, JSON.toJSONString(convertBranchTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String[] keys = new String[3];\n+            keys[0] = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n+            keys[1] = getGlobalKeyByTransactionId(convertGlobalTransactionDO.getTransactionId());\n+            String branchesKey = getBranchListKeyByXid(convertGlobalTransactionDO.getXid());\n+            List<String> redisBranches = jedis.lrange(branchesKey, 0, 1);\n+            if (null == redisBranches || redisBranches.size() <= 0) {\n+                keys[2] = branchesKey;\n+            }\n+            jedis.del(keys);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String keys = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n+            Pipeline pipeline = jedis.pipelined();\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            keys = getGlobalKeyByTransactionId(convertGlobalTransactionDO.getTransactionId());\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @param withBranchSessions\n+     *            the withBranchSessions\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid, boolean withBranchSessions) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            globalSessionJson = jedis.get(getGlobalKeyByXid(xid));\n+            if (StringUtils.isBlank(globalSessionJson)) {\n+                return null;\n+            }\n+            // global transaction\n+            GlobalTransactionDO globalTransactionDO = JSON.parseObject(globalSessionJson, GlobalTransactionDO.class);\n+            if (globalTransactionDO == null) {\n+                return null;\n+            }\n+            // branch transactions\n+            List<BranchTransactionDO> branchTransactionDOs = null;\n+            // reduce rpc with db when branchRegister and getGlobalStatus\n+            if (withBranchSessions) {\n+                Set<String> keys = lRange(jedis, getBranchListKeyByXid(globalTransactionDO.getXid()));\n+                if (CollectionUtils.isNotEmpty(keys)) {\n+                    branchTransactionDOs = new ArrayList<>();\n+                    for (String s : keys) {\n+                        branchTransactionDOs.add(JSON.parseObject(jedis.get(s), BranchTransactionDO.class));\n+                    }\n+                }\n+            }\n+            return getGlobalSession(globalTransactionDO, branchTransactionDOs);\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid) {\n+        return this.readSession(xid, true);\n+    }\n+\n+    /**\n+     * Read session list.\n+     *\n+     * @param statuses\n+     *            the statuses\n+     * @return the list\n+     */\n+    public List<GlobalSession> readSession(GlobalStatus[] statuses) {\n+        List<Integer> states = new ArrayList<>();\n+        for (int i = 0; i < statuses.length; i++) {\n+            states.add(statuses[i].getCode());\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Set<String> keys = new HashSet<>();\n+            String cursor = INITIAL_CURSOR;\n+            ScanParams params = new ScanParams();\n+            params.count(logQueryLimit);\n+            params.match(getGlobalKeyByXid(\"*\"));\n+            ScanResult<String> scans;\n+            do {\n+                scans = jedis.scan(cursor, params);\n+                keys.addAll(scans.getResult().stream().collect(Collectors.toSet()));\n+                cursor = scans.getCursor();\n+            } while (!INITIAL_CURSOR.equalsIgnoreCase(cursor));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e9e7572cf863c8df368885f692ed08e109e0305"}, "originalPosition": 254}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f0023656d4209654fc6533961a11ed8706bcad74", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/f0023656d4209654fc6533961a11ed8706bcad74", "committedDate": "2020-05-20T09:40:52Z", "message": "optimize code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "795e85b273442b240de73456df57f28c3b1fdc7f", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/795e85b273442b240de73456df57f28c3b1fdc7f", "committedDate": "2020-05-21T03:44:51Z", "message": "optimize code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6f8d82e1db1bcf49818c5f819eda3f8304ae1195", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/6f8d82e1db1bcf49818c5f819eda3f8304ae1195", "committedDate": "2020-05-21T05:43:04Z", "message": "bug fix"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE1OTAzNjYy", "url": "https://github.com/seata/seata/pull/2484#pullrequestreview-415903662", "createdAt": "2020-05-21T06:16:22Z", "commit": {"oid": "6f8d82e1db1bcf49818c5f819eda3f8304ae1195"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwNjoxNjoyMlrOGYnduA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwNjoxNjo0MVrOGYneOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2NTU5Mg==", "bodyText": "directly throws Exception for test?", "url": "https://github.com/seata/seata/pull/2484#discussion_r428465592", "createdAt": "2020-05-21T06:16:22Z", "author": {"login": "jsbxyyx"}, "path": "server/src/test/java/io/seata/server/lock/redis/RedisLockManagerTest.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package io.seata.server.lock.redis;\n+\n+import java.io.IOException;\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+import com.github.fppt.jedismock.RedisServer;\n+\n+import io.seata.core.exception.TransactionException;\n+import io.seata.core.lock.Locker;\n+import io.seata.server.lock.LockManager;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.storage.file.lock.FileLockManager;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.storage.redis.lock.RedisLocker;\n+import redis.clients.jedis.JedisPool;\n+import redis.clients.jedis.JedisPoolConfig;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisLockManagerTest {\n+    static RedisServer server = null;\n+    static LockManager lockManager = null;\n+\n+    @BeforeAll\n+    public static void start() {\n+        try {\n+            server = RedisServer.newRedisServer(6789);\n+            server.start();\n+        } catch (IOException e) {\n+            e.printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f8d82e1db1bcf49818c5f819eda3f8304ae1195"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2NTcyMg==", "bodyText": "directly throws exception for test?", "url": "https://github.com/seata/seata/pull/2484#discussion_r428465722", "createdAt": "2020-05-21T06:16:41Z", "author": {"login": "jsbxyyx"}, "path": "server/src/test/java/io/seata/server/session/redis/RedisSeesionManagerTest.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package io.seata.server.session.redis;\n+\n+import java.io.IOException;\n+import com.github.fppt.jedismock.RedisServer;\n+import io.seata.common.XID;\n+import io.seata.core.exception.TransactionException;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.server.UUIDGenerator;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionManager;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.storage.redis.session.RedisSessionManager;\n+import io.seata.server.storage.redis.store.RedisTransactionStoreManager;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import redis.clients.jedis.JedisPool;\n+import redis.clients.jedis.JedisPoolConfig;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisSeesionManagerTest {\n+    private static RedisServer server = null;\n+    private static SessionManager sessionManager = null;\n+\n+    @BeforeAll\n+    public static void start() {\n+        try {\n+            server = RedisServer.newRedisServer(6789);\n+            server.start();\n+        } catch (IOException e) {\n+            e.printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f8d82e1db1bcf49818c5f819eda3f8304ae1195"}, "originalPosition": 52}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3f9e257e6b40a44d8a94e12488376590c7a1cbcf", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/3f9e257e6b40a44d8a94e12488376590c7a1cbcf", "committedDate": "2020-05-21T09:41:17Z", "message": "optimize test cases"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cd944da028f8c1e2f3fb1383e43a8d422753e6d0", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/cd944da028f8c1e2f3fb1383e43a8d422753e6d0", "committedDate": "2020-05-22T05:49:51Z", "message": "optimize logic"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2ea55fa3b527a185f2ad20c26d2aab89bec04ce4", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/2ea55fa3b527a185f2ad20c26d2aab89bec04ce4", "committedDate": "2020-05-23T06:51:13Z", "message": "Merge branch 'develop' into store_mode_redis"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3NDE2MTA4", "url": "https://github.com/seata/seata/pull/2484#pullrequestreview-417416108", "createdAt": "2020-05-25T01:28:28Z", "commit": {"oid": "2ea55fa3b527a185f2ad20c26d2aab89bec04ce4"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b", "committedDate": "2020-05-28T10:39:42Z", "message": "Merge branch 'develop' into store_mode_redis"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxNDAzODEw", "url": "https://github.com/seata/seata/pull/2484#pullrequestreview-421403810", "createdAt": "2020-05-30T13:04:40Z", "commit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "state": "COMMENTED", "comments": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQxMzowNDo0MFrOGcydvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQxNzoxNjo0MlrOGc0Xqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg0MDEyNw==", "bodyText": "private constructor, logQueryLimit assignment can be put on it", "url": "https://github.com/seata/seata/pull/2484#discussion_r432840127", "createdAt": "2020-05-30T13:04:40Z", "author": {"login": "ph3636"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import com.alibaba.fastjson.JSON;\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String INITIAL_CURSOR = \"0\";\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    public RedisTransactionStoreManager() {\n+        logQueryLimit =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg0MDIxMA==", "bodyText": "Is array better", "url": "https://github.com/seata/seata/pull/2484#discussion_r432840210", "createdAt": "2020-05-30T13:05:36Z", "author": {"login": "ph3636"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import com.alibaba.fastjson.JSON;\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String INITIAL_CURSOR = \"0\";\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    public RedisTransactionStoreManager() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            jedis.del(key);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            Pipeline pipeline = jedis.pipelined();\n+            if (jedis.get(key) == null) {\n+                pipeline.lpush(getBranchListKeyByXid(branchTransactionDO.getXid()), key);\n+            }\n+            pipeline.set(key, JSON.toJSONString(branchTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<String> keys = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg0MDI3MQ==", "bodyText": "Convert JSON once", "url": "https://github.com/seata/seata/pull/2484#discussion_r432840271", "createdAt": "2020-05-30T13:06:43Z", "author": {"login": "ph3636"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import com.alibaba.fastjson.JSON;\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String INITIAL_CURSOR = \"0\";\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    public RedisTransactionStoreManager() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            jedis.del(key);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            Pipeline pipeline = jedis.pipelined();\n+            if (jedis.get(key) == null) {\n+                pipeline.lpush(getBranchListKeyByXid(branchTransactionDO.getXid()), key);\n+            }\n+            pipeline.set(key, JSON.toJSONString(branchTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<String> keys = new ArrayList<>();\n+            keys.add(getGlobalKeyByXid(globalTransactionDO.getXid()));\n+            keys.add(getGlobalKeyByTransactionId(globalTransactionDO.getTransactionId()));\n+            keys.add(getBranchListKeyByXid(globalTransactionDO.getXid()));\n+            jedis.del(keys.toArray(new String[keys.size()]));\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String keys = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n+            Pipeline pipeline = jedis.pipelined();\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg0MDQzMg==", "bodyText": "Judge whether it is empty", "url": "https://github.com/seata/seata/pull/2484#discussion_r432840432", "createdAt": "2020-05-30T13:09:00Z", "author": {"login": "ph3636"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import com.alibaba.fastjson.JSON;\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String INITIAL_CURSOR = \"0\";\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    public RedisTransactionStoreManager() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            jedis.del(key);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            Pipeline pipeline = jedis.pipelined();\n+            if (jedis.get(key) == null) {\n+                pipeline.lpush(getBranchListKeyByXid(branchTransactionDO.getXid()), key);\n+            }\n+            pipeline.set(key, JSON.toJSONString(branchTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<String> keys = new ArrayList<>();\n+            keys.add(getGlobalKeyByXid(globalTransactionDO.getXid()));\n+            keys.add(getGlobalKeyByTransactionId(globalTransactionDO.getTransactionId()));\n+            keys.add(getBranchListKeyByXid(globalTransactionDO.getXid()));\n+            jedis.del(keys.toArray(new String[keys.size()]));\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String keys = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n+            Pipeline pipeline = jedis.pipelined();\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            keys = getGlobalKeyByTransactionId(convertGlobalTransactionDO.getTransactionId());\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @param withBranchSessions\n+     *            the withBranchSessions\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid, boolean withBranchSessions) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            globalSessionJson = jedis.get(getGlobalKeyByXid(xid));\n+            if (StringUtils.isBlank(globalSessionJson)) {\n+                return null;\n+            }\n+            // global transaction\n+            GlobalTransactionDO globalTransactionDO = JSON.parseObject(globalSessionJson, GlobalTransactionDO.class);\n+            if (globalTransactionDO == null) {\n+                return null;\n+            }\n+            // branch transactions\n+            List<BranchTransactionDO> branchTransactionDOs = null;\n+            // reduce rpc with db when branchRegister and getGlobalStatus\n+            if (withBranchSessions) {\n+                Set<String> keys = lRange(jedis, getBranchListKeyByXid(globalTransactionDO.getXid()));\n+                if (CollectionUtils.isNotEmpty(keys)) {\n+                    branchTransactionDOs = new ArrayList<>();\n+                    for (String s : keys) {\n+                        String branchJson = jedis.get(s);\n+                        if (StringUtils.isNotBlank(branchJson)) {\n+                            branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg0MDg1OQ==", "bodyText": "Judge whether it is empty", "url": "https://github.com/seata/seata/pull/2484#discussion_r432840859", "createdAt": "2020-05-30T13:14:54Z", "author": {"login": "ph3636"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import com.alibaba.fastjson.JSON;\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String INITIAL_CURSOR = \"0\";\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    public RedisTransactionStoreManager() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            jedis.del(key);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            Pipeline pipeline = jedis.pipelined();\n+            if (jedis.get(key) == null) {\n+                pipeline.lpush(getBranchListKeyByXid(branchTransactionDO.getXid()), key);\n+            }\n+            pipeline.set(key, JSON.toJSONString(branchTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<String> keys = new ArrayList<>();\n+            keys.add(getGlobalKeyByXid(globalTransactionDO.getXid()));\n+            keys.add(getGlobalKeyByTransactionId(globalTransactionDO.getTransactionId()));\n+            keys.add(getBranchListKeyByXid(globalTransactionDO.getXid()));\n+            jedis.del(keys.toArray(new String[keys.size()]));\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String keys = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n+            Pipeline pipeline = jedis.pipelined();\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            keys = getGlobalKeyByTransactionId(convertGlobalTransactionDO.getTransactionId());\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @param withBranchSessions\n+     *            the withBranchSessions\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid, boolean withBranchSessions) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            globalSessionJson = jedis.get(getGlobalKeyByXid(xid));\n+            if (StringUtils.isBlank(globalSessionJson)) {\n+                return null;\n+            }\n+            // global transaction\n+            GlobalTransactionDO globalTransactionDO = JSON.parseObject(globalSessionJson, GlobalTransactionDO.class);\n+            if (globalTransactionDO == null) {\n+                return null;\n+            }\n+            // branch transactions\n+            List<BranchTransactionDO> branchTransactionDOs = null;\n+            // reduce rpc with db when branchRegister and getGlobalStatus\n+            if (withBranchSessions) {\n+                Set<String> keys = lRange(jedis, getBranchListKeyByXid(globalTransactionDO.getXid()));\n+                if (CollectionUtils.isNotEmpty(keys)) {\n+                    branchTransactionDOs = new ArrayList<>();\n+                    for (String s : keys) {\n+                        String branchJson = jedis.get(s);\n+                        if (StringUtils.isNotBlank(branchJson)) {\n+                            branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                        }\n+                    }\n+                }\n+            }\n+            return getGlobalSession(globalTransactionDO, branchTransactionDOs);\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid) {\n+        return this.readSession(xid, true);\n+    }\n+\n+    /**\n+     * Read session list.\n+     *\n+     * @param statuses\n+     *            the statuses\n+     * @return the list\n+     */\n+    public List<GlobalSession> readSession(GlobalStatus[] statuses) {\n+        List<Integer> states = new ArrayList<>();\n+        for (int i = 0; i < statuses.length; i++) {\n+            states.add(statuses[i].getCode());\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Set<String> keys = new HashSet<>();\n+            String cursor = INITIAL_CURSOR;\n+            ScanParams params = new ScanParams();\n+            params.count(logQueryLimit);\n+            params.match(getGlobalKeyByXid(\"*\"));\n+            ScanResult<String> scans;\n+            do {\n+                scans = jedis.scan(cursor, params);\n+                keys.addAll(scans.getResult().stream().collect(Collectors.toSet()));\n+                cursor = scans.getCursor();\n+            } while (!INITIAL_CURSOR.equals(cursor));\n+            if (CollectionUtils.isNotEmpty(keys)) {\n+                List<GlobalTransactionDO> globalTransactionDOs = new ArrayList<>();\n+                for (String globalKey : keys) {\n+                    GlobalTransactionDO globalTransactionDO =\n+                        JSON.parseObject(jedis.get(globalKey), GlobalTransactionDO.class);\n+                    if (null != globalTransactionDO && states.contains(globalTransactionDO.getStatus())) {\n+                        globalTransactionDOs.add(globalTransactionDO);\n+                    }\n+                }\n+                if (CollectionUtils.isNotEmpty(globalTransactionDOs)) {\n+                    List<String> xids =\n+                        globalTransactionDOs.stream().map(GlobalTransactionDO::getXid).collect(Collectors.toList());\n+                    List<BranchTransactionDO> branchTransactionDOs = new ArrayList<>();\n+                    for (String xid : xids) {\n+                        Set<String> branches = lRange(jedis, getBranchListKeyByXid(xid));\n+                        if (CollectionUtils.isNotEmpty(branches)) {\n+                            for (String branchKey : branches) {\n+                                String branchJson = jedis.get(branchKey);\n+                                if (StringUtils.isNotBlank(branchJson)) {\n+                                    branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                                }\n+                            }\n+                        }\n+                    }\n+                    Map<String, List<BranchTransactionDO>> branchTransactionDOsMap =\n+                        branchTransactionDOs.stream().collect(Collectors.groupingBy(BranchTransactionDO::getXid,\n+                            LinkedHashMap::new, Collectors.toList()));\n+                    return globalTransactionDOs.stream()\n+                        .map(globalTransactionDO -> getGlobalSession(globalTransactionDO,\n+                            branchTransactionDOsMap.get(globalTransactionDO.getXid())))\n+                        .collect(Collectors.toList());\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public List<GlobalSession> readSession(SessionCondition sessionCondition) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            if (StringUtils.isNotBlank(sessionCondition.getXid())) {\n+                globalSessionJson = jedis.get(getGlobalKeyByXid(sessionCondition.getXid()));\n+                if (StringUtils.isNotBlank(globalSessionJson)) {\n+                    GlobalSession session =\n+                        convertGlobalSession(JSON.parseObject(globalSessionJson, GlobalTransactionDO.class));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 279}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg0MTE5Mg==", "bodyText": "mget", "url": "https://github.com/seata/seata/pull/2484#discussion_r432841192", "createdAt": "2020-05-30T13:19:33Z", "author": {"login": "ph3636"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import com.alibaba.fastjson.JSON;\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String INITIAL_CURSOR = \"0\";\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    public RedisTransactionStoreManager() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            jedis.del(key);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            Pipeline pipeline = jedis.pipelined();\n+            if (jedis.get(key) == null) {\n+                pipeline.lpush(getBranchListKeyByXid(branchTransactionDO.getXid()), key);\n+            }\n+            pipeline.set(key, JSON.toJSONString(branchTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<String> keys = new ArrayList<>();\n+            keys.add(getGlobalKeyByXid(globalTransactionDO.getXid()));\n+            keys.add(getGlobalKeyByTransactionId(globalTransactionDO.getTransactionId()));\n+            keys.add(getBranchListKeyByXid(globalTransactionDO.getXid()));\n+            jedis.del(keys.toArray(new String[keys.size()]));\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String keys = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n+            Pipeline pipeline = jedis.pipelined();\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            keys = getGlobalKeyByTransactionId(convertGlobalTransactionDO.getTransactionId());\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @param withBranchSessions\n+     *            the withBranchSessions\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid, boolean withBranchSessions) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            globalSessionJson = jedis.get(getGlobalKeyByXid(xid));\n+            if (StringUtils.isBlank(globalSessionJson)) {\n+                return null;\n+            }\n+            // global transaction\n+            GlobalTransactionDO globalTransactionDO = JSON.parseObject(globalSessionJson, GlobalTransactionDO.class);\n+            if (globalTransactionDO == null) {\n+                return null;\n+            }\n+            // branch transactions\n+            List<BranchTransactionDO> branchTransactionDOs = null;\n+            // reduce rpc with db when branchRegister and getGlobalStatus\n+            if (withBranchSessions) {\n+                Set<String> keys = lRange(jedis, getBranchListKeyByXid(globalTransactionDO.getXid()));\n+                if (CollectionUtils.isNotEmpty(keys)) {\n+                    branchTransactionDOs = new ArrayList<>();\n+                    for (String s : keys) {\n+                        String branchJson = jedis.get(s);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 187}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg0MTMyNA==", "bodyText": "The scope of globalSessionJson and global is clear", "url": "https://github.com/seata/seata/pull/2484#discussion_r432841324", "createdAt": "2020-05-30T13:21:37Z", "author": {"login": "ph3636"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import com.alibaba.fastjson.JSON;\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String INITIAL_CURSOR = \"0\";\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    public RedisTransactionStoreManager() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            jedis.del(key);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            Pipeline pipeline = jedis.pipelined();\n+            if (jedis.get(key) == null) {\n+                pipeline.lpush(getBranchListKeyByXid(branchTransactionDO.getXid()), key);\n+            }\n+            pipeline.set(key, JSON.toJSONString(branchTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<String> keys = new ArrayList<>();\n+            keys.add(getGlobalKeyByXid(globalTransactionDO.getXid()));\n+            keys.add(getGlobalKeyByTransactionId(globalTransactionDO.getTransactionId()));\n+            keys.add(getBranchListKeyByXid(globalTransactionDO.getXid()));\n+            jedis.del(keys.toArray(new String[keys.size()]));\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String keys = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n+            Pipeline pipeline = jedis.pipelined();\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            keys = getGlobalKeyByTransactionId(convertGlobalTransactionDO.getTransactionId());\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @param withBranchSessions\n+     *            the withBranchSessions\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid, boolean withBranchSessions) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            globalSessionJson = jedis.get(getGlobalKeyByXid(xid));\n+            if (StringUtils.isBlank(globalSessionJson)) {\n+                return null;\n+            }\n+            // global transaction\n+            GlobalTransactionDO globalTransactionDO = JSON.parseObject(globalSessionJson, GlobalTransactionDO.class);\n+            if (globalTransactionDO == null) {\n+                return null;\n+            }\n+            // branch transactions\n+            List<BranchTransactionDO> branchTransactionDOs = null;\n+            // reduce rpc with db when branchRegister and getGlobalStatus\n+            if (withBranchSessions) {\n+                Set<String> keys = lRange(jedis, getBranchListKeyByXid(globalTransactionDO.getXid()));\n+                if (CollectionUtils.isNotEmpty(keys)) {\n+                    branchTransactionDOs = new ArrayList<>();\n+                    for (String s : keys) {\n+                        String branchJson = jedis.get(s);\n+                        if (StringUtils.isNotBlank(branchJson)) {\n+                            branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                        }\n+                    }\n+                }\n+            }\n+            return getGlobalSession(globalTransactionDO, branchTransactionDOs);\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid) {\n+        return this.readSession(xid, true);\n+    }\n+\n+    /**\n+     * Read session list.\n+     *\n+     * @param statuses\n+     *            the statuses\n+     * @return the list\n+     */\n+    public List<GlobalSession> readSession(GlobalStatus[] statuses) {\n+        List<Integer> states = new ArrayList<>();\n+        for (int i = 0; i < statuses.length; i++) {\n+            states.add(statuses[i].getCode());\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Set<String> keys = new HashSet<>();\n+            String cursor = INITIAL_CURSOR;\n+            ScanParams params = new ScanParams();\n+            params.count(logQueryLimit);\n+            params.match(getGlobalKeyByXid(\"*\"));\n+            ScanResult<String> scans;\n+            do {\n+                scans = jedis.scan(cursor, params);\n+                keys.addAll(scans.getResult().stream().collect(Collectors.toSet()));\n+                cursor = scans.getCursor();\n+            } while (!INITIAL_CURSOR.equals(cursor));\n+            if (CollectionUtils.isNotEmpty(keys)) {\n+                List<GlobalTransactionDO> globalTransactionDOs = new ArrayList<>();\n+                for (String globalKey : keys) {\n+                    GlobalTransactionDO globalTransactionDO =\n+                        JSON.parseObject(jedis.get(globalKey), GlobalTransactionDO.class);\n+                    if (null != globalTransactionDO && states.contains(globalTransactionDO.getStatus())) {\n+                        globalTransactionDOs.add(globalTransactionDO);\n+                    }\n+                }\n+                if (CollectionUtils.isNotEmpty(globalTransactionDOs)) {\n+                    List<String> xids =\n+                        globalTransactionDOs.stream().map(GlobalTransactionDO::getXid).collect(Collectors.toList());\n+                    List<BranchTransactionDO> branchTransactionDOs = new ArrayList<>();\n+                    for (String xid : xids) {\n+                        Set<String> branches = lRange(jedis, getBranchListKeyByXid(xid));\n+                        if (CollectionUtils.isNotEmpty(branches)) {\n+                            for (String branchKey : branches) {\n+                                String branchJson = jedis.get(branchKey);\n+                                if (StringUtils.isNotBlank(branchJson)) {\n+                                    branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                                }\n+                            }\n+                        }\n+                    }\n+                    Map<String, List<BranchTransactionDO>> branchTransactionDOsMap =\n+                        branchTransactionDOs.stream().collect(Collectors.groupingBy(BranchTransactionDO::getXid,\n+                            LinkedHashMap::new, Collectors.toList()));\n+                    return globalTransactionDOs.stream()\n+                        .map(globalTransactionDO -> getGlobalSession(globalTransactionDO,\n+                            branchTransactionDOsMap.get(globalTransactionDO.getXid())))\n+                        .collect(Collectors.toList());\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public List<GlobalSession> readSession(SessionCondition sessionCondition) {\n+        String globalSessionJson;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 273}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg0MTM2OQ==", "bodyText": "Judge whether it is empty", "url": "https://github.com/seata/seata/pull/2484#discussion_r432841369", "createdAt": "2020-05-30T13:22:05Z", "author": {"login": "ph3636"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import com.alibaba.fastjson.JSON;\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String INITIAL_CURSOR = \"0\";\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    public RedisTransactionStoreManager() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            jedis.del(key);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            Pipeline pipeline = jedis.pipelined();\n+            if (jedis.get(key) == null) {\n+                pipeline.lpush(getBranchListKeyByXid(branchTransactionDO.getXid()), key);\n+            }\n+            pipeline.set(key, JSON.toJSONString(branchTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<String> keys = new ArrayList<>();\n+            keys.add(getGlobalKeyByXid(globalTransactionDO.getXid()));\n+            keys.add(getGlobalKeyByTransactionId(globalTransactionDO.getTransactionId()));\n+            keys.add(getBranchListKeyByXid(globalTransactionDO.getXid()));\n+            jedis.del(keys.toArray(new String[keys.size()]));\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String keys = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n+            Pipeline pipeline = jedis.pipelined();\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            keys = getGlobalKeyByTransactionId(convertGlobalTransactionDO.getTransactionId());\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @param withBranchSessions\n+     *            the withBranchSessions\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid, boolean withBranchSessions) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            globalSessionJson = jedis.get(getGlobalKeyByXid(xid));\n+            if (StringUtils.isBlank(globalSessionJson)) {\n+                return null;\n+            }\n+            // global transaction\n+            GlobalTransactionDO globalTransactionDO = JSON.parseObject(globalSessionJson, GlobalTransactionDO.class);\n+            if (globalTransactionDO == null) {\n+                return null;\n+            }\n+            // branch transactions\n+            List<BranchTransactionDO> branchTransactionDOs = null;\n+            // reduce rpc with db when branchRegister and getGlobalStatus\n+            if (withBranchSessions) {\n+                Set<String> keys = lRange(jedis, getBranchListKeyByXid(globalTransactionDO.getXid()));\n+                if (CollectionUtils.isNotEmpty(keys)) {\n+                    branchTransactionDOs = new ArrayList<>();\n+                    for (String s : keys) {\n+                        String branchJson = jedis.get(s);\n+                        if (StringUtils.isNotBlank(branchJson)) {\n+                            branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                        }\n+                    }\n+                }\n+            }\n+            return getGlobalSession(globalTransactionDO, branchTransactionDOs);\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid) {\n+        return this.readSession(xid, true);\n+    }\n+\n+    /**\n+     * Read session list.\n+     *\n+     * @param statuses\n+     *            the statuses\n+     * @return the list\n+     */\n+    public List<GlobalSession> readSession(GlobalStatus[] statuses) {\n+        List<Integer> states = new ArrayList<>();\n+        for (int i = 0; i < statuses.length; i++) {\n+            states.add(statuses[i].getCode());\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Set<String> keys = new HashSet<>();\n+            String cursor = INITIAL_CURSOR;\n+            ScanParams params = new ScanParams();\n+            params.count(logQueryLimit);\n+            params.match(getGlobalKeyByXid(\"*\"));\n+            ScanResult<String> scans;\n+            do {\n+                scans = jedis.scan(cursor, params);\n+                keys.addAll(scans.getResult().stream().collect(Collectors.toSet()));\n+                cursor = scans.getCursor();\n+            } while (!INITIAL_CURSOR.equals(cursor));\n+            if (CollectionUtils.isNotEmpty(keys)) {\n+                List<GlobalTransactionDO> globalTransactionDOs = new ArrayList<>();\n+                for (String globalKey : keys) {\n+                    GlobalTransactionDO globalTransactionDO =\n+                        JSON.parseObject(jedis.get(globalKey), GlobalTransactionDO.class);\n+                    if (null != globalTransactionDO && states.contains(globalTransactionDO.getStatus())) {\n+                        globalTransactionDOs.add(globalTransactionDO);\n+                    }\n+                }\n+                if (CollectionUtils.isNotEmpty(globalTransactionDOs)) {\n+                    List<String> xids =\n+                        globalTransactionDOs.stream().map(GlobalTransactionDO::getXid).collect(Collectors.toList());\n+                    List<BranchTransactionDO> branchTransactionDOs = new ArrayList<>();\n+                    for (String xid : xids) {\n+                        Set<String> branches = lRange(jedis, getBranchListKeyByXid(xid));\n+                        if (CollectionUtils.isNotEmpty(branches)) {\n+                            for (String branchKey : branches) {\n+                                String branchJson = jedis.get(branchKey);\n+                                if (StringUtils.isNotBlank(branchJson)) {\n+                                    branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                                }\n+                            }\n+                        }\n+                    }\n+                    Map<String, List<BranchTransactionDO>> branchTransactionDOsMap =\n+                        branchTransactionDOs.stream().collect(Collectors.groupingBy(BranchTransactionDO::getXid,\n+                            LinkedHashMap::new, Collectors.toList()));\n+                    return globalTransactionDOs.stream()\n+                        .map(globalTransactionDO -> getGlobalSession(globalTransactionDO,\n+                            branchTransactionDOsMap.get(globalTransactionDO.getXid())))\n+                        .collect(Collectors.toList());\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public List<GlobalSession> readSession(SessionCondition sessionCondition) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            if (StringUtils.isNotBlank(sessionCondition.getXid())) {\n+                globalSessionJson = jedis.get(getGlobalKeyByXid(sessionCondition.getXid()));\n+                if (StringUtils.isNotBlank(globalSessionJson)) {\n+                    GlobalSession session =\n+                        convertGlobalSession(JSON.parseObject(globalSessionJson, GlobalTransactionDO.class));\n+                    List<GlobalSession> globalSessions = new ArrayList<>();\n+                    globalSessions.add(session);\n+                    return globalSessions;\n+                }\n+            } else if (sessionCondition.getTransactionId() != null) {\n+                String global = jedis.get(getGlobalKeyByTransactionId(sessionCondition.getTransactionId()));\n+                if (StringUtils.isBlank(global)) {\n+                    return null;\n+                }\n+                GlobalTransactionDO globalTransactionDO = JSON.parseObject(global, GlobalTransactionDO.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 289}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg0MTQ0OA==", "bodyText": "Judge whether it is empty", "url": "https://github.com/seata/seata/pull/2484#discussion_r432841448", "createdAt": "2020-05-30T13:22:59Z", "author": {"login": "ph3636"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import com.alibaba.fastjson.JSON;\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String INITIAL_CURSOR = \"0\";\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    public RedisTransactionStoreManager() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            jedis.del(key);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            Pipeline pipeline = jedis.pipelined();\n+            if (jedis.get(key) == null) {\n+                pipeline.lpush(getBranchListKeyByXid(branchTransactionDO.getXid()), key);\n+            }\n+            pipeline.set(key, JSON.toJSONString(branchTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<String> keys = new ArrayList<>();\n+            keys.add(getGlobalKeyByXid(globalTransactionDO.getXid()));\n+            keys.add(getGlobalKeyByTransactionId(globalTransactionDO.getTransactionId()));\n+            keys.add(getBranchListKeyByXid(globalTransactionDO.getXid()));\n+            jedis.del(keys.toArray(new String[keys.size()]));\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String keys = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n+            Pipeline pipeline = jedis.pipelined();\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            keys = getGlobalKeyByTransactionId(convertGlobalTransactionDO.getTransactionId());\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @param withBranchSessions\n+     *            the withBranchSessions\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid, boolean withBranchSessions) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            globalSessionJson = jedis.get(getGlobalKeyByXid(xid));\n+            if (StringUtils.isBlank(globalSessionJson)) {\n+                return null;\n+            }\n+            // global transaction\n+            GlobalTransactionDO globalTransactionDO = JSON.parseObject(globalSessionJson, GlobalTransactionDO.class);\n+            if (globalTransactionDO == null) {\n+                return null;\n+            }\n+            // branch transactions\n+            List<BranchTransactionDO> branchTransactionDOs = null;\n+            // reduce rpc with db when branchRegister and getGlobalStatus\n+            if (withBranchSessions) {\n+                Set<String> keys = lRange(jedis, getBranchListKeyByXid(globalTransactionDO.getXid()));\n+                if (CollectionUtils.isNotEmpty(keys)) {\n+                    branchTransactionDOs = new ArrayList<>();\n+                    for (String s : keys) {\n+                        String branchJson = jedis.get(s);\n+                        if (StringUtils.isNotBlank(branchJson)) {\n+                            branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                        }\n+                    }\n+                }\n+            }\n+            return getGlobalSession(globalTransactionDO, branchTransactionDOs);\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid) {\n+        return this.readSession(xid, true);\n+    }\n+\n+    /**\n+     * Read session list.\n+     *\n+     * @param statuses\n+     *            the statuses\n+     * @return the list\n+     */\n+    public List<GlobalSession> readSession(GlobalStatus[] statuses) {\n+        List<Integer> states = new ArrayList<>();\n+        for (int i = 0; i < statuses.length; i++) {\n+            states.add(statuses[i].getCode());\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Set<String> keys = new HashSet<>();\n+            String cursor = INITIAL_CURSOR;\n+            ScanParams params = new ScanParams();\n+            params.count(logQueryLimit);\n+            params.match(getGlobalKeyByXid(\"*\"));\n+            ScanResult<String> scans;\n+            do {\n+                scans = jedis.scan(cursor, params);\n+                keys.addAll(scans.getResult().stream().collect(Collectors.toSet()));\n+                cursor = scans.getCursor();\n+            } while (!INITIAL_CURSOR.equals(cursor));\n+            if (CollectionUtils.isNotEmpty(keys)) {\n+                List<GlobalTransactionDO> globalTransactionDOs = new ArrayList<>();\n+                for (String globalKey : keys) {\n+                    GlobalTransactionDO globalTransactionDO =\n+                        JSON.parseObject(jedis.get(globalKey), GlobalTransactionDO.class);\n+                    if (null != globalTransactionDO && states.contains(globalTransactionDO.getStatus())) {\n+                        globalTransactionDOs.add(globalTransactionDO);\n+                    }\n+                }\n+                if (CollectionUtils.isNotEmpty(globalTransactionDOs)) {\n+                    List<String> xids =\n+                        globalTransactionDOs.stream().map(GlobalTransactionDO::getXid).collect(Collectors.toList());\n+                    List<BranchTransactionDO> branchTransactionDOs = new ArrayList<>();\n+                    for (String xid : xids) {\n+                        Set<String> branches = lRange(jedis, getBranchListKeyByXid(xid));\n+                        if (CollectionUtils.isNotEmpty(branches)) {\n+                            for (String branchKey : branches) {\n+                                String branchJson = jedis.get(branchKey);\n+                                if (StringUtils.isNotBlank(branchJson)) {\n+                                    branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                                }\n+                            }\n+                        }\n+                    }\n+                    Map<String, List<BranchTransactionDO>> branchTransactionDOsMap =\n+                        branchTransactionDOs.stream().collect(Collectors.groupingBy(BranchTransactionDO::getXid,\n+                            LinkedHashMap::new, Collectors.toList()));\n+                    return globalTransactionDOs.stream()\n+                        .map(globalTransactionDO -> getGlobalSession(globalTransactionDO,\n+                            branchTransactionDOsMap.get(globalTransactionDO.getXid())))\n+                        .collect(Collectors.toList());\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public List<GlobalSession> readSession(SessionCondition sessionCondition) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            if (StringUtils.isNotBlank(sessionCondition.getXid())) {\n+                globalSessionJson = jedis.get(getGlobalKeyByXid(sessionCondition.getXid()));\n+                if (StringUtils.isNotBlank(globalSessionJson)) {\n+                    GlobalSession session =\n+                        convertGlobalSession(JSON.parseObject(globalSessionJson, GlobalTransactionDO.class));\n+                    List<GlobalSession> globalSessions = new ArrayList<>();\n+                    globalSessions.add(session);\n+                    return globalSessions;\n+                }\n+            } else if (sessionCondition.getTransactionId() != null) {\n+                String global = jedis.get(getGlobalKeyByTransactionId(sessionCondition.getTransactionId()));\n+                if (StringUtils.isBlank(global)) {\n+                    return null;\n+                }\n+                GlobalTransactionDO globalTransactionDO = JSON.parseObject(global, GlobalTransactionDO.class);\n+                String branchKey = getBranchListKeyByXid(globalTransactionDO.getXid());\n+                Set<String> keys = lRange(jedis, branchKey);\n+                List<BranchTransactionDO> branchTransactionDOs = new ArrayList<>();\n+                if (CollectionUtils.isNotEmpty(keys)) {\n+                    for (String s : keys) {\n+                        String branchJson = jedis.get(s);\n+                        if (StringUtils.isNotBlank(branchJson)) {\n+                            branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 297}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg0MTQ2Ng==", "bodyText": "mget", "url": "https://github.com/seata/seata/pull/2484#discussion_r432841466", "createdAt": "2020-05-30T13:23:08Z", "author": {"login": "ph3636"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import com.alibaba.fastjson.JSON;\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String INITIAL_CURSOR = \"0\";\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    public RedisTransactionStoreManager() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            jedis.del(key);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            Pipeline pipeline = jedis.pipelined();\n+            if (jedis.get(key) == null) {\n+                pipeline.lpush(getBranchListKeyByXid(branchTransactionDO.getXid()), key);\n+            }\n+            pipeline.set(key, JSON.toJSONString(branchTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<String> keys = new ArrayList<>();\n+            keys.add(getGlobalKeyByXid(globalTransactionDO.getXid()));\n+            keys.add(getGlobalKeyByTransactionId(globalTransactionDO.getTransactionId()));\n+            keys.add(getBranchListKeyByXid(globalTransactionDO.getXid()));\n+            jedis.del(keys.toArray(new String[keys.size()]));\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String keys = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n+            Pipeline pipeline = jedis.pipelined();\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            keys = getGlobalKeyByTransactionId(convertGlobalTransactionDO.getTransactionId());\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @param withBranchSessions\n+     *            the withBranchSessions\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid, boolean withBranchSessions) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            globalSessionJson = jedis.get(getGlobalKeyByXid(xid));\n+            if (StringUtils.isBlank(globalSessionJson)) {\n+                return null;\n+            }\n+            // global transaction\n+            GlobalTransactionDO globalTransactionDO = JSON.parseObject(globalSessionJson, GlobalTransactionDO.class);\n+            if (globalTransactionDO == null) {\n+                return null;\n+            }\n+            // branch transactions\n+            List<BranchTransactionDO> branchTransactionDOs = null;\n+            // reduce rpc with db when branchRegister and getGlobalStatus\n+            if (withBranchSessions) {\n+                Set<String> keys = lRange(jedis, getBranchListKeyByXid(globalTransactionDO.getXid()));\n+                if (CollectionUtils.isNotEmpty(keys)) {\n+                    branchTransactionDOs = new ArrayList<>();\n+                    for (String s : keys) {\n+                        String branchJson = jedis.get(s);\n+                        if (StringUtils.isNotBlank(branchJson)) {\n+                            branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                        }\n+                    }\n+                }\n+            }\n+            return getGlobalSession(globalTransactionDO, branchTransactionDOs);\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid) {\n+        return this.readSession(xid, true);\n+    }\n+\n+    /**\n+     * Read session list.\n+     *\n+     * @param statuses\n+     *            the statuses\n+     * @return the list\n+     */\n+    public List<GlobalSession> readSession(GlobalStatus[] statuses) {\n+        List<Integer> states = new ArrayList<>();\n+        for (int i = 0; i < statuses.length; i++) {\n+            states.add(statuses[i].getCode());\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Set<String> keys = new HashSet<>();\n+            String cursor = INITIAL_CURSOR;\n+            ScanParams params = new ScanParams();\n+            params.count(logQueryLimit);\n+            params.match(getGlobalKeyByXid(\"*\"));\n+            ScanResult<String> scans;\n+            do {\n+                scans = jedis.scan(cursor, params);\n+                keys.addAll(scans.getResult().stream().collect(Collectors.toSet()));\n+                cursor = scans.getCursor();\n+            } while (!INITIAL_CURSOR.equals(cursor));\n+            if (CollectionUtils.isNotEmpty(keys)) {\n+                List<GlobalTransactionDO> globalTransactionDOs = new ArrayList<>();\n+                for (String globalKey : keys) {\n+                    GlobalTransactionDO globalTransactionDO =\n+                        JSON.parseObject(jedis.get(globalKey), GlobalTransactionDO.class);\n+                    if (null != globalTransactionDO && states.contains(globalTransactionDO.getStatus())) {\n+                        globalTransactionDOs.add(globalTransactionDO);\n+                    }\n+                }\n+                if (CollectionUtils.isNotEmpty(globalTransactionDOs)) {\n+                    List<String> xids =\n+                        globalTransactionDOs.stream().map(GlobalTransactionDO::getXid).collect(Collectors.toList());\n+                    List<BranchTransactionDO> branchTransactionDOs = new ArrayList<>();\n+                    for (String xid : xids) {\n+                        Set<String> branches = lRange(jedis, getBranchListKeyByXid(xid));\n+                        if (CollectionUtils.isNotEmpty(branches)) {\n+                            for (String branchKey : branches) {\n+                                String branchJson = jedis.get(branchKey);\n+                                if (StringUtils.isNotBlank(branchJson)) {\n+                                    branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                                }\n+                            }\n+                        }\n+                    }\n+                    Map<String, List<BranchTransactionDO>> branchTransactionDOsMap =\n+                        branchTransactionDOs.stream().collect(Collectors.groupingBy(BranchTransactionDO::getXid,\n+                            LinkedHashMap::new, Collectors.toList()));\n+                    return globalTransactionDOs.stream()\n+                        .map(globalTransactionDO -> getGlobalSession(globalTransactionDO,\n+                            branchTransactionDOsMap.get(globalTransactionDO.getXid())))\n+                        .collect(Collectors.toList());\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public List<GlobalSession> readSession(SessionCondition sessionCondition) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            if (StringUtils.isNotBlank(sessionCondition.getXid())) {\n+                globalSessionJson = jedis.get(getGlobalKeyByXid(sessionCondition.getXid()));\n+                if (StringUtils.isNotBlank(globalSessionJson)) {\n+                    GlobalSession session =\n+                        convertGlobalSession(JSON.parseObject(globalSessionJson, GlobalTransactionDO.class));\n+                    List<GlobalSession> globalSessions = new ArrayList<>();\n+                    globalSessions.add(session);\n+                    return globalSessions;\n+                }\n+            } else if (sessionCondition.getTransactionId() != null) {\n+                String global = jedis.get(getGlobalKeyByTransactionId(sessionCondition.getTransactionId()));\n+                if (StringUtils.isBlank(global)) {\n+                    return null;\n+                }\n+                GlobalTransactionDO globalTransactionDO = JSON.parseObject(global, GlobalTransactionDO.class);\n+                String branchKey = getBranchListKeyByXid(globalTransactionDO.getXid());\n+                Set<String> keys = lRange(jedis, branchKey);\n+                List<BranchTransactionDO> branchTransactionDOs = new ArrayList<>();\n+                if (CollectionUtils.isNotEmpty(keys)) {\n+                    for (String s : keys) {\n+                        String branchJson = jedis.get(s);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 295}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg0MTY0NA==", "bodyText": "Put the above six lines of code to the next level", "url": "https://github.com/seata/seata/pull/2484#discussion_r432841644", "createdAt": "2020-05-30T13:25:25Z", "author": {"login": "ph3636"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import com.alibaba.fastjson.JSON;\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String INITIAL_CURSOR = \"0\";\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    public RedisTransactionStoreManager() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            jedis.del(key);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            Pipeline pipeline = jedis.pipelined();\n+            if (jedis.get(key) == null) {\n+                pipeline.lpush(getBranchListKeyByXid(branchTransactionDO.getXid()), key);\n+            }\n+            pipeline.set(key, JSON.toJSONString(branchTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<String> keys = new ArrayList<>();\n+            keys.add(getGlobalKeyByXid(globalTransactionDO.getXid()));\n+            keys.add(getGlobalKeyByTransactionId(globalTransactionDO.getTransactionId()));\n+            keys.add(getBranchListKeyByXid(globalTransactionDO.getXid()));\n+            jedis.del(keys.toArray(new String[keys.size()]));\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String keys = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n+            Pipeline pipeline = jedis.pipelined();\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            keys = getGlobalKeyByTransactionId(convertGlobalTransactionDO.getTransactionId());\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @param withBranchSessions\n+     *            the withBranchSessions\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid, boolean withBranchSessions) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            globalSessionJson = jedis.get(getGlobalKeyByXid(xid));\n+            if (StringUtils.isBlank(globalSessionJson)) {\n+                return null;\n+            }\n+            // global transaction\n+            GlobalTransactionDO globalTransactionDO = JSON.parseObject(globalSessionJson, GlobalTransactionDO.class);\n+            if (globalTransactionDO == null) {\n+                return null;\n+            }\n+            // branch transactions\n+            List<BranchTransactionDO> branchTransactionDOs = null;\n+            // reduce rpc with db when branchRegister and getGlobalStatus\n+            if (withBranchSessions) {\n+                Set<String> keys = lRange(jedis, getBranchListKeyByXid(globalTransactionDO.getXid()));\n+                if (CollectionUtils.isNotEmpty(keys)) {\n+                    branchTransactionDOs = new ArrayList<>();\n+                    for (String s : keys) {\n+                        String branchJson = jedis.get(s);\n+                        if (StringUtils.isNotBlank(branchJson)) {\n+                            branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                        }\n+                    }\n+                }\n+            }\n+            return getGlobalSession(globalTransactionDO, branchTransactionDOs);\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid) {\n+        return this.readSession(xid, true);\n+    }\n+\n+    /**\n+     * Read session list.\n+     *\n+     * @param statuses\n+     *            the statuses\n+     * @return the list\n+     */\n+    public List<GlobalSession> readSession(GlobalStatus[] statuses) {\n+        List<Integer> states = new ArrayList<>();\n+        for (int i = 0; i < statuses.length; i++) {\n+            states.add(statuses[i].getCode());\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Set<String> keys = new HashSet<>();\n+            String cursor = INITIAL_CURSOR;\n+            ScanParams params = new ScanParams();\n+            params.count(logQueryLimit);\n+            params.match(getGlobalKeyByXid(\"*\"));\n+            ScanResult<String> scans;\n+            do {\n+                scans = jedis.scan(cursor, params);\n+                keys.addAll(scans.getResult().stream().collect(Collectors.toSet()));\n+                cursor = scans.getCursor();\n+            } while (!INITIAL_CURSOR.equals(cursor));\n+            if (CollectionUtils.isNotEmpty(keys)) {\n+                List<GlobalTransactionDO> globalTransactionDOs = new ArrayList<>();\n+                for (String globalKey : keys) {\n+                    GlobalTransactionDO globalTransactionDO =\n+                        JSON.parseObject(jedis.get(globalKey), GlobalTransactionDO.class);\n+                    if (null != globalTransactionDO && states.contains(globalTransactionDO.getStatus())) {\n+                        globalTransactionDOs.add(globalTransactionDO);\n+                    }\n+                }\n+                if (CollectionUtils.isNotEmpty(globalTransactionDOs)) {\n+                    List<String> xids =\n+                        globalTransactionDOs.stream().map(GlobalTransactionDO::getXid).collect(Collectors.toList());\n+                    List<BranchTransactionDO> branchTransactionDOs = new ArrayList<>();\n+                    for (String xid : xids) {\n+                        Set<String> branches = lRange(jedis, getBranchListKeyByXid(xid));\n+                        if (CollectionUtils.isNotEmpty(branches)) {\n+                            for (String branchKey : branches) {\n+                                String branchJson = jedis.get(branchKey);\n+                                if (StringUtils.isNotBlank(branchJson)) {\n+                                    branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                                }\n+                            }\n+                        }\n+                    }\n+                    Map<String, List<BranchTransactionDO>> branchTransactionDOsMap =\n+                        branchTransactionDOs.stream().collect(Collectors.groupingBy(BranchTransactionDO::getXid,\n+                            LinkedHashMap::new, Collectors.toList()));\n+                    return globalTransactionDOs.stream()\n+                        .map(globalTransactionDO -> getGlobalSession(globalTransactionDO,\n+                            branchTransactionDOsMap.get(globalTransactionDO.getXid())))\n+                        .collect(Collectors.toList());\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public List<GlobalSession> readSession(SessionCondition sessionCondition) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            if (StringUtils.isNotBlank(sessionCondition.getXid())) {\n+                globalSessionJson = jedis.get(getGlobalKeyByXid(sessionCondition.getXid()));\n+                if (StringUtils.isNotBlank(globalSessionJson)) {\n+                    GlobalSession session =\n+                        convertGlobalSession(JSON.parseObject(globalSessionJson, GlobalTransactionDO.class));\n+                    List<GlobalSession> globalSessions = new ArrayList<>();\n+                    globalSessions.add(session);\n+                    return globalSessions;\n+                }\n+            } else if (sessionCondition.getTransactionId() != null) {\n+                String global = jedis.get(getGlobalKeyByTransactionId(sessionCondition.getTransactionId()));\n+                if (StringUtils.isBlank(global)) {\n+                    return null;\n+                }\n+                GlobalTransactionDO globalTransactionDO = JSON.parseObject(global, GlobalTransactionDO.class);\n+                String branchKey = getBranchListKeyByXid(globalTransactionDO.getXid());\n+                Set<String> keys = lRange(jedis, branchKey);\n+                List<BranchTransactionDO> branchTransactionDOs = new ArrayList<>();\n+                if (CollectionUtils.isNotEmpty(keys)) {\n+                    for (String s : keys) {\n+                        String branchJson = jedis.get(s);\n+                        if (StringUtils.isNotBlank(branchJson)) {\n+                            branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                        }\n+                    }\n+                    GlobalSession globalSession = getGlobalSession(globalTransactionDO, branchTransactionDOs);\n+                    if (globalSession != null) {\n+                        List<GlobalSession> globalSessions = new ArrayList<>();\n+                        globalSessions.add(globalSession);\n+                        return globalSessions;\n+                    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 305}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg0MjAxNQ==", "bodyText": "keys.addAll(scans.getResult());", "url": "https://github.com/seata/seata/pull/2484#discussion_r432842015", "createdAt": "2020-05-30T13:31:29Z", "author": {"login": "ph3636"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import com.alibaba.fastjson.JSON;\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String INITIAL_CURSOR = \"0\";\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    public RedisTransactionStoreManager() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            jedis.del(key);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            Pipeline pipeline = jedis.pipelined();\n+            if (jedis.get(key) == null) {\n+                pipeline.lpush(getBranchListKeyByXid(branchTransactionDO.getXid()), key);\n+            }\n+            pipeline.set(key, JSON.toJSONString(branchTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<String> keys = new ArrayList<>();\n+            keys.add(getGlobalKeyByXid(globalTransactionDO.getXid()));\n+            keys.add(getGlobalKeyByTransactionId(globalTransactionDO.getTransactionId()));\n+            keys.add(getBranchListKeyByXid(globalTransactionDO.getXid()));\n+            jedis.del(keys.toArray(new String[keys.size()]));\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String keys = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n+            Pipeline pipeline = jedis.pipelined();\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            keys = getGlobalKeyByTransactionId(convertGlobalTransactionDO.getTransactionId());\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @param withBranchSessions\n+     *            the withBranchSessions\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid, boolean withBranchSessions) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            globalSessionJson = jedis.get(getGlobalKeyByXid(xid));\n+            if (StringUtils.isBlank(globalSessionJson)) {\n+                return null;\n+            }\n+            // global transaction\n+            GlobalTransactionDO globalTransactionDO = JSON.parseObject(globalSessionJson, GlobalTransactionDO.class);\n+            if (globalTransactionDO == null) {\n+                return null;\n+            }\n+            // branch transactions\n+            List<BranchTransactionDO> branchTransactionDOs = null;\n+            // reduce rpc with db when branchRegister and getGlobalStatus\n+            if (withBranchSessions) {\n+                Set<String> keys = lRange(jedis, getBranchListKeyByXid(globalTransactionDO.getXid()));\n+                if (CollectionUtils.isNotEmpty(keys)) {\n+                    branchTransactionDOs = new ArrayList<>();\n+                    for (String s : keys) {\n+                        String branchJson = jedis.get(s);\n+                        if (StringUtils.isNotBlank(branchJson)) {\n+                            branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                        }\n+                    }\n+                }\n+            }\n+            return getGlobalSession(globalTransactionDO, branchTransactionDOs);\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid) {\n+        return this.readSession(xid, true);\n+    }\n+\n+    /**\n+     * Read session list.\n+     *\n+     * @param statuses\n+     *            the statuses\n+     * @return the list\n+     */\n+    public List<GlobalSession> readSession(GlobalStatus[] statuses) {\n+        List<Integer> states = new ArrayList<>();\n+        for (int i = 0; i < statuses.length; i++) {\n+            states.add(statuses[i].getCode());\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Set<String> keys = new HashSet<>();\n+            String cursor = INITIAL_CURSOR;\n+            ScanParams params = new ScanParams();\n+            params.count(logQueryLimit);\n+            params.match(getGlobalKeyByXid(\"*\"));\n+            ScanResult<String> scans;\n+            do {\n+                scans = jedis.scan(cursor, params);\n+                keys.addAll(scans.getResult().stream().collect(Collectors.toSet()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 231}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg0MjI4OQ==", "bodyText": "Judge whether it is empty", "url": "https://github.com/seata/seata/pull/2484#discussion_r432842289", "createdAt": "2020-05-30T13:36:44Z", "author": {"login": "ph3636"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import com.alibaba.fastjson.JSON;\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String INITIAL_CURSOR = \"0\";\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    public RedisTransactionStoreManager() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            jedis.del(key);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            Pipeline pipeline = jedis.pipelined();\n+            if (jedis.get(key) == null) {\n+                pipeline.lpush(getBranchListKeyByXid(branchTransactionDO.getXid()), key);\n+            }\n+            pipeline.set(key, JSON.toJSONString(branchTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<String> keys = new ArrayList<>();\n+            keys.add(getGlobalKeyByXid(globalTransactionDO.getXid()));\n+            keys.add(getGlobalKeyByTransactionId(globalTransactionDO.getTransactionId()));\n+            keys.add(getBranchListKeyByXid(globalTransactionDO.getXid()));\n+            jedis.del(keys.toArray(new String[keys.size()]));\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String keys = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n+            Pipeline pipeline = jedis.pipelined();\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            keys = getGlobalKeyByTransactionId(convertGlobalTransactionDO.getTransactionId());\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @param withBranchSessions\n+     *            the withBranchSessions\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid, boolean withBranchSessions) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            globalSessionJson = jedis.get(getGlobalKeyByXid(xid));\n+            if (StringUtils.isBlank(globalSessionJson)) {\n+                return null;\n+            }\n+            // global transaction\n+            GlobalTransactionDO globalTransactionDO = JSON.parseObject(globalSessionJson, GlobalTransactionDO.class);\n+            if (globalTransactionDO == null) {\n+                return null;\n+            }\n+            // branch transactions\n+            List<BranchTransactionDO> branchTransactionDOs = null;\n+            // reduce rpc with db when branchRegister and getGlobalStatus\n+            if (withBranchSessions) {\n+                Set<String> keys = lRange(jedis, getBranchListKeyByXid(globalTransactionDO.getXid()));\n+                if (CollectionUtils.isNotEmpty(keys)) {\n+                    branchTransactionDOs = new ArrayList<>();\n+                    for (String s : keys) {\n+                        String branchJson = jedis.get(s);\n+                        if (StringUtils.isNotBlank(branchJson)) {\n+                            branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                        }\n+                    }\n+                }\n+            }\n+            return getGlobalSession(globalTransactionDO, branchTransactionDOs);\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid) {\n+        return this.readSession(xid, true);\n+    }\n+\n+    /**\n+     * Read session list.\n+     *\n+     * @param statuses\n+     *            the statuses\n+     * @return the list\n+     */\n+    public List<GlobalSession> readSession(GlobalStatus[] statuses) {\n+        List<Integer> states = new ArrayList<>();\n+        for (int i = 0; i < statuses.length; i++) {\n+            states.add(statuses[i].getCode());\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Set<String> keys = new HashSet<>();\n+            String cursor = INITIAL_CURSOR;\n+            ScanParams params = new ScanParams();\n+            params.count(logQueryLimit);\n+            params.match(getGlobalKeyByXid(\"*\"));\n+            ScanResult<String> scans;\n+            do {\n+                scans = jedis.scan(cursor, params);\n+                keys.addAll(scans.getResult().stream().collect(Collectors.toSet()));\n+                cursor = scans.getCursor();\n+            } while (!INITIAL_CURSOR.equals(cursor));\n+            if (CollectionUtils.isNotEmpty(keys)) {\n+                List<GlobalTransactionDO> globalTransactionDOs = new ArrayList<>();\n+                for (String globalKey : keys) {\n+                    GlobalTransactionDO globalTransactionDO =\n+                        JSON.parseObject(jedis.get(globalKey), GlobalTransactionDO.class);\n+                    if (null != globalTransactionDO && states.contains(globalTransactionDO.getStatus())) {\n+                        globalTransactionDOs.add(globalTransactionDO);\n+                    }\n+                }\n+                if (CollectionUtils.isNotEmpty(globalTransactionDOs)) {\n+                    List<String> xids =\n+                        globalTransactionDOs.stream().map(GlobalTransactionDO::getXid).collect(Collectors.toList());\n+                    List<BranchTransactionDO> branchTransactionDOs = new ArrayList<>();\n+                    for (String xid : xids) {\n+                        Set<String> branches = lRange(jedis, getBranchListKeyByXid(xid));\n+                        if (CollectionUtils.isNotEmpty(branches)) {\n+                            for (String branchKey : branches) {\n+                                String branchJson = jedis.get(branchKey);\n+                                if (StringUtils.isNotBlank(branchJson)) {\n+                                    branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 253}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg0MzIyMA==", "bodyText": "This method can be deleted", "url": "https://github.com/seata/seata/pull/2484#discussion_r432843220", "createdAt": "2020-05-30T13:51:34Z", "author": {"login": "ph3636"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.lock;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.LambdaUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.lock.AbstractLocker;\n+import io.seata.core.lock.RowLock;\n+import io.seata.core.store.LockDO;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.Transaction;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisLocker extends AbstractLocker {\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_PREFIX = \"SEATA_LOCK_\";\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX = \"SEATA_LOCK_XID_\";\n+\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    /**\n+     * Instantiates a new Redis locker.\n+     *\n+     */\n+    public RedisLocker() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    @Override\n+    public boolean acquireLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        Set<String> successList = new HashSet<>();\n+        long status = 1;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<LockDO> locks = convertToLockDO(rowLocks);\n+            if (locks.size() > 1) {\n+                locks =\n+                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            }\n+            Pipeline pipeline = jedis.pipelined();\n+            List<String> readyKeys = new ArrayList<>();\n+            for (LockDO lock : locks) {\n+                String key = getLockKey(lock.getRowKey());\n+                pipeline.setnx(key, JSON.toJSONString(lock));\n+                readyKeys.add(key);\n+            }\n+            List<Object> results = pipeline.syncAndReturnAll();\n+            for (int i = 0; i < results.size(); i++) {\n+                Long result = (long)results.get(i);\n+                String key = readyKeys.get(i);\n+                if (result != 1) {\n+                    status = result;\n+                } else {\n+                    successList.add(key);\n+                }\n+            }\n+            if (status != 1) {\n+                String[] rms = successList.toArray(new String[successList.size()]);\n+                if (rms.length > 0) {\n+                    jedis.del(rms);\n+                }\n+                return false;\n+            } else {\n+                Transaction multi = jedis.multi();\n+                try {\n+                    for (LockDO lock : locks) {\n+                        String xidLockKey = getXidLockKey(lock.getXid());\n+                        String key = getLockKey(lock.getRowKey());\n+                        multi.lpush(xidLockKey, key);\n+                    }\n+                } catch (Exception e) {\n+                    multi.discard();\n+                    return false;\n+                }\n+                multi.exec();\n+                return true;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        String[] keys = new String[rowLocks.size()];\n+        List<LockDO> locks = convertToLockDO(rowLocks);\n+        for (int i = 0; i < locks.size(); i++) {\n+            String key = getLockKey(locks.get(i).getRowKey());\n+            keys[i] = key;\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            jedis.del(keys);\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(String xid, List<Long> branchIds) {\n+        if (CollectionUtils.isEmpty(branchIds)) {\n+            // no lock\n+            return true;\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String lockListKey = getXidLockKey(xid);\n+            Set<String> keys = lRange(jedis, lockListKey);\n+            if (CollectionUtils.isNotEmpty(keys)) {\n+                Iterator<String> it = keys.iterator();\n+                while (it.hasNext()) {\n+                    String key = it.next();\n+                    LockDO lock = JSON.parseObject(jedis.get(key), LockDO.class);\n+                    for (int i = 0; i < branchIds.size(); i++) {\n+                        if (null != lock && Objects.equals(lock.getBranchId(), branchIds.get(i))) {\n+                            jedis.del(key);\n+                            jedis.lrem(lockListKey, 0, key);\n+                            it.remove();\n+                        }\n+                    }\n+                }\n+                if (keys.size() == 0) {\n+                    jedis.del(lockListKey);\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(String xid, Long branchId) {\n+        List<Long> branchIds = new ArrayList<>();\n+        branchIds.add(branchId);\n+        return releaseLock(xid, branchIds);\n+    }\n+\n+    @Override\n+    public boolean isLockable(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<LockDO> locks = convertToLockDO(rowLocks);\n+            for (LockDO rowlock : locks) {\n+                String rowlockJson = jedis.get(getLockKey(rowlock.getRowKey()));\n+                if (StringUtils.isNotBlank(rowlockJson)) {\n+                    LockDO lock = JSON.parseObject(rowlockJson, LockDO.class);\n+                    if (null != lock && !Objects.equals(lock.getXid(), rowlock.getXid())) {\n+                        return false;\n+                    }\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Convert to lock do list.\n+     *\n+     * @param locks\n+     *            the locks\n+     * @return the list\n+     */\n+    protected List<LockDO> convertToLockDO(List<RowLock> locks) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 204}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg0NDg5OA==", "bodyText": "change to [ String xidLockKey = getXidLockKey(locks.get(0).getXid());\nmulti.lpush(xidLockKey, readyKeys.toArray(new String[0]));]", "url": "https://github.com/seata/seata/pull/2484#discussion_r432844898", "createdAt": "2020-05-30T14:15:30Z", "author": {"login": "ph3636"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.lock;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.LambdaUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.lock.AbstractLocker;\n+import io.seata.core.lock.RowLock;\n+import io.seata.core.store.LockDO;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.Transaction;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisLocker extends AbstractLocker {\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_PREFIX = \"SEATA_LOCK_\";\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX = \"SEATA_LOCK_XID_\";\n+\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    /**\n+     * Instantiates a new Redis locker.\n+     *\n+     */\n+    public RedisLocker() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    @Override\n+    public boolean acquireLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        Set<String> successList = new HashSet<>();\n+        long status = 1;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<LockDO> locks = convertToLockDO(rowLocks);\n+            if (locks.size() > 1) {\n+                locks =\n+                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            }\n+            Pipeline pipeline = jedis.pipelined();\n+            List<String> readyKeys = new ArrayList<>();\n+            for (LockDO lock : locks) {\n+                String key = getLockKey(lock.getRowKey());\n+                pipeline.setnx(key, JSON.toJSONString(lock));\n+                readyKeys.add(key);\n+            }\n+            List<Object> results = pipeline.syncAndReturnAll();\n+            for (int i = 0; i < results.size(); i++) {\n+                Long result = (long)results.get(i);\n+                String key = readyKeys.get(i);\n+                if (result != 1) {\n+                    status = result;\n+                } else {\n+                    successList.add(key);\n+                }\n+            }\n+            if (status != 1) {\n+                String[] rms = successList.toArray(new String[successList.size()]);\n+                if (rms.length > 0) {\n+                    jedis.del(rms);\n+                }\n+                return false;\n+            } else {\n+                Transaction multi = jedis.multi();\n+                try {\n+                    for (LockDO lock : locks) {\n+                        String xidLockKey = getXidLockKey(lock.getXid());\n+                        String key = getLockKey(lock.getRowKey());\n+                        multi.lpush(xidLockKey, key);\n+                    }\n+                } catch (Exception e) {\n+                    multi.discard();\n+                    return false;\n+                }\n+                multi.exec();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg2NzAxMA==", "bodyText": "change to [Pipeline pipeline = jedis.pipelined();\npipeline.lrem(getBranchListKeyByXid(branchTransactionDO.getXid()), 0, key);\npipeline.del(key);\npipeline.sync();]", "url": "https://github.com/seata/seata/pull/2484#discussion_r432867010", "createdAt": "2020-05-30T16:13:33Z", "author": {"login": "ph3636"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import com.alibaba.fastjson.JSON;\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String INITIAL_CURSOR = \"0\";\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    public RedisTransactionStoreManager() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            jedis.del(key);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg2NzYwOQ==", "bodyText": "change to [String xidLockKey = getXidLockKey(locks.get(0).getXid());\nPipeline pipeline = jedis.pipelined();\npipeline.del(keys);\nArrays.stream(keys).forEach(key -> pipeline.lrem(xidLockKey, 0, key));\npipeline.exec();]", "url": "https://github.com/seata/seata/pull/2484#discussion_r432867609", "createdAt": "2020-05-30T16:22:28Z", "author": {"login": "ph3636"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.lock;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.LambdaUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.lock.AbstractLocker;\n+import io.seata.core.lock.RowLock;\n+import io.seata.core.store.LockDO;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.Transaction;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisLocker extends AbstractLocker {\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_PREFIX = \"SEATA_LOCK_\";\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX = \"SEATA_LOCK_XID_\";\n+\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    /**\n+     * Instantiates a new Redis locker.\n+     *\n+     */\n+    public RedisLocker() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    @Override\n+    public boolean acquireLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        Set<String> successList = new HashSet<>();\n+        long status = 1;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<LockDO> locks = convertToLockDO(rowLocks);\n+            if (locks.size() > 1) {\n+                locks =\n+                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            }\n+            Pipeline pipeline = jedis.pipelined();\n+            List<String> readyKeys = new ArrayList<>();\n+            for (LockDO lock : locks) {\n+                String key = getLockKey(lock.getRowKey());\n+                pipeline.setnx(key, JSON.toJSONString(lock));\n+                readyKeys.add(key);\n+            }\n+            List<Object> results = pipeline.syncAndReturnAll();\n+            for (int i = 0; i < results.size(); i++) {\n+                Long result = (long)results.get(i);\n+                String key = readyKeys.get(i);\n+                if (result != 1) {\n+                    status = result;\n+                } else {\n+                    successList.add(key);\n+                }\n+            }\n+            if (status != 1) {\n+                String[] rms = successList.toArray(new String[successList.size()]);\n+                if (rms.length > 0) {\n+                    jedis.del(rms);\n+                }\n+                return false;\n+            } else {\n+                Transaction multi = jedis.multi();\n+                try {\n+                    for (LockDO lock : locks) {\n+                        String xidLockKey = getXidLockKey(lock.getXid());\n+                        String key = getLockKey(lock.getRowKey());\n+                        multi.lpush(xidLockKey, key);\n+                    }\n+                } catch (Exception e) {\n+                    multi.discard();\n+                    return false;\n+                }\n+                multi.exec();\n+                return true;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        String[] keys = new String[rowLocks.size()];\n+        List<LockDO> locks = convertToLockDO(rowLocks);\n+        for (int i = 0; i < locks.size(); i++) {\n+            String key = getLockKey(locks.get(i).getRowKey());\n+            keys[i] = key;\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            jedis.del(keys);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3MDkwNw==", "bodyText": "Change the following to [List list = jedis.mget(keys.toArray(new String[0]));\nif (CollectionUtils.isNotEmpty(list)) {\nPipeline pipeline = null;\nSet branchIdSet = new HashSet<>(branchIds);\nint i = 0;\nfor (String key : keys) {\nLockDO lock = JSON.parseObject(jedis.get(list.get(i)), LockDO.class);\nif (null != lock && branchIdSet.contains(lock.getBranchId())) {\nif (pipeline == null) {\npipeline = jedis.pipelined();\n}\njedis.del(key);\njedis.lrem(lockListKey, 0, key);\n}\ni++;\n}\nif (pipeline != null) {\npipeline.exec();\n}\n}]", "url": "https://github.com/seata/seata/pull/2484#discussion_r432870907", "createdAt": "2020-05-30T17:10:43Z", "author": {"login": "ph3636"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.lock;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.LambdaUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.lock.AbstractLocker;\n+import io.seata.core.lock.RowLock;\n+import io.seata.core.store.LockDO;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.Transaction;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisLocker extends AbstractLocker {\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_PREFIX = \"SEATA_LOCK_\";\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX = \"SEATA_LOCK_XID_\";\n+\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    /**\n+     * Instantiates a new Redis locker.\n+     *\n+     */\n+    public RedisLocker() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    @Override\n+    public boolean acquireLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        Set<String> successList = new HashSet<>();\n+        long status = 1;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<LockDO> locks = convertToLockDO(rowLocks);\n+            if (locks.size() > 1) {\n+                locks =\n+                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            }\n+            Pipeline pipeline = jedis.pipelined();\n+            List<String> readyKeys = new ArrayList<>();\n+            for (LockDO lock : locks) {\n+                String key = getLockKey(lock.getRowKey());\n+                pipeline.setnx(key, JSON.toJSONString(lock));\n+                readyKeys.add(key);\n+            }\n+            List<Object> results = pipeline.syncAndReturnAll();\n+            for (int i = 0; i < results.size(); i++) {\n+                Long result = (long)results.get(i);\n+                String key = readyKeys.get(i);\n+                if (result != 1) {\n+                    status = result;\n+                } else {\n+                    successList.add(key);\n+                }\n+            }\n+            if (status != 1) {\n+                String[] rms = successList.toArray(new String[successList.size()]);\n+                if (rms.length > 0) {\n+                    jedis.del(rms);\n+                }\n+                return false;\n+            } else {\n+                Transaction multi = jedis.multi();\n+                try {\n+                    for (LockDO lock : locks) {\n+                        String xidLockKey = getXidLockKey(lock.getXid());\n+                        String key = getLockKey(lock.getRowKey());\n+                        multi.lpush(xidLockKey, key);\n+                    }\n+                } catch (Exception e) {\n+                    multi.discard();\n+                    return false;\n+                }\n+                multi.exec();\n+                return true;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        String[] keys = new String[rowLocks.size()];\n+        List<LockDO> locks = convertToLockDO(rowLocks);\n+        for (int i = 0; i < locks.size(); i++) {\n+            String key = getLockKey(locks.get(i).getRowKey());\n+            keys[i] = key;\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            jedis.del(keys);\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(String xid, List<Long> branchIds) {\n+        if (CollectionUtils.isEmpty(branchIds)) {\n+            // no lock\n+            return true;\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String lockListKey = getXidLockKey(xid);\n+            Set<String> keys = lRange(jedis, lockListKey);\n+            if (CollectionUtils.isNotEmpty(keys)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3MTMzOQ==", "bodyText": "mget", "url": "https://github.com/seata/seata/pull/2484#discussion_r432871339", "createdAt": "2020-05-30T17:16:42Z", "author": {"login": "ph3636"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.lock;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.LambdaUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.lock.AbstractLocker;\n+import io.seata.core.lock.RowLock;\n+import io.seata.core.store.LockDO;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.Transaction;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisLocker extends AbstractLocker {\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_PREFIX = \"SEATA_LOCK_\";\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX = \"SEATA_LOCK_XID_\";\n+\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    /**\n+     * Instantiates a new Redis locker.\n+     *\n+     */\n+    public RedisLocker() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    @Override\n+    public boolean acquireLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        Set<String> successList = new HashSet<>();\n+        long status = 1;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<LockDO> locks = convertToLockDO(rowLocks);\n+            if (locks.size() > 1) {\n+                locks =\n+                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            }\n+            Pipeline pipeline = jedis.pipelined();\n+            List<String> readyKeys = new ArrayList<>();\n+            for (LockDO lock : locks) {\n+                String key = getLockKey(lock.getRowKey());\n+                pipeline.setnx(key, JSON.toJSONString(lock));\n+                readyKeys.add(key);\n+            }\n+            List<Object> results = pipeline.syncAndReturnAll();\n+            for (int i = 0; i < results.size(); i++) {\n+                Long result = (long)results.get(i);\n+                String key = readyKeys.get(i);\n+                if (result != 1) {\n+                    status = result;\n+                } else {\n+                    successList.add(key);\n+                }\n+            }\n+            if (status != 1) {\n+                String[] rms = successList.toArray(new String[successList.size()]);\n+                if (rms.length > 0) {\n+                    jedis.del(rms);\n+                }\n+                return false;\n+            } else {\n+                Transaction multi = jedis.multi();\n+                try {\n+                    for (LockDO lock : locks) {\n+                        String xidLockKey = getXidLockKey(lock.getXid());\n+                        String key = getLockKey(lock.getRowKey());\n+                        multi.lpush(xidLockKey, key);\n+                    }\n+                } catch (Exception e) {\n+                    multi.discard();\n+                    return false;\n+                }\n+                multi.exec();\n+                return true;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        String[] keys = new String[rowLocks.size()];\n+        List<LockDO> locks = convertToLockDO(rowLocks);\n+        for (int i = 0; i < locks.size(); i++) {\n+            String key = getLockKey(locks.get(i).getRowKey());\n+            keys[i] = key;\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            jedis.del(keys);\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(String xid, List<Long> branchIds) {\n+        if (CollectionUtils.isEmpty(branchIds)) {\n+            // no lock\n+            return true;\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String lockListKey = getXidLockKey(xid);\n+            Set<String> keys = lRange(jedis, lockListKey);\n+            if (CollectionUtils.isNotEmpty(keys)) {\n+                Iterator<String> it = keys.iterator();\n+                while (it.hasNext()) {\n+                    String key = it.next();\n+                    LockDO lock = JSON.parseObject(jedis.get(key), LockDO.class);\n+                    for (int i = 0; i < branchIds.size(); i++) {\n+                        if (null != lock && Objects.equals(lock.getBranchId(), branchIds.get(i))) {\n+                            jedis.del(key);\n+                            jedis.lrem(lockListKey, 0, key);\n+                            it.remove();\n+                        }\n+                    }\n+                }\n+                if (keys.size() == 0) {\n+                    jedis.del(lockListKey);\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(String xid, Long branchId) {\n+        List<Long> branchIds = new ArrayList<>();\n+        branchIds.add(branchId);\n+        return releaseLock(xid, branchIds);\n+    }\n+\n+    @Override\n+    public boolean isLockable(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<LockDO> locks = convertToLockDO(rowLocks);\n+            for (LockDO rowlock : locks) {\n+                String rowlockJson = jedis.get(getLockKey(rowlock.getRowKey()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 185}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxNDYyMDY0", "url": "https://github.com/seata/seata/pull/2484#pullrequestreview-421462064", "createdAt": "2020-05-31T05:09:45Z", "commit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMVQwNTowOTo0NlrOGc2wXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMVQwNToxNjozNlrOGc2xow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkxMDQzMQ==", "bodyText": "Set keys = new HashSet<>();", "url": "https://github.com/seata/seata/pull/2484#discussion_r432910431", "createdAt": "2020-05-31T05:09:46Z", "author": {"login": "ph3636"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import com.alibaba.fastjson.JSON;\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String INITIAL_CURSOR = \"0\";\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    public RedisTransactionStoreManager() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            jedis.del(key);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            Pipeline pipeline = jedis.pipelined();\n+            if (jedis.get(key) == null) {\n+                pipeline.lpush(getBranchListKeyByXid(branchTransactionDO.getXid()), key);\n+            }\n+            pipeline.set(key, JSON.toJSONString(branchTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<String> keys = new ArrayList<>();\n+            keys.add(getGlobalKeyByXid(globalTransactionDO.getXid()));\n+            keys.add(getGlobalKeyByTransactionId(globalTransactionDO.getTransactionId()));\n+            keys.add(getBranchListKeyByXid(globalTransactionDO.getXid()));\n+            jedis.del(keys.toArray(new String[keys.size()]));\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String keys = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n+            Pipeline pipeline = jedis.pipelined();\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            keys = getGlobalKeyByTransactionId(convertGlobalTransactionDO.getTransactionId());\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @param withBranchSessions\n+     *            the withBranchSessions\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid, boolean withBranchSessions) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            globalSessionJson = jedis.get(getGlobalKeyByXid(xid));\n+            if (StringUtils.isBlank(globalSessionJson)) {\n+                return null;\n+            }\n+            // global transaction\n+            GlobalTransactionDO globalTransactionDO = JSON.parseObject(globalSessionJson, GlobalTransactionDO.class);\n+            if (globalTransactionDO == null) {\n+                return null;\n+            }\n+            // branch transactions\n+            List<BranchTransactionDO> branchTransactionDOs = null;\n+            // reduce rpc with db when branchRegister and getGlobalStatus\n+            if (withBranchSessions) {\n+                Set<String> keys = lRange(jedis, getBranchListKeyByXid(globalTransactionDO.getXid()));\n+                if (CollectionUtils.isNotEmpty(keys)) {\n+                    branchTransactionDOs = new ArrayList<>();\n+                    for (String s : keys) {\n+                        String branchJson = jedis.get(s);\n+                        if (StringUtils.isNotBlank(branchJson)) {\n+                            branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                        }\n+                    }\n+                }\n+            }\n+            return getGlobalSession(globalTransactionDO, branchTransactionDOs);\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid) {\n+        return this.readSession(xid, true);\n+    }\n+\n+    /**\n+     * Read session list.\n+     *\n+     * @param statuses\n+     *            the statuses\n+     * @return the list\n+     */\n+    public List<GlobalSession> readSession(GlobalStatus[] statuses) {\n+        List<Integer> states = new ArrayList<>();\n+        for (int i = 0; i < statuses.length; i++) {\n+            states.add(statuses[i].getCode());\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Set<String> keys = new HashSet<>();\n+            String cursor = INITIAL_CURSOR;\n+            ScanParams params = new ScanParams();\n+            params.count(logQueryLimit);\n+            params.match(getGlobalKeyByXid(\"*\"));\n+            ScanResult<String> scans;\n+            do {\n+                scans = jedis.scan(cursor, params);\n+                keys.addAll(scans.getResult().stream().collect(Collectors.toSet()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg0MjAxNQ=="}, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 231}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkxMDYzMQ==", "bodyText": "This object has been converted to JSON twice", "url": "https://github.com/seata/seata/pull/2484#discussion_r432910631", "createdAt": "2020-05-31T05:13:49Z", "author": {"login": "ph3636"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import com.alibaba.fastjson.JSON;\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String INITIAL_CURSOR = \"0\";\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    public RedisTransactionStoreManager() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            jedis.del(key);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            Pipeline pipeline = jedis.pipelined();\n+            if (jedis.get(key) == null) {\n+                pipeline.lpush(getBranchListKeyByXid(branchTransactionDO.getXid()), key);\n+            }\n+            pipeline.set(key, JSON.toJSONString(branchTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<String> keys = new ArrayList<>();\n+            keys.add(getGlobalKeyByXid(globalTransactionDO.getXid()));\n+            keys.add(getGlobalKeyByTransactionId(globalTransactionDO.getTransactionId()));\n+            keys.add(getBranchListKeyByXid(globalTransactionDO.getXid()));\n+            jedis.del(keys.toArray(new String[keys.size()]));\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String keys = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n+            Pipeline pipeline = jedis.pipelined();\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg0MDI3MQ=="}, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkxMDc1NQ==", "bodyText": "The intermediate process may be inconsistent because deleting a branch does not necessarily delete the transaction immediately", "url": "https://github.com/seata/seata/pull/2484#discussion_r432910755", "createdAt": "2020-05-31T05:16:36Z", "author": {"login": "ph3636"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import com.alibaba.fastjson.JSON;\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String INITIAL_CURSOR = \"0\";\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    public RedisTransactionStoreManager() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            jedis.del(key);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg2NzAxMA=="}, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 116}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5eb16715176f961163631e06c1dc0bb1d4c0dfdb", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/5eb16715176f961163631e06c1dc0bb1d4c0dfdb", "committedDate": "2020-05-31T10:48:05Z", "message": "optimized code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d22ce2ff2675d57c5883d57a6da6f6cf1883299c", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/d22ce2ff2675d57c5883d57a6da6f6cf1883299c", "committedDate": "2020-05-31T11:04:25Z", "message": "optimized code"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxNDg4MTUy", "url": "https://github.com/seata/seata/pull/2484#pullrequestreview-421488152", "createdAt": "2020-05-31T12:07:32Z", "commit": {"oid": "d22ce2ff2675d57c5883d57a6da6f6cf1883299c"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMVQxMjowNzozMlrOGc4lAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMVQxMjozODozNVrOGc4vHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk0MDI4OA==", "bodyText": "Transaction unnecessary", "url": "https://github.com/seata/seata/pull/2484#discussion_r432940288", "createdAt": "2020-05-31T12:07:32Z", "author": {"login": "ph3636"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.lock;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.LambdaUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.lock.AbstractLocker;\n+import io.seata.core.lock.RowLock;\n+import io.seata.core.store.LockDO;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.Transaction;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisLocker extends AbstractLocker {\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_PREFIX = \"SEATA_LOCK_\";\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX = \"SEATA_LOCK_XID_\";\n+\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    /**\n+     * Instantiates a new Redis locker.\n+     *\n+     */\n+    public RedisLocker() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    @Override\n+    public boolean acquireLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        Set<String> successList = new HashSet<>();\n+        long status = 1;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<LockDO> locks = convertToLockDO(rowLocks);\n+            if (locks.size() > 1) {\n+                locks =\n+                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            }\n+            Pipeline pipeline = jedis.pipelined();\n+            List<String> readyKeys = new ArrayList<>();\n+            for (LockDO lock : locks) {\n+                String key = getLockKey(lock.getRowKey());\n+                pipeline.setnx(key, JSON.toJSONString(lock));\n+                readyKeys.add(key);\n+            }\n+            List<Object> results = pipeline.syncAndReturnAll();\n+            for (int i = 0; i < results.size(); i++) {\n+                Long result = (long)results.get(i);\n+                String key = readyKeys.get(i);\n+                if (result != 1) {\n+                    status = result;\n+                } else {\n+                    successList.add(key);\n+                }\n+            }\n+            if (status != 1) {\n+                String[] rms = successList.toArray(new String[successList.size()]);\n+                if (rms.length > 0) {\n+                    jedis.del(rms);\n+                }\n+                return false;\n+            } else {\n+                Transaction multi = jedis.multi();\n+                try {\n+                    for (LockDO lock : locks) {\n+                        String xidLockKey = getXidLockKey(lock.getXid());\n+                        String key = getLockKey(lock.getRowKey());\n+                        multi.lpush(xidLockKey, key);\n+                    }\n+                } catch (Exception e) {\n+                    multi.discard();\n+                    return false;\n+                }\n+                multi.exec();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg0NDg5OA=="}, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk0MjY3OA==", "bodyText": "this", "url": "https://github.com/seata/seata/pull/2484#discussion_r432942678", "createdAt": "2020-05-31T12:36:03Z", "author": {"login": "ph3636"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import com.alibaba.fastjson.JSON;\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String INITIAL_CURSOR = \"0\";\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    public RedisTransactionStoreManager() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            jedis.del(key);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            Pipeline pipeline = jedis.pipelined();\n+            if (jedis.get(key) == null) {\n+                pipeline.lpush(getBranchListKeyByXid(branchTransactionDO.getXid()), key);\n+            }\n+            pipeline.set(key, JSON.toJSONString(branchTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<String> keys = new ArrayList<>();\n+            keys.add(getGlobalKeyByXid(globalTransactionDO.getXid()));\n+            keys.add(getGlobalKeyByTransactionId(globalTransactionDO.getTransactionId()));\n+            keys.add(getBranchListKeyByXid(globalTransactionDO.getXid()));\n+            jedis.del(keys.toArray(new String[keys.size()]));\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String keys = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n+            Pipeline pipeline = jedis.pipelined();\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            keys = getGlobalKeyByTransactionId(convertGlobalTransactionDO.getTransactionId());\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @param withBranchSessions\n+     *            the withBranchSessions\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid, boolean withBranchSessions) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            globalSessionJson = jedis.get(getGlobalKeyByXid(xid));\n+            if (StringUtils.isBlank(globalSessionJson)) {\n+                return null;\n+            }\n+            // global transaction\n+            GlobalTransactionDO globalTransactionDO = JSON.parseObject(globalSessionJson, GlobalTransactionDO.class);\n+            if (globalTransactionDO == null) {\n+                return null;\n+            }\n+            // branch transactions\n+            List<BranchTransactionDO> branchTransactionDOs = null;\n+            // reduce rpc with db when branchRegister and getGlobalStatus\n+            if (withBranchSessions) {\n+                Set<String> keys = lRange(jedis, getBranchListKeyByXid(globalTransactionDO.getXid()));\n+                if (CollectionUtils.isNotEmpty(keys)) {\n+                    branchTransactionDOs = new ArrayList<>();\n+                    for (String s : keys) {\n+                        String branchJson = jedis.get(s);\n+                        if (StringUtils.isNotBlank(branchJson)) {\n+                            branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                        }\n+                    }\n+                }\n+            }\n+            return getGlobalSession(globalTransactionDO, branchTransactionDOs);\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid) {\n+        return this.readSession(xid, true);\n+    }\n+\n+    /**\n+     * Read session list.\n+     *\n+     * @param statuses\n+     *            the statuses\n+     * @return the list\n+     */\n+    public List<GlobalSession> readSession(GlobalStatus[] statuses) {\n+        List<Integer> states = new ArrayList<>();\n+        for (int i = 0; i < statuses.length; i++) {\n+            states.add(statuses[i].getCode());\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Set<String> keys = new HashSet<>();\n+            String cursor = INITIAL_CURSOR;\n+            ScanParams params = new ScanParams();\n+            params.count(logQueryLimit);\n+            params.match(getGlobalKeyByXid(\"*\"));\n+            ScanResult<String> scans;\n+            do {\n+                scans = jedis.scan(cursor, params);\n+                keys.addAll(scans.getResult().stream().collect(Collectors.toSet()));\n+                cursor = scans.getCursor();\n+            } while (!INITIAL_CURSOR.equals(cursor));\n+            if (CollectionUtils.isNotEmpty(keys)) {\n+                List<GlobalTransactionDO> globalTransactionDOs = new ArrayList<>();\n+                for (String globalKey : keys) {\n+                    GlobalTransactionDO globalTransactionDO =\n+                        JSON.parseObject(jedis.get(globalKey), GlobalTransactionDO.class);\n+                    if (null != globalTransactionDO && states.contains(globalTransactionDO.getStatus())) {\n+                        globalTransactionDOs.add(globalTransactionDO);\n+                    }\n+                }\n+                if (CollectionUtils.isNotEmpty(globalTransactionDOs)) {\n+                    List<String> xids =\n+                        globalTransactionDOs.stream().map(GlobalTransactionDO::getXid).collect(Collectors.toList());\n+                    List<BranchTransactionDO> branchTransactionDOs = new ArrayList<>();\n+                    for (String xid : xids) {\n+                        Set<String> branches = lRange(jedis, getBranchListKeyByXid(xid));\n+                        if (CollectionUtils.isNotEmpty(branches)) {\n+                            for (String branchKey : branches) {\n+                                String branchJson = jedis.get(branchKey);\n+                                if (StringUtils.isNotBlank(branchJson)) {\n+                                    branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                                }\n+                            }\n+                        }\n+                    }\n+                    Map<String, List<BranchTransactionDO>> branchTransactionDOsMap =\n+                        branchTransactionDOs.stream().collect(Collectors.groupingBy(BranchTransactionDO::getXid,\n+                            LinkedHashMap::new, Collectors.toList()));\n+                    return globalTransactionDOs.stream()\n+                        .map(globalTransactionDO -> getGlobalSession(globalTransactionDO,\n+                            branchTransactionDOsMap.get(globalTransactionDO.getXid())))\n+                        .collect(Collectors.toList());\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public List<GlobalSession> readSession(SessionCondition sessionCondition) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            if (StringUtils.isNotBlank(sessionCondition.getXid())) {\n+                globalSessionJson = jedis.get(getGlobalKeyByXid(sessionCondition.getXid()));\n+                if (StringUtils.isNotBlank(globalSessionJson)) {\n+                    GlobalSession session =\n+                        convertGlobalSession(JSON.parseObject(globalSessionJson, GlobalTransactionDO.class));\n+                    List<GlobalSession> globalSessions = new ArrayList<>();\n+                    globalSessions.add(session);\n+                    return globalSessions;\n+                }\n+            } else if (sessionCondition.getTransactionId() != null) {\n+                String global = jedis.get(getGlobalKeyByTransactionId(sessionCondition.getTransactionId()));\n+                if (StringUtils.isBlank(global)) {\n+                    return null;\n+                }\n+                GlobalTransactionDO globalTransactionDO = JSON.parseObject(global, GlobalTransactionDO.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg0MTM2OQ=="}, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 289}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk0MjY5Mg==", "bodyText": "this", "url": "https://github.com/seata/seata/pull/2484#discussion_r432942692", "createdAt": "2020-05-31T12:36:18Z", "author": {"login": "ph3636"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import com.alibaba.fastjson.JSON;\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String INITIAL_CURSOR = \"0\";\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    public RedisTransactionStoreManager() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            jedis.del(key);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            Pipeline pipeline = jedis.pipelined();\n+            if (jedis.get(key) == null) {\n+                pipeline.lpush(getBranchListKeyByXid(branchTransactionDO.getXid()), key);\n+            }\n+            pipeline.set(key, JSON.toJSONString(branchTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<String> keys = new ArrayList<>();\n+            keys.add(getGlobalKeyByXid(globalTransactionDO.getXid()));\n+            keys.add(getGlobalKeyByTransactionId(globalTransactionDO.getTransactionId()));\n+            keys.add(getBranchListKeyByXid(globalTransactionDO.getXid()));\n+            jedis.del(keys.toArray(new String[keys.size()]));\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String keys = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n+            Pipeline pipeline = jedis.pipelined();\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            keys = getGlobalKeyByTransactionId(convertGlobalTransactionDO.getTransactionId());\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @param withBranchSessions\n+     *            the withBranchSessions\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid, boolean withBranchSessions) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            globalSessionJson = jedis.get(getGlobalKeyByXid(xid));\n+            if (StringUtils.isBlank(globalSessionJson)) {\n+                return null;\n+            }\n+            // global transaction\n+            GlobalTransactionDO globalTransactionDO = JSON.parseObject(globalSessionJson, GlobalTransactionDO.class);\n+            if (globalTransactionDO == null) {\n+                return null;\n+            }\n+            // branch transactions\n+            List<BranchTransactionDO> branchTransactionDOs = null;\n+            // reduce rpc with db when branchRegister and getGlobalStatus\n+            if (withBranchSessions) {\n+                Set<String> keys = lRange(jedis, getBranchListKeyByXid(globalTransactionDO.getXid()));\n+                if (CollectionUtils.isNotEmpty(keys)) {\n+                    branchTransactionDOs = new ArrayList<>();\n+                    for (String s : keys) {\n+                        String branchJson = jedis.get(s);\n+                        if (StringUtils.isNotBlank(branchJson)) {\n+                            branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                        }\n+                    }\n+                }\n+            }\n+            return getGlobalSession(globalTransactionDO, branchTransactionDOs);\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid) {\n+        return this.readSession(xid, true);\n+    }\n+\n+    /**\n+     * Read session list.\n+     *\n+     * @param statuses\n+     *            the statuses\n+     * @return the list\n+     */\n+    public List<GlobalSession> readSession(GlobalStatus[] statuses) {\n+        List<Integer> states = new ArrayList<>();\n+        for (int i = 0; i < statuses.length; i++) {\n+            states.add(statuses[i].getCode());\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Set<String> keys = new HashSet<>();\n+            String cursor = INITIAL_CURSOR;\n+            ScanParams params = new ScanParams();\n+            params.count(logQueryLimit);\n+            params.match(getGlobalKeyByXid(\"*\"));\n+            ScanResult<String> scans;\n+            do {\n+                scans = jedis.scan(cursor, params);\n+                keys.addAll(scans.getResult().stream().collect(Collectors.toSet()));\n+                cursor = scans.getCursor();\n+            } while (!INITIAL_CURSOR.equals(cursor));\n+            if (CollectionUtils.isNotEmpty(keys)) {\n+                List<GlobalTransactionDO> globalTransactionDOs = new ArrayList<>();\n+                for (String globalKey : keys) {\n+                    GlobalTransactionDO globalTransactionDO =\n+                        JSON.parseObject(jedis.get(globalKey), GlobalTransactionDO.class);\n+                    if (null != globalTransactionDO && states.contains(globalTransactionDO.getStatus())) {\n+                        globalTransactionDOs.add(globalTransactionDO);\n+                    }\n+                }\n+                if (CollectionUtils.isNotEmpty(globalTransactionDOs)) {\n+                    List<String> xids =\n+                        globalTransactionDOs.stream().map(GlobalTransactionDO::getXid).collect(Collectors.toList());\n+                    List<BranchTransactionDO> branchTransactionDOs = new ArrayList<>();\n+                    for (String xid : xids) {\n+                        Set<String> branches = lRange(jedis, getBranchListKeyByXid(xid));\n+                        if (CollectionUtils.isNotEmpty(branches)) {\n+                            for (String branchKey : branches) {\n+                                String branchJson = jedis.get(branchKey);\n+                                if (StringUtils.isNotBlank(branchJson)) {\n+                                    branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                                }\n+                            }\n+                        }\n+                    }\n+                    Map<String, List<BranchTransactionDO>> branchTransactionDOsMap =\n+                        branchTransactionDOs.stream().collect(Collectors.groupingBy(BranchTransactionDO::getXid,\n+                            LinkedHashMap::new, Collectors.toList()));\n+                    return globalTransactionDOs.stream()\n+                        .map(globalTransactionDO -> getGlobalSession(globalTransactionDO,\n+                            branchTransactionDOsMap.get(globalTransactionDO.getXid())))\n+                        .collect(Collectors.toList());\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public List<GlobalSession> readSession(SessionCondition sessionCondition) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            if (StringUtils.isNotBlank(sessionCondition.getXid())) {\n+                globalSessionJson = jedis.get(getGlobalKeyByXid(sessionCondition.getXid()));\n+                if (StringUtils.isNotBlank(globalSessionJson)) {\n+                    GlobalSession session =\n+                        convertGlobalSession(JSON.parseObject(globalSessionJson, GlobalTransactionDO.class));\n+                    List<GlobalSession> globalSessions = new ArrayList<>();\n+                    globalSessions.add(session);\n+                    return globalSessions;\n+                }\n+            } else if (sessionCondition.getTransactionId() != null) {\n+                String global = jedis.get(getGlobalKeyByTransactionId(sessionCondition.getTransactionId()));\n+                if (StringUtils.isBlank(global)) {\n+                    return null;\n+                }\n+                GlobalTransactionDO globalTransactionDO = JSON.parseObject(global, GlobalTransactionDO.class);\n+                String branchKey = getBranchListKeyByXid(globalTransactionDO.getXid());\n+                Set<String> keys = lRange(jedis, branchKey);\n+                List<BranchTransactionDO> branchTransactionDOs = new ArrayList<>();\n+                if (CollectionUtils.isNotEmpty(keys)) {\n+                    for (String s : keys) {\n+                        String branchJson = jedis.get(s);\n+                        if (StringUtils.isNotBlank(branchJson)) {\n+                            branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                        }\n+                    }\n+                    GlobalSession globalSession = getGlobalSession(globalTransactionDO, branchTransactionDOs);\n+                    if (globalSession != null) {\n+                        List<GlobalSession> globalSessions = new ArrayList<>();\n+                        globalSessions.add(globalSession);\n+                        return globalSessions;\n+                    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg0MTY0NA=="}, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 305}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk0MjczOQ==", "bodyText": "The object converted by JSON needs to be judged to be empty", "url": "https://github.com/seata/seata/pull/2484#discussion_r432942739", "createdAt": "2020-05-31T12:37:07Z", "author": {"login": "ph3636"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,413 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import com.alibaba.fastjson.JSON;\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String INITIAL_CURSOR = \"0\";\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit =\n+        ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);;\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            jedis.del(key);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            Pipeline pipeline = jedis.pipelined();\n+            if (jedis.get(key) == null) {\n+                pipeline.lpush(getBranchListKeyByXid(branchTransactionDO.getXid()), key);\n+            }\n+            pipeline.set(key, JSON.toJSONString(branchTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String[] keys = new String[3];\n+            keys[0] = getGlobalKeyByXid(globalTransactionDO.getXid());\n+            keys[1] = getGlobalKeyByTransactionId(globalTransactionDO.getTransactionId());\n+            keys[2] = getBranchListKeyByXid(globalTransactionDO.getXid());\n+            jedis.del(keys);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String keys = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n+            Pipeline pipeline = jedis.pipelined();\n+            String json = JSON.toJSONString(convertGlobalTransactionDO);\n+            pipeline.set(keys, json);\n+            keys = getGlobalKeyByTransactionId(convertGlobalTransactionDO.getTransactionId());\n+            pipeline.set(keys, json);\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @param withBranchSessions\n+     *            the withBranchSessions\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid, boolean withBranchSessions) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            globalSessionJson = jedis.get(getGlobalKeyByXid(xid));\n+            if (StringUtils.isBlank(globalSessionJson)) {\n+                return null;\n+            }\n+            // global transaction\n+            GlobalTransactionDO globalTransactionDO = JSON.parseObject(globalSessionJson, GlobalTransactionDO.class);\n+            if (globalTransactionDO == null) {\n+                return null;\n+            }\n+            // branch transactions\n+            List<BranchTransactionDO> branchTransactionDOs = null;\n+            // reduce rpc with db when branchRegister and getGlobalStatus\n+            if (withBranchSessions) {\n+                Set<String> keys = lRange(jedis, getBranchListKeyByXid(globalTransactionDO.getXid()));\n+                if (CollectionUtils.isNotEmpty(keys)) {\n+                    branchTransactionDOs = getBranchJsons(jedis, keys);\n+                }\n+            }\n+            return getGlobalSession(globalTransactionDO, branchTransactionDOs);\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid) {\n+        return this.readSession(xid, true);\n+    }\n+\n+    /**\n+     * Read session list.\n+     *\n+     * @param statuses\n+     *            the statuses\n+     * @return the list\n+     */\n+    public List<GlobalSession> readSession(GlobalStatus[] statuses) {\n+        List<Integer> states = new ArrayList<>();\n+        for (int i = 0; i < statuses.length; i++) {\n+            states.add(statuses[i].getCode());\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Set<String> keys = new HashSet<>();\n+            String cursor = INITIAL_CURSOR;\n+            ScanParams params = new ScanParams();\n+            params.count(logQueryLimit);\n+            params.match(getGlobalKeyByXid(\"*\"));\n+            ScanResult<String> scans;\n+            do {\n+                scans = jedis.scan(cursor, params);\n+                keys.addAll(scans.getResult());\n+                cursor = scans.getCursor();\n+            } while (!INITIAL_CURSOR.equals(cursor));\n+            if (CollectionUtils.isNotEmpty(keys)) {\n+                List<GlobalTransactionDO> globalTransactionDOs = new ArrayList<>();\n+                for (String globalKey : keys) {\n+                    GlobalTransactionDO globalTransactionDO =\n+                        JSON.parseObject(jedis.get(globalKey), GlobalTransactionDO.class);\n+                    if (null != globalTransactionDO && states.contains(globalTransactionDO.getStatus())) {\n+                        globalTransactionDOs.add(globalTransactionDO);\n+                    }\n+                }\n+                if (CollectionUtils.isNotEmpty(globalTransactionDOs)) {\n+                    List<String> xids =\n+                        globalTransactionDOs.stream().map(GlobalTransactionDO::getXid).collect(Collectors.toList());\n+                    List<BranchTransactionDO> branchTransactionDOs = new ArrayList<>();\n+                    for (String xid : xids) {\n+                        Set<String> branches = lRange(jedis, getBranchListKeyByXid(xid));\n+                        if (CollectionUtils.isNotEmpty(branches)) {\n+                            branchTransactionDOs.addAll(getBranchJsons(jedis, branches));\n+                        }\n+                    }\n+                    Map<String, List<BranchTransactionDO>> branchTransactionDOsMap =\n+                        branchTransactionDOs.stream().collect(Collectors.groupingBy(BranchTransactionDO::getXid,\n+                            LinkedHashMap::new, Collectors.toList()));\n+                    return globalTransactionDOs.stream()\n+                        .map(globalTransactionDO -> getGlobalSession(globalTransactionDO,\n+                            branchTransactionDOsMap.get(globalTransactionDO.getXid())))\n+                        .collect(Collectors.toList());\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public List<GlobalSession> readSession(SessionCondition sessionCondition) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            if (!StringUtils.isEmpty(sessionCondition.getXid())) {\n+                String globalSessionJson = jedis.get(getGlobalKeyByXid(sessionCondition.getXid()));\n+                if (!StringUtils.isEmpty(globalSessionJson)) {\n+                    GlobalSession session =\n+                        convertGlobalSession(JSON.parseObject(globalSessionJson, GlobalTransactionDO.class));\n+                    List<GlobalSession> globalSessions = new ArrayList<>();\n+                    globalSessions.add(session);\n+                    return globalSessions;\n+                }\n+            } else if (sessionCondition.getTransactionId() != null) {\n+                String global = jedis.get(getGlobalKeyByTransactionId(sessionCondition.getTransactionId()));\n+                if (StringUtils.isEmpty(global)) {\n+                    return null;\n+                }\n+                GlobalTransactionDO globalTransactionDO = JSON.parseObject(global, GlobalTransactionDO.class);\n+                String branchKey = getBranchListKeyByXid(globalTransactionDO.getXid());\n+                Set<String> keys = lRange(jedis, branchKey);\n+                List<BranchTransactionDO> branchTransactionDOs;\n+                if (CollectionUtils.isNotEmpty(keys)) {\n+                    branchTransactionDOs = getBranchJsons(jedis, keys);\n+                    GlobalSession globalSession = getGlobalSession(globalTransactionDO, branchTransactionDOs);\n+                    if (globalSession != null) {\n+                        List<GlobalSession> globalSessions = new ArrayList<>();\n+                        globalSessions.add(globalSession);\n+                        return globalSessions;\n+                    }\n+                }\n+            } else if (CollectionUtils.isNotEmpty(sessionCondition.getStatuses())) {\n+                return readSession(sessionCondition.getStatuses());\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private List<BranchTransactionDO> getBranchJsons(Jedis jedis, Set<String> keys) {\n+        List<BranchTransactionDO> branchTransactionDOs = new ArrayList<>();\n+        List<String> branchJsons = jedis.mget(keys.toArray(new String[0]));\n+        for (String branchJson : branchJsons) {\n+            if (!StringUtils.isEmpty(branchJson)) {\n+                branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d22ce2ff2675d57c5883d57a6da6f6cf1883299c"}, "originalPosition": 299}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk0Mjg3Nw==", "bodyText": "this", "url": "https://github.com/seata/seata/pull/2484#discussion_r432942877", "createdAt": "2020-05-31T12:38:35Z", "author": {"login": "ph3636"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import com.alibaba.fastjson.JSON;\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String INITIAL_CURSOR = \"0\";\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    public RedisTransactionStoreManager() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            jedis.del(key);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            Pipeline pipeline = jedis.pipelined();\n+            if (jedis.get(key) == null) {\n+                pipeline.lpush(getBranchListKeyByXid(branchTransactionDO.getXid()), key);\n+            }\n+            pipeline.set(key, JSON.toJSONString(branchTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<String> keys = new ArrayList<>();\n+            keys.add(getGlobalKeyByXid(globalTransactionDO.getXid()));\n+            keys.add(getGlobalKeyByTransactionId(globalTransactionDO.getTransactionId()));\n+            keys.add(getBranchListKeyByXid(globalTransactionDO.getXid()));\n+            jedis.del(keys.toArray(new String[keys.size()]));\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String keys = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n+            Pipeline pipeline = jedis.pipelined();\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            keys = getGlobalKeyByTransactionId(convertGlobalTransactionDO.getTransactionId());\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @param withBranchSessions\n+     *            the withBranchSessions\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid, boolean withBranchSessions) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            globalSessionJson = jedis.get(getGlobalKeyByXid(xid));\n+            if (StringUtils.isBlank(globalSessionJson)) {\n+                return null;\n+            }\n+            // global transaction\n+            GlobalTransactionDO globalTransactionDO = JSON.parseObject(globalSessionJson, GlobalTransactionDO.class);\n+            if (globalTransactionDO == null) {\n+                return null;\n+            }\n+            // branch transactions\n+            List<BranchTransactionDO> branchTransactionDOs = null;\n+            // reduce rpc with db when branchRegister and getGlobalStatus\n+            if (withBranchSessions) {\n+                Set<String> keys = lRange(jedis, getBranchListKeyByXid(globalTransactionDO.getXid()));\n+                if (CollectionUtils.isNotEmpty(keys)) {\n+                    branchTransactionDOs = new ArrayList<>();\n+                    for (String s : keys) {\n+                        String branchJson = jedis.get(s);\n+                        if (StringUtils.isNotBlank(branchJson)) {\n+                            branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                        }\n+                    }\n+                }\n+            }\n+            return getGlobalSession(globalTransactionDO, branchTransactionDOs);\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid) {\n+        return this.readSession(xid, true);\n+    }\n+\n+    /**\n+     * Read session list.\n+     *\n+     * @param statuses\n+     *            the statuses\n+     * @return the list\n+     */\n+    public List<GlobalSession> readSession(GlobalStatus[] statuses) {\n+        List<Integer> states = new ArrayList<>();\n+        for (int i = 0; i < statuses.length; i++) {\n+            states.add(statuses[i].getCode());\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Set<String> keys = new HashSet<>();\n+            String cursor = INITIAL_CURSOR;\n+            ScanParams params = new ScanParams();\n+            params.count(logQueryLimit);\n+            params.match(getGlobalKeyByXid(\"*\"));\n+            ScanResult<String> scans;\n+            do {\n+                scans = jedis.scan(cursor, params);\n+                keys.addAll(scans.getResult().stream().collect(Collectors.toSet()));\n+                cursor = scans.getCursor();\n+            } while (!INITIAL_CURSOR.equals(cursor));\n+            if (CollectionUtils.isNotEmpty(keys)) {\n+                List<GlobalTransactionDO> globalTransactionDOs = new ArrayList<>();\n+                for (String globalKey : keys) {\n+                    GlobalTransactionDO globalTransactionDO =\n+                        JSON.parseObject(jedis.get(globalKey), GlobalTransactionDO.class);\n+                    if (null != globalTransactionDO && states.contains(globalTransactionDO.getStatus())) {\n+                        globalTransactionDOs.add(globalTransactionDO);\n+                    }\n+                }\n+                if (CollectionUtils.isNotEmpty(globalTransactionDOs)) {\n+                    List<String> xids =\n+                        globalTransactionDOs.stream().map(GlobalTransactionDO::getXid).collect(Collectors.toList());\n+                    List<BranchTransactionDO> branchTransactionDOs = new ArrayList<>();\n+                    for (String xid : xids) {\n+                        Set<String> branches = lRange(jedis, getBranchListKeyByXid(xid));\n+                        if (CollectionUtils.isNotEmpty(branches)) {\n+                            for (String branchKey : branches) {\n+                                String branchJson = jedis.get(branchKey);\n+                                if (StringUtils.isNotBlank(branchJson)) {\n+                                    branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                                }\n+                            }\n+                        }\n+                    }\n+                    Map<String, List<BranchTransactionDO>> branchTransactionDOsMap =\n+                        branchTransactionDOs.stream().collect(Collectors.groupingBy(BranchTransactionDO::getXid,\n+                            LinkedHashMap::new, Collectors.toList()));\n+                    return globalTransactionDOs.stream()\n+                        .map(globalTransactionDO -> getGlobalSession(globalTransactionDO,\n+                            branchTransactionDOsMap.get(globalTransactionDO.getXid())))\n+                        .collect(Collectors.toList());\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public List<GlobalSession> readSession(SessionCondition sessionCondition) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            if (StringUtils.isNotBlank(sessionCondition.getXid())) {\n+                globalSessionJson = jedis.get(getGlobalKeyByXid(sessionCondition.getXid()));\n+                if (StringUtils.isNotBlank(globalSessionJson)) {\n+                    GlobalSession session =\n+                        convertGlobalSession(JSON.parseObject(globalSessionJson, GlobalTransactionDO.class));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg0MDg1OQ=="}, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 279}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6c057b5d45bdd97144013c9acf808e077d0df9e6", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/6c057b5d45bdd97144013c9acf808e077d0df9e6", "committedDate": "2020-05-31T12:48:49Z", "message": "code formatting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "05d80f9defcd197d9312f6226c068924dbb5eca3", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/05d80f9defcd197d9312f6226c068924dbb5eca3", "committedDate": "2020-05-31T12:53:59Z", "message": "optimized code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a404b78743d82546fd11860385ac3ca3c7a23ab4", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/a404b78743d82546fd11860385ac3ca3c7a23ab4", "committedDate": "2020-05-31T13:19:42Z", "message": "optimized code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6332d2e468da359bdd9ae32461309f157f5352ce", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/6332d2e468da359bdd9ae32461309f157f5352ce", "committedDate": "2020-06-01T06:37:14Z", "message": "Merge branch 'develop' into store_mode_redis"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6ab6fee9066d5dc63f6e67c193f1246900d35ff6", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/6ab6fee9066d5dc63f6e67c193f1246900d35ff6", "committedDate": "2020-06-01T07:22:38Z", "message": "optimized code"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxNjcwOTkx", "url": "https://github.com/seata/seata/pull/2484#pullrequestreview-421670991", "createdAt": "2020-06-01T08:20:09Z", "commit": {"oid": "6ab6fee9066d5dc63f6e67c193f1246900d35ff6"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1ce94d0753e5b3f9683d90779b6313c4712d4e56", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/1ce94d0753e5b3f9683d90779b6313c4712d4e56", "committedDate": "2020-06-01T08:24:55Z", "message": "optimized code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e2ef454b5a98d71a30d37cc1ccc689e9e34cd823", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/e2ef454b5a98d71a30d37cc1ccc689e9e34cd823", "committedDate": "2020-06-03T03:52:54Z", "message": "Merge branch 'develop' into store_mode_redis"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzMjA5MjU2", "url": "https://github.com/seata/seata/pull/2484#pullrequestreview-423209256", "createdAt": "2020-06-03T04:26:21Z", "commit": {"oid": "e2ef454b5a98d71a30d37cc1ccc689e9e34cd823"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3862, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}