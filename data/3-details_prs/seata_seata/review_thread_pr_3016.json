{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY3NzE4Nzg0", "number": 3016, "reviewThreads": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQwMzowMTo1OFrOEYUYgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxMDowMTo0NVrOEbfwZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzOTM1MjMzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQwMzowMTo1OFrOHAl7LA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwNzoyNzowOFrOHCGxpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM4MzQwNA==", "bodyText": "cannot play the role of competition lock", "url": "https://github.com/seata/seata/pull/3016#discussion_r470383404", "createdAt": "2020-08-14T03:01:58Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -70,59 +87,80 @@ public boolean acquireLock(List<RowLock> rowLocks) {\n             return true;\n         }\n         Set<String> successList = new HashSet<>();\n-        long status = 1;\n+        String status = OK;\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            List<LockDO> locks = convertToLockDO(rowLocks);\n-            if (locks.size() > 1) {\n-                locks =\n-                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            List<LockDO> needLockDOS = convertToLockDO(rowLocks);\n+            if (needLockDOS.size() >= 1) {\n+                needLockDOS = needLockDOS.stream().\n+                        filter(LambdaUtils.distinctByKey(LockDO::getRowKey))\n+                        .collect(Collectors.toList());\n             }\n-            List<String> existedKeyList = new ArrayList<>();\n-            locks.forEach(lockDO -> {\n-                existedKeyList.add(getLockKey(lockDO.getRowKey()));\n-            });\n-            List<String> lockList = jedis.mget(existedKeyList.toArray(new String[0]));\n-            Map<String, String> map = new HashMap<>(existedKeyList.size(), 1);\n-            for (int i = 0; i < existedKeyList.size(); i++) {\n-                String existedValue = lockList.get(i);\n-                if (existedValue == null) {\n-                    String key = existedKeyList.get(i);\n-                    map.put(key, JSON.toJSONString(locks.get(i)));\n+            List<String> needLockKeys = new ArrayList<>();\n+            needLockDOS.forEach(lockDO -> needLockKeys.add(buildLockKey(lockDO.getRowKey())));\n+\n+            Pipeline pipeline1 = jedis.pipelined();\n+            needLockKeys.stream().forEachOrdered(needLockKey -> pipeline1.hget(needLockKey, XID));\n+            List<Object> existedXidObjs = pipeline1.syncAndReturnAll();\n+            List<String> existedXids = (List<String>) (List) existedXidObjs;\n+            Map<String, LockDO> map = new HashMap<>(needLockKeys.size(), 1);\n+\n+            String needLockXid = rowLocks.get(0).getXid();\n+            for (int i = 0; i < needLockKeys.size(); i++) {\n+                String existedXid = existedXids.get(i);\n+                if (StringUtils.isEmpty(existedXid)) {\n+                    //If empty,we need to lock this row\n+                    map.put(needLockKeys.get(i), needLockDOS.get(i));\n                 } else {\n-                    LockDO existed = JSON.parseObject(existedValue, LockDO.class);\n-                    if (!StringUtils.equals(existed.getXid(), locks.get(i).getXid())) {\n+                    if (!StringUtils.equals(existedXid, needLockXid)) {\n+                        //If not equals,means the rowkey is holding by another global transaction\n                         return false;\n                     }\n                 }\n             }\n+\n             if (map.isEmpty()) {\n                 return true;\n             }\n             Pipeline pipeline = jedis.pipelined();\n             List<String> readyKeys = new ArrayList<>();\n             map.forEach((key, value) -> {\n-                pipeline.setnx(key, value);\n+                Map<String, String> lockMap = new HashMap<>(8);\n+                lockMap.put(XID, value.getXid());\n+                lockMap.put(TRANSACTION_ID, value.getTransactionId().toString());\n+                lockMap.put(BRANCH_ID, value.getBranchId().toString());\n+                lockMap.put(RESOURCE_ID, value.getResourceId());\n+                lockMap.put(TABLE_NAME, value.getTableName());\n+                lockMap.put(ROW_KEY, value.getRowKey());\n+                lockMap.put(PK, value.getPk());\n+                pipeline.hmset(key, lockMap);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a0fe6e82c988178511a2212d1e7e4b9f556ceb7"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk3MDIxNA==", "bodyText": "fixed.", "url": "https://github.com/seata/seata/pull/3016#discussion_r471970214", "createdAt": "2020-08-18T07:27:08Z", "author": {"login": "lightClouds917"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -70,59 +87,80 @@ public boolean acquireLock(List<RowLock> rowLocks) {\n             return true;\n         }\n         Set<String> successList = new HashSet<>();\n-        long status = 1;\n+        String status = OK;\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            List<LockDO> locks = convertToLockDO(rowLocks);\n-            if (locks.size() > 1) {\n-                locks =\n-                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            List<LockDO> needLockDOS = convertToLockDO(rowLocks);\n+            if (needLockDOS.size() >= 1) {\n+                needLockDOS = needLockDOS.stream().\n+                        filter(LambdaUtils.distinctByKey(LockDO::getRowKey))\n+                        .collect(Collectors.toList());\n             }\n-            List<String> existedKeyList = new ArrayList<>();\n-            locks.forEach(lockDO -> {\n-                existedKeyList.add(getLockKey(lockDO.getRowKey()));\n-            });\n-            List<String> lockList = jedis.mget(existedKeyList.toArray(new String[0]));\n-            Map<String, String> map = new HashMap<>(existedKeyList.size(), 1);\n-            for (int i = 0; i < existedKeyList.size(); i++) {\n-                String existedValue = lockList.get(i);\n-                if (existedValue == null) {\n-                    String key = existedKeyList.get(i);\n-                    map.put(key, JSON.toJSONString(locks.get(i)));\n+            List<String> needLockKeys = new ArrayList<>();\n+            needLockDOS.forEach(lockDO -> needLockKeys.add(buildLockKey(lockDO.getRowKey())));\n+\n+            Pipeline pipeline1 = jedis.pipelined();\n+            needLockKeys.stream().forEachOrdered(needLockKey -> pipeline1.hget(needLockKey, XID));\n+            List<Object> existedXidObjs = pipeline1.syncAndReturnAll();\n+            List<String> existedXids = (List<String>) (List) existedXidObjs;\n+            Map<String, LockDO> map = new HashMap<>(needLockKeys.size(), 1);\n+\n+            String needLockXid = rowLocks.get(0).getXid();\n+            for (int i = 0; i < needLockKeys.size(); i++) {\n+                String existedXid = existedXids.get(i);\n+                if (StringUtils.isEmpty(existedXid)) {\n+                    //If empty,we need to lock this row\n+                    map.put(needLockKeys.get(i), needLockDOS.get(i));\n                 } else {\n-                    LockDO existed = JSON.parseObject(existedValue, LockDO.class);\n-                    if (!StringUtils.equals(existed.getXid(), locks.get(i).getXid())) {\n+                    if (!StringUtils.equals(existedXid, needLockXid)) {\n+                        //If not equals,means the rowkey is holding by another global transaction\n                         return false;\n                     }\n                 }\n             }\n+\n             if (map.isEmpty()) {\n                 return true;\n             }\n             Pipeline pipeline = jedis.pipelined();\n             List<String> readyKeys = new ArrayList<>();\n             map.forEach((key, value) -> {\n-                pipeline.setnx(key, value);\n+                Map<String, String> lockMap = new HashMap<>(8);\n+                lockMap.put(XID, value.getXid());\n+                lockMap.put(TRANSACTION_ID, value.getTransactionId().toString());\n+                lockMap.put(BRANCH_ID, value.getBranchId().toString());\n+                lockMap.put(RESOURCE_ID, value.getResourceId());\n+                lockMap.put(TABLE_NAME, value.getTableName());\n+                lockMap.put(ROW_KEY, value.getRowKey());\n+                lockMap.put(PK, value.getPk());\n+                pipeline.hmset(key, lockMap);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM4MzQwNA=="}, "originalCommit": {"oid": "0a0fe6e82c988178511a2212d1e7e4b9f556ceb7"}, "originalPosition": 128}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MDIzMjI2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwNzo1MDozM1rOHCHpPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMjowMzo1MlrOHCQSew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk4NDQ0NA==", "bodyText": "partitions.get(i).contains", "url": "https://github.com/seata/seata/pull/3016#discussion_r471984444", "createdAt": "2020-08-18T07:50:33Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -60,131 +87,178 @@\n      */\n     public RedisLocker() {\n         logQueryLimit =\n-            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+                ConfigurationFactory.getInstance()\n+                        .getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n     }\n \n     @Override\n     public boolean acquireLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        Set<String> successList = new HashSet<>();\n-        long status = 1;\n+        Integer status = SUCCEED;\n+        String needLockXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            List<LockDO> locks = convertToLockDO(rowLocks);\n-            if (locks.size() > 1) {\n-                locks =\n-                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            List<LockDO> needLockDOS = convertToLockDO(rowLocks);\n+            if (needLockDOS.size() >= 1) {\n+                needLockDOS = needLockDOS.stream().\n+                        filter(LambdaUtils.distinctByKey(LockDO::getRowKey))\n+                        .collect(Collectors.toList());\n             }\n-            List<String> existedKeyList = new ArrayList<>();\n-            locks.forEach(lockDO -> {\n-                existedKeyList.add(getLockKey(lockDO.getRowKey()));\n-            });\n-            List<String> lockList = jedis.mget(existedKeyList.toArray(new String[0]));\n-            Map<String, String> map = new HashMap<>(existedKeyList.size(), 1);\n-            for (int i = 0; i < existedKeyList.size(); i++) {\n-                String existedValue = lockList.get(i);\n-                if (existedValue == null) {\n-                    String key = existedKeyList.get(i);\n-                    map.put(key, JSON.toJSONString(locks.get(i)));\n+            List<String> needLockKeys = new ArrayList<>();\n+            needLockDOS.forEach(lockDO -> needLockKeys.add(buildLockKey(lockDO.getRowKey())));\n+\n+            Pipeline pipeline1 = jedis.pipelined();\n+            needLockKeys.stream().forEachOrdered(\n+                    needLockKey -> pipeline1.hmget(needLockKey, XID, TABLE_NAME, PK, BRANCH_ID));\n+            List<Object> existedObjs = pipeline1.syncAndReturnAll();\n+            List<List<String>> existedLockInfos = (List<List<String>>) (List) existedObjs;\n+            Map<String, LockDO> needAddLock = new HashMap<>(needLockKeys.size(), 1);\n+\n+            for (int i = 0; i < needLockKeys.size(); i++) {\n+                List<String> existedLockInfo = existedLockInfos.get(i);\n+                if (CollectionUtils.isEmpty(existedLockInfo) ||\n+                        existedLockInfo.stream().allMatch(info -> info == null)) {\n+                    //If empty,we need to lock this row\n+                    needAddLock.put(needLockKeys.get(i), needLockDOS.get(i));\n                 } else {\n-                    LockDO existed = JSON.parseObject(existedValue, LockDO.class);\n-                    if (!StringUtils.equals(existed.getXid(), locks.get(i).getXid())) {\n+                    if (!StringUtils.equals(existedLockInfo.get(0), needLockXid)) {\n+                        //If not equals,means the rowkey is holding by another global transaction\n+                        LOGGER.error(\"Acquire lock failed,Global lock on [{}:{}] is holding by xid {} branchId {}\",\n+                                existedLockInfo.get(1), existedLockInfo.get(2),\n+                                existedLockInfo.get(0), existedLockInfo.get(3));\n                         return false;\n                     }\n                 }\n             }\n-            if (map.isEmpty()) {\n+\n+            if (needAddLock.isEmpty()) {\n                 return true;\n             }\n             Pipeline pipeline = jedis.pipelined();\n             List<String> readyKeys = new ArrayList<>();\n-            map.forEach((key, value) -> {\n-                pipeline.setnx(key, value);\n+            needAddLock.forEach((key, value) -> {\n+                pipeline.hsetnx(key, XID, value.getXid());\n+                pipeline.hsetnx(key, TRANSACTION_ID, value.getTransactionId().toString());\n+                pipeline.hsetnx(key, BRANCH_ID, value.getBranchId().toString());\n+                pipeline.hsetnx(key, RESOURCE_ID, value.getResourceId());\n+                pipeline.hsetnx(key, TABLE_NAME, value.getTableName());\n+                pipeline.hsetnx(key, ROW_KEY, value.getRowKey());\n+                pipeline.hsetnx(key, PK, value.getPk());\n                 readyKeys.add(key);\n             });\n             List<Object> results = pipeline.syncAndReturnAll();\n-            for (int i = 0; i < results.size(); i++) {\n-                Long result = (long)results.get(i);\n+            List<Integer> results2 = (List<Integer>) (List) results;\n+            List<List<Integer>> partitions = Lists.partition(results2, 7);\n+\n+            Set<String> successSet = new HashSet<>();\n+            for (int i = 0; i < partitions.size(); i++) {\n                 String key = readyKeys.get(i);\n-                if (result != 1) {\n-                    status = result;\n+                if (partitions.contains(FAILED)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92275de275a98b11baf0ee39de54927d80faf659"}, "originalPosition": 171}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjEyNjA3NQ==", "bodyText": "finished", "url": "https://github.com/seata/seata/pull/3016#discussion_r472126075", "createdAt": "2020-08-18T12:03:52Z", "author": {"login": "lightClouds917"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -60,131 +87,178 @@\n      */\n     public RedisLocker() {\n         logQueryLimit =\n-            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+                ConfigurationFactory.getInstance()\n+                        .getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n     }\n \n     @Override\n     public boolean acquireLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        Set<String> successList = new HashSet<>();\n-        long status = 1;\n+        Integer status = SUCCEED;\n+        String needLockXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            List<LockDO> locks = convertToLockDO(rowLocks);\n-            if (locks.size() > 1) {\n-                locks =\n-                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            List<LockDO> needLockDOS = convertToLockDO(rowLocks);\n+            if (needLockDOS.size() >= 1) {\n+                needLockDOS = needLockDOS.stream().\n+                        filter(LambdaUtils.distinctByKey(LockDO::getRowKey))\n+                        .collect(Collectors.toList());\n             }\n-            List<String> existedKeyList = new ArrayList<>();\n-            locks.forEach(lockDO -> {\n-                existedKeyList.add(getLockKey(lockDO.getRowKey()));\n-            });\n-            List<String> lockList = jedis.mget(existedKeyList.toArray(new String[0]));\n-            Map<String, String> map = new HashMap<>(existedKeyList.size(), 1);\n-            for (int i = 0; i < existedKeyList.size(); i++) {\n-                String existedValue = lockList.get(i);\n-                if (existedValue == null) {\n-                    String key = existedKeyList.get(i);\n-                    map.put(key, JSON.toJSONString(locks.get(i)));\n+            List<String> needLockKeys = new ArrayList<>();\n+            needLockDOS.forEach(lockDO -> needLockKeys.add(buildLockKey(lockDO.getRowKey())));\n+\n+            Pipeline pipeline1 = jedis.pipelined();\n+            needLockKeys.stream().forEachOrdered(\n+                    needLockKey -> pipeline1.hmget(needLockKey, XID, TABLE_NAME, PK, BRANCH_ID));\n+            List<Object> existedObjs = pipeline1.syncAndReturnAll();\n+            List<List<String>> existedLockInfos = (List<List<String>>) (List) existedObjs;\n+            Map<String, LockDO> needAddLock = new HashMap<>(needLockKeys.size(), 1);\n+\n+            for (int i = 0; i < needLockKeys.size(); i++) {\n+                List<String> existedLockInfo = existedLockInfos.get(i);\n+                if (CollectionUtils.isEmpty(existedLockInfo) ||\n+                        existedLockInfo.stream().allMatch(info -> info == null)) {\n+                    //If empty,we need to lock this row\n+                    needAddLock.put(needLockKeys.get(i), needLockDOS.get(i));\n                 } else {\n-                    LockDO existed = JSON.parseObject(existedValue, LockDO.class);\n-                    if (!StringUtils.equals(existed.getXid(), locks.get(i).getXid())) {\n+                    if (!StringUtils.equals(existedLockInfo.get(0), needLockXid)) {\n+                        //If not equals,means the rowkey is holding by another global transaction\n+                        LOGGER.error(\"Acquire lock failed,Global lock on [{}:{}] is holding by xid {} branchId {}\",\n+                                existedLockInfo.get(1), existedLockInfo.get(2),\n+                                existedLockInfo.get(0), existedLockInfo.get(3));\n                         return false;\n                     }\n                 }\n             }\n-            if (map.isEmpty()) {\n+\n+            if (needAddLock.isEmpty()) {\n                 return true;\n             }\n             Pipeline pipeline = jedis.pipelined();\n             List<String> readyKeys = new ArrayList<>();\n-            map.forEach((key, value) -> {\n-                pipeline.setnx(key, value);\n+            needAddLock.forEach((key, value) -> {\n+                pipeline.hsetnx(key, XID, value.getXid());\n+                pipeline.hsetnx(key, TRANSACTION_ID, value.getTransactionId().toString());\n+                pipeline.hsetnx(key, BRANCH_ID, value.getBranchId().toString());\n+                pipeline.hsetnx(key, RESOURCE_ID, value.getResourceId());\n+                pipeline.hsetnx(key, TABLE_NAME, value.getTableName());\n+                pipeline.hsetnx(key, ROW_KEY, value.getRowKey());\n+                pipeline.hsetnx(key, PK, value.getPk());\n                 readyKeys.add(key);\n             });\n             List<Object> results = pipeline.syncAndReturnAll();\n-            for (int i = 0; i < results.size(); i++) {\n-                Long result = (long)results.get(i);\n+            List<Integer> results2 = (List<Integer>) (List) results;\n+            List<List<Integer>> partitions = Lists.partition(results2, 7);\n+\n+            Set<String> successSet = new HashSet<>();\n+            for (int i = 0; i < partitions.size(); i++) {\n                 String key = readyKeys.get(i);\n-                if (result != 1) {\n-                    status = result;\n+                if (partitions.contains(FAILED)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk4NDQ0NA=="}, "originalCommit": {"oid": "92275de275a98b11baf0ee39de54927d80faf659"}, "originalPosition": 171}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MDI0NTk3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwNzo1NDoxOVrOHCHxgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMjowMzo1NVrOHCQSmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk4NjU2MQ==", "bodyText": "del successSet. toArray (new String[0])", "url": "https://github.com/seata/seata/pull/3016#discussion_r471986561", "createdAt": "2020-08-18T07:54:19Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -60,131 +87,178 @@\n      */\n     public RedisLocker() {\n         logQueryLimit =\n-            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+                ConfigurationFactory.getInstance()\n+                        .getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n     }\n \n     @Override\n     public boolean acquireLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        Set<String> successList = new HashSet<>();\n-        long status = 1;\n+        Integer status = SUCCEED;\n+        String needLockXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            List<LockDO> locks = convertToLockDO(rowLocks);\n-            if (locks.size() > 1) {\n-                locks =\n-                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            List<LockDO> needLockDOS = convertToLockDO(rowLocks);\n+            if (needLockDOS.size() >= 1) {\n+                needLockDOS = needLockDOS.stream().\n+                        filter(LambdaUtils.distinctByKey(LockDO::getRowKey))\n+                        .collect(Collectors.toList());\n             }\n-            List<String> existedKeyList = new ArrayList<>();\n-            locks.forEach(lockDO -> {\n-                existedKeyList.add(getLockKey(lockDO.getRowKey()));\n-            });\n-            List<String> lockList = jedis.mget(existedKeyList.toArray(new String[0]));\n-            Map<String, String> map = new HashMap<>(existedKeyList.size(), 1);\n-            for (int i = 0; i < existedKeyList.size(); i++) {\n-                String existedValue = lockList.get(i);\n-                if (existedValue == null) {\n-                    String key = existedKeyList.get(i);\n-                    map.put(key, JSON.toJSONString(locks.get(i)));\n+            List<String> needLockKeys = new ArrayList<>();\n+            needLockDOS.forEach(lockDO -> needLockKeys.add(buildLockKey(lockDO.getRowKey())));\n+\n+            Pipeline pipeline1 = jedis.pipelined();\n+            needLockKeys.stream().forEachOrdered(\n+                    needLockKey -> pipeline1.hmget(needLockKey, XID, TABLE_NAME, PK, BRANCH_ID));\n+            List<Object> existedObjs = pipeline1.syncAndReturnAll();\n+            List<List<String>> existedLockInfos = (List<List<String>>) (List) existedObjs;\n+            Map<String, LockDO> needAddLock = new HashMap<>(needLockKeys.size(), 1);\n+\n+            for (int i = 0; i < needLockKeys.size(); i++) {\n+                List<String> existedLockInfo = existedLockInfos.get(i);\n+                if (CollectionUtils.isEmpty(existedLockInfo) ||\n+                        existedLockInfo.stream().allMatch(info -> info == null)) {\n+                    //If empty,we need to lock this row\n+                    needAddLock.put(needLockKeys.get(i), needLockDOS.get(i));\n                 } else {\n-                    LockDO existed = JSON.parseObject(existedValue, LockDO.class);\n-                    if (!StringUtils.equals(existed.getXid(), locks.get(i).getXid())) {\n+                    if (!StringUtils.equals(existedLockInfo.get(0), needLockXid)) {\n+                        //If not equals,means the rowkey is holding by another global transaction\n+                        LOGGER.error(\"Acquire lock failed,Global lock on [{}:{}] is holding by xid {} branchId {}\",\n+                                existedLockInfo.get(1), existedLockInfo.get(2),\n+                                existedLockInfo.get(0), existedLockInfo.get(3));\n                         return false;\n                     }\n                 }\n             }\n-            if (map.isEmpty()) {\n+\n+            if (needAddLock.isEmpty()) {\n                 return true;\n             }\n             Pipeline pipeline = jedis.pipelined();\n             List<String> readyKeys = new ArrayList<>();\n-            map.forEach((key, value) -> {\n-                pipeline.setnx(key, value);\n+            needAddLock.forEach((key, value) -> {\n+                pipeline.hsetnx(key, XID, value.getXid());\n+                pipeline.hsetnx(key, TRANSACTION_ID, value.getTransactionId().toString());\n+                pipeline.hsetnx(key, BRANCH_ID, value.getBranchId().toString());\n+                pipeline.hsetnx(key, RESOURCE_ID, value.getResourceId());\n+                pipeline.hsetnx(key, TABLE_NAME, value.getTableName());\n+                pipeline.hsetnx(key, ROW_KEY, value.getRowKey());\n+                pipeline.hsetnx(key, PK, value.getPk());\n                 readyKeys.add(key);\n             });\n             List<Object> results = pipeline.syncAndReturnAll();\n-            for (int i = 0; i < results.size(); i++) {\n-                Long result = (long)results.get(i);\n+            List<Integer> results2 = (List<Integer>) (List) results;\n+            List<List<Integer>> partitions = Lists.partition(results2, 7);\n+\n+            Set<String> successSet = new HashSet<>();\n+            for (int i = 0; i < partitions.size(); i++) {\n                 String key = readyKeys.get(i);\n-                if (result != 1) {\n-                    status = result;\n+                if (partitions.contains(FAILED)) {\n+                    status = FAILED;\n                 } else {\n-                    successList.add(key);\n+                    successSet.add(key);\n                 }\n             }\n-            if (status != 1) {\n-                String[] rms = successList.toArray(new String[0]);\n-                if (rms.length > 0) {\n-                    jedis.del(rms);\n+\n+            //If someone has failed,all the lockkey which has been added need to be delete.\n+            if (FAILED.equals(status)) {\n+                if (successSet.size() > 0) {\n+                    Pipeline pipeline2 = jedis.pipelined();\n+                    successSet.forEach(locKey ->\n+                            pipeline2.hdel(locKey, XID, TRANSACTION_ID, BRANCH_ID, RESOURCE_ID,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92275de275a98b11baf0ee39de54927d80faf659"}, "originalPosition": 188}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjEyNjEwNQ==", "bodyText": "finished", "url": "https://github.com/seata/seata/pull/3016#discussion_r472126105", "createdAt": "2020-08-18T12:03:55Z", "author": {"login": "lightClouds917"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -60,131 +87,178 @@\n      */\n     public RedisLocker() {\n         logQueryLimit =\n-            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+                ConfigurationFactory.getInstance()\n+                        .getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n     }\n \n     @Override\n     public boolean acquireLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        Set<String> successList = new HashSet<>();\n-        long status = 1;\n+        Integer status = SUCCEED;\n+        String needLockXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            List<LockDO> locks = convertToLockDO(rowLocks);\n-            if (locks.size() > 1) {\n-                locks =\n-                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            List<LockDO> needLockDOS = convertToLockDO(rowLocks);\n+            if (needLockDOS.size() >= 1) {\n+                needLockDOS = needLockDOS.stream().\n+                        filter(LambdaUtils.distinctByKey(LockDO::getRowKey))\n+                        .collect(Collectors.toList());\n             }\n-            List<String> existedKeyList = new ArrayList<>();\n-            locks.forEach(lockDO -> {\n-                existedKeyList.add(getLockKey(lockDO.getRowKey()));\n-            });\n-            List<String> lockList = jedis.mget(existedKeyList.toArray(new String[0]));\n-            Map<String, String> map = new HashMap<>(existedKeyList.size(), 1);\n-            for (int i = 0; i < existedKeyList.size(); i++) {\n-                String existedValue = lockList.get(i);\n-                if (existedValue == null) {\n-                    String key = existedKeyList.get(i);\n-                    map.put(key, JSON.toJSONString(locks.get(i)));\n+            List<String> needLockKeys = new ArrayList<>();\n+            needLockDOS.forEach(lockDO -> needLockKeys.add(buildLockKey(lockDO.getRowKey())));\n+\n+            Pipeline pipeline1 = jedis.pipelined();\n+            needLockKeys.stream().forEachOrdered(\n+                    needLockKey -> pipeline1.hmget(needLockKey, XID, TABLE_NAME, PK, BRANCH_ID));\n+            List<Object> existedObjs = pipeline1.syncAndReturnAll();\n+            List<List<String>> existedLockInfos = (List<List<String>>) (List) existedObjs;\n+            Map<String, LockDO> needAddLock = new HashMap<>(needLockKeys.size(), 1);\n+\n+            for (int i = 0; i < needLockKeys.size(); i++) {\n+                List<String> existedLockInfo = existedLockInfos.get(i);\n+                if (CollectionUtils.isEmpty(existedLockInfo) ||\n+                        existedLockInfo.stream().allMatch(info -> info == null)) {\n+                    //If empty,we need to lock this row\n+                    needAddLock.put(needLockKeys.get(i), needLockDOS.get(i));\n                 } else {\n-                    LockDO existed = JSON.parseObject(existedValue, LockDO.class);\n-                    if (!StringUtils.equals(existed.getXid(), locks.get(i).getXid())) {\n+                    if (!StringUtils.equals(existedLockInfo.get(0), needLockXid)) {\n+                        //If not equals,means the rowkey is holding by another global transaction\n+                        LOGGER.error(\"Acquire lock failed,Global lock on [{}:{}] is holding by xid {} branchId {}\",\n+                                existedLockInfo.get(1), existedLockInfo.get(2),\n+                                existedLockInfo.get(0), existedLockInfo.get(3));\n                         return false;\n                     }\n                 }\n             }\n-            if (map.isEmpty()) {\n+\n+            if (needAddLock.isEmpty()) {\n                 return true;\n             }\n             Pipeline pipeline = jedis.pipelined();\n             List<String> readyKeys = new ArrayList<>();\n-            map.forEach((key, value) -> {\n-                pipeline.setnx(key, value);\n+            needAddLock.forEach((key, value) -> {\n+                pipeline.hsetnx(key, XID, value.getXid());\n+                pipeline.hsetnx(key, TRANSACTION_ID, value.getTransactionId().toString());\n+                pipeline.hsetnx(key, BRANCH_ID, value.getBranchId().toString());\n+                pipeline.hsetnx(key, RESOURCE_ID, value.getResourceId());\n+                pipeline.hsetnx(key, TABLE_NAME, value.getTableName());\n+                pipeline.hsetnx(key, ROW_KEY, value.getRowKey());\n+                pipeline.hsetnx(key, PK, value.getPk());\n                 readyKeys.add(key);\n             });\n             List<Object> results = pipeline.syncAndReturnAll();\n-            for (int i = 0; i < results.size(); i++) {\n-                Long result = (long)results.get(i);\n+            List<Integer> results2 = (List<Integer>) (List) results;\n+            List<List<Integer>> partitions = Lists.partition(results2, 7);\n+\n+            Set<String> successSet = new HashSet<>();\n+            for (int i = 0; i < partitions.size(); i++) {\n                 String key = readyKeys.get(i);\n-                if (result != 1) {\n-                    status = result;\n+                if (partitions.contains(FAILED)) {\n+                    status = FAILED;\n                 } else {\n-                    successList.add(key);\n+                    successSet.add(key);\n                 }\n             }\n-            if (status != 1) {\n-                String[] rms = successList.toArray(new String[0]);\n-                if (rms.length > 0) {\n-                    jedis.del(rms);\n+\n+            //If someone has failed,all the lockkey which has been added need to be delete.\n+            if (FAILED.equals(status)) {\n+                if (successSet.size() > 0) {\n+                    Pipeline pipeline2 = jedis.pipelined();\n+                    successSet.forEach(locKey ->\n+                            pipeline2.hdel(locKey, XID, TRANSACTION_ID, BRANCH_ID, RESOURCE_ID,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk4NjU2MQ=="}, "originalCommit": {"oid": "92275de275a98b11baf0ee39de54927d80faf659"}, "originalPosition": 188}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MDI3ODA2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwODowMjozM1rOHCIE9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMjowMzo1OFrOHCQSrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk5MTU0MA==", "bodyText": "only need to xid", "url": "https://github.com/seata/seata/pull/3016#discussion_r471991540", "createdAt": "2020-08-18T08:02:33Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -60,131 +87,179 @@\n      */\n     public RedisLocker() {\n         logQueryLimit =\n-            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+                ConfigurationFactory.getInstance()\n+                        .getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n     }\n \n     @Override\n     public boolean acquireLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        Set<String> successList = new HashSet<>();\n-        long status = 1;\n+        Integer status = SUCCEED;\n+        String needLockXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            List<LockDO> locks = convertToLockDO(rowLocks);\n-            if (locks.size() > 1) {\n-                locks =\n-                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            List<LockDO> needLockDOS = convertToLockDO(rowLocks);\n+            if (needLockDOS.size() >= 1) {\n+                needLockDOS = needLockDOS.stream().\n+                        filter(LambdaUtils.distinctByKey(LockDO::getRowKey))\n+                        .collect(Collectors.toList());\n             }\n-            List<String> existedKeyList = new ArrayList<>();\n-            locks.forEach(lockDO -> {\n-                existedKeyList.add(getLockKey(lockDO.getRowKey()));\n-            });\n-            List<String> lockList = jedis.mget(existedKeyList.toArray(new String[0]));\n-            Map<String, String> map = new HashMap<>(existedKeyList.size(), 1);\n-            for (int i = 0; i < existedKeyList.size(); i++) {\n-                String existedValue = lockList.get(i);\n-                if (existedValue == null) {\n-                    String key = existedKeyList.get(i);\n-                    map.put(key, JSON.toJSONString(locks.get(i)));\n+            List<String> needLockKeys = new ArrayList<>();\n+            needLockDOS.forEach(lockDO -> needLockKeys.add(buildLockKey(lockDO.getRowKey())));\n+\n+            Pipeline pipeline1 = jedis.pipelined();\n+            needLockKeys.stream().forEachOrdered(\n+                    needLockKey -> pipeline1.hmget(needLockKey, XID, TABLE_NAME, PK, BRANCH_ID));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f4cca9c462a0d18a58d8cdd23a7d97fdbaaeb4a"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjEyNjEyNA==", "bodyText": "finished", "url": "https://github.com/seata/seata/pull/3016#discussion_r472126124", "createdAt": "2020-08-18T12:03:58Z", "author": {"login": "lightClouds917"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -60,131 +87,179 @@\n      */\n     public RedisLocker() {\n         logQueryLimit =\n-            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+                ConfigurationFactory.getInstance()\n+                        .getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n     }\n \n     @Override\n     public boolean acquireLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        Set<String> successList = new HashSet<>();\n-        long status = 1;\n+        Integer status = SUCCEED;\n+        String needLockXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            List<LockDO> locks = convertToLockDO(rowLocks);\n-            if (locks.size() > 1) {\n-                locks =\n-                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            List<LockDO> needLockDOS = convertToLockDO(rowLocks);\n+            if (needLockDOS.size() >= 1) {\n+                needLockDOS = needLockDOS.stream().\n+                        filter(LambdaUtils.distinctByKey(LockDO::getRowKey))\n+                        .collect(Collectors.toList());\n             }\n-            List<String> existedKeyList = new ArrayList<>();\n-            locks.forEach(lockDO -> {\n-                existedKeyList.add(getLockKey(lockDO.getRowKey()));\n-            });\n-            List<String> lockList = jedis.mget(existedKeyList.toArray(new String[0]));\n-            Map<String, String> map = new HashMap<>(existedKeyList.size(), 1);\n-            for (int i = 0; i < existedKeyList.size(); i++) {\n-                String existedValue = lockList.get(i);\n-                if (existedValue == null) {\n-                    String key = existedKeyList.get(i);\n-                    map.put(key, JSON.toJSONString(locks.get(i)));\n+            List<String> needLockKeys = new ArrayList<>();\n+            needLockDOS.forEach(lockDO -> needLockKeys.add(buildLockKey(lockDO.getRowKey())));\n+\n+            Pipeline pipeline1 = jedis.pipelined();\n+            needLockKeys.stream().forEachOrdered(\n+                    needLockKey -> pipeline1.hmget(needLockKey, XID, TABLE_NAME, PK, BRANCH_ID));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk5MTU0MA=="}, "originalCommit": {"oid": "1f4cca9c462a0d18a58d8cdd23a7d97fdbaaeb4a"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MDMxNzM1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwODoxMzozMlrOHCIdWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMjowNDowMVrOHCQSww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk5Nzc4Nw==", "bodyText": "List< Integer > results = (List) (List) pipeline.syncAndReturnAll();", "url": "https://github.com/seata/seata/pull/3016#discussion_r471997787", "createdAt": "2020-08-18T08:13:32Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -60,131 +87,179 @@\n      */\n     public RedisLocker() {\n         logQueryLimit =\n-            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+                ConfigurationFactory.getInstance()\n+                        .getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n     }\n \n     @Override\n     public boolean acquireLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        Set<String> successList = new HashSet<>();\n-        long status = 1;\n+        Integer status = SUCCEED;\n+        String needLockXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            List<LockDO> locks = convertToLockDO(rowLocks);\n-            if (locks.size() > 1) {\n-                locks =\n-                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            List<LockDO> needLockDOS = convertToLockDO(rowLocks);\n+            if (needLockDOS.size() >= 1) {\n+                needLockDOS = needLockDOS.stream().\n+                        filter(LambdaUtils.distinctByKey(LockDO::getRowKey))\n+                        .collect(Collectors.toList());\n             }\n-            List<String> existedKeyList = new ArrayList<>();\n-            locks.forEach(lockDO -> {\n-                existedKeyList.add(getLockKey(lockDO.getRowKey()));\n-            });\n-            List<String> lockList = jedis.mget(existedKeyList.toArray(new String[0]));\n-            Map<String, String> map = new HashMap<>(existedKeyList.size(), 1);\n-            for (int i = 0; i < existedKeyList.size(); i++) {\n-                String existedValue = lockList.get(i);\n-                if (existedValue == null) {\n-                    String key = existedKeyList.get(i);\n-                    map.put(key, JSON.toJSONString(locks.get(i)));\n+            List<String> needLockKeys = new ArrayList<>();\n+            needLockDOS.forEach(lockDO -> needLockKeys.add(buildLockKey(lockDO.getRowKey())));\n+\n+            Pipeline pipeline1 = jedis.pipelined();\n+            needLockKeys.stream().forEachOrdered(\n+                    needLockKey -> pipeline1.hmget(needLockKey, XID, TABLE_NAME, PK, BRANCH_ID));\n+            List<Object> existedObjs = pipeline1.syncAndReturnAll();\n+            List<List<String>> existedLockInfos = (List<List<String>>) (List) existedObjs;\n+            Map<String, LockDO> needAddLock = new HashMap<>(needLockKeys.size(), 1);\n+\n+            for (int i = 0; i < needLockKeys.size(); i++) {\n+                List<String> existedLockInfo = existedLockInfos.get(i);\n+                if (CollectionUtils.isEmpty(existedLockInfo) ||\n+                        existedLockInfo.stream().allMatch(info -> info == null)) {\n+                    //If empty,we need to lock this row\n+                    needAddLock.put(needLockKeys.get(i), needLockDOS.get(i));\n                 } else {\n-                    LockDO existed = JSON.parseObject(existedValue, LockDO.class);\n-                    if (!StringUtils.equals(existed.getXid(), locks.get(i).getXid())) {\n+                    if (!StringUtils.equals(existedLockInfo.get(0), needLockXid)) {\n+                        //If not equals,means the rowkey is holding by another global transaction\n+                        LOGGER.error(\n+                                \"Acquire lock failed,Global lock on [{}:{}] is holding by xid {} branchId {}\",\n+                                existedLockInfo.get(1), existedLockInfo.get(2),\n+                                existedLockInfo.get(0), existedLockInfo.get(3));\n                         return false;\n                     }\n                 }\n             }\n-            if (map.isEmpty()) {\n+\n+            if (needAddLock.isEmpty()) {\n                 return true;\n             }\n             Pipeline pipeline = jedis.pipelined();\n             List<String> readyKeys = new ArrayList<>();\n-            map.forEach((key, value) -> {\n-                pipeline.setnx(key, value);\n+            needAddLock.forEach((key, value) -> {\n+                pipeline.hsetnx(key, XID, value.getXid());\n+                pipeline.hsetnx(key, TRANSACTION_ID, value.getTransactionId().toString());\n+                pipeline.hsetnx(key, BRANCH_ID, value.getBranchId().toString());\n+                pipeline.hsetnx(key, RESOURCE_ID, value.getResourceId());\n+                pipeline.hsetnx(key, TABLE_NAME, value.getTableName());\n+                pipeline.hsetnx(key, ROW_KEY, value.getRowKey());\n+                pipeline.hsetnx(key, PK, value.getPk());\n                 readyKeys.add(key);\n             });\n             List<Object> results = pipeline.syncAndReturnAll();\n-            for (int i = 0; i < results.size(); i++) {\n-                Long result = (long)results.get(i);\n+            List<Integer> results2 = (List<Integer>) (List) results;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f4cca9c462a0d18a58d8cdd23a7d97fdbaaeb4a"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjEyNjE0Nw==", "bodyText": "finished", "url": "https://github.com/seata/seata/pull/3016#discussion_r472126147", "createdAt": "2020-08-18T12:04:01Z", "author": {"login": "lightClouds917"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -60,131 +87,179 @@\n      */\n     public RedisLocker() {\n         logQueryLimit =\n-            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+                ConfigurationFactory.getInstance()\n+                        .getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n     }\n \n     @Override\n     public boolean acquireLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        Set<String> successList = new HashSet<>();\n-        long status = 1;\n+        Integer status = SUCCEED;\n+        String needLockXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            List<LockDO> locks = convertToLockDO(rowLocks);\n-            if (locks.size() > 1) {\n-                locks =\n-                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            List<LockDO> needLockDOS = convertToLockDO(rowLocks);\n+            if (needLockDOS.size() >= 1) {\n+                needLockDOS = needLockDOS.stream().\n+                        filter(LambdaUtils.distinctByKey(LockDO::getRowKey))\n+                        .collect(Collectors.toList());\n             }\n-            List<String> existedKeyList = new ArrayList<>();\n-            locks.forEach(lockDO -> {\n-                existedKeyList.add(getLockKey(lockDO.getRowKey()));\n-            });\n-            List<String> lockList = jedis.mget(existedKeyList.toArray(new String[0]));\n-            Map<String, String> map = new HashMap<>(existedKeyList.size(), 1);\n-            for (int i = 0; i < existedKeyList.size(); i++) {\n-                String existedValue = lockList.get(i);\n-                if (existedValue == null) {\n-                    String key = existedKeyList.get(i);\n-                    map.put(key, JSON.toJSONString(locks.get(i)));\n+            List<String> needLockKeys = new ArrayList<>();\n+            needLockDOS.forEach(lockDO -> needLockKeys.add(buildLockKey(lockDO.getRowKey())));\n+\n+            Pipeline pipeline1 = jedis.pipelined();\n+            needLockKeys.stream().forEachOrdered(\n+                    needLockKey -> pipeline1.hmget(needLockKey, XID, TABLE_NAME, PK, BRANCH_ID));\n+            List<Object> existedObjs = pipeline1.syncAndReturnAll();\n+            List<List<String>> existedLockInfos = (List<List<String>>) (List) existedObjs;\n+            Map<String, LockDO> needAddLock = new HashMap<>(needLockKeys.size(), 1);\n+\n+            for (int i = 0; i < needLockKeys.size(); i++) {\n+                List<String> existedLockInfo = existedLockInfos.get(i);\n+                if (CollectionUtils.isEmpty(existedLockInfo) ||\n+                        existedLockInfo.stream().allMatch(info -> info == null)) {\n+                    //If empty,we need to lock this row\n+                    needAddLock.put(needLockKeys.get(i), needLockDOS.get(i));\n                 } else {\n-                    LockDO existed = JSON.parseObject(existedValue, LockDO.class);\n-                    if (!StringUtils.equals(existed.getXid(), locks.get(i).getXid())) {\n+                    if (!StringUtils.equals(existedLockInfo.get(0), needLockXid)) {\n+                        //If not equals,means the rowkey is holding by another global transaction\n+                        LOGGER.error(\n+                                \"Acquire lock failed,Global lock on [{}:{}] is holding by xid {} branchId {}\",\n+                                existedLockInfo.get(1), existedLockInfo.get(2),\n+                                existedLockInfo.get(0), existedLockInfo.get(3));\n                         return false;\n                     }\n                 }\n             }\n-            if (map.isEmpty()) {\n+\n+            if (needAddLock.isEmpty()) {\n                 return true;\n             }\n             Pipeline pipeline = jedis.pipelined();\n             List<String> readyKeys = new ArrayList<>();\n-            map.forEach((key, value) -> {\n-                pipeline.setnx(key, value);\n+            needAddLock.forEach((key, value) -> {\n+                pipeline.hsetnx(key, XID, value.getXid());\n+                pipeline.hsetnx(key, TRANSACTION_ID, value.getTransactionId().toString());\n+                pipeline.hsetnx(key, BRANCH_ID, value.getBranchId().toString());\n+                pipeline.hsetnx(key, RESOURCE_ID, value.getResourceId());\n+                pipeline.hsetnx(key, TABLE_NAME, value.getTableName());\n+                pipeline.hsetnx(key, ROW_KEY, value.getRowKey());\n+                pipeline.hsetnx(key, PK, value.getPk());\n                 readyKeys.add(key);\n             });\n             List<Object> results = pipeline.syncAndReturnAll();\n-            for (int i = 0; i < results.size(); i++) {\n-                Long result = (long)results.get(i);\n+            List<Integer> results2 = (List<Integer>) (List) results;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk5Nzc4Nw=="}, "originalCommit": {"oid": "1f4cca9c462a0d18a58d8cdd23a7d97fdbaaeb4a"}, "originalPosition": 164}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MDMzMTI5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwODoxNzoxNVrOHCIl3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMjowNDowM1rOHCQS2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk5OTk2Ng==", "bodyText": "the lock can only be actively unlocked by the owner without having to retrieve it again", "url": "https://github.com/seata/seata/pull/3016#discussion_r471999966", "createdAt": "2020-08-18T08:17:15Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -60,131 +87,179 @@\n      */\n     public RedisLocker() {\n         logQueryLimit =\n-            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+                ConfigurationFactory.getInstance()\n+                        .getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n     }\n \n     @Override\n     public boolean acquireLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        Set<String> successList = new HashSet<>();\n-        long status = 1;\n+        Integer status = SUCCEED;\n+        String needLockXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            List<LockDO> locks = convertToLockDO(rowLocks);\n-            if (locks.size() > 1) {\n-                locks =\n-                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            List<LockDO> needLockDOS = convertToLockDO(rowLocks);\n+            if (needLockDOS.size() >= 1) {\n+                needLockDOS = needLockDOS.stream().\n+                        filter(LambdaUtils.distinctByKey(LockDO::getRowKey))\n+                        .collect(Collectors.toList());\n             }\n-            List<String> existedKeyList = new ArrayList<>();\n-            locks.forEach(lockDO -> {\n-                existedKeyList.add(getLockKey(lockDO.getRowKey()));\n-            });\n-            List<String> lockList = jedis.mget(existedKeyList.toArray(new String[0]));\n-            Map<String, String> map = new HashMap<>(existedKeyList.size(), 1);\n-            for (int i = 0; i < existedKeyList.size(); i++) {\n-                String existedValue = lockList.get(i);\n-                if (existedValue == null) {\n-                    String key = existedKeyList.get(i);\n-                    map.put(key, JSON.toJSONString(locks.get(i)));\n+            List<String> needLockKeys = new ArrayList<>();\n+            needLockDOS.forEach(lockDO -> needLockKeys.add(buildLockKey(lockDO.getRowKey())));\n+\n+            Pipeline pipeline1 = jedis.pipelined();\n+            needLockKeys.stream().forEachOrdered(\n+                    needLockKey -> pipeline1.hmget(needLockKey, XID, TABLE_NAME, PK, BRANCH_ID));\n+            List<Object> existedObjs = pipeline1.syncAndReturnAll();\n+            List<List<String>> existedLockInfos = (List<List<String>>) (List) existedObjs;\n+            Map<String, LockDO> needAddLock = new HashMap<>(needLockKeys.size(), 1);\n+\n+            for (int i = 0; i < needLockKeys.size(); i++) {\n+                List<String> existedLockInfo = existedLockInfos.get(i);\n+                if (CollectionUtils.isEmpty(existedLockInfo) ||\n+                        existedLockInfo.stream().allMatch(info -> info == null)) {\n+                    //If empty,we need to lock this row\n+                    needAddLock.put(needLockKeys.get(i), needLockDOS.get(i));\n                 } else {\n-                    LockDO existed = JSON.parseObject(existedValue, LockDO.class);\n-                    if (!StringUtils.equals(existed.getXid(), locks.get(i).getXid())) {\n+                    if (!StringUtils.equals(existedLockInfo.get(0), needLockXid)) {\n+                        //If not equals,means the rowkey is holding by another global transaction\n+                        LOGGER.error(\n+                                \"Acquire lock failed,Global lock on [{}:{}] is holding by xid {} branchId {}\",\n+                                existedLockInfo.get(1), existedLockInfo.get(2),\n+                                existedLockInfo.get(0), existedLockInfo.get(3));\n                         return false;\n                     }\n                 }\n             }\n-            if (map.isEmpty()) {\n+\n+            if (needAddLock.isEmpty()) {\n                 return true;\n             }\n             Pipeline pipeline = jedis.pipelined();\n             List<String> readyKeys = new ArrayList<>();\n-            map.forEach((key, value) -> {\n-                pipeline.setnx(key, value);\n+            needAddLock.forEach((key, value) -> {\n+                pipeline.hsetnx(key, XID, value.getXid());\n+                pipeline.hsetnx(key, TRANSACTION_ID, value.getTransactionId().toString());\n+                pipeline.hsetnx(key, BRANCH_ID, value.getBranchId().toString());\n+                pipeline.hsetnx(key, RESOURCE_ID, value.getResourceId());\n+                pipeline.hsetnx(key, TABLE_NAME, value.getTableName());\n+                pipeline.hsetnx(key, ROW_KEY, value.getRowKey());\n+                pipeline.hsetnx(key, PK, value.getPk());\n                 readyKeys.add(key);\n             });\n             List<Object> results = pipeline.syncAndReturnAll();\n-            for (int i = 0; i < results.size(); i++) {\n-                Long result = (long)results.get(i);\n+            List<Integer> results2 = (List<Integer>) (List) results;\n+            List<List<Integer>> partitions = Lists.partition(results2, 7);\n+\n+            Set<String> successSet = new HashSet<>();\n+            for (int i = 0; i < partitions.size(); i++) {\n                 String key = readyKeys.get(i);\n-                if (result != 1) {\n-                    status = result;\n+                if (partitions.get(i).contains(FAILED)) {\n+                    status = FAILED;\n                 } else {\n-                    successList.add(key);\n+                    successSet.add(key);\n                 }\n             }\n-            if (status != 1) {\n-                String[] rms = successList.toArray(new String[0]);\n-                if (rms.length > 0) {\n-                    jedis.del(rms);\n+\n+            //If someone has failed,all the lockkey which has been added need to be delete.\n+            if (FAILED.equals(status)) {\n+                if (successSet.size() > 0) {\n+                    Pipeline pipeline2 = jedis.pipelined();\n+                    successSet.forEach(locKey ->\n+                            pipeline2.hdel(locKey, XID, TRANSACTION_ID, BRANCH_ID, RESOURCE_ID,\n+                                    TABLE_NAME, ROW_KEY, PK));\n+                    pipeline2.sync();\n                 }\n                 return false;\n-            } else {\n-                try {\n-                    String xidLockKey = getXidLockKey(locks.get(0).getXid());\n-                    jedis.lpush(xidLockKey, readyKeys.toArray(new String[0]));\n-                } catch (Exception e) {\n-                    return false;\n-                }\n-                return true;\n             }\n+            String xidLockKey = buildXidLockKey(needLockXid);\n+            StringJoiner lockKeysString = new StringJoiner(SEMICOLON);\n+            needLockKeys.stream().forEach(lockKey -> lockKeysString.add(lockKey));\n+            jedis.hsetnx(xidLockKey, branchId.toString(), lockKeysString.toString());\n+            return true;\n         }\n     }\n \n     @Override\n     public boolean releaseLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        String[] keys = new String[rowLocks.size()];\n-        List<LockDO> locks = convertToLockDO(rowLocks);\n-        for (int i = 0; i < locks.size(); i++) {\n-            String key = getLockKey(locks.get(i).getRowKey());\n-            keys[i] = key;\n-        }\n+        String currentXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+        List<String> needReleaseKeys = new ArrayList<>(rowLocks.size());\n+        List<LockDO> needReleaseLocks = convertToLockDO(rowLocks);\n+        needReleaseLocks.stream()\n+                .forEach(lockDO -> needReleaseKeys.add(buildLockKey(lockDO.getRowKey())));\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String xidLockKey = getXidLockKey(locks.get(0).getXid());\n-            Pipeline pipeline = jedis.pipelined();\n-            pipeline.del(keys);\n-            Arrays.stream(keys).forEach(key -> pipeline.lrem(xidLockKey, 0, key));\n-            pipeline.sync();\n+            Pipeline pipelined = jedis.pipelined();\n+            needReleaseKeys.stream()\n+                    .forEach(key -> pipelined.hmget(key, XID, TABLE_NAME, PK, BRANCH_ID));\n+            List<Object> existedObjs = pipelined.syncAndReturnAll();\n+            List<List<String>> existedLockInfos = (List<List<String>>) (List) existedObjs;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f4cca9c462a0d18a58d8cdd23a7d97fdbaaeb4a"}, "originalPosition": 240}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjEyNjE3MQ==", "bodyText": "finished", "url": "https://github.com/seata/seata/pull/3016#discussion_r472126171", "createdAt": "2020-08-18T12:04:03Z", "author": {"login": "lightClouds917"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -60,131 +87,179 @@\n      */\n     public RedisLocker() {\n         logQueryLimit =\n-            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+                ConfigurationFactory.getInstance()\n+                        .getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n     }\n \n     @Override\n     public boolean acquireLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        Set<String> successList = new HashSet<>();\n-        long status = 1;\n+        Integer status = SUCCEED;\n+        String needLockXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            List<LockDO> locks = convertToLockDO(rowLocks);\n-            if (locks.size() > 1) {\n-                locks =\n-                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            List<LockDO> needLockDOS = convertToLockDO(rowLocks);\n+            if (needLockDOS.size() >= 1) {\n+                needLockDOS = needLockDOS.stream().\n+                        filter(LambdaUtils.distinctByKey(LockDO::getRowKey))\n+                        .collect(Collectors.toList());\n             }\n-            List<String> existedKeyList = new ArrayList<>();\n-            locks.forEach(lockDO -> {\n-                existedKeyList.add(getLockKey(lockDO.getRowKey()));\n-            });\n-            List<String> lockList = jedis.mget(existedKeyList.toArray(new String[0]));\n-            Map<String, String> map = new HashMap<>(existedKeyList.size(), 1);\n-            for (int i = 0; i < existedKeyList.size(); i++) {\n-                String existedValue = lockList.get(i);\n-                if (existedValue == null) {\n-                    String key = existedKeyList.get(i);\n-                    map.put(key, JSON.toJSONString(locks.get(i)));\n+            List<String> needLockKeys = new ArrayList<>();\n+            needLockDOS.forEach(lockDO -> needLockKeys.add(buildLockKey(lockDO.getRowKey())));\n+\n+            Pipeline pipeline1 = jedis.pipelined();\n+            needLockKeys.stream().forEachOrdered(\n+                    needLockKey -> pipeline1.hmget(needLockKey, XID, TABLE_NAME, PK, BRANCH_ID));\n+            List<Object> existedObjs = pipeline1.syncAndReturnAll();\n+            List<List<String>> existedLockInfos = (List<List<String>>) (List) existedObjs;\n+            Map<String, LockDO> needAddLock = new HashMap<>(needLockKeys.size(), 1);\n+\n+            for (int i = 0; i < needLockKeys.size(); i++) {\n+                List<String> existedLockInfo = existedLockInfos.get(i);\n+                if (CollectionUtils.isEmpty(existedLockInfo) ||\n+                        existedLockInfo.stream().allMatch(info -> info == null)) {\n+                    //If empty,we need to lock this row\n+                    needAddLock.put(needLockKeys.get(i), needLockDOS.get(i));\n                 } else {\n-                    LockDO existed = JSON.parseObject(existedValue, LockDO.class);\n-                    if (!StringUtils.equals(existed.getXid(), locks.get(i).getXid())) {\n+                    if (!StringUtils.equals(existedLockInfo.get(0), needLockXid)) {\n+                        //If not equals,means the rowkey is holding by another global transaction\n+                        LOGGER.error(\n+                                \"Acquire lock failed,Global lock on [{}:{}] is holding by xid {} branchId {}\",\n+                                existedLockInfo.get(1), existedLockInfo.get(2),\n+                                existedLockInfo.get(0), existedLockInfo.get(3));\n                         return false;\n                     }\n                 }\n             }\n-            if (map.isEmpty()) {\n+\n+            if (needAddLock.isEmpty()) {\n                 return true;\n             }\n             Pipeline pipeline = jedis.pipelined();\n             List<String> readyKeys = new ArrayList<>();\n-            map.forEach((key, value) -> {\n-                pipeline.setnx(key, value);\n+            needAddLock.forEach((key, value) -> {\n+                pipeline.hsetnx(key, XID, value.getXid());\n+                pipeline.hsetnx(key, TRANSACTION_ID, value.getTransactionId().toString());\n+                pipeline.hsetnx(key, BRANCH_ID, value.getBranchId().toString());\n+                pipeline.hsetnx(key, RESOURCE_ID, value.getResourceId());\n+                pipeline.hsetnx(key, TABLE_NAME, value.getTableName());\n+                pipeline.hsetnx(key, ROW_KEY, value.getRowKey());\n+                pipeline.hsetnx(key, PK, value.getPk());\n                 readyKeys.add(key);\n             });\n             List<Object> results = pipeline.syncAndReturnAll();\n-            for (int i = 0; i < results.size(); i++) {\n-                Long result = (long)results.get(i);\n+            List<Integer> results2 = (List<Integer>) (List) results;\n+            List<List<Integer>> partitions = Lists.partition(results2, 7);\n+\n+            Set<String> successSet = new HashSet<>();\n+            for (int i = 0; i < partitions.size(); i++) {\n                 String key = readyKeys.get(i);\n-                if (result != 1) {\n-                    status = result;\n+                if (partitions.get(i).contains(FAILED)) {\n+                    status = FAILED;\n                 } else {\n-                    successList.add(key);\n+                    successSet.add(key);\n                 }\n             }\n-            if (status != 1) {\n-                String[] rms = successList.toArray(new String[0]);\n-                if (rms.length > 0) {\n-                    jedis.del(rms);\n+\n+            //If someone has failed,all the lockkey which has been added need to be delete.\n+            if (FAILED.equals(status)) {\n+                if (successSet.size() > 0) {\n+                    Pipeline pipeline2 = jedis.pipelined();\n+                    successSet.forEach(locKey ->\n+                            pipeline2.hdel(locKey, XID, TRANSACTION_ID, BRANCH_ID, RESOURCE_ID,\n+                                    TABLE_NAME, ROW_KEY, PK));\n+                    pipeline2.sync();\n                 }\n                 return false;\n-            } else {\n-                try {\n-                    String xidLockKey = getXidLockKey(locks.get(0).getXid());\n-                    jedis.lpush(xidLockKey, readyKeys.toArray(new String[0]));\n-                } catch (Exception e) {\n-                    return false;\n-                }\n-                return true;\n             }\n+            String xidLockKey = buildXidLockKey(needLockXid);\n+            StringJoiner lockKeysString = new StringJoiner(SEMICOLON);\n+            needLockKeys.stream().forEach(lockKey -> lockKeysString.add(lockKey));\n+            jedis.hsetnx(xidLockKey, branchId.toString(), lockKeysString.toString());\n+            return true;\n         }\n     }\n \n     @Override\n     public boolean releaseLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        String[] keys = new String[rowLocks.size()];\n-        List<LockDO> locks = convertToLockDO(rowLocks);\n-        for (int i = 0; i < locks.size(); i++) {\n-            String key = getLockKey(locks.get(i).getRowKey());\n-            keys[i] = key;\n-        }\n+        String currentXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+        List<String> needReleaseKeys = new ArrayList<>(rowLocks.size());\n+        List<LockDO> needReleaseLocks = convertToLockDO(rowLocks);\n+        needReleaseLocks.stream()\n+                .forEach(lockDO -> needReleaseKeys.add(buildLockKey(lockDO.getRowKey())));\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String xidLockKey = getXidLockKey(locks.get(0).getXid());\n-            Pipeline pipeline = jedis.pipelined();\n-            pipeline.del(keys);\n-            Arrays.stream(keys).forEach(key -> pipeline.lrem(xidLockKey, 0, key));\n-            pipeline.sync();\n+            Pipeline pipelined = jedis.pipelined();\n+            needReleaseKeys.stream()\n+                    .forEach(key -> pipelined.hmget(key, XID, TABLE_NAME, PK, BRANCH_ID));\n+            List<Object> existedObjs = pipelined.syncAndReturnAll();\n+            List<List<String>> existedLockInfos = (List<List<String>>) (List) existedObjs;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk5OTk2Ng=="}, "originalCommit": {"oid": "1f4cca9c462a0d18a58d8cdd23a7d97fdbaaeb4a"}, "originalPosition": 240}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MDM1ODM5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwODoyNDowM1rOHCI2KA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwODoyNDowM1rOHCI2KA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjAwNDEzNg==", "bodyText": "only need to xid", "url": "https://github.com/seata/seata/pull/3016#discussion_r472004136", "createdAt": "2020-08-18T08:24:03Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -60,131 +87,179 @@\n      */\n     public RedisLocker() {\n         logQueryLimit =\n-            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+                ConfigurationFactory.getInstance()\n+                        .getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n     }\n \n     @Override\n     public boolean acquireLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        Set<String> successList = new HashSet<>();\n-        long status = 1;\n+        Integer status = SUCCEED;\n+        String needLockXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            List<LockDO> locks = convertToLockDO(rowLocks);\n-            if (locks.size() > 1) {\n-                locks =\n-                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            List<LockDO> needLockDOS = convertToLockDO(rowLocks);\n+            if (needLockDOS.size() >= 1) {\n+                needLockDOS = needLockDOS.stream().\n+                        filter(LambdaUtils.distinctByKey(LockDO::getRowKey))\n+                        .collect(Collectors.toList());\n             }\n-            List<String> existedKeyList = new ArrayList<>();\n-            locks.forEach(lockDO -> {\n-                existedKeyList.add(getLockKey(lockDO.getRowKey()));\n-            });\n-            List<String> lockList = jedis.mget(existedKeyList.toArray(new String[0]));\n-            Map<String, String> map = new HashMap<>(existedKeyList.size(), 1);\n-            for (int i = 0; i < existedKeyList.size(); i++) {\n-                String existedValue = lockList.get(i);\n-                if (existedValue == null) {\n-                    String key = existedKeyList.get(i);\n-                    map.put(key, JSON.toJSONString(locks.get(i)));\n+            List<String> needLockKeys = new ArrayList<>();\n+            needLockDOS.forEach(lockDO -> needLockKeys.add(buildLockKey(lockDO.getRowKey())));\n+\n+            Pipeline pipeline1 = jedis.pipelined();\n+            needLockKeys.stream().forEachOrdered(\n+                    needLockKey -> pipeline1.hmget(needLockKey, XID, TABLE_NAME, PK, BRANCH_ID));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f4cca9c462a0d18a58d8cdd23a7d97fdbaaeb4a"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MDM1OTY3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwODoyNDoyNFrOHCI2_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMjowNDowNlrOHCQS8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjAwNDM0OQ==", "bodyText": "only need to xid", "url": "https://github.com/seata/seata/pull/3016#discussion_r472004349", "createdAt": "2020-08-18T08:24:24Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -60,131 +87,179 @@\n      */\n     public RedisLocker() {\n         logQueryLimit =\n-            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+                ConfigurationFactory.getInstance()\n+                        .getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n     }\n \n     @Override\n     public boolean acquireLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        Set<String> successList = new HashSet<>();\n-        long status = 1;\n+        Integer status = SUCCEED;\n+        String needLockXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            List<LockDO> locks = convertToLockDO(rowLocks);\n-            if (locks.size() > 1) {\n-                locks =\n-                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            List<LockDO> needLockDOS = convertToLockDO(rowLocks);\n+            if (needLockDOS.size() >= 1) {\n+                needLockDOS = needLockDOS.stream().\n+                        filter(LambdaUtils.distinctByKey(LockDO::getRowKey))\n+                        .collect(Collectors.toList());\n             }\n-            List<String> existedKeyList = new ArrayList<>();\n-            locks.forEach(lockDO -> {\n-                existedKeyList.add(getLockKey(lockDO.getRowKey()));\n-            });\n-            List<String> lockList = jedis.mget(existedKeyList.toArray(new String[0]));\n-            Map<String, String> map = new HashMap<>(existedKeyList.size(), 1);\n-            for (int i = 0; i < existedKeyList.size(); i++) {\n-                String existedValue = lockList.get(i);\n-                if (existedValue == null) {\n-                    String key = existedKeyList.get(i);\n-                    map.put(key, JSON.toJSONString(locks.get(i)));\n+            List<String> needLockKeys = new ArrayList<>();\n+            needLockDOS.forEach(lockDO -> needLockKeys.add(buildLockKey(lockDO.getRowKey())));\n+\n+            Pipeline pipeline1 = jedis.pipelined();\n+            needLockKeys.stream().forEachOrdered(\n+                    needLockKey -> pipeline1.hmget(needLockKey, XID, TABLE_NAME, PK, BRANCH_ID));\n+            List<Object> existedObjs = pipeline1.syncAndReturnAll();\n+            List<List<String>> existedLockInfos = (List<List<String>>) (List) existedObjs;\n+            Map<String, LockDO> needAddLock = new HashMap<>(needLockKeys.size(), 1);\n+\n+            for (int i = 0; i < needLockKeys.size(); i++) {\n+                List<String> existedLockInfo = existedLockInfos.get(i);\n+                if (CollectionUtils.isEmpty(existedLockInfo) ||\n+                        existedLockInfo.stream().allMatch(info -> info == null)) {\n+                    //If empty,we need to lock this row\n+                    needAddLock.put(needLockKeys.get(i), needLockDOS.get(i));\n                 } else {\n-                    LockDO existed = JSON.parseObject(existedValue, LockDO.class);\n-                    if (!StringUtils.equals(existed.getXid(), locks.get(i).getXid())) {\n+                    if (!StringUtils.equals(existedLockInfo.get(0), needLockXid)) {\n+                        //If not equals,means the rowkey is holding by another global transaction\n+                        LOGGER.error(\n+                                \"Acquire lock failed,Global lock on [{}:{}] is holding by xid {} branchId {}\",\n+                                existedLockInfo.get(1), existedLockInfo.get(2),\n+                                existedLockInfo.get(0), existedLockInfo.get(3));\n                         return false;\n                     }\n                 }\n             }\n-            if (map.isEmpty()) {\n+\n+            if (needAddLock.isEmpty()) {\n                 return true;\n             }\n             Pipeline pipeline = jedis.pipelined();\n             List<String> readyKeys = new ArrayList<>();\n-            map.forEach((key, value) -> {\n-                pipeline.setnx(key, value);\n+            needAddLock.forEach((key, value) -> {\n+                pipeline.hsetnx(key, XID, value.getXid());\n+                pipeline.hsetnx(key, TRANSACTION_ID, value.getTransactionId().toString());\n+                pipeline.hsetnx(key, BRANCH_ID, value.getBranchId().toString());\n+                pipeline.hsetnx(key, RESOURCE_ID, value.getResourceId());\n+                pipeline.hsetnx(key, TABLE_NAME, value.getTableName());\n+                pipeline.hsetnx(key, ROW_KEY, value.getRowKey());\n+                pipeline.hsetnx(key, PK, value.getPk());\n                 readyKeys.add(key);\n             });\n             List<Object> results = pipeline.syncAndReturnAll();\n-            for (int i = 0; i < results.size(); i++) {\n-                Long result = (long)results.get(i);\n+            List<Integer> results2 = (List<Integer>) (List) results;\n+            List<List<Integer>> partitions = Lists.partition(results2, 7);\n+\n+            Set<String> successSet = new HashSet<>();\n+            for (int i = 0; i < partitions.size(); i++) {\n                 String key = readyKeys.get(i);\n-                if (result != 1) {\n-                    status = result;\n+                if (partitions.get(i).contains(FAILED)) {\n+                    status = FAILED;\n                 } else {\n-                    successList.add(key);\n+                    successSet.add(key);\n                 }\n             }\n-            if (status != 1) {\n-                String[] rms = successList.toArray(new String[0]);\n-                if (rms.length > 0) {\n-                    jedis.del(rms);\n+\n+            //If someone has failed,all the lockkey which has been added need to be delete.\n+            if (FAILED.equals(status)) {\n+                if (successSet.size() > 0) {\n+                    Pipeline pipeline2 = jedis.pipelined();\n+                    successSet.forEach(locKey ->\n+                            pipeline2.hdel(locKey, XID, TRANSACTION_ID, BRANCH_ID, RESOURCE_ID,\n+                                    TABLE_NAME, ROW_KEY, PK));\n+                    pipeline2.sync();\n                 }\n                 return false;\n-            } else {\n-                try {\n-                    String xidLockKey = getXidLockKey(locks.get(0).getXid());\n-                    jedis.lpush(xidLockKey, readyKeys.toArray(new String[0]));\n-                } catch (Exception e) {\n-                    return false;\n-                }\n-                return true;\n             }\n+            String xidLockKey = buildXidLockKey(needLockXid);\n+            StringJoiner lockKeysString = new StringJoiner(SEMICOLON);\n+            needLockKeys.stream().forEach(lockKey -> lockKeysString.add(lockKey));\n+            jedis.hsetnx(xidLockKey, branchId.toString(), lockKeysString.toString());\n+            return true;\n         }\n     }\n \n     @Override\n     public boolean releaseLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        String[] keys = new String[rowLocks.size()];\n-        List<LockDO> locks = convertToLockDO(rowLocks);\n-        for (int i = 0; i < locks.size(); i++) {\n-            String key = getLockKey(locks.get(i).getRowKey());\n-            keys[i] = key;\n-        }\n+        String currentXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+        List<String> needReleaseKeys = new ArrayList<>(rowLocks.size());\n+        List<LockDO> needReleaseLocks = convertToLockDO(rowLocks);\n+        needReleaseLocks.stream()\n+                .forEach(lockDO -> needReleaseKeys.add(buildLockKey(lockDO.getRowKey())));\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String xidLockKey = getXidLockKey(locks.get(0).getXid());\n-            Pipeline pipeline = jedis.pipelined();\n-            pipeline.del(keys);\n-            Arrays.stream(keys).forEach(key -> pipeline.lrem(xidLockKey, 0, key));\n-            pipeline.sync();\n+            Pipeline pipelined = jedis.pipelined();\n+            needReleaseKeys.stream()\n+                    .forEach(key -> pipelined.hmget(key, XID, TABLE_NAME, PK, BRANCH_ID));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f4cca9c462a0d18a58d8cdd23a7d97fdbaaeb4a"}, "originalPosition": 238}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjEyNjE5NQ==", "bodyText": "finished", "url": "https://github.com/seata/seata/pull/3016#discussion_r472126195", "createdAt": "2020-08-18T12:04:06Z", "author": {"login": "lightClouds917"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -60,131 +87,179 @@\n      */\n     public RedisLocker() {\n         logQueryLimit =\n-            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+                ConfigurationFactory.getInstance()\n+                        .getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n     }\n \n     @Override\n     public boolean acquireLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        Set<String> successList = new HashSet<>();\n-        long status = 1;\n+        Integer status = SUCCEED;\n+        String needLockXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            List<LockDO> locks = convertToLockDO(rowLocks);\n-            if (locks.size() > 1) {\n-                locks =\n-                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            List<LockDO> needLockDOS = convertToLockDO(rowLocks);\n+            if (needLockDOS.size() >= 1) {\n+                needLockDOS = needLockDOS.stream().\n+                        filter(LambdaUtils.distinctByKey(LockDO::getRowKey))\n+                        .collect(Collectors.toList());\n             }\n-            List<String> existedKeyList = new ArrayList<>();\n-            locks.forEach(lockDO -> {\n-                existedKeyList.add(getLockKey(lockDO.getRowKey()));\n-            });\n-            List<String> lockList = jedis.mget(existedKeyList.toArray(new String[0]));\n-            Map<String, String> map = new HashMap<>(existedKeyList.size(), 1);\n-            for (int i = 0; i < existedKeyList.size(); i++) {\n-                String existedValue = lockList.get(i);\n-                if (existedValue == null) {\n-                    String key = existedKeyList.get(i);\n-                    map.put(key, JSON.toJSONString(locks.get(i)));\n+            List<String> needLockKeys = new ArrayList<>();\n+            needLockDOS.forEach(lockDO -> needLockKeys.add(buildLockKey(lockDO.getRowKey())));\n+\n+            Pipeline pipeline1 = jedis.pipelined();\n+            needLockKeys.stream().forEachOrdered(\n+                    needLockKey -> pipeline1.hmget(needLockKey, XID, TABLE_NAME, PK, BRANCH_ID));\n+            List<Object> existedObjs = pipeline1.syncAndReturnAll();\n+            List<List<String>> existedLockInfos = (List<List<String>>) (List) existedObjs;\n+            Map<String, LockDO> needAddLock = new HashMap<>(needLockKeys.size(), 1);\n+\n+            for (int i = 0; i < needLockKeys.size(); i++) {\n+                List<String> existedLockInfo = existedLockInfos.get(i);\n+                if (CollectionUtils.isEmpty(existedLockInfo) ||\n+                        existedLockInfo.stream().allMatch(info -> info == null)) {\n+                    //If empty,we need to lock this row\n+                    needAddLock.put(needLockKeys.get(i), needLockDOS.get(i));\n                 } else {\n-                    LockDO existed = JSON.parseObject(existedValue, LockDO.class);\n-                    if (!StringUtils.equals(existed.getXid(), locks.get(i).getXid())) {\n+                    if (!StringUtils.equals(existedLockInfo.get(0), needLockXid)) {\n+                        //If not equals,means the rowkey is holding by another global transaction\n+                        LOGGER.error(\n+                                \"Acquire lock failed,Global lock on [{}:{}] is holding by xid {} branchId {}\",\n+                                existedLockInfo.get(1), existedLockInfo.get(2),\n+                                existedLockInfo.get(0), existedLockInfo.get(3));\n                         return false;\n                     }\n                 }\n             }\n-            if (map.isEmpty()) {\n+\n+            if (needAddLock.isEmpty()) {\n                 return true;\n             }\n             Pipeline pipeline = jedis.pipelined();\n             List<String> readyKeys = new ArrayList<>();\n-            map.forEach((key, value) -> {\n-                pipeline.setnx(key, value);\n+            needAddLock.forEach((key, value) -> {\n+                pipeline.hsetnx(key, XID, value.getXid());\n+                pipeline.hsetnx(key, TRANSACTION_ID, value.getTransactionId().toString());\n+                pipeline.hsetnx(key, BRANCH_ID, value.getBranchId().toString());\n+                pipeline.hsetnx(key, RESOURCE_ID, value.getResourceId());\n+                pipeline.hsetnx(key, TABLE_NAME, value.getTableName());\n+                pipeline.hsetnx(key, ROW_KEY, value.getRowKey());\n+                pipeline.hsetnx(key, PK, value.getPk());\n                 readyKeys.add(key);\n             });\n             List<Object> results = pipeline.syncAndReturnAll();\n-            for (int i = 0; i < results.size(); i++) {\n-                Long result = (long)results.get(i);\n+            List<Integer> results2 = (List<Integer>) (List) results;\n+            List<List<Integer>> partitions = Lists.partition(results2, 7);\n+\n+            Set<String> successSet = new HashSet<>();\n+            for (int i = 0; i < partitions.size(); i++) {\n                 String key = readyKeys.get(i);\n-                if (result != 1) {\n-                    status = result;\n+                if (partitions.get(i).contains(FAILED)) {\n+                    status = FAILED;\n                 } else {\n-                    successList.add(key);\n+                    successSet.add(key);\n                 }\n             }\n-            if (status != 1) {\n-                String[] rms = successList.toArray(new String[0]);\n-                if (rms.length > 0) {\n-                    jedis.del(rms);\n+\n+            //If someone has failed,all the lockkey which has been added need to be delete.\n+            if (FAILED.equals(status)) {\n+                if (successSet.size() > 0) {\n+                    Pipeline pipeline2 = jedis.pipelined();\n+                    successSet.forEach(locKey ->\n+                            pipeline2.hdel(locKey, XID, TRANSACTION_ID, BRANCH_ID, RESOURCE_ID,\n+                                    TABLE_NAME, ROW_KEY, PK));\n+                    pipeline2.sync();\n                 }\n                 return false;\n-            } else {\n-                try {\n-                    String xidLockKey = getXidLockKey(locks.get(0).getXid());\n-                    jedis.lpush(xidLockKey, readyKeys.toArray(new String[0]));\n-                } catch (Exception e) {\n-                    return false;\n-                }\n-                return true;\n             }\n+            String xidLockKey = buildXidLockKey(needLockXid);\n+            StringJoiner lockKeysString = new StringJoiner(SEMICOLON);\n+            needLockKeys.stream().forEach(lockKey -> lockKeysString.add(lockKey));\n+            jedis.hsetnx(xidLockKey, branchId.toString(), lockKeysString.toString());\n+            return true;\n         }\n     }\n \n     @Override\n     public boolean releaseLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        String[] keys = new String[rowLocks.size()];\n-        List<LockDO> locks = convertToLockDO(rowLocks);\n-        for (int i = 0; i < locks.size(); i++) {\n-            String key = getLockKey(locks.get(i).getRowKey());\n-            keys[i] = key;\n-        }\n+        String currentXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+        List<String> needReleaseKeys = new ArrayList<>(rowLocks.size());\n+        List<LockDO> needReleaseLocks = convertToLockDO(rowLocks);\n+        needReleaseLocks.stream()\n+                .forEach(lockDO -> needReleaseKeys.add(buildLockKey(lockDO.getRowKey())));\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String xidLockKey = getXidLockKey(locks.get(0).getXid());\n-            Pipeline pipeline = jedis.pipelined();\n-            pipeline.del(keys);\n-            Arrays.stream(keys).forEach(key -> pipeline.lrem(xidLockKey, 0, key));\n-            pipeline.sync();\n+            Pipeline pipelined = jedis.pipelined();\n+            needReleaseKeys.stream()\n+                    .forEach(key -> pipelined.hmget(key, XID, TABLE_NAME, PK, BRANCH_ID));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjAwNDM0OQ=="}, "originalCommit": {"oid": "1f4cca9c462a0d18a58d8cdd23a7d97fdbaaeb4a"}, "originalPosition": 238}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MDM2NzM5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwODoyNjoxOVrOHCI7vA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMjowNDoxMFrOHCQTGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjAwNTU2NA==", "bodyText": "del needReleaseKeys. toArray (new String[0])", "url": "https://github.com/seata/seata/pull/3016#discussion_r472005564", "createdAt": "2020-08-18T08:26:19Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -60,131 +87,179 @@\n      */\n     public RedisLocker() {\n         logQueryLimit =\n-            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+                ConfigurationFactory.getInstance()\n+                        .getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n     }\n \n     @Override\n     public boolean acquireLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        Set<String> successList = new HashSet<>();\n-        long status = 1;\n+        Integer status = SUCCEED;\n+        String needLockXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            List<LockDO> locks = convertToLockDO(rowLocks);\n-            if (locks.size() > 1) {\n-                locks =\n-                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            List<LockDO> needLockDOS = convertToLockDO(rowLocks);\n+            if (needLockDOS.size() >= 1) {\n+                needLockDOS = needLockDOS.stream().\n+                        filter(LambdaUtils.distinctByKey(LockDO::getRowKey))\n+                        .collect(Collectors.toList());\n             }\n-            List<String> existedKeyList = new ArrayList<>();\n-            locks.forEach(lockDO -> {\n-                existedKeyList.add(getLockKey(lockDO.getRowKey()));\n-            });\n-            List<String> lockList = jedis.mget(existedKeyList.toArray(new String[0]));\n-            Map<String, String> map = new HashMap<>(existedKeyList.size(), 1);\n-            for (int i = 0; i < existedKeyList.size(); i++) {\n-                String existedValue = lockList.get(i);\n-                if (existedValue == null) {\n-                    String key = existedKeyList.get(i);\n-                    map.put(key, JSON.toJSONString(locks.get(i)));\n+            List<String> needLockKeys = new ArrayList<>();\n+            needLockDOS.forEach(lockDO -> needLockKeys.add(buildLockKey(lockDO.getRowKey())));\n+\n+            Pipeline pipeline1 = jedis.pipelined();\n+            needLockKeys.stream().forEachOrdered(\n+                    needLockKey -> pipeline1.hmget(needLockKey, XID, TABLE_NAME, PK, BRANCH_ID));\n+            List<Object> existedObjs = pipeline1.syncAndReturnAll();\n+            List<List<String>> existedLockInfos = (List<List<String>>) (List) existedObjs;\n+            Map<String, LockDO> needAddLock = new HashMap<>(needLockKeys.size(), 1);\n+\n+            for (int i = 0; i < needLockKeys.size(); i++) {\n+                List<String> existedLockInfo = existedLockInfos.get(i);\n+                if (CollectionUtils.isEmpty(existedLockInfo) ||\n+                        existedLockInfo.stream().allMatch(info -> info == null)) {\n+                    //If empty,we need to lock this row\n+                    needAddLock.put(needLockKeys.get(i), needLockDOS.get(i));\n                 } else {\n-                    LockDO existed = JSON.parseObject(existedValue, LockDO.class);\n-                    if (!StringUtils.equals(existed.getXid(), locks.get(i).getXid())) {\n+                    if (!StringUtils.equals(existedLockInfo.get(0), needLockXid)) {\n+                        //If not equals,means the rowkey is holding by another global transaction\n+                        LOGGER.error(\n+                                \"Acquire lock failed,Global lock on [{}:{}] is holding by xid {} branchId {}\",\n+                                existedLockInfo.get(1), existedLockInfo.get(2),\n+                                existedLockInfo.get(0), existedLockInfo.get(3));\n                         return false;\n                     }\n                 }\n             }\n-            if (map.isEmpty()) {\n+\n+            if (needAddLock.isEmpty()) {\n                 return true;\n             }\n             Pipeline pipeline = jedis.pipelined();\n             List<String> readyKeys = new ArrayList<>();\n-            map.forEach((key, value) -> {\n-                pipeline.setnx(key, value);\n+            needAddLock.forEach((key, value) -> {\n+                pipeline.hsetnx(key, XID, value.getXid());\n+                pipeline.hsetnx(key, TRANSACTION_ID, value.getTransactionId().toString());\n+                pipeline.hsetnx(key, BRANCH_ID, value.getBranchId().toString());\n+                pipeline.hsetnx(key, RESOURCE_ID, value.getResourceId());\n+                pipeline.hsetnx(key, TABLE_NAME, value.getTableName());\n+                pipeline.hsetnx(key, ROW_KEY, value.getRowKey());\n+                pipeline.hsetnx(key, PK, value.getPk());\n                 readyKeys.add(key);\n             });\n             List<Object> results = pipeline.syncAndReturnAll();\n-            for (int i = 0; i < results.size(); i++) {\n-                Long result = (long)results.get(i);\n+            List<Integer> results2 = (List<Integer>) (List) results;\n+            List<List<Integer>> partitions = Lists.partition(results2, 7);\n+\n+            Set<String> successSet = new HashSet<>();\n+            for (int i = 0; i < partitions.size(); i++) {\n                 String key = readyKeys.get(i);\n-                if (result != 1) {\n-                    status = result;\n+                if (partitions.get(i).contains(FAILED)) {\n+                    status = FAILED;\n                 } else {\n-                    successList.add(key);\n+                    successSet.add(key);\n                 }\n             }\n-            if (status != 1) {\n-                String[] rms = successList.toArray(new String[0]);\n-                if (rms.length > 0) {\n-                    jedis.del(rms);\n+\n+            //If someone has failed,all the lockkey which has been added need to be delete.\n+            if (FAILED.equals(status)) {\n+                if (successSet.size() > 0) {\n+                    Pipeline pipeline2 = jedis.pipelined();\n+                    successSet.forEach(locKey ->\n+                            pipeline2.hdel(locKey, XID, TRANSACTION_ID, BRANCH_ID, RESOURCE_ID,\n+                                    TABLE_NAME, ROW_KEY, PK));\n+                    pipeline2.sync();\n                 }\n                 return false;\n-            } else {\n-                try {\n-                    String xidLockKey = getXidLockKey(locks.get(0).getXid());\n-                    jedis.lpush(xidLockKey, readyKeys.toArray(new String[0]));\n-                } catch (Exception e) {\n-                    return false;\n-                }\n-                return true;\n             }\n+            String xidLockKey = buildXidLockKey(needLockXid);\n+            StringJoiner lockKeysString = new StringJoiner(SEMICOLON);\n+            needLockKeys.stream().forEach(lockKey -> lockKeysString.add(lockKey));\n+            jedis.hsetnx(xidLockKey, branchId.toString(), lockKeysString.toString());\n+            return true;\n         }\n     }\n \n     @Override\n     public boolean releaseLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        String[] keys = new String[rowLocks.size()];\n-        List<LockDO> locks = convertToLockDO(rowLocks);\n-        for (int i = 0; i < locks.size(); i++) {\n-            String key = getLockKey(locks.get(i).getRowKey());\n-            keys[i] = key;\n-        }\n+        String currentXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+        List<String> needReleaseKeys = new ArrayList<>(rowLocks.size());\n+        List<LockDO> needReleaseLocks = convertToLockDO(rowLocks);\n+        needReleaseLocks.stream()\n+                .forEach(lockDO -> needReleaseKeys.add(buildLockKey(lockDO.getRowKey())));\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String xidLockKey = getXidLockKey(locks.get(0).getXid());\n-            Pipeline pipeline = jedis.pipelined();\n-            pipeline.del(keys);\n-            Arrays.stream(keys).forEach(key -> pipeline.lrem(xidLockKey, 0, key));\n-            pipeline.sync();\n+            Pipeline pipelined = jedis.pipelined();\n+            needReleaseKeys.stream()\n+                    .forEach(key -> pipelined.hmget(key, XID, TABLE_NAME, PK, BRANCH_ID));\n+            List<Object> existedObjs = pipelined.syncAndReturnAll();\n+            List<List<String>> existedLockInfos = (List<List<String>>) (List) existedObjs;\n+\n+            for (int i = 0; i < existedLockInfos.size(); i++) {\n+                List<String> existedLockInfo = existedLockInfos.get(i);\n+                if (CollectionUtils.isNotEmpty(existedLockInfo) ||\n+                        existedLockInfo.stream().allMatch(info -> info != null)) {\n+                    if (!StringUtils.equals(currentXid, existedLockInfo.get(0))) {\n+                        LOGGER.error(\n+                                \"Release lock failed,Global lock on [{}:{}] is holding by xid {} branchId {}\",\n+                                existedLockInfo.get(1), existedLockInfo.get(2),\n+                                existedLockInfo.get(0), existedLockInfo.get(3));\n+                        return false;\n+                    }\n+                }\n+            }\n+\n+            Pipeline pipelined1 = jedis.pipelined();\n+            needReleaseKeys.stream().forEach(key ->\n+                    pipelined1.hdel(key, XID, TRANSACTION_ID, BRANCH_ID, RESOURCE_ID,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f4cca9c462a0d18a58d8cdd23a7d97fdbaaeb4a"}, "originalPosition": 258}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjEyNjIzNA==", "bodyText": "finished", "url": "https://github.com/seata/seata/pull/3016#discussion_r472126234", "createdAt": "2020-08-18T12:04:10Z", "author": {"login": "lightClouds917"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -60,131 +87,179 @@\n      */\n     public RedisLocker() {\n         logQueryLimit =\n-            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+                ConfigurationFactory.getInstance()\n+                        .getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n     }\n \n     @Override\n     public boolean acquireLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        Set<String> successList = new HashSet<>();\n-        long status = 1;\n+        Integer status = SUCCEED;\n+        String needLockXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            List<LockDO> locks = convertToLockDO(rowLocks);\n-            if (locks.size() > 1) {\n-                locks =\n-                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            List<LockDO> needLockDOS = convertToLockDO(rowLocks);\n+            if (needLockDOS.size() >= 1) {\n+                needLockDOS = needLockDOS.stream().\n+                        filter(LambdaUtils.distinctByKey(LockDO::getRowKey))\n+                        .collect(Collectors.toList());\n             }\n-            List<String> existedKeyList = new ArrayList<>();\n-            locks.forEach(lockDO -> {\n-                existedKeyList.add(getLockKey(lockDO.getRowKey()));\n-            });\n-            List<String> lockList = jedis.mget(existedKeyList.toArray(new String[0]));\n-            Map<String, String> map = new HashMap<>(existedKeyList.size(), 1);\n-            for (int i = 0; i < existedKeyList.size(); i++) {\n-                String existedValue = lockList.get(i);\n-                if (existedValue == null) {\n-                    String key = existedKeyList.get(i);\n-                    map.put(key, JSON.toJSONString(locks.get(i)));\n+            List<String> needLockKeys = new ArrayList<>();\n+            needLockDOS.forEach(lockDO -> needLockKeys.add(buildLockKey(lockDO.getRowKey())));\n+\n+            Pipeline pipeline1 = jedis.pipelined();\n+            needLockKeys.stream().forEachOrdered(\n+                    needLockKey -> pipeline1.hmget(needLockKey, XID, TABLE_NAME, PK, BRANCH_ID));\n+            List<Object> existedObjs = pipeline1.syncAndReturnAll();\n+            List<List<String>> existedLockInfos = (List<List<String>>) (List) existedObjs;\n+            Map<String, LockDO> needAddLock = new HashMap<>(needLockKeys.size(), 1);\n+\n+            for (int i = 0; i < needLockKeys.size(); i++) {\n+                List<String> existedLockInfo = existedLockInfos.get(i);\n+                if (CollectionUtils.isEmpty(existedLockInfo) ||\n+                        existedLockInfo.stream().allMatch(info -> info == null)) {\n+                    //If empty,we need to lock this row\n+                    needAddLock.put(needLockKeys.get(i), needLockDOS.get(i));\n                 } else {\n-                    LockDO existed = JSON.parseObject(existedValue, LockDO.class);\n-                    if (!StringUtils.equals(existed.getXid(), locks.get(i).getXid())) {\n+                    if (!StringUtils.equals(existedLockInfo.get(0), needLockXid)) {\n+                        //If not equals,means the rowkey is holding by another global transaction\n+                        LOGGER.error(\n+                                \"Acquire lock failed,Global lock on [{}:{}] is holding by xid {} branchId {}\",\n+                                existedLockInfo.get(1), existedLockInfo.get(2),\n+                                existedLockInfo.get(0), existedLockInfo.get(3));\n                         return false;\n                     }\n                 }\n             }\n-            if (map.isEmpty()) {\n+\n+            if (needAddLock.isEmpty()) {\n                 return true;\n             }\n             Pipeline pipeline = jedis.pipelined();\n             List<String> readyKeys = new ArrayList<>();\n-            map.forEach((key, value) -> {\n-                pipeline.setnx(key, value);\n+            needAddLock.forEach((key, value) -> {\n+                pipeline.hsetnx(key, XID, value.getXid());\n+                pipeline.hsetnx(key, TRANSACTION_ID, value.getTransactionId().toString());\n+                pipeline.hsetnx(key, BRANCH_ID, value.getBranchId().toString());\n+                pipeline.hsetnx(key, RESOURCE_ID, value.getResourceId());\n+                pipeline.hsetnx(key, TABLE_NAME, value.getTableName());\n+                pipeline.hsetnx(key, ROW_KEY, value.getRowKey());\n+                pipeline.hsetnx(key, PK, value.getPk());\n                 readyKeys.add(key);\n             });\n             List<Object> results = pipeline.syncAndReturnAll();\n-            for (int i = 0; i < results.size(); i++) {\n-                Long result = (long)results.get(i);\n+            List<Integer> results2 = (List<Integer>) (List) results;\n+            List<List<Integer>> partitions = Lists.partition(results2, 7);\n+\n+            Set<String> successSet = new HashSet<>();\n+            for (int i = 0; i < partitions.size(); i++) {\n                 String key = readyKeys.get(i);\n-                if (result != 1) {\n-                    status = result;\n+                if (partitions.get(i).contains(FAILED)) {\n+                    status = FAILED;\n                 } else {\n-                    successList.add(key);\n+                    successSet.add(key);\n                 }\n             }\n-            if (status != 1) {\n-                String[] rms = successList.toArray(new String[0]);\n-                if (rms.length > 0) {\n-                    jedis.del(rms);\n+\n+            //If someone has failed,all the lockkey which has been added need to be delete.\n+            if (FAILED.equals(status)) {\n+                if (successSet.size() > 0) {\n+                    Pipeline pipeline2 = jedis.pipelined();\n+                    successSet.forEach(locKey ->\n+                            pipeline2.hdel(locKey, XID, TRANSACTION_ID, BRANCH_ID, RESOURCE_ID,\n+                                    TABLE_NAME, ROW_KEY, PK));\n+                    pipeline2.sync();\n                 }\n                 return false;\n-            } else {\n-                try {\n-                    String xidLockKey = getXidLockKey(locks.get(0).getXid());\n-                    jedis.lpush(xidLockKey, readyKeys.toArray(new String[0]));\n-                } catch (Exception e) {\n-                    return false;\n-                }\n-                return true;\n             }\n+            String xidLockKey = buildXidLockKey(needLockXid);\n+            StringJoiner lockKeysString = new StringJoiner(SEMICOLON);\n+            needLockKeys.stream().forEach(lockKey -> lockKeysString.add(lockKey));\n+            jedis.hsetnx(xidLockKey, branchId.toString(), lockKeysString.toString());\n+            return true;\n         }\n     }\n \n     @Override\n     public boolean releaseLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        String[] keys = new String[rowLocks.size()];\n-        List<LockDO> locks = convertToLockDO(rowLocks);\n-        for (int i = 0; i < locks.size(); i++) {\n-            String key = getLockKey(locks.get(i).getRowKey());\n-            keys[i] = key;\n-        }\n+        String currentXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+        List<String> needReleaseKeys = new ArrayList<>(rowLocks.size());\n+        List<LockDO> needReleaseLocks = convertToLockDO(rowLocks);\n+        needReleaseLocks.stream()\n+                .forEach(lockDO -> needReleaseKeys.add(buildLockKey(lockDO.getRowKey())));\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String xidLockKey = getXidLockKey(locks.get(0).getXid());\n-            Pipeline pipeline = jedis.pipelined();\n-            pipeline.del(keys);\n-            Arrays.stream(keys).forEach(key -> pipeline.lrem(xidLockKey, 0, key));\n-            pipeline.sync();\n+            Pipeline pipelined = jedis.pipelined();\n+            needReleaseKeys.stream()\n+                    .forEach(key -> pipelined.hmget(key, XID, TABLE_NAME, PK, BRANCH_ID));\n+            List<Object> existedObjs = pipelined.syncAndReturnAll();\n+            List<List<String>> existedLockInfos = (List<List<String>>) (List) existedObjs;\n+\n+            for (int i = 0; i < existedLockInfos.size(); i++) {\n+                List<String> existedLockInfo = existedLockInfos.get(i);\n+                if (CollectionUtils.isNotEmpty(existedLockInfo) ||\n+                        existedLockInfo.stream().allMatch(info -> info != null)) {\n+                    if (!StringUtils.equals(currentXid, existedLockInfo.get(0))) {\n+                        LOGGER.error(\n+                                \"Release lock failed,Global lock on [{}:{}] is holding by xid {} branchId {}\",\n+                                existedLockInfo.get(1), existedLockInfo.get(2),\n+                                existedLockInfo.get(0), existedLockInfo.get(3));\n+                        return false;\n+                    }\n+                }\n+            }\n+\n+            Pipeline pipelined1 = jedis.pipelined();\n+            needReleaseKeys.stream().forEach(key ->\n+                    pipelined1.hdel(key, XID, TRANSACTION_ID, BRANCH_ID, RESOURCE_ID,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjAwNTU2NA=="}, "originalCommit": {"oid": "1f4cca9c462a0d18a58d8cdd23a7d97fdbaaeb4a"}, "originalPosition": 258}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MDQwNTg2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwODozNTo1MVrOHCJTIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMjowNDoxM1rOHCQTNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjAxMTU1NQ==", "bodyText": "del rowkey", "url": "https://github.com/seata/seata/pull/3016#discussion_r472011555", "createdAt": "2020-08-18T08:35:51Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -60,131 +87,179 @@\n      */\n     public RedisLocker() {\n         logQueryLimit =\n-            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+                ConfigurationFactory.getInstance()\n+                        .getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n     }\n \n     @Override\n     public boolean acquireLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        Set<String> successList = new HashSet<>();\n-        long status = 1;\n+        Integer status = SUCCEED;\n+        String needLockXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            List<LockDO> locks = convertToLockDO(rowLocks);\n-            if (locks.size() > 1) {\n-                locks =\n-                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            List<LockDO> needLockDOS = convertToLockDO(rowLocks);\n+            if (needLockDOS.size() >= 1) {\n+                needLockDOS = needLockDOS.stream().\n+                        filter(LambdaUtils.distinctByKey(LockDO::getRowKey))\n+                        .collect(Collectors.toList());\n             }\n-            List<String> existedKeyList = new ArrayList<>();\n-            locks.forEach(lockDO -> {\n-                existedKeyList.add(getLockKey(lockDO.getRowKey()));\n-            });\n-            List<String> lockList = jedis.mget(existedKeyList.toArray(new String[0]));\n-            Map<String, String> map = new HashMap<>(existedKeyList.size(), 1);\n-            for (int i = 0; i < existedKeyList.size(); i++) {\n-                String existedValue = lockList.get(i);\n-                if (existedValue == null) {\n-                    String key = existedKeyList.get(i);\n-                    map.put(key, JSON.toJSONString(locks.get(i)));\n+            List<String> needLockKeys = new ArrayList<>();\n+            needLockDOS.forEach(lockDO -> needLockKeys.add(buildLockKey(lockDO.getRowKey())));\n+\n+            Pipeline pipeline1 = jedis.pipelined();\n+            needLockKeys.stream().forEachOrdered(\n+                    needLockKey -> pipeline1.hmget(needLockKey, XID, TABLE_NAME, PK, BRANCH_ID));\n+            List<Object> existedObjs = pipeline1.syncAndReturnAll();\n+            List<List<String>> existedLockInfos = (List<List<String>>) (List) existedObjs;\n+            Map<String, LockDO> needAddLock = new HashMap<>(needLockKeys.size(), 1);\n+\n+            for (int i = 0; i < needLockKeys.size(); i++) {\n+                List<String> existedLockInfo = existedLockInfos.get(i);\n+                if (CollectionUtils.isEmpty(existedLockInfo) ||\n+                        existedLockInfo.stream().allMatch(info -> info == null)) {\n+                    //If empty,we need to lock this row\n+                    needAddLock.put(needLockKeys.get(i), needLockDOS.get(i));\n                 } else {\n-                    LockDO existed = JSON.parseObject(existedValue, LockDO.class);\n-                    if (!StringUtils.equals(existed.getXid(), locks.get(i).getXid())) {\n+                    if (!StringUtils.equals(existedLockInfo.get(0), needLockXid)) {\n+                        //If not equals,means the rowkey is holding by another global transaction\n+                        LOGGER.error(\n+                                \"Acquire lock failed,Global lock on [{}:{}] is holding by xid {} branchId {}\",\n+                                existedLockInfo.get(1), existedLockInfo.get(2),\n+                                existedLockInfo.get(0), existedLockInfo.get(3));\n                         return false;\n                     }\n                 }\n             }\n-            if (map.isEmpty()) {\n+\n+            if (needAddLock.isEmpty()) {\n                 return true;\n             }\n             Pipeline pipeline = jedis.pipelined();\n             List<String> readyKeys = new ArrayList<>();\n-            map.forEach((key, value) -> {\n-                pipeline.setnx(key, value);\n+            needAddLock.forEach((key, value) -> {\n+                pipeline.hsetnx(key, XID, value.getXid());\n+                pipeline.hsetnx(key, TRANSACTION_ID, value.getTransactionId().toString());\n+                pipeline.hsetnx(key, BRANCH_ID, value.getBranchId().toString());\n+                pipeline.hsetnx(key, RESOURCE_ID, value.getResourceId());\n+                pipeline.hsetnx(key, TABLE_NAME, value.getTableName());\n+                pipeline.hsetnx(key, ROW_KEY, value.getRowKey());\n+                pipeline.hsetnx(key, PK, value.getPk());\n                 readyKeys.add(key);\n             });\n             List<Object> results = pipeline.syncAndReturnAll();\n-            for (int i = 0; i < results.size(); i++) {\n-                Long result = (long)results.get(i);\n+            List<Integer> results2 = (List<Integer>) (List) results;\n+            List<List<Integer>> partitions = Lists.partition(results2, 7);\n+\n+            Set<String> successSet = new HashSet<>();\n+            for (int i = 0; i < partitions.size(); i++) {\n                 String key = readyKeys.get(i);\n-                if (result != 1) {\n-                    status = result;\n+                if (partitions.get(i).contains(FAILED)) {\n+                    status = FAILED;\n                 } else {\n-                    successList.add(key);\n+                    successSet.add(key);\n                 }\n             }\n-            if (status != 1) {\n-                String[] rms = successList.toArray(new String[0]);\n-                if (rms.length > 0) {\n-                    jedis.del(rms);\n+\n+            //If someone has failed,all the lockkey which has been added need to be delete.\n+            if (FAILED.equals(status)) {\n+                if (successSet.size() > 0) {\n+                    Pipeline pipeline2 = jedis.pipelined();\n+                    successSet.forEach(locKey ->\n+                            pipeline2.hdel(locKey, XID, TRANSACTION_ID, BRANCH_ID, RESOURCE_ID,\n+                                    TABLE_NAME, ROW_KEY, PK));\n+                    pipeline2.sync();\n                 }\n                 return false;\n-            } else {\n-                try {\n-                    String xidLockKey = getXidLockKey(locks.get(0).getXid());\n-                    jedis.lpush(xidLockKey, readyKeys.toArray(new String[0]));\n-                } catch (Exception e) {\n-                    return false;\n-                }\n-                return true;\n             }\n+            String xidLockKey = buildXidLockKey(needLockXid);\n+            StringJoiner lockKeysString = new StringJoiner(SEMICOLON);\n+            needLockKeys.stream().forEach(lockKey -> lockKeysString.add(lockKey));\n+            jedis.hsetnx(xidLockKey, branchId.toString(), lockKeysString.toString());\n+            return true;\n         }\n     }\n \n     @Override\n     public boolean releaseLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        String[] keys = new String[rowLocks.size()];\n-        List<LockDO> locks = convertToLockDO(rowLocks);\n-        for (int i = 0; i < locks.size(); i++) {\n-            String key = getLockKey(locks.get(i).getRowKey());\n-            keys[i] = key;\n-        }\n+        String currentXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+        List<String> needReleaseKeys = new ArrayList<>(rowLocks.size());\n+        List<LockDO> needReleaseLocks = convertToLockDO(rowLocks);\n+        needReleaseLocks.stream()\n+                .forEach(lockDO -> needReleaseKeys.add(buildLockKey(lockDO.getRowKey())));\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String xidLockKey = getXidLockKey(locks.get(0).getXid());\n-            Pipeline pipeline = jedis.pipelined();\n-            pipeline.del(keys);\n-            Arrays.stream(keys).forEach(key -> pipeline.lrem(xidLockKey, 0, key));\n-            pipeline.sync();\n+            Pipeline pipelined = jedis.pipelined();\n+            needReleaseKeys.stream()\n+                    .forEach(key -> pipelined.hmget(key, XID, TABLE_NAME, PK, BRANCH_ID));\n+            List<Object> existedObjs = pipelined.syncAndReturnAll();\n+            List<List<String>> existedLockInfos = (List<List<String>>) (List) existedObjs;\n+\n+            for (int i = 0; i < existedLockInfos.size(); i++) {\n+                List<String> existedLockInfo = existedLockInfos.get(i);\n+                if (CollectionUtils.isNotEmpty(existedLockInfo) ||\n+                        existedLockInfo.stream().allMatch(info -> info != null)) {\n+                    if (!StringUtils.equals(currentXid, existedLockInfo.get(0))) {\n+                        LOGGER.error(\n+                                \"Release lock failed,Global lock on [{}:{}] is holding by xid {} branchId {}\",\n+                                existedLockInfo.get(1), existedLockInfo.get(2),\n+                                existedLockInfo.get(0), existedLockInfo.get(3));\n+                        return false;\n+                    }\n+                }\n+            }\n+\n+            Pipeline pipelined1 = jedis.pipelined();\n+            needReleaseKeys.stream().forEach(key ->\n+                    pipelined1.hdel(key, XID, TRANSACTION_ID, BRANCH_ID, RESOURCE_ID,\n+                            TABLE_NAME, ROW_KEY, PK));\n+            pipelined1.hdel(buildXidLockKey(currentXid), branchId.toString());\n+            pipelined1.sync();\n             return true;\n         }\n     }\n \n     @Override\n     public boolean releaseLock(String xid, List<Long> branchIds) {\n         if (CollectionUtils.isEmpty(branchIds)) {\n-            // no lock\n             return true;\n         }\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String lockListKey = getXidLockKey(xid);\n-            Set<String> keys = lRange(jedis, lockListKey);\n-            if (CollectionUtils.isNotEmpty(keys)) {\n-                List<String> delKeys = new ArrayList<>();\n-                List<String> values = jedis.mget(keys.toArray(new String[0]));\n-                for (String value : values) {\n-                    Iterator<Long> it = branchIds.iterator();\n-                    LockDO lock = JSON.parseObject(value, LockDO.class);\n-                    while (it.hasNext()) {\n-                        Long branchId = it.next();\n-                        if (lock != null && Objects.equals(lock.getBranchId(), branchId)) {\n-                            delKeys.add(getLockKey(lock.getRowKey()));\n-                            break;\n+            String xidLockKey = buildXidLockKey(xid);\n+            String[] branchIdsArray = new String[branchIds.size()];\n+            for (int i = 0; i < branchIds.size(); i++) {\n+                branchIdsArray[i] = branchIds.get(i).toString();\n+            }\n+            List<String> rowKeys = jedis.hmget(xidLockKey, branchIdsArray);\n+\n+            if (CollectionUtils.isNotEmpty(rowKeys)) {\n+                Pipeline pipelined = jedis.pipelined();\n+                pipelined.hdel(xidLockKey, branchIdsArray);\n+                rowKeys.stream().forEach(rowKeyStr -> {\n+                    if (StringUtils.isNotEmpty(rowKeyStr)) {\n+                        if (rowKeyStr.contains(SEMICOLON)) {\n+                            String[] keys = rowKeyStr.split(SEMICOLON);\n+                            Arrays.asList(keys).stream().forEach(rowKey -> {\n+                                if (StringUtils.isNotEmpty(rowKey)) {\n+                                    pipelined.hdel(rowKey, XID, TRANSACTION_ID, BRANCH_ID,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f4cca9c462a0d18a58d8cdd23a7d97fdbaaeb4a"}, "originalPosition": 302}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjEyNjI2Mw==", "bodyText": "finished", "url": "https://github.com/seata/seata/pull/3016#discussion_r472126263", "createdAt": "2020-08-18T12:04:13Z", "author": {"login": "lightClouds917"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -60,131 +87,179 @@\n      */\n     public RedisLocker() {\n         logQueryLimit =\n-            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+                ConfigurationFactory.getInstance()\n+                        .getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n     }\n \n     @Override\n     public boolean acquireLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        Set<String> successList = new HashSet<>();\n-        long status = 1;\n+        Integer status = SUCCEED;\n+        String needLockXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            List<LockDO> locks = convertToLockDO(rowLocks);\n-            if (locks.size() > 1) {\n-                locks =\n-                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            List<LockDO> needLockDOS = convertToLockDO(rowLocks);\n+            if (needLockDOS.size() >= 1) {\n+                needLockDOS = needLockDOS.stream().\n+                        filter(LambdaUtils.distinctByKey(LockDO::getRowKey))\n+                        .collect(Collectors.toList());\n             }\n-            List<String> existedKeyList = new ArrayList<>();\n-            locks.forEach(lockDO -> {\n-                existedKeyList.add(getLockKey(lockDO.getRowKey()));\n-            });\n-            List<String> lockList = jedis.mget(existedKeyList.toArray(new String[0]));\n-            Map<String, String> map = new HashMap<>(existedKeyList.size(), 1);\n-            for (int i = 0; i < existedKeyList.size(); i++) {\n-                String existedValue = lockList.get(i);\n-                if (existedValue == null) {\n-                    String key = existedKeyList.get(i);\n-                    map.put(key, JSON.toJSONString(locks.get(i)));\n+            List<String> needLockKeys = new ArrayList<>();\n+            needLockDOS.forEach(lockDO -> needLockKeys.add(buildLockKey(lockDO.getRowKey())));\n+\n+            Pipeline pipeline1 = jedis.pipelined();\n+            needLockKeys.stream().forEachOrdered(\n+                    needLockKey -> pipeline1.hmget(needLockKey, XID, TABLE_NAME, PK, BRANCH_ID));\n+            List<Object> existedObjs = pipeline1.syncAndReturnAll();\n+            List<List<String>> existedLockInfos = (List<List<String>>) (List) existedObjs;\n+            Map<String, LockDO> needAddLock = new HashMap<>(needLockKeys.size(), 1);\n+\n+            for (int i = 0; i < needLockKeys.size(); i++) {\n+                List<String> existedLockInfo = existedLockInfos.get(i);\n+                if (CollectionUtils.isEmpty(existedLockInfo) ||\n+                        existedLockInfo.stream().allMatch(info -> info == null)) {\n+                    //If empty,we need to lock this row\n+                    needAddLock.put(needLockKeys.get(i), needLockDOS.get(i));\n                 } else {\n-                    LockDO existed = JSON.parseObject(existedValue, LockDO.class);\n-                    if (!StringUtils.equals(existed.getXid(), locks.get(i).getXid())) {\n+                    if (!StringUtils.equals(existedLockInfo.get(0), needLockXid)) {\n+                        //If not equals,means the rowkey is holding by another global transaction\n+                        LOGGER.error(\n+                                \"Acquire lock failed,Global lock on [{}:{}] is holding by xid {} branchId {}\",\n+                                existedLockInfo.get(1), existedLockInfo.get(2),\n+                                existedLockInfo.get(0), existedLockInfo.get(3));\n                         return false;\n                     }\n                 }\n             }\n-            if (map.isEmpty()) {\n+\n+            if (needAddLock.isEmpty()) {\n                 return true;\n             }\n             Pipeline pipeline = jedis.pipelined();\n             List<String> readyKeys = new ArrayList<>();\n-            map.forEach((key, value) -> {\n-                pipeline.setnx(key, value);\n+            needAddLock.forEach((key, value) -> {\n+                pipeline.hsetnx(key, XID, value.getXid());\n+                pipeline.hsetnx(key, TRANSACTION_ID, value.getTransactionId().toString());\n+                pipeline.hsetnx(key, BRANCH_ID, value.getBranchId().toString());\n+                pipeline.hsetnx(key, RESOURCE_ID, value.getResourceId());\n+                pipeline.hsetnx(key, TABLE_NAME, value.getTableName());\n+                pipeline.hsetnx(key, ROW_KEY, value.getRowKey());\n+                pipeline.hsetnx(key, PK, value.getPk());\n                 readyKeys.add(key);\n             });\n             List<Object> results = pipeline.syncAndReturnAll();\n-            for (int i = 0; i < results.size(); i++) {\n-                Long result = (long)results.get(i);\n+            List<Integer> results2 = (List<Integer>) (List) results;\n+            List<List<Integer>> partitions = Lists.partition(results2, 7);\n+\n+            Set<String> successSet = new HashSet<>();\n+            for (int i = 0; i < partitions.size(); i++) {\n                 String key = readyKeys.get(i);\n-                if (result != 1) {\n-                    status = result;\n+                if (partitions.get(i).contains(FAILED)) {\n+                    status = FAILED;\n                 } else {\n-                    successList.add(key);\n+                    successSet.add(key);\n                 }\n             }\n-            if (status != 1) {\n-                String[] rms = successList.toArray(new String[0]);\n-                if (rms.length > 0) {\n-                    jedis.del(rms);\n+\n+            //If someone has failed,all the lockkey which has been added need to be delete.\n+            if (FAILED.equals(status)) {\n+                if (successSet.size() > 0) {\n+                    Pipeline pipeline2 = jedis.pipelined();\n+                    successSet.forEach(locKey ->\n+                            pipeline2.hdel(locKey, XID, TRANSACTION_ID, BRANCH_ID, RESOURCE_ID,\n+                                    TABLE_NAME, ROW_KEY, PK));\n+                    pipeline2.sync();\n                 }\n                 return false;\n-            } else {\n-                try {\n-                    String xidLockKey = getXidLockKey(locks.get(0).getXid());\n-                    jedis.lpush(xidLockKey, readyKeys.toArray(new String[0]));\n-                } catch (Exception e) {\n-                    return false;\n-                }\n-                return true;\n             }\n+            String xidLockKey = buildXidLockKey(needLockXid);\n+            StringJoiner lockKeysString = new StringJoiner(SEMICOLON);\n+            needLockKeys.stream().forEach(lockKey -> lockKeysString.add(lockKey));\n+            jedis.hsetnx(xidLockKey, branchId.toString(), lockKeysString.toString());\n+            return true;\n         }\n     }\n \n     @Override\n     public boolean releaseLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        String[] keys = new String[rowLocks.size()];\n-        List<LockDO> locks = convertToLockDO(rowLocks);\n-        for (int i = 0; i < locks.size(); i++) {\n-            String key = getLockKey(locks.get(i).getRowKey());\n-            keys[i] = key;\n-        }\n+        String currentXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+        List<String> needReleaseKeys = new ArrayList<>(rowLocks.size());\n+        List<LockDO> needReleaseLocks = convertToLockDO(rowLocks);\n+        needReleaseLocks.stream()\n+                .forEach(lockDO -> needReleaseKeys.add(buildLockKey(lockDO.getRowKey())));\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String xidLockKey = getXidLockKey(locks.get(0).getXid());\n-            Pipeline pipeline = jedis.pipelined();\n-            pipeline.del(keys);\n-            Arrays.stream(keys).forEach(key -> pipeline.lrem(xidLockKey, 0, key));\n-            pipeline.sync();\n+            Pipeline pipelined = jedis.pipelined();\n+            needReleaseKeys.stream()\n+                    .forEach(key -> pipelined.hmget(key, XID, TABLE_NAME, PK, BRANCH_ID));\n+            List<Object> existedObjs = pipelined.syncAndReturnAll();\n+            List<List<String>> existedLockInfos = (List<List<String>>) (List) existedObjs;\n+\n+            for (int i = 0; i < existedLockInfos.size(); i++) {\n+                List<String> existedLockInfo = existedLockInfos.get(i);\n+                if (CollectionUtils.isNotEmpty(existedLockInfo) ||\n+                        existedLockInfo.stream().allMatch(info -> info != null)) {\n+                    if (!StringUtils.equals(currentXid, existedLockInfo.get(0))) {\n+                        LOGGER.error(\n+                                \"Release lock failed,Global lock on [{}:{}] is holding by xid {} branchId {}\",\n+                                existedLockInfo.get(1), existedLockInfo.get(2),\n+                                existedLockInfo.get(0), existedLockInfo.get(3));\n+                        return false;\n+                    }\n+                }\n+            }\n+\n+            Pipeline pipelined1 = jedis.pipelined();\n+            needReleaseKeys.stream().forEach(key ->\n+                    pipelined1.hdel(key, XID, TRANSACTION_ID, BRANCH_ID, RESOURCE_ID,\n+                            TABLE_NAME, ROW_KEY, PK));\n+            pipelined1.hdel(buildXidLockKey(currentXid), branchId.toString());\n+            pipelined1.sync();\n             return true;\n         }\n     }\n \n     @Override\n     public boolean releaseLock(String xid, List<Long> branchIds) {\n         if (CollectionUtils.isEmpty(branchIds)) {\n-            // no lock\n             return true;\n         }\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String lockListKey = getXidLockKey(xid);\n-            Set<String> keys = lRange(jedis, lockListKey);\n-            if (CollectionUtils.isNotEmpty(keys)) {\n-                List<String> delKeys = new ArrayList<>();\n-                List<String> values = jedis.mget(keys.toArray(new String[0]));\n-                for (String value : values) {\n-                    Iterator<Long> it = branchIds.iterator();\n-                    LockDO lock = JSON.parseObject(value, LockDO.class);\n-                    while (it.hasNext()) {\n-                        Long branchId = it.next();\n-                        if (lock != null && Objects.equals(lock.getBranchId(), branchId)) {\n-                            delKeys.add(getLockKey(lock.getRowKey()));\n-                            break;\n+            String xidLockKey = buildXidLockKey(xid);\n+            String[] branchIdsArray = new String[branchIds.size()];\n+            for (int i = 0; i < branchIds.size(); i++) {\n+                branchIdsArray[i] = branchIds.get(i).toString();\n+            }\n+            List<String> rowKeys = jedis.hmget(xidLockKey, branchIdsArray);\n+\n+            if (CollectionUtils.isNotEmpty(rowKeys)) {\n+                Pipeline pipelined = jedis.pipelined();\n+                pipelined.hdel(xidLockKey, branchIdsArray);\n+                rowKeys.stream().forEach(rowKeyStr -> {\n+                    if (StringUtils.isNotEmpty(rowKeyStr)) {\n+                        if (rowKeyStr.contains(SEMICOLON)) {\n+                            String[] keys = rowKeyStr.split(SEMICOLON);\n+                            Arrays.asList(keys).stream().forEach(rowKey -> {\n+                                if (StringUtils.isNotEmpty(rowKey)) {\n+                                    pipelined.hdel(rowKey, XID, TRANSACTION_ID, BRANCH_ID,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjAxMTU1NQ=="}, "originalCommit": {"oid": "1f4cca9c462a0d18a58d8cdd23a7d97fdbaaeb4a"}, "originalPosition": 302}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MDQwNjM2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwODozNTo1OFrOHCJTbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMjowNDoxOFrOHCQTaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjAxMTYzMQ==", "bodyText": "del rowkey", "url": "https://github.com/seata/seata/pull/3016#discussion_r472011631", "createdAt": "2020-08-18T08:35:58Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -60,131 +87,179 @@\n      */\n     public RedisLocker() {\n         logQueryLimit =\n-            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+                ConfigurationFactory.getInstance()\n+                        .getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n     }\n \n     @Override\n     public boolean acquireLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        Set<String> successList = new HashSet<>();\n-        long status = 1;\n+        Integer status = SUCCEED;\n+        String needLockXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            List<LockDO> locks = convertToLockDO(rowLocks);\n-            if (locks.size() > 1) {\n-                locks =\n-                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            List<LockDO> needLockDOS = convertToLockDO(rowLocks);\n+            if (needLockDOS.size() >= 1) {\n+                needLockDOS = needLockDOS.stream().\n+                        filter(LambdaUtils.distinctByKey(LockDO::getRowKey))\n+                        .collect(Collectors.toList());\n             }\n-            List<String> existedKeyList = new ArrayList<>();\n-            locks.forEach(lockDO -> {\n-                existedKeyList.add(getLockKey(lockDO.getRowKey()));\n-            });\n-            List<String> lockList = jedis.mget(existedKeyList.toArray(new String[0]));\n-            Map<String, String> map = new HashMap<>(existedKeyList.size(), 1);\n-            for (int i = 0; i < existedKeyList.size(); i++) {\n-                String existedValue = lockList.get(i);\n-                if (existedValue == null) {\n-                    String key = existedKeyList.get(i);\n-                    map.put(key, JSON.toJSONString(locks.get(i)));\n+            List<String> needLockKeys = new ArrayList<>();\n+            needLockDOS.forEach(lockDO -> needLockKeys.add(buildLockKey(lockDO.getRowKey())));\n+\n+            Pipeline pipeline1 = jedis.pipelined();\n+            needLockKeys.stream().forEachOrdered(\n+                    needLockKey -> pipeline1.hmget(needLockKey, XID, TABLE_NAME, PK, BRANCH_ID));\n+            List<Object> existedObjs = pipeline1.syncAndReturnAll();\n+            List<List<String>> existedLockInfos = (List<List<String>>) (List) existedObjs;\n+            Map<String, LockDO> needAddLock = new HashMap<>(needLockKeys.size(), 1);\n+\n+            for (int i = 0; i < needLockKeys.size(); i++) {\n+                List<String> existedLockInfo = existedLockInfos.get(i);\n+                if (CollectionUtils.isEmpty(existedLockInfo) ||\n+                        existedLockInfo.stream().allMatch(info -> info == null)) {\n+                    //If empty,we need to lock this row\n+                    needAddLock.put(needLockKeys.get(i), needLockDOS.get(i));\n                 } else {\n-                    LockDO existed = JSON.parseObject(existedValue, LockDO.class);\n-                    if (!StringUtils.equals(existed.getXid(), locks.get(i).getXid())) {\n+                    if (!StringUtils.equals(existedLockInfo.get(0), needLockXid)) {\n+                        //If not equals,means the rowkey is holding by another global transaction\n+                        LOGGER.error(\n+                                \"Acquire lock failed,Global lock on [{}:{}] is holding by xid {} branchId {}\",\n+                                existedLockInfo.get(1), existedLockInfo.get(2),\n+                                existedLockInfo.get(0), existedLockInfo.get(3));\n                         return false;\n                     }\n                 }\n             }\n-            if (map.isEmpty()) {\n+\n+            if (needAddLock.isEmpty()) {\n                 return true;\n             }\n             Pipeline pipeline = jedis.pipelined();\n             List<String> readyKeys = new ArrayList<>();\n-            map.forEach((key, value) -> {\n-                pipeline.setnx(key, value);\n+            needAddLock.forEach((key, value) -> {\n+                pipeline.hsetnx(key, XID, value.getXid());\n+                pipeline.hsetnx(key, TRANSACTION_ID, value.getTransactionId().toString());\n+                pipeline.hsetnx(key, BRANCH_ID, value.getBranchId().toString());\n+                pipeline.hsetnx(key, RESOURCE_ID, value.getResourceId());\n+                pipeline.hsetnx(key, TABLE_NAME, value.getTableName());\n+                pipeline.hsetnx(key, ROW_KEY, value.getRowKey());\n+                pipeline.hsetnx(key, PK, value.getPk());\n                 readyKeys.add(key);\n             });\n             List<Object> results = pipeline.syncAndReturnAll();\n-            for (int i = 0; i < results.size(); i++) {\n-                Long result = (long)results.get(i);\n+            List<Integer> results2 = (List<Integer>) (List) results;\n+            List<List<Integer>> partitions = Lists.partition(results2, 7);\n+\n+            Set<String> successSet = new HashSet<>();\n+            for (int i = 0; i < partitions.size(); i++) {\n                 String key = readyKeys.get(i);\n-                if (result != 1) {\n-                    status = result;\n+                if (partitions.get(i).contains(FAILED)) {\n+                    status = FAILED;\n                 } else {\n-                    successList.add(key);\n+                    successSet.add(key);\n                 }\n             }\n-            if (status != 1) {\n-                String[] rms = successList.toArray(new String[0]);\n-                if (rms.length > 0) {\n-                    jedis.del(rms);\n+\n+            //If someone has failed,all the lockkey which has been added need to be delete.\n+            if (FAILED.equals(status)) {\n+                if (successSet.size() > 0) {\n+                    Pipeline pipeline2 = jedis.pipelined();\n+                    successSet.forEach(locKey ->\n+                            pipeline2.hdel(locKey, XID, TRANSACTION_ID, BRANCH_ID, RESOURCE_ID,\n+                                    TABLE_NAME, ROW_KEY, PK));\n+                    pipeline2.sync();\n                 }\n                 return false;\n-            } else {\n-                try {\n-                    String xidLockKey = getXidLockKey(locks.get(0).getXid());\n-                    jedis.lpush(xidLockKey, readyKeys.toArray(new String[0]));\n-                } catch (Exception e) {\n-                    return false;\n-                }\n-                return true;\n             }\n+            String xidLockKey = buildXidLockKey(needLockXid);\n+            StringJoiner lockKeysString = new StringJoiner(SEMICOLON);\n+            needLockKeys.stream().forEach(lockKey -> lockKeysString.add(lockKey));\n+            jedis.hsetnx(xidLockKey, branchId.toString(), lockKeysString.toString());\n+            return true;\n         }\n     }\n \n     @Override\n     public boolean releaseLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        String[] keys = new String[rowLocks.size()];\n-        List<LockDO> locks = convertToLockDO(rowLocks);\n-        for (int i = 0; i < locks.size(); i++) {\n-            String key = getLockKey(locks.get(i).getRowKey());\n-            keys[i] = key;\n-        }\n+        String currentXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+        List<String> needReleaseKeys = new ArrayList<>(rowLocks.size());\n+        List<LockDO> needReleaseLocks = convertToLockDO(rowLocks);\n+        needReleaseLocks.stream()\n+                .forEach(lockDO -> needReleaseKeys.add(buildLockKey(lockDO.getRowKey())));\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String xidLockKey = getXidLockKey(locks.get(0).getXid());\n-            Pipeline pipeline = jedis.pipelined();\n-            pipeline.del(keys);\n-            Arrays.stream(keys).forEach(key -> pipeline.lrem(xidLockKey, 0, key));\n-            pipeline.sync();\n+            Pipeline pipelined = jedis.pipelined();\n+            needReleaseKeys.stream()\n+                    .forEach(key -> pipelined.hmget(key, XID, TABLE_NAME, PK, BRANCH_ID));\n+            List<Object> existedObjs = pipelined.syncAndReturnAll();\n+            List<List<String>> existedLockInfos = (List<List<String>>) (List) existedObjs;\n+\n+            for (int i = 0; i < existedLockInfos.size(); i++) {\n+                List<String> existedLockInfo = existedLockInfos.get(i);\n+                if (CollectionUtils.isNotEmpty(existedLockInfo) ||\n+                        existedLockInfo.stream().allMatch(info -> info != null)) {\n+                    if (!StringUtils.equals(currentXid, existedLockInfo.get(0))) {\n+                        LOGGER.error(\n+                                \"Release lock failed,Global lock on [{}:{}] is holding by xid {} branchId {}\",\n+                                existedLockInfo.get(1), existedLockInfo.get(2),\n+                                existedLockInfo.get(0), existedLockInfo.get(3));\n+                        return false;\n+                    }\n+                }\n+            }\n+\n+            Pipeline pipelined1 = jedis.pipelined();\n+            needReleaseKeys.stream().forEach(key ->\n+                    pipelined1.hdel(key, XID, TRANSACTION_ID, BRANCH_ID, RESOURCE_ID,\n+                            TABLE_NAME, ROW_KEY, PK));\n+            pipelined1.hdel(buildXidLockKey(currentXid), branchId.toString());\n+            pipelined1.sync();\n             return true;\n         }\n     }\n \n     @Override\n     public boolean releaseLock(String xid, List<Long> branchIds) {\n         if (CollectionUtils.isEmpty(branchIds)) {\n-            // no lock\n             return true;\n         }\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String lockListKey = getXidLockKey(xid);\n-            Set<String> keys = lRange(jedis, lockListKey);\n-            if (CollectionUtils.isNotEmpty(keys)) {\n-                List<String> delKeys = new ArrayList<>();\n-                List<String> values = jedis.mget(keys.toArray(new String[0]));\n-                for (String value : values) {\n-                    Iterator<Long> it = branchIds.iterator();\n-                    LockDO lock = JSON.parseObject(value, LockDO.class);\n-                    while (it.hasNext()) {\n-                        Long branchId = it.next();\n-                        if (lock != null && Objects.equals(lock.getBranchId(), branchId)) {\n-                            delKeys.add(getLockKey(lock.getRowKey()));\n-                            break;\n+            String xidLockKey = buildXidLockKey(xid);\n+            String[] branchIdsArray = new String[branchIds.size()];\n+            for (int i = 0; i < branchIds.size(); i++) {\n+                branchIdsArray[i] = branchIds.get(i).toString();\n+            }\n+            List<String> rowKeys = jedis.hmget(xidLockKey, branchIdsArray);\n+\n+            if (CollectionUtils.isNotEmpty(rowKeys)) {\n+                Pipeline pipelined = jedis.pipelined();\n+                pipelined.hdel(xidLockKey, branchIdsArray);\n+                rowKeys.stream().forEach(rowKeyStr -> {\n+                    if (StringUtils.isNotEmpty(rowKeyStr)) {\n+                        if (rowKeyStr.contains(SEMICOLON)) {\n+                            String[] keys = rowKeyStr.split(SEMICOLON);\n+                            Arrays.asList(keys).stream().forEach(rowKey -> {\n+                                if (StringUtils.isNotEmpty(rowKey)) {\n+                                    pipelined.hdel(rowKey, XID, TRANSACTION_ID, BRANCH_ID,\n+                                            RESOURCE_ID, TABLE_NAME, ROW_KEY, PK);\n+                                }\n+                            });\n+                        } else {\n+                            pipelined.hdel(rowKeyStr, XID, TRANSACTION_ID, BRANCH_ID, RESOURCE_ID,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f4cca9c462a0d18a58d8cdd23a7d97fdbaaeb4a"}, "originalPosition": 307}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjEyNjMxNQ==", "bodyText": "finished", "url": "https://github.com/seata/seata/pull/3016#discussion_r472126315", "createdAt": "2020-08-18T12:04:18Z", "author": {"login": "lightClouds917"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -60,131 +87,179 @@\n      */\n     public RedisLocker() {\n         logQueryLimit =\n-            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+                ConfigurationFactory.getInstance()\n+                        .getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n     }\n \n     @Override\n     public boolean acquireLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        Set<String> successList = new HashSet<>();\n-        long status = 1;\n+        Integer status = SUCCEED;\n+        String needLockXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            List<LockDO> locks = convertToLockDO(rowLocks);\n-            if (locks.size() > 1) {\n-                locks =\n-                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            List<LockDO> needLockDOS = convertToLockDO(rowLocks);\n+            if (needLockDOS.size() >= 1) {\n+                needLockDOS = needLockDOS.stream().\n+                        filter(LambdaUtils.distinctByKey(LockDO::getRowKey))\n+                        .collect(Collectors.toList());\n             }\n-            List<String> existedKeyList = new ArrayList<>();\n-            locks.forEach(lockDO -> {\n-                existedKeyList.add(getLockKey(lockDO.getRowKey()));\n-            });\n-            List<String> lockList = jedis.mget(existedKeyList.toArray(new String[0]));\n-            Map<String, String> map = new HashMap<>(existedKeyList.size(), 1);\n-            for (int i = 0; i < existedKeyList.size(); i++) {\n-                String existedValue = lockList.get(i);\n-                if (existedValue == null) {\n-                    String key = existedKeyList.get(i);\n-                    map.put(key, JSON.toJSONString(locks.get(i)));\n+            List<String> needLockKeys = new ArrayList<>();\n+            needLockDOS.forEach(lockDO -> needLockKeys.add(buildLockKey(lockDO.getRowKey())));\n+\n+            Pipeline pipeline1 = jedis.pipelined();\n+            needLockKeys.stream().forEachOrdered(\n+                    needLockKey -> pipeline1.hmget(needLockKey, XID, TABLE_NAME, PK, BRANCH_ID));\n+            List<Object> existedObjs = pipeline1.syncAndReturnAll();\n+            List<List<String>> existedLockInfos = (List<List<String>>) (List) existedObjs;\n+            Map<String, LockDO> needAddLock = new HashMap<>(needLockKeys.size(), 1);\n+\n+            for (int i = 0; i < needLockKeys.size(); i++) {\n+                List<String> existedLockInfo = existedLockInfos.get(i);\n+                if (CollectionUtils.isEmpty(existedLockInfo) ||\n+                        existedLockInfo.stream().allMatch(info -> info == null)) {\n+                    //If empty,we need to lock this row\n+                    needAddLock.put(needLockKeys.get(i), needLockDOS.get(i));\n                 } else {\n-                    LockDO existed = JSON.parseObject(existedValue, LockDO.class);\n-                    if (!StringUtils.equals(existed.getXid(), locks.get(i).getXid())) {\n+                    if (!StringUtils.equals(existedLockInfo.get(0), needLockXid)) {\n+                        //If not equals,means the rowkey is holding by another global transaction\n+                        LOGGER.error(\n+                                \"Acquire lock failed,Global lock on [{}:{}] is holding by xid {} branchId {}\",\n+                                existedLockInfo.get(1), existedLockInfo.get(2),\n+                                existedLockInfo.get(0), existedLockInfo.get(3));\n                         return false;\n                     }\n                 }\n             }\n-            if (map.isEmpty()) {\n+\n+            if (needAddLock.isEmpty()) {\n                 return true;\n             }\n             Pipeline pipeline = jedis.pipelined();\n             List<String> readyKeys = new ArrayList<>();\n-            map.forEach((key, value) -> {\n-                pipeline.setnx(key, value);\n+            needAddLock.forEach((key, value) -> {\n+                pipeline.hsetnx(key, XID, value.getXid());\n+                pipeline.hsetnx(key, TRANSACTION_ID, value.getTransactionId().toString());\n+                pipeline.hsetnx(key, BRANCH_ID, value.getBranchId().toString());\n+                pipeline.hsetnx(key, RESOURCE_ID, value.getResourceId());\n+                pipeline.hsetnx(key, TABLE_NAME, value.getTableName());\n+                pipeline.hsetnx(key, ROW_KEY, value.getRowKey());\n+                pipeline.hsetnx(key, PK, value.getPk());\n                 readyKeys.add(key);\n             });\n             List<Object> results = pipeline.syncAndReturnAll();\n-            for (int i = 0; i < results.size(); i++) {\n-                Long result = (long)results.get(i);\n+            List<Integer> results2 = (List<Integer>) (List) results;\n+            List<List<Integer>> partitions = Lists.partition(results2, 7);\n+\n+            Set<String> successSet = new HashSet<>();\n+            for (int i = 0; i < partitions.size(); i++) {\n                 String key = readyKeys.get(i);\n-                if (result != 1) {\n-                    status = result;\n+                if (partitions.get(i).contains(FAILED)) {\n+                    status = FAILED;\n                 } else {\n-                    successList.add(key);\n+                    successSet.add(key);\n                 }\n             }\n-            if (status != 1) {\n-                String[] rms = successList.toArray(new String[0]);\n-                if (rms.length > 0) {\n-                    jedis.del(rms);\n+\n+            //If someone has failed,all the lockkey which has been added need to be delete.\n+            if (FAILED.equals(status)) {\n+                if (successSet.size() > 0) {\n+                    Pipeline pipeline2 = jedis.pipelined();\n+                    successSet.forEach(locKey ->\n+                            pipeline2.hdel(locKey, XID, TRANSACTION_ID, BRANCH_ID, RESOURCE_ID,\n+                                    TABLE_NAME, ROW_KEY, PK));\n+                    pipeline2.sync();\n                 }\n                 return false;\n-            } else {\n-                try {\n-                    String xidLockKey = getXidLockKey(locks.get(0).getXid());\n-                    jedis.lpush(xidLockKey, readyKeys.toArray(new String[0]));\n-                } catch (Exception e) {\n-                    return false;\n-                }\n-                return true;\n             }\n+            String xidLockKey = buildXidLockKey(needLockXid);\n+            StringJoiner lockKeysString = new StringJoiner(SEMICOLON);\n+            needLockKeys.stream().forEach(lockKey -> lockKeysString.add(lockKey));\n+            jedis.hsetnx(xidLockKey, branchId.toString(), lockKeysString.toString());\n+            return true;\n         }\n     }\n \n     @Override\n     public boolean releaseLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        String[] keys = new String[rowLocks.size()];\n-        List<LockDO> locks = convertToLockDO(rowLocks);\n-        for (int i = 0; i < locks.size(); i++) {\n-            String key = getLockKey(locks.get(i).getRowKey());\n-            keys[i] = key;\n-        }\n+        String currentXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+        List<String> needReleaseKeys = new ArrayList<>(rowLocks.size());\n+        List<LockDO> needReleaseLocks = convertToLockDO(rowLocks);\n+        needReleaseLocks.stream()\n+                .forEach(lockDO -> needReleaseKeys.add(buildLockKey(lockDO.getRowKey())));\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String xidLockKey = getXidLockKey(locks.get(0).getXid());\n-            Pipeline pipeline = jedis.pipelined();\n-            pipeline.del(keys);\n-            Arrays.stream(keys).forEach(key -> pipeline.lrem(xidLockKey, 0, key));\n-            pipeline.sync();\n+            Pipeline pipelined = jedis.pipelined();\n+            needReleaseKeys.stream()\n+                    .forEach(key -> pipelined.hmget(key, XID, TABLE_NAME, PK, BRANCH_ID));\n+            List<Object> existedObjs = pipelined.syncAndReturnAll();\n+            List<List<String>> existedLockInfos = (List<List<String>>) (List) existedObjs;\n+\n+            for (int i = 0; i < existedLockInfos.size(); i++) {\n+                List<String> existedLockInfo = existedLockInfos.get(i);\n+                if (CollectionUtils.isNotEmpty(existedLockInfo) ||\n+                        existedLockInfo.stream().allMatch(info -> info != null)) {\n+                    if (!StringUtils.equals(currentXid, existedLockInfo.get(0))) {\n+                        LOGGER.error(\n+                                \"Release lock failed,Global lock on [{}:{}] is holding by xid {} branchId {}\",\n+                                existedLockInfo.get(1), existedLockInfo.get(2),\n+                                existedLockInfo.get(0), existedLockInfo.get(3));\n+                        return false;\n+                    }\n+                }\n+            }\n+\n+            Pipeline pipelined1 = jedis.pipelined();\n+            needReleaseKeys.stream().forEach(key ->\n+                    pipelined1.hdel(key, XID, TRANSACTION_ID, BRANCH_ID, RESOURCE_ID,\n+                            TABLE_NAME, ROW_KEY, PK));\n+            pipelined1.hdel(buildXidLockKey(currentXid), branchId.toString());\n+            pipelined1.sync();\n             return true;\n         }\n     }\n \n     @Override\n     public boolean releaseLock(String xid, List<Long> branchIds) {\n         if (CollectionUtils.isEmpty(branchIds)) {\n-            // no lock\n             return true;\n         }\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String lockListKey = getXidLockKey(xid);\n-            Set<String> keys = lRange(jedis, lockListKey);\n-            if (CollectionUtils.isNotEmpty(keys)) {\n-                List<String> delKeys = new ArrayList<>();\n-                List<String> values = jedis.mget(keys.toArray(new String[0]));\n-                for (String value : values) {\n-                    Iterator<Long> it = branchIds.iterator();\n-                    LockDO lock = JSON.parseObject(value, LockDO.class);\n-                    while (it.hasNext()) {\n-                        Long branchId = it.next();\n-                        if (lock != null && Objects.equals(lock.getBranchId(), branchId)) {\n-                            delKeys.add(getLockKey(lock.getRowKey()));\n-                            break;\n+            String xidLockKey = buildXidLockKey(xid);\n+            String[] branchIdsArray = new String[branchIds.size()];\n+            for (int i = 0; i < branchIds.size(); i++) {\n+                branchIdsArray[i] = branchIds.get(i).toString();\n+            }\n+            List<String> rowKeys = jedis.hmget(xidLockKey, branchIdsArray);\n+\n+            if (CollectionUtils.isNotEmpty(rowKeys)) {\n+                Pipeline pipelined = jedis.pipelined();\n+                pipelined.hdel(xidLockKey, branchIdsArray);\n+                rowKeys.stream().forEach(rowKeyStr -> {\n+                    if (StringUtils.isNotEmpty(rowKeyStr)) {\n+                        if (rowKeyStr.contains(SEMICOLON)) {\n+                            String[] keys = rowKeyStr.split(SEMICOLON);\n+                            Arrays.asList(keys).stream().forEach(rowKey -> {\n+                                if (StringUtils.isNotEmpty(rowKey)) {\n+                                    pipelined.hdel(rowKey, XID, TRANSACTION_ID, BRANCH_ID,\n+                                            RESOURCE_ID, TABLE_NAME, ROW_KEY, PK);\n+                                }\n+                            });\n+                        } else {\n+                            pipelined.hdel(rowKeyStr, XID, TRANSACTION_ID, BRANCH_ID, RESOURCE_ID,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjAxMTYzMQ=="}, "originalCommit": {"oid": "1f4cca9c462a0d18a58d8cdd23a7d97fdbaaeb4a"}, "originalPosition": 307}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MDQxMjY1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwODozNzozNFrOHCJXSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMjowNDoyMlrOHCQTgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjAxMjYxNw==", "bodyText": "List existedXids = (List) (List) pipeline.syncAndReturnAll();", "url": "https://github.com/seata/seata/pull/3016#discussion_r472012617", "createdAt": "2020-08-18T08:37:34Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -207,41 +282,23 @@ public boolean isLockable(List<RowLock> rowLocks) {\n             List<LockDO> locks = convertToLockDO(rowLocks);\n             Set<String> lockKeys = new HashSet<>();\n             for (LockDO rowlock : locks) {\n-                lockKeys.add(getLockKey(rowlock.getRowKey()));\n+                lockKeys.add(buildLockKey(rowlock.getRowKey()));\n             }\n-            List<String> rowlockJsons = jedis.mget(lockKeys.toArray(new String[0]));\n+\n             String xid = rowLocks.get(0).getXid();\n-            for (String rowlockJson : rowlockJsons) {\n-                if (!StringUtils.isEmpty(rowlockJson)) {\n-                    LockDO lock = JSON.parseObject(rowlockJson, LockDO.class);\n-                    if (lock != null && !Objects.equals(lock.getXid(), xid)) {\n-                        return false;\n-                    }\n-                }\n-            }\n+            Pipeline pipeline = jedis.pipelined();\n+            lockKeys.stream().forEach(key -> pipeline.hget(key, XID));\n+            List<Object> existedRowLockXid = pipeline.syncAndReturnAll();\n+            List<String> existedXids = (List<String>) (List) existedRowLockXid;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f4cca9c462a0d18a58d8cdd23a7d97fdbaaeb4a"}, "originalPosition": 347}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjEyNjMzNw==", "bodyText": "finished", "url": "https://github.com/seata/seata/pull/3016#discussion_r472126337", "createdAt": "2020-08-18T12:04:22Z", "author": {"login": "lightClouds917"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -207,41 +282,23 @@ public boolean isLockable(List<RowLock> rowLocks) {\n             List<LockDO> locks = convertToLockDO(rowLocks);\n             Set<String> lockKeys = new HashSet<>();\n             for (LockDO rowlock : locks) {\n-                lockKeys.add(getLockKey(rowlock.getRowKey()));\n+                lockKeys.add(buildLockKey(rowlock.getRowKey()));\n             }\n-            List<String> rowlockJsons = jedis.mget(lockKeys.toArray(new String[0]));\n+\n             String xid = rowLocks.get(0).getXid();\n-            for (String rowlockJson : rowlockJsons) {\n-                if (!StringUtils.isEmpty(rowlockJson)) {\n-                    LockDO lock = JSON.parseObject(rowlockJson, LockDO.class);\n-                    if (lock != null && !Objects.equals(lock.getXid(), xid)) {\n-                        return false;\n-                    }\n-                }\n-            }\n+            Pipeline pipeline = jedis.pipelined();\n+            lockKeys.stream().forEach(key -> pipeline.hget(key, XID));\n+            List<Object> existedRowLockXid = pipeline.syncAndReturnAll();\n+            List<String> existedXids = (List<String>) (List) existedRowLockXid;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjAxMjYxNw=="}, "originalCommit": {"oid": "1f4cca9c462a0d18a58d8cdd23a7d97fdbaaeb4a"}, "originalPosition": 347}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MTU2MTI0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMzoyNzowOFrOHCUgTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwMToxMTo0NFrOHCr27w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjE5NTE1MQ==", "bodyText": "hset enough", "url": "https://github.com/seata/seata/pull/3016#discussion_r472195151", "createdAt": "2020-08-18T13:27:08Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -60,131 +82,139 @@\n      */\n     public RedisLocker() {\n         logQueryLimit =\n-            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+                ConfigurationFactory.getInstance()\n+                        .getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n     }\n \n     @Override\n     public boolean acquireLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        Set<String> successList = new HashSet<>();\n-        long status = 1;\n+        Integer status = SUCCEED;\n+        String needLockXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            List<LockDO> locks = convertToLockDO(rowLocks);\n-            if (locks.size() > 1) {\n-                locks =\n-                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            List<LockDO> needLockDOS = convertToLockDO(rowLocks);\n+            if (needLockDOS.size() >= 1) {\n+                needLockDOS = needLockDOS.stream().\n+                        filter(LambdaUtils.distinctByKey(LockDO::getRowKey))\n+                        .collect(Collectors.toList());\n             }\n-            List<String> existedKeyList = new ArrayList<>();\n-            locks.forEach(lockDO -> {\n-                existedKeyList.add(getLockKey(lockDO.getRowKey()));\n-            });\n-            List<String> lockList = jedis.mget(existedKeyList.toArray(new String[0]));\n-            Map<String, String> map = new HashMap<>(existedKeyList.size(), 1);\n-            for (int i = 0; i < existedKeyList.size(); i++) {\n-                String existedValue = lockList.get(i);\n-                if (existedValue == null) {\n-                    String key = existedKeyList.get(i);\n-                    map.put(key, JSON.toJSONString(locks.get(i)));\n+            List<String> needLockKeys = new ArrayList<>();\n+            needLockDOS.forEach(lockDO -> needLockKeys.add(buildLockKey(lockDO.getRowKey())));\n+\n+            Pipeline pipeline1 = jedis.pipelined();\n+            needLockKeys.stream().forEachOrdered(needLockKey -> pipeline1.hget(needLockKey, XID));\n+            List<String> existedLockInfos = (List<String>) (List) pipeline1.syncAndReturnAll();\n+            Map<String, LockDO> needAddLock = new HashMap<>(needLockKeys.size(), 1);\n+\n+            for (int i = 0; i < needLockKeys.size(); i++) {\n+                String existedLockXid = existedLockInfos.get(i);\n+                if (StringUtils.isEmpty(existedLockXid)) {\n+                    //If empty,we need to lock this row\n+                    needAddLock.put(needLockKeys.get(i), needLockDOS.get(i));\n                 } else {\n-                    LockDO existed = JSON.parseObject(existedValue, LockDO.class);\n-                    if (!StringUtils.equals(existed.getXid(), locks.get(i).getXid())) {\n+                    if (!StringUtils.equals(existedLockXid, needLockXid)) {\n+                        //If not equals,means the rowkey is holding by another global transaction\n                         return false;\n                     }\n                 }\n             }\n-            if (map.isEmpty()) {\n+\n+            if (needAddLock.isEmpty()) {\n                 return true;\n             }\n             Pipeline pipeline = jedis.pipelined();\n             List<String> readyKeys = new ArrayList<>();\n-            map.forEach((key, value) -> {\n-                pipeline.setnx(key, value);\n+            needAddLock.forEach((key, value) -> {\n+                pipeline.hsetnx(key, XID, value.getXid());\n+                pipeline.hsetnx(key, TRANSACTION_ID, value.getTransactionId().toString());\n+                pipeline.hsetnx(key, BRANCH_ID, value.getBranchId().toString());\n+                pipeline.hsetnx(key, RESOURCE_ID, value.getResourceId());\n+                pipeline.hsetnx(key, TABLE_NAME, value.getTableName());\n+                pipeline.hsetnx(key, ROW_KEY, value.getRowKey());\n+                pipeline.hsetnx(key, PK, value.getPk());\n                 readyKeys.add(key);\n             });\n-            List<Object> results = pipeline.syncAndReturnAll();\n-            for (int i = 0; i < results.size(); i++) {\n-                Long result = (long)results.get(i);\n+            List<Integer> results = (List<Integer>) (List) pipeline.syncAndReturnAll();\n+            List<List<Integer>> partitions = Lists.partition(results, 7);\n+\n+            String[] success = new String[partitions.size()];\n+            for (int i = 0; i < partitions.size(); i++) {\n                 String key = readyKeys.get(i);\n-                if (result != 1) {\n-                    status = result;\n+                if (partitions.get(i).contains(FAILED)) {\n+                    status = FAILED;\n                 } else {\n-                    successList.add(key);\n+                    success[0] = key;\n                 }\n             }\n-            if (status != 1) {\n-                String[] rms = successList.toArray(new String[0]);\n-                if (rms.length > 0) {\n-                    jedis.del(rms);\n+\n+            //If someone has failed,all the lockkey which has been added need to be delete.\n+            if (FAILED.equals(status)) {\n+                if (success.length > 0) {\n+                    jedis.del(success);\n                 }\n                 return false;\n-            } else {\n-                try {\n-                    String xidLockKey = getXidLockKey(locks.get(0).getXid());\n-                    jedis.lpush(xidLockKey, readyKeys.toArray(new String[0]));\n-                } catch (Exception e) {\n-                    return false;\n-                }\n-                return true;\n             }\n+            String xidLockKey = buildXidLockKey(needLockXid);\n+            StringJoiner lockKeysString = new StringJoiner(SEMICOLON);\n+            needLockKeys.stream().forEach(lockKey -> lockKeysString.add(lockKey));\n+            jedis.hsetnx(xidLockKey, branchId.toString(), lockKeysString.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93bb511d77726bee31b4f21fbb72561314497ba6"}, "originalPosition": 187}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjU3Nzc3NQ==", "bodyText": "finished", "url": "https://github.com/seata/seata/pull/3016#discussion_r472577775", "createdAt": "2020-08-19T01:11:44Z", "author": {"login": "lightClouds917"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -60,131 +82,139 @@\n      */\n     public RedisLocker() {\n         logQueryLimit =\n-            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+                ConfigurationFactory.getInstance()\n+                        .getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n     }\n \n     @Override\n     public boolean acquireLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        Set<String> successList = new HashSet<>();\n-        long status = 1;\n+        Integer status = SUCCEED;\n+        String needLockXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            List<LockDO> locks = convertToLockDO(rowLocks);\n-            if (locks.size() > 1) {\n-                locks =\n-                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            List<LockDO> needLockDOS = convertToLockDO(rowLocks);\n+            if (needLockDOS.size() >= 1) {\n+                needLockDOS = needLockDOS.stream().\n+                        filter(LambdaUtils.distinctByKey(LockDO::getRowKey))\n+                        .collect(Collectors.toList());\n             }\n-            List<String> existedKeyList = new ArrayList<>();\n-            locks.forEach(lockDO -> {\n-                existedKeyList.add(getLockKey(lockDO.getRowKey()));\n-            });\n-            List<String> lockList = jedis.mget(existedKeyList.toArray(new String[0]));\n-            Map<String, String> map = new HashMap<>(existedKeyList.size(), 1);\n-            for (int i = 0; i < existedKeyList.size(); i++) {\n-                String existedValue = lockList.get(i);\n-                if (existedValue == null) {\n-                    String key = existedKeyList.get(i);\n-                    map.put(key, JSON.toJSONString(locks.get(i)));\n+            List<String> needLockKeys = new ArrayList<>();\n+            needLockDOS.forEach(lockDO -> needLockKeys.add(buildLockKey(lockDO.getRowKey())));\n+\n+            Pipeline pipeline1 = jedis.pipelined();\n+            needLockKeys.stream().forEachOrdered(needLockKey -> pipeline1.hget(needLockKey, XID));\n+            List<String> existedLockInfos = (List<String>) (List) pipeline1.syncAndReturnAll();\n+            Map<String, LockDO> needAddLock = new HashMap<>(needLockKeys.size(), 1);\n+\n+            for (int i = 0; i < needLockKeys.size(); i++) {\n+                String existedLockXid = existedLockInfos.get(i);\n+                if (StringUtils.isEmpty(existedLockXid)) {\n+                    //If empty,we need to lock this row\n+                    needAddLock.put(needLockKeys.get(i), needLockDOS.get(i));\n                 } else {\n-                    LockDO existed = JSON.parseObject(existedValue, LockDO.class);\n-                    if (!StringUtils.equals(existed.getXid(), locks.get(i).getXid())) {\n+                    if (!StringUtils.equals(existedLockXid, needLockXid)) {\n+                        //If not equals,means the rowkey is holding by another global transaction\n                         return false;\n                     }\n                 }\n             }\n-            if (map.isEmpty()) {\n+\n+            if (needAddLock.isEmpty()) {\n                 return true;\n             }\n             Pipeline pipeline = jedis.pipelined();\n             List<String> readyKeys = new ArrayList<>();\n-            map.forEach((key, value) -> {\n-                pipeline.setnx(key, value);\n+            needAddLock.forEach((key, value) -> {\n+                pipeline.hsetnx(key, XID, value.getXid());\n+                pipeline.hsetnx(key, TRANSACTION_ID, value.getTransactionId().toString());\n+                pipeline.hsetnx(key, BRANCH_ID, value.getBranchId().toString());\n+                pipeline.hsetnx(key, RESOURCE_ID, value.getResourceId());\n+                pipeline.hsetnx(key, TABLE_NAME, value.getTableName());\n+                pipeline.hsetnx(key, ROW_KEY, value.getRowKey());\n+                pipeline.hsetnx(key, PK, value.getPk());\n                 readyKeys.add(key);\n             });\n-            List<Object> results = pipeline.syncAndReturnAll();\n-            for (int i = 0; i < results.size(); i++) {\n-                Long result = (long)results.get(i);\n+            List<Integer> results = (List<Integer>) (List) pipeline.syncAndReturnAll();\n+            List<List<Integer>> partitions = Lists.partition(results, 7);\n+\n+            String[] success = new String[partitions.size()];\n+            for (int i = 0; i < partitions.size(); i++) {\n                 String key = readyKeys.get(i);\n-                if (result != 1) {\n-                    status = result;\n+                if (partitions.get(i).contains(FAILED)) {\n+                    status = FAILED;\n                 } else {\n-                    successList.add(key);\n+                    success[0] = key;\n                 }\n             }\n-            if (status != 1) {\n-                String[] rms = successList.toArray(new String[0]);\n-                if (rms.length > 0) {\n-                    jedis.del(rms);\n+\n+            //If someone has failed,all the lockkey which has been added need to be delete.\n+            if (FAILED.equals(status)) {\n+                if (success.length > 0) {\n+                    jedis.del(success);\n                 }\n                 return false;\n-            } else {\n-                try {\n-                    String xidLockKey = getXidLockKey(locks.get(0).getXid());\n-                    jedis.lpush(xidLockKey, readyKeys.toArray(new String[0]));\n-                } catch (Exception e) {\n-                    return false;\n-                }\n-                return true;\n             }\n+            String xidLockKey = buildXidLockKey(needLockXid);\n+            StringJoiner lockKeysString = new StringJoiner(SEMICOLON);\n+            needLockKeys.stream().forEach(lockKey -> lockKeysString.add(lockKey));\n+            jedis.hsetnx(xidLockKey, branchId.toString(), lockKeysString.toString());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjE5NTE1MQ=="}, "originalCommit": {"oid": "93bb511d77726bee31b4f21fbb72561314497ba6"}, "originalPosition": 187}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MTg1NjQ4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxNDozMToyNlrOHCXYQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwMToxMTo0N1rOHCr2_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjI0MjI0Mw==", "bodyText": "please pay attention to this problem: list All elements are null\nexistedXids.size>0", "url": "https://github.com/seata/seata/pull/3016#discussion_r472242243", "createdAt": "2020-08-18T14:31:26Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -207,41 +237,22 @@ public boolean isLockable(List<RowLock> rowLocks) {\n             List<LockDO> locks = convertToLockDO(rowLocks);\n             Set<String> lockKeys = new HashSet<>();\n             for (LockDO rowlock : locks) {\n-                lockKeys.add(getLockKey(rowlock.getRowKey()));\n+                lockKeys.add(buildLockKey(rowlock.getRowKey()));\n             }\n-            List<String> rowlockJsons = jedis.mget(lockKeys.toArray(new String[0]));\n+\n             String xid = rowLocks.get(0).getXid();\n-            for (String rowlockJson : rowlockJsons) {\n-                if (!StringUtils.isEmpty(rowlockJson)) {\n-                    LockDO lock = JSON.parseObject(rowlockJson, LockDO.class);\n-                    if (lock != null && !Objects.equals(lock.getXid(), xid)) {\n-                        return false;\n-                    }\n-                }\n-            }\n+            Pipeline pipeline = jedis.pipelined();\n+            lockKeys.stream().forEach(key -> pipeline.hget(key, XID));\n+            List<String> existedXids = (List<String>) (List) pipeline.syncAndReturnAll();\n+            return existedXids.stream().allMatch(existedXid -> xid.equals(existedXid));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93bb511d77726bee31b4f21fbb72561314497ba6"}, "originalPosition": 299}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjU3Nzc4OQ==", "bodyText": "finished", "url": "https://github.com/seata/seata/pull/3016#discussion_r472577789", "createdAt": "2020-08-19T01:11:47Z", "author": {"login": "lightClouds917"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -207,41 +237,22 @@ public boolean isLockable(List<RowLock> rowLocks) {\n             List<LockDO> locks = convertToLockDO(rowLocks);\n             Set<String> lockKeys = new HashSet<>();\n             for (LockDO rowlock : locks) {\n-                lockKeys.add(getLockKey(rowlock.getRowKey()));\n+                lockKeys.add(buildLockKey(rowlock.getRowKey()));\n             }\n-            List<String> rowlockJsons = jedis.mget(lockKeys.toArray(new String[0]));\n+\n             String xid = rowLocks.get(0).getXid();\n-            for (String rowlockJson : rowlockJsons) {\n-                if (!StringUtils.isEmpty(rowlockJson)) {\n-                    LockDO lock = JSON.parseObject(rowlockJson, LockDO.class);\n-                    if (lock != null && !Objects.equals(lock.getXid(), xid)) {\n-                        return false;\n-                    }\n-                }\n-            }\n+            Pipeline pipeline = jedis.pipelined();\n+            lockKeys.stream().forEach(key -> pipeline.hget(key, XID));\n+            List<String> existedXids = (List<String>) (List) pipeline.syncAndReturnAll();\n+            return existedXids.stream().allMatch(existedXid -> xid.equals(existedXid));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjI0MjI0Mw=="}, "originalCommit": {"oid": "93bb511d77726bee31b4f21fbb72561314497ba6"}, "originalPosition": 299}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1NDAyNjA3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwMTozOToxNVrOHCsUjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwMzoyOTowNFrOHCvt-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjU4NTM1OA==", "bodyText": "don't need the logQueryLimit", "url": "https://github.com/seata/seata/pull/3016#discussion_r472585358", "createdAt": "2020-08-19T01:39:15Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -60,131 +82,139 @@\n      */\n     public RedisLocker() {\n         logQueryLimit =\n-            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+                ConfigurationFactory.getInstance()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d83284f57fa41a676592c7561c742028e0034a44"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjY0MTAxNw==", "bodyText": "finished", "url": "https://github.com/seata/seata/pull/3016#discussion_r472641017", "createdAt": "2020-08-19T03:29:04Z", "author": {"login": "lightClouds917"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -60,131 +82,139 @@\n      */\n     public RedisLocker() {\n         logQueryLimit =\n-            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+                ConfigurationFactory.getInstance()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjU4NTM1OA=="}, "originalCommit": {"oid": "d83284f57fa41a676592c7561c742028e0034a44"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MjU4NjA3OnYy", "diffSide": "RIGHT", "path": "common/src/main/java/io/seata/common/Constants.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQwOTozNzo1MlrOHFclLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwNjo1ODoyMVrOHG-aQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ3MzE5OA==", "bodyText": "Can be completed or deleted", "url": "https://github.com/seata/seata/pull/3016#discussion_r475473198", "createdAt": "2020-08-24T09:37:52Z", "author": {"login": "ph3636"}, "path": "common/src/main/java/io/seata/common/Constants.java", "diffHunk": "@@ -40,8 +41,15 @@\n      */\n     public static final String DBKEYS_SPLIT_CHAR = \",\";\n \n-    /** the start time of transaction */\n-    public static final String START_TIME  = \"start-time\";\n+    /**\n+     * The constant ;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91360c7adeeeb3d8bc6e0f58e82fb8946f9df2dc"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzA3NjAzNA==", "bodyText": "finished", "url": "https://github.com/seata/seata/pull/3016#discussion_r477076034", "createdAt": "2020-08-26T06:58:21Z", "author": {"login": "lightClouds917"}, "path": "common/src/main/java/io/seata/common/Constants.java", "diffHunk": "@@ -40,8 +41,15 @@\n      */\n     public static final String DBKEYS_SPLIT_CHAR = \",\";\n \n-    /** the start time of transaction */\n-    public static final String START_TIME  = \"start-time\";\n+    /**\n+     * The constant ;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ3MzE5OA=="}, "originalCommit": {"oid": "91360c7adeeeb3d8bc6e0f58e82fb8946f9df2dc"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MjU5MTA2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQwOTozODo1NFrOHFcoeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwNDoyOTowMlrOHH80fg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ3NDA0MQ==", "bodyText": "Can be placed below", "url": "https://github.com/seata/seata/pull/3016#discussion_r475474041", "createdAt": "2020-08-24T09:38:54Z", "author": {"login": "ph3636"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -15,23 +15,21 @@\n  */\n package io.seata.server.storage.redis.lock;\n \n+import static io.seata.common.Constants.SEMICOLON;\n+\n+import com.google.common.collect.Lists;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91360c7adeeeb3d8bc6e0f58e82fb8946f9df2dc"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzEzMjM3Mg==", "bodyText": "It seemed that the java package was on the top", "url": "https://github.com/seata/seata/pull/3016#discussion_r477132372", "createdAt": "2020-08-26T08:37:36Z", "author": {"login": "ph3636"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -15,23 +15,21 @@\n  */\n package io.seata.server.storage.redis.lock;\n \n+import static io.seata.common.Constants.SEMICOLON;\n+\n+import com.google.common.collect.Lists;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ3NDA0MQ=="}, "originalCommit": {"oid": "91360c7adeeeb3d8bc6e0f58e82fb8946f9df2dc"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODA5ODU1OA==", "bodyText": "It seemed that the java package was on the top\n\nfinished", "url": "https://github.com/seata/seata/pull/3016#discussion_r478098558", "createdAt": "2020-08-27T04:29:02Z", "author": {"login": "lightClouds917"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -15,23 +15,21 @@\n  */\n package io.seata.server.storage.redis.lock;\n \n+import static io.seata.common.Constants.SEMICOLON;\n+\n+import com.google.common.collect.Lists;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ3NDA0MQ=="}, "originalCommit": {"oid": "91360c7adeeeb3d8bc6e0f58e82fb8946f9df2dc"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MjU5OTIxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQwOTo0MTowOVrOHFctSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwNDoyOToxMlrOHH81TQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ3NTI3NQ==", "bodyText": "Remove equal to", "url": "https://github.com/seata/seata/pull/3016#discussion_r475475275", "createdAt": "2020-08-24T09:41:09Z", "author": {"login": "ph3636"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -40,151 +38,170 @@\n import redis.clients.jedis.Pipeline;\n \n /**\n+ * The redis lock store operation\n+ *\n  * @author funkye\n+ * @author wangzhongxiang\n  */\n public class RedisLocker extends AbstractLocker {\n \n-    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+    private static final Integer SUCCEED = 1;\n+\n+    private static final Integer FAILED = 0;\n \n     private static final String DEFAULT_REDIS_SEATA_LOCK_PREFIX = \"SEATA_LOCK_\";\n \n     private static final String DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX = \"SEATA_LOCK_XID_\";\n \n-    /**\n-     * The query limit.\n-     */\n-    private int logQueryLimit;\n+    private static final String XID = \"xid\";\n+\n+    private static final String TRANSACTION_ID = \"transactionId\";\n+\n+    private static final String BRANCH_ID = \"branchId\";\n+\n+    private static final String RESOURCE_ID = \"resourceId\";\n+\n+    private static final String TABLE_NAME = \"tableName\";\n+\n+    private static final String PK = \"pk\";\n+\n+    private static final String ROW_KEY = \"rowKey\";\n \n     /**\n      * Instantiates a new Redis locker.\n      */\n     public RedisLocker() {\n-        logQueryLimit =\n-            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n     }\n \n     @Override\n     public boolean acquireLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        Set<String> successList = new HashSet<>();\n-        long status = 1;\n+        Integer status = SUCCEED;\n+        String needLockXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            List<LockDO> locks = convertToLockDO(rowLocks);\n-            if (locks.size() > 1) {\n-                locks =\n-                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            List<LockDO> needLockDOS = convertToLockDO(rowLocks);\n+            if (needLockDOS.size() >= 1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91360c7adeeeb3d8bc6e0f58e82fb8946f9df2dc"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzA3NjA4Mw==", "bodyText": "finished", "url": "https://github.com/seata/seata/pull/3016#discussion_r477076083", "createdAt": "2020-08-26T06:58:25Z", "author": {"login": "lightClouds917"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -40,151 +38,170 @@\n import redis.clients.jedis.Pipeline;\n \n /**\n+ * The redis lock store operation\n+ *\n  * @author funkye\n+ * @author wangzhongxiang\n  */\n public class RedisLocker extends AbstractLocker {\n \n-    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+    private static final Integer SUCCEED = 1;\n+\n+    private static final Integer FAILED = 0;\n \n     private static final String DEFAULT_REDIS_SEATA_LOCK_PREFIX = \"SEATA_LOCK_\";\n \n     private static final String DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX = \"SEATA_LOCK_XID_\";\n \n-    /**\n-     * The query limit.\n-     */\n-    private int logQueryLimit;\n+    private static final String XID = \"xid\";\n+\n+    private static final String TRANSACTION_ID = \"transactionId\";\n+\n+    private static final String BRANCH_ID = \"branchId\";\n+\n+    private static final String RESOURCE_ID = \"resourceId\";\n+\n+    private static final String TABLE_NAME = \"tableName\";\n+\n+    private static final String PK = \"pk\";\n+\n+    private static final String ROW_KEY = \"rowKey\";\n \n     /**\n      * Instantiates a new Redis locker.\n      */\n     public RedisLocker() {\n-        logQueryLimit =\n-            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n     }\n \n     @Override\n     public boolean acquireLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        Set<String> successList = new HashSet<>();\n-        long status = 1;\n+        Integer status = SUCCEED;\n+        String needLockXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            List<LockDO> locks = convertToLockDO(rowLocks);\n-            if (locks.size() > 1) {\n-                locks =\n-                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            List<LockDO> needLockDOS = convertToLockDO(rowLocks);\n+            if (needLockDOS.size() >= 1) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ3NTI3NQ=="}, "originalCommit": {"oid": "91360c7adeeeb3d8bc6e0f58e82fb8946f9df2dc"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzEzMTUzNQ==", "bodyText": "The meaning here is the same as before, so be it", "url": "https://github.com/seata/seata/pull/3016#discussion_r477131535", "createdAt": "2020-08-26T08:36:21Z", "author": {"login": "ph3636"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -40,151 +38,170 @@\n import redis.clients.jedis.Pipeline;\n \n /**\n+ * The redis lock store operation\n+ *\n  * @author funkye\n+ * @author wangzhongxiang\n  */\n public class RedisLocker extends AbstractLocker {\n \n-    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+    private static final Integer SUCCEED = 1;\n+\n+    private static final Integer FAILED = 0;\n \n     private static final String DEFAULT_REDIS_SEATA_LOCK_PREFIX = \"SEATA_LOCK_\";\n \n     private static final String DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX = \"SEATA_LOCK_XID_\";\n \n-    /**\n-     * The query limit.\n-     */\n-    private int logQueryLimit;\n+    private static final String XID = \"xid\";\n+\n+    private static final String TRANSACTION_ID = \"transactionId\";\n+\n+    private static final String BRANCH_ID = \"branchId\";\n+\n+    private static final String RESOURCE_ID = \"resourceId\";\n+\n+    private static final String TABLE_NAME = \"tableName\";\n+\n+    private static final String PK = \"pk\";\n+\n+    private static final String ROW_KEY = \"rowKey\";\n \n     /**\n      * Instantiates a new Redis locker.\n      */\n     public RedisLocker() {\n-        logQueryLimit =\n-            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n     }\n \n     @Override\n     public boolean acquireLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        Set<String> successList = new HashSet<>();\n-        long status = 1;\n+        Integer status = SUCCEED;\n+        String needLockXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            List<LockDO> locks = convertToLockDO(rowLocks);\n-            if (locks.size() > 1) {\n-                locks =\n-                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            List<LockDO> needLockDOS = convertToLockDO(rowLocks);\n+            if (needLockDOS.size() >= 1) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ3NTI3NQ=="}, "originalCommit": {"oid": "91360c7adeeeb3d8bc6e0f58e82fb8946f9df2dc"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODA5ODc2NQ==", "bodyText": "The meaning here is the same as before, so be it\n\nfinished", "url": "https://github.com/seata/seata/pull/3016#discussion_r478098765", "createdAt": "2020-08-27T04:29:12Z", "author": {"login": "lightClouds917"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -40,151 +38,170 @@\n import redis.clients.jedis.Pipeline;\n \n /**\n+ * The redis lock store operation\n+ *\n  * @author funkye\n+ * @author wangzhongxiang\n  */\n public class RedisLocker extends AbstractLocker {\n \n-    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+    private static final Integer SUCCEED = 1;\n+\n+    private static final Integer FAILED = 0;\n \n     private static final String DEFAULT_REDIS_SEATA_LOCK_PREFIX = \"SEATA_LOCK_\";\n \n     private static final String DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX = \"SEATA_LOCK_XID_\";\n \n-    /**\n-     * The query limit.\n-     */\n-    private int logQueryLimit;\n+    private static final String XID = \"xid\";\n+\n+    private static final String TRANSACTION_ID = \"transactionId\";\n+\n+    private static final String BRANCH_ID = \"branchId\";\n+\n+    private static final String RESOURCE_ID = \"resourceId\";\n+\n+    private static final String TABLE_NAME = \"tableName\";\n+\n+    private static final String PK = \"pk\";\n+\n+    private static final String ROW_KEY = \"rowKey\";\n \n     /**\n      * Instantiates a new Redis locker.\n      */\n     public RedisLocker() {\n-        logQueryLimit =\n-            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n     }\n \n     @Override\n     public boolean acquireLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        Set<String> successList = new HashSet<>();\n-        long status = 1;\n+        Integer status = SUCCEED;\n+        String needLockXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            List<LockDO> locks = convertToLockDO(rowLocks);\n-            if (locks.size() > 1) {\n-                locks =\n-                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            List<LockDO> needLockDOS = convertToLockDO(rowLocks);\n+            if (needLockDOS.size() >= 1) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ3NTI3NQ=="}, "originalCommit": {"oid": "91360c7adeeeb3d8bc6e0f58e82fb8946f9df2dc"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MjY3MzAwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxMDowMTo0NVrOHFdZtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwNjo1ODozNlrOHG-a1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ4NjY0Nw==", "bodyText": "Change the names of these two keys for structure error", "url": "https://github.com/seata/seata/pull/3016#discussion_r475486647", "createdAt": "2020-08-24T10:01:45Z", "author": {"login": "ph3636"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -200,48 +217,28 @@ public boolean releaseLock(String xid, Long branchId) {\n     @Override\n     public boolean isLockable(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n             List<LockDO> locks = convertToLockDO(rowLocks);\n             Set<String> lockKeys = new HashSet<>();\n             for (LockDO rowlock : locks) {\n-                lockKeys.add(getLockKey(rowlock.getRowKey()));\n+                lockKeys.add(buildLockKey(rowlock.getRowKey()));\n             }\n-            List<String> rowlockJsons = jedis.mget(lockKeys.toArray(new String[0]));\n+\n             String xid = rowLocks.get(0).getXid();\n-            for (String rowlockJson : rowlockJsons) {\n-                if (!StringUtils.isEmpty(rowlockJson)) {\n-                    LockDO lock = JSON.parseObject(rowlockJson, LockDO.class);\n-                    if (lock != null && !Objects.equals(lock.getXid(), xid)) {\n-                        return false;\n-                    }\n-                }\n-            }\n+            Pipeline pipeline = jedis.pipelined();\n+            lockKeys.stream().forEach(key -> pipeline.hget(key, XID));\n+            List<String> existedXids = (List<String>) (List) pipeline.syncAndReturnAll();\n+            return existedXids.stream().allMatch(existedXid -> existedXid == null || xid.equals(existedXid));\n         }\n-        return true;\n-    }\n-\n-    private Set<String> lRange(Jedis jedis, String key) {\n-        Set<String> keys = new HashSet<>();\n-        List<String> redisLockJson;\n-        int start = 0;\n-        int stop = logQueryLimit;\n-        do {\n-            redisLockJson = jedis.lrange(key, start, stop);\n-            keys.addAll(redisLockJson);\n-            start = keys.size();\n-            stop = start + logQueryLimit;\n-        } while (CollectionUtils.isNotEmpty(redisLockJson));\n-        return keys;\n     }\n \n-    private String getXidLockKey(String xid) {\n+    private String buildXidLockKey(String xid) {\n         return DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX + xid;\n     }\n \n-    private String getLockKey(String rowKey) {\n+    private String buildLockKey(String rowKey) {\n         return DEFAULT_REDIS_SEATA_LOCK_PREFIX + rowKey;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91360c7adeeeb3d8bc6e0f58e82fb8946f9df2dc"}, "originalPosition": 335}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzA3NjE4Mw==", "bodyText": "Change the names of these two keys for structure error\n\nfinished", "url": "https://github.com/seata/seata/pull/3016#discussion_r477076183", "createdAt": "2020-08-26T06:58:36Z", "author": {"login": "lightClouds917"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -200,48 +217,28 @@ public boolean releaseLock(String xid, Long branchId) {\n     @Override\n     public boolean isLockable(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n             List<LockDO> locks = convertToLockDO(rowLocks);\n             Set<String> lockKeys = new HashSet<>();\n             for (LockDO rowlock : locks) {\n-                lockKeys.add(getLockKey(rowlock.getRowKey()));\n+                lockKeys.add(buildLockKey(rowlock.getRowKey()));\n             }\n-            List<String> rowlockJsons = jedis.mget(lockKeys.toArray(new String[0]));\n+\n             String xid = rowLocks.get(0).getXid();\n-            for (String rowlockJson : rowlockJsons) {\n-                if (!StringUtils.isEmpty(rowlockJson)) {\n-                    LockDO lock = JSON.parseObject(rowlockJson, LockDO.class);\n-                    if (lock != null && !Objects.equals(lock.getXid(), xid)) {\n-                        return false;\n-                    }\n-                }\n-            }\n+            Pipeline pipeline = jedis.pipelined();\n+            lockKeys.stream().forEach(key -> pipeline.hget(key, XID));\n+            List<String> existedXids = (List<String>) (List) pipeline.syncAndReturnAll();\n+            return existedXids.stream().allMatch(existedXid -> existedXid == null || xid.equals(existedXid));\n         }\n-        return true;\n-    }\n-\n-    private Set<String> lRange(Jedis jedis, String key) {\n-        Set<String> keys = new HashSet<>();\n-        List<String> redisLockJson;\n-        int start = 0;\n-        int stop = logQueryLimit;\n-        do {\n-            redisLockJson = jedis.lrange(key, start, stop);\n-            keys.addAll(redisLockJson);\n-            start = keys.size();\n-            stop = start + logQueryLimit;\n-        } while (CollectionUtils.isNotEmpty(redisLockJson));\n-        return keys;\n     }\n \n-    private String getXidLockKey(String xid) {\n+    private String buildXidLockKey(String xid) {\n         return DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX + xid;\n     }\n \n-    private String getLockKey(String rowKey) {\n+    private String buildLockKey(String rowKey) {\n         return DEFAULT_REDIS_SEATA_LOCK_PREFIX + rowKey;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ4NjY0Nw=="}, "originalCommit": {"oid": "91360c7adeeeb3d8bc6e0f58e82fb8946f9df2dc"}, "originalPosition": 335}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1402, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}