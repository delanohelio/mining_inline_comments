{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAwOTAzNTc1", "number": 3175, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQwNTo0NjozM1rOEsQG6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxMDoxMDo1MlrOFCPKCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0ODM2NzEyOnYy", "diffSide": "RIGHT", "path": "common/src/test/java/io/seata/common/util/IdWorkerTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQwNTo0NjozM1rOHfddQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QwMjoxODoxN1rOHgTC9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjc1MDUyOA==", "bodyText": "do not use *", "url": "https://github.com/seata/seata/pull/3175#discussion_r502750528", "createdAt": "2020-10-10T05:46:33Z", "author": {"login": "a364176773"}, "path": "common/src/test/java/io/seata/common/util/IdWorkerTest.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.common.util;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a77d19b3300a8f3a0dbd82c2a19c9f12eac946a"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzYyODUzNQ==", "bodyText": "idea auto merge these in one *", "url": "https://github.com/seata/seata/pull/3175#discussion_r503628535", "createdAt": "2020-10-13T02:18:17Z", "author": {"login": "selfishlover"}, "path": "common/src/test/java/io/seata/common/util/IdWorkerTest.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.common.util;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjc1MDUyOA=="}, "originalCommit": {"oid": "2a77d19b3300a8f3a0dbd82c2a19c9f12eac946a"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NjQyNzg5OnYy", "diffSide": "RIGHT", "path": "common/src/main/java/io/seata/common/util/IdWorker.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQwMTo0ODozNFrOH_oBPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QwMTo0ODowMVrOIASx1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ3ODAxNQ==", "bodyText": "if currentWithSequence will never be negative number, I think use\n>>\n\nis enought.", "url": "https://github.com/seata/seata/pull/3175#discussion_r536478015", "createdAt": "2020-12-05T01:48:34Z", "author": {"login": "l81893521"}, "path": "common/src/main/java/io/seata/common/util/IdWorker.java", "diffHunk": "@@ -14,161 +14,173 @@\n  *  limitations under the License.\n  */\n package io.seata.common.util;\n-import java.net.InetAddress;\n-import java.net.UnknownHostException;\n+\n+import java.net.NetworkInterface;\n+import java.util.Enumeration;\n+import java.util.Random;\n+import java.util.concurrent.atomic.AtomicLong;\n \n /**\n  * @author funkye\n  */\n public class IdWorker {\n \n-    private volatile static IdWorker idWorker = null;\n-\n     /**\n      * Start time cut (2020-05-03)\n      */\n     private final long twepoch = 1588435200000L;\n \n     /**\n-     * The number of bits occupied by the machine id\n+     * The number of bits occupied by workerId\n      */\n-    private final long workerIdBits = 10L;\n+    private final int workerIdBits = 10;\n \n     /**\n-     * Maximum supported machine id, the result is 1023 (this shift algorithm can quickly calculate the largest decimal\n-     * number that can be represented by a few binary numbers)\n+     * The number of bits occupied by timestamp\n      */\n-    private final long maxWorkerId = -1L ^ (-1L << workerIdBits);\n+    private final int timestampBits = 41;\n \n     /**\n-     * The number of bits the sequence occupies in id\n+     * The number of bits occupied by sequence\n      */\n-    private final long sequenceBits = 12L;\n+    private final int sequenceBits = 12;\n \n     /**\n-     * Machine ID left 12 digits\n+     * Maximum supported machine id, the result is 1023\n      */\n-    private final long workerIdShift = sequenceBits;\n+    private final int maxWorkerId = ~(-1 << workerIdBits);\n \n     /**\n-     * Time truncated to the left by 22 bits (10 + 12)\n+     * business meaning: machine ID (0 ~ 1023)\n+     * actual layout in memory:\n+     * highest 1 bit: 0\n+     * middle 10 bit: workerId\n+     * lowest 53 bit: all 0\n      */\n-    private final long timestampLeftShift = sequenceBits + workerIdBits;\n+    private long workerId;\n \n     /**\n-     * Generate sequence mask\n+     * timestamp and sequence mix in one Long\n+     * highest 11 bit: not used\n+     * middle  41 bit: timestamp\n+     * lowest  12 bit: sequence\n      */\n-    private final long sequenceMask = -1L ^ (-1L << sequenceBits);\n+    private AtomicLong timestampAndSequence;\n \n     /**\n-     * Machine ID (0 ~ 1023)\n+     * mask that help to extract timestamp and sequence from a long\n      */\n-    private long workerId;\n+    private final long timestampAndSequenceMask = ~(-1L << (timestampBits + sequenceBits));\n \n     /**\n-     * Sequence in milliseconds (0 ~ 4095)\n+     * instantiate an IdWorker using given workerId\n+     * @param workerId if null, then will auto assign one\n      */\n-    private long sequence = 0L;\n+    public IdWorker(Long workerId) {\n+        initTimestampAndSequence();\n+        initWorkerId(workerId);\n+    }\n \n     /**\n-     * Time of last ID generation\n+     * init first timestamp and sequence immediately\n      */\n-    private long lastTimestamp = -1L;\n+    private void initTimestampAndSequence() {\n+        long timestamp = getNewestTimestamp();\n+        long timestampWithSequence = timestamp << sequenceBits;\n+        this.timestampAndSequence = new AtomicLong(timestampWithSequence);\n+    }\n \n     /**\n-     * Constructor\n-     *\n-     * @param workerId\n-     *            Job ID (0 ~ 1023)\n+     * init workerId\n+     * @param workerId if null, then auto generate one\n      */\n-    public IdWorker(long workerId) {\n+    private void initWorkerId(Long workerId) {\n+        if (workerId == null) {\n+            workerId = generateWorkerId();\n+        }\n         if (workerId > maxWorkerId || workerId < 0) {\n-            throw new IllegalArgumentException(\n-                String.format(\"worker Id can't be greater than %d or less than 0\", maxWorkerId));\n+            String message = String.format(\"worker Id can't be greater than %d or less than 0\", maxWorkerId);\n+            throw new IllegalArgumentException(message);\n         }\n-        this.workerId = workerId;\n+        this.workerId = workerId << (timestampBits + sequenceBits);\n     }\n \n     /**\n-     * Get the next ID (the method is thread-safe)\n-     *\n-     * @return SnowflakeId\n+     * get next UUID(base on snowflake algorithm), which look like:\n+     * highest 1 bit: always 0\n+     * next   10 bit: workerId\n+     * next   41 bit: timestamp\n+     * lowest 12 bit: sequence\n+     * @return UUID\n      */\n-    public synchronized long nextId() {\n-        long timestamp = timeGen();\n-\n-        if (timestamp < lastTimestamp) {\n-            throw new RuntimeException(String.format(\n-                \"clock moved backwards.  Refusing to generate id for %d milliseconds\", lastTimestamp - timestamp));\n-        }\n-\n-        if (lastTimestamp == timestamp) {\n-            sequence = (sequence + 1) & sequenceMask;\n-            if (sequence == 0) {\n-                timestamp = tilNextMillis(lastTimestamp);\n-            }\n-        } else {\n-            sequence = 0L;\n-        }\n-        lastTimestamp = timestamp;\n-\n-        return ((timestamp - twepoch) << timestampLeftShift) | (workerId << workerIdShift) | sequence;\n+    public long nextId() {\n+        waitIfNecessary();\n+        long next = timestampAndSequence.incrementAndGet();\n+        long timestampWithSequence = next & timestampAndSequenceMask;\n+        return workerId | timestampWithSequence;\n     }\n \n     /**\n-     * Block until the next millisecond until a new timestamp is obtained\n-     *\n-     * @param lastTimestamp\n-     *            Time of last ID generation\n-     * @return Current timestamp\n+     * block current thread if the QPS of acquiring UUID is too high\n+     * that current sequence space is exhausted\n      */\n-    protected long tilNextMillis(long lastTimestamp) {\n-        long timestamp = timeGen();\n-        while (timestamp <= lastTimestamp) {\n-            timestamp = timeGen();\n+    private void waitIfNecessary() {\n+        long currentWithSequence = timestampAndSequence.get();\n+        long current = currentWithSequence >>> sequenceBits;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c2d3c1ad47b9720bcffe604dc401739eb7a2f396"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzE3ODU4Mg==", "bodyText": "currentWithSequence could be a negative number(though it would be a long long time to reach this~). What ever, >>> and >> have the same speed for cpu.", "url": "https://github.com/seata/seata/pull/3175#discussion_r537178582", "createdAt": "2020-12-07T01:48:01Z", "author": {"login": "selfishlover"}, "path": "common/src/main/java/io/seata/common/util/IdWorker.java", "diffHunk": "@@ -14,161 +14,173 @@\n  *  limitations under the License.\n  */\n package io.seata.common.util;\n-import java.net.InetAddress;\n-import java.net.UnknownHostException;\n+\n+import java.net.NetworkInterface;\n+import java.util.Enumeration;\n+import java.util.Random;\n+import java.util.concurrent.atomic.AtomicLong;\n \n /**\n  * @author funkye\n  */\n public class IdWorker {\n \n-    private volatile static IdWorker idWorker = null;\n-\n     /**\n      * Start time cut (2020-05-03)\n      */\n     private final long twepoch = 1588435200000L;\n \n     /**\n-     * The number of bits occupied by the machine id\n+     * The number of bits occupied by workerId\n      */\n-    private final long workerIdBits = 10L;\n+    private final int workerIdBits = 10;\n \n     /**\n-     * Maximum supported machine id, the result is 1023 (this shift algorithm can quickly calculate the largest decimal\n-     * number that can be represented by a few binary numbers)\n+     * The number of bits occupied by timestamp\n      */\n-    private final long maxWorkerId = -1L ^ (-1L << workerIdBits);\n+    private final int timestampBits = 41;\n \n     /**\n-     * The number of bits the sequence occupies in id\n+     * The number of bits occupied by sequence\n      */\n-    private final long sequenceBits = 12L;\n+    private final int sequenceBits = 12;\n \n     /**\n-     * Machine ID left 12 digits\n+     * Maximum supported machine id, the result is 1023\n      */\n-    private final long workerIdShift = sequenceBits;\n+    private final int maxWorkerId = ~(-1 << workerIdBits);\n \n     /**\n-     * Time truncated to the left by 22 bits (10 + 12)\n+     * business meaning: machine ID (0 ~ 1023)\n+     * actual layout in memory:\n+     * highest 1 bit: 0\n+     * middle 10 bit: workerId\n+     * lowest 53 bit: all 0\n      */\n-    private final long timestampLeftShift = sequenceBits + workerIdBits;\n+    private long workerId;\n \n     /**\n-     * Generate sequence mask\n+     * timestamp and sequence mix in one Long\n+     * highest 11 bit: not used\n+     * middle  41 bit: timestamp\n+     * lowest  12 bit: sequence\n      */\n-    private final long sequenceMask = -1L ^ (-1L << sequenceBits);\n+    private AtomicLong timestampAndSequence;\n \n     /**\n-     * Machine ID (0 ~ 1023)\n+     * mask that help to extract timestamp and sequence from a long\n      */\n-    private long workerId;\n+    private final long timestampAndSequenceMask = ~(-1L << (timestampBits + sequenceBits));\n \n     /**\n-     * Sequence in milliseconds (0 ~ 4095)\n+     * instantiate an IdWorker using given workerId\n+     * @param workerId if null, then will auto assign one\n      */\n-    private long sequence = 0L;\n+    public IdWorker(Long workerId) {\n+        initTimestampAndSequence();\n+        initWorkerId(workerId);\n+    }\n \n     /**\n-     * Time of last ID generation\n+     * init first timestamp and sequence immediately\n      */\n-    private long lastTimestamp = -1L;\n+    private void initTimestampAndSequence() {\n+        long timestamp = getNewestTimestamp();\n+        long timestampWithSequence = timestamp << sequenceBits;\n+        this.timestampAndSequence = new AtomicLong(timestampWithSequence);\n+    }\n \n     /**\n-     * Constructor\n-     *\n-     * @param workerId\n-     *            Job ID (0 ~ 1023)\n+     * init workerId\n+     * @param workerId if null, then auto generate one\n      */\n-    public IdWorker(long workerId) {\n+    private void initWorkerId(Long workerId) {\n+        if (workerId == null) {\n+            workerId = generateWorkerId();\n+        }\n         if (workerId > maxWorkerId || workerId < 0) {\n-            throw new IllegalArgumentException(\n-                String.format(\"worker Id can't be greater than %d or less than 0\", maxWorkerId));\n+            String message = String.format(\"worker Id can't be greater than %d or less than 0\", maxWorkerId);\n+            throw new IllegalArgumentException(message);\n         }\n-        this.workerId = workerId;\n+        this.workerId = workerId << (timestampBits + sequenceBits);\n     }\n \n     /**\n-     * Get the next ID (the method is thread-safe)\n-     *\n-     * @return SnowflakeId\n+     * get next UUID(base on snowflake algorithm), which look like:\n+     * highest 1 bit: always 0\n+     * next   10 bit: workerId\n+     * next   41 bit: timestamp\n+     * lowest 12 bit: sequence\n+     * @return UUID\n      */\n-    public synchronized long nextId() {\n-        long timestamp = timeGen();\n-\n-        if (timestamp < lastTimestamp) {\n-            throw new RuntimeException(String.format(\n-                \"clock moved backwards.  Refusing to generate id for %d milliseconds\", lastTimestamp - timestamp));\n-        }\n-\n-        if (lastTimestamp == timestamp) {\n-            sequence = (sequence + 1) & sequenceMask;\n-            if (sequence == 0) {\n-                timestamp = tilNextMillis(lastTimestamp);\n-            }\n-        } else {\n-            sequence = 0L;\n-        }\n-        lastTimestamp = timestamp;\n-\n-        return ((timestamp - twepoch) << timestampLeftShift) | (workerId << workerIdShift) | sequence;\n+    public long nextId() {\n+        waitIfNecessary();\n+        long next = timestampAndSequence.incrementAndGet();\n+        long timestampWithSequence = next & timestampAndSequenceMask;\n+        return workerId | timestampWithSequence;\n     }\n \n     /**\n-     * Block until the next millisecond until a new timestamp is obtained\n-     *\n-     * @param lastTimestamp\n-     *            Time of last ID generation\n-     * @return Current timestamp\n+     * block current thread if the QPS of acquiring UUID is too high\n+     * that current sequence space is exhausted\n      */\n-    protected long tilNextMillis(long lastTimestamp) {\n-        long timestamp = timeGen();\n-        while (timestamp <= lastTimestamp) {\n-            timestamp = timeGen();\n+    private void waitIfNecessary() {\n+        long currentWithSequence = timestampAndSequence.get();\n+        long current = currentWithSequence >>> sequenceBits;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ3ODAxNQ=="}, "originalCommit": {"oid": "c2d3c1ad47b9720bcffe604dc401739eb7a2f396"}, "originalPosition": 178}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3ODg5ODAyOnYy", "diffSide": "RIGHT", "path": "common/src/main/java/io/seata/common/util/IdWorker.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxMDoxMDo1MlrOIBRguA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxMDoxMDo1MlrOIBRguA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODIwNjM5Mg==", "bodyText": "I think origin generate worker id is better than this.", "url": "https://github.com/seata/seata/pull/3175#discussion_r538206392", "createdAt": "2020-12-08T10:10:52Z", "author": {"login": "l81893521"}, "path": "common/src/main/java/io/seata/common/util/IdWorker.java", "diffHunk": "@@ -14,161 +14,174 @@\n  *  limitations under the License.\n  */\n package io.seata.common.util;\n-import java.net.InetAddress;\n-import java.net.UnknownHostException;\n+\n+import java.net.NetworkInterface;\n+import java.util.Enumeration;\n+import java.util.Random;\n+import java.util.concurrent.atomic.AtomicLong;\n \n /**\n  * @author funkye\n+ * @author selfishlover\n  */\n public class IdWorker {\n \n-    private volatile static IdWorker idWorker = null;\n-\n     /**\n      * Start time cut (2020-05-03)\n      */\n     private final long twepoch = 1588435200000L;\n \n     /**\n-     * The number of bits occupied by the machine id\n+     * The number of bits occupied by workerId\n      */\n-    private final long workerIdBits = 10L;\n+    private final int workerIdBits = 10;\n \n     /**\n-     * Maximum supported machine id, the result is 1023 (this shift algorithm can quickly calculate the largest decimal\n-     * number that can be represented by a few binary numbers)\n+     * The number of bits occupied by timestamp\n      */\n-    private final long maxWorkerId = -1L ^ (-1L << workerIdBits);\n+    private final int timestampBits = 41;\n \n     /**\n-     * The number of bits the sequence occupies in id\n+     * The number of bits occupied by sequence\n      */\n-    private final long sequenceBits = 12L;\n+    private final int sequenceBits = 12;\n \n     /**\n-     * Machine ID left 12 digits\n+     * Maximum supported machine id, the result is 1023\n      */\n-    private final long workerIdShift = sequenceBits;\n+    private final int maxWorkerId = ~(-1 << workerIdBits);\n \n     /**\n-     * Time truncated to the left by 22 bits (10 + 12)\n+     * business meaning: machine ID (0 ~ 1023)\n+     * actual layout in memory:\n+     * highest 1 bit: 0\n+     * middle 10 bit: workerId\n+     * lowest 53 bit: all 0\n      */\n-    private final long timestampLeftShift = sequenceBits + workerIdBits;\n+    private long workerId;\n \n     /**\n-     * Generate sequence mask\n+     * timestamp and sequence mix in one Long\n+     * highest 11 bit: not used\n+     * middle  41 bit: timestamp\n+     * lowest  12 bit: sequence\n      */\n-    private final long sequenceMask = -1L ^ (-1L << sequenceBits);\n+    private AtomicLong timestampAndSequence;\n \n     /**\n-     * Machine ID (0 ~ 1023)\n+     * mask that help to extract timestamp and sequence from a long\n      */\n-    private long workerId;\n+    private final long timestampAndSequenceMask = ~(-1L << (timestampBits + sequenceBits));\n \n     /**\n-     * Sequence in milliseconds (0 ~ 4095)\n+     * instantiate an IdWorker using given workerId\n+     * @param workerId if null, then will auto assign one\n      */\n-    private long sequence = 0L;\n+    public IdWorker(Long workerId) {\n+        initTimestampAndSequence();\n+        initWorkerId(workerId);\n+    }\n \n     /**\n-     * Time of last ID generation\n+     * init first timestamp and sequence immediately\n      */\n-    private long lastTimestamp = -1L;\n+    private void initTimestampAndSequence() {\n+        long timestamp = getNewestTimestamp();\n+        long timestampWithSequence = timestamp << sequenceBits;\n+        this.timestampAndSequence = new AtomicLong(timestampWithSequence);\n+    }\n \n     /**\n-     * Constructor\n-     *\n-     * @param workerId\n-     *            Job ID (0 ~ 1023)\n+     * init workerId\n+     * @param workerId if null, then auto generate one\n      */\n-    public IdWorker(long workerId) {\n+    private void initWorkerId(Long workerId) {\n+        if (workerId == null) {\n+            workerId = generateWorkerId();\n+        }\n         if (workerId > maxWorkerId || workerId < 0) {\n-            throw new IllegalArgumentException(\n-                String.format(\"worker Id can't be greater than %d or less than 0\", maxWorkerId));\n+            String message = String.format(\"worker Id can't be greater than %d or less than 0\", maxWorkerId);\n+            throw new IllegalArgumentException(message);\n         }\n-        this.workerId = workerId;\n+        this.workerId = workerId << (timestampBits + sequenceBits);\n     }\n \n     /**\n-     * Get the next ID (the method is thread-safe)\n-     *\n-     * @return SnowflakeId\n+     * get next UUID(base on snowflake algorithm), which look like:\n+     * highest 1 bit: always 0\n+     * next   10 bit: workerId\n+     * next   41 bit: timestamp\n+     * lowest 12 bit: sequence\n+     * @return UUID\n      */\n-    public synchronized long nextId() {\n-        long timestamp = timeGen();\n-\n-        if (timestamp < lastTimestamp) {\n-            throw new RuntimeException(String.format(\n-                \"clock moved backwards.  Refusing to generate id for %d milliseconds\", lastTimestamp - timestamp));\n-        }\n-\n-        if (lastTimestamp == timestamp) {\n-            sequence = (sequence + 1) & sequenceMask;\n-            if (sequence == 0) {\n-                timestamp = tilNextMillis(lastTimestamp);\n-            }\n-        } else {\n-            sequence = 0L;\n-        }\n-        lastTimestamp = timestamp;\n-\n-        return ((timestamp - twepoch) << timestampLeftShift) | (workerId << workerIdShift) | sequence;\n+    public long nextId() {\n+        waitIfNecessary();\n+        long next = timestampAndSequence.incrementAndGet();\n+        long timestampWithSequence = next & timestampAndSequenceMask;\n+        return workerId | timestampWithSequence;\n     }\n \n     /**\n-     * Block until the next millisecond until a new timestamp is obtained\n-     *\n-     * @param lastTimestamp\n-     *            Time of last ID generation\n-     * @return Current timestamp\n+     * block current thread if the QPS of acquiring UUID is too high\n+     * that current sequence space is exhausted\n      */\n-    protected long tilNextMillis(long lastTimestamp) {\n-        long timestamp = timeGen();\n-        while (timestamp <= lastTimestamp) {\n-            timestamp = timeGen();\n+    private void waitIfNecessary() {\n+        long currentWithSequence = timestampAndSequence.get();\n+        long current = currentWithSequence >>> sequenceBits;\n+        long newest = getNewestTimestamp();\n+        if (current >= newest) {\n+            try {\n+                Thread.sleep(5);\n+            } catch (InterruptedException ignore) {\n+                // don't care\n+            }\n         }\n-        return timestamp;\n     }\n \n     /**\n-     * Returns the current time in milliseconds\n-     *\n-     * @return Current time (ms)\n+     * get newest timestamp relative to twepoch\n      */\n-    protected long timeGen() {\n-        return System.currentTimeMillis();\n-    }\n-\n-    public static IdWorker getInstance() {\n-        if (idWorker == null) {\n-            synchronized (IdWorker.class) {\n-                if (idWorker == null) {\n-                    init(initWorkerId());\n-                }\n-            }\n-        }\n-        return idWorker;\n+    private long getNewestTimestamp() {\n+        return System.currentTimeMillis() - twepoch;\n     }\n \n-    public static long initWorkerId() {\n-        InetAddress address;\n+    /**\n+     * auto generate workerId, try using mac first, if failed, then randomly generate one\n+     * @return workerId\n+     */\n+    private long generateWorkerId() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "456a442f215adaf7476fe0a1ab112a80854529d7"}, "originalPosition": 220}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1449, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}