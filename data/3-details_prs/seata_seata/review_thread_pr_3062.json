{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDczNjczNjE3", "number": 3062, "reviewThreads": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNDozMjoyNVrOEkkSfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwOTowNzozMlrOEsis4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2Nzc4NzQ5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/db/store/DataBaseTransactionStoreManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNDozMjoyNVrOHTlPiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNDozMjoyNVrOHTlPiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDI5NTE3Ng==", "bodyText": "Java packages should be at the top level", "url": "https://github.com/seata/seata/pull/3062#discussion_r490295176", "createdAt": "2020-09-17T14:32:25Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/db/store/DataBaseTransactionStoreManager.java", "diffHunk": "@@ -15,6 +15,7 @@\n  */\n package io.seata.server.storage.db.store;\n \n+import io.seata.server.storage.SessionConverter;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66f28c784c4c0b5b2a35cd56d2b37896dee734aa"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2Nzc5MTgyOnYy", "diffSide": "RIGHT", "path": "server/src/test/java/io/seata/server/session/redis/RedisSessionManagerTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNDozMzoxNFrOHTlSig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNDozMzoxNFrOHTlSig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDI5NTk0Ng==", "bodyText": "Java packages should be at the top level", "url": "https://github.com/seata/seata/pull/3062#discussion_r490295946", "createdAt": "2020-09-17T14:33:14Z", "author": {"login": "a364176773"}, "path": "server/src/test/java/io/seata/server/session/redis/RedisSessionManagerTest.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package io.seata.server.session.redis;\n+\n+import io.seata.server.session.SessionCondition;\n+import java.io.IOException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66f28c784c4c0b5b2a35cd56d2b37896dee734aa"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2Nzc5NTU1OnYy", "diffSide": "RIGHT", "path": "server/src/test/java/io/seata/server/session/redis/SessionConverterTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNDozMzo1MlrOHTlU9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNDozMzo1MlrOHTlU9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDI5NjU2Nw==", "bodyText": "Java packages should be at the top level", "url": "https://github.com/seata/seata/pull/3062#discussion_r490296567", "createdAt": "2020-09-17T14:33:52Z", "author": {"login": "a364176773"}, "path": "server/src/test/java/io/seata/server/session/redis/SessionConverterTest.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.session.redis;\n+\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.storage.SessionConverter;\n+import java.util.Date;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66f28c784c4c0b5b2a35cd56d2b37896dee734aa"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2Nzc5OTcxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNDozNDozN1rOHTlXoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNDozNDozN1rOHTlXoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDI5NzI0OA==", "bodyText": "Java packages should be at the top level", "url": "https://github.com/seata/seata/pull/3062#discussion_r490297248", "createdAt": "2020-09-17T14:34:37Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -15,63 +15,66 @@\n  */\n package io.seata.server.storage.redis.store;\n \n+import io.seata.common.exception.RedisException;\n+import io.seata.common.util.BeanUtils;\n+import io.seata.server.storage.SessionConverter;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66f28c784c4c0b5b2a35cd56d2b37896dee734aa"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2NzgzMTk3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNDo0MDoxM1rOHTlsSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNDo0MDoxM1rOHTlsSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDMwMjUzNg==", "bodyText": "why not use pipeline", "url": "https://github.com/seata/seata/pull/3062#discussion_r490302536", "createdAt": "2020-09-17T14:40:13Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -90,99 +93,251 @@ public static RedisTransactionStoreManager getInstance() {\n     @Override\n     public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n         if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n-            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return insertGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n-            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return updateGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n-            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return deleteGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n-            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+            return insertBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n-            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+            return updateBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n-            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+            return deleteBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else {\n             throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n         }\n     }\n \n+    /**\n+     * Insert branch transaction\n+     * @param branchTransactionDO\n+     * @return the boolean\n+     */\n+    private boolean insertBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        String branchKey = buildBranchKey(branchTransactionDO.getBranchId());\n+        String branchListKey = buildBranchListKeyByXid(branchTransactionDO.getXid());\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Date now = new Date();\n+            branchTransactionDO.setGmtCreate(now);\n+            branchTransactionDO.setGmtModified(now);\n+            String hmset = jedis.hmset(branchKey, BeanUtils.objectToMap(branchTransactionDO));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66f28c784c4c0b5b2a35cd56d2b37896dee734aa"}, "originalPosition": 132}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2Nzg3NDg5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNDo0NzoxMlrOHTmH3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNDo0NzoxMlrOHTmH3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDMwOTU5OA==", "bodyText": "Is this possibility now?", "url": "https://github.com/seata/seata/pull/3062#discussion_r490309598", "createdAt": "2020-09-17T14:47:12Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -90,99 +93,251 @@ public static RedisTransactionStoreManager getInstance() {\n     @Override\n     public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n         if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n-            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return insertGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n-            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return updateGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n-            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return deleteGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n-            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+            return insertBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n-            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+            return updateBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n-            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+            return deleteBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else {\n             throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n         }\n     }\n \n+    /**\n+     * Insert branch transaction\n+     * @param branchTransactionDO\n+     * @return the boolean\n+     */\n+    private boolean insertBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        String branchKey = buildBranchKey(branchTransactionDO.getBranchId());\n+        String branchListKey = buildBranchListKeyByXid(branchTransactionDO.getXid());\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Date now = new Date();\n+            branchTransactionDO.setGmtCreate(now);\n+            branchTransactionDO.setGmtModified(now);\n+            String hmset = jedis.hmset(branchKey, BeanUtils.objectToMap(branchTransactionDO));\n+            if (OK.equalsIgnoreCase(hmset)) {\n+                Long rpush = jedis.rpush(branchListKey, branchKey);\n+                if (rpush > 0) {\n+                    return true;\n+                } else {\n+                    jedis.del(branchKey);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66f28c784c4c0b5b2a35cd56d2b37896dee734aa"}, "originalPosition": 138}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2Nzk0NDkwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNDo1Nzo1MlrOHTmzmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNDo1Nzo1MlrOHTmzmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDMyMDc5Mg==", "bodyText": "why not use pipeline", "url": "https://github.com/seata/seata/pull/3062#discussion_r490320792", "createdAt": "2020-09-17T14:57:52Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -90,99 +93,251 @@ public static RedisTransactionStoreManager getInstance() {\n     @Override\n     public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n         if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n-            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return insertGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n-            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return updateGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n-            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return deleteGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n-            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+            return insertBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n-            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+            return updateBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n-            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+            return deleteBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else {\n             throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n         }\n     }\n \n+    /**\n+     * Insert branch transaction\n+     * @param branchTransactionDO\n+     * @return the boolean\n+     */\n+    private boolean insertBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        String branchKey = buildBranchKey(branchTransactionDO.getBranchId());\n+        String branchListKey = buildBranchListKeyByXid(branchTransactionDO.getXid());\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Date now = new Date();\n+            branchTransactionDO.setGmtCreate(now);\n+            branchTransactionDO.setGmtModified(now);\n+            String hmset = jedis.hmset(branchKey, BeanUtils.objectToMap(branchTransactionDO));\n+            if (OK.equalsIgnoreCase(hmset)) {\n+                Long rpush = jedis.rpush(branchListKey, branchKey);\n+                if (rpush > 0) {\n+                    return true;\n+                } else {\n+                    jedis.del(branchKey);\n+                    return false;\n+                }\n+            } else {\n+                return false;\n+            }\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n+        }\n+    }\n+\n+    /**\n+     * Delete the branch transaction\n+     * @param branchTransactionDO\n+     * @return\n+     */\n     private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        String branchKey = buildBranchKey(branchTransactionDO.getBranchId());\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String key = getBranchKey(branchTransactionDO.getBranchId());\n-            jedis.del(key);\n-            return true;\n+            String xid = jedis.hget(branchKey, REDIS_KEY_BRANCH_XID);\n+            if (StringUtils.isEmpty(xid)) {\n+                return true;\n+            }\n+            String branchListKey = buildBranchListKeyByXid(branchTransactionDO.getXid());\n+            Long lrem = jedis.lrem(branchListKey, 0, branchKey);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66f28c784c4c0b5b2a35cd56d2b37896dee734aa"}, "originalPosition": 165}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2ODA4OTMxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNToyODo0OFrOHToNYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNToyODo0OFrOHToNYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDM0Mzc3OA==", "bodyText": "why not use pipeline", "url": "https://github.com/seata/seata/pull/3062#discussion_r490343778", "createdAt": "2020-09-17T15:28:48Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -90,99 +93,251 @@ public static RedisTransactionStoreManager getInstance() {\n     @Override\n     public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n         if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n-            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return insertGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n-            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return updateGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n-            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return deleteGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n-            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+            return insertBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n-            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+            return updateBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n-            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+            return deleteBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else {\n             throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n         }\n     }\n \n+    /**\n+     * Insert branch transaction\n+     * @param branchTransactionDO\n+     * @return the boolean\n+     */\n+    private boolean insertBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        String branchKey = buildBranchKey(branchTransactionDO.getBranchId());\n+        String branchListKey = buildBranchListKeyByXid(branchTransactionDO.getXid());\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Date now = new Date();\n+            branchTransactionDO.setGmtCreate(now);\n+            branchTransactionDO.setGmtModified(now);\n+            String hmset = jedis.hmset(branchKey, BeanUtils.objectToMap(branchTransactionDO));\n+            if (OK.equalsIgnoreCase(hmset)) {\n+                Long rpush = jedis.rpush(branchListKey, branchKey);\n+                if (rpush > 0) {\n+                    return true;\n+                } else {\n+                    jedis.del(branchKey);\n+                    return false;\n+                }\n+            } else {\n+                return false;\n+            }\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n+        }\n+    }\n+\n+    /**\n+     * Delete the branch transaction\n+     * @param branchTransactionDO\n+     * @return\n+     */\n     private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        String branchKey = buildBranchKey(branchTransactionDO.getBranchId());\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String key = getBranchKey(branchTransactionDO.getBranchId());\n-            jedis.del(key);\n-            return true;\n+            String xid = jedis.hget(branchKey, REDIS_KEY_BRANCH_XID);\n+            if (StringUtils.isEmpty(xid)) {\n+                return true;\n+            }\n+            String branchListKey = buildBranchListKeyByXid(branchTransactionDO.getXid());\n+            Long lrem = jedis.lrem(branchListKey, 0, branchKey);\n+            if (lrem > 0) {\n+                Long del = jedis.del(branchKey);\n+                if (del == 1) {\n+                    return true;\n+                } else {\n+                    jedis.rpush(branchListKey,branchKey);\n+                    return false;\n+                }\n+            }\n+            return false;\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n         }\n     }\n \n-    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+    /**\n+     * Update the branch transaction\n+     * @param branchTransactionDO\n+     * @return\n+     */\n+    private boolean updateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        String branchKey = buildBranchKey(branchTransactionDO.getBranchId());\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String key = getBranchKey(branchTransactionDO.getBranchId());\n-            Pipeline pipeline = jedis.pipelined();\n-            if (jedis.get(key) == null) {\n-                pipeline.lpush(getBranchListKeyByXid(branchTransactionDO.getXid()), key);\n+            String previousBranchStatus = jedis.hget(branchKey, REDIS_KEY_BRANCH_STATUS);\n+            if (StringUtils.isEmpty(previousBranchStatus)) {\n+                throw new StoreException(\"Branch transaction is not exist, update branch transaction failed.\");\n+            }\n+            Map<String,String> map = new HashMap<>(2);\n+            map.put(REDIS_KEY_BRANCH_STATUS,String.valueOf(branchTransactionDO.getStatus()));\n+            map.put(REDIS_KEY_BRANCH_GMT_MODIFIED,String.valueOf((new Date()).getTime()));\n+            String hmset = jedis.hmset(branchKey, map);\n+            if (OK.equalsIgnoreCase(hmset)) {\n+                return true;\n             }\n-            pipeline.set(key, JSON.toJSONString(branchTransactionDO));\n-            pipeline.sync();\n-            return true;\n+            return false;\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n         }\n     }\n \n+    /**\n+     * Insert the global transaction.\n+     * @param globalTransactionDO\n+     * @return\n+     */\n+    private boolean insertGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        String globalKey = buildGlobalKeyByTransactionId(globalTransactionDO.getTransactionId());\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Date now = new Date();\n+            globalTransactionDO.setGmtCreate(now);\n+            globalTransactionDO.setGmtModified(now);\n+            String hmset = jedis.hmset(globalKey, BeanUtils.objectToMap(globalTransactionDO));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66f28c784c4c0b5b2a35cd56d2b37896dee734aa"}, "originalPosition": 225}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2ODA5NTMzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNTozMDowMlrOHToRDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNTozMDowMlrOHToRDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDM0NDcxOQ==", "bodyText": "you don't have to do that", "url": "https://github.com/seata/seata/pull/3062#discussion_r490344719", "createdAt": "2020-09-17T15:30:02Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -90,99 +93,251 @@ public static RedisTransactionStoreManager getInstance() {\n     @Override\n     public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n         if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n-            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return insertGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n-            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return updateGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n-            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return deleteGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n-            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+            return insertBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n-            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+            return updateBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n-            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+            return deleteBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else {\n             throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n         }\n     }\n \n+    /**\n+     * Insert branch transaction\n+     * @param branchTransactionDO\n+     * @return the boolean\n+     */\n+    private boolean insertBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        String branchKey = buildBranchKey(branchTransactionDO.getBranchId());\n+        String branchListKey = buildBranchListKeyByXid(branchTransactionDO.getXid());\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Date now = new Date();\n+            branchTransactionDO.setGmtCreate(now);\n+            branchTransactionDO.setGmtModified(now);\n+            String hmset = jedis.hmset(branchKey, BeanUtils.objectToMap(branchTransactionDO));\n+            if (OK.equalsIgnoreCase(hmset)) {\n+                Long rpush = jedis.rpush(branchListKey, branchKey);\n+                if (rpush > 0) {\n+                    return true;\n+                } else {\n+                    jedis.del(branchKey);\n+                    return false;\n+                }\n+            } else {\n+                return false;\n+            }\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n+        }\n+    }\n+\n+    /**\n+     * Delete the branch transaction\n+     * @param branchTransactionDO\n+     * @return\n+     */\n     private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        String branchKey = buildBranchKey(branchTransactionDO.getBranchId());\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String key = getBranchKey(branchTransactionDO.getBranchId());\n-            jedis.del(key);\n-            return true;\n+            String xid = jedis.hget(branchKey, REDIS_KEY_BRANCH_XID);\n+            if (StringUtils.isEmpty(xid)) {\n+                return true;\n+            }\n+            String branchListKey = buildBranchListKeyByXid(branchTransactionDO.getXid());\n+            Long lrem = jedis.lrem(branchListKey, 0, branchKey);\n+            if (lrem > 0) {\n+                Long del = jedis.del(branchKey);\n+                if (del == 1) {\n+                    return true;\n+                } else {\n+                    jedis.rpush(branchListKey,branchKey);\n+                    return false;\n+                }\n+            }\n+            return false;\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n         }\n     }\n \n-    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+    /**\n+     * Update the branch transaction\n+     * @param branchTransactionDO\n+     * @return\n+     */\n+    private boolean updateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        String branchKey = buildBranchKey(branchTransactionDO.getBranchId());\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String key = getBranchKey(branchTransactionDO.getBranchId());\n-            Pipeline pipeline = jedis.pipelined();\n-            if (jedis.get(key) == null) {\n-                pipeline.lpush(getBranchListKeyByXid(branchTransactionDO.getXid()), key);\n+            String previousBranchStatus = jedis.hget(branchKey, REDIS_KEY_BRANCH_STATUS);\n+            if (StringUtils.isEmpty(previousBranchStatus)) {\n+                throw new StoreException(\"Branch transaction is not exist, update branch transaction failed.\");\n+            }\n+            Map<String,String> map = new HashMap<>(2);\n+            map.put(REDIS_KEY_BRANCH_STATUS,String.valueOf(branchTransactionDO.getStatus()));\n+            map.put(REDIS_KEY_BRANCH_GMT_MODIFIED,String.valueOf((new Date()).getTime()));\n+            String hmset = jedis.hmset(branchKey, map);\n+            if (OK.equalsIgnoreCase(hmset)) {\n+                return true;\n             }\n-            pipeline.set(key, JSON.toJSONString(branchTransactionDO));\n-            pipeline.sync();\n-            return true;\n+            return false;\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n         }\n     }\n \n+    /**\n+     * Insert the global transaction.\n+     * @param globalTransactionDO\n+     * @return\n+     */\n+    private boolean insertGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        String globalKey = buildGlobalKeyByTransactionId(globalTransactionDO.getTransactionId());\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Date now = new Date();\n+            globalTransactionDO.setGmtCreate(now);\n+            globalTransactionDO.setGmtModified(now);\n+            String hmset = jedis.hmset(globalKey, BeanUtils.objectToMap(globalTransactionDO));\n+            if (OK.equalsIgnoreCase(hmset)) {\n+                Long rpush = jedis.rpush(buildGlobalStatus(globalTransactionDO.getStatus()),\n+                        globalTransactionDO.getXid());\n+                if (rpush > 0) {\n+                    return true;\n+                } else {\n+                    jedis.hdel(globalKey);\n+                    return false;\n+                }\n+            }\n+            return false;\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n+        }\n+    }\n+\n+    /**\n+     * Delete the global transaction.\n+     * It will operate two parts:\n+     *  1.delete the global session map\n+     *  2.remove the xid from the global status list\n+     * If the operate failed,the succeed operates will rollback\n+     * @param globalTransactionDO\n+     * @return\n+     */\n     private boolean deleteGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        String globalKey = buildGlobalKeyByTransactionId(globalTransactionDO.getTransactionId());\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String[] keys = new String[3];\n-            keys[0] = getGlobalKeyByXid(globalTransactionDO.getXid());\n-            keys[1] = getGlobalKeyByTransactionId(globalTransactionDO.getTransactionId());\n-            keys[2] = getBranchListKeyByXid(globalTransactionDO.getXid());\n-            jedis.del(keys);\n-            return true;\n+            String xid = jedis.hget(globalKey, REDIS_KEY_GLOBAL_XID);\n+            if (StringUtils.isEmpty(xid)) {\n+                LOGGER.warn(\"Global transaction is not exist,xid = {}.Maybe has been deleted by another tc server\",\n+                        globalTransactionDO.getXid());\n+                return true;\n+            }\n+            Long lrem = jedis.lrem(buildGlobalStatus(globalTransactionDO.getStatus()), 0,\n+                    globalTransactionDO.getXid());\n+            if (lrem > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66f28c784c4c0b5b2a35cd56d2b37896dee734aa"}, "originalPosition": 268}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2ODExOTQ2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNTozNToxN1rOHTofyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwOTo0NTozN1rOHY2QBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDM0ODQ5MQ==", "bodyText": "I think the pipe can be used instead", "url": "https://github.com/seata/seata/pull/3062#discussion_r490348491", "createdAt": "2020-09-17T15:35:17Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -90,99 +93,251 @@ public static RedisTransactionStoreManager getInstance() {\n     @Override\n     public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n         if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n-            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return insertGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n-            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return updateGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n-            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return deleteGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n-            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+            return insertBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n-            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+            return updateBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n-            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+            return deleteBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else {\n             throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n         }\n     }\n \n+    /**\n+     * Insert branch transaction\n+     * @param branchTransactionDO\n+     * @return the boolean\n+     */\n+    private boolean insertBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        String branchKey = buildBranchKey(branchTransactionDO.getBranchId());\n+        String branchListKey = buildBranchListKeyByXid(branchTransactionDO.getXid());\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Date now = new Date();\n+            branchTransactionDO.setGmtCreate(now);\n+            branchTransactionDO.setGmtModified(now);\n+            String hmset = jedis.hmset(branchKey, BeanUtils.objectToMap(branchTransactionDO));\n+            if (OK.equalsIgnoreCase(hmset)) {\n+                Long rpush = jedis.rpush(branchListKey, branchKey);\n+                if (rpush > 0) {\n+                    return true;\n+                } else {\n+                    jedis.del(branchKey);\n+                    return false;\n+                }\n+            } else {\n+                return false;\n+            }\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n+        }\n+    }\n+\n+    /**\n+     * Delete the branch transaction\n+     * @param branchTransactionDO\n+     * @return\n+     */\n     private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        String branchKey = buildBranchKey(branchTransactionDO.getBranchId());\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String key = getBranchKey(branchTransactionDO.getBranchId());\n-            jedis.del(key);\n-            return true;\n+            String xid = jedis.hget(branchKey, REDIS_KEY_BRANCH_XID);\n+            if (StringUtils.isEmpty(xid)) {\n+                return true;\n+            }\n+            String branchListKey = buildBranchListKeyByXid(branchTransactionDO.getXid());\n+            Long lrem = jedis.lrem(branchListKey, 0, branchKey);\n+            if (lrem > 0) {\n+                Long del = jedis.del(branchKey);\n+                if (del == 1) {\n+                    return true;\n+                } else {\n+                    jedis.rpush(branchListKey,branchKey);\n+                    return false;\n+                }\n+            }\n+            return false;\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n         }\n     }\n \n-    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+    /**\n+     * Update the branch transaction\n+     * @param branchTransactionDO\n+     * @return\n+     */\n+    private boolean updateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        String branchKey = buildBranchKey(branchTransactionDO.getBranchId());\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String key = getBranchKey(branchTransactionDO.getBranchId());\n-            Pipeline pipeline = jedis.pipelined();\n-            if (jedis.get(key) == null) {\n-                pipeline.lpush(getBranchListKeyByXid(branchTransactionDO.getXid()), key);\n+            String previousBranchStatus = jedis.hget(branchKey, REDIS_KEY_BRANCH_STATUS);\n+            if (StringUtils.isEmpty(previousBranchStatus)) {\n+                throw new StoreException(\"Branch transaction is not exist, update branch transaction failed.\");\n+            }\n+            Map<String,String> map = new HashMap<>(2);\n+            map.put(REDIS_KEY_BRANCH_STATUS,String.valueOf(branchTransactionDO.getStatus()));\n+            map.put(REDIS_KEY_BRANCH_GMT_MODIFIED,String.valueOf((new Date()).getTime()));\n+            String hmset = jedis.hmset(branchKey, map);\n+            if (OK.equalsIgnoreCase(hmset)) {\n+                return true;\n             }\n-            pipeline.set(key, JSON.toJSONString(branchTransactionDO));\n-            pipeline.sync();\n-            return true;\n+            return false;\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n         }\n     }\n \n+    /**\n+     * Insert the global transaction.\n+     * @param globalTransactionDO\n+     * @return\n+     */\n+    private boolean insertGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        String globalKey = buildGlobalKeyByTransactionId(globalTransactionDO.getTransactionId());\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Date now = new Date();\n+            globalTransactionDO.setGmtCreate(now);\n+            globalTransactionDO.setGmtModified(now);\n+            String hmset = jedis.hmset(globalKey, BeanUtils.objectToMap(globalTransactionDO));\n+            if (OK.equalsIgnoreCase(hmset)) {\n+                Long rpush = jedis.rpush(buildGlobalStatus(globalTransactionDO.getStatus()),\n+                        globalTransactionDO.getXid());\n+                if (rpush > 0) {\n+                    return true;\n+                } else {\n+                    jedis.hdel(globalKey);\n+                    return false;\n+                }\n+            }\n+            return false;\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n+        }\n+    }\n+\n+    /**\n+     * Delete the global transaction.\n+     * It will operate two parts:\n+     *  1.delete the global session map\n+     *  2.remove the xid from the global status list\n+     * If the operate failed,the succeed operates will rollback\n+     * @param globalTransactionDO\n+     * @return\n+     */\n     private boolean deleteGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        String globalKey = buildGlobalKeyByTransactionId(globalTransactionDO.getTransactionId());\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String[] keys = new String[3];\n-            keys[0] = getGlobalKeyByXid(globalTransactionDO.getXid());\n-            keys[1] = getGlobalKeyByTransactionId(globalTransactionDO.getTransactionId());\n-            keys[2] = getBranchListKeyByXid(globalTransactionDO.getXid());\n-            jedis.del(keys);\n-            return true;\n+            String xid = jedis.hget(globalKey, REDIS_KEY_GLOBAL_XID);\n+            if (StringUtils.isEmpty(xid)) {\n+                LOGGER.warn(\"Global transaction is not exist,xid = {}.Maybe has been deleted by another tc server\",\n+                        globalTransactionDO.getXid());\n+                return true;\n+            }\n+            Long lrem = jedis.lrem(buildGlobalStatus(globalTransactionDO.getStatus()), 0,\n+                    globalTransactionDO.getXid());\n+            if (lrem > 0) {\n+                Long del = jedis.del(globalKey);\n+                if (del > 0) {\n+                    return true;\n+                } else {\n+                    jedis.rpush(buildGlobalStatus(globalTransactionDO.getStatus()),globalTransactionDO.getXid());\n+                    return false;\n+                }\n+            }\n+            return false;\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n         }\n     }\n \n-    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+    /**\n+     * Update the global transaction.\n+     * It will update two parts:\n+     *  1.the global session map\n+     *  2.the global status list\n+     * If the update failed,the succeed operates will rollback\n+     * @param globalTransactionDO\n+     * @return\n+     */\n+    private boolean updateGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        String xid = globalTransactionDO.getXid();\n+        String globalKey = buildGlobalKeyByTransactionId(globalTransactionDO.getTransactionId());\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String keys = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n-            Pipeline pipeline = jedis.pipelined();\n-            String json = JSON.toJSONString(convertGlobalTransactionDO);\n-            pipeline.set(keys, json);\n-            keys = getGlobalKeyByTransactionId(convertGlobalTransactionDO.getTransactionId());\n-            pipeline.set(keys, json);\n-            pipeline.sync();\n-            return true;\n+            // Defensive watch to prevent other TC server operating concurrently,Fail fast\n+            jedis.watch(globalKey);\n+            String previousStatus = jedis.hget(globalKey, REDIS_KEY_GLOBAL_STATUS);\n+            if (StringUtils.isEmpty(previousStatus)) {\n+                throw new StoreException(\"Global transaction is not exist, update global transaction failed.\");\n+            }\n+            String previousGmtModified = jedis.hget(globalKey, REDIS_KEY_GLOBAL_GMT_MODIFIED);\n+            Transaction multi = jedis.multi();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66f28c784c4c0b5b2a35cd56d2b37896dee734aa"}, "originalPosition": 312}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk3OTU5Ng==", "bodyText": "I think the pipe can be used instead\n\n\u8fd9\u4e2a\u5730\u65b9\u6ca1\u6709\u4f7f\u7528pipeline,\u4e3b\u8981\u8003\u8651\uff0c\u5982\u679c\u591a\u4e2atc\u90fd\u6765\u64cd\u4f5c\uff0c\u90fd\u5224\u65ad\u5168\u5c40\u4e8b\u52a1\u662f\u5b58\u5728\u7684\uff0c\u7136\u540e\u90fd\u53bb\u4fee\u6539\uff0c\u90a3\u4f1a\u4e0d\u4f1a\u51fa\u95ee\u9898\u3002\u800c\u8fd9\u51e0\u4e2a\u547d\u4ee4\uff0c\u5c24\u5176\u662fhmset\uff0cmap\u5b58\u4e0d\u5b58\u5728\uff0c\u5b83\u90fd\u4f1a\u6210\u529f\u3002pipeline\uff0c\u770b\u8d77\u6765\u9632\u4e0d\u4f4f\u8fd9\u79cd\u5e76\u53d1\u4fee\u6539\u7684\u573a\u666f\u3002", "url": "https://github.com/seata/seata/pull/3062#discussion_r491979596", "createdAt": "2020-09-21T11:48:59Z", "author": {"login": "lightClouds917"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -90,99 +93,251 @@ public static RedisTransactionStoreManager getInstance() {\n     @Override\n     public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n         if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n-            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return insertGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n-            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return updateGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n-            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return deleteGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n-            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+            return insertBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n-            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+            return updateBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n-            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+            return deleteBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else {\n             throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n         }\n     }\n \n+    /**\n+     * Insert branch transaction\n+     * @param branchTransactionDO\n+     * @return the boolean\n+     */\n+    private boolean insertBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        String branchKey = buildBranchKey(branchTransactionDO.getBranchId());\n+        String branchListKey = buildBranchListKeyByXid(branchTransactionDO.getXid());\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Date now = new Date();\n+            branchTransactionDO.setGmtCreate(now);\n+            branchTransactionDO.setGmtModified(now);\n+            String hmset = jedis.hmset(branchKey, BeanUtils.objectToMap(branchTransactionDO));\n+            if (OK.equalsIgnoreCase(hmset)) {\n+                Long rpush = jedis.rpush(branchListKey, branchKey);\n+                if (rpush > 0) {\n+                    return true;\n+                } else {\n+                    jedis.del(branchKey);\n+                    return false;\n+                }\n+            } else {\n+                return false;\n+            }\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n+        }\n+    }\n+\n+    /**\n+     * Delete the branch transaction\n+     * @param branchTransactionDO\n+     * @return\n+     */\n     private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        String branchKey = buildBranchKey(branchTransactionDO.getBranchId());\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String key = getBranchKey(branchTransactionDO.getBranchId());\n-            jedis.del(key);\n-            return true;\n+            String xid = jedis.hget(branchKey, REDIS_KEY_BRANCH_XID);\n+            if (StringUtils.isEmpty(xid)) {\n+                return true;\n+            }\n+            String branchListKey = buildBranchListKeyByXid(branchTransactionDO.getXid());\n+            Long lrem = jedis.lrem(branchListKey, 0, branchKey);\n+            if (lrem > 0) {\n+                Long del = jedis.del(branchKey);\n+                if (del == 1) {\n+                    return true;\n+                } else {\n+                    jedis.rpush(branchListKey,branchKey);\n+                    return false;\n+                }\n+            }\n+            return false;\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n         }\n     }\n \n-    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+    /**\n+     * Update the branch transaction\n+     * @param branchTransactionDO\n+     * @return\n+     */\n+    private boolean updateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        String branchKey = buildBranchKey(branchTransactionDO.getBranchId());\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String key = getBranchKey(branchTransactionDO.getBranchId());\n-            Pipeline pipeline = jedis.pipelined();\n-            if (jedis.get(key) == null) {\n-                pipeline.lpush(getBranchListKeyByXid(branchTransactionDO.getXid()), key);\n+            String previousBranchStatus = jedis.hget(branchKey, REDIS_KEY_BRANCH_STATUS);\n+            if (StringUtils.isEmpty(previousBranchStatus)) {\n+                throw new StoreException(\"Branch transaction is not exist, update branch transaction failed.\");\n+            }\n+            Map<String,String> map = new HashMap<>(2);\n+            map.put(REDIS_KEY_BRANCH_STATUS,String.valueOf(branchTransactionDO.getStatus()));\n+            map.put(REDIS_KEY_BRANCH_GMT_MODIFIED,String.valueOf((new Date()).getTime()));\n+            String hmset = jedis.hmset(branchKey, map);\n+            if (OK.equalsIgnoreCase(hmset)) {\n+                return true;\n             }\n-            pipeline.set(key, JSON.toJSONString(branchTransactionDO));\n-            pipeline.sync();\n-            return true;\n+            return false;\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n         }\n     }\n \n+    /**\n+     * Insert the global transaction.\n+     * @param globalTransactionDO\n+     * @return\n+     */\n+    private boolean insertGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        String globalKey = buildGlobalKeyByTransactionId(globalTransactionDO.getTransactionId());\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Date now = new Date();\n+            globalTransactionDO.setGmtCreate(now);\n+            globalTransactionDO.setGmtModified(now);\n+            String hmset = jedis.hmset(globalKey, BeanUtils.objectToMap(globalTransactionDO));\n+            if (OK.equalsIgnoreCase(hmset)) {\n+                Long rpush = jedis.rpush(buildGlobalStatus(globalTransactionDO.getStatus()),\n+                        globalTransactionDO.getXid());\n+                if (rpush > 0) {\n+                    return true;\n+                } else {\n+                    jedis.hdel(globalKey);\n+                    return false;\n+                }\n+            }\n+            return false;\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n+        }\n+    }\n+\n+    /**\n+     * Delete the global transaction.\n+     * It will operate two parts:\n+     *  1.delete the global session map\n+     *  2.remove the xid from the global status list\n+     * If the operate failed,the succeed operates will rollback\n+     * @param globalTransactionDO\n+     * @return\n+     */\n     private boolean deleteGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        String globalKey = buildGlobalKeyByTransactionId(globalTransactionDO.getTransactionId());\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String[] keys = new String[3];\n-            keys[0] = getGlobalKeyByXid(globalTransactionDO.getXid());\n-            keys[1] = getGlobalKeyByTransactionId(globalTransactionDO.getTransactionId());\n-            keys[2] = getBranchListKeyByXid(globalTransactionDO.getXid());\n-            jedis.del(keys);\n-            return true;\n+            String xid = jedis.hget(globalKey, REDIS_KEY_GLOBAL_XID);\n+            if (StringUtils.isEmpty(xid)) {\n+                LOGGER.warn(\"Global transaction is not exist,xid = {}.Maybe has been deleted by another tc server\",\n+                        globalTransactionDO.getXid());\n+                return true;\n+            }\n+            Long lrem = jedis.lrem(buildGlobalStatus(globalTransactionDO.getStatus()), 0,\n+                    globalTransactionDO.getXid());\n+            if (lrem > 0) {\n+                Long del = jedis.del(globalKey);\n+                if (del > 0) {\n+                    return true;\n+                } else {\n+                    jedis.rpush(buildGlobalStatus(globalTransactionDO.getStatus()),globalTransactionDO.getXid());\n+                    return false;\n+                }\n+            }\n+            return false;\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n         }\n     }\n \n-    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+    /**\n+     * Update the global transaction.\n+     * It will update two parts:\n+     *  1.the global session map\n+     *  2.the global status list\n+     * If the update failed,the succeed operates will rollback\n+     * @param globalTransactionDO\n+     * @return\n+     */\n+    private boolean updateGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        String xid = globalTransactionDO.getXid();\n+        String globalKey = buildGlobalKeyByTransactionId(globalTransactionDO.getTransactionId());\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String keys = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n-            Pipeline pipeline = jedis.pipelined();\n-            String json = JSON.toJSONString(convertGlobalTransactionDO);\n-            pipeline.set(keys, json);\n-            keys = getGlobalKeyByTransactionId(convertGlobalTransactionDO.getTransactionId());\n-            pipeline.set(keys, json);\n-            pipeline.sync();\n-            return true;\n+            // Defensive watch to prevent other TC server operating concurrently,Fail fast\n+            jedis.watch(globalKey);\n+            String previousStatus = jedis.hget(globalKey, REDIS_KEY_GLOBAL_STATUS);\n+            if (StringUtils.isEmpty(previousStatus)) {\n+                throw new StoreException(\"Global transaction is not exist, update global transaction failed.\");\n+            }\n+            String previousGmtModified = jedis.hget(globalKey, REDIS_KEY_GLOBAL_GMT_MODIFIED);\n+            Transaction multi = jedis.multi();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDM0ODQ5MQ=="}, "originalCommit": {"oid": "66f28c784c4c0b5b2a35cd56d2b37896dee734aa"}, "originalPosition": 312}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgxNjcxMA==", "bodyText": "I think a direct lock + pipeline is better than Multi", "url": "https://github.com/seata/seata/pull/3062#discussion_r495816710", "createdAt": "2020-09-28T09:45:37Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -90,99 +93,251 @@ public static RedisTransactionStoreManager getInstance() {\n     @Override\n     public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n         if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n-            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return insertGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n-            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return updateGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n-            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return deleteGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n-            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+            return insertBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n-            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+            return updateBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n-            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+            return deleteBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else {\n             throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n         }\n     }\n \n+    /**\n+     * Insert branch transaction\n+     * @param branchTransactionDO\n+     * @return the boolean\n+     */\n+    private boolean insertBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        String branchKey = buildBranchKey(branchTransactionDO.getBranchId());\n+        String branchListKey = buildBranchListKeyByXid(branchTransactionDO.getXid());\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Date now = new Date();\n+            branchTransactionDO.setGmtCreate(now);\n+            branchTransactionDO.setGmtModified(now);\n+            String hmset = jedis.hmset(branchKey, BeanUtils.objectToMap(branchTransactionDO));\n+            if (OK.equalsIgnoreCase(hmset)) {\n+                Long rpush = jedis.rpush(branchListKey, branchKey);\n+                if (rpush > 0) {\n+                    return true;\n+                } else {\n+                    jedis.del(branchKey);\n+                    return false;\n+                }\n+            } else {\n+                return false;\n+            }\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n+        }\n+    }\n+\n+    /**\n+     * Delete the branch transaction\n+     * @param branchTransactionDO\n+     * @return\n+     */\n     private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        String branchKey = buildBranchKey(branchTransactionDO.getBranchId());\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String key = getBranchKey(branchTransactionDO.getBranchId());\n-            jedis.del(key);\n-            return true;\n+            String xid = jedis.hget(branchKey, REDIS_KEY_BRANCH_XID);\n+            if (StringUtils.isEmpty(xid)) {\n+                return true;\n+            }\n+            String branchListKey = buildBranchListKeyByXid(branchTransactionDO.getXid());\n+            Long lrem = jedis.lrem(branchListKey, 0, branchKey);\n+            if (lrem > 0) {\n+                Long del = jedis.del(branchKey);\n+                if (del == 1) {\n+                    return true;\n+                } else {\n+                    jedis.rpush(branchListKey,branchKey);\n+                    return false;\n+                }\n+            }\n+            return false;\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n         }\n     }\n \n-    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+    /**\n+     * Update the branch transaction\n+     * @param branchTransactionDO\n+     * @return\n+     */\n+    private boolean updateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        String branchKey = buildBranchKey(branchTransactionDO.getBranchId());\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String key = getBranchKey(branchTransactionDO.getBranchId());\n-            Pipeline pipeline = jedis.pipelined();\n-            if (jedis.get(key) == null) {\n-                pipeline.lpush(getBranchListKeyByXid(branchTransactionDO.getXid()), key);\n+            String previousBranchStatus = jedis.hget(branchKey, REDIS_KEY_BRANCH_STATUS);\n+            if (StringUtils.isEmpty(previousBranchStatus)) {\n+                throw new StoreException(\"Branch transaction is not exist, update branch transaction failed.\");\n+            }\n+            Map<String,String> map = new HashMap<>(2);\n+            map.put(REDIS_KEY_BRANCH_STATUS,String.valueOf(branchTransactionDO.getStatus()));\n+            map.put(REDIS_KEY_BRANCH_GMT_MODIFIED,String.valueOf((new Date()).getTime()));\n+            String hmset = jedis.hmset(branchKey, map);\n+            if (OK.equalsIgnoreCase(hmset)) {\n+                return true;\n             }\n-            pipeline.set(key, JSON.toJSONString(branchTransactionDO));\n-            pipeline.sync();\n-            return true;\n+            return false;\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n         }\n     }\n \n+    /**\n+     * Insert the global transaction.\n+     * @param globalTransactionDO\n+     * @return\n+     */\n+    private boolean insertGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        String globalKey = buildGlobalKeyByTransactionId(globalTransactionDO.getTransactionId());\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Date now = new Date();\n+            globalTransactionDO.setGmtCreate(now);\n+            globalTransactionDO.setGmtModified(now);\n+            String hmset = jedis.hmset(globalKey, BeanUtils.objectToMap(globalTransactionDO));\n+            if (OK.equalsIgnoreCase(hmset)) {\n+                Long rpush = jedis.rpush(buildGlobalStatus(globalTransactionDO.getStatus()),\n+                        globalTransactionDO.getXid());\n+                if (rpush > 0) {\n+                    return true;\n+                } else {\n+                    jedis.hdel(globalKey);\n+                    return false;\n+                }\n+            }\n+            return false;\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n+        }\n+    }\n+\n+    /**\n+     * Delete the global transaction.\n+     * It will operate two parts:\n+     *  1.delete the global session map\n+     *  2.remove the xid from the global status list\n+     * If the operate failed,the succeed operates will rollback\n+     * @param globalTransactionDO\n+     * @return\n+     */\n     private boolean deleteGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        String globalKey = buildGlobalKeyByTransactionId(globalTransactionDO.getTransactionId());\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String[] keys = new String[3];\n-            keys[0] = getGlobalKeyByXid(globalTransactionDO.getXid());\n-            keys[1] = getGlobalKeyByTransactionId(globalTransactionDO.getTransactionId());\n-            keys[2] = getBranchListKeyByXid(globalTransactionDO.getXid());\n-            jedis.del(keys);\n-            return true;\n+            String xid = jedis.hget(globalKey, REDIS_KEY_GLOBAL_XID);\n+            if (StringUtils.isEmpty(xid)) {\n+                LOGGER.warn(\"Global transaction is not exist,xid = {}.Maybe has been deleted by another tc server\",\n+                        globalTransactionDO.getXid());\n+                return true;\n+            }\n+            Long lrem = jedis.lrem(buildGlobalStatus(globalTransactionDO.getStatus()), 0,\n+                    globalTransactionDO.getXid());\n+            if (lrem > 0) {\n+                Long del = jedis.del(globalKey);\n+                if (del > 0) {\n+                    return true;\n+                } else {\n+                    jedis.rpush(buildGlobalStatus(globalTransactionDO.getStatus()),globalTransactionDO.getXid());\n+                    return false;\n+                }\n+            }\n+            return false;\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n         }\n     }\n \n-    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+    /**\n+     * Update the global transaction.\n+     * It will update two parts:\n+     *  1.the global session map\n+     *  2.the global status list\n+     * If the update failed,the succeed operates will rollback\n+     * @param globalTransactionDO\n+     * @return\n+     */\n+    private boolean updateGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        String xid = globalTransactionDO.getXid();\n+        String globalKey = buildGlobalKeyByTransactionId(globalTransactionDO.getTransactionId());\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String keys = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n-            Pipeline pipeline = jedis.pipelined();\n-            String json = JSON.toJSONString(convertGlobalTransactionDO);\n-            pipeline.set(keys, json);\n-            keys = getGlobalKeyByTransactionId(convertGlobalTransactionDO.getTransactionId());\n-            pipeline.set(keys, json);\n-            pipeline.sync();\n-            return true;\n+            // Defensive watch to prevent other TC server operating concurrently,Fail fast\n+            jedis.watch(globalKey);\n+            String previousStatus = jedis.hget(globalKey, REDIS_KEY_GLOBAL_STATUS);\n+            if (StringUtils.isEmpty(previousStatus)) {\n+                throw new StoreException(\"Global transaction is not exist, update global transaction failed.\");\n+            }\n+            String previousGmtModified = jedis.hget(globalKey, REDIS_KEY_GLOBAL_GMT_MODIFIED);\n+            Transaction multi = jedis.multi();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDM0ODQ5MQ=="}, "originalCommit": {"oid": "66f28c784c4c0b5b2a35cd56d2b37896dee734aa"}, "originalPosition": 312}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3NDA0NTI4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOVQwMzowNzoyOVrOHUgNew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOVQwMzowNzoyOVrOHUgNew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI2MTMwNw==", "bodyText": "use String.valueOf(XID.getTransactionId(xid))  instead\uff1f", "url": "https://github.com/seata/seata/pull/3062#discussion_r491261307", "createdAt": "2020-09-19T03:07:29Z", "author": {"login": "caohdgege"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -90,99 +93,286 @@ public static RedisTransactionStoreManager getInstance() {\n     @Override\n     public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n         if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n-            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return insertGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n-            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return updateGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n-            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return deleteGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n-            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+            return insertBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n-            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+            return updateBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n-            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+            return deleteBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else {\n             throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n         }\n     }\n \n+    /**\n+     * Insert branch transaction\n+     * @param branchTransactionDO\n+     * @return the boolean\n+     */\n+    private boolean insertBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        String branchKey = buildBranchKey(branchTransactionDO.getBranchId());\n+        String branchListKey = buildBranchListKeyByXid(branchTransactionDO.getXid());\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Date now = new Date();\n+            branchTransactionDO.setGmtCreate(now);\n+            branchTransactionDO.setGmtModified(now);\n+            Pipeline pipelined = jedis.pipelined();\n+            pipelined.hmset(branchKey, BeanUtils.objectToMap(branchTransactionDO));\n+            pipelined.rpush(branchListKey, branchKey);\n+            List<Object> objects = pipelined.syncAndReturnAll();\n+            if (CollectionUtils.isNotEmpty(objects)) {\n+                String hmset = objects.get(0).toString();\n+                Long rpush = Long.valueOf(objects.get(1).toString());\n+                if (OK.equals(hmset) && rpush > 0) {\n+                    return true;\n+                } else {\n+                    if (OK.equals(hmset)) {\n+                        jedis.del(branchKey);\n+                    }\n+                    if (rpush > 0) {\n+                        jedis.lrem(branchListKey,0,branchKey);\n+                    }\n+                    return false;\n+                }\n+            }\n+            return false;\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n+        }\n+    }\n+\n+    /**\n+     * Delete the branch transaction\n+     * @param branchTransactionDO\n+     * @return\n+     */\n     private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        String branchKey = buildBranchKey(branchTransactionDO.getBranchId());\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Map<String, String> branchTransactionDOMap = jedis.hgetAll(branchKey);\n+            String xid = branchTransactionDOMap.get(REDIS_KEY_BRANCH_XID);\n+            if (StringUtils.isEmpty(xid)) {\n+                return true;\n+            }\n+            String branchListKey = buildBranchListKeyByXid(branchTransactionDO.getXid());\n+            Pipeline pipelined = jedis.pipelined();\n+            pipelined.lrem(branchListKey, 0, branchKey);\n+            pipelined.del(branchKey);\n+            List<Object> objects = pipelined.syncAndReturnAll();\n+            if (CollectionUtils.isNotEmpty(objects)) {\n+                Long lrem = Long.valueOf(objects.get(0).toString());\n+                Long del = Long.valueOf(objects.get(1).toString());\n+                if (lrem > 0 && del > 0) {\n+                    return true;\n+                } else {\n+                    if (lrem > 0) {\n+                        jedis.rpush(branchListKey,branchKey);\n+                    }\n+                    if (del > 0) {\n+                        jedis.hmset(branchKey,branchTransactionDOMap);\n+                    }\n+                }\n+            }\n+            return false;\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n+        }\n+    }\n+\n+    /**\n+     * Update the branch transaction\n+     * @param branchTransactionDO\n+     * @return\n+     */\n+    private boolean updateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        String branchKey = buildBranchKey(branchTransactionDO.getBranchId());\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String key = getBranchKey(branchTransactionDO.getBranchId());\n-            jedis.del(key);\n-            return true;\n+            String previousBranchStatus = jedis.hget(branchKey, REDIS_KEY_BRANCH_STATUS);\n+            if (StringUtils.isEmpty(previousBranchStatus)) {\n+                throw new StoreException(\"Branch transaction is not exist, update branch transaction failed.\");\n+            }\n+            Map<String,String> map = new HashMap<>(2);\n+            map.put(REDIS_KEY_BRANCH_STATUS,String.valueOf(branchTransactionDO.getStatus()));\n+            map.put(REDIS_KEY_BRANCH_GMT_MODIFIED,String.valueOf((new Date()).getTime()));\n+            String hmset = jedis.hmset(branchKey, map);\n+            if (OK.equalsIgnoreCase(hmset)) {\n+                return true;\n+            }\n+            return false;\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n         }\n     }\n \n-    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+    /**\n+     * Insert the global transaction.\n+     * @param globalTransactionDO\n+     * @return\n+     */\n+    private boolean insertGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        String globalKey = buildGlobalKeyByTransactionId(globalTransactionDO.getTransactionId());\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String key = getBranchKey(branchTransactionDO.getBranchId());\n-            Pipeline pipeline = jedis.pipelined();\n-            if (jedis.get(key) == null) {\n-                pipeline.lpush(getBranchListKeyByXid(branchTransactionDO.getXid()), key);\n+            Date now = new Date();\n+            globalTransactionDO.setGmtCreate(now);\n+            globalTransactionDO.setGmtModified(now);\n+            Pipeline pipelined = jedis.pipelined();\n+            pipelined.hmset(globalKey, BeanUtils.objectToMap(globalTransactionDO));\n+            pipelined.rpush(buildGlobalStatus(globalTransactionDO.getStatus()), globalTransactionDO.getXid());\n+            List<Object> objects = pipelined.syncAndReturnAll();\n+            if (CollectionUtils.isNotEmpty(objects)) {\n+                String hmset = objects.get(0).toString();\n+                Long rpush = Long.valueOf(objects.get(1).toString());\n+                if (OK.equals(hmset) && rpush > 0) {\n+                    return true;\n+                } else {\n+                    if (OK.equals(hmset)) {\n+                        jedis.hdel(globalKey);\n+                    }\n+                    if (rpush > 0) {\n+                        jedis.lrem(buildGlobalStatus(globalTransactionDO.getStatus()),0, globalTransactionDO.getXid());\n+                    }\n+                    return false;\n+                }\n             }\n-            pipeline.set(key, JSON.toJSONString(branchTransactionDO));\n-            pipeline.sync();\n-            return true;\n+            return false;\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n         }\n     }\n \n+    /**\n+     * Delete the global transaction.\n+     * It will operate two parts:\n+     *  1.delete the global session map\n+     *  2.remove the xid from the global status list\n+     * If the operate failed,the succeed operates will rollback\n+     * @param globalTransactionDO\n+     * @return\n+     */\n     private boolean deleteGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        String globalKey = buildGlobalKeyByTransactionId(globalTransactionDO.getTransactionId());\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String[] keys = new String[3];\n-            keys[0] = getGlobalKeyByXid(globalTransactionDO.getXid());\n-            keys[1] = getGlobalKeyByTransactionId(globalTransactionDO.getTransactionId());\n-            keys[2] = getBranchListKeyByXid(globalTransactionDO.getXid());\n-            jedis.del(keys);\n-            return true;\n+            Map<String, String> globalTransactionDoMap = jedis.hgetAll(globalKey);\n+            String xid = globalTransactionDoMap.get(REDIS_KEY_GLOBAL_XID);\n+            if (StringUtils.isEmpty(xid)) {\n+                LOGGER.warn(\"Global transaction is not exist,xid = {}.Maybe has been deleted by another tc server\",\n+                        globalTransactionDO.getXid());\n+                return true;\n+            }\n+\n+            Pipeline pipelined = jedis.pipelined();\n+            pipelined.lrem(buildGlobalStatus(globalTransactionDO.getStatus()), 0, globalTransactionDO.getXid());\n+            pipelined.del(globalKey);\n+            List<Object> objects = pipelined.syncAndReturnAll();\n+            if (CollectionUtils.isNotEmpty(objects)) {\n+                Long lrem = Long.valueOf(objects.get(0).toString());\n+                Long del = Long.valueOf(objects.get(1).toString());\n+                if (lrem > 0 && del > 0) {\n+                    return true;\n+                } else {\n+                    if (lrem > 0) {\n+                        jedis.rpush(buildGlobalStatus(globalTransactionDO.getStatus()),globalTransactionDO.getXid());\n+                    }\n+                    if (del > 0) {\n+                        jedis.hmset(globalKey,globalTransactionDoMap);\n+                    }\n+                }\n+\n+            }\n+            return false;\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n         }\n     }\n \n-    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+    /**\n+     * Update the global transaction.\n+     * It will update two parts:\n+     *  1.the global session map\n+     *  2.the global status list\n+     * If the update failed,the succeed operates will rollback\n+     * @param globalTransactionDO\n+     * @return\n+     */\n+    private boolean updateGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        String xid = globalTransactionDO.getXid();\n+        String globalKey = buildGlobalKeyByTransactionId(globalTransactionDO.getTransactionId());\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String keys = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n-            Pipeline pipeline = jedis.pipelined();\n-            String json = JSON.toJSONString(convertGlobalTransactionDO);\n-            pipeline.set(keys, json);\n-            keys = getGlobalKeyByTransactionId(convertGlobalTransactionDO.getTransactionId());\n-            pipeline.set(keys, json);\n-            pipeline.sync();\n-            return true;\n+            // Defensive watch to prevent other TC server operating concurrently,Fail fast\n+            jedis.watch(globalKey);\n+            String previousStatus = jedis.hget(globalKey, REDIS_KEY_GLOBAL_STATUS);\n+            if (StringUtils.isEmpty(previousStatus)) {\n+                throw new StoreException(\"Global transaction is not exist, update global transaction failed.\");\n+            }\n+            String previousGmtModified = jedis.hget(globalKey, REDIS_KEY_GLOBAL_GMT_MODIFIED);\n+            Transaction multi = jedis.multi();\n+            Map<String,String> map = new HashMap<>(2);\n+            map.put(REDIS_KEY_GLOBAL_STATUS,String.valueOf(globalTransactionDO.getStatus()));\n+            map.put(REDIS_KEY_GLOBAL_GMT_MODIFIED,String.valueOf((new Date()).getTime()));\n+            multi.hmset(globalKey,map);\n+            multi.lrem(buildGlobalStatus(Integer.valueOf(previousStatus)),0, xid);\n+            multi.rpush(buildGlobalStatus(globalTransactionDO.getStatus()), xid);\n+            List<Object> exec = multi.exec();\n+            String hmset = exec.get(0).toString();\n+            long lrem  = (long)exec.get(1);\n+            long rpush = (long)exec.get(2);\n+            if (OK.equalsIgnoreCase(hmset) && lrem > 0 && rpush > 0) {\n+                return true;\n+            } else {\n+                // If someone failed, the succeed operations need rollback\n+                if (OK.equalsIgnoreCase(hmset)) {\n+                    // Defensive watch to prevent other TC server operating concurrently,give up this operate\n+                    jedis.watch(globalKey);\n+                    String xid2 = jedis.hget(globalKey, REDIS_KEY_GLOBAL_XID);\n+                    if (StringUtils.isNotEmpty(xid2)) {\n+                        Map<String,String> mapPrevious = new HashMap<>(2);\n+                        mapPrevious.put(REDIS_KEY_GLOBAL_STATUS,previousStatus);\n+                        mapPrevious.put(REDIS_KEY_GLOBAL_GMT_MODIFIED,previousGmtModified);\n+                        Transaction multi2 = jedis.multi();\n+                        multi2.hmset(globalKey,mapPrevious);\n+                        multi2.exec();\n+                    }\n+                }\n+                if (lrem > 0) {\n+                    jedis.rpush(buildGlobalStatus(Integer.valueOf(previousStatus)),xid);\n+                }\n+                if (rpush > 0) {\n+                    jedis.lrem(buildGlobalStatus(globalTransactionDO.getStatus()),0,xid);\n+                }\n+                return false;\n+            }\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n         }\n     }\n \n     /**\n      * Read session global session.\n      *\n-     * @param xid\n-     *            the xid\n-     * @param withBranchSessions\n-     *            the withBranchSessions\n+     * @param xid the xid\n+     * @param withBranchSessions  the withBranchSessions\n      * @return the global session\n      */\n     @Override\n     public GlobalSession readSession(String xid, boolean withBranchSessions) {\n-        String globalSessionJson;\n+        String transactionId = xid.split(\":\")[2];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07afa8672b209c5e544a4123e201f5dde6dea326"}, "originalPosition": 403}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3NDY2NjAzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOVQxMDowMDo1N1rOHUmPrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOVQxMDowMDo1N1rOHUmPrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTM2MDE3NA==", "bodyText": "if previousStatus == currentStatus, is it necessary to do update? or just need to return true immediately", "url": "https://github.com/seata/seata/pull/3062#discussion_r491360174", "createdAt": "2020-09-19T10:00:57Z", "author": {"login": "caohdgege"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -90,99 +93,286 @@ public static RedisTransactionStoreManager getInstance() {\n     @Override\n     public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n         if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n-            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return insertGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n-            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return updateGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n-            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return deleteGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n-            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+            return insertBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n-            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+            return updateBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n-            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+            return deleteBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else {\n             throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n         }\n     }\n \n+    /**\n+     * Insert branch transaction\n+     * @param branchTransactionDO\n+     * @return the boolean\n+     */\n+    private boolean insertBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        String branchKey = buildBranchKey(branchTransactionDO.getBranchId());\n+        String branchListKey = buildBranchListKeyByXid(branchTransactionDO.getXid());\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Date now = new Date();\n+            branchTransactionDO.setGmtCreate(now);\n+            branchTransactionDO.setGmtModified(now);\n+            Pipeline pipelined = jedis.pipelined();\n+            pipelined.hmset(branchKey, BeanUtils.objectToMap(branchTransactionDO));\n+            pipelined.rpush(branchListKey, branchKey);\n+            List<Object> objects = pipelined.syncAndReturnAll();\n+            if (CollectionUtils.isNotEmpty(objects)) {\n+                String hmset = objects.get(0).toString();\n+                Long rpush = Long.valueOf(objects.get(1).toString());\n+                if (OK.equals(hmset) && rpush > 0) {\n+                    return true;\n+                } else {\n+                    if (OK.equals(hmset)) {\n+                        jedis.del(branchKey);\n+                    }\n+                    if (rpush > 0) {\n+                        jedis.lrem(branchListKey,0,branchKey);\n+                    }\n+                    return false;\n+                }\n+            }\n+            return false;\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n+        }\n+    }\n+\n+    /**\n+     * Delete the branch transaction\n+     * @param branchTransactionDO\n+     * @return\n+     */\n     private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        String branchKey = buildBranchKey(branchTransactionDO.getBranchId());\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Map<String, String> branchTransactionDOMap = jedis.hgetAll(branchKey);\n+            String xid = branchTransactionDOMap.get(REDIS_KEY_BRANCH_XID);\n+            if (StringUtils.isEmpty(xid)) {\n+                return true;\n+            }\n+            String branchListKey = buildBranchListKeyByXid(branchTransactionDO.getXid());\n+            Pipeline pipelined = jedis.pipelined();\n+            pipelined.lrem(branchListKey, 0, branchKey);\n+            pipelined.del(branchKey);\n+            List<Object> objects = pipelined.syncAndReturnAll();\n+            if (CollectionUtils.isNotEmpty(objects)) {\n+                Long lrem = Long.valueOf(objects.get(0).toString());\n+                Long del = Long.valueOf(objects.get(1).toString());\n+                if (lrem > 0 && del > 0) {\n+                    return true;\n+                } else {\n+                    if (lrem > 0) {\n+                        jedis.rpush(branchListKey,branchKey);\n+                    }\n+                    if (del > 0) {\n+                        jedis.hmset(branchKey,branchTransactionDOMap);\n+                    }\n+                }\n+            }\n+            return false;\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n+        }\n+    }\n+\n+    /**\n+     * Update the branch transaction\n+     * @param branchTransactionDO\n+     * @return\n+     */\n+    private boolean updateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        String branchKey = buildBranchKey(branchTransactionDO.getBranchId());\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String key = getBranchKey(branchTransactionDO.getBranchId());\n-            jedis.del(key);\n-            return true;\n+            String previousBranchStatus = jedis.hget(branchKey, REDIS_KEY_BRANCH_STATUS);\n+            if (StringUtils.isEmpty(previousBranchStatus)) {\n+                throw new StoreException(\"Branch transaction is not exist, update branch transaction failed.\");\n+            }\n+            Map<String,String> map = new HashMap<>(2);\n+            map.put(REDIS_KEY_BRANCH_STATUS,String.valueOf(branchTransactionDO.getStatus()));\n+            map.put(REDIS_KEY_BRANCH_GMT_MODIFIED,String.valueOf((new Date()).getTime()));\n+            String hmset = jedis.hmset(branchKey, map);\n+            if (OK.equalsIgnoreCase(hmset)) {\n+                return true;\n+            }\n+            return false;\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n         }\n     }\n \n-    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+    /**\n+     * Insert the global transaction.\n+     * @param globalTransactionDO\n+     * @return\n+     */\n+    private boolean insertGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        String globalKey = buildGlobalKeyByTransactionId(globalTransactionDO.getTransactionId());\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String key = getBranchKey(branchTransactionDO.getBranchId());\n-            Pipeline pipeline = jedis.pipelined();\n-            if (jedis.get(key) == null) {\n-                pipeline.lpush(getBranchListKeyByXid(branchTransactionDO.getXid()), key);\n+            Date now = new Date();\n+            globalTransactionDO.setGmtCreate(now);\n+            globalTransactionDO.setGmtModified(now);\n+            Pipeline pipelined = jedis.pipelined();\n+            pipelined.hmset(globalKey, BeanUtils.objectToMap(globalTransactionDO));\n+            pipelined.rpush(buildGlobalStatus(globalTransactionDO.getStatus()), globalTransactionDO.getXid());\n+            List<Object> objects = pipelined.syncAndReturnAll();\n+            if (CollectionUtils.isNotEmpty(objects)) {\n+                String hmset = objects.get(0).toString();\n+                Long rpush = Long.valueOf(objects.get(1).toString());\n+                if (OK.equals(hmset) && rpush > 0) {\n+                    return true;\n+                } else {\n+                    if (OK.equals(hmset)) {\n+                        jedis.hdel(globalKey);\n+                    }\n+                    if (rpush > 0) {\n+                        jedis.lrem(buildGlobalStatus(globalTransactionDO.getStatus()),0, globalTransactionDO.getXid());\n+                    }\n+                    return false;\n+                }\n             }\n-            pipeline.set(key, JSON.toJSONString(branchTransactionDO));\n-            pipeline.sync();\n-            return true;\n+            return false;\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n         }\n     }\n \n+    /**\n+     * Delete the global transaction.\n+     * It will operate two parts:\n+     *  1.delete the global session map\n+     *  2.remove the xid from the global status list\n+     * If the operate failed,the succeed operates will rollback\n+     * @param globalTransactionDO\n+     * @return\n+     */\n     private boolean deleteGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        String globalKey = buildGlobalKeyByTransactionId(globalTransactionDO.getTransactionId());\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String[] keys = new String[3];\n-            keys[0] = getGlobalKeyByXid(globalTransactionDO.getXid());\n-            keys[1] = getGlobalKeyByTransactionId(globalTransactionDO.getTransactionId());\n-            keys[2] = getBranchListKeyByXid(globalTransactionDO.getXid());\n-            jedis.del(keys);\n-            return true;\n+            Map<String, String> globalTransactionDoMap = jedis.hgetAll(globalKey);\n+            String xid = globalTransactionDoMap.get(REDIS_KEY_GLOBAL_XID);\n+            if (StringUtils.isEmpty(xid)) {\n+                LOGGER.warn(\"Global transaction is not exist,xid = {}.Maybe has been deleted by another tc server\",\n+                        globalTransactionDO.getXid());\n+                return true;\n+            }\n+\n+            Pipeline pipelined = jedis.pipelined();\n+            pipelined.lrem(buildGlobalStatus(globalTransactionDO.getStatus()), 0, globalTransactionDO.getXid());\n+            pipelined.del(globalKey);\n+            List<Object> objects = pipelined.syncAndReturnAll();\n+            if (CollectionUtils.isNotEmpty(objects)) {\n+                Long lrem = Long.valueOf(objects.get(0).toString());\n+                Long del = Long.valueOf(objects.get(1).toString());\n+                if (lrem > 0 && del > 0) {\n+                    return true;\n+                } else {\n+                    if (lrem > 0) {\n+                        jedis.rpush(buildGlobalStatus(globalTransactionDO.getStatus()),globalTransactionDO.getXid());\n+                    }\n+                    if (del > 0) {\n+                        jedis.hmset(globalKey,globalTransactionDoMap);\n+                    }\n+                }\n+\n+            }\n+            return false;\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n         }\n     }\n \n-    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+    /**\n+     * Update the global transaction.\n+     * It will update two parts:\n+     *  1.the global session map\n+     *  2.the global status list\n+     * If the update failed,the succeed operates will rollback\n+     * @param globalTransactionDO\n+     * @return\n+     */\n+    private boolean updateGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        String xid = globalTransactionDO.getXid();\n+        String globalKey = buildGlobalKeyByTransactionId(globalTransactionDO.getTransactionId());\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String keys = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n-            Pipeline pipeline = jedis.pipelined();\n-            String json = JSON.toJSONString(convertGlobalTransactionDO);\n-            pipeline.set(keys, json);\n-            keys = getGlobalKeyByTransactionId(convertGlobalTransactionDO.getTransactionId());\n-            pipeline.set(keys, json);\n-            pipeline.sync();\n-            return true;\n+            // Defensive watch to prevent other TC server operating concurrently,Fail fast\n+            jedis.watch(globalKey);\n+            String previousStatus = jedis.hget(globalKey, REDIS_KEY_GLOBAL_STATUS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07afa8672b209c5e544a4123e201f5dde6dea326"}, "originalPosition": 343}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3NDY3NTMyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOVQxMDowNToyNFrOHUmVdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxMzo0ODozNFrOHVQ6CA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTM2MTY1Mw==", "bodyText": "using hmget to get REDIS_KEY_GLOBAL_GMT_MODIFIED\uff0cREDIS_KEY_GLOBAL_STATUS in one time?", "url": "https://github.com/seata/seata/pull/3062#discussion_r491361653", "createdAt": "2020-09-19T10:05:24Z", "author": {"login": "caohdgege"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -90,99 +93,286 @@ public static RedisTransactionStoreManager getInstance() {\n     @Override\n     public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n         if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n-            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return insertGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n-            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return updateGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n-            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return deleteGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n-            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+            return insertBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n-            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+            return updateBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n-            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+            return deleteBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else {\n             throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n         }\n     }\n \n+    /**\n+     * Insert branch transaction\n+     * @param branchTransactionDO\n+     * @return the boolean\n+     */\n+    private boolean insertBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        String branchKey = buildBranchKey(branchTransactionDO.getBranchId());\n+        String branchListKey = buildBranchListKeyByXid(branchTransactionDO.getXid());\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Date now = new Date();\n+            branchTransactionDO.setGmtCreate(now);\n+            branchTransactionDO.setGmtModified(now);\n+            Pipeline pipelined = jedis.pipelined();\n+            pipelined.hmset(branchKey, BeanUtils.objectToMap(branchTransactionDO));\n+            pipelined.rpush(branchListKey, branchKey);\n+            List<Object> objects = pipelined.syncAndReturnAll();\n+            if (CollectionUtils.isNotEmpty(objects)) {\n+                String hmset = objects.get(0).toString();\n+                Long rpush = Long.valueOf(objects.get(1).toString());\n+                if (OK.equals(hmset) && rpush > 0) {\n+                    return true;\n+                } else {\n+                    if (OK.equals(hmset)) {\n+                        jedis.del(branchKey);\n+                    }\n+                    if (rpush > 0) {\n+                        jedis.lrem(branchListKey,0,branchKey);\n+                    }\n+                    return false;\n+                }\n+            }\n+            return false;\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n+        }\n+    }\n+\n+    /**\n+     * Delete the branch transaction\n+     * @param branchTransactionDO\n+     * @return\n+     */\n     private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        String branchKey = buildBranchKey(branchTransactionDO.getBranchId());\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Map<String, String> branchTransactionDOMap = jedis.hgetAll(branchKey);\n+            String xid = branchTransactionDOMap.get(REDIS_KEY_BRANCH_XID);\n+            if (StringUtils.isEmpty(xid)) {\n+                return true;\n+            }\n+            String branchListKey = buildBranchListKeyByXid(branchTransactionDO.getXid());\n+            Pipeline pipelined = jedis.pipelined();\n+            pipelined.lrem(branchListKey, 0, branchKey);\n+            pipelined.del(branchKey);\n+            List<Object> objects = pipelined.syncAndReturnAll();\n+            if (CollectionUtils.isNotEmpty(objects)) {\n+                Long lrem = Long.valueOf(objects.get(0).toString());\n+                Long del = Long.valueOf(objects.get(1).toString());\n+                if (lrem > 0 && del > 0) {\n+                    return true;\n+                } else {\n+                    if (lrem > 0) {\n+                        jedis.rpush(branchListKey,branchKey);\n+                    }\n+                    if (del > 0) {\n+                        jedis.hmset(branchKey,branchTransactionDOMap);\n+                    }\n+                }\n+            }\n+            return false;\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n+        }\n+    }\n+\n+    /**\n+     * Update the branch transaction\n+     * @param branchTransactionDO\n+     * @return\n+     */\n+    private boolean updateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        String branchKey = buildBranchKey(branchTransactionDO.getBranchId());\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String key = getBranchKey(branchTransactionDO.getBranchId());\n-            jedis.del(key);\n-            return true;\n+            String previousBranchStatus = jedis.hget(branchKey, REDIS_KEY_BRANCH_STATUS);\n+            if (StringUtils.isEmpty(previousBranchStatus)) {\n+                throw new StoreException(\"Branch transaction is not exist, update branch transaction failed.\");\n+            }\n+            Map<String,String> map = new HashMap<>(2);\n+            map.put(REDIS_KEY_BRANCH_STATUS,String.valueOf(branchTransactionDO.getStatus()));\n+            map.put(REDIS_KEY_BRANCH_GMT_MODIFIED,String.valueOf((new Date()).getTime()));\n+            String hmset = jedis.hmset(branchKey, map);\n+            if (OK.equalsIgnoreCase(hmset)) {\n+                return true;\n+            }\n+            return false;\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n         }\n     }\n \n-    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+    /**\n+     * Insert the global transaction.\n+     * @param globalTransactionDO\n+     * @return\n+     */\n+    private boolean insertGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        String globalKey = buildGlobalKeyByTransactionId(globalTransactionDO.getTransactionId());\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String key = getBranchKey(branchTransactionDO.getBranchId());\n-            Pipeline pipeline = jedis.pipelined();\n-            if (jedis.get(key) == null) {\n-                pipeline.lpush(getBranchListKeyByXid(branchTransactionDO.getXid()), key);\n+            Date now = new Date();\n+            globalTransactionDO.setGmtCreate(now);\n+            globalTransactionDO.setGmtModified(now);\n+            Pipeline pipelined = jedis.pipelined();\n+            pipelined.hmset(globalKey, BeanUtils.objectToMap(globalTransactionDO));\n+            pipelined.rpush(buildGlobalStatus(globalTransactionDO.getStatus()), globalTransactionDO.getXid());\n+            List<Object> objects = pipelined.syncAndReturnAll();\n+            if (CollectionUtils.isNotEmpty(objects)) {\n+                String hmset = objects.get(0).toString();\n+                Long rpush = Long.valueOf(objects.get(1).toString());\n+                if (OK.equals(hmset) && rpush > 0) {\n+                    return true;\n+                } else {\n+                    if (OK.equals(hmset)) {\n+                        jedis.hdel(globalKey);\n+                    }\n+                    if (rpush > 0) {\n+                        jedis.lrem(buildGlobalStatus(globalTransactionDO.getStatus()),0, globalTransactionDO.getXid());\n+                    }\n+                    return false;\n+                }\n             }\n-            pipeline.set(key, JSON.toJSONString(branchTransactionDO));\n-            pipeline.sync();\n-            return true;\n+            return false;\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n         }\n     }\n \n+    /**\n+     * Delete the global transaction.\n+     * It will operate two parts:\n+     *  1.delete the global session map\n+     *  2.remove the xid from the global status list\n+     * If the operate failed,the succeed operates will rollback\n+     * @param globalTransactionDO\n+     * @return\n+     */\n     private boolean deleteGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        String globalKey = buildGlobalKeyByTransactionId(globalTransactionDO.getTransactionId());\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String[] keys = new String[3];\n-            keys[0] = getGlobalKeyByXid(globalTransactionDO.getXid());\n-            keys[1] = getGlobalKeyByTransactionId(globalTransactionDO.getTransactionId());\n-            keys[2] = getBranchListKeyByXid(globalTransactionDO.getXid());\n-            jedis.del(keys);\n-            return true;\n+            Map<String, String> globalTransactionDoMap = jedis.hgetAll(globalKey);\n+            String xid = globalTransactionDoMap.get(REDIS_KEY_GLOBAL_XID);\n+            if (StringUtils.isEmpty(xid)) {\n+                LOGGER.warn(\"Global transaction is not exist,xid = {}.Maybe has been deleted by another tc server\",\n+                        globalTransactionDO.getXid());\n+                return true;\n+            }\n+\n+            Pipeline pipelined = jedis.pipelined();\n+            pipelined.lrem(buildGlobalStatus(globalTransactionDO.getStatus()), 0, globalTransactionDO.getXid());\n+            pipelined.del(globalKey);\n+            List<Object> objects = pipelined.syncAndReturnAll();\n+            if (CollectionUtils.isNotEmpty(objects)) {\n+                Long lrem = Long.valueOf(objects.get(0).toString());\n+                Long del = Long.valueOf(objects.get(1).toString());\n+                if (lrem > 0 && del > 0) {\n+                    return true;\n+                } else {\n+                    if (lrem > 0) {\n+                        jedis.rpush(buildGlobalStatus(globalTransactionDO.getStatus()),globalTransactionDO.getXid());\n+                    }\n+                    if (del > 0) {\n+                        jedis.hmset(globalKey,globalTransactionDoMap);\n+                    }\n+                }\n+\n+            }\n+            return false;\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n         }\n     }\n \n-    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+    /**\n+     * Update the global transaction.\n+     * It will update two parts:\n+     *  1.the global session map\n+     *  2.the global status list\n+     * If the update failed,the succeed operates will rollback\n+     * @param globalTransactionDO\n+     * @return\n+     */\n+    private boolean updateGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        String xid = globalTransactionDO.getXid();\n+        String globalKey = buildGlobalKeyByTransactionId(globalTransactionDO.getTransactionId());\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String keys = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n-            Pipeline pipeline = jedis.pipelined();\n-            String json = JSON.toJSONString(convertGlobalTransactionDO);\n-            pipeline.set(keys, json);\n-            keys = getGlobalKeyByTransactionId(convertGlobalTransactionDO.getTransactionId());\n-            pipeline.set(keys, json);\n-            pipeline.sync();\n-            return true;\n+            // Defensive watch to prevent other TC server operating concurrently,Fail fast\n+            jedis.watch(globalKey);\n+            String previousStatus = jedis.hget(globalKey, REDIS_KEY_GLOBAL_STATUS);\n+            if (StringUtils.isEmpty(previousStatus)) {\n+                throw new StoreException(\"Global transaction is not exist, update global transaction failed.\");\n+            }\n+            String previousGmtModified = jedis.hget(globalKey, REDIS_KEY_GLOBAL_GMT_MODIFIED);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07afa8672b209c5e544a4123e201f5dde6dea326"}, "originalPosition": 347}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjA1OTE0NA==", "bodyText": "using hmget to get REDIS_KEY_GLOBAL_GMT_MODIFIED\uff0cREDIS_KEY_GLOBAL_STATUS in one times?\n\ngood idea,i will change", "url": "https://github.com/seata/seata/pull/3062#discussion_r492059144", "createdAt": "2020-09-21T13:48:34Z", "author": {"login": "lightClouds917"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -90,99 +93,286 @@ public static RedisTransactionStoreManager getInstance() {\n     @Override\n     public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n         if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n-            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return insertGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n-            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return updateGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n-            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return deleteGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n-            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+            return insertBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n-            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+            return updateBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n-            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+            return deleteBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else {\n             throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n         }\n     }\n \n+    /**\n+     * Insert branch transaction\n+     * @param branchTransactionDO\n+     * @return the boolean\n+     */\n+    private boolean insertBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        String branchKey = buildBranchKey(branchTransactionDO.getBranchId());\n+        String branchListKey = buildBranchListKeyByXid(branchTransactionDO.getXid());\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Date now = new Date();\n+            branchTransactionDO.setGmtCreate(now);\n+            branchTransactionDO.setGmtModified(now);\n+            Pipeline pipelined = jedis.pipelined();\n+            pipelined.hmset(branchKey, BeanUtils.objectToMap(branchTransactionDO));\n+            pipelined.rpush(branchListKey, branchKey);\n+            List<Object> objects = pipelined.syncAndReturnAll();\n+            if (CollectionUtils.isNotEmpty(objects)) {\n+                String hmset = objects.get(0).toString();\n+                Long rpush = Long.valueOf(objects.get(1).toString());\n+                if (OK.equals(hmset) && rpush > 0) {\n+                    return true;\n+                } else {\n+                    if (OK.equals(hmset)) {\n+                        jedis.del(branchKey);\n+                    }\n+                    if (rpush > 0) {\n+                        jedis.lrem(branchListKey,0,branchKey);\n+                    }\n+                    return false;\n+                }\n+            }\n+            return false;\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n+        }\n+    }\n+\n+    /**\n+     * Delete the branch transaction\n+     * @param branchTransactionDO\n+     * @return\n+     */\n     private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        String branchKey = buildBranchKey(branchTransactionDO.getBranchId());\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Map<String, String> branchTransactionDOMap = jedis.hgetAll(branchKey);\n+            String xid = branchTransactionDOMap.get(REDIS_KEY_BRANCH_XID);\n+            if (StringUtils.isEmpty(xid)) {\n+                return true;\n+            }\n+            String branchListKey = buildBranchListKeyByXid(branchTransactionDO.getXid());\n+            Pipeline pipelined = jedis.pipelined();\n+            pipelined.lrem(branchListKey, 0, branchKey);\n+            pipelined.del(branchKey);\n+            List<Object> objects = pipelined.syncAndReturnAll();\n+            if (CollectionUtils.isNotEmpty(objects)) {\n+                Long lrem = Long.valueOf(objects.get(0).toString());\n+                Long del = Long.valueOf(objects.get(1).toString());\n+                if (lrem > 0 && del > 0) {\n+                    return true;\n+                } else {\n+                    if (lrem > 0) {\n+                        jedis.rpush(branchListKey,branchKey);\n+                    }\n+                    if (del > 0) {\n+                        jedis.hmset(branchKey,branchTransactionDOMap);\n+                    }\n+                }\n+            }\n+            return false;\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n+        }\n+    }\n+\n+    /**\n+     * Update the branch transaction\n+     * @param branchTransactionDO\n+     * @return\n+     */\n+    private boolean updateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        String branchKey = buildBranchKey(branchTransactionDO.getBranchId());\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String key = getBranchKey(branchTransactionDO.getBranchId());\n-            jedis.del(key);\n-            return true;\n+            String previousBranchStatus = jedis.hget(branchKey, REDIS_KEY_BRANCH_STATUS);\n+            if (StringUtils.isEmpty(previousBranchStatus)) {\n+                throw new StoreException(\"Branch transaction is not exist, update branch transaction failed.\");\n+            }\n+            Map<String,String> map = new HashMap<>(2);\n+            map.put(REDIS_KEY_BRANCH_STATUS,String.valueOf(branchTransactionDO.getStatus()));\n+            map.put(REDIS_KEY_BRANCH_GMT_MODIFIED,String.valueOf((new Date()).getTime()));\n+            String hmset = jedis.hmset(branchKey, map);\n+            if (OK.equalsIgnoreCase(hmset)) {\n+                return true;\n+            }\n+            return false;\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n         }\n     }\n \n-    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+    /**\n+     * Insert the global transaction.\n+     * @param globalTransactionDO\n+     * @return\n+     */\n+    private boolean insertGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        String globalKey = buildGlobalKeyByTransactionId(globalTransactionDO.getTransactionId());\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String key = getBranchKey(branchTransactionDO.getBranchId());\n-            Pipeline pipeline = jedis.pipelined();\n-            if (jedis.get(key) == null) {\n-                pipeline.lpush(getBranchListKeyByXid(branchTransactionDO.getXid()), key);\n+            Date now = new Date();\n+            globalTransactionDO.setGmtCreate(now);\n+            globalTransactionDO.setGmtModified(now);\n+            Pipeline pipelined = jedis.pipelined();\n+            pipelined.hmset(globalKey, BeanUtils.objectToMap(globalTransactionDO));\n+            pipelined.rpush(buildGlobalStatus(globalTransactionDO.getStatus()), globalTransactionDO.getXid());\n+            List<Object> objects = pipelined.syncAndReturnAll();\n+            if (CollectionUtils.isNotEmpty(objects)) {\n+                String hmset = objects.get(0).toString();\n+                Long rpush = Long.valueOf(objects.get(1).toString());\n+                if (OK.equals(hmset) && rpush > 0) {\n+                    return true;\n+                } else {\n+                    if (OK.equals(hmset)) {\n+                        jedis.hdel(globalKey);\n+                    }\n+                    if (rpush > 0) {\n+                        jedis.lrem(buildGlobalStatus(globalTransactionDO.getStatus()),0, globalTransactionDO.getXid());\n+                    }\n+                    return false;\n+                }\n             }\n-            pipeline.set(key, JSON.toJSONString(branchTransactionDO));\n-            pipeline.sync();\n-            return true;\n+            return false;\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n         }\n     }\n \n+    /**\n+     * Delete the global transaction.\n+     * It will operate two parts:\n+     *  1.delete the global session map\n+     *  2.remove the xid from the global status list\n+     * If the operate failed,the succeed operates will rollback\n+     * @param globalTransactionDO\n+     * @return\n+     */\n     private boolean deleteGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        String globalKey = buildGlobalKeyByTransactionId(globalTransactionDO.getTransactionId());\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String[] keys = new String[3];\n-            keys[0] = getGlobalKeyByXid(globalTransactionDO.getXid());\n-            keys[1] = getGlobalKeyByTransactionId(globalTransactionDO.getTransactionId());\n-            keys[2] = getBranchListKeyByXid(globalTransactionDO.getXid());\n-            jedis.del(keys);\n-            return true;\n+            Map<String, String> globalTransactionDoMap = jedis.hgetAll(globalKey);\n+            String xid = globalTransactionDoMap.get(REDIS_KEY_GLOBAL_XID);\n+            if (StringUtils.isEmpty(xid)) {\n+                LOGGER.warn(\"Global transaction is not exist,xid = {}.Maybe has been deleted by another tc server\",\n+                        globalTransactionDO.getXid());\n+                return true;\n+            }\n+\n+            Pipeline pipelined = jedis.pipelined();\n+            pipelined.lrem(buildGlobalStatus(globalTransactionDO.getStatus()), 0, globalTransactionDO.getXid());\n+            pipelined.del(globalKey);\n+            List<Object> objects = pipelined.syncAndReturnAll();\n+            if (CollectionUtils.isNotEmpty(objects)) {\n+                Long lrem = Long.valueOf(objects.get(0).toString());\n+                Long del = Long.valueOf(objects.get(1).toString());\n+                if (lrem > 0 && del > 0) {\n+                    return true;\n+                } else {\n+                    if (lrem > 0) {\n+                        jedis.rpush(buildGlobalStatus(globalTransactionDO.getStatus()),globalTransactionDO.getXid());\n+                    }\n+                    if (del > 0) {\n+                        jedis.hmset(globalKey,globalTransactionDoMap);\n+                    }\n+                }\n+\n+            }\n+            return false;\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n         }\n     }\n \n-    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+    /**\n+     * Update the global transaction.\n+     * It will update two parts:\n+     *  1.the global session map\n+     *  2.the global status list\n+     * If the update failed,the succeed operates will rollback\n+     * @param globalTransactionDO\n+     * @return\n+     */\n+    private boolean updateGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        String xid = globalTransactionDO.getXid();\n+        String globalKey = buildGlobalKeyByTransactionId(globalTransactionDO.getTransactionId());\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String keys = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n-            Pipeline pipeline = jedis.pipelined();\n-            String json = JSON.toJSONString(convertGlobalTransactionDO);\n-            pipeline.set(keys, json);\n-            keys = getGlobalKeyByTransactionId(convertGlobalTransactionDO.getTransactionId());\n-            pipeline.set(keys, json);\n-            pipeline.sync();\n-            return true;\n+            // Defensive watch to prevent other TC server operating concurrently,Fail fast\n+            jedis.watch(globalKey);\n+            String previousStatus = jedis.hget(globalKey, REDIS_KEY_GLOBAL_STATUS);\n+            if (StringUtils.isEmpty(previousStatus)) {\n+                throw new StoreException(\"Global transaction is not exist, update global transaction failed.\");\n+            }\n+            String previousGmtModified = jedis.hget(globalKey, REDIS_KEY_GLOBAL_GMT_MODIFIED);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTM2MTY1Mw=="}, "originalCommit": {"oid": "07afa8672b209c5e544a4123e201f5dde6dea326"}, "originalPosition": 347}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1MTQwNjUxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwOTowNTo0NFrOHf1tyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwOTowNTo0NFrOHf1tyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzE0Nzk3OQ==", "bodyText": "Repeat method", "url": "https://github.com/seata/seata/pull/3062#discussion_r503147979", "createdAt": "2020-10-12T09:05:44Z", "author": {"login": "ph3636"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -200,213 +334,153 @@ public GlobalSession readSession(String xid) {\n     }\n \n     /**\n-     * Read session list.\n+     * Read globalSession list by global status\n      *\n-     * @param statuses\n-     *            the statuses\n+     * @param statuses the statuses\n      * @return the list\n      */\n     public List<GlobalSession> readSession(GlobalStatus[] statuses) {\n-        List<Integer> states = new ArrayList<>();\n+        List<String> statusKeys = new ArrayList<>();\n         for (int i = 0; i < statuses.length; i++) {\n-            states.add(statuses[i].getCode());\n+            statusKeys.add(buildGlobalStatus(statuses[i].getCode()));\n         }\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            Set<String> keys = new HashSet<>();\n-            String cursor = INITIAL_CURSOR;\n-            ScanParams params = new ScanParams();\n-            params.count(logQueryLimit);\n-            params.match(getGlobalKeyByXid(\"*\"));\n-            ScanResult<String> scans;\n-            do {\n-                scans = jedis.scan(cursor, params);\n-                keys.addAll(scans.getResult());\n-                cursor = scans.getCursor();\n-            } while (!INITIAL_CURSOR.equals(cursor));\n-            if (CollectionUtils.isNotEmpty(keys)) {\n-                List<GlobalTransactionDO> globalTransactionDOs = new ArrayList<>();\n-                for (String globalKey : keys) {\n-                    GlobalTransactionDO globalTransactionDO =\n-                        JSON.parseObject(jedis.get(globalKey), GlobalTransactionDO.class);\n-                    if (globalTransactionDO != null && states.contains(globalTransactionDO.getStatus())) {\n-                        globalTransactionDOs.add(globalTransactionDO);\n-                    }\n-                }\n-                if (CollectionUtils.isNotEmpty(globalTransactionDOs)) {\n-                    List<String> xids =\n-                        globalTransactionDOs.stream().map(GlobalTransactionDO::getXid).collect(Collectors.toList());\n-                    List<BranchTransactionDO> branchTransactionDOs = new ArrayList<>();\n-                    for (String xid : xids) {\n-                        Set<String> branches = lRange(jedis, getBranchListKeyByXid(xid));\n-                        if (CollectionUtils.isNotEmpty(branches)) {\n-                            branchTransactionDOs.addAll(getBranchJsons(jedis, branches));\n-                        }\n-                    }\n-                    Map<String, List<BranchTransactionDO>> branchTransactionDOsMap =\n-                        branchTransactionDOs.stream().collect(Collectors.groupingBy(BranchTransactionDO::getXid,\n-                            LinkedHashMap::new, Collectors.toList()));\n-                    return globalTransactionDOs.stream()\n-                        .map(globalTransactionDO -> getGlobalSession(globalTransactionDO,\n-                            branchTransactionDOsMap.get(globalTransactionDO.getXid())))\n-                        .collect(Collectors.toList());\n-                }\n+            Pipeline pipelined = jedis.pipelined();\n+            statusKeys.stream().forEach(statusKey -> pipelined.lrange(statusKey,0,-1));\n+            List<List<String>> list = (List<List<String>>)(List)pipelined.syncAndReturnAll();\n+            List<String> xids = new ArrayList<>();\n+            if (CollectionUtils.isNotEmpty(list)) {\n+                xids = list.stream().flatMap(ll -> ll.stream()).collect(Collectors.toList());\n             }\n+            List<GlobalSession> globalSessions = new ArrayList<>();\n+            xids.parallelStream().forEach(xid -> {\n+                GlobalSession globalSession = this.readSession(xid, true);\n+                if (globalSession != null) {\n+                    globalSessions.add(globalSession);\n+                }\n+            });\n+            return globalSessions;\n         }\n-        return null;\n     }\n \n+    /**\n+     * read the global session list by different condition\n+     * @param sessionCondition the session condition\n+     * @return the global sessions\n+     */\n     @Override\n     public List<GlobalSession> readSession(SessionCondition sessionCondition) {\n-        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            if (!StringUtils.isEmpty(sessionCondition.getXid())) {\n-                String globalSessionJson = jedis.get(getGlobalKeyByXid(sessionCondition.getXid()));\n-                if (!StringUtils.isEmpty(globalSessionJson)) {\n-                    GlobalSession session =\n-                        convertGlobalSession(JSON.parseObject(globalSessionJson, GlobalTransactionDO.class));\n-                    List<GlobalSession> globalSessions = new ArrayList<>();\n-                    globalSessions.add(session);\n-                    return globalSessions;\n-                }\n-            } else if (sessionCondition.getTransactionId() != null) {\n-                String global = jedis.get(getGlobalKeyByTransactionId(sessionCondition.getTransactionId()));\n-                if (StringUtils.isEmpty(global)) {\n-                    return null;\n-                }\n-                GlobalTransactionDO globalTransactionDO = JSON.parseObject(global, GlobalTransactionDO.class);\n-                String branchKey = getBranchListKeyByXid(globalTransactionDO.getXid());\n-                Set<String> keys = lRange(jedis, branchKey);\n-                List<BranchTransactionDO> branchTransactionDOs = null;\n-                if (CollectionUtils.isNotEmpty(keys)) {\n-                    branchTransactionDOs = getBranchJsons(jedis, keys);\n-                }\n-                GlobalSession globalSession = getGlobalSession(globalTransactionDO, branchTransactionDOs);\n-                List<GlobalSession> globalSessions = new ArrayList<>();\n+        List<GlobalSession> globalSessions = new ArrayList<>();\n+        if (StringUtils.isNotEmpty(sessionCondition.getXid())) {\n+            GlobalSession globalSession = this.readSession(sessionCondition.getXid(), true);\n+            if (globalSession != null) {\n                 globalSessions.add(globalSession);\n-                return globalSessions;\n-            } else if (CollectionUtils.isNotEmpty(sessionCondition.getStatuses())) {\n-                return readSession(sessionCondition.getStatuses());\n             }\n+            return globalSessions;\n+        } else if (sessionCondition.getTransactionId() != null) {\n+            GlobalSession globalSession = this\n+                    .readSessionByTransactionId(sessionCondition.getTransactionId().toString(), true);\n+            if (globalSession != null) {\n+                globalSessions.add(globalSession);\n+            }\n+            return globalSessions;\n+        } else if (CollectionUtils.isNotEmpty(sessionCondition.getStatuses())) {\n+            return readSession(sessionCondition.getStatuses());\n+        } else if (sessionCondition.getStatus() != null) {\n+            return readSession(new GlobalStatus[]{sessionCondition.getStatus()});\n         }\n         return null;\n     }\n \n-    private List<BranchTransactionDO> getBranchJsons(Jedis jedis, Set<String> keys) {\n-        List<BranchTransactionDO> branchTransactionDOs = new ArrayList<>();\n-        List<String> branchJsons = jedis.mget(keys.toArray(new String[0]));\n-        for (String branchJson : branchJsons) {\n-            if (!StringUtils.isEmpty(branchJson)) {\n-                branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+    /**\n+     * assemble the global session and branch session\n+     * @param globalTransactionDO the global transactionDo\n+     * @param branchTransactionDOs the branch transactionDos\n+     * @return the global session with branch session\n+     */\n+    private GlobalSession getGlobalSession(GlobalTransactionDO globalTransactionDO,\n+            List<BranchTransactionDO> branchTransactionDOs) {\n+        GlobalSession globalSession = SessionConverter.convertGlobalSession(globalTransactionDO);\n+        if (CollectionUtils.isNotEmpty(branchTransactionDOs)) {\n+            for (BranchTransactionDO branchTransactionDO : branchTransactionDOs) {\n+                globalSession.add(SessionConverter.convertBranchSession(branchTransactionDO));\n             }\n         }\n-        return branchTransactionDOs;\n+        return globalSession;\n     }\n \n-    private GlobalTransactionDO convertGlobalTransactionDO(SessionStorable session) {\n-        if (session == null || !(session instanceof GlobalSession)) {\n-            throw new IllegalArgumentException(\n-                \"the parameter of SessionStorable is not available, SessionStorable:\" + StringUtils.toString(session));\n+    /**\n+     * read the global session by transactionId\n+     * @param transactionId the transaction id\n+     * @param withBranchSessions if read branch sessions\n+     * @return the global session\n+     */\n+    private GlobalSession readSessionByTransactionId(String transactionId, boolean withBranchSessions) {\n+        String globalKey = buildGlobalKeyByTransactionId(transactionId);\n+        String xid = null;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Map<String, String> map  = jedis.hgetAll(globalKey);\n+            if (CollectionUtils.isEmpty(map)) {\n+                return null;\n+            }\n+            GlobalTransactionDO globalTransactionDO = (GlobalTransactionDO)BeanUtils.mapToObject(map, GlobalTransactionDO.class);\n+            if (globalTransactionDO != null) {\n+                xid = globalTransactionDO.getXid();\n+            }\n+            List<BranchTransactionDO> branchTransactionDOs = new ArrayList<>();\n+            if (withBranchSessions) {\n+                branchTransactionDOs = this.readBranchSessionByXid(jedis,xid);\n+            }\n+            return getGlobalSession(globalTransactionDO,branchTransactionDOs);\n         }\n-        GlobalSession globalSession = (GlobalSession)session;\n-\n-        GlobalTransactionDO globalTransactionDO = new GlobalTransactionDO();\n-        globalTransactionDO.setXid(globalSession.getXid());\n-        globalTransactionDO.setStatus(globalSession.getStatus().getCode());\n-        globalTransactionDO.setApplicationId(globalSession.getApplicationId());\n-        globalTransactionDO.setBeginTime(globalSession.getBeginTime());\n-        globalTransactionDO.setTimeout(globalSession.getTimeout());\n-        globalTransactionDO.setTransactionId(globalSession.getTransactionId());\n-        globalTransactionDO.setTransactionName(globalSession.getTransactionName());\n-        globalTransactionDO.setTransactionServiceGroup(globalSession.getTransactionServiceGroup());\n-        globalTransactionDO.setApplicationData(globalSession.getApplicationData());\n-        return globalTransactionDO;\n     }\n \n-    private BranchTransactionDO convertBranchTransactionDO(SessionStorable session) {\n-        if (session == null || !(session instanceof BranchSession)) {\n-            throw new IllegalArgumentException(\n-                \"the parameter of SessionStorable is not available, SessionStorable:\" + StringUtils.toString(session));\n+    /**\n+     * Read the branch session list by xid\n+     * @param jedis\n+     * @param xid the xid\n+     * @return the branch transactionDo list\n+     */\n+    private List<BranchTransactionDO> readBranchSessionByXid(Jedis jedis,String xid) {\n+        List<BranchTransactionDO> branchTransactionDOs = new ArrayList<>();\n+        String branchListKey = buildBranchListKeyByXid(xid);\n+        List<String> branchKeys = jedis.lrange(branchListKey, 0, -1);\n+        Pipeline pipeline = jedis.pipelined();\n+        if (CollectionUtils.isNotEmpty(branchKeys)) {\n+            branchKeys.stream().forEachOrdered(branchKey -> pipeline.hgetAll(branchKey));\n+            List<Object> branchInfos = pipeline.syncAndReturnAll();\n+            for (Object branchInfo : branchInfos) {\n+                if (branchInfo != null) {\n+                    Map<String, String> branchInfoMap = (Map<String, String>) branchInfo;\n+                    BranchTransactionDO branchTransactionDO =\n+                            (BranchTransactionDO) BeanUtils.mapToObject(branchInfoMap, BranchTransactionDO.class);\n+                    branchTransactionDOs.add(branchTransactionDO);\n+                }\n+            }\n         }\n-        BranchSession branchSession = (BranchSession)session;\n-\n-        BranchTransactionDO branchTransactionDO = new BranchTransactionDO();\n-        branchTransactionDO.setXid(branchSession.getXid());\n-        branchTransactionDO.setBranchId(branchSession.getBranchId());\n-        branchTransactionDO.setBranchType(branchSession.getBranchType().name());\n-        branchTransactionDO.setClientId(branchSession.getClientId());\n-        branchTransactionDO.setResourceGroupId(branchSession.getResourceGroupId());\n-        branchTransactionDO.setTransactionId(branchSession.getTransactionId());\n-        branchTransactionDO.setApplicationData(branchSession.getApplicationData());\n-        branchTransactionDO.setResourceId(branchSession.getResourceId());\n-        branchTransactionDO.setStatus(branchSession.getStatus().getCode());\n-        return branchTransactionDO;\n-    }\n-\n-    private GlobalSession convertGlobalSession(GlobalTransactionDO globalTransactionDO) {\n-        GlobalSession session =\n-            new GlobalSession(globalTransactionDO.getApplicationId(), globalTransactionDO.getTransactionServiceGroup(),\n-                globalTransactionDO.getTransactionName(), globalTransactionDO.getTimeout());\n-        session.setTransactionId(globalTransactionDO.getTransactionId());\n-        session.setXid(globalTransactionDO.getXid());\n-        session.setStatus(GlobalStatus.get(globalTransactionDO.getStatus()));\n-        session.setApplicationData(globalTransactionDO.getApplicationData());\n-        session.setBeginTime(globalTransactionDO.getBeginTime());\n-        return session;\n-    }\n-\n-    private BranchSession convertBranchSession(BranchTransactionDO branchTransactionDO) {\n-        BranchSession branchSession = new BranchSession();\n-        branchSession.setXid(branchTransactionDO.getXid());\n-        branchSession.setTransactionId(branchTransactionDO.getTransactionId());\n-        branchSession.setApplicationData(branchTransactionDO.getApplicationData());\n-        branchSession.setBranchId(branchTransactionDO.getBranchId());\n-        branchSession.setBranchType(BranchType.valueOf(branchTransactionDO.getBranchType()));\n-        branchSession.setResourceId(branchTransactionDO.getResourceId());\n-        branchSession.setClientId(branchTransactionDO.getClientId());\n-        branchSession.setResourceGroupId(branchTransactionDO.getResourceGroupId());\n-        branchSession.setStatus(BranchStatus.get(branchTransactionDO.getStatus()));\n-        return branchSession;\n-    }\n-\n-    private GlobalSession getGlobalSession(GlobalTransactionDO globalTransactionDO,\n-        List<BranchTransactionDO> branchTransactionDOs) {\n-        GlobalSession globalSession = convertGlobalSession(globalTransactionDO);\n-        // branch transactions\n         if (CollectionUtils.isNotEmpty(branchTransactionDOs)) {\n-            for (BranchTransactionDO branchTransactionDO : branchTransactionDOs) {\n-                globalSession.add(convertBranchSession(branchTransactionDO));\n-            }\n+            branchTransactionDOs = branchTransactionDOs.stream().sorted(Comparator.comparing(BranchTransactionDO::getGmtCreate))\n+                    .collect(Collectors.toList());\n         }\n-        return globalSession;\n+        return branchTransactionDOs;\n     }\n \n-    private Set<String> lRange(Jedis jedis, String key) {\n-        Set<String> keys = new HashSet<>();\n-        List<String> redisBranchJson;\n-        int start = 0;\n-        int stop = logQueryLimit;\n-        do {\n-            redisBranchJson = jedis.lrange(key, start, stop);\n-            keys.addAll(redisBranchJson);\n-            start = keys.size();\n-            stop = start + logQueryLimit;\n-        } while (CollectionUtils.isNotEmpty(redisBranchJson));\n-        return keys;\n+    private String buildBranchListKeyByXid(String xid) {\n+        return REDIS_SEATA_BRANCHES_PREFIX + xid;\n     }\n \n-    private String getGlobalKeyByXid(String xid) {\n-        return DEFAULT_REDIS_SEATA_GLOBAL_SESSION_PREFIX + xid;\n+    private String buildGlobalKeyByTransactionId(Long transactionId) {\n+        return REDIS_SEATA_GLOBAL_PREFIX + transactionId;\n     }\n-\n-    private String getBranchListKeyByXid(String xid) {\n-        return DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + xid;\n+    private String buildGlobalKeyByTransactionId(String transactionId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef32fc3fa0617c52a79ed676e2d581881c25df61"}, "originalPosition": 683}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1MTQxMzQ1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwOTowNzozMlrOHf1yDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwOTowNzozMlrOHf1yDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzE0OTA2OA==", "bodyText": "Can be changed to Map<String,String> map = new HashMap<>(2, 1);", "url": "https://github.com/seata/seata/pull/3062#discussion_r503149068", "createdAt": "2020-10-12T09:07:32Z", "author": {"login": "ph3636"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -90,100 +94,230 @@ public static RedisTransactionStoreManager getInstance() {\n     @Override\n     public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n         if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n-            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return insertGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n-            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return updateGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n-            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return deleteGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n-            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+            return insertBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n-            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+            return updateBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n-            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+            return deleteBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else {\n             throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n         }\n     }\n \n+    /**\n+     * Insert branch transaction\n+     * @param branchTransactionDO\n+     * @return the boolean\n+     */\n+    private boolean insertBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        String branchKey = buildBranchKey(branchTransactionDO.getBranchId());\n+        String branchListKey = buildBranchListKeyByXid(branchTransactionDO.getXid());\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Date now = new Date();\n+            branchTransactionDO.setGmtCreate(now);\n+            branchTransactionDO.setGmtModified(now);\n+            Pipeline pipelined = jedis.pipelined();\n+            pipelined.hmset(branchKey, BeanUtils.objectToMap(branchTransactionDO));\n+            pipelined.rpush(branchListKey, branchKey);\n+            pipelined.sync();\n+            return true;\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n+        }\n+    }\n+\n+    /**\n+     * Delete the branch transaction\n+     * @param branchTransactionDO\n+     * @return\n+     */\n     private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        String branchKey = buildBranchKey(branchTransactionDO.getBranchId());\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String key = getBranchKey(branchTransactionDO.getBranchId());\n-            jedis.del(key);\n+            Map<String, String> branchTransactionDOMap = jedis.hgetAll(branchKey);\n+            String xid = branchTransactionDOMap.get(REDIS_KEY_BRANCH_XID);\n+            if (StringUtils.isEmpty(xid)) {\n+                return true;\n+            }\n+            String branchListKey = buildBranchListKeyByXid(branchTransactionDO.getXid());\n+            Pipeline pipelined = jedis.pipelined();\n+            pipelined.lrem(branchListKey, 0, branchKey);\n+            pipelined.del(branchKey);\n+            pipelined.sync();\n             return true;\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n         }\n     }\n \n-    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+    /**\n+     * Update the branch transaction\n+     * @param branchTransactionDO\n+     * @return\n+     */\n+    private boolean updateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        String branchKey = buildBranchKey(branchTransactionDO.getBranchId());\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String key = getBranchKey(branchTransactionDO.getBranchId());\n-            String branch = jedis.get(key);\n-            Pipeline pipeline = jedis.pipelined();\n-            if (StringUtils.isEmpty(branch)) {\n-                pipeline.lpush(getBranchListKeyByXid(branchTransactionDO.getXid()), key);\n+            String previousBranchStatus = jedis.hget(branchKey, REDIS_KEY_BRANCH_STATUS);\n+            if (StringUtils.isEmpty(previousBranchStatus)) {\n+                throw new StoreException(\"Branch transaction is not exist, update branch transaction failed.\");\n             }\n-            pipeline.set(key, JSON.toJSONString(branchTransactionDO));\n-            pipeline.sync();\n+            Map<String,String> map = new HashMap<>(2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef32fc3fa0617c52a79ed676e2d581881c25df61"}, "originalPosition": 190}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1410, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}