{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM5NDA0NDkw", "number": 3374, "reviewThreads": {"totalCount": 23, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMjo0NzoyN1rOFE9x8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0wM1QwNjoyMTo1NVrOF5iKSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwNzUwODMyOnYy", "diffSide": "RIGHT", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/ExecuteTemplate.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMjo0NzoyN1rOIFO0Ag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QwMjoyNjo0MFrOIKPIYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM1NjQ4Mg==", "bodyText": "ON DUPLICATE KEY UPDATE It should be set to a constant", "url": "https://github.com/seata/seata/pull/3374#discussion_r542356482", "createdAt": "2020-12-14T12:47:27Z", "author": {"login": "a364176773"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/ExecuteTemplate.java", "diffHunk": "@@ -85,9 +86,13 @@\n                 SQLRecognizer sqlRecognizer = sqlRecognizers.get(0);\n                 switch (sqlRecognizer.getSQLType()) {\n                     case INSERT:\n-                        executor = EnhancedServiceLoader.load(InsertExecutor.class, dbType,\n-                                new Class[]{StatementProxy.class, StatementCallback.class, SQLRecognizer.class},\n-                                new Object[]{statementProxy, statementCallback, sqlRecognizer});\n+                        if(sqlRecognizer.getOriginalSQL().toUpperCase().trim().contains(\"ON DUPLICATE KEY UPDATE\".trim()) && \"mysql\".equals(dbType)){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88adb45a69016b169b6d23e9134dd9461736815b"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM1NzE4Nw==", "bodyText": "JdbcConstants.MYSQL?", "url": "https://github.com/seata/seata/pull/3374#discussion_r542357187", "createdAt": "2020-12-14T12:48:43Z", "author": {"login": "a364176773"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/ExecuteTemplate.java", "diffHunk": "@@ -85,9 +86,13 @@\n                 SQLRecognizer sqlRecognizer = sqlRecognizers.get(0);\n                 switch (sqlRecognizer.getSQLType()) {\n                     case INSERT:\n-                        executor = EnhancedServiceLoader.load(InsertExecutor.class, dbType,\n-                                new Class[]{StatementProxy.class, StatementCallback.class, SQLRecognizer.class},\n-                                new Object[]{statementProxy, statementCallback, sqlRecognizer});\n+                        if(sqlRecognizer.getOriginalSQL().toUpperCase().trim().contains(\"ON DUPLICATE KEY UPDATE\".trim()) && \"mysql\".equals(dbType)){", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM1NjQ4Mg=="}, "originalCommit": {"oid": "88adb45a69016b169b6d23e9134dd9461736815b"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0MDE1NQ==", "bodyText": "\u53ef\u4ee5\u7684\uff0c\u8c22\u8c22", "url": "https://github.com/seata/seata/pull/3374#discussion_r547240155", "createdAt": "2020-12-22T12:04:58Z", "author": {"login": "huan415"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/ExecuteTemplate.java", "diffHunk": "@@ -85,9 +86,13 @@\n                 SQLRecognizer sqlRecognizer = sqlRecognizers.get(0);\n                 switch (sqlRecognizer.getSQLType()) {\n                     case INSERT:\n-                        executor = EnhancedServiceLoader.load(InsertExecutor.class, dbType,\n-                                new Class[]{StatementProxy.class, StatementCallback.class, SQLRecognizer.class},\n-                                new Object[]{statementProxy, statementCallback, sqlRecognizer});\n+                        if(sqlRecognizer.getOriginalSQL().toUpperCase().trim().contains(\"ON DUPLICATE KEY UPDATE\".trim()) && \"mysql\".equals(dbType)){", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM1NjQ4Mg=="}, "originalCommit": {"oid": "88adb45a69016b169b6d23e9134dd9461736815b"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYwNDU3Nw==", "bodyText": "\u6539\u5b8c\u4e86\u5c31\u53ef\u4ee5\u81ea\u5df1\u70b9\u4e00\u4e0bResolve conversation\u3002", "url": "https://github.com/seata/seata/pull/3374#discussion_r547604577", "createdAt": "2020-12-23T02:26:40Z", "author": {"login": "caohdgege"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/ExecuteTemplate.java", "diffHunk": "@@ -85,9 +86,13 @@\n                 SQLRecognizer sqlRecognizer = sqlRecognizers.get(0);\n                 switch (sqlRecognizer.getSQLType()) {\n                     case INSERT:\n-                        executor = EnhancedServiceLoader.load(InsertExecutor.class, dbType,\n-                                new Class[]{StatementProxy.class, StatementCallback.class, SQLRecognizer.class},\n-                                new Object[]{statementProxy, statementCallback, sqlRecognizer});\n+                        if(sqlRecognizer.getOriginalSQL().toUpperCase().trim().contains(\"ON DUPLICATE KEY UPDATE\".trim()) && \"mysql\".equals(dbType)){", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM1NjQ4Mg=="}, "originalCommit": {"oid": "88adb45a69016b169b6d23e9134dd9461736815b"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwNzY0NjA3OnYy", "diffSide": "RIGHT", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/ExecuteTemplate.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMzoxOTozOFrOIFQCwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxNToyMTo1M1rOIJ-1Tw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM3NjY0MQ==", "bodyText": "\u600e\u4e48\u4fdd\u8bc1ON DUPLICATE KEY UPDATE\u6bcf\u4e2a\u5355\u8bcd\u4e4b\u95f4\u53ea\u6709\u4e00\u4e2a\u7a7a\u683c\uff1f\u901a\u8fc7druid\u751f\u6210\u7684\u8bed\u6cd5\u6811\u6765\u5224\u65ad\u4f1a\u4e0d\u4f1a\u597d\u4e00\u70b9\uff1f\u770b\u5230\u91cc\u9762\u662f\u6709\u5bf9\u5e94\u7684\u5b57\u6bb5\u7684\u3002", "url": "https://github.com/seata/seata/pull/3374#discussion_r542376641", "createdAt": "2020-12-14T13:19:38Z", "author": {"login": "caohdgege"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/ExecuteTemplate.java", "diffHunk": "@@ -85,9 +86,13 @@\n                 SQLRecognizer sqlRecognizer = sqlRecognizers.get(0);\n                 switch (sqlRecognizer.getSQLType()) {\n                     case INSERT:\n-                        executor = EnhancedServiceLoader.load(InsertExecutor.class, dbType,\n-                                new Class[]{StatementProxy.class, StatementCallback.class, SQLRecognizer.class},\n-                                new Object[]{statementProxy, statementCallback, sqlRecognizer});\n+                        if(sqlRecognizer.getOriginalSQL().toUpperCase().trim().contains(\"ON DUPLICATE KEY UPDATE\".trim()) && \"mysql\".equals(dbType)){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88adb45a69016b169b6d23e9134dd9461736815b"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk3NjQ0Ng==", "bodyText": "+1", "url": "https://github.com/seata/seata/pull/3374#discussion_r542976446", "createdAt": "2020-12-15T01:32:08Z", "author": {"login": "a364176773"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/ExecuteTemplate.java", "diffHunk": "@@ -85,9 +86,13 @@\n                 SQLRecognizer sqlRecognizer = sqlRecognizers.get(0);\n                 switch (sqlRecognizer.getSQLType()) {\n                     case INSERT:\n-                        executor = EnhancedServiceLoader.load(InsertExecutor.class, dbType,\n-                                new Class[]{StatementProxy.class, StatementCallback.class, SQLRecognizer.class},\n-                                new Object[]{statementProxy, statementCallback, sqlRecognizer});\n+                        if(sqlRecognizer.getOriginalSQL().toUpperCase().trim().contains(\"ON DUPLICATE KEY UPDATE\".trim()) && \"mysql\".equals(dbType)){", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM3NjY0MQ=="}, "originalCommit": {"oid": "88adb45a69016b169b6d23e9134dd9461736815b"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0MzAxMA==", "bodyText": "\u8fd9\u4e2a\u662f\u6211\u6b20\u8003\u8651\u4e86\u3002\u6ca1\u627e\u5230\u80fd\u5177\u4f53\u4e00\u70b9\u5417\uff1f\u662fMysqlInsertStatement\u91cc\u7684duplicateKeyUpdate\uff0c\u8fd9\u4e2a\u662f\u6709update\u7684\u5b57\u6bb5\uff0c\u60a8\u662f\u6307\u8fd9\u4e2a\u5417\uff1f", "url": "https://github.com/seata/seata/pull/3374#discussion_r547243010", "createdAt": "2020-12-22T12:11:46Z", "author": {"login": "huan415"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/ExecuteTemplate.java", "diffHunk": "@@ -85,9 +86,13 @@\n                 SQLRecognizer sqlRecognizer = sqlRecognizers.get(0);\n                 switch (sqlRecognizer.getSQLType()) {\n                     case INSERT:\n-                        executor = EnhancedServiceLoader.load(InsertExecutor.class, dbType,\n-                                new Class[]{StatementProxy.class, StatementCallback.class, SQLRecognizer.class},\n-                                new Object[]{statementProxy, statementCallback, sqlRecognizer});\n+                        if(sqlRecognizer.getOriginalSQL().toUpperCase().trim().contains(\"ON DUPLICATE KEY UPDATE\".trim()) && \"mysql\".equals(dbType)){", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM3NjY0MQ=="}, "originalCommit": {"oid": "88adb45a69016b169b6d23e9134dd9461736815b"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI2Mzg5Nw==", "bodyText": "\u662f\u7684\uff0c\u5c31\u662f\u8fd9\u4e2a", "url": "https://github.com/seata/seata/pull/3374#discussion_r547263897", "createdAt": "2020-12-22T12:58:58Z", "author": {"login": "caohdgege"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/ExecuteTemplate.java", "diffHunk": "@@ -85,9 +86,13 @@\n                 SQLRecognizer sqlRecognizer = sqlRecognizers.get(0);\n                 switch (sqlRecognizer.getSQLType()) {\n                     case INSERT:\n-                        executor = EnhancedServiceLoader.load(InsertExecutor.class, dbType,\n-                                new Class[]{StatementProxy.class, StatementCallback.class, SQLRecognizer.class},\n-                                new Object[]{statementProxy, statementCallback, sqlRecognizer});\n+                        if(sqlRecognizer.getOriginalSQL().toUpperCase().trim().contains(\"ON DUPLICATE KEY UPDATE\".trim()) && \"mysql\".equals(dbType)){", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM3NjY0MQ=="}, "originalCommit": {"oid": "88adb45a69016b169b6d23e9134dd9461736815b"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzMzNzU1MQ==", "bodyText": "\u5df2\u6539\u6b63\uff0c\u671b\u91c7\u7eb3", "url": "https://github.com/seata/seata/pull/3374#discussion_r547337551", "createdAt": "2020-12-22T15:21:53Z", "author": {"login": "huan415"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/ExecuteTemplate.java", "diffHunk": "@@ -85,9 +86,13 @@\n                 SQLRecognizer sqlRecognizer = sqlRecognizers.get(0);\n                 switch (sqlRecognizer.getSQLType()) {\n                     case INSERT:\n-                        executor = EnhancedServiceLoader.load(InsertExecutor.class, dbType,\n-                                new Class[]{StatementProxy.class, StatementCallback.class, SQLRecognizer.class},\n-                                new Object[]{statementProxy, statementCallback, sqlRecognizer});\n+                        if(sqlRecognizer.getOriginalSQL().toUpperCase().trim().contains(\"ON DUPLICATE KEY UPDATE\".trim()) && \"mysql\".equals(dbType)){", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM3NjY0MQ=="}, "originalCommit": {"oid": "88adb45a69016b169b6d23e9134dd9461736815b"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0MDk0NzAyOnYy", "diffSide": "RIGHT", "path": "sqlparser/seata-sqlparser-core/src/main/java/io/seata/sqlparser/SQLInsertRecognizer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxMzoxNjoxNlrOIJ60qg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yNFQwMjozOToxMVrOIK9AnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI3MTg1MA==", "bodyText": "\u8fd9\u4e2a\u62fc\u51fa\u6765\u7684\u662f\u4e0d\u662f\u4e0d\u7b26\u5408SQL\u8bed\u6cd5\u4e86\uff1f", "url": "https://github.com/seata/seata/pull/3374#discussion_r547271850", "createdAt": "2020-12-22T13:16:16Z", "author": {"login": "caohdgege"}, "path": "sqlparser/seata-sqlparser-core/src/main/java/io/seata/sqlparser/SQLInsertRecognizer.java", "diffHunk": "@@ -45,4 +45,11 @@\n      * @return the insert rows\n      */\n     List<List<Object>> getInsertRows(Collection<Integer> primaryKeyIndex);\n+\n+    /**\n+     * Gets insert\n+     *\n+     * @return  VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)   VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)\n+     */\n+    List<String> getInsertParamsValue();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "635ab95adf556dde6a4731d9fdea1896b31013e9"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM1NjI1Mg==", "bodyText": "\u8fd9\u4e2a\u4e0d\u662fsql, \u4e3b\u8981\u4e0b\u60f3\u83b7\u53d6\u5360\u4f4d\u7b26\uff0c\u901a\u8fc7\u5360\u4f4d\u7b26\u6765\u83b7\u53d6\u5404\u4e2a\u5b57\u6bb5\u5bf9\u5e94\u7684\u503c\uff0c\u4e4b\u6240\u4ee5\u8003\u8651\u6709\u5360\u4f4d\u7b26\u6765\u83b7\u53d6\u5bf9\u5e94\u7684\u5b57\u6bb5\u503c\uff0c\u662f\u8003\u8651values\u6709\u53ef\u80fd\u662f\u5e38\u91cf\uff0c\u6bd4\u5982\u8bf4nows().   \u5982\u679c\u6709\u5e38\u91cf\u65f6,statementProxy.getParameters\u4e0erecognizer.getInsertColumns\u65e0\u6cd5\u4e00 \u4e00\u5bf9\u5e94", "url": "https://github.com/seata/seata/pull/3374#discussion_r548356252", "createdAt": "2020-12-24T02:39:11Z", "author": {"login": "huan415"}, "path": "sqlparser/seata-sqlparser-core/src/main/java/io/seata/sqlparser/SQLInsertRecognizer.java", "diffHunk": "@@ -45,4 +45,11 @@\n      * @return the insert rows\n      */\n     List<List<Object>> getInsertRows(Collection<Integer> primaryKeyIndex);\n+\n+    /**\n+     * Gets insert\n+     *\n+     * @return  VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)   VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)\n+     */\n+    List<String> getInsertParamsValue();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI3MTg1MA=="}, "originalCommit": {"oid": "635ab95adf556dde6a4731d9fdea1896b31013e9"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0MTA5MjQ3OnYy", "diffSide": "RIGHT", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxNDowMTowOFrOIJ8KMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yNlQxMDoxOTowM1rOILiVXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI5Mzc0NQ==", "bodyText": "\u8fd9\u91cc\u4e3a\u4ec0\u4e48\u8df3\u8fc7\u4e86\u4e3b\u952e\uff1f\u4e3b\u952e\u4e5f\u5177\u6709\u552f\u4e00\u6027\uff0c\u4e5f\u5e94\u8be5\u89e6\u53d1\u8fd9\u4e2a\u624d\u5bf9\u5440\uff1f", "url": "https://github.com/seata/seata/pull/3374#discussion_r547293745", "createdAt": "2020-12-22T14:01:08Z", "author": {"login": "caohdgege"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "diffHunk": "@@ -0,0 +1,354 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec.mysql;\n+\n+import com.google.common.base.Joiner;\n+import io.seata.common.exception.NotSupportYetException;\n+import io.seata.common.loader.LoadLevel;\n+import io.seata.common.loader.Scope;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.IOUtil;\n+import io.seata.common.util.StringUtils;\n+import io.seata.rm.datasource.ConnectionProxy;\n+import io.seata.rm.datasource.PreparedStatementProxy;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.StatementCallback;\n+import io.seata.rm.datasource.sql.struct.Field;\n+import io.seata.rm.datasource.sql.struct.Row;\n+import io.seata.rm.datasource.sql.struct.TableMeta;\n+import io.seata.rm.datasource.sql.struct.TableRecords;\n+import io.seata.rm.datasource.undo.SQLUndoLog;\n+import io.seata.sqlparser.SQLInsertRecognizer;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.SQLType;\n+import io.seata.sqlparser.struct.Defaultable;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+\n+/**\n+ * @version: 1.00.00\n+ * @description:\n+ * @author: yangyicong\n+ * @date: 2020-11-26 09:06\n+ */\n+@LoadLevel(name = JdbcConstants.MYSQL, scope = Scope.PROTOTYPE)\n+public class MySQLInsertOrUpdateExecutor extends MySQLInsertExecutor implements Defaultable {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MySQLInsertOrUpdateExecutor.class);\n+\n+    //is updated or not\n+    private boolean isUpdateFlag = false;\n+\n+    //before image sql and after image sql,condition is unique index\n+    private String selectSQL;\n+\n+    //the params of selectSQL, value is the unique index\n+    private ArrayList<List<Object>> paramAppenderList;\n+\n+    //key is unique index name, value is unique index\n+    private Map<String, List<String>> beforeUniqueIndexMap = new HashMap<>();\n+\n+    public MySQLInsertOrUpdateExecutor(StatementProxy statementProxy, StatementCallback statementCallback, SQLRecognizer sqlRecognizer) {\n+        super(statementProxy, statementCallback, sqlRecognizer);\n+    }\n+\n+    /**\n+     * Execute auto commit false t.\n+     *\n+     * @param args the args\n+     * @return the t\n+     * @throws Exception the exception\n+     */\n+    @Override\n+    protected Object executeAutoCommitFalse(Object[] args) throws Exception {\n+        if (!JdbcConstants.MYSQL.equalsIgnoreCase(getDbType()) && getTableMeta().getPrimaryKeyOnlyName().size() > 1) {\n+            throw new NotSupportYetException(\"multi pk only support mysql!\");\n+        }\n+        TableRecords beforeImage = beforeImage();\n+        if (CollectionUtils.isNotEmpty(beforeImage.getRows())) {\n+            isUpdateFlag = true;\n+        } else {\n+            beforeImage = TableRecords.empty(getTableMeta());\n+        }\n+        Object result = statementCallback.execute(statementProxy.getTargetStatement(), args);\n+        TableRecords afterImage = afterImage(beforeImage);\n+        prepareUndoLog2(beforeImage, afterImage);\n+        return result;\n+    }\n+\n+    /**\n+     * prepare undo log.\n+     *\n+     * @param beforeImage the before image\n+     * @param afterImage  the after image\n+     * @throws SQLException the sql exception\n+     */\n+    protected void prepareUndoLog2(TableRecords beforeImage, TableRecords afterImage) {\n+        if (beforeImage.getRows().isEmpty() && afterImage.getRows().isEmpty()) {\n+            return;\n+        }\n+        ConnectionProxy connectionProxy = statementProxy.getConnectionProxy();\n+        TableRecords lockKeyRecords = sqlRecognizer.getSQLType() == SQLType.DELETE ? beforeImage : afterImage;\n+        String lockKeys = buildLockKey(lockKeyRecords);\n+        connectionProxy.appendLockKey(lockKeys);\n+        buildUndoItemAll(connectionProxy,beforeImage, afterImage);\n+    }\n+\n+    /**\n+     * build a SQLUndoLog\n+     *\n+     * @param beforeImage the before image\n+     * @param afterImage  the after image\n+     * @return sql undo log\n+     */\n+    protected void buildUndoItemAll(ConnectionProxy connectionProxy, TableRecords beforeImage, TableRecords afterImage) {\n+        if (!isUpdateFlag) {\n+            SQLUndoLog sqlUndoLog = buildUndoItem(TableRecords.empty(getTableMeta()), afterImage);\n+            connectionProxy.appendUndoLog(sqlUndoLog);\n+            return;\n+        }\n+        List<Row> beforeImageRows = beforeImage.getRows();\n+        for (Row r : beforeImageRows) {\n+            getTableMeta().getAllIndexes().forEach((k, v) -> {\n+                if (!\"PRIMARY\".equals(k.toUpperCase()) && !v.isNonUnique()) {\n+                    StringBuilder everyRowIndex = new StringBuilder();\n+                    v.getValues().forEach(m -> {\n+                        for (Field f : r.getFields()) {\n+                            if (m.getColumnName().equals(f.getName())) {\n+                                everyRowIndex.append(f.getValue());\n+                            }\n+                        }\n+                    });\n+                    List<String> indexList = beforeUniqueIndexMap.get(k.toUpperCase());\n+                    if (CollectionUtils.isEmpty(indexList)) {\n+                        indexList = new ArrayList<>();\n+                    }\n+                    indexList.add(everyRowIndex.toString());\n+                    beforeUniqueIndexMap.put(k.toUpperCase(), indexList);\n+                }\n+            });\n+        }\n+        List<Row> insertRows = new ArrayList<>();\n+        List<Row> updateRows = new ArrayList<>();\n+        List<Row> afterImageRows = afterImage.getRows();\n+        for (Row r : afterImageRows) {\n+            Boolean[] isUpdateRows = {false};\n+            getTableMeta().getAllIndexes().forEach((k, v) -> {\n+                if (!\"PRIMARY\".equals(k.toUpperCase()) && !v.isNonUnique()) {\n+                    StringBuilder everyRowIndex = new StringBuilder();\n+                    v.getValues().forEach(m -> {\n+                        for (Field f : r.getFields()) {\n+                            if (m.getColumnName().equals(f.getName())) {\n+                                everyRowIndex.append(f.getValue());\n+                            }\n+                        }\n+                    });\n+                    List<String> indexList = beforeUniqueIndexMap.get(k.toUpperCase());\n+                    if (CollectionUtils.isNotEmpty(indexList)) {\n+                        indexList.forEach(m -> {\n+                            if (m.equals(everyRowIndex.toString())) {\n+                                isUpdateRows[0] = true;\n+                            }\n+                        });\n+                    }\n+                }\n+            });\n+            if (isUpdateRows[0]) {\n+                updateRows.add(r);\n+            } else {\n+                insertRows.add(r);\n+            }\n+        }\n+        if (CollectionUtils.isNotEmpty(updateRows)) {\n+            TableRecords partAfterImage = new TableRecords(afterImage.getTableMeta());\n+            partAfterImage.setTableName(afterImage.getTableName());\n+            partAfterImage.setRows(updateRows);\n+            connectionProxy.appendUndoLog(buildUndoItem(SQLType.UPDATE, beforeImage, partAfterImage));\n+        }\n+        if (CollectionUtils.isNotEmpty(insertRows)) {\n+            TableRecords partAfterImage = new TableRecords(afterImage.getTableMeta());\n+            partAfterImage.setTableName(afterImage.getTableName());\n+            partAfterImage.setRows(insertRows);\n+            connectionProxy.appendUndoLog(buildUndoItem(TableRecords.empty(getTableMeta()), partAfterImage));\n+        }\n+    }\n+\n+    /**\n+     * build a SQLUndoLog\n+     * @param sqlType\n+     * @param beforeImage\n+     * @param afterImage\n+     * @return\n+     */\n+    protected SQLUndoLog buildUndoItem(SQLType sqlType, TableRecords beforeImage, TableRecords afterImage) {\n+        String tableName = sqlRecognizer.getTableName();\n+        SQLUndoLog sqlUndoLog = new SQLUndoLog();\n+        sqlUndoLog.setSqlType(sqlType);\n+        sqlUndoLog.setTableName(tableName);\n+        sqlUndoLog.setBeforeImage(beforeImage);\n+        sqlUndoLog.setAfterImage(afterImage);\n+        return sqlUndoLog;\n+    }\n+\n+\n+    @Override\n+    protected TableRecords afterImage(TableRecords beforeImage) throws SQLException {\n+        Map<String, List<Object>> pkValues = getPkValues();\n+        if (isUpdateFlag) {\n+            return buildImage();\n+        } else {\n+            return afterImageInsert(pkValues);\n+        }\n+    }\n+\n+    private TableRecords afterImageInsert(Map<String, List<Object>> pkValues) throws SQLException {\n+        TableRecords afterImage = buildTableRecords(pkValues);\n+        if (afterImage == null) {\n+            throw new SQLException(\"Failed to build after-image for insert\");\n+        }\n+        return afterImage;\n+    }\n+\n+    @Override\n+    protected TableRecords beforeImage() throws SQLException {\n+        return buildImage();\n+    }\n+\n+    /**\n+     * build before image and after image\n+     * @return\n+     * @throws SQLException\n+     */\n+    protected TableRecords buildImage() throws SQLException {\n+        TableMeta tmeta = getTableMeta();\n+        //after image sql the same of before image\n+        if (StringUtils.isBlank(selectSQL)) {\n+            paramAppenderList = new ArrayList<>();\n+            selectSQL = buildImageSQL(tmeta);\n+        }\n+        return buildTableRecords2(tmeta, selectSQL, paramAppenderList);\n+    }\n+\n+    /**\n+     *  build TableRecords\n+     * @param tableMeta\n+     * @param selectSQL\n+     * @param paramAppenderList\n+     * @return\n+     * @throws SQLException\n+     */\n+    protected TableRecords buildTableRecords2(TableMeta tableMeta, String selectSQL, ArrayList<List<Object>> paramAppenderList) throws SQLException {\n+        ResultSet rs = null;\n+        try (PreparedStatement ps = statementProxy.getConnection().prepareStatement(selectSQL)) {\n+            if (CollectionUtils.isNotEmpty(paramAppenderList)) {\n+                for (int i = 0, ts = paramAppenderList.size(); i < ts; i++) {\n+                    List<Object> paramAppender = paramAppenderList.get(i);\n+                    for (int j = 0, ds = paramAppender.size(); j < ds; j++) {\n+                        ps.setObject(i * ds + j + 1, \"NULL\".equals(paramAppender.get(j).toString()) ? null : paramAppender.get(j));\n+                    }\n+                }\n+            }\n+            rs = ps.executeQuery();\n+            return TableRecords.buildRecords(tableMeta, rs);\n+        } finally {\n+            IOUtil.close(rs);\n+        }\n+    }\n+\n+    /**\n+     * build image sql\n+     * @param tableMeta\n+     * @return\n+     */\n+    private String buildImageSQL(TableMeta tableMeta) {\n+        if (CollectionUtils.isEmpty(paramAppenderList)) {\n+            paramAppenderList = new ArrayList<>();\n+        }\n+        SQLInsertRecognizer recognizer = (SQLInsertRecognizer) sqlRecognizer;\n+        Map<String, ArrayList<Object>> imageParamperterMap = new HashMap<>();\n+        int insertNum = buildImageParamperters(recognizer, imageParamperterMap);\n+        StringBuilder prefix = new StringBuilder(\"SELECT * \");\n+        StringBuilder suffix = new StringBuilder(\" FROM \").append(getFromTableInSQL());\n+        for (int i = 0; i < insertNum; i++) {\n+            int finalI = i;\n+            List<Object> paramAppenderTempList = new ArrayList<>();\n+            tableMeta.getAllIndexes().forEach((k, v) -> {\n+                if (!\"PRIMARY\".equals(k.toUpperCase()) && !v.isNonUnique()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "635ab95adf556dde6a4731d9fdea1896b31013e9"}, "originalPosition": 299}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM1Njk1Mg==", "bodyText": "\u8fd9\u4e2a\u662f\u56e0\u4e3a\u524d\u7f6e\u955c\u50cf\u83b7\u53d6\u4e0d\u5230id\uff0c\u800c\u6211\u90a3\u65f6\u5019\u7684\u4e1a\u52a1\u573a\u666f\u5982\u679cid\u4e00\u6837\uff0c\u552f\u4e00\u7d22\u5f15\u4e5f\u662f\u4e00\u6837\u7684\uff0c\u6240\u4ee5\u8fc7\u6ee4\u6389\u7684\u3002\u4ece\u7406\u8bba\u4e0a\u8bf4\u662f\u4e0d\u5e94\u8be5\u53bb\u6389\uff0c\u6211\u518d\u60f3\u60f3\u529e\u6cd5", "url": "https://github.com/seata/seata/pull/3374#discussion_r548356952", "createdAt": "2020-12-24T02:43:01Z", "author": {"login": "huan415"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "diffHunk": "@@ -0,0 +1,354 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec.mysql;\n+\n+import com.google.common.base.Joiner;\n+import io.seata.common.exception.NotSupportYetException;\n+import io.seata.common.loader.LoadLevel;\n+import io.seata.common.loader.Scope;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.IOUtil;\n+import io.seata.common.util.StringUtils;\n+import io.seata.rm.datasource.ConnectionProxy;\n+import io.seata.rm.datasource.PreparedStatementProxy;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.StatementCallback;\n+import io.seata.rm.datasource.sql.struct.Field;\n+import io.seata.rm.datasource.sql.struct.Row;\n+import io.seata.rm.datasource.sql.struct.TableMeta;\n+import io.seata.rm.datasource.sql.struct.TableRecords;\n+import io.seata.rm.datasource.undo.SQLUndoLog;\n+import io.seata.sqlparser.SQLInsertRecognizer;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.SQLType;\n+import io.seata.sqlparser.struct.Defaultable;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+\n+/**\n+ * @version: 1.00.00\n+ * @description:\n+ * @author: yangyicong\n+ * @date: 2020-11-26 09:06\n+ */\n+@LoadLevel(name = JdbcConstants.MYSQL, scope = Scope.PROTOTYPE)\n+public class MySQLInsertOrUpdateExecutor extends MySQLInsertExecutor implements Defaultable {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MySQLInsertOrUpdateExecutor.class);\n+\n+    //is updated or not\n+    private boolean isUpdateFlag = false;\n+\n+    //before image sql and after image sql,condition is unique index\n+    private String selectSQL;\n+\n+    //the params of selectSQL, value is the unique index\n+    private ArrayList<List<Object>> paramAppenderList;\n+\n+    //key is unique index name, value is unique index\n+    private Map<String, List<String>> beforeUniqueIndexMap = new HashMap<>();\n+\n+    public MySQLInsertOrUpdateExecutor(StatementProxy statementProxy, StatementCallback statementCallback, SQLRecognizer sqlRecognizer) {\n+        super(statementProxy, statementCallback, sqlRecognizer);\n+    }\n+\n+    /**\n+     * Execute auto commit false t.\n+     *\n+     * @param args the args\n+     * @return the t\n+     * @throws Exception the exception\n+     */\n+    @Override\n+    protected Object executeAutoCommitFalse(Object[] args) throws Exception {\n+        if (!JdbcConstants.MYSQL.equalsIgnoreCase(getDbType()) && getTableMeta().getPrimaryKeyOnlyName().size() > 1) {\n+            throw new NotSupportYetException(\"multi pk only support mysql!\");\n+        }\n+        TableRecords beforeImage = beforeImage();\n+        if (CollectionUtils.isNotEmpty(beforeImage.getRows())) {\n+            isUpdateFlag = true;\n+        } else {\n+            beforeImage = TableRecords.empty(getTableMeta());\n+        }\n+        Object result = statementCallback.execute(statementProxy.getTargetStatement(), args);\n+        TableRecords afterImage = afterImage(beforeImage);\n+        prepareUndoLog2(beforeImage, afterImage);\n+        return result;\n+    }\n+\n+    /**\n+     * prepare undo log.\n+     *\n+     * @param beforeImage the before image\n+     * @param afterImage  the after image\n+     * @throws SQLException the sql exception\n+     */\n+    protected void prepareUndoLog2(TableRecords beforeImage, TableRecords afterImage) {\n+        if (beforeImage.getRows().isEmpty() && afterImage.getRows().isEmpty()) {\n+            return;\n+        }\n+        ConnectionProxy connectionProxy = statementProxy.getConnectionProxy();\n+        TableRecords lockKeyRecords = sqlRecognizer.getSQLType() == SQLType.DELETE ? beforeImage : afterImage;\n+        String lockKeys = buildLockKey(lockKeyRecords);\n+        connectionProxy.appendLockKey(lockKeys);\n+        buildUndoItemAll(connectionProxy,beforeImage, afterImage);\n+    }\n+\n+    /**\n+     * build a SQLUndoLog\n+     *\n+     * @param beforeImage the before image\n+     * @param afterImage  the after image\n+     * @return sql undo log\n+     */\n+    protected void buildUndoItemAll(ConnectionProxy connectionProxy, TableRecords beforeImage, TableRecords afterImage) {\n+        if (!isUpdateFlag) {\n+            SQLUndoLog sqlUndoLog = buildUndoItem(TableRecords.empty(getTableMeta()), afterImage);\n+            connectionProxy.appendUndoLog(sqlUndoLog);\n+            return;\n+        }\n+        List<Row> beforeImageRows = beforeImage.getRows();\n+        for (Row r : beforeImageRows) {\n+            getTableMeta().getAllIndexes().forEach((k, v) -> {\n+                if (!\"PRIMARY\".equals(k.toUpperCase()) && !v.isNonUnique()) {\n+                    StringBuilder everyRowIndex = new StringBuilder();\n+                    v.getValues().forEach(m -> {\n+                        for (Field f : r.getFields()) {\n+                            if (m.getColumnName().equals(f.getName())) {\n+                                everyRowIndex.append(f.getValue());\n+                            }\n+                        }\n+                    });\n+                    List<String> indexList = beforeUniqueIndexMap.get(k.toUpperCase());\n+                    if (CollectionUtils.isEmpty(indexList)) {\n+                        indexList = new ArrayList<>();\n+                    }\n+                    indexList.add(everyRowIndex.toString());\n+                    beforeUniqueIndexMap.put(k.toUpperCase(), indexList);\n+                }\n+            });\n+        }\n+        List<Row> insertRows = new ArrayList<>();\n+        List<Row> updateRows = new ArrayList<>();\n+        List<Row> afterImageRows = afterImage.getRows();\n+        for (Row r : afterImageRows) {\n+            Boolean[] isUpdateRows = {false};\n+            getTableMeta().getAllIndexes().forEach((k, v) -> {\n+                if (!\"PRIMARY\".equals(k.toUpperCase()) && !v.isNonUnique()) {\n+                    StringBuilder everyRowIndex = new StringBuilder();\n+                    v.getValues().forEach(m -> {\n+                        for (Field f : r.getFields()) {\n+                            if (m.getColumnName().equals(f.getName())) {\n+                                everyRowIndex.append(f.getValue());\n+                            }\n+                        }\n+                    });\n+                    List<String> indexList = beforeUniqueIndexMap.get(k.toUpperCase());\n+                    if (CollectionUtils.isNotEmpty(indexList)) {\n+                        indexList.forEach(m -> {\n+                            if (m.equals(everyRowIndex.toString())) {\n+                                isUpdateRows[0] = true;\n+                            }\n+                        });\n+                    }\n+                }\n+            });\n+            if (isUpdateRows[0]) {\n+                updateRows.add(r);\n+            } else {\n+                insertRows.add(r);\n+            }\n+        }\n+        if (CollectionUtils.isNotEmpty(updateRows)) {\n+            TableRecords partAfterImage = new TableRecords(afterImage.getTableMeta());\n+            partAfterImage.setTableName(afterImage.getTableName());\n+            partAfterImage.setRows(updateRows);\n+            connectionProxy.appendUndoLog(buildUndoItem(SQLType.UPDATE, beforeImage, partAfterImage));\n+        }\n+        if (CollectionUtils.isNotEmpty(insertRows)) {\n+            TableRecords partAfterImage = new TableRecords(afterImage.getTableMeta());\n+            partAfterImage.setTableName(afterImage.getTableName());\n+            partAfterImage.setRows(insertRows);\n+            connectionProxy.appendUndoLog(buildUndoItem(TableRecords.empty(getTableMeta()), partAfterImage));\n+        }\n+    }\n+\n+    /**\n+     * build a SQLUndoLog\n+     * @param sqlType\n+     * @param beforeImage\n+     * @param afterImage\n+     * @return\n+     */\n+    protected SQLUndoLog buildUndoItem(SQLType sqlType, TableRecords beforeImage, TableRecords afterImage) {\n+        String tableName = sqlRecognizer.getTableName();\n+        SQLUndoLog sqlUndoLog = new SQLUndoLog();\n+        sqlUndoLog.setSqlType(sqlType);\n+        sqlUndoLog.setTableName(tableName);\n+        sqlUndoLog.setBeforeImage(beforeImage);\n+        sqlUndoLog.setAfterImage(afterImage);\n+        return sqlUndoLog;\n+    }\n+\n+\n+    @Override\n+    protected TableRecords afterImage(TableRecords beforeImage) throws SQLException {\n+        Map<String, List<Object>> pkValues = getPkValues();\n+        if (isUpdateFlag) {\n+            return buildImage();\n+        } else {\n+            return afterImageInsert(pkValues);\n+        }\n+    }\n+\n+    private TableRecords afterImageInsert(Map<String, List<Object>> pkValues) throws SQLException {\n+        TableRecords afterImage = buildTableRecords(pkValues);\n+        if (afterImage == null) {\n+            throw new SQLException(\"Failed to build after-image for insert\");\n+        }\n+        return afterImage;\n+    }\n+\n+    @Override\n+    protected TableRecords beforeImage() throws SQLException {\n+        return buildImage();\n+    }\n+\n+    /**\n+     * build before image and after image\n+     * @return\n+     * @throws SQLException\n+     */\n+    protected TableRecords buildImage() throws SQLException {\n+        TableMeta tmeta = getTableMeta();\n+        //after image sql the same of before image\n+        if (StringUtils.isBlank(selectSQL)) {\n+            paramAppenderList = new ArrayList<>();\n+            selectSQL = buildImageSQL(tmeta);\n+        }\n+        return buildTableRecords2(tmeta, selectSQL, paramAppenderList);\n+    }\n+\n+    /**\n+     *  build TableRecords\n+     * @param tableMeta\n+     * @param selectSQL\n+     * @param paramAppenderList\n+     * @return\n+     * @throws SQLException\n+     */\n+    protected TableRecords buildTableRecords2(TableMeta tableMeta, String selectSQL, ArrayList<List<Object>> paramAppenderList) throws SQLException {\n+        ResultSet rs = null;\n+        try (PreparedStatement ps = statementProxy.getConnection().prepareStatement(selectSQL)) {\n+            if (CollectionUtils.isNotEmpty(paramAppenderList)) {\n+                for (int i = 0, ts = paramAppenderList.size(); i < ts; i++) {\n+                    List<Object> paramAppender = paramAppenderList.get(i);\n+                    for (int j = 0, ds = paramAppender.size(); j < ds; j++) {\n+                        ps.setObject(i * ds + j + 1, \"NULL\".equals(paramAppender.get(j).toString()) ? null : paramAppender.get(j));\n+                    }\n+                }\n+            }\n+            rs = ps.executeQuery();\n+            return TableRecords.buildRecords(tableMeta, rs);\n+        } finally {\n+            IOUtil.close(rs);\n+        }\n+    }\n+\n+    /**\n+     * build image sql\n+     * @param tableMeta\n+     * @return\n+     */\n+    private String buildImageSQL(TableMeta tableMeta) {\n+        if (CollectionUtils.isEmpty(paramAppenderList)) {\n+            paramAppenderList = new ArrayList<>();\n+        }\n+        SQLInsertRecognizer recognizer = (SQLInsertRecognizer) sqlRecognizer;\n+        Map<String, ArrayList<Object>> imageParamperterMap = new HashMap<>();\n+        int insertNum = buildImageParamperters(recognizer, imageParamperterMap);\n+        StringBuilder prefix = new StringBuilder(\"SELECT * \");\n+        StringBuilder suffix = new StringBuilder(\" FROM \").append(getFromTableInSQL());\n+        for (int i = 0; i < insertNum; i++) {\n+            int finalI = i;\n+            List<Object> paramAppenderTempList = new ArrayList<>();\n+            tableMeta.getAllIndexes().forEach((k, v) -> {\n+                if (!\"PRIMARY\".equals(k.toUpperCase()) && !v.isNonUnique()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI5Mzc0NQ=="}, "originalCommit": {"oid": "635ab95adf556dde6a4731d9fdea1896b31013e9"}, "originalPosition": 299}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODk2Nzc3NQ==", "bodyText": "\u5df2\u6539\u6b63\uff0c\u5982\u679cinsert\u524d\u7f6e\u955c\u50cf\u6ca1\u6709id\uff0c\u5219\u4e0d\u5217\u5165\u67e5\u8be2\u6761\u4ef6", "url": "https://github.com/seata/seata/pull/3374#discussion_r548967775", "createdAt": "2020-12-26T10:19:03Z", "author": {"login": "huan415"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "diffHunk": "@@ -0,0 +1,354 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec.mysql;\n+\n+import com.google.common.base.Joiner;\n+import io.seata.common.exception.NotSupportYetException;\n+import io.seata.common.loader.LoadLevel;\n+import io.seata.common.loader.Scope;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.IOUtil;\n+import io.seata.common.util.StringUtils;\n+import io.seata.rm.datasource.ConnectionProxy;\n+import io.seata.rm.datasource.PreparedStatementProxy;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.StatementCallback;\n+import io.seata.rm.datasource.sql.struct.Field;\n+import io.seata.rm.datasource.sql.struct.Row;\n+import io.seata.rm.datasource.sql.struct.TableMeta;\n+import io.seata.rm.datasource.sql.struct.TableRecords;\n+import io.seata.rm.datasource.undo.SQLUndoLog;\n+import io.seata.sqlparser.SQLInsertRecognizer;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.SQLType;\n+import io.seata.sqlparser.struct.Defaultable;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+\n+/**\n+ * @version: 1.00.00\n+ * @description:\n+ * @author: yangyicong\n+ * @date: 2020-11-26 09:06\n+ */\n+@LoadLevel(name = JdbcConstants.MYSQL, scope = Scope.PROTOTYPE)\n+public class MySQLInsertOrUpdateExecutor extends MySQLInsertExecutor implements Defaultable {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MySQLInsertOrUpdateExecutor.class);\n+\n+    //is updated or not\n+    private boolean isUpdateFlag = false;\n+\n+    //before image sql and after image sql,condition is unique index\n+    private String selectSQL;\n+\n+    //the params of selectSQL, value is the unique index\n+    private ArrayList<List<Object>> paramAppenderList;\n+\n+    //key is unique index name, value is unique index\n+    private Map<String, List<String>> beforeUniqueIndexMap = new HashMap<>();\n+\n+    public MySQLInsertOrUpdateExecutor(StatementProxy statementProxy, StatementCallback statementCallback, SQLRecognizer sqlRecognizer) {\n+        super(statementProxy, statementCallback, sqlRecognizer);\n+    }\n+\n+    /**\n+     * Execute auto commit false t.\n+     *\n+     * @param args the args\n+     * @return the t\n+     * @throws Exception the exception\n+     */\n+    @Override\n+    protected Object executeAutoCommitFalse(Object[] args) throws Exception {\n+        if (!JdbcConstants.MYSQL.equalsIgnoreCase(getDbType()) && getTableMeta().getPrimaryKeyOnlyName().size() > 1) {\n+            throw new NotSupportYetException(\"multi pk only support mysql!\");\n+        }\n+        TableRecords beforeImage = beforeImage();\n+        if (CollectionUtils.isNotEmpty(beforeImage.getRows())) {\n+            isUpdateFlag = true;\n+        } else {\n+            beforeImage = TableRecords.empty(getTableMeta());\n+        }\n+        Object result = statementCallback.execute(statementProxy.getTargetStatement(), args);\n+        TableRecords afterImage = afterImage(beforeImage);\n+        prepareUndoLog2(beforeImage, afterImage);\n+        return result;\n+    }\n+\n+    /**\n+     * prepare undo log.\n+     *\n+     * @param beforeImage the before image\n+     * @param afterImage  the after image\n+     * @throws SQLException the sql exception\n+     */\n+    protected void prepareUndoLog2(TableRecords beforeImage, TableRecords afterImage) {\n+        if (beforeImage.getRows().isEmpty() && afterImage.getRows().isEmpty()) {\n+            return;\n+        }\n+        ConnectionProxy connectionProxy = statementProxy.getConnectionProxy();\n+        TableRecords lockKeyRecords = sqlRecognizer.getSQLType() == SQLType.DELETE ? beforeImage : afterImage;\n+        String lockKeys = buildLockKey(lockKeyRecords);\n+        connectionProxy.appendLockKey(lockKeys);\n+        buildUndoItemAll(connectionProxy,beforeImage, afterImage);\n+    }\n+\n+    /**\n+     * build a SQLUndoLog\n+     *\n+     * @param beforeImage the before image\n+     * @param afterImage  the after image\n+     * @return sql undo log\n+     */\n+    protected void buildUndoItemAll(ConnectionProxy connectionProxy, TableRecords beforeImage, TableRecords afterImage) {\n+        if (!isUpdateFlag) {\n+            SQLUndoLog sqlUndoLog = buildUndoItem(TableRecords.empty(getTableMeta()), afterImage);\n+            connectionProxy.appendUndoLog(sqlUndoLog);\n+            return;\n+        }\n+        List<Row> beforeImageRows = beforeImage.getRows();\n+        for (Row r : beforeImageRows) {\n+            getTableMeta().getAllIndexes().forEach((k, v) -> {\n+                if (!\"PRIMARY\".equals(k.toUpperCase()) && !v.isNonUnique()) {\n+                    StringBuilder everyRowIndex = new StringBuilder();\n+                    v.getValues().forEach(m -> {\n+                        for (Field f : r.getFields()) {\n+                            if (m.getColumnName().equals(f.getName())) {\n+                                everyRowIndex.append(f.getValue());\n+                            }\n+                        }\n+                    });\n+                    List<String> indexList = beforeUniqueIndexMap.get(k.toUpperCase());\n+                    if (CollectionUtils.isEmpty(indexList)) {\n+                        indexList = new ArrayList<>();\n+                    }\n+                    indexList.add(everyRowIndex.toString());\n+                    beforeUniqueIndexMap.put(k.toUpperCase(), indexList);\n+                }\n+            });\n+        }\n+        List<Row> insertRows = new ArrayList<>();\n+        List<Row> updateRows = new ArrayList<>();\n+        List<Row> afterImageRows = afterImage.getRows();\n+        for (Row r : afterImageRows) {\n+            Boolean[] isUpdateRows = {false};\n+            getTableMeta().getAllIndexes().forEach((k, v) -> {\n+                if (!\"PRIMARY\".equals(k.toUpperCase()) && !v.isNonUnique()) {\n+                    StringBuilder everyRowIndex = new StringBuilder();\n+                    v.getValues().forEach(m -> {\n+                        for (Field f : r.getFields()) {\n+                            if (m.getColumnName().equals(f.getName())) {\n+                                everyRowIndex.append(f.getValue());\n+                            }\n+                        }\n+                    });\n+                    List<String> indexList = beforeUniqueIndexMap.get(k.toUpperCase());\n+                    if (CollectionUtils.isNotEmpty(indexList)) {\n+                        indexList.forEach(m -> {\n+                            if (m.equals(everyRowIndex.toString())) {\n+                                isUpdateRows[0] = true;\n+                            }\n+                        });\n+                    }\n+                }\n+            });\n+            if (isUpdateRows[0]) {\n+                updateRows.add(r);\n+            } else {\n+                insertRows.add(r);\n+            }\n+        }\n+        if (CollectionUtils.isNotEmpty(updateRows)) {\n+            TableRecords partAfterImage = new TableRecords(afterImage.getTableMeta());\n+            partAfterImage.setTableName(afterImage.getTableName());\n+            partAfterImage.setRows(updateRows);\n+            connectionProxy.appendUndoLog(buildUndoItem(SQLType.UPDATE, beforeImage, partAfterImage));\n+        }\n+        if (CollectionUtils.isNotEmpty(insertRows)) {\n+            TableRecords partAfterImage = new TableRecords(afterImage.getTableMeta());\n+            partAfterImage.setTableName(afterImage.getTableName());\n+            partAfterImage.setRows(insertRows);\n+            connectionProxy.appendUndoLog(buildUndoItem(TableRecords.empty(getTableMeta()), partAfterImage));\n+        }\n+    }\n+\n+    /**\n+     * build a SQLUndoLog\n+     * @param sqlType\n+     * @param beforeImage\n+     * @param afterImage\n+     * @return\n+     */\n+    protected SQLUndoLog buildUndoItem(SQLType sqlType, TableRecords beforeImage, TableRecords afterImage) {\n+        String tableName = sqlRecognizer.getTableName();\n+        SQLUndoLog sqlUndoLog = new SQLUndoLog();\n+        sqlUndoLog.setSqlType(sqlType);\n+        sqlUndoLog.setTableName(tableName);\n+        sqlUndoLog.setBeforeImage(beforeImage);\n+        sqlUndoLog.setAfterImage(afterImage);\n+        return sqlUndoLog;\n+    }\n+\n+\n+    @Override\n+    protected TableRecords afterImage(TableRecords beforeImage) throws SQLException {\n+        Map<String, List<Object>> pkValues = getPkValues();\n+        if (isUpdateFlag) {\n+            return buildImage();\n+        } else {\n+            return afterImageInsert(pkValues);\n+        }\n+    }\n+\n+    private TableRecords afterImageInsert(Map<String, List<Object>> pkValues) throws SQLException {\n+        TableRecords afterImage = buildTableRecords(pkValues);\n+        if (afterImage == null) {\n+            throw new SQLException(\"Failed to build after-image for insert\");\n+        }\n+        return afterImage;\n+    }\n+\n+    @Override\n+    protected TableRecords beforeImage() throws SQLException {\n+        return buildImage();\n+    }\n+\n+    /**\n+     * build before image and after image\n+     * @return\n+     * @throws SQLException\n+     */\n+    protected TableRecords buildImage() throws SQLException {\n+        TableMeta tmeta = getTableMeta();\n+        //after image sql the same of before image\n+        if (StringUtils.isBlank(selectSQL)) {\n+            paramAppenderList = new ArrayList<>();\n+            selectSQL = buildImageSQL(tmeta);\n+        }\n+        return buildTableRecords2(tmeta, selectSQL, paramAppenderList);\n+    }\n+\n+    /**\n+     *  build TableRecords\n+     * @param tableMeta\n+     * @param selectSQL\n+     * @param paramAppenderList\n+     * @return\n+     * @throws SQLException\n+     */\n+    protected TableRecords buildTableRecords2(TableMeta tableMeta, String selectSQL, ArrayList<List<Object>> paramAppenderList) throws SQLException {\n+        ResultSet rs = null;\n+        try (PreparedStatement ps = statementProxy.getConnection().prepareStatement(selectSQL)) {\n+            if (CollectionUtils.isNotEmpty(paramAppenderList)) {\n+                for (int i = 0, ts = paramAppenderList.size(); i < ts; i++) {\n+                    List<Object> paramAppender = paramAppenderList.get(i);\n+                    for (int j = 0, ds = paramAppender.size(); j < ds; j++) {\n+                        ps.setObject(i * ds + j + 1, \"NULL\".equals(paramAppender.get(j).toString()) ? null : paramAppender.get(j));\n+                    }\n+                }\n+            }\n+            rs = ps.executeQuery();\n+            return TableRecords.buildRecords(tableMeta, rs);\n+        } finally {\n+            IOUtil.close(rs);\n+        }\n+    }\n+\n+    /**\n+     * build image sql\n+     * @param tableMeta\n+     * @return\n+     */\n+    private String buildImageSQL(TableMeta tableMeta) {\n+        if (CollectionUtils.isEmpty(paramAppenderList)) {\n+            paramAppenderList = new ArrayList<>();\n+        }\n+        SQLInsertRecognizer recognizer = (SQLInsertRecognizer) sqlRecognizer;\n+        Map<String, ArrayList<Object>> imageParamperterMap = new HashMap<>();\n+        int insertNum = buildImageParamperters(recognizer, imageParamperterMap);\n+        StringBuilder prefix = new StringBuilder(\"SELECT * \");\n+        StringBuilder suffix = new StringBuilder(\" FROM \").append(getFromTableInSQL());\n+        for (int i = 0; i < insertNum; i++) {\n+            int finalI = i;\n+            List<Object> paramAppenderTempList = new ArrayList<>();\n+            tableMeta.getAllIndexes().forEach((k, v) -> {\n+                if (!\"PRIMARY\".equals(k.toUpperCase()) && !v.isNonUnique()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI5Mzc0NQ=="}, "originalCommit": {"oid": "635ab95adf556dde6a4731d9fdea1896b31013e9"}, "originalPosition": 299}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0MTEwNTk4OnYy", "diffSide": "RIGHT", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxNDowNToxNFrOIJ8STQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yNlQxMDoyMjoxMFrOILiWIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI5NTgyMQ==", "bodyText": "\u8fd9\u91cc\u7528contains\u7684\u6027\u80fd\u662f\u4e0d\u662f\u4f1a\u5dee\u4e00\u70b9\uff1f\u5e76\u4e14contains\u7684\u8bdd\uff0c\u662f\u4e0d\u662f\u6709\u53ef\u80fd\u8bef\u5224\uff1f", "url": "https://github.com/seata/seata/pull/3374#discussion_r547295821", "createdAt": "2020-12-22T14:05:14Z", "author": {"login": "caohdgege"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "diffHunk": "@@ -0,0 +1,354 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec.mysql;\n+\n+import com.google.common.base.Joiner;\n+import io.seata.common.exception.NotSupportYetException;\n+import io.seata.common.loader.LoadLevel;\n+import io.seata.common.loader.Scope;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.IOUtil;\n+import io.seata.common.util.StringUtils;\n+import io.seata.rm.datasource.ConnectionProxy;\n+import io.seata.rm.datasource.PreparedStatementProxy;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.StatementCallback;\n+import io.seata.rm.datasource.sql.struct.Field;\n+import io.seata.rm.datasource.sql.struct.Row;\n+import io.seata.rm.datasource.sql.struct.TableMeta;\n+import io.seata.rm.datasource.sql.struct.TableRecords;\n+import io.seata.rm.datasource.undo.SQLUndoLog;\n+import io.seata.sqlparser.SQLInsertRecognizer;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.SQLType;\n+import io.seata.sqlparser.struct.Defaultable;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+\n+/**\n+ * @version: 1.00.00\n+ * @description:\n+ * @author: yangyicong\n+ * @date: 2020-11-26 09:06\n+ */\n+@LoadLevel(name = JdbcConstants.MYSQL, scope = Scope.PROTOTYPE)\n+public class MySQLInsertOrUpdateExecutor extends MySQLInsertExecutor implements Defaultable {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MySQLInsertOrUpdateExecutor.class);\n+\n+    //is updated or not\n+    private boolean isUpdateFlag = false;\n+\n+    //before image sql and after image sql,condition is unique index\n+    private String selectSQL;\n+\n+    //the params of selectSQL, value is the unique index\n+    private ArrayList<List<Object>> paramAppenderList;\n+\n+    //key is unique index name, value is unique index\n+    private Map<String, List<String>> beforeUniqueIndexMap = new HashMap<>();\n+\n+    public MySQLInsertOrUpdateExecutor(StatementProxy statementProxy, StatementCallback statementCallback, SQLRecognizer sqlRecognizer) {\n+        super(statementProxy, statementCallback, sqlRecognizer);\n+    }\n+\n+    /**\n+     * Execute auto commit false t.\n+     *\n+     * @param args the args\n+     * @return the t\n+     * @throws Exception the exception\n+     */\n+    @Override\n+    protected Object executeAutoCommitFalse(Object[] args) throws Exception {\n+        if (!JdbcConstants.MYSQL.equalsIgnoreCase(getDbType()) && getTableMeta().getPrimaryKeyOnlyName().size() > 1) {\n+            throw new NotSupportYetException(\"multi pk only support mysql!\");\n+        }\n+        TableRecords beforeImage = beforeImage();\n+        if (CollectionUtils.isNotEmpty(beforeImage.getRows())) {\n+            isUpdateFlag = true;\n+        } else {\n+            beforeImage = TableRecords.empty(getTableMeta());\n+        }\n+        Object result = statementCallback.execute(statementProxy.getTargetStatement(), args);\n+        TableRecords afterImage = afterImage(beforeImage);\n+        prepareUndoLog2(beforeImage, afterImage);\n+        return result;\n+    }\n+\n+    /**\n+     * prepare undo log.\n+     *\n+     * @param beforeImage the before image\n+     * @param afterImage  the after image\n+     * @throws SQLException the sql exception\n+     */\n+    protected void prepareUndoLog2(TableRecords beforeImage, TableRecords afterImage) {\n+        if (beforeImage.getRows().isEmpty() && afterImage.getRows().isEmpty()) {\n+            return;\n+        }\n+        ConnectionProxy connectionProxy = statementProxy.getConnectionProxy();\n+        TableRecords lockKeyRecords = sqlRecognizer.getSQLType() == SQLType.DELETE ? beforeImage : afterImage;\n+        String lockKeys = buildLockKey(lockKeyRecords);\n+        connectionProxy.appendLockKey(lockKeys);\n+        buildUndoItemAll(connectionProxy,beforeImage, afterImage);\n+    }\n+\n+    /**\n+     * build a SQLUndoLog\n+     *\n+     * @param beforeImage the before image\n+     * @param afterImage  the after image\n+     * @return sql undo log\n+     */\n+    protected void buildUndoItemAll(ConnectionProxy connectionProxy, TableRecords beforeImage, TableRecords afterImage) {\n+        if (!isUpdateFlag) {\n+            SQLUndoLog sqlUndoLog = buildUndoItem(TableRecords.empty(getTableMeta()), afterImage);\n+            connectionProxy.appendUndoLog(sqlUndoLog);\n+            return;\n+        }\n+        List<Row> beforeImageRows = beforeImage.getRows();\n+        for (Row r : beforeImageRows) {\n+            getTableMeta().getAllIndexes().forEach((k, v) -> {\n+                if (!\"PRIMARY\".equals(k.toUpperCase()) && !v.isNonUnique()) {\n+                    StringBuilder everyRowIndex = new StringBuilder();\n+                    v.getValues().forEach(m -> {\n+                        for (Field f : r.getFields()) {\n+                            if (m.getColumnName().equals(f.getName())) {\n+                                everyRowIndex.append(f.getValue());\n+                            }\n+                        }\n+                    });\n+                    List<String> indexList = beforeUniqueIndexMap.get(k.toUpperCase());\n+                    if (CollectionUtils.isEmpty(indexList)) {\n+                        indexList = new ArrayList<>();\n+                    }\n+                    indexList.add(everyRowIndex.toString());\n+                    beforeUniqueIndexMap.put(k.toUpperCase(), indexList);\n+                }\n+            });\n+        }\n+        List<Row> insertRows = new ArrayList<>();\n+        List<Row> updateRows = new ArrayList<>();\n+        List<Row> afterImageRows = afterImage.getRows();\n+        for (Row r : afterImageRows) {\n+            Boolean[] isUpdateRows = {false};\n+            getTableMeta().getAllIndexes().forEach((k, v) -> {\n+                if (!\"PRIMARY\".equals(k.toUpperCase()) && !v.isNonUnique()) {\n+                    StringBuilder everyRowIndex = new StringBuilder();\n+                    v.getValues().forEach(m -> {\n+                        for (Field f : r.getFields()) {\n+                            if (m.getColumnName().equals(f.getName())) {\n+                                everyRowIndex.append(f.getValue());\n+                            }\n+                        }\n+                    });\n+                    List<String> indexList = beforeUniqueIndexMap.get(k.toUpperCase());\n+                    if (CollectionUtils.isNotEmpty(indexList)) {\n+                        indexList.forEach(m -> {\n+                            if (m.equals(everyRowIndex.toString())) {\n+                                isUpdateRows[0] = true;\n+                            }\n+                        });\n+                    }\n+                }\n+            });\n+            if (isUpdateRows[0]) {\n+                updateRows.add(r);\n+            } else {\n+                insertRows.add(r);\n+            }\n+        }\n+        if (CollectionUtils.isNotEmpty(updateRows)) {\n+            TableRecords partAfterImage = new TableRecords(afterImage.getTableMeta());\n+            partAfterImage.setTableName(afterImage.getTableName());\n+            partAfterImage.setRows(updateRows);\n+            connectionProxy.appendUndoLog(buildUndoItem(SQLType.UPDATE, beforeImage, partAfterImage));\n+        }\n+        if (CollectionUtils.isNotEmpty(insertRows)) {\n+            TableRecords partAfterImage = new TableRecords(afterImage.getTableMeta());\n+            partAfterImage.setTableName(afterImage.getTableName());\n+            partAfterImage.setRows(insertRows);\n+            connectionProxy.appendUndoLog(buildUndoItem(TableRecords.empty(getTableMeta()), partAfterImage));\n+        }\n+    }\n+\n+    /**\n+     * build a SQLUndoLog\n+     * @param sqlType\n+     * @param beforeImage\n+     * @param afterImage\n+     * @return\n+     */\n+    protected SQLUndoLog buildUndoItem(SQLType sqlType, TableRecords beforeImage, TableRecords afterImage) {\n+        String tableName = sqlRecognizer.getTableName();\n+        SQLUndoLog sqlUndoLog = new SQLUndoLog();\n+        sqlUndoLog.setSqlType(sqlType);\n+        sqlUndoLog.setTableName(tableName);\n+        sqlUndoLog.setBeforeImage(beforeImage);\n+        sqlUndoLog.setAfterImage(afterImage);\n+        return sqlUndoLog;\n+    }\n+\n+\n+    @Override\n+    protected TableRecords afterImage(TableRecords beforeImage) throws SQLException {\n+        Map<String, List<Object>> pkValues = getPkValues();\n+        if (isUpdateFlag) {\n+            return buildImage();\n+        } else {\n+            return afterImageInsert(pkValues);\n+        }\n+    }\n+\n+    private TableRecords afterImageInsert(Map<String, List<Object>> pkValues) throws SQLException {\n+        TableRecords afterImage = buildTableRecords(pkValues);\n+        if (afterImage == null) {\n+            throw new SQLException(\"Failed to build after-image for insert\");\n+        }\n+        return afterImage;\n+    }\n+\n+    @Override\n+    protected TableRecords beforeImage() throws SQLException {\n+        return buildImage();\n+    }\n+\n+    /**\n+     * build before image and after image\n+     * @return\n+     * @throws SQLException\n+     */\n+    protected TableRecords buildImage() throws SQLException {\n+        TableMeta tmeta = getTableMeta();\n+        //after image sql the same of before image\n+        if (StringUtils.isBlank(selectSQL)) {\n+            paramAppenderList = new ArrayList<>();\n+            selectSQL = buildImageSQL(tmeta);\n+        }\n+        return buildTableRecords2(tmeta, selectSQL, paramAppenderList);\n+    }\n+\n+    /**\n+     *  build TableRecords\n+     * @param tableMeta\n+     * @param selectSQL\n+     * @param paramAppenderList\n+     * @return\n+     * @throws SQLException\n+     */\n+    protected TableRecords buildTableRecords2(TableMeta tableMeta, String selectSQL, ArrayList<List<Object>> paramAppenderList) throws SQLException {\n+        ResultSet rs = null;\n+        try (PreparedStatement ps = statementProxy.getConnection().prepareStatement(selectSQL)) {\n+            if (CollectionUtils.isNotEmpty(paramAppenderList)) {\n+                for (int i = 0, ts = paramAppenderList.size(); i < ts; i++) {\n+                    List<Object> paramAppender = paramAppenderList.get(i);\n+                    for (int j = 0, ds = paramAppender.size(); j < ds; j++) {\n+                        ps.setObject(i * ds + j + 1, \"NULL\".equals(paramAppender.get(j).toString()) ? null : paramAppender.get(j));\n+                    }\n+                }\n+            }\n+            rs = ps.executeQuery();\n+            return TableRecords.buildRecords(tableMeta, rs);\n+        } finally {\n+            IOUtil.close(rs);\n+        }\n+    }\n+\n+    /**\n+     * build image sql\n+     * @param tableMeta\n+     * @return\n+     */\n+    private String buildImageSQL(TableMeta tableMeta) {\n+        if (CollectionUtils.isEmpty(paramAppenderList)) {\n+            paramAppenderList = new ArrayList<>();\n+        }\n+        SQLInsertRecognizer recognizer = (SQLInsertRecognizer) sqlRecognizer;\n+        Map<String, ArrayList<Object>> imageParamperterMap = new HashMap<>();\n+        int insertNum = buildImageParamperters(recognizer, imageParamperterMap);\n+        StringBuilder prefix = new StringBuilder(\"SELECT * \");\n+        StringBuilder suffix = new StringBuilder(\" FROM \").append(getFromTableInSQL());\n+        for (int i = 0; i < insertNum; i++) {\n+            int finalI = i;\n+            List<Object> paramAppenderTempList = new ArrayList<>();\n+            tableMeta.getAllIndexes().forEach((k, v) -> {\n+                if (!\"PRIMARY\".equals(k.toUpperCase()) && !v.isNonUnique()) {\n+                    List<String> uniqueList = new ArrayList<>();\n+                    v.getValues().forEach(m -> {\n+                        String columnName = m.getColumnName();\n+                        uniqueList.add(columnName + \" = ? \");\n+                        paramAppenderTempList.add(imageParamperterMap.get(m.getColumnName()).get(finalI));\n+                    });\n+                    if (suffix.toString().contains(\"WHERE\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "635ab95adf556dde6a4731d9fdea1896b31013e9"}, "originalPosition": 306}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODk2Nzk2OA==", "bodyText": "\u8fd9\u4e2asql\u662f\u6211\u4eec\u81ea\u5df1\u62fc\u63a5\u6765\u67e5\u8be2\u955c\u50cf\uff0c\u4e00\u822c\u4e0d\u4f1a\u6709\u8bef\u5224\u3002\n\u6539\u4e3a\u58f0\u660e\u4e86\u4e00\u4e2aflag\uff0c\u7b2c\u4e00\u6b21\u7684\u65f6\u5019\u62fc\u63a5where\uff0c\u4ee5\u540e\u62fc\u63a5\u7684\u662for", "url": "https://github.com/seata/seata/pull/3374#discussion_r548967968", "createdAt": "2020-12-26T10:22:10Z", "author": {"login": "huan415"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "diffHunk": "@@ -0,0 +1,354 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec.mysql;\n+\n+import com.google.common.base.Joiner;\n+import io.seata.common.exception.NotSupportYetException;\n+import io.seata.common.loader.LoadLevel;\n+import io.seata.common.loader.Scope;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.IOUtil;\n+import io.seata.common.util.StringUtils;\n+import io.seata.rm.datasource.ConnectionProxy;\n+import io.seata.rm.datasource.PreparedStatementProxy;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.StatementCallback;\n+import io.seata.rm.datasource.sql.struct.Field;\n+import io.seata.rm.datasource.sql.struct.Row;\n+import io.seata.rm.datasource.sql.struct.TableMeta;\n+import io.seata.rm.datasource.sql.struct.TableRecords;\n+import io.seata.rm.datasource.undo.SQLUndoLog;\n+import io.seata.sqlparser.SQLInsertRecognizer;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.SQLType;\n+import io.seata.sqlparser.struct.Defaultable;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+\n+/**\n+ * @version: 1.00.00\n+ * @description:\n+ * @author: yangyicong\n+ * @date: 2020-11-26 09:06\n+ */\n+@LoadLevel(name = JdbcConstants.MYSQL, scope = Scope.PROTOTYPE)\n+public class MySQLInsertOrUpdateExecutor extends MySQLInsertExecutor implements Defaultable {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MySQLInsertOrUpdateExecutor.class);\n+\n+    //is updated or not\n+    private boolean isUpdateFlag = false;\n+\n+    //before image sql and after image sql,condition is unique index\n+    private String selectSQL;\n+\n+    //the params of selectSQL, value is the unique index\n+    private ArrayList<List<Object>> paramAppenderList;\n+\n+    //key is unique index name, value is unique index\n+    private Map<String, List<String>> beforeUniqueIndexMap = new HashMap<>();\n+\n+    public MySQLInsertOrUpdateExecutor(StatementProxy statementProxy, StatementCallback statementCallback, SQLRecognizer sqlRecognizer) {\n+        super(statementProxy, statementCallback, sqlRecognizer);\n+    }\n+\n+    /**\n+     * Execute auto commit false t.\n+     *\n+     * @param args the args\n+     * @return the t\n+     * @throws Exception the exception\n+     */\n+    @Override\n+    protected Object executeAutoCommitFalse(Object[] args) throws Exception {\n+        if (!JdbcConstants.MYSQL.equalsIgnoreCase(getDbType()) && getTableMeta().getPrimaryKeyOnlyName().size() > 1) {\n+            throw new NotSupportYetException(\"multi pk only support mysql!\");\n+        }\n+        TableRecords beforeImage = beforeImage();\n+        if (CollectionUtils.isNotEmpty(beforeImage.getRows())) {\n+            isUpdateFlag = true;\n+        } else {\n+            beforeImage = TableRecords.empty(getTableMeta());\n+        }\n+        Object result = statementCallback.execute(statementProxy.getTargetStatement(), args);\n+        TableRecords afterImage = afterImage(beforeImage);\n+        prepareUndoLog2(beforeImage, afterImage);\n+        return result;\n+    }\n+\n+    /**\n+     * prepare undo log.\n+     *\n+     * @param beforeImage the before image\n+     * @param afterImage  the after image\n+     * @throws SQLException the sql exception\n+     */\n+    protected void prepareUndoLog2(TableRecords beforeImage, TableRecords afterImage) {\n+        if (beforeImage.getRows().isEmpty() && afterImage.getRows().isEmpty()) {\n+            return;\n+        }\n+        ConnectionProxy connectionProxy = statementProxy.getConnectionProxy();\n+        TableRecords lockKeyRecords = sqlRecognizer.getSQLType() == SQLType.DELETE ? beforeImage : afterImage;\n+        String lockKeys = buildLockKey(lockKeyRecords);\n+        connectionProxy.appendLockKey(lockKeys);\n+        buildUndoItemAll(connectionProxy,beforeImage, afterImage);\n+    }\n+\n+    /**\n+     * build a SQLUndoLog\n+     *\n+     * @param beforeImage the before image\n+     * @param afterImage  the after image\n+     * @return sql undo log\n+     */\n+    protected void buildUndoItemAll(ConnectionProxy connectionProxy, TableRecords beforeImage, TableRecords afterImage) {\n+        if (!isUpdateFlag) {\n+            SQLUndoLog sqlUndoLog = buildUndoItem(TableRecords.empty(getTableMeta()), afterImage);\n+            connectionProxy.appendUndoLog(sqlUndoLog);\n+            return;\n+        }\n+        List<Row> beforeImageRows = beforeImage.getRows();\n+        for (Row r : beforeImageRows) {\n+            getTableMeta().getAllIndexes().forEach((k, v) -> {\n+                if (!\"PRIMARY\".equals(k.toUpperCase()) && !v.isNonUnique()) {\n+                    StringBuilder everyRowIndex = new StringBuilder();\n+                    v.getValues().forEach(m -> {\n+                        for (Field f : r.getFields()) {\n+                            if (m.getColumnName().equals(f.getName())) {\n+                                everyRowIndex.append(f.getValue());\n+                            }\n+                        }\n+                    });\n+                    List<String> indexList = beforeUniqueIndexMap.get(k.toUpperCase());\n+                    if (CollectionUtils.isEmpty(indexList)) {\n+                        indexList = new ArrayList<>();\n+                    }\n+                    indexList.add(everyRowIndex.toString());\n+                    beforeUniqueIndexMap.put(k.toUpperCase(), indexList);\n+                }\n+            });\n+        }\n+        List<Row> insertRows = new ArrayList<>();\n+        List<Row> updateRows = new ArrayList<>();\n+        List<Row> afterImageRows = afterImage.getRows();\n+        for (Row r : afterImageRows) {\n+            Boolean[] isUpdateRows = {false};\n+            getTableMeta().getAllIndexes().forEach((k, v) -> {\n+                if (!\"PRIMARY\".equals(k.toUpperCase()) && !v.isNonUnique()) {\n+                    StringBuilder everyRowIndex = new StringBuilder();\n+                    v.getValues().forEach(m -> {\n+                        for (Field f : r.getFields()) {\n+                            if (m.getColumnName().equals(f.getName())) {\n+                                everyRowIndex.append(f.getValue());\n+                            }\n+                        }\n+                    });\n+                    List<String> indexList = beforeUniqueIndexMap.get(k.toUpperCase());\n+                    if (CollectionUtils.isNotEmpty(indexList)) {\n+                        indexList.forEach(m -> {\n+                            if (m.equals(everyRowIndex.toString())) {\n+                                isUpdateRows[0] = true;\n+                            }\n+                        });\n+                    }\n+                }\n+            });\n+            if (isUpdateRows[0]) {\n+                updateRows.add(r);\n+            } else {\n+                insertRows.add(r);\n+            }\n+        }\n+        if (CollectionUtils.isNotEmpty(updateRows)) {\n+            TableRecords partAfterImage = new TableRecords(afterImage.getTableMeta());\n+            partAfterImage.setTableName(afterImage.getTableName());\n+            partAfterImage.setRows(updateRows);\n+            connectionProxy.appendUndoLog(buildUndoItem(SQLType.UPDATE, beforeImage, partAfterImage));\n+        }\n+        if (CollectionUtils.isNotEmpty(insertRows)) {\n+            TableRecords partAfterImage = new TableRecords(afterImage.getTableMeta());\n+            partAfterImage.setTableName(afterImage.getTableName());\n+            partAfterImage.setRows(insertRows);\n+            connectionProxy.appendUndoLog(buildUndoItem(TableRecords.empty(getTableMeta()), partAfterImage));\n+        }\n+    }\n+\n+    /**\n+     * build a SQLUndoLog\n+     * @param sqlType\n+     * @param beforeImage\n+     * @param afterImage\n+     * @return\n+     */\n+    protected SQLUndoLog buildUndoItem(SQLType sqlType, TableRecords beforeImage, TableRecords afterImage) {\n+        String tableName = sqlRecognizer.getTableName();\n+        SQLUndoLog sqlUndoLog = new SQLUndoLog();\n+        sqlUndoLog.setSqlType(sqlType);\n+        sqlUndoLog.setTableName(tableName);\n+        sqlUndoLog.setBeforeImage(beforeImage);\n+        sqlUndoLog.setAfterImage(afterImage);\n+        return sqlUndoLog;\n+    }\n+\n+\n+    @Override\n+    protected TableRecords afterImage(TableRecords beforeImage) throws SQLException {\n+        Map<String, List<Object>> pkValues = getPkValues();\n+        if (isUpdateFlag) {\n+            return buildImage();\n+        } else {\n+            return afterImageInsert(pkValues);\n+        }\n+    }\n+\n+    private TableRecords afterImageInsert(Map<String, List<Object>> pkValues) throws SQLException {\n+        TableRecords afterImage = buildTableRecords(pkValues);\n+        if (afterImage == null) {\n+            throw new SQLException(\"Failed to build after-image for insert\");\n+        }\n+        return afterImage;\n+    }\n+\n+    @Override\n+    protected TableRecords beforeImage() throws SQLException {\n+        return buildImage();\n+    }\n+\n+    /**\n+     * build before image and after image\n+     * @return\n+     * @throws SQLException\n+     */\n+    protected TableRecords buildImage() throws SQLException {\n+        TableMeta tmeta = getTableMeta();\n+        //after image sql the same of before image\n+        if (StringUtils.isBlank(selectSQL)) {\n+            paramAppenderList = new ArrayList<>();\n+            selectSQL = buildImageSQL(tmeta);\n+        }\n+        return buildTableRecords2(tmeta, selectSQL, paramAppenderList);\n+    }\n+\n+    /**\n+     *  build TableRecords\n+     * @param tableMeta\n+     * @param selectSQL\n+     * @param paramAppenderList\n+     * @return\n+     * @throws SQLException\n+     */\n+    protected TableRecords buildTableRecords2(TableMeta tableMeta, String selectSQL, ArrayList<List<Object>> paramAppenderList) throws SQLException {\n+        ResultSet rs = null;\n+        try (PreparedStatement ps = statementProxy.getConnection().prepareStatement(selectSQL)) {\n+            if (CollectionUtils.isNotEmpty(paramAppenderList)) {\n+                for (int i = 0, ts = paramAppenderList.size(); i < ts; i++) {\n+                    List<Object> paramAppender = paramAppenderList.get(i);\n+                    for (int j = 0, ds = paramAppender.size(); j < ds; j++) {\n+                        ps.setObject(i * ds + j + 1, \"NULL\".equals(paramAppender.get(j).toString()) ? null : paramAppender.get(j));\n+                    }\n+                }\n+            }\n+            rs = ps.executeQuery();\n+            return TableRecords.buildRecords(tableMeta, rs);\n+        } finally {\n+            IOUtil.close(rs);\n+        }\n+    }\n+\n+    /**\n+     * build image sql\n+     * @param tableMeta\n+     * @return\n+     */\n+    private String buildImageSQL(TableMeta tableMeta) {\n+        if (CollectionUtils.isEmpty(paramAppenderList)) {\n+            paramAppenderList = new ArrayList<>();\n+        }\n+        SQLInsertRecognizer recognizer = (SQLInsertRecognizer) sqlRecognizer;\n+        Map<String, ArrayList<Object>> imageParamperterMap = new HashMap<>();\n+        int insertNum = buildImageParamperters(recognizer, imageParamperterMap);\n+        StringBuilder prefix = new StringBuilder(\"SELECT * \");\n+        StringBuilder suffix = new StringBuilder(\" FROM \").append(getFromTableInSQL());\n+        for (int i = 0; i < insertNum; i++) {\n+            int finalI = i;\n+            List<Object> paramAppenderTempList = new ArrayList<>();\n+            tableMeta.getAllIndexes().forEach((k, v) -> {\n+                if (!\"PRIMARY\".equals(k.toUpperCase()) && !v.isNonUnique()) {\n+                    List<String> uniqueList = new ArrayList<>();\n+                    v.getValues().forEach(m -> {\n+                        String columnName = m.getColumnName();\n+                        uniqueList.add(columnName + \" = ? \");\n+                        paramAppenderTempList.add(imageParamperterMap.get(m.getColumnName()).get(finalI));\n+                    });\n+                    if (suffix.toString().contains(\"WHERE\")) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI5NTgyMQ=="}, "originalCommit": {"oid": "635ab95adf556dde6a4731d9fdea1896b31013e9"}, "originalPosition": 306}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1MzY4MzQ5OnYy", "diffSide": "RIGHT", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yN1QxNjowMzo1OFrOILsOcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOFQxMzo1ODo0OFrOIL6HGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTEyOTg0Mw==", "bodyText": "java\u5f00\u5934\u7684import\u8981\u8c03\u5230\u4e0a\u9762\u3002", "url": "https://github.com/seata/seata/pull/3374#discussion_r549129843", "createdAt": "2020-12-27T16:03:58Z", "author": {"login": "caohdgege"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec.mysql;\n+\n+import com.google.common.base.Joiner;\n+import io.seata.common.exception.NotSupportYetException;\n+import io.seata.common.loader.LoadLevel;\n+import io.seata.common.loader.Scope;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.IOUtil;\n+import io.seata.common.util.StringUtils;\n+import io.seata.rm.datasource.ConnectionProxy;\n+import io.seata.rm.datasource.PreparedStatementProxy;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.StatementCallback;\n+import io.seata.rm.datasource.sql.struct.ColumnMeta;\n+import io.seata.rm.datasource.sql.struct.Field;\n+import io.seata.rm.datasource.sql.struct.Row;\n+import io.seata.rm.datasource.sql.struct.TableMeta;\n+import io.seata.rm.datasource.sql.struct.TableRecords;\n+import io.seata.rm.datasource.undo.SQLUndoLog;\n+import io.seata.sqlparser.SQLInsertRecognizer;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.SQLType;\n+import io.seata.sqlparser.struct.Defaultable;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "326a058fafc46d70462fd25dd10207ec511f1b80"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTM1NTA0Mg==", "bodyText": "\u5df2\u6539\uff0c\u80fd\u8bf4\u4e00\u4e0b\u539f\u56e0\u5417", "url": "https://github.com/seata/seata/pull/3374#discussion_r549355042", "createdAt": "2020-12-28T13:51:35Z", "author": {"login": "huan415"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec.mysql;\n+\n+import com.google.common.base.Joiner;\n+import io.seata.common.exception.NotSupportYetException;\n+import io.seata.common.loader.LoadLevel;\n+import io.seata.common.loader.Scope;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.IOUtil;\n+import io.seata.common.util.StringUtils;\n+import io.seata.rm.datasource.ConnectionProxy;\n+import io.seata.rm.datasource.PreparedStatementProxy;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.StatementCallback;\n+import io.seata.rm.datasource.sql.struct.ColumnMeta;\n+import io.seata.rm.datasource.sql.struct.Field;\n+import io.seata.rm.datasource.sql.struct.Row;\n+import io.seata.rm.datasource.sql.struct.TableMeta;\n+import io.seata.rm.datasource.sql.struct.TableRecords;\n+import io.seata.rm.datasource.undo.SQLUndoLog;\n+import io.seata.sqlparser.SQLInsertRecognizer;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.SQLType;\n+import io.seata.sqlparser.struct.Defaultable;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTEyOTg0Mw=="}, "originalCommit": {"oid": "326a058fafc46d70462fd25dd10207ec511f1b80"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTM1NzMzOQ==", "bodyText": "\u89c4\u8303\u5427\u3002\u3002\u3002\u6211\u8fdb\u6765\u7684\u65f6\u5019\u5927\u4f6c\u4eec\u8ddf\u6211\u8bf4\u7684\u3002\u3002\u3002", "url": "https://github.com/seata/seata/pull/3374#discussion_r549357339", "createdAt": "2020-12-28T13:58:48Z", "author": {"login": "caohdgege"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec.mysql;\n+\n+import com.google.common.base.Joiner;\n+import io.seata.common.exception.NotSupportYetException;\n+import io.seata.common.loader.LoadLevel;\n+import io.seata.common.loader.Scope;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.IOUtil;\n+import io.seata.common.util.StringUtils;\n+import io.seata.rm.datasource.ConnectionProxy;\n+import io.seata.rm.datasource.PreparedStatementProxy;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.StatementCallback;\n+import io.seata.rm.datasource.sql.struct.ColumnMeta;\n+import io.seata.rm.datasource.sql.struct.Field;\n+import io.seata.rm.datasource.sql.struct.Row;\n+import io.seata.rm.datasource.sql.struct.TableMeta;\n+import io.seata.rm.datasource.sql.struct.TableRecords;\n+import io.seata.rm.datasource.undo.SQLUndoLog;\n+import io.seata.sqlparser.SQLInsertRecognizer;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.SQLType;\n+import io.seata.sqlparser.struct.Defaultable;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTEyOTg0Mw=="}, "originalCommit": {"oid": "326a058fafc46d70462fd25dd10207ec511f1b80"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1MzY4NTA5OnYy", "diffSide": "RIGHT", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yN1QxNjowNTo1NFrOILsPNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yN1QxNjowNTo1NFrOILsPNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTEzMDAzOA==", "bodyText": "\u7528\u4ee5\u4e0b\u7684\u6ce8\u91ca\u65b9\u5f0f\n/**\n*\n*/", "url": "https://github.com/seata/seata/pull/3374#discussion_r549130038", "createdAt": "2020-12-27T16:05:54Z", "author": {"login": "caohdgege"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec.mysql;\n+\n+import com.google.common.base.Joiner;\n+import io.seata.common.exception.NotSupportYetException;\n+import io.seata.common.loader.LoadLevel;\n+import io.seata.common.loader.Scope;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.IOUtil;\n+import io.seata.common.util.StringUtils;\n+import io.seata.rm.datasource.ConnectionProxy;\n+import io.seata.rm.datasource.PreparedStatementProxy;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.StatementCallback;\n+import io.seata.rm.datasource.sql.struct.ColumnMeta;\n+import io.seata.rm.datasource.sql.struct.Field;\n+import io.seata.rm.datasource.sql.struct.Row;\n+import io.seata.rm.datasource.sql.struct.TableMeta;\n+import io.seata.rm.datasource.sql.struct.TableRecords;\n+import io.seata.rm.datasource.undo.SQLUndoLog;\n+import io.seata.sqlparser.SQLInsertRecognizer;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.SQLType;\n+import io.seata.sqlparser.struct.Defaultable;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+\n+/**\n+ * @version: 1.00.00\n+ * @description:\n+ * @author: yangyicong\n+ * @date: 2020-11-26 09:06\n+ */\n+@LoadLevel(name = JdbcConstants.MYSQL, scope = Scope.PROTOTYPE)\n+public class MySQLInsertOrUpdateExecutor extends MySQLInsertExecutor implements Defaultable {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MySQLInsertOrUpdateExecutor.class);\n+\n+    //is updated or not", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "326a058fafc46d70462fd25dd10207ec511f1b80"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1MzY4NjUxOnYy", "diffSide": "RIGHT", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yN1QxNjowNzowMFrOILsP0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yN1QxNjowNzowMFrOILsP0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTEzMDE5Mg==", "bodyText": "\u8fd9\u4e2a\u65b9\u6cd5\u540d\u80fd\u4e0d\u80fd\u4f18\u5316\u4e00\u4e0b\uff1f", "url": "https://github.com/seata/seata/pull/3374#discussion_r549130192", "createdAt": "2020-12-27T16:07:00Z", "author": {"login": "caohdgege"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec.mysql;\n+\n+import com.google.common.base.Joiner;\n+import io.seata.common.exception.NotSupportYetException;\n+import io.seata.common.loader.LoadLevel;\n+import io.seata.common.loader.Scope;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.IOUtil;\n+import io.seata.common.util.StringUtils;\n+import io.seata.rm.datasource.ConnectionProxy;\n+import io.seata.rm.datasource.PreparedStatementProxy;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.StatementCallback;\n+import io.seata.rm.datasource.sql.struct.ColumnMeta;\n+import io.seata.rm.datasource.sql.struct.Field;\n+import io.seata.rm.datasource.sql.struct.Row;\n+import io.seata.rm.datasource.sql.struct.TableMeta;\n+import io.seata.rm.datasource.sql.struct.TableRecords;\n+import io.seata.rm.datasource.undo.SQLUndoLog;\n+import io.seata.sqlparser.SQLInsertRecognizer;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.SQLType;\n+import io.seata.sqlparser.struct.Defaultable;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+\n+/**\n+ * @version: 1.00.00\n+ * @description:\n+ * @author: yangyicong\n+ * @date: 2020-11-26 09:06\n+ */\n+@LoadLevel(name = JdbcConstants.MYSQL, scope = Scope.PROTOTYPE)\n+public class MySQLInsertOrUpdateExecutor extends MySQLInsertExecutor implements Defaultable {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MySQLInsertOrUpdateExecutor.class);\n+\n+    //is updated or not\n+    private boolean isUpdateFlag = false;\n+\n+    //before image sql and after image sql,condition is unique index\n+    private String selectSQL;\n+\n+    //the params of selectSQL, value is the unique index\n+    private ArrayList<List<Object>> paramAppenderList;\n+\n+    //key is unique index name, value is unique index\n+    private Map<String, List<String>> beforeUniqueIndexMap = new HashMap<>();\n+\n+    public MySQLInsertOrUpdateExecutor(StatementProxy statementProxy, StatementCallback statementCallback, SQLRecognizer sqlRecognizer) {\n+        super(statementProxy, statementCallback, sqlRecognizer);\n+    }\n+\n+    /**\n+     * Execute auto commit false t.\n+     *\n+     * @param args the args\n+     * @return the t\n+     * @throws Exception the exception\n+     */\n+    @Override\n+    protected Object executeAutoCommitFalse(Object[] args) throws Exception {\n+        if (!JdbcConstants.MYSQL.equalsIgnoreCase(getDbType()) && getTableMeta().getPrimaryKeyOnlyName().size() > 1) {\n+            throw new NotSupportYetException(\"multi pk only support mysql!\");\n+        }\n+        TableRecords beforeImage = beforeImage();\n+        if (CollectionUtils.isNotEmpty(beforeImage.getRows())) {\n+            isUpdateFlag = true;\n+        } else {\n+            beforeImage = TableRecords.empty(getTableMeta());\n+        }\n+        Object result = statementCallback.execute(statementProxy.getTargetStatement(), args);\n+        TableRecords afterImage = afterImage(beforeImage);\n+        prepareUndoLog2(beforeImage, afterImage);\n+        return result;\n+    }\n+\n+    /**\n+     * prepare undo log.\n+     *\n+     * @param beforeImage the before image\n+     * @param afterImage  the after image\n+     * @throws SQLException the sql exception\n+     */\n+    protected void prepareUndoLog2(TableRecords beforeImage, TableRecords afterImage) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "326a058fafc46d70462fd25dd10207ec511f1b80"}, "originalPosition": 110}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1MzY5MDk1OnYy", "diffSide": "RIGHT", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yN1QxNjoxMjozMlrOILsR5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOFQxNDoxMDozOFrOIL6V0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTEzMDcyNA==", "bodyText": "\u8fd9\u91cc\u4e3a\u4ec0\u4e48\u662f\u4e2a\u6570\u7ec4\u6765\u7684\uff1f", "url": "https://github.com/seata/seata/pull/3374#discussion_r549130724", "createdAt": "2020-12-27T16:12:32Z", "author": {"login": "caohdgege"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec.mysql;\n+\n+import com.google.common.base.Joiner;\n+import io.seata.common.exception.NotSupportYetException;\n+import io.seata.common.loader.LoadLevel;\n+import io.seata.common.loader.Scope;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.IOUtil;\n+import io.seata.common.util.StringUtils;\n+import io.seata.rm.datasource.ConnectionProxy;\n+import io.seata.rm.datasource.PreparedStatementProxy;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.StatementCallback;\n+import io.seata.rm.datasource.sql.struct.ColumnMeta;\n+import io.seata.rm.datasource.sql.struct.Field;\n+import io.seata.rm.datasource.sql.struct.Row;\n+import io.seata.rm.datasource.sql.struct.TableMeta;\n+import io.seata.rm.datasource.sql.struct.TableRecords;\n+import io.seata.rm.datasource.undo.SQLUndoLog;\n+import io.seata.sqlparser.SQLInsertRecognizer;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.SQLType;\n+import io.seata.sqlparser.struct.Defaultable;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+\n+/**\n+ * @version: 1.00.00\n+ * @description:\n+ * @author: yangyicong\n+ * @date: 2020-11-26 09:06\n+ */\n+@LoadLevel(name = JdbcConstants.MYSQL, scope = Scope.PROTOTYPE)\n+public class MySQLInsertOrUpdateExecutor extends MySQLInsertExecutor implements Defaultable {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MySQLInsertOrUpdateExecutor.class);\n+\n+    //is updated or not\n+    private boolean isUpdateFlag = false;\n+\n+    //before image sql and after image sql,condition is unique index\n+    private String selectSQL;\n+\n+    //the params of selectSQL, value is the unique index\n+    private ArrayList<List<Object>> paramAppenderList;\n+\n+    //key is unique index name, value is unique index\n+    private Map<String, List<String>> beforeUniqueIndexMap = new HashMap<>();\n+\n+    public MySQLInsertOrUpdateExecutor(StatementProxy statementProxy, StatementCallback statementCallback, SQLRecognizer sqlRecognizer) {\n+        super(statementProxy, statementCallback, sqlRecognizer);\n+    }\n+\n+    /**\n+     * Execute auto commit false t.\n+     *\n+     * @param args the args\n+     * @return the t\n+     * @throws Exception the exception\n+     */\n+    @Override\n+    protected Object executeAutoCommitFalse(Object[] args) throws Exception {\n+        if (!JdbcConstants.MYSQL.equalsIgnoreCase(getDbType()) && getTableMeta().getPrimaryKeyOnlyName().size() > 1) {\n+            throw new NotSupportYetException(\"multi pk only support mysql!\");\n+        }\n+        TableRecords beforeImage = beforeImage();\n+        if (CollectionUtils.isNotEmpty(beforeImage.getRows())) {\n+            isUpdateFlag = true;\n+        } else {\n+            beforeImage = TableRecords.empty(getTableMeta());\n+        }\n+        Object result = statementCallback.execute(statementProxy.getTargetStatement(), args);\n+        TableRecords afterImage = afterImage(beforeImage);\n+        prepareUndoLog2(beforeImage, afterImage);\n+        return result;\n+    }\n+\n+    /**\n+     * prepare undo log.\n+     *\n+     * @param beforeImage the before image\n+     * @param afterImage  the after image\n+     * @throws SQLException the sql exception\n+     */\n+    protected void prepareUndoLog2(TableRecords beforeImage, TableRecords afterImage) {\n+        if (beforeImage.getRows().isEmpty() && afterImage.getRows().isEmpty()) {\n+            return;\n+        }\n+        ConnectionProxy connectionProxy = statementProxy.getConnectionProxy();\n+        TableRecords lockKeyRecords = sqlRecognizer.getSQLType() == SQLType.DELETE ? beforeImage : afterImage;\n+        String lockKeys = buildLockKey(lockKeyRecords);\n+        connectionProxy.appendLockKey(lockKeys);\n+        buildUndoItemAll(connectionProxy,beforeImage, afterImage);\n+    }\n+\n+    /**\n+     * build a SQLUndoLog\n+     *\n+     * @param beforeImage the before image\n+     * @param afterImage  the after image\n+     * @return sql undo log\n+     */\n+    protected void buildUndoItemAll(ConnectionProxy connectionProxy, TableRecords beforeImage, TableRecords afterImage) {\n+        if (!isUpdateFlag) {\n+            SQLUndoLog sqlUndoLog = buildUndoItem(TableRecords.empty(getTableMeta()), afterImage);\n+            connectionProxy.appendUndoLog(sqlUndoLog);\n+            return;\n+        }\n+        List<Row> beforeImageRows = beforeImage.getRows();\n+        for (Row r : beforeImageRows) {\n+            getTableMeta().getAllIndexes().forEach((k, v) -> {\n+                if (!\"PRIMARY\".equals(k.toUpperCase()) && !v.isNonUnique()) {\n+                    StringBuilder everyRowIndex = new StringBuilder();\n+                    v.getValues().forEach(m -> {\n+                        for (Field f : r.getFields()) {\n+                            if (m.getColumnName().equals(f.getName())) {\n+                                everyRowIndex.append(f.getValue());\n+                            }\n+                        }\n+                    });\n+                    List<String> indexList = beforeUniqueIndexMap.get(k.toUpperCase());\n+                    if (CollectionUtils.isEmpty(indexList)) {\n+                        indexList = new ArrayList<>();\n+                    }\n+                    indexList.add(everyRowIndex.toString());\n+                    beforeUniqueIndexMap.put(k.toUpperCase(), indexList);\n+                }\n+            });\n+        }\n+        List<Row> insertRows = new ArrayList<>();\n+        List<Row> updateRows = new ArrayList<>();\n+        List<Row> afterImageRows = afterImage.getRows();\n+        for (Row r : afterImageRows) {\n+            Boolean[] isUpdateRows = {false};", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "326a058fafc46d70462fd25dd10207ec511f1b80"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTM1NjgyMA==", "bodyText": "\u8fd9\u662f\u4e00\u4e2aflag, \u904d\u5386\u540e\u7f6e\u955c\u50cf\u91cc\u7684\u6bcf\u6761\u6570\u636e\uff0c\u5982\u679c\u8be5\u6761\u6570\u636e\u7684\u552f\u4e00\u7d22\u5f15\u5728\u524d\u7f6e\u955c\u50cf\u5df2\u7ecf\u5b58\u5728\uff0c\u5219\u6807\u8bb0\u6210true\u3002\u540e\u9762\u6839\u636e\u8fd9\u4e2a\u503c\u5224\u65ad\u662finsertUndolog\uff0c\u8fd8\u662fupdateUndolog\u3002\n\u6211\u5728\u5916\u9762\u58f0\u660eboolean\uff0csteam\u91cc\u9762\u4e0d\u80fd\u7528\uff0c\u6240\u4ee5\u7528\u6570\u7ec4\u3002\u5982\u679c\u7528\u6570\u7ec4\u4e0d\u597d\uff0c\u6211\u6539\u6210AtomicBoolean", "url": "https://github.com/seata/seata/pull/3374#discussion_r549356820", "createdAt": "2020-12-28T13:57:02Z", "author": {"login": "huan415"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec.mysql;\n+\n+import com.google.common.base.Joiner;\n+import io.seata.common.exception.NotSupportYetException;\n+import io.seata.common.loader.LoadLevel;\n+import io.seata.common.loader.Scope;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.IOUtil;\n+import io.seata.common.util.StringUtils;\n+import io.seata.rm.datasource.ConnectionProxy;\n+import io.seata.rm.datasource.PreparedStatementProxy;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.StatementCallback;\n+import io.seata.rm.datasource.sql.struct.ColumnMeta;\n+import io.seata.rm.datasource.sql.struct.Field;\n+import io.seata.rm.datasource.sql.struct.Row;\n+import io.seata.rm.datasource.sql.struct.TableMeta;\n+import io.seata.rm.datasource.sql.struct.TableRecords;\n+import io.seata.rm.datasource.undo.SQLUndoLog;\n+import io.seata.sqlparser.SQLInsertRecognizer;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.SQLType;\n+import io.seata.sqlparser.struct.Defaultable;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+\n+/**\n+ * @version: 1.00.00\n+ * @description:\n+ * @author: yangyicong\n+ * @date: 2020-11-26 09:06\n+ */\n+@LoadLevel(name = JdbcConstants.MYSQL, scope = Scope.PROTOTYPE)\n+public class MySQLInsertOrUpdateExecutor extends MySQLInsertExecutor implements Defaultable {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MySQLInsertOrUpdateExecutor.class);\n+\n+    //is updated or not\n+    private boolean isUpdateFlag = false;\n+\n+    //before image sql and after image sql,condition is unique index\n+    private String selectSQL;\n+\n+    //the params of selectSQL, value is the unique index\n+    private ArrayList<List<Object>> paramAppenderList;\n+\n+    //key is unique index name, value is unique index\n+    private Map<String, List<String>> beforeUniqueIndexMap = new HashMap<>();\n+\n+    public MySQLInsertOrUpdateExecutor(StatementProxy statementProxy, StatementCallback statementCallback, SQLRecognizer sqlRecognizer) {\n+        super(statementProxy, statementCallback, sqlRecognizer);\n+    }\n+\n+    /**\n+     * Execute auto commit false t.\n+     *\n+     * @param args the args\n+     * @return the t\n+     * @throws Exception the exception\n+     */\n+    @Override\n+    protected Object executeAutoCommitFalse(Object[] args) throws Exception {\n+        if (!JdbcConstants.MYSQL.equalsIgnoreCase(getDbType()) && getTableMeta().getPrimaryKeyOnlyName().size() > 1) {\n+            throw new NotSupportYetException(\"multi pk only support mysql!\");\n+        }\n+        TableRecords beforeImage = beforeImage();\n+        if (CollectionUtils.isNotEmpty(beforeImage.getRows())) {\n+            isUpdateFlag = true;\n+        } else {\n+            beforeImage = TableRecords.empty(getTableMeta());\n+        }\n+        Object result = statementCallback.execute(statementProxy.getTargetStatement(), args);\n+        TableRecords afterImage = afterImage(beforeImage);\n+        prepareUndoLog2(beforeImage, afterImage);\n+        return result;\n+    }\n+\n+    /**\n+     * prepare undo log.\n+     *\n+     * @param beforeImage the before image\n+     * @param afterImage  the after image\n+     * @throws SQLException the sql exception\n+     */\n+    protected void prepareUndoLog2(TableRecords beforeImage, TableRecords afterImage) {\n+        if (beforeImage.getRows().isEmpty() && afterImage.getRows().isEmpty()) {\n+            return;\n+        }\n+        ConnectionProxy connectionProxy = statementProxy.getConnectionProxy();\n+        TableRecords lockKeyRecords = sqlRecognizer.getSQLType() == SQLType.DELETE ? beforeImage : afterImage;\n+        String lockKeys = buildLockKey(lockKeyRecords);\n+        connectionProxy.appendLockKey(lockKeys);\n+        buildUndoItemAll(connectionProxy,beforeImage, afterImage);\n+    }\n+\n+    /**\n+     * build a SQLUndoLog\n+     *\n+     * @param beforeImage the before image\n+     * @param afterImage  the after image\n+     * @return sql undo log\n+     */\n+    protected void buildUndoItemAll(ConnectionProxy connectionProxy, TableRecords beforeImage, TableRecords afterImage) {\n+        if (!isUpdateFlag) {\n+            SQLUndoLog sqlUndoLog = buildUndoItem(TableRecords.empty(getTableMeta()), afterImage);\n+            connectionProxy.appendUndoLog(sqlUndoLog);\n+            return;\n+        }\n+        List<Row> beforeImageRows = beforeImage.getRows();\n+        for (Row r : beforeImageRows) {\n+            getTableMeta().getAllIndexes().forEach((k, v) -> {\n+                if (!\"PRIMARY\".equals(k.toUpperCase()) && !v.isNonUnique()) {\n+                    StringBuilder everyRowIndex = new StringBuilder();\n+                    v.getValues().forEach(m -> {\n+                        for (Field f : r.getFields()) {\n+                            if (m.getColumnName().equals(f.getName())) {\n+                                everyRowIndex.append(f.getValue());\n+                            }\n+                        }\n+                    });\n+                    List<String> indexList = beforeUniqueIndexMap.get(k.toUpperCase());\n+                    if (CollectionUtils.isEmpty(indexList)) {\n+                        indexList = new ArrayList<>();\n+                    }\n+                    indexList.add(everyRowIndex.toString());\n+                    beforeUniqueIndexMap.put(k.toUpperCase(), indexList);\n+                }\n+            });\n+        }\n+        List<Row> insertRows = new ArrayList<>();\n+        List<Row> updateRows = new ArrayList<>();\n+        List<Row> afterImageRows = afterImage.getRows();\n+        for (Row r : afterImageRows) {\n+            Boolean[] isUpdateRows = {false};", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTEzMDcyNA=="}, "originalCommit": {"oid": "326a058fafc46d70462fd25dd10207ec511f1b80"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTM2MTEwNg==", "bodyText": "\u8fd9\u91cc\u7684\u8bdd\uff0c\u4f60\u5176\u5b9e\u5c31\u662f\u9700\u8981\u4e00\u4e2a\u5f15\u7528\u7c7b\u578b\uff0c\u7136\u540e\u8ba9\u4ed6\u53ef\u4ee5\u5728stream\u91cc\u9762\u4f7f\u7528\u5bf9\u5427\uff1f\u6709\u6ca1\u6709\u4e00\u4e9b\u66f4\u4f18\u96c5\u7684\u4f7f\u7528\u65b9\u5f0f\uff1f", "url": "https://github.com/seata/seata/pull/3374#discussion_r549361106", "createdAt": "2020-12-28T14:10:38Z", "author": {"login": "caohdgege"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec.mysql;\n+\n+import com.google.common.base.Joiner;\n+import io.seata.common.exception.NotSupportYetException;\n+import io.seata.common.loader.LoadLevel;\n+import io.seata.common.loader.Scope;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.IOUtil;\n+import io.seata.common.util.StringUtils;\n+import io.seata.rm.datasource.ConnectionProxy;\n+import io.seata.rm.datasource.PreparedStatementProxy;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.StatementCallback;\n+import io.seata.rm.datasource.sql.struct.ColumnMeta;\n+import io.seata.rm.datasource.sql.struct.Field;\n+import io.seata.rm.datasource.sql.struct.Row;\n+import io.seata.rm.datasource.sql.struct.TableMeta;\n+import io.seata.rm.datasource.sql.struct.TableRecords;\n+import io.seata.rm.datasource.undo.SQLUndoLog;\n+import io.seata.sqlparser.SQLInsertRecognizer;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.SQLType;\n+import io.seata.sqlparser.struct.Defaultable;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+\n+/**\n+ * @version: 1.00.00\n+ * @description:\n+ * @author: yangyicong\n+ * @date: 2020-11-26 09:06\n+ */\n+@LoadLevel(name = JdbcConstants.MYSQL, scope = Scope.PROTOTYPE)\n+public class MySQLInsertOrUpdateExecutor extends MySQLInsertExecutor implements Defaultable {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MySQLInsertOrUpdateExecutor.class);\n+\n+    //is updated or not\n+    private boolean isUpdateFlag = false;\n+\n+    //before image sql and after image sql,condition is unique index\n+    private String selectSQL;\n+\n+    //the params of selectSQL, value is the unique index\n+    private ArrayList<List<Object>> paramAppenderList;\n+\n+    //key is unique index name, value is unique index\n+    private Map<String, List<String>> beforeUniqueIndexMap = new HashMap<>();\n+\n+    public MySQLInsertOrUpdateExecutor(StatementProxy statementProxy, StatementCallback statementCallback, SQLRecognizer sqlRecognizer) {\n+        super(statementProxy, statementCallback, sqlRecognizer);\n+    }\n+\n+    /**\n+     * Execute auto commit false t.\n+     *\n+     * @param args the args\n+     * @return the t\n+     * @throws Exception the exception\n+     */\n+    @Override\n+    protected Object executeAutoCommitFalse(Object[] args) throws Exception {\n+        if (!JdbcConstants.MYSQL.equalsIgnoreCase(getDbType()) && getTableMeta().getPrimaryKeyOnlyName().size() > 1) {\n+            throw new NotSupportYetException(\"multi pk only support mysql!\");\n+        }\n+        TableRecords beforeImage = beforeImage();\n+        if (CollectionUtils.isNotEmpty(beforeImage.getRows())) {\n+            isUpdateFlag = true;\n+        } else {\n+            beforeImage = TableRecords.empty(getTableMeta());\n+        }\n+        Object result = statementCallback.execute(statementProxy.getTargetStatement(), args);\n+        TableRecords afterImage = afterImage(beforeImage);\n+        prepareUndoLog2(beforeImage, afterImage);\n+        return result;\n+    }\n+\n+    /**\n+     * prepare undo log.\n+     *\n+     * @param beforeImage the before image\n+     * @param afterImage  the after image\n+     * @throws SQLException the sql exception\n+     */\n+    protected void prepareUndoLog2(TableRecords beforeImage, TableRecords afterImage) {\n+        if (beforeImage.getRows().isEmpty() && afterImage.getRows().isEmpty()) {\n+            return;\n+        }\n+        ConnectionProxy connectionProxy = statementProxy.getConnectionProxy();\n+        TableRecords lockKeyRecords = sqlRecognizer.getSQLType() == SQLType.DELETE ? beforeImage : afterImage;\n+        String lockKeys = buildLockKey(lockKeyRecords);\n+        connectionProxy.appendLockKey(lockKeys);\n+        buildUndoItemAll(connectionProxy,beforeImage, afterImage);\n+    }\n+\n+    /**\n+     * build a SQLUndoLog\n+     *\n+     * @param beforeImage the before image\n+     * @param afterImage  the after image\n+     * @return sql undo log\n+     */\n+    protected void buildUndoItemAll(ConnectionProxy connectionProxy, TableRecords beforeImage, TableRecords afterImage) {\n+        if (!isUpdateFlag) {\n+            SQLUndoLog sqlUndoLog = buildUndoItem(TableRecords.empty(getTableMeta()), afterImage);\n+            connectionProxy.appendUndoLog(sqlUndoLog);\n+            return;\n+        }\n+        List<Row> beforeImageRows = beforeImage.getRows();\n+        for (Row r : beforeImageRows) {\n+            getTableMeta().getAllIndexes().forEach((k, v) -> {\n+                if (!\"PRIMARY\".equals(k.toUpperCase()) && !v.isNonUnique()) {\n+                    StringBuilder everyRowIndex = new StringBuilder();\n+                    v.getValues().forEach(m -> {\n+                        for (Field f : r.getFields()) {\n+                            if (m.getColumnName().equals(f.getName())) {\n+                                everyRowIndex.append(f.getValue());\n+                            }\n+                        }\n+                    });\n+                    List<String> indexList = beforeUniqueIndexMap.get(k.toUpperCase());\n+                    if (CollectionUtils.isEmpty(indexList)) {\n+                        indexList = new ArrayList<>();\n+                    }\n+                    indexList.add(everyRowIndex.toString());\n+                    beforeUniqueIndexMap.put(k.toUpperCase(), indexList);\n+                }\n+            });\n+        }\n+        List<Row> insertRows = new ArrayList<>();\n+        List<Row> updateRows = new ArrayList<>();\n+        List<Row> afterImageRows = afterImage.getRows();\n+        for (Row r : afterImageRows) {\n+            Boolean[] isUpdateRows = {false};", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTEzMDcyNA=="}, "originalCommit": {"oid": "326a058fafc46d70462fd25dd10207ec511f1b80"}, "originalPosition": 159}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4MjY5ODM2OnYy", "diffSide": "RIGHT", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxMzozNjozOVrOIPsnLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxMzozNjozOVrOIPsnLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMzMDQ3Nw==", "bodyText": "\u4ec5\u7559@author\u5373\u53ef", "url": "https://github.com/seata/seata/pull/3374#discussion_r553330477", "createdAt": "2021-01-07T13:36:39Z", "author": {"login": "a364176773"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "diffHunk": "@@ -0,0 +1,376 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec.mysql;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import com.google.common.base.Joiner;\n+import io.seata.common.exception.NotSupportYetException;\n+import io.seata.common.loader.LoadLevel;\n+import io.seata.common.loader.Scope;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.IOUtil;\n+import io.seata.common.util.StringUtils;\n+import io.seata.rm.datasource.ConnectionProxy;\n+import io.seata.rm.datasource.PreparedStatementProxy;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.StatementCallback;\n+import io.seata.rm.datasource.sql.struct.ColumnMeta;\n+import io.seata.rm.datasource.sql.struct.Field;\n+import io.seata.rm.datasource.sql.struct.Row;\n+import io.seata.rm.datasource.sql.struct.TableMeta;\n+import io.seata.rm.datasource.sql.struct.TableRecords;\n+import io.seata.rm.datasource.undo.SQLUndoLog;\n+import io.seata.sqlparser.SQLInsertRecognizer;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.SQLType;\n+import io.seata.sqlparser.struct.Defaultable;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * @version: 1.00.00\n+ * @description:\n+ * @author: yangyicong\n+ * @date: 2020-11-26 09:06", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32b0318010e39dfbaba18b6379cf7be0214e3ada"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4MzA3ODU5OnYy", "diffSide": "RIGHT", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxNToxNDowOFrOIPwOOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMFQwNTo0MDo0MlrOIQ06YQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzM4OTYyNg==", "bodyText": "\u8fd9\u91cc\u76f4\u63a5\u7528afterImage\u5c31\u597d\u4e86\u5427", "url": "https://github.com/seata/seata/pull/3374#discussion_r553389626", "createdAt": "2021-01-07T15:14:08Z", "author": {"login": "caohdgege"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "diffHunk": "@@ -0,0 +1,376 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec.mysql;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import com.google.common.base.Joiner;\n+import io.seata.common.exception.NotSupportYetException;\n+import io.seata.common.loader.LoadLevel;\n+import io.seata.common.loader.Scope;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.IOUtil;\n+import io.seata.common.util.StringUtils;\n+import io.seata.rm.datasource.ConnectionProxy;\n+import io.seata.rm.datasource.PreparedStatementProxy;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.StatementCallback;\n+import io.seata.rm.datasource.sql.struct.ColumnMeta;\n+import io.seata.rm.datasource.sql.struct.Field;\n+import io.seata.rm.datasource.sql.struct.Row;\n+import io.seata.rm.datasource.sql.struct.TableMeta;\n+import io.seata.rm.datasource.sql.struct.TableRecords;\n+import io.seata.rm.datasource.undo.SQLUndoLog;\n+import io.seata.sqlparser.SQLInsertRecognizer;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.SQLType;\n+import io.seata.sqlparser.struct.Defaultable;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * @version: 1.00.00\n+ * @description:\n+ * @author: yangyicong\n+ * @date: 2020-11-26 09:06\n+ */\n+@LoadLevel(name = JdbcConstants.MYSQL, scope = Scope.PROTOTYPE)\n+public class MySQLInsertOrUpdateExecutor extends MySQLInsertExecutor implements Defaultable {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MySQLInsertOrUpdateExecutor.class);\n+\n+    /**\n+     * is updated or not\n+     */\n+    private boolean isUpdateFlag = false;\n+\n+    /**\n+     * before image sql and after image sql,condition is unique index\n+     */\n+    private String selectSQL;\n+\n+    /**\n+     * the params of selectSQL, value is the unique index\n+     */\n+    private ArrayList<List<Object>> paramAppenderList;\n+\n+    /**\n+     * key is unique index name, value is unique index\n+     */\n+    private Map<String, List<String>> beforeUniqueIndexMap = new HashMap<>();\n+\n+    public MySQLInsertOrUpdateExecutor(StatementProxy statementProxy, StatementCallback statementCallback, SQLRecognizer sqlRecognizer) {\n+        super(statementProxy, statementCallback, sqlRecognizer);\n+    }\n+\n+    /**\n+     * Execute auto commit false t.\n+     *\n+     * @param args the args\n+     * @return the t\n+     * @throws Exception the exception\n+     */\n+    @Override\n+    protected Object executeAutoCommitFalse(Object[] args) throws Exception {\n+        if (!JdbcConstants.MYSQL.equalsIgnoreCase(getDbType()) && getTableMeta().getPrimaryKeyOnlyName().size() > 1) {\n+            throw new NotSupportYetException(\"multi pk only support mysql!\");\n+        }\n+        TableRecords beforeImage = beforeImage();\n+        if (CollectionUtils.isNotEmpty(beforeImage.getRows())) {\n+            isUpdateFlag = true;\n+        } else {\n+            beforeImage = TableRecords.empty(getTableMeta());\n+        }\n+        Object result = statementCallback.execute(statementProxy.getTargetStatement(), args);\n+        TableRecords afterImage = afterImage(beforeImage);\n+        prepareUndoLogAll(beforeImage, afterImage);\n+        return result;\n+    }\n+\n+    /**\n+     * prepare undo log.\n+     *\n+     * @param beforeImage the before image\n+     * @param afterImage  the after image\n+     * @throws SQLException the sql exception\n+     */\n+    protected void prepareUndoLogAll(TableRecords beforeImage, TableRecords afterImage) {\n+        if (beforeImage.getRows().isEmpty() && afterImage.getRows().isEmpty()) {\n+            return;\n+        }\n+        ConnectionProxy connectionProxy = statementProxy.getConnectionProxy();\n+        TableRecords lockKeyRecords = sqlRecognizer.getSQLType() == SQLType.DELETE ? beforeImage : afterImage;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32b0318010e39dfbaba18b6379cf7be0214e3ada"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDUxNTA0MQ==", "bodyText": "\u8fd9\u8fb9\u662f\u53ef\u4ee5\u76f4\u63a5\u8fd4\u56deafterImage", "url": "https://github.com/seata/seata/pull/3374#discussion_r554515041", "createdAt": "2021-01-10T05:40:42Z", "author": {"login": "huan415"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "diffHunk": "@@ -0,0 +1,376 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec.mysql;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import com.google.common.base.Joiner;\n+import io.seata.common.exception.NotSupportYetException;\n+import io.seata.common.loader.LoadLevel;\n+import io.seata.common.loader.Scope;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.IOUtil;\n+import io.seata.common.util.StringUtils;\n+import io.seata.rm.datasource.ConnectionProxy;\n+import io.seata.rm.datasource.PreparedStatementProxy;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.StatementCallback;\n+import io.seata.rm.datasource.sql.struct.ColumnMeta;\n+import io.seata.rm.datasource.sql.struct.Field;\n+import io.seata.rm.datasource.sql.struct.Row;\n+import io.seata.rm.datasource.sql.struct.TableMeta;\n+import io.seata.rm.datasource.sql.struct.TableRecords;\n+import io.seata.rm.datasource.undo.SQLUndoLog;\n+import io.seata.sqlparser.SQLInsertRecognizer;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.SQLType;\n+import io.seata.sqlparser.struct.Defaultable;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * @version: 1.00.00\n+ * @description:\n+ * @author: yangyicong\n+ * @date: 2020-11-26 09:06\n+ */\n+@LoadLevel(name = JdbcConstants.MYSQL, scope = Scope.PROTOTYPE)\n+public class MySQLInsertOrUpdateExecutor extends MySQLInsertExecutor implements Defaultable {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MySQLInsertOrUpdateExecutor.class);\n+\n+    /**\n+     * is updated or not\n+     */\n+    private boolean isUpdateFlag = false;\n+\n+    /**\n+     * before image sql and after image sql,condition is unique index\n+     */\n+    private String selectSQL;\n+\n+    /**\n+     * the params of selectSQL, value is the unique index\n+     */\n+    private ArrayList<List<Object>> paramAppenderList;\n+\n+    /**\n+     * key is unique index name, value is unique index\n+     */\n+    private Map<String, List<String>> beforeUniqueIndexMap = new HashMap<>();\n+\n+    public MySQLInsertOrUpdateExecutor(StatementProxy statementProxy, StatementCallback statementCallback, SQLRecognizer sqlRecognizer) {\n+        super(statementProxy, statementCallback, sqlRecognizer);\n+    }\n+\n+    /**\n+     * Execute auto commit false t.\n+     *\n+     * @param args the args\n+     * @return the t\n+     * @throws Exception the exception\n+     */\n+    @Override\n+    protected Object executeAutoCommitFalse(Object[] args) throws Exception {\n+        if (!JdbcConstants.MYSQL.equalsIgnoreCase(getDbType()) && getTableMeta().getPrimaryKeyOnlyName().size() > 1) {\n+            throw new NotSupportYetException(\"multi pk only support mysql!\");\n+        }\n+        TableRecords beforeImage = beforeImage();\n+        if (CollectionUtils.isNotEmpty(beforeImage.getRows())) {\n+            isUpdateFlag = true;\n+        } else {\n+            beforeImage = TableRecords.empty(getTableMeta());\n+        }\n+        Object result = statementCallback.execute(statementProxy.getTargetStatement(), args);\n+        TableRecords afterImage = afterImage(beforeImage);\n+        prepareUndoLogAll(beforeImage, afterImage);\n+        return result;\n+    }\n+\n+    /**\n+     * prepare undo log.\n+     *\n+     * @param beforeImage the before image\n+     * @param afterImage  the after image\n+     * @throws SQLException the sql exception\n+     */\n+    protected void prepareUndoLogAll(TableRecords beforeImage, TableRecords afterImage) {\n+        if (beforeImage.getRows().isEmpty() && afterImage.getRows().isEmpty()) {\n+            return;\n+        }\n+        ConnectionProxy connectionProxy = statementProxy.getConnectionProxy();\n+        TableRecords lockKeyRecords = sqlRecognizer.getSQLType() == SQLType.DELETE ? beforeImage : afterImage;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzM4OTYyNg=="}, "originalCommit": {"oid": "32b0318010e39dfbaba18b6379cf7be0214e3ada"}, "originalPosition": 124}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUzMTExNDc3OnYy", "diffSide": "RIGHT", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMFQwODoxNzoxNlrOIWxxlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMFQwODoxNzoxNlrOIWxxlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDc1NTA5Mg==", "bodyText": "imageParamperterMap.computeIfAbsent(m,k->new ArrayList<>())", "url": "https://github.com/seata/seata/pull/3374#discussion_r560755092", "createdAt": "2021-01-20T08:17:16Z", "author": {"login": "a364176773"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "diffHunk": "@@ -0,0 +1,381 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec.mysql;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import com.google.common.base.Joiner;\n+import io.seata.common.exception.NotSupportYetException;\n+import io.seata.common.loader.LoadLevel;\n+import io.seata.common.loader.Scope;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.IOUtil;\n+import io.seata.common.util.StringUtils;\n+import io.seata.rm.datasource.ConnectionProxy;\n+import io.seata.rm.datasource.PreparedStatementProxy;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.StatementCallback;\n+import io.seata.rm.datasource.sql.struct.ColumnMeta;\n+import io.seata.rm.datasource.sql.struct.Field;\n+import io.seata.rm.datasource.sql.struct.Row;\n+import io.seata.rm.datasource.sql.struct.TableMeta;\n+import io.seata.rm.datasource.sql.struct.TableRecords;\n+import io.seata.rm.datasource.undo.SQLUndoLog;\n+import io.seata.sqlparser.SQLInsertRecognizer;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.SQLType;\n+import io.seata.sqlparser.struct.Defaultable;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * @author: yangyicong\n+ */\n+@LoadLevel(name = JdbcConstants.MYSQL, scope = Scope.PROTOTYPE)\n+public class MySQLInsertOrUpdateExecutor extends MySQLInsertExecutor implements Defaultable {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MySQLInsertOrUpdateExecutor.class);\n+\n+    /**\n+     * is updated or not\n+     */\n+    private boolean isUpdateFlag = false;\n+\n+    public String getSelectSQL() {\n+        return selectSQL;\n+    }\n+\n+    /**\n+     * before image sql and after image sql,condition is unique index\n+     */\n+    private String selectSQL;\n+\n+    public ArrayList<List<Object>> getParamAppenderList() {\n+        return paramAppenderList;\n+    }\n+\n+    /**\n+     * the params of selectSQL, value is the unique index\n+     */\n+    private ArrayList<List<Object>> paramAppenderList;\n+\n+    /**\n+     * key is unique index name, value is unique index\n+     */\n+    private Map<String, List<String>> beforeUniqueIndexMap = new HashMap<>();\n+\n+    public MySQLInsertOrUpdateExecutor(StatementProxy statementProxy, StatementCallback statementCallback, SQLRecognizer sqlRecognizer) {\n+        super(statementProxy, statementCallback, sqlRecognizer);\n+    }\n+\n+    /**\n+     * Execute auto commit false t.\n+     *\n+     * @param args the args\n+     * @return the t\n+     * @throws Exception the exception\n+     */\n+    @Override\n+    protected Object executeAutoCommitFalse(Object[] args) throws Exception {\n+        if (!JdbcConstants.MYSQL.equalsIgnoreCase(getDbType()) && getTableMeta().getPrimaryKeyOnlyName().size() > 1) {\n+            throw new NotSupportYetException(\"multi pk only support mysql!\");\n+        }\n+        TableRecords beforeImage = beforeImage();\n+        if (CollectionUtils.isNotEmpty(beforeImage.getRows())) {\n+            isUpdateFlag = true;\n+        } else {\n+            beforeImage = TableRecords.empty(getTableMeta());\n+        }\n+        Object result = statementCallback.execute(statementProxy.getTargetStatement(), args);\n+        TableRecords afterImage = afterImage(beforeImage);\n+        prepareUndoLogAll(beforeImage, afterImage);\n+        return result;\n+    }\n+\n+    /**\n+     * prepare undo log.\n+     *\n+     * @param beforeImage the before image\n+     * @param afterImage  the after image\n+     * @throws SQLException the sql exception\n+     */\n+    protected void prepareUndoLogAll(TableRecords beforeImage, TableRecords afterImage) {\n+        if (beforeImage.getRows().isEmpty() && afterImage.getRows().isEmpty()) {\n+            return;\n+        }\n+        ConnectionProxy connectionProxy = statementProxy.getConnectionProxy();\n+        TableRecords lockKeyRecords = afterImage;\n+        String lockKeys = buildLockKey(lockKeyRecords);\n+        connectionProxy.appendLockKey(lockKeys);\n+        buildUndoItemAll(connectionProxy,beforeImage, afterImage);\n+    }\n+\n+    /**\n+     * build a SQLUndoLog\n+     *\n+     * @param beforeImage the before image\n+     * @param afterImage  the after image\n+     * @return sql undo log\n+     */\n+    protected void buildUndoItemAll(ConnectionProxy connectionProxy, TableRecords beforeImage, TableRecords afterImage) {\n+        if (!isUpdateFlag) {\n+            SQLUndoLog sqlUndoLog = buildUndoItem(TableRecords.empty(getTableMeta()), afterImage);\n+            connectionProxy.appendUndoLog(sqlUndoLog);\n+            return;\n+        }\n+        List<Row> beforeImageRows = beforeImage.getRows();\n+        for (Row r : beforeImageRows) {\n+            getTableMeta().getAllIndexes().forEach((k, v) -> {\n+                if (!\"PRIMARY\".equals(k.toUpperCase()) && !v.isNonUnique()) {\n+                    StringBuilder everyRowIndex = new StringBuilder();\n+                    v.getValues().forEach(m -> {\n+                        for (Field f : r.getFields()) {\n+                            if (m.getColumnName().equals(f.getName())) {\n+                                everyRowIndex.append(f.getValue());\n+                            }\n+                        }\n+                    });\n+                    List<String> indexList = beforeUniqueIndexMap.get(k.toUpperCase());\n+                    if (CollectionUtils.isEmpty(indexList)) {\n+                        indexList = new ArrayList<>();\n+                    }\n+                    indexList.add(everyRowIndex.toString());\n+                    beforeUniqueIndexMap.put(k.toUpperCase(), indexList);\n+                }\n+            });\n+        }\n+        List<Row> insertRows = new ArrayList<>();\n+        List<Row> updateRows = new ArrayList<>();\n+        List<Row> afterImageRows = afterImage.getRows();\n+        for (Row r : afterImageRows) {\n+            AtomicBoolean isUpdateRowsFlag = new AtomicBoolean(false);\n+            getTableMeta().getAllIndexes().forEach((k, v) -> {\n+                if (!\"PRIMARY\".equals(k.toUpperCase()) && !v.isNonUnique()) {\n+                    StringBuilder everyRowIndex = new StringBuilder();\n+                    v.getValues().forEach(m -> {\n+                        for (Field f : r.getFields()) {\n+                            if (m.getColumnName().equals(f.getName())) {\n+                                everyRowIndex.append(f.getValue());\n+                            }\n+                        }\n+                    });\n+                    List<String> indexList = beforeUniqueIndexMap.get(k.toUpperCase());\n+                    if (CollectionUtils.isNotEmpty(indexList)) {\n+                        indexList.forEach(m -> {\n+                            if (m.equals(everyRowIndex.toString())) {\n+                                isUpdateRowsFlag.set(true);\n+                            }\n+                        });\n+                    }\n+                }\n+            });\n+            if (isUpdateRowsFlag.get()) {\n+                updateRows.add(r);\n+            } else {\n+                insertRows.add(r);\n+            }\n+        }\n+        if (CollectionUtils.isNotEmpty(updateRows)) {\n+            TableRecords partAfterImage = new TableRecords(afterImage.getTableMeta());\n+            partAfterImage.setTableName(afterImage.getTableName());\n+            partAfterImage.setRows(updateRows);\n+            connectionProxy.appendUndoLog(buildUndoItem(SQLType.UPDATE, beforeImage, partAfterImage));\n+        }\n+        if (CollectionUtils.isNotEmpty(insertRows)) {\n+            TableRecords partAfterImage = new TableRecords(afterImage.getTableMeta());\n+            partAfterImage.setTableName(afterImage.getTableName());\n+            partAfterImage.setRows(insertRows);\n+            connectionProxy.appendUndoLog(buildUndoItem(TableRecords.empty(getTableMeta()), partAfterImage));\n+        }\n+    }\n+\n+    /**\n+     * build a SQLUndoLog\n+     * @param sqlType\n+     * @param beforeImage\n+     * @param afterImage\n+     * @return\n+     */\n+    protected SQLUndoLog buildUndoItem(SQLType sqlType, TableRecords beforeImage, TableRecords afterImage) {\n+        String tableName = sqlRecognizer.getTableName();\n+        SQLUndoLog sqlUndoLog = new SQLUndoLog();\n+        sqlUndoLog.setSqlType(sqlType);\n+        sqlUndoLog.setTableName(tableName);\n+        sqlUndoLog.setBeforeImage(beforeImage);\n+        sqlUndoLog.setAfterImage(afterImage);\n+        return sqlUndoLog;\n+    }\n+\n+\n+    @Override\n+    protected TableRecords afterImage(TableRecords beforeImage) throws SQLException {\n+        if (isUpdateFlag) {\n+            return buildImage();\n+        } else {\n+            Map<String, List<Object>> pkValues = getPkValues();\n+            return afterImageInsert(pkValues);\n+        }\n+    }\n+\n+    private TableRecords afterImageInsert(Map<String, List<Object>> pkValues) throws SQLException {\n+        TableRecords afterImage = buildTableRecords(pkValues);\n+        if (afterImage == null) {\n+            throw new SQLException(\"Failed to build after-image for insert\");\n+        }\n+        return afterImage;\n+    }\n+\n+    @Override\n+    public TableRecords beforeImage() throws SQLException {\n+        return buildImage();\n+    }\n+\n+    /**\n+     * build before image and after image\n+     * @return\n+     * @throws SQLException\n+     */\n+    protected TableRecords buildImage() throws SQLException {\n+        TableMeta tmeta = getTableMeta();\n+        //after image sql the same of before image\n+        if (StringUtils.isBlank(selectSQL)) {\n+            paramAppenderList = new ArrayList<>();\n+            selectSQL = buildImageSQL(tmeta);\n+        }\n+        return buildTableRecords2(tmeta, selectSQL, paramAppenderList);\n+    }\n+\n+    /**\n+     *  build TableRecords\n+     * @param tableMeta\n+     * @param selectSQL\n+     * @param paramAppenderList\n+     * @return\n+     * @throws SQLException\n+     */\n+    public TableRecords buildTableRecords2(TableMeta tableMeta, String selectSQL, ArrayList<List<Object>> paramAppenderList) throws SQLException {\n+        ResultSet rs = null;\n+        try (PreparedStatement ps = statementProxy.getConnection().prepareStatement(selectSQL)) {\n+            if (CollectionUtils.isNotEmpty(paramAppenderList)) {\n+                for (int i = 0, ts = paramAppenderList.size(); i < ts; i++) {\n+                    List<Object> paramAppender = paramAppenderList.get(i);\n+                    for (int j = 0, ds = paramAppender.size(); j < ds; j++) {\n+                        ps.setObject(i * ds + j + 1, \"NULL\".equals(paramAppender.get(j).toString()) ? null : paramAppender.get(j));\n+                    }\n+                }\n+            }\n+            rs = ps.executeQuery();\n+            return TableRecords.buildRecords(tableMeta, rs);\n+        } finally {\n+            IOUtil.close(rs);\n+        }\n+    }\n+\n+    /**\n+     * build image sql\n+     * @param tableMeta\n+     * @return\n+     */\n+    public String buildImageSQL(TableMeta tableMeta) {\n+        if (CollectionUtils.isEmpty(paramAppenderList)) {\n+            paramAppenderList = new ArrayList<>();\n+        }\n+        SQLInsertRecognizer recognizer = (SQLInsertRecognizer) sqlRecognizer;\n+        int insertNum = recognizer.getInsertParamsValue().size();\n+        Map<String, ArrayList<Object>> imageParamperterMap =  buildImageParamperters(recognizer);\n+        StringBuilder prefix = new StringBuilder(\"SELECT * \");\n+        StringBuilder suffix = new StringBuilder(\" FROM \").append(getFromTableInSQL());\n+        boolean[] isContainWhere = {false};\n+        for (int i = 0; i < insertNum; i++) {\n+            int finalI = i;\n+            List<Object> paramAppenderTempList = new ArrayList<>();\n+            tableMeta.getAllIndexes().forEach((k, v) -> {\n+                if (!v.isNonUnique()) {\n+                    List<String> uniqueList = new ArrayList<>();\n+                    for (ColumnMeta m : v.getValues()) {\n+                        String columnName = m.getColumnName();\n+                        if (imageParamperterMap.get(columnName) == null || imageParamperterMap.get(columnName).get(finalI) == null) {\n+                            continue;\n+                        }\n+                        uniqueList.add(columnName + \" = ? \");\n+                        paramAppenderTempList.add(imageParamperterMap.get(columnName).get(finalI));\n+                    }\n+                    if (isContainWhere[0]) {\n+                        suffix.append(\" OR (\").append(Joiner.on(\" and \").join(uniqueList)).append(\") \");\n+                    } else {\n+                        suffix.append(\" WHERE (\").append(Joiner.on(\" and \").join(uniqueList)).append(\") \");\n+                        isContainWhere[0] = true;\n+                    }\n+                }\n+            });\n+            paramAppenderList.add(paramAppenderTempList);\n+        }\n+        suffix.append(\" FOR UPDATE\");\n+        StringJoiner selectSQLJoin = new StringJoiner(\", \", prefix.toString(), suffix.toString());\n+        return selectSQLJoin.toString();\n+    }\n+\n+    /**\n+     * build sql params\n+     * @param recognizer\n+     * @return\n+     */\n+    public Map<String, ArrayList<Object>> buildImageParamperters(SQLInsertRecognizer recognizer) {\n+        Map<String, ArrayList<Object>> imageParamperterMap = new HashMap<>();\n+        Map<Integer, ArrayList<Object>> parameters = ((PreparedStatementProxy) statementProxy).getParameters();\n+        //  VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)   VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)\n+        List<String> insertParamsList = recognizer.getInsertParamsValue();\n+        List<String> insertColumns = recognizer.getInsertColumns();\n+        int paramsindex = 1;\n+        for (String insertParams : insertParamsList) {\n+            String[] insertParamsArray = insertParams.split(\",\");\n+            for (int i = 0; i < insertColumns.size(); i++) {\n+                String m = insertColumns.get(i);\n+                String params = insertParamsArray[i];\n+                ArrayList<Object> imageListTemp = imageParamperterMap.get(m);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e5b6175b1f891d6253d4aa742687572d6d5442c"}, "originalPosition": 357}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU5Nzg0OTg2OnYy", "diffSide": "RIGHT", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/ExecuteTemplate.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNVQxMjozNzo0MVrOIgfV9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wOVQxMzozNTowNFrOIiWQpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDkzODg2OA==", "bodyText": "else throw new NotSupportYetException ?", "url": "https://github.com/seata/seata/pull/3374#discussion_r570938868", "createdAt": "2021-02-05T12:37:41Z", "author": {"login": "caohdgege"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/ExecuteTemplate.java", "diffHunk": "@@ -98,6 +101,11 @@\n                     case SELECT_FOR_UPDATE:\n                         executor = new SelectForUpdateExecutor<>(statementProxy, statementCallback, sqlRecognizer);\n                         break;\n+                    case INSERT_ON_DUPLICATE_UPDATE:\n+                        if (JdbcConstants.MYSQL.equals(dbType)) {\n+                            executor = new MySQLInsertOrUpdateExecutor(statementProxy,statementCallback,sqlRecognizer);\n+                        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fb31f43da21f8bed23906748688bb7061a9b7ea"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mjg4NzIwNw==", "bodyText": "\u5176\u4ed6\u7684dbType\uff0c\u6211\u662f\u60f3\u5148\u8ba9mysql\u8bd5\u8bd5\uff0c\u5982\u679c\u80fd\u88ab\u4f60\u4eec\u91c7\u7eb3\uff0c\u6211\u540e\u7eed\u4e5f\u60f3\u652f\u6301\u4e00\u4e0b\u5176\u4ed6\u7684", "url": "https://github.com/seata/seata/pull/3374#discussion_r572887207", "createdAt": "2021-02-09T13:35:04Z", "author": {"login": "huan415"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/ExecuteTemplate.java", "diffHunk": "@@ -98,6 +101,11 @@\n                     case SELECT_FOR_UPDATE:\n                         executor = new SelectForUpdateExecutor<>(statementProxy, statementCallback, sqlRecognizer);\n                         break;\n+                    case INSERT_ON_DUPLICATE_UPDATE:\n+                        if (JdbcConstants.MYSQL.equals(dbType)) {\n+                            executor = new MySQLInsertOrUpdateExecutor(statementProxy,statementCallback,sqlRecognizer);\n+                        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDkzODg2OA=="}, "originalCommit": {"oid": "0fb31f43da21f8bed23906748688bb7061a9b7ea"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU5Nzg1MTA4OnYy", "diffSide": "RIGHT", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/ExecuteTemplate.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNVQxMjozODowM1rOIgfWqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wOVQxMzo0MDozNFrOIiWgTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDkzOTA1MA==", "bodyText": "\u8fd9\u91cc\u4e3a\u4ec0\u4e48\u6ce8\u91ca\u6389\u7684\uff1f", "url": "https://github.com/seata/seata/pull/3374#discussion_r570939050", "createdAt": "2021-02-05T12:38:03Z", "author": {"login": "caohdgege"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/ExecuteTemplate.java", "diffHunk": "@@ -98,6 +101,11 @@\n                     case SELECT_FOR_UPDATE:\n                         executor = new SelectForUpdateExecutor<>(statementProxy, statementCallback, sqlRecognizer);\n                         break;\n+                    case INSERT_ON_DUPLICATE_UPDATE:\n+                        if (JdbcConstants.MYSQL.equals(dbType)) {\n+                            executor = new MySQLInsertOrUpdateExecutor(statementProxy,statementCallback,sqlRecognizer);\n+                        }\n+                        //  break;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fb31f43da21f8bed23906748688bb7061a9b7ea"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mjg5MTIxMg==", "bodyText": "\u6ce8\u91ca\u6389\u7684\u539f\u56e0\u662f\uff1a\u5982\u679c\u4e00\u4e2a\u5f88\u6210\u719f\u7684\u9879\u76ee\u63a5\u5165seata\uff0c\u6709\u7528\u5230ON DUPLICATE KEY UPDATE\uff0c\u4f46\u662f\u4ed6\u4eec\u53c8\u4e0d\u77e5\u9053seata\u4e0d\u652f\u6301\u8fd9\u79cdsql.  \u6b64\u65f6\u5982\u679c\u6ca1\u6709\u6d4b\u8bd5\u5230\uff0c\u4e0a\u751f\u4ea7\u73af\u5883\u7684\u8bdd\u4f1a\u51fa\u95ee\u9898\u3002\u6240\u4ee5\u6211\u60f3\u6309\u6b63\u5e38\u7684sql\u6267\u884c\uff08\u6ca1\u6709\u5206\u5e03\u5f0f\u4e8b\u52a1\uff09\u3002\u6240\u4ee5\u6211\u628abreak\u6ce8\u91ca\u6389\uff0c\u4e0d\u5f71\u54cd\u4e1a\u52a1\uff0c\u53ea\u662f\u5206\u5e03\u5f0f\u4e8b\u52a1\u6ca1\u6709\u8d77\u4f5c\u7528", "url": "https://github.com/seata/seata/pull/3374#discussion_r572891212", "createdAt": "2021-02-09T13:40:34Z", "author": {"login": "huan415"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/ExecuteTemplate.java", "diffHunk": "@@ -98,6 +101,11 @@\n                     case SELECT_FOR_UPDATE:\n                         executor = new SelectForUpdateExecutor<>(statementProxy, statementCallback, sqlRecognizer);\n                         break;\n+                    case INSERT_ON_DUPLICATE_UPDATE:\n+                        if (JdbcConstants.MYSQL.equals(dbType)) {\n+                            executor = new MySQLInsertOrUpdateExecutor(statementProxy,statementCallback,sqlRecognizer);\n+                        }\n+                        //  break;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDkzOTA1MA=="}, "originalCommit": {"oid": "0fb31f43da21f8bed23906748688bb7061a9b7ea"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU5Nzg4MTk0OnYy", "diffSide": "RIGHT", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNVQxMjo0Njo0N1rOIgfogQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wOVQxNDoxMTozNVrOIiX9jA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDk0MzYxNw==", "bodyText": "\u8fd9\u91cc\u7684\u67e5\u8be2\u7684\u5b57\u6bb5\uff0c\u662f\u5426\u9700\u8981\u53d7onlyCareUpdateColumns\u8fd9\u4e2a\u53c2\u6570\u7684\u5f71\u54cd\uff1f", "url": "https://github.com/seata/seata/pull/3374#discussion_r570943617", "createdAt": "2021-02-05T12:46:47Z", "author": {"login": "caohdgege"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "diffHunk": "@@ -0,0 +1,375 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec.mysql;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import com.google.common.base.Joiner;\n+import io.seata.common.exception.NotSupportYetException;\n+import io.seata.common.loader.LoadLevel;\n+import io.seata.common.loader.Scope;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.IOUtil;\n+import io.seata.common.util.StringUtils;\n+import io.seata.rm.datasource.ConnectionProxy;\n+import io.seata.rm.datasource.PreparedStatementProxy;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.StatementCallback;\n+import io.seata.rm.datasource.sql.struct.ColumnMeta;\n+import io.seata.rm.datasource.sql.struct.Field;\n+import io.seata.rm.datasource.sql.struct.Row;\n+import io.seata.rm.datasource.sql.struct.TableMeta;\n+import io.seata.rm.datasource.sql.struct.TableRecords;\n+import io.seata.rm.datasource.undo.SQLUndoLog;\n+import io.seata.sqlparser.SQLInsertRecognizer;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.SQLType;\n+import io.seata.sqlparser.struct.Defaultable;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * @author: yangyicong\n+ */\n+@LoadLevel(name = JdbcConstants.MYSQL, scope = Scope.PROTOTYPE)\n+public class MySQLInsertOrUpdateExecutor extends MySQLInsertExecutor implements Defaultable {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MySQLInsertOrUpdateExecutor.class);\n+\n+    /**\n+     * is updated or not\n+     */\n+    private boolean isUpdateFlag = false;\n+\n+    public String getSelectSQL() {\n+        return selectSQL;\n+    }\n+\n+    /**\n+     * before image sql and after image sql,condition is unique index\n+     */\n+    private String selectSQL;\n+\n+    public ArrayList<List<Object>> getParamAppenderList() {\n+        return paramAppenderList;\n+    }\n+\n+    /**\n+     * the params of selectSQL, value is the unique index\n+     */\n+    private ArrayList<List<Object>> paramAppenderList;\n+\n+    /**\n+     * key is unique index name, value is unique index\n+     */\n+    private Map<String, List<String>> beforeUniqueIndexMap = new HashMap<>();\n+\n+    public MySQLInsertOrUpdateExecutor(StatementProxy statementProxy, StatementCallback statementCallback, SQLRecognizer sqlRecognizer) {\n+        super(statementProxy, statementCallback, sqlRecognizer);\n+    }\n+\n+    /**\n+     * Execute auto commit false t.\n+     *\n+     * @param args the args\n+     * @return the t\n+     * @throws Exception the exception\n+     */\n+    @Override\n+    protected Object executeAutoCommitFalse(Object[] args) throws Exception {\n+        if (!JdbcConstants.MYSQL.equalsIgnoreCase(getDbType()) && getTableMeta().getPrimaryKeyOnlyName().size() > 1) {\n+            throw new NotSupportYetException(\"multi pk only support mysql!\");\n+        }\n+        TableRecords beforeImage = beforeImage();\n+        if (CollectionUtils.isNotEmpty(beforeImage.getRows())) {\n+            isUpdateFlag = true;\n+        } else {\n+            beforeImage = TableRecords.empty(getTableMeta());\n+        }\n+        Object result = statementCallback.execute(statementProxy.getTargetStatement(), args);\n+        TableRecords afterImage = afterImage(beforeImage);\n+        prepareUndoLogAll(beforeImage, afterImage);\n+        return result;\n+    }\n+\n+    /**\n+     * prepare undo log.\n+     *\n+     * @param beforeImage the before image\n+     * @param afterImage  the after image\n+     * @throws SQLException the sql exception\n+     */\n+    protected void prepareUndoLogAll(TableRecords beforeImage, TableRecords afterImage) {\n+        if (beforeImage.getRows().isEmpty() && afterImage.getRows().isEmpty()) {\n+            return;\n+        }\n+        ConnectionProxy connectionProxy = statementProxy.getConnectionProxy();\n+        TableRecords lockKeyRecords = afterImage;\n+        String lockKeys = buildLockKey(lockKeyRecords);\n+        connectionProxy.appendLockKey(lockKeys);\n+        buildUndoItemAll(connectionProxy,beforeImage, afterImage);\n+    }\n+\n+    /**\n+     * build a SQLUndoLog\n+     *\n+     * @param beforeImage the before image\n+     * @param afterImage  the after image\n+     * @return sql undo log\n+     */\n+    protected void buildUndoItemAll(ConnectionProxy connectionProxy, TableRecords beforeImage, TableRecords afterImage) {\n+        if (!isUpdateFlag) {\n+            SQLUndoLog sqlUndoLog = buildUndoItem(TableRecords.empty(getTableMeta()), afterImage);\n+            connectionProxy.appendUndoLog(sqlUndoLog);\n+            return;\n+        }\n+        List<Row> beforeImageRows = beforeImage.getRows();\n+        for (Row r : beforeImageRows) {\n+            getTableMeta().getAllIndexes().forEach((k, v) -> {\n+                if (!\"PRIMARY\".equals(k.toUpperCase()) && !v.isNonUnique()) {\n+                    StringBuilder everyRowIndex = new StringBuilder();\n+                    v.getValues().forEach(m -> {\n+                        for (Field f : r.getFields()) {\n+                            if (m.getColumnName().equals(f.getName())) {\n+                                everyRowIndex.append(f.getValue());\n+                            }\n+                        }\n+                    });\n+                    List<String> indexList = beforeUniqueIndexMap.computeIfAbsent(k.toUpperCase(),key -> new ArrayList<>());\n+                    indexList.add(everyRowIndex.toString());\n+                    beforeUniqueIndexMap.put(k.toUpperCase(), indexList);\n+                }\n+            });\n+        }\n+        List<Row> insertRows = new ArrayList<>();\n+        List<Row> updateRows = new ArrayList<>();\n+        List<Row> afterImageRows = afterImage.getRows();\n+        for (Row r : afterImageRows) {\n+            AtomicBoolean isUpdateRowsFlag = new AtomicBoolean(false);\n+            getTableMeta().getAllIndexes().forEach((k, v) -> {\n+                if (!\"PRIMARY\".equals(k.toUpperCase()) && !v.isNonUnique()) {\n+                    StringBuilder everyRowIndex = new StringBuilder();\n+                    v.getValues().forEach(m -> {\n+                        for (Field f : r.getFields()) {\n+                            if (m.getColumnName().equals(f.getName())) {\n+                                everyRowIndex.append(f.getValue());\n+                            }\n+                        }\n+                    });\n+                    List<String> indexList = beforeUniqueIndexMap.get(k.toUpperCase());\n+                    if (CollectionUtils.isNotEmpty(indexList)) {\n+                        indexList.forEach(m -> {\n+                            if (m.equals(everyRowIndex.toString())) {\n+                                isUpdateRowsFlag.set(true);\n+                            }\n+                        });\n+                    }\n+                }\n+            });\n+            if (isUpdateRowsFlag.get()) {\n+                updateRows.add(r);\n+            } else {\n+                insertRows.add(r);\n+            }\n+        }\n+        if (CollectionUtils.isNotEmpty(updateRows)) {\n+            TableRecords partAfterImage = new TableRecords(afterImage.getTableMeta());\n+            partAfterImage.setTableName(afterImage.getTableName());\n+            partAfterImage.setRows(updateRows);\n+            connectionProxy.appendUndoLog(buildUndoItem(SQLType.UPDATE, beforeImage, partAfterImage));\n+        }\n+        if (CollectionUtils.isNotEmpty(insertRows)) {\n+            TableRecords partAfterImage = new TableRecords(afterImage.getTableMeta());\n+            partAfterImage.setTableName(afterImage.getTableName());\n+            partAfterImage.setRows(insertRows);\n+            connectionProxy.appendUndoLog(buildUndoItem(TableRecords.empty(getTableMeta()), partAfterImage));\n+        }\n+    }\n+\n+    /**\n+     * build a SQLUndoLog\n+     * @param sqlType\n+     * @param beforeImage\n+     * @param afterImage\n+     * @return\n+     */\n+    protected SQLUndoLog buildUndoItem(SQLType sqlType, TableRecords beforeImage, TableRecords afterImage) {\n+        String tableName = sqlRecognizer.getTableName();\n+        SQLUndoLog sqlUndoLog = new SQLUndoLog();\n+        sqlUndoLog.setSqlType(sqlType);\n+        sqlUndoLog.setTableName(tableName);\n+        sqlUndoLog.setBeforeImage(beforeImage);\n+        sqlUndoLog.setAfterImage(afterImage);\n+        return sqlUndoLog;\n+    }\n+\n+\n+    @Override\n+    protected TableRecords afterImage(TableRecords beforeImage) throws SQLException {\n+        if (isUpdateFlag) {\n+            return buildImage();\n+        } else {\n+            Map<String, List<Object>> pkValues = getPkValues();\n+            return afterImageInsert(pkValues);\n+        }\n+    }\n+\n+    private TableRecords afterImageInsert(Map<String, List<Object>> pkValues) throws SQLException {\n+        TableRecords afterImage = buildTableRecords(pkValues);\n+        if (afterImage == null) {\n+            throw new SQLException(\"Failed to build after-image for insert\");\n+        }\n+        return afterImage;\n+    }\n+\n+    @Override\n+    public TableRecords beforeImage() throws SQLException {\n+        return buildImage();\n+    }\n+\n+    /**\n+     * build before image and after image\n+     * @return\n+     * @throws SQLException\n+     */\n+    protected TableRecords buildImage() throws SQLException {\n+        TableMeta tmeta = getTableMeta();\n+        //after image sql the same of before image\n+        if (StringUtils.isBlank(selectSQL)) {\n+            paramAppenderList = new ArrayList<>();\n+            selectSQL = buildImageSQL(tmeta);\n+        }\n+        return buildTableRecords2(tmeta, selectSQL, paramAppenderList);\n+    }\n+\n+    /**\n+     *  build TableRecords\n+     * @param tableMeta\n+     * @param selectSQL\n+     * @param paramAppenderList\n+     * @return\n+     * @throws SQLException\n+     */\n+    public TableRecords buildTableRecords2(TableMeta tableMeta, String selectSQL, ArrayList<List<Object>> paramAppenderList) throws SQLException {\n+        ResultSet rs = null;\n+        try (PreparedStatement ps = statementProxy.getConnection().prepareStatement(selectSQL)) {\n+            if (CollectionUtils.isNotEmpty(paramAppenderList)) {\n+                for (int i = 0, ts = paramAppenderList.size(); i < ts; i++) {\n+                    List<Object> paramAppender = paramAppenderList.get(i);\n+                    for (int j = 0, ds = paramAppender.size(); j < ds; j++) {\n+                        ps.setObject(i * ds + j + 1, \"NULL\".equals(paramAppender.get(j).toString()) ? null : paramAppender.get(j));\n+                    }\n+                }\n+            }\n+            rs = ps.executeQuery();\n+            return TableRecords.buildRecords(tableMeta, rs);\n+        } finally {\n+            IOUtil.close(rs);\n+        }\n+    }\n+\n+    /**\n+     * build image sql\n+     * @param tableMeta\n+     * @return\n+     */\n+    public String buildImageSQL(TableMeta tableMeta) {\n+        if (CollectionUtils.isEmpty(paramAppenderList)) {\n+            paramAppenderList = new ArrayList<>();\n+        }\n+        SQLInsertRecognizer recognizer = (SQLInsertRecognizer) sqlRecognizer;\n+        int insertNum = recognizer.getInsertParamsValue().size();\n+        Map<String, ArrayList<Object>> imageParamperterMap =  buildImageParamperters(recognizer);\n+        StringBuilder prefix = new StringBuilder(\"SELECT * \");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fb31f43da21f8bed23906748688bb7061a9b7ea"}, "originalPosition": 305}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjkxNTA4NA==", "bodyText": "\u597d\u50cf\u6709\u70b9\u9ebb\u70e6\uff0c\u6211\u662f\u524d\u7f6e\u955c\u50cf\u548c\u540e\u7f6e\u955c\u50cf\u5bf9\u6bd4\uff0c\u5f97\u51fa\u662finsert\u6216update\u3002\u505a\u524d\u7f6e\u955c\u50cf\u7684\u65f6\u5019\u8fd8\u4e0d\u77e5\u9053\u8fd9\u4e2a\u662finsert\u6216update, \u6240\u4ee5\u6240\u6709\u5b57\u6bb5\u90fd\u67e5\u4e86\u3002\u6709\u4ec0\u4e48\u6bd4\u8f83\u597d\u7684\u5efa\u8bae\uff1f", "url": "https://github.com/seata/seata/pull/3374#discussion_r572915084", "createdAt": "2021-02-09T14:11:35Z", "author": {"login": "huan415"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "diffHunk": "@@ -0,0 +1,375 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec.mysql;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import com.google.common.base.Joiner;\n+import io.seata.common.exception.NotSupportYetException;\n+import io.seata.common.loader.LoadLevel;\n+import io.seata.common.loader.Scope;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.IOUtil;\n+import io.seata.common.util.StringUtils;\n+import io.seata.rm.datasource.ConnectionProxy;\n+import io.seata.rm.datasource.PreparedStatementProxy;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.StatementCallback;\n+import io.seata.rm.datasource.sql.struct.ColumnMeta;\n+import io.seata.rm.datasource.sql.struct.Field;\n+import io.seata.rm.datasource.sql.struct.Row;\n+import io.seata.rm.datasource.sql.struct.TableMeta;\n+import io.seata.rm.datasource.sql.struct.TableRecords;\n+import io.seata.rm.datasource.undo.SQLUndoLog;\n+import io.seata.sqlparser.SQLInsertRecognizer;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.SQLType;\n+import io.seata.sqlparser.struct.Defaultable;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * @author: yangyicong\n+ */\n+@LoadLevel(name = JdbcConstants.MYSQL, scope = Scope.PROTOTYPE)\n+public class MySQLInsertOrUpdateExecutor extends MySQLInsertExecutor implements Defaultable {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MySQLInsertOrUpdateExecutor.class);\n+\n+    /**\n+     * is updated or not\n+     */\n+    private boolean isUpdateFlag = false;\n+\n+    public String getSelectSQL() {\n+        return selectSQL;\n+    }\n+\n+    /**\n+     * before image sql and after image sql,condition is unique index\n+     */\n+    private String selectSQL;\n+\n+    public ArrayList<List<Object>> getParamAppenderList() {\n+        return paramAppenderList;\n+    }\n+\n+    /**\n+     * the params of selectSQL, value is the unique index\n+     */\n+    private ArrayList<List<Object>> paramAppenderList;\n+\n+    /**\n+     * key is unique index name, value is unique index\n+     */\n+    private Map<String, List<String>> beforeUniqueIndexMap = new HashMap<>();\n+\n+    public MySQLInsertOrUpdateExecutor(StatementProxy statementProxy, StatementCallback statementCallback, SQLRecognizer sqlRecognizer) {\n+        super(statementProxy, statementCallback, sqlRecognizer);\n+    }\n+\n+    /**\n+     * Execute auto commit false t.\n+     *\n+     * @param args the args\n+     * @return the t\n+     * @throws Exception the exception\n+     */\n+    @Override\n+    protected Object executeAutoCommitFalse(Object[] args) throws Exception {\n+        if (!JdbcConstants.MYSQL.equalsIgnoreCase(getDbType()) && getTableMeta().getPrimaryKeyOnlyName().size() > 1) {\n+            throw new NotSupportYetException(\"multi pk only support mysql!\");\n+        }\n+        TableRecords beforeImage = beforeImage();\n+        if (CollectionUtils.isNotEmpty(beforeImage.getRows())) {\n+            isUpdateFlag = true;\n+        } else {\n+            beforeImage = TableRecords.empty(getTableMeta());\n+        }\n+        Object result = statementCallback.execute(statementProxy.getTargetStatement(), args);\n+        TableRecords afterImage = afterImage(beforeImage);\n+        prepareUndoLogAll(beforeImage, afterImage);\n+        return result;\n+    }\n+\n+    /**\n+     * prepare undo log.\n+     *\n+     * @param beforeImage the before image\n+     * @param afterImage  the after image\n+     * @throws SQLException the sql exception\n+     */\n+    protected void prepareUndoLogAll(TableRecords beforeImage, TableRecords afterImage) {\n+        if (beforeImage.getRows().isEmpty() && afterImage.getRows().isEmpty()) {\n+            return;\n+        }\n+        ConnectionProxy connectionProxy = statementProxy.getConnectionProxy();\n+        TableRecords lockKeyRecords = afterImage;\n+        String lockKeys = buildLockKey(lockKeyRecords);\n+        connectionProxy.appendLockKey(lockKeys);\n+        buildUndoItemAll(connectionProxy,beforeImage, afterImage);\n+    }\n+\n+    /**\n+     * build a SQLUndoLog\n+     *\n+     * @param beforeImage the before image\n+     * @param afterImage  the after image\n+     * @return sql undo log\n+     */\n+    protected void buildUndoItemAll(ConnectionProxy connectionProxy, TableRecords beforeImage, TableRecords afterImage) {\n+        if (!isUpdateFlag) {\n+            SQLUndoLog sqlUndoLog = buildUndoItem(TableRecords.empty(getTableMeta()), afterImage);\n+            connectionProxy.appendUndoLog(sqlUndoLog);\n+            return;\n+        }\n+        List<Row> beforeImageRows = beforeImage.getRows();\n+        for (Row r : beforeImageRows) {\n+            getTableMeta().getAllIndexes().forEach((k, v) -> {\n+                if (!\"PRIMARY\".equals(k.toUpperCase()) && !v.isNonUnique()) {\n+                    StringBuilder everyRowIndex = new StringBuilder();\n+                    v.getValues().forEach(m -> {\n+                        for (Field f : r.getFields()) {\n+                            if (m.getColumnName().equals(f.getName())) {\n+                                everyRowIndex.append(f.getValue());\n+                            }\n+                        }\n+                    });\n+                    List<String> indexList = beforeUniqueIndexMap.computeIfAbsent(k.toUpperCase(),key -> new ArrayList<>());\n+                    indexList.add(everyRowIndex.toString());\n+                    beforeUniqueIndexMap.put(k.toUpperCase(), indexList);\n+                }\n+            });\n+        }\n+        List<Row> insertRows = new ArrayList<>();\n+        List<Row> updateRows = new ArrayList<>();\n+        List<Row> afterImageRows = afterImage.getRows();\n+        for (Row r : afterImageRows) {\n+            AtomicBoolean isUpdateRowsFlag = new AtomicBoolean(false);\n+            getTableMeta().getAllIndexes().forEach((k, v) -> {\n+                if (!\"PRIMARY\".equals(k.toUpperCase()) && !v.isNonUnique()) {\n+                    StringBuilder everyRowIndex = new StringBuilder();\n+                    v.getValues().forEach(m -> {\n+                        for (Field f : r.getFields()) {\n+                            if (m.getColumnName().equals(f.getName())) {\n+                                everyRowIndex.append(f.getValue());\n+                            }\n+                        }\n+                    });\n+                    List<String> indexList = beforeUniqueIndexMap.get(k.toUpperCase());\n+                    if (CollectionUtils.isNotEmpty(indexList)) {\n+                        indexList.forEach(m -> {\n+                            if (m.equals(everyRowIndex.toString())) {\n+                                isUpdateRowsFlag.set(true);\n+                            }\n+                        });\n+                    }\n+                }\n+            });\n+            if (isUpdateRowsFlag.get()) {\n+                updateRows.add(r);\n+            } else {\n+                insertRows.add(r);\n+            }\n+        }\n+        if (CollectionUtils.isNotEmpty(updateRows)) {\n+            TableRecords partAfterImage = new TableRecords(afterImage.getTableMeta());\n+            partAfterImage.setTableName(afterImage.getTableName());\n+            partAfterImage.setRows(updateRows);\n+            connectionProxy.appendUndoLog(buildUndoItem(SQLType.UPDATE, beforeImage, partAfterImage));\n+        }\n+        if (CollectionUtils.isNotEmpty(insertRows)) {\n+            TableRecords partAfterImage = new TableRecords(afterImage.getTableMeta());\n+            partAfterImage.setTableName(afterImage.getTableName());\n+            partAfterImage.setRows(insertRows);\n+            connectionProxy.appendUndoLog(buildUndoItem(TableRecords.empty(getTableMeta()), partAfterImage));\n+        }\n+    }\n+\n+    /**\n+     * build a SQLUndoLog\n+     * @param sqlType\n+     * @param beforeImage\n+     * @param afterImage\n+     * @return\n+     */\n+    protected SQLUndoLog buildUndoItem(SQLType sqlType, TableRecords beforeImage, TableRecords afterImage) {\n+        String tableName = sqlRecognizer.getTableName();\n+        SQLUndoLog sqlUndoLog = new SQLUndoLog();\n+        sqlUndoLog.setSqlType(sqlType);\n+        sqlUndoLog.setTableName(tableName);\n+        sqlUndoLog.setBeforeImage(beforeImage);\n+        sqlUndoLog.setAfterImage(afterImage);\n+        return sqlUndoLog;\n+    }\n+\n+\n+    @Override\n+    protected TableRecords afterImage(TableRecords beforeImage) throws SQLException {\n+        if (isUpdateFlag) {\n+            return buildImage();\n+        } else {\n+            Map<String, List<Object>> pkValues = getPkValues();\n+            return afterImageInsert(pkValues);\n+        }\n+    }\n+\n+    private TableRecords afterImageInsert(Map<String, List<Object>> pkValues) throws SQLException {\n+        TableRecords afterImage = buildTableRecords(pkValues);\n+        if (afterImage == null) {\n+            throw new SQLException(\"Failed to build after-image for insert\");\n+        }\n+        return afterImage;\n+    }\n+\n+    @Override\n+    public TableRecords beforeImage() throws SQLException {\n+        return buildImage();\n+    }\n+\n+    /**\n+     * build before image and after image\n+     * @return\n+     * @throws SQLException\n+     */\n+    protected TableRecords buildImage() throws SQLException {\n+        TableMeta tmeta = getTableMeta();\n+        //after image sql the same of before image\n+        if (StringUtils.isBlank(selectSQL)) {\n+            paramAppenderList = new ArrayList<>();\n+            selectSQL = buildImageSQL(tmeta);\n+        }\n+        return buildTableRecords2(tmeta, selectSQL, paramAppenderList);\n+    }\n+\n+    /**\n+     *  build TableRecords\n+     * @param tableMeta\n+     * @param selectSQL\n+     * @param paramAppenderList\n+     * @return\n+     * @throws SQLException\n+     */\n+    public TableRecords buildTableRecords2(TableMeta tableMeta, String selectSQL, ArrayList<List<Object>> paramAppenderList) throws SQLException {\n+        ResultSet rs = null;\n+        try (PreparedStatement ps = statementProxy.getConnection().prepareStatement(selectSQL)) {\n+            if (CollectionUtils.isNotEmpty(paramAppenderList)) {\n+                for (int i = 0, ts = paramAppenderList.size(); i < ts; i++) {\n+                    List<Object> paramAppender = paramAppenderList.get(i);\n+                    for (int j = 0, ds = paramAppender.size(); j < ds; j++) {\n+                        ps.setObject(i * ds + j + 1, \"NULL\".equals(paramAppender.get(j).toString()) ? null : paramAppender.get(j));\n+                    }\n+                }\n+            }\n+            rs = ps.executeQuery();\n+            return TableRecords.buildRecords(tableMeta, rs);\n+        } finally {\n+            IOUtil.close(rs);\n+        }\n+    }\n+\n+    /**\n+     * build image sql\n+     * @param tableMeta\n+     * @return\n+     */\n+    public String buildImageSQL(TableMeta tableMeta) {\n+        if (CollectionUtils.isEmpty(paramAppenderList)) {\n+            paramAppenderList = new ArrayList<>();\n+        }\n+        SQLInsertRecognizer recognizer = (SQLInsertRecognizer) sqlRecognizer;\n+        int insertNum = recognizer.getInsertParamsValue().size();\n+        Map<String, ArrayList<Object>> imageParamperterMap =  buildImageParamperters(recognizer);\n+        StringBuilder prefix = new StringBuilder(\"SELECT * \");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDk0MzYxNw=="}, "originalCommit": {"oid": "0fb31f43da21f8bed23906748688bb7061a9b7ea"}, "originalPosition": 305}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYxMTgzOTg0OnYy", "diffSide": "RIGHT", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wOVQxNTo0NDowNVrOIic_NA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xMFQwNTo0MzoyN1rOIi5bTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mjk5NzQyOA==", "bodyText": "\u8fd9\u91cc\u62fc\u63a5\u5b57\u7b26\u4e32\u4f1a\u4e0d\u4f1a\u4e0d\u662f\u5f88\u597d\uff1f\u50cf\u90a3\u79cd(a,b)\u7684\u8054\u5408\u552f\u4e00\u7d22\u5f15\uff0ca=1,b=22 \u548c a=12,b=2\u7684\u8bdd\uff0c\u662f\u4e0d\u662f\u4f1a\u5bfc\u81f4\u8bef\u5224\uff1f", "url": "https://github.com/seata/seata/pull/3374#discussion_r572997428", "createdAt": "2021-02-09T15:44:05Z", "author": {"login": "caohdgege"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "diffHunk": "@@ -0,0 +1,375 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec.mysql;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import com.google.common.base.Joiner;\n+import io.seata.common.exception.NotSupportYetException;\n+import io.seata.common.loader.LoadLevel;\n+import io.seata.common.loader.Scope;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.IOUtil;\n+import io.seata.common.util.StringUtils;\n+import io.seata.rm.datasource.ConnectionProxy;\n+import io.seata.rm.datasource.PreparedStatementProxy;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.StatementCallback;\n+import io.seata.rm.datasource.sql.struct.ColumnMeta;\n+import io.seata.rm.datasource.sql.struct.Field;\n+import io.seata.rm.datasource.sql.struct.Row;\n+import io.seata.rm.datasource.sql.struct.TableMeta;\n+import io.seata.rm.datasource.sql.struct.TableRecords;\n+import io.seata.rm.datasource.undo.SQLUndoLog;\n+import io.seata.sqlparser.SQLInsertRecognizer;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.SQLType;\n+import io.seata.sqlparser.struct.Defaultable;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * @author: yangyicong\n+ */\n+@LoadLevel(name = JdbcConstants.MYSQL, scope = Scope.PROTOTYPE)\n+public class MySQLInsertOrUpdateExecutor extends MySQLInsertExecutor implements Defaultable {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MySQLInsertOrUpdateExecutor.class);\n+\n+    /**\n+     * is updated or not\n+     */\n+    private boolean isUpdateFlag = false;\n+\n+    public String getSelectSQL() {\n+        return selectSQL;\n+    }\n+\n+    /**\n+     * before image sql and after image sql,condition is unique index\n+     */\n+    private String selectSQL;\n+\n+    public ArrayList<List<Object>> getParamAppenderList() {\n+        return paramAppenderList;\n+    }\n+\n+    /**\n+     * the params of selectSQL, value is the unique index\n+     */\n+    private ArrayList<List<Object>> paramAppenderList;\n+\n+    /**\n+     * key is unique index name, value is unique index\n+     */\n+    private Map<String, List<String>> beforeUniqueIndexMap = new HashMap<>();\n+\n+    public MySQLInsertOrUpdateExecutor(StatementProxy statementProxy, StatementCallback statementCallback, SQLRecognizer sqlRecognizer) {\n+        super(statementProxy, statementCallback, sqlRecognizer);\n+    }\n+\n+    /**\n+     * Execute auto commit false t.\n+     *\n+     * @param args the args\n+     * @return the t\n+     * @throws Exception the exception\n+     */\n+    @Override\n+    protected Object executeAutoCommitFalse(Object[] args) throws Exception {\n+        if (!JdbcConstants.MYSQL.equalsIgnoreCase(getDbType()) && getTableMeta().getPrimaryKeyOnlyName().size() > 1) {\n+            throw new NotSupportYetException(\"multi pk only support mysql!\");\n+        }\n+        TableRecords beforeImage = beforeImage();\n+        if (CollectionUtils.isNotEmpty(beforeImage.getRows())) {\n+            isUpdateFlag = true;\n+        } else {\n+            beforeImage = TableRecords.empty(getTableMeta());\n+        }\n+        Object result = statementCallback.execute(statementProxy.getTargetStatement(), args);\n+        TableRecords afterImage = afterImage(beforeImage);\n+        prepareUndoLogAll(beforeImage, afterImage);\n+        return result;\n+    }\n+\n+    /**\n+     * prepare undo log.\n+     *\n+     * @param beforeImage the before image\n+     * @param afterImage  the after image\n+     * @throws SQLException the sql exception\n+     */\n+    protected void prepareUndoLogAll(TableRecords beforeImage, TableRecords afterImage) {\n+        if (beforeImage.getRows().isEmpty() && afterImage.getRows().isEmpty()) {\n+            return;\n+        }\n+        ConnectionProxy connectionProxy = statementProxy.getConnectionProxy();\n+        TableRecords lockKeyRecords = afterImage;\n+        String lockKeys = buildLockKey(lockKeyRecords);\n+        connectionProxy.appendLockKey(lockKeys);\n+        buildUndoItemAll(connectionProxy,beforeImage, afterImage);\n+    }\n+\n+    /**\n+     * build a SQLUndoLog\n+     *\n+     * @param beforeImage the before image\n+     * @param afterImage  the after image\n+     * @return sql undo log\n+     */\n+    protected void buildUndoItemAll(ConnectionProxy connectionProxy, TableRecords beforeImage, TableRecords afterImage) {\n+        if (!isUpdateFlag) {\n+            SQLUndoLog sqlUndoLog = buildUndoItem(TableRecords.empty(getTableMeta()), afterImage);\n+            connectionProxy.appendUndoLog(sqlUndoLog);\n+            return;\n+        }\n+        List<Row> beforeImageRows = beforeImage.getRows();\n+        for (Row r : beforeImageRows) {\n+            getTableMeta().getAllIndexes().forEach((k, v) -> {\n+                if (!\"PRIMARY\".equals(k.toUpperCase()) && !v.isNonUnique()) {\n+                    StringBuilder everyRowIndex = new StringBuilder();\n+                    v.getValues().forEach(m -> {\n+                        for (Field f : r.getFields()) {\n+                            if (m.getColumnName().equals(f.getName())) {\n+                                everyRowIndex.append(f.getValue());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb3dc6a44f363f7cc7510b870e762d8cf80d20c0"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzQ2MzM3Mw==", "bodyText": "\u8fd9\u4e2a\u4f1a\u8bef\u5224\uff0c\u6211\u52a0\u5206\u9694\u7b26\u628a", "url": "https://github.com/seata/seata/pull/3374#discussion_r573463373", "createdAt": "2021-02-10T05:43:27Z", "author": {"login": "huan415"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "diffHunk": "@@ -0,0 +1,375 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec.mysql;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import com.google.common.base.Joiner;\n+import io.seata.common.exception.NotSupportYetException;\n+import io.seata.common.loader.LoadLevel;\n+import io.seata.common.loader.Scope;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.IOUtil;\n+import io.seata.common.util.StringUtils;\n+import io.seata.rm.datasource.ConnectionProxy;\n+import io.seata.rm.datasource.PreparedStatementProxy;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.StatementCallback;\n+import io.seata.rm.datasource.sql.struct.ColumnMeta;\n+import io.seata.rm.datasource.sql.struct.Field;\n+import io.seata.rm.datasource.sql.struct.Row;\n+import io.seata.rm.datasource.sql.struct.TableMeta;\n+import io.seata.rm.datasource.sql.struct.TableRecords;\n+import io.seata.rm.datasource.undo.SQLUndoLog;\n+import io.seata.sqlparser.SQLInsertRecognizer;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.SQLType;\n+import io.seata.sqlparser.struct.Defaultable;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * @author: yangyicong\n+ */\n+@LoadLevel(name = JdbcConstants.MYSQL, scope = Scope.PROTOTYPE)\n+public class MySQLInsertOrUpdateExecutor extends MySQLInsertExecutor implements Defaultable {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MySQLInsertOrUpdateExecutor.class);\n+\n+    /**\n+     * is updated or not\n+     */\n+    private boolean isUpdateFlag = false;\n+\n+    public String getSelectSQL() {\n+        return selectSQL;\n+    }\n+\n+    /**\n+     * before image sql and after image sql,condition is unique index\n+     */\n+    private String selectSQL;\n+\n+    public ArrayList<List<Object>> getParamAppenderList() {\n+        return paramAppenderList;\n+    }\n+\n+    /**\n+     * the params of selectSQL, value is the unique index\n+     */\n+    private ArrayList<List<Object>> paramAppenderList;\n+\n+    /**\n+     * key is unique index name, value is unique index\n+     */\n+    private Map<String, List<String>> beforeUniqueIndexMap = new HashMap<>();\n+\n+    public MySQLInsertOrUpdateExecutor(StatementProxy statementProxy, StatementCallback statementCallback, SQLRecognizer sqlRecognizer) {\n+        super(statementProxy, statementCallback, sqlRecognizer);\n+    }\n+\n+    /**\n+     * Execute auto commit false t.\n+     *\n+     * @param args the args\n+     * @return the t\n+     * @throws Exception the exception\n+     */\n+    @Override\n+    protected Object executeAutoCommitFalse(Object[] args) throws Exception {\n+        if (!JdbcConstants.MYSQL.equalsIgnoreCase(getDbType()) && getTableMeta().getPrimaryKeyOnlyName().size() > 1) {\n+            throw new NotSupportYetException(\"multi pk only support mysql!\");\n+        }\n+        TableRecords beforeImage = beforeImage();\n+        if (CollectionUtils.isNotEmpty(beforeImage.getRows())) {\n+            isUpdateFlag = true;\n+        } else {\n+            beforeImage = TableRecords.empty(getTableMeta());\n+        }\n+        Object result = statementCallback.execute(statementProxy.getTargetStatement(), args);\n+        TableRecords afterImage = afterImage(beforeImage);\n+        prepareUndoLogAll(beforeImage, afterImage);\n+        return result;\n+    }\n+\n+    /**\n+     * prepare undo log.\n+     *\n+     * @param beforeImage the before image\n+     * @param afterImage  the after image\n+     * @throws SQLException the sql exception\n+     */\n+    protected void prepareUndoLogAll(TableRecords beforeImage, TableRecords afterImage) {\n+        if (beforeImage.getRows().isEmpty() && afterImage.getRows().isEmpty()) {\n+            return;\n+        }\n+        ConnectionProxy connectionProxy = statementProxy.getConnectionProxy();\n+        TableRecords lockKeyRecords = afterImage;\n+        String lockKeys = buildLockKey(lockKeyRecords);\n+        connectionProxy.appendLockKey(lockKeys);\n+        buildUndoItemAll(connectionProxy,beforeImage, afterImage);\n+    }\n+\n+    /**\n+     * build a SQLUndoLog\n+     *\n+     * @param beforeImage the before image\n+     * @param afterImage  the after image\n+     * @return sql undo log\n+     */\n+    protected void buildUndoItemAll(ConnectionProxy connectionProxy, TableRecords beforeImage, TableRecords afterImage) {\n+        if (!isUpdateFlag) {\n+            SQLUndoLog sqlUndoLog = buildUndoItem(TableRecords.empty(getTableMeta()), afterImage);\n+            connectionProxy.appendUndoLog(sqlUndoLog);\n+            return;\n+        }\n+        List<Row> beforeImageRows = beforeImage.getRows();\n+        for (Row r : beforeImageRows) {\n+            getTableMeta().getAllIndexes().forEach((k, v) -> {\n+                if (!\"PRIMARY\".equals(k.toUpperCase()) && !v.isNonUnique()) {\n+                    StringBuilder everyRowIndex = new StringBuilder();\n+                    v.getValues().forEach(m -> {\n+                        for (Field f : r.getFields()) {\n+                            if (m.getColumnName().equals(f.getName())) {\n+                                everyRowIndex.append(f.getValue());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mjk5NzQyOA=="}, "originalCommit": {"oid": "cb3dc6a44f363f7cc7510b870e762d8cf80d20c0"}, "originalPosition": 156}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYxMTg0NDY5OnYy", "diffSide": "RIGHT", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wOVQxNTo0NTowMlrOIidCUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wOVQxNTo0NTowMlrOIidCUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mjk5ODIyNA==", "bodyText": "\u8fd9\u4e00\u884c\u662f\u5426\u662f\u591a\u4f59\u7684\uff1f", "url": "https://github.com/seata/seata/pull/3374#discussion_r572998224", "createdAt": "2021-02-09T15:45:02Z", "author": {"login": "caohdgege"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "diffHunk": "@@ -0,0 +1,375 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec.mysql;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import com.google.common.base.Joiner;\n+import io.seata.common.exception.NotSupportYetException;\n+import io.seata.common.loader.LoadLevel;\n+import io.seata.common.loader.Scope;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.IOUtil;\n+import io.seata.common.util.StringUtils;\n+import io.seata.rm.datasource.ConnectionProxy;\n+import io.seata.rm.datasource.PreparedStatementProxy;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.StatementCallback;\n+import io.seata.rm.datasource.sql.struct.ColumnMeta;\n+import io.seata.rm.datasource.sql.struct.Field;\n+import io.seata.rm.datasource.sql.struct.Row;\n+import io.seata.rm.datasource.sql.struct.TableMeta;\n+import io.seata.rm.datasource.sql.struct.TableRecords;\n+import io.seata.rm.datasource.undo.SQLUndoLog;\n+import io.seata.sqlparser.SQLInsertRecognizer;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.SQLType;\n+import io.seata.sqlparser.struct.Defaultable;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * @author: yangyicong\n+ */\n+@LoadLevel(name = JdbcConstants.MYSQL, scope = Scope.PROTOTYPE)\n+public class MySQLInsertOrUpdateExecutor extends MySQLInsertExecutor implements Defaultable {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MySQLInsertOrUpdateExecutor.class);\n+\n+    /**\n+     * is updated or not\n+     */\n+    private boolean isUpdateFlag = false;\n+\n+    public String getSelectSQL() {\n+        return selectSQL;\n+    }\n+\n+    /**\n+     * before image sql and after image sql,condition is unique index\n+     */\n+    private String selectSQL;\n+\n+    public ArrayList<List<Object>> getParamAppenderList() {\n+        return paramAppenderList;\n+    }\n+\n+    /**\n+     * the params of selectSQL, value is the unique index\n+     */\n+    private ArrayList<List<Object>> paramAppenderList;\n+\n+    /**\n+     * key is unique index name, value is unique index\n+     */\n+    private Map<String, List<String>> beforeUniqueIndexMap = new HashMap<>();\n+\n+    public MySQLInsertOrUpdateExecutor(StatementProxy statementProxy, StatementCallback statementCallback, SQLRecognizer sqlRecognizer) {\n+        super(statementProxy, statementCallback, sqlRecognizer);\n+    }\n+\n+    /**\n+     * Execute auto commit false t.\n+     *\n+     * @param args the args\n+     * @return the t\n+     * @throws Exception the exception\n+     */\n+    @Override\n+    protected Object executeAutoCommitFalse(Object[] args) throws Exception {\n+        if (!JdbcConstants.MYSQL.equalsIgnoreCase(getDbType()) && getTableMeta().getPrimaryKeyOnlyName().size() > 1) {\n+            throw new NotSupportYetException(\"multi pk only support mysql!\");\n+        }\n+        TableRecords beforeImage = beforeImage();\n+        if (CollectionUtils.isNotEmpty(beforeImage.getRows())) {\n+            isUpdateFlag = true;\n+        } else {\n+            beforeImage = TableRecords.empty(getTableMeta());\n+        }\n+        Object result = statementCallback.execute(statementProxy.getTargetStatement(), args);\n+        TableRecords afterImage = afterImage(beforeImage);\n+        prepareUndoLogAll(beforeImage, afterImage);\n+        return result;\n+    }\n+\n+    /**\n+     * prepare undo log.\n+     *\n+     * @param beforeImage the before image\n+     * @param afterImage  the after image\n+     * @throws SQLException the sql exception\n+     */\n+    protected void prepareUndoLogAll(TableRecords beforeImage, TableRecords afterImage) {\n+        if (beforeImage.getRows().isEmpty() && afterImage.getRows().isEmpty()) {\n+            return;\n+        }\n+        ConnectionProxy connectionProxy = statementProxy.getConnectionProxy();\n+        TableRecords lockKeyRecords = afterImage;\n+        String lockKeys = buildLockKey(lockKeyRecords);\n+        connectionProxy.appendLockKey(lockKeys);\n+        buildUndoItemAll(connectionProxy,beforeImage, afterImage);\n+    }\n+\n+    /**\n+     * build a SQLUndoLog\n+     *\n+     * @param beforeImage the before image\n+     * @param afterImage  the after image\n+     * @return sql undo log\n+     */\n+    protected void buildUndoItemAll(ConnectionProxy connectionProxy, TableRecords beforeImage, TableRecords afterImage) {\n+        if (!isUpdateFlag) {\n+            SQLUndoLog sqlUndoLog = buildUndoItem(TableRecords.empty(getTableMeta()), afterImage);\n+            connectionProxy.appendUndoLog(sqlUndoLog);\n+            return;\n+        }\n+        List<Row> beforeImageRows = beforeImage.getRows();\n+        for (Row r : beforeImageRows) {\n+            getTableMeta().getAllIndexes().forEach((k, v) -> {\n+                if (!\"PRIMARY\".equals(k.toUpperCase()) && !v.isNonUnique()) {\n+                    StringBuilder everyRowIndex = new StringBuilder();\n+                    v.getValues().forEach(m -> {\n+                        for (Field f : r.getFields()) {\n+                            if (m.getColumnName().equals(f.getName())) {\n+                                everyRowIndex.append(f.getValue());\n+                            }\n+                        }\n+                    });\n+                    List<String> indexList = beforeUniqueIndexMap.computeIfAbsent(k.toUpperCase(),key -> new ArrayList<>());\n+                    indexList.add(everyRowIndex.toString());\n+                    beforeUniqueIndexMap.put(k.toUpperCase(), indexList);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb3dc6a44f363f7cc7510b870e762d8cf80d20c0"}, "originalPosition": 162}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzY0NjQ0MjQ2OnYy", "diffSide": "RIGHT", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xOFQwODoyODozN1rOInbv7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xOFQwODoyODozN1rOInbv7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3ODIyMDAxMg==", "bodyText": "please remove :", "url": "https://github.com/seata/seata/pull/3374#discussion_r578220012", "createdAt": "2021-02-18T08:28:37Z", "author": {"login": "xingfudeshi"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "diffHunk": "@@ -0,0 +1,380 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec.mysql;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import com.google.common.base.Joiner;\n+import io.seata.common.exception.NotSupportYetException;\n+import io.seata.common.loader.LoadLevel;\n+import io.seata.common.loader.Scope;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.IOUtil;\n+import io.seata.common.util.StringUtils;\n+import io.seata.rm.datasource.ConnectionProxy;\n+import io.seata.rm.datasource.PreparedStatementProxy;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.StatementCallback;\n+import io.seata.rm.datasource.sql.struct.ColumnMeta;\n+import io.seata.rm.datasource.sql.struct.Field;\n+import io.seata.rm.datasource.sql.struct.Row;\n+import io.seata.rm.datasource.sql.struct.TableMeta;\n+import io.seata.rm.datasource.sql.struct.TableRecords;\n+import io.seata.rm.datasource.undo.SQLUndoLog;\n+import io.seata.sqlparser.SQLInsertRecognizer;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.SQLType;\n+import io.seata.sqlparser.struct.Defaultable;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * @author: yangyicong", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15f016a7424683edb3be869b18591b8fe179d919"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzY0NjQ0NTc5OnYy", "diffSide": "RIGHT", "path": "rm-datasource/src/test/java/io/seata/rm/datasource/exec/MySQLInsertOrUpdateExecutorTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xOFQwODoyOToyMFrOInbx5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xOFQwODoyOToyMFrOInbx5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3ODIyMDUxNw==", "bodyText": "please remove :", "url": "https://github.com/seata/seata/pull/3374#discussion_r578220517", "createdAt": "2021-02-18T08:29:20Z", "author": {"login": "xingfudeshi"}, "path": "rm-datasource/src/test/java/io/seata/rm/datasource/exec/MySQLInsertOrUpdateExecutorTest.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec;\n+\n+import com.google.common.collect.Lists;\n+import io.seata.common.exception.ShouldNeverHappenException;\n+import io.seata.rm.datasource.ConnectionProxy;\n+import io.seata.rm.datasource.PreparedStatementProxy;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.mysql.MySQLInsertExecutor;\n+import io.seata.rm.datasource.exec.mysql.MySQLInsertOrUpdateExecutor;\n+import io.seata.rm.datasource.sql.struct.*;\n+import io.seata.sqlparser.SQLInsertRecognizer;\n+import io.seata.sqlparser.struct.Null;\n+import io.seata.sqlparser.struct.SqlDefaultExpr;\n+import io.seata.sqlparser.struct.SqlMethodExpr;\n+import io.seata.sqlparser.struct.SqlSequenceExpr;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mockito;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.*;\n+\n+import static org.mockito.Mockito.*;\n+\n+/**\n+ * @author: yangyicong", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15f016a7424683edb3be869b18591b8fe179d919"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzY0NjQ0NjQ2OnYy", "diffSide": "RIGHT", "path": "rm-datasource/src/test/java/io/seata/rm/datasource/exec/MySQLInsertOrUpdateExecutorTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xOFQwODoyOTozMlrOInbyYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xOFQwODoyOTozMlrOInbyYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3ODIyMDY0MA==", "bodyText": "Please do not use *.", "url": "https://github.com/seata/seata/pull/3374#discussion_r578220640", "createdAt": "2021-02-18T08:29:32Z", "author": {"login": "xingfudeshi"}, "path": "rm-datasource/src/test/java/io/seata/rm/datasource/exec/MySQLInsertOrUpdateExecutorTest.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec;\n+\n+import com.google.common.collect.Lists;\n+import io.seata.common.exception.ShouldNeverHappenException;\n+import io.seata.rm.datasource.ConnectionProxy;\n+import io.seata.rm.datasource.PreparedStatementProxy;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.mysql.MySQLInsertExecutor;\n+import io.seata.rm.datasource.exec.mysql.MySQLInsertOrUpdateExecutor;\n+import io.seata.rm.datasource.sql.struct.*;\n+import io.seata.sqlparser.SQLInsertRecognizer;\n+import io.seata.sqlparser.struct.Null;\n+import io.seata.sqlparser.struct.SqlDefaultExpr;\n+import io.seata.sqlparser.struct.SqlMethodExpr;\n+import io.seata.sqlparser.struct.SqlSequenceExpr;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mockito;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.*;\n+\n+import static org.mockito.Mockito.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15f016a7424683edb3be869b18591b8fe179d919"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzg0MTQzNDkwOnYy", "diffSide": "RIGHT", "path": "sqlparser/seata-sqlparser-druid/src/main/java/io/seata/sqlparser/druid/mysql/MySQLInsertRecognizer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wNlQwNTozODo1MVrOJDYR1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0xN1QxMzo0NzoxM1rOJKwVFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNzUyMzI4NA==", "bodyText": "\u6709\u4e00\u4e9b\u5730\u65b9\u901a\u8fc7\u5224\u65ad sqlRecognizer.getSQLType() == SQLType.INSERT \u505a\u76f8\u5e94\u5904\u7406\uff0c\u8fd9\u6837\u7684\u5730\u65b9\u53ef\u80fd\u4e5f\u9700\u8981\u4e00\u8d77\u6539\u4e0b\uff0c\u6bd4\u5982\uff1aio.seata.rm.datasource.AbstractConnectionProxy#prepareStatement(java.lang.String)", "url": "https://github.com/seata/seata/pull/3374#discussion_r607523284", "createdAt": "2021-04-06T05:38:51Z", "author": {"login": "ymwangzq"}, "path": "sqlparser/seata-sqlparser-druid/src/main/java/io/seata/sqlparser/druid/mysql/MySQLInsertRecognizer.java", "diffHunk": "@@ -61,7 +61,7 @@ public MySQLInsertRecognizer(String originalSQL, SQLStatement ast) {\n \n     @Override\n     public SQLType getSQLType() {\n-        return SQLType.INSERT;\n+        return isDuplicateKeyUpdate() ? SQLType.INSERT_ON_DUPLICATE_UPDATE : SQLType.INSERT;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "054846286321470256b6a8f7cc163295c157ccf4"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTI1NzM2Nw==", "bodyText": "\u5176\u4ed6\u7684\u5730\u65b9\u597d\u50cf\u4e0d\u9700\u8981\u52a0\u628a\u3002\u60a8\u4e3e\u4f8b\u7684\u8fd9\u4e2a\uff0c\u6211\u770b\u6ce8\u91ca\u662fsupport oracle 10.2+\uff0c\u4f46\u662foracle\u6ca1\u6709\u8fd9\u79cd\u8bed\u6cd5\u3002\u6240\u4ee5\u4e0d\u9700\u8981\u5427", "url": "https://github.com/seata/seata/pull/3374#discussion_r615257367", "createdAt": "2021-04-17T13:47:13Z", "author": {"login": "huan415"}, "path": "sqlparser/seata-sqlparser-druid/src/main/java/io/seata/sqlparser/druid/mysql/MySQLInsertRecognizer.java", "diffHunk": "@@ -61,7 +61,7 @@ public MySQLInsertRecognizer(String originalSQL, SQLStatement ast) {\n \n     @Override\n     public SQLType getSQLType() {\n-        return SQLType.INSERT;\n+        return isDuplicateKeyUpdate() ? SQLType.INSERT_ON_DUPLICATE_UPDATE : SQLType.INSERT;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNzUyMzI4NA=="}, "originalCommit": {"oid": "054846286321470256b6a8f7cc163295c157ccf4"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzg0NjUzMzQ4OnYy", "diffSide": "RIGHT", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wN1QwMjo0NTo1N1rOJEH2dQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0yMVQxMzozODozNlrOJM71QA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwODMwMjcwOQ==", "bodyText": "\u5982\u679cupdate \u64cd\u4f5c\u91cc\u6709\u4fee\u6539\u4e3b\u952e\uff0c\u53ef\u80fd\u8fd8\u9700\u8981\u62e6\u622a\u6389\u3002", "url": "https://github.com/seata/seata/pull/3374#discussion_r608302709", "createdAt": "2021-04-07T02:45:57Z", "author": {"login": "ymwangzq"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "diffHunk": "@@ -0,0 +1,363 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec.mysql;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+import com.google.common.base.Joiner;\n+import io.seata.common.exception.NotSupportYetException;\n+import io.seata.common.loader.LoadLevel;\n+import io.seata.common.loader.Scope;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.IOUtil;\n+import io.seata.common.util.StringUtils;\n+import io.seata.rm.datasource.ConnectionProxy;\n+import io.seata.rm.datasource.PreparedStatementProxy;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.StatementCallback;\n+import io.seata.rm.datasource.sql.struct.ColumnMeta;\n+import io.seata.rm.datasource.sql.struct.Field;\n+import io.seata.rm.datasource.sql.struct.Row;\n+import io.seata.rm.datasource.sql.struct.TableMeta;\n+import io.seata.rm.datasource.sql.struct.TableRecords;\n+import io.seata.rm.datasource.undo.SQLUndoLog;\n+import io.seata.sqlparser.SQLInsertRecognizer;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.SQLType;\n+import io.seata.sqlparser.struct.Defaultable;\n+import io.seata.sqlparser.struct.Null;\n+import io.seata.sqlparser.util.JdbcConstants;\n+\n+/**\n+ * @author: yangyicong\n+ */\n+@LoadLevel(name = JdbcConstants.MYSQL, scope = Scope.PROTOTYPE)\n+public class MySQLInsertOrUpdateExecutor extends MySQLInsertExecutor implements Defaultable {\n+\n+\n+    private static final String COLUMN_SEPARATOR = \"|\";\n+\n+    /**\n+     * is updated or not\n+     */\n+    private boolean isUpdateFlag = false;\n+\n+    public String getSelectSQL() {\n+        return selectSQL;\n+    }\n+\n+    /**\n+     * before image sql and after image sql,condition is unique index\n+     */\n+    private String selectSQL;\n+\n+    public ArrayList<List<Object>> getParamAppenderList() {\n+        return paramAppenderList;\n+    }\n+\n+    /**\n+     * the params of selectSQL, value is the unique index\n+     */\n+    private ArrayList<List<Object>> paramAppenderList;\n+\n+    /**\n+     * key is unique index name, value is unique index\n+     */\n+    private Map<String, List<String>> beforeUniqueIndexMap = new HashMap<>();\n+\n+    public MySQLInsertOrUpdateExecutor(StatementProxy statementProxy, StatementCallback statementCallback, SQLRecognizer sqlRecognizer) {\n+        super(statementProxy, statementCallback, sqlRecognizer);\n+    }\n+\n+    /**\n+     * Execute auto commit false t.\n+     *\n+     * @param args the args\n+     * @return the t\n+     * @throws Exception the exception\n+     */\n+    @Override\n+    protected Object executeAutoCommitFalse(Object[] args) throws Exception {\n+        if (!JdbcConstants.MYSQL.equalsIgnoreCase(getDbType()) && getTableMeta().getPrimaryKeyOnlyName().size() > 1) {\n+            throw new NotSupportYetException(\"multi pk only support mysql!\");\n+        }\n+        TableRecords beforeImage = beforeImage();\n+        if (CollectionUtils.isNotEmpty(beforeImage.getRows())) {\n+            isUpdateFlag = true;\n+        } else {\n+            beforeImage = TableRecords.empty(getTableMeta());\n+        }\n+        Object result = statementCallback.execute(statementProxy.getTargetStatement(), args);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "054846286321470256b6a8f7cc163295c157ccf4"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTI1NzQ3Ng==", "bodyText": "\u62e6\u622a\u6389\uff1f\u4ec0\u4e48\u610f\u601d\uff0c\u6ca1\u660e\u767d", "url": "https://github.com/seata/seata/pull/3374#discussion_r615257476", "createdAt": "2021-04-17T13:47:49Z", "author": {"login": "huan415"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "diffHunk": "@@ -0,0 +1,363 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec.mysql;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+import com.google.common.base.Joiner;\n+import io.seata.common.exception.NotSupportYetException;\n+import io.seata.common.loader.LoadLevel;\n+import io.seata.common.loader.Scope;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.IOUtil;\n+import io.seata.common.util.StringUtils;\n+import io.seata.rm.datasource.ConnectionProxy;\n+import io.seata.rm.datasource.PreparedStatementProxy;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.StatementCallback;\n+import io.seata.rm.datasource.sql.struct.ColumnMeta;\n+import io.seata.rm.datasource.sql.struct.Field;\n+import io.seata.rm.datasource.sql.struct.Row;\n+import io.seata.rm.datasource.sql.struct.TableMeta;\n+import io.seata.rm.datasource.sql.struct.TableRecords;\n+import io.seata.rm.datasource.undo.SQLUndoLog;\n+import io.seata.sqlparser.SQLInsertRecognizer;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.SQLType;\n+import io.seata.sqlparser.struct.Defaultable;\n+import io.seata.sqlparser.struct.Null;\n+import io.seata.sqlparser.util.JdbcConstants;\n+\n+/**\n+ * @author: yangyicong\n+ */\n+@LoadLevel(name = JdbcConstants.MYSQL, scope = Scope.PROTOTYPE)\n+public class MySQLInsertOrUpdateExecutor extends MySQLInsertExecutor implements Defaultable {\n+\n+\n+    private static final String COLUMN_SEPARATOR = \"|\";\n+\n+    /**\n+     * is updated or not\n+     */\n+    private boolean isUpdateFlag = false;\n+\n+    public String getSelectSQL() {\n+        return selectSQL;\n+    }\n+\n+    /**\n+     * before image sql and after image sql,condition is unique index\n+     */\n+    private String selectSQL;\n+\n+    public ArrayList<List<Object>> getParamAppenderList() {\n+        return paramAppenderList;\n+    }\n+\n+    /**\n+     * the params of selectSQL, value is the unique index\n+     */\n+    private ArrayList<List<Object>> paramAppenderList;\n+\n+    /**\n+     * key is unique index name, value is unique index\n+     */\n+    private Map<String, List<String>> beforeUniqueIndexMap = new HashMap<>();\n+\n+    public MySQLInsertOrUpdateExecutor(StatementProxy statementProxy, StatementCallback statementCallback, SQLRecognizer sqlRecognizer) {\n+        super(statementProxy, statementCallback, sqlRecognizer);\n+    }\n+\n+    /**\n+     * Execute auto commit false t.\n+     *\n+     * @param args the args\n+     * @return the t\n+     * @throws Exception the exception\n+     */\n+    @Override\n+    protected Object executeAutoCommitFalse(Object[] args) throws Exception {\n+        if (!JdbcConstants.MYSQL.equalsIgnoreCase(getDbType()) && getTableMeta().getPrimaryKeyOnlyName().size() > 1) {\n+            throw new NotSupportYetException(\"multi pk only support mysql!\");\n+        }\n+        TableRecords beforeImage = beforeImage();\n+        if (CollectionUtils.isNotEmpty(beforeImage.getRows())) {\n+            isUpdateFlag = true;\n+        } else {\n+            beforeImage = TableRecords.empty(getTableMeta());\n+        }\n+        Object result = statementCallback.execute(statementProxy.getTargetStatement(), args);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwODMwMjcwOQ=="}, "originalCommit": {"oid": "054846286321470256b6a8f7cc163295c157ccf4"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTMzMTYwOA==", "bodyText": "\u53c2\u8003\u8fd9\u4e2a\u6539\u52a8\u4e4b\u524d\u7684\u7248\u672c https://github.com/seata/seata/pull/3287/files \uff08\u6539\u52a8\u4ee5\u540e\u903b\u8f91\u4e0d\u592a\u76f4\u89c2\uff09\n\u5728 UpdateExecutor \u91cc\u6784\u9020 beforeImage \u7684\u65f6\u5019\uff0c\u4f1a\u8c03\u7528 com.kuaishou.infra.seata.rm.datasource.exec.AbstractDMLBaseExecutor#assertContainsPKColumnName\n\u68c0\u67e5\u662f\u5426\u66f4\u65b0\u4e86\u4e3b\u952e\u3002\u5982\u679c\u4fee\u6539\u4e3b\u952e\u4f1a\u5bfc\u81f4beforeImage\u548cafterImage\u5bf9\u4e0d\u4e0a\uff0c\u65e0\u6cd5\u56de\u6eda.", "url": "https://github.com/seata/seata/pull/3374#discussion_r615331608", "createdAt": "2021-04-18T02:43:54Z", "author": {"login": "ymwangzq"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "diffHunk": "@@ -0,0 +1,363 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec.mysql;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+import com.google.common.base.Joiner;\n+import io.seata.common.exception.NotSupportYetException;\n+import io.seata.common.loader.LoadLevel;\n+import io.seata.common.loader.Scope;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.IOUtil;\n+import io.seata.common.util.StringUtils;\n+import io.seata.rm.datasource.ConnectionProxy;\n+import io.seata.rm.datasource.PreparedStatementProxy;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.StatementCallback;\n+import io.seata.rm.datasource.sql.struct.ColumnMeta;\n+import io.seata.rm.datasource.sql.struct.Field;\n+import io.seata.rm.datasource.sql.struct.Row;\n+import io.seata.rm.datasource.sql.struct.TableMeta;\n+import io.seata.rm.datasource.sql.struct.TableRecords;\n+import io.seata.rm.datasource.undo.SQLUndoLog;\n+import io.seata.sqlparser.SQLInsertRecognizer;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.SQLType;\n+import io.seata.sqlparser.struct.Defaultable;\n+import io.seata.sqlparser.struct.Null;\n+import io.seata.sqlparser.util.JdbcConstants;\n+\n+/**\n+ * @author: yangyicong\n+ */\n+@LoadLevel(name = JdbcConstants.MYSQL, scope = Scope.PROTOTYPE)\n+public class MySQLInsertOrUpdateExecutor extends MySQLInsertExecutor implements Defaultable {\n+\n+\n+    private static final String COLUMN_SEPARATOR = \"|\";\n+\n+    /**\n+     * is updated or not\n+     */\n+    private boolean isUpdateFlag = false;\n+\n+    public String getSelectSQL() {\n+        return selectSQL;\n+    }\n+\n+    /**\n+     * before image sql and after image sql,condition is unique index\n+     */\n+    private String selectSQL;\n+\n+    public ArrayList<List<Object>> getParamAppenderList() {\n+        return paramAppenderList;\n+    }\n+\n+    /**\n+     * the params of selectSQL, value is the unique index\n+     */\n+    private ArrayList<List<Object>> paramAppenderList;\n+\n+    /**\n+     * key is unique index name, value is unique index\n+     */\n+    private Map<String, List<String>> beforeUniqueIndexMap = new HashMap<>();\n+\n+    public MySQLInsertOrUpdateExecutor(StatementProxy statementProxy, StatementCallback statementCallback, SQLRecognizer sqlRecognizer) {\n+        super(statementProxy, statementCallback, sqlRecognizer);\n+    }\n+\n+    /**\n+     * Execute auto commit false t.\n+     *\n+     * @param args the args\n+     * @return the t\n+     * @throws Exception the exception\n+     */\n+    @Override\n+    protected Object executeAutoCommitFalse(Object[] args) throws Exception {\n+        if (!JdbcConstants.MYSQL.equalsIgnoreCase(getDbType()) && getTableMeta().getPrimaryKeyOnlyName().size() > 1) {\n+            throw new NotSupportYetException(\"multi pk only support mysql!\");\n+        }\n+        TableRecords beforeImage = beforeImage();\n+        if (CollectionUtils.isNotEmpty(beforeImage.getRows())) {\n+            isUpdateFlag = true;\n+        } else {\n+            beforeImage = TableRecords.empty(getTableMeta());\n+        }\n+        Object result = statementCallback.execute(statementProxy.getTargetStatement(), args);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwODMwMjcwOQ=="}, "originalCommit": {"oid": "054846286321470256b6a8f7cc163295c157ccf4"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNzU0Mjk3Ng==", "bodyText": "insert into  on duplicate key update.  \u4e3b\u952e\u4e0d\u4e00\u6837\u5c31\u662finsert\u4e86\uff0c\u9664\u975e\u7528\u552f\u4e00\u952e\u6765\u66f4\u65b0\u4e3b\u952e\uff08on duplicate key update.\u540e\u9762\u66f4\u65b0\u4e3b\u952e\uff09\uff0c\u611f\u89c9\u8fd9\u79cd\u5199\u6cd5\u5f88\u5947\u8469\uff0c\u4f46\u662f\u6700\u597d\u4e5f\u652f\u6301\u4e00\u4e0b\u3002\u6240\u4ee5UpdateExecutor\u662f\u5224\u65adbeforeImage\u548cafterImage\u5927\u5c0f\u4e0d\u4e00\u6837\uff0c\u5c31\u8ba4\u4e3a\u662f\u66f4\u65b0\u4e86\u4e3b\u952e\u76f4\u63a5\u629b\u5f02\u5e38\uff1f  \u6240\u4ee5\u8fd9\u5982\u679c\u662fupdate\u7684\u60c5\u51b5\u4e0b\uff0c\u4e5f\u5224\u65adafterImage\u548cafterImage\u4e0d\u4e00\u6837\u5c31\u629b\u5f02\u5e38\u4e0d\u652f\u6301\uff1f", "url": "https://github.com/seata/seata/pull/3374#discussion_r617542976", "createdAt": "2021-04-21T13:38:36Z", "author": {"login": "huan415"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "diffHunk": "@@ -0,0 +1,363 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec.mysql;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+import com.google.common.base.Joiner;\n+import io.seata.common.exception.NotSupportYetException;\n+import io.seata.common.loader.LoadLevel;\n+import io.seata.common.loader.Scope;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.IOUtil;\n+import io.seata.common.util.StringUtils;\n+import io.seata.rm.datasource.ConnectionProxy;\n+import io.seata.rm.datasource.PreparedStatementProxy;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.StatementCallback;\n+import io.seata.rm.datasource.sql.struct.ColumnMeta;\n+import io.seata.rm.datasource.sql.struct.Field;\n+import io.seata.rm.datasource.sql.struct.Row;\n+import io.seata.rm.datasource.sql.struct.TableMeta;\n+import io.seata.rm.datasource.sql.struct.TableRecords;\n+import io.seata.rm.datasource.undo.SQLUndoLog;\n+import io.seata.sqlparser.SQLInsertRecognizer;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.SQLType;\n+import io.seata.sqlparser.struct.Defaultable;\n+import io.seata.sqlparser.struct.Null;\n+import io.seata.sqlparser.util.JdbcConstants;\n+\n+/**\n+ * @author: yangyicong\n+ */\n+@LoadLevel(name = JdbcConstants.MYSQL, scope = Scope.PROTOTYPE)\n+public class MySQLInsertOrUpdateExecutor extends MySQLInsertExecutor implements Defaultable {\n+\n+\n+    private static final String COLUMN_SEPARATOR = \"|\";\n+\n+    /**\n+     * is updated or not\n+     */\n+    private boolean isUpdateFlag = false;\n+\n+    public String getSelectSQL() {\n+        return selectSQL;\n+    }\n+\n+    /**\n+     * before image sql and after image sql,condition is unique index\n+     */\n+    private String selectSQL;\n+\n+    public ArrayList<List<Object>> getParamAppenderList() {\n+        return paramAppenderList;\n+    }\n+\n+    /**\n+     * the params of selectSQL, value is the unique index\n+     */\n+    private ArrayList<List<Object>> paramAppenderList;\n+\n+    /**\n+     * key is unique index name, value is unique index\n+     */\n+    private Map<String, List<String>> beforeUniqueIndexMap = new HashMap<>();\n+\n+    public MySQLInsertOrUpdateExecutor(StatementProxy statementProxy, StatementCallback statementCallback, SQLRecognizer sqlRecognizer) {\n+        super(statementProxy, statementCallback, sqlRecognizer);\n+    }\n+\n+    /**\n+     * Execute auto commit false t.\n+     *\n+     * @param args the args\n+     * @return the t\n+     * @throws Exception the exception\n+     */\n+    @Override\n+    protected Object executeAutoCommitFalse(Object[] args) throws Exception {\n+        if (!JdbcConstants.MYSQL.equalsIgnoreCase(getDbType()) && getTableMeta().getPrimaryKeyOnlyName().size() > 1) {\n+            throw new NotSupportYetException(\"multi pk only support mysql!\");\n+        }\n+        TableRecords beforeImage = beforeImage();\n+        if (CollectionUtils.isNotEmpty(beforeImage.getRows())) {\n+            isUpdateFlag = true;\n+        } else {\n+            beforeImage = TableRecords.empty(getTableMeta());\n+        }\n+        Object result = statementCallback.execute(statementProxy.getTargetStatement(), args);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwODMwMjcwOQ=="}, "originalCommit": {"oid": "054846286321470256b6a8f7cc163295c157ccf4"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzk1ODcyODQzOnYy", "diffSide": "RIGHT", "path": "sqlparser/seata-sqlparser-druid/src/main/java/io/seata/sqlparser/druid/mysql/MySQLInsertRecognizer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0wM1QwNjoyMTo1NVrOJT8kiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0wM1QwNjoyMTo1NVrOJT8kiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNDg5NTExNQ==", "bodyText": "\u4e0d\u5141\u8bb8import *", "url": "https://github.com/seata/seata/pull/3374#discussion_r624895115", "createdAt": "2021-05-03T06:21:55Z", "author": {"login": "a364176773"}, "path": "sqlparser/seata-sqlparser-druid/src/main/java/io/seata/sqlparser/druid/mysql/MySQLInsertRecognizer.java", "diffHunk": "@@ -17,11 +17,7 @@\n \n import com.alibaba.druid.sql.ast.SQLExpr;\n import com.alibaba.druid.sql.ast.SQLStatement;\n-import com.alibaba.druid.sql.ast.expr.SQLIdentifierExpr;\n-import com.alibaba.druid.sql.ast.expr.SQLMethodInvokeExpr;\n-import com.alibaba.druid.sql.ast.expr.SQLNullExpr;\n-import com.alibaba.druid.sql.ast.expr.SQLValuableExpr;\n-import com.alibaba.druid.sql.ast.expr.SQLVariantRefExpr;\n+import com.alibaba.druid.sql.ast.expr.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b9e0a55a0a4feac0f256c11fe828381508f3f10f"}, "originalPosition": 9}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1378, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}