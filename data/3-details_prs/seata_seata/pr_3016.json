{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY3NzE4Nzg0", "number": 3016, "title": "optimize: refactor the redis lock string to hash", "bodyText": "\u2160. Describe what this PR did\nredis lock data structor \uff0cuse hash to replace string\n\u2161. Does this pull request fix one issue?\n\nfixes #3008\n\u2162. Why don't you add test cases (unit test/integration test)?\n\u2163. Describe how to verify it\n\u2164. Special notes for reviews", "createdAt": "2020-08-14T01:36:57Z", "url": "https://github.com/seata/seata/pull/3016", "merged": true, "mergeCommit": {"oid": "fc0c9ced86c317fafb2bffd37289d8afa56e7be8"}, "closed": true, "closedAt": "2020-09-03T07:25:14Z", "author": {"login": "lightClouds917"}, "timelineItems": {"totalCount": 29, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc-qA0xAH2gAyNDY3NzE4Nzg0OmIxMzM5ODFhZWJmMmRmOWUzMDQ2NWJiZDA5ODk2NjIzYzgxZWQ3NzY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdFKFLnAFqTQ4MTUxMDUzOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "b133981aebf2df9e30465bbd09896623c81ed776", "author": {"user": {"login": "lightClouds917", "name": "IT\u4e91\u6e05"}}, "url": "https://github.com/seata/seata/commit/b133981aebf2df9e30465bbd09896623c81ed776", "committedDate": "2020-08-14T01:06:18Z", "message": "refactor:the redis lock string to hash"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0a0fe6e82c988178511a2212d1e7e4b9f556ceb7", "author": {"user": {"login": "lightClouds917", "name": "IT\u4e91\u6e05"}}, "url": "https://github.com/seata/seata/commit/0a0fe6e82c988178511a2212d1e7e4b9f556ceb7", "committedDate": "2020-08-14T01:56:48Z", "message": "optimize:code format"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3Mjc3Njc1", "url": "https://github.com/seata/seata/pull/3016#pullrequestreview-467277675", "createdAt": "2020-08-14T03:01:58Z", "commit": {"oid": "0a0fe6e82c988178511a2212d1e7e4b9f556ceb7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQwMzowMTo1OFrOHAl7LA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQwMzowMTo1OFrOHAl7LA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM4MzQwNA==", "bodyText": "cannot play the role of competition lock", "url": "https://github.com/seata/seata/pull/3016#discussion_r470383404", "createdAt": "2020-08-14T03:01:58Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -70,59 +87,80 @@ public boolean acquireLock(List<RowLock> rowLocks) {\n             return true;\n         }\n         Set<String> successList = new HashSet<>();\n-        long status = 1;\n+        String status = OK;\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            List<LockDO> locks = convertToLockDO(rowLocks);\n-            if (locks.size() > 1) {\n-                locks =\n-                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            List<LockDO> needLockDOS = convertToLockDO(rowLocks);\n+            if (needLockDOS.size() >= 1) {\n+                needLockDOS = needLockDOS.stream().\n+                        filter(LambdaUtils.distinctByKey(LockDO::getRowKey))\n+                        .collect(Collectors.toList());\n             }\n-            List<String> existedKeyList = new ArrayList<>();\n-            locks.forEach(lockDO -> {\n-                existedKeyList.add(getLockKey(lockDO.getRowKey()));\n-            });\n-            List<String> lockList = jedis.mget(existedKeyList.toArray(new String[0]));\n-            Map<String, String> map = new HashMap<>(existedKeyList.size(), 1);\n-            for (int i = 0; i < existedKeyList.size(); i++) {\n-                String existedValue = lockList.get(i);\n-                if (existedValue == null) {\n-                    String key = existedKeyList.get(i);\n-                    map.put(key, JSON.toJSONString(locks.get(i)));\n+            List<String> needLockKeys = new ArrayList<>();\n+            needLockDOS.forEach(lockDO -> needLockKeys.add(buildLockKey(lockDO.getRowKey())));\n+\n+            Pipeline pipeline1 = jedis.pipelined();\n+            needLockKeys.stream().forEachOrdered(needLockKey -> pipeline1.hget(needLockKey, XID));\n+            List<Object> existedXidObjs = pipeline1.syncAndReturnAll();\n+            List<String> existedXids = (List<String>) (List) existedXidObjs;\n+            Map<String, LockDO> map = new HashMap<>(needLockKeys.size(), 1);\n+\n+            String needLockXid = rowLocks.get(0).getXid();\n+            for (int i = 0; i < needLockKeys.size(); i++) {\n+                String existedXid = existedXids.get(i);\n+                if (StringUtils.isEmpty(existedXid)) {\n+                    //If empty,we need to lock this row\n+                    map.put(needLockKeys.get(i), needLockDOS.get(i));\n                 } else {\n-                    LockDO existed = JSON.parseObject(existedValue, LockDO.class);\n-                    if (!StringUtils.equals(existed.getXid(), locks.get(i).getXid())) {\n+                    if (!StringUtils.equals(existedXid, needLockXid)) {\n+                        //If not equals,means the rowkey is holding by another global transaction\n                         return false;\n                     }\n                 }\n             }\n+\n             if (map.isEmpty()) {\n                 return true;\n             }\n             Pipeline pipeline = jedis.pipelined();\n             List<String> readyKeys = new ArrayList<>();\n             map.forEach((key, value) -> {\n-                pipeline.setnx(key, value);\n+                Map<String, String> lockMap = new HashMap<>(8);\n+                lockMap.put(XID, value.getXid());\n+                lockMap.put(TRANSACTION_ID, value.getTransactionId().toString());\n+                lockMap.put(BRANCH_ID, value.getBranchId().toString());\n+                lockMap.put(RESOURCE_ID, value.getResourceId());\n+                lockMap.put(TABLE_NAME, value.getTableName());\n+                lockMap.put(ROW_KEY, value.getRowKey());\n+                lockMap.put(PK, value.getPk());\n+                pipeline.hmset(key, lockMap);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a0fe6e82c988178511a2212d1e7e4b9f556ceb7"}, "originalPosition": 128}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "14f8ec02faa91ce4f94d4bc59e435066a862e61b", "author": {"user": {"login": "lightClouds917", "name": "IT\u4e91\u6e05"}}, "url": "https://github.com/seata/seata/commit/14f8ec02faa91ce4f94d4bc59e435066a862e61b", "committedDate": "2020-08-18T03:53:59Z", "message": "refactor:refactor the redis lock data structure"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "92275de275a98b11baf0ee39de54927d80faf659", "author": {"user": {"login": "lightClouds917", "name": "IT\u4e91\u6e05"}}, "url": "https://github.com/seata/seata/commit/92275de275a98b11baf0ee39de54927d80faf659", "committedDate": "2020-08-18T04:37:10Z", "message": "refactor:refactor the redis lock data structure"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1f4cca9c462a0d18a58d8cdd23a7d97fdbaaeb4a", "author": {"user": {"login": "lightClouds917", "name": "IT\u4e91\u6e05"}}, "url": "https://github.com/seata/seata/commit/1f4cca9c462a0d18a58d8cdd23a7d97fdbaaeb4a", "committedDate": "2020-08-18T07:42:22Z", "message": "fix:the hsetnx response"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5MDc2MTg0", "url": "https://github.com/seata/seata/pull/3016#pullrequestreview-469076184", "createdAt": "2020-08-18T07:50:33Z", "commit": {"oid": "92275de275a98b11baf0ee39de54927d80faf659"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwNzo1MDozM1rOHCHpPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwODozNzozNFrOHCJXSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk4NDQ0NA==", "bodyText": "partitions.get(i).contains", "url": "https://github.com/seata/seata/pull/3016#discussion_r471984444", "createdAt": "2020-08-18T07:50:33Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -60,131 +87,178 @@\n      */\n     public RedisLocker() {\n         logQueryLimit =\n-            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+                ConfigurationFactory.getInstance()\n+                        .getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n     }\n \n     @Override\n     public boolean acquireLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        Set<String> successList = new HashSet<>();\n-        long status = 1;\n+        Integer status = SUCCEED;\n+        String needLockXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            List<LockDO> locks = convertToLockDO(rowLocks);\n-            if (locks.size() > 1) {\n-                locks =\n-                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            List<LockDO> needLockDOS = convertToLockDO(rowLocks);\n+            if (needLockDOS.size() >= 1) {\n+                needLockDOS = needLockDOS.stream().\n+                        filter(LambdaUtils.distinctByKey(LockDO::getRowKey))\n+                        .collect(Collectors.toList());\n             }\n-            List<String> existedKeyList = new ArrayList<>();\n-            locks.forEach(lockDO -> {\n-                existedKeyList.add(getLockKey(lockDO.getRowKey()));\n-            });\n-            List<String> lockList = jedis.mget(existedKeyList.toArray(new String[0]));\n-            Map<String, String> map = new HashMap<>(existedKeyList.size(), 1);\n-            for (int i = 0; i < existedKeyList.size(); i++) {\n-                String existedValue = lockList.get(i);\n-                if (existedValue == null) {\n-                    String key = existedKeyList.get(i);\n-                    map.put(key, JSON.toJSONString(locks.get(i)));\n+            List<String> needLockKeys = new ArrayList<>();\n+            needLockDOS.forEach(lockDO -> needLockKeys.add(buildLockKey(lockDO.getRowKey())));\n+\n+            Pipeline pipeline1 = jedis.pipelined();\n+            needLockKeys.stream().forEachOrdered(\n+                    needLockKey -> pipeline1.hmget(needLockKey, XID, TABLE_NAME, PK, BRANCH_ID));\n+            List<Object> existedObjs = pipeline1.syncAndReturnAll();\n+            List<List<String>> existedLockInfos = (List<List<String>>) (List) existedObjs;\n+            Map<String, LockDO> needAddLock = new HashMap<>(needLockKeys.size(), 1);\n+\n+            for (int i = 0; i < needLockKeys.size(); i++) {\n+                List<String> existedLockInfo = existedLockInfos.get(i);\n+                if (CollectionUtils.isEmpty(existedLockInfo) ||\n+                        existedLockInfo.stream().allMatch(info -> info == null)) {\n+                    //If empty,we need to lock this row\n+                    needAddLock.put(needLockKeys.get(i), needLockDOS.get(i));\n                 } else {\n-                    LockDO existed = JSON.parseObject(existedValue, LockDO.class);\n-                    if (!StringUtils.equals(existed.getXid(), locks.get(i).getXid())) {\n+                    if (!StringUtils.equals(existedLockInfo.get(0), needLockXid)) {\n+                        //If not equals,means the rowkey is holding by another global transaction\n+                        LOGGER.error(\"Acquire lock failed,Global lock on [{}:{}] is holding by xid {} branchId {}\",\n+                                existedLockInfo.get(1), existedLockInfo.get(2),\n+                                existedLockInfo.get(0), existedLockInfo.get(3));\n                         return false;\n                     }\n                 }\n             }\n-            if (map.isEmpty()) {\n+\n+            if (needAddLock.isEmpty()) {\n                 return true;\n             }\n             Pipeline pipeline = jedis.pipelined();\n             List<String> readyKeys = new ArrayList<>();\n-            map.forEach((key, value) -> {\n-                pipeline.setnx(key, value);\n+            needAddLock.forEach((key, value) -> {\n+                pipeline.hsetnx(key, XID, value.getXid());\n+                pipeline.hsetnx(key, TRANSACTION_ID, value.getTransactionId().toString());\n+                pipeline.hsetnx(key, BRANCH_ID, value.getBranchId().toString());\n+                pipeline.hsetnx(key, RESOURCE_ID, value.getResourceId());\n+                pipeline.hsetnx(key, TABLE_NAME, value.getTableName());\n+                pipeline.hsetnx(key, ROW_KEY, value.getRowKey());\n+                pipeline.hsetnx(key, PK, value.getPk());\n                 readyKeys.add(key);\n             });\n             List<Object> results = pipeline.syncAndReturnAll();\n-            for (int i = 0; i < results.size(); i++) {\n-                Long result = (long)results.get(i);\n+            List<Integer> results2 = (List<Integer>) (List) results;\n+            List<List<Integer>> partitions = Lists.partition(results2, 7);\n+\n+            Set<String> successSet = new HashSet<>();\n+            for (int i = 0; i < partitions.size(); i++) {\n                 String key = readyKeys.get(i);\n-                if (result != 1) {\n-                    status = result;\n+                if (partitions.contains(FAILED)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92275de275a98b11baf0ee39de54927d80faf659"}, "originalPosition": 171}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk4NjU2MQ==", "bodyText": "del successSet. toArray (new String[0])", "url": "https://github.com/seata/seata/pull/3016#discussion_r471986561", "createdAt": "2020-08-18T07:54:19Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -60,131 +87,178 @@\n      */\n     public RedisLocker() {\n         logQueryLimit =\n-            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+                ConfigurationFactory.getInstance()\n+                        .getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n     }\n \n     @Override\n     public boolean acquireLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        Set<String> successList = new HashSet<>();\n-        long status = 1;\n+        Integer status = SUCCEED;\n+        String needLockXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            List<LockDO> locks = convertToLockDO(rowLocks);\n-            if (locks.size() > 1) {\n-                locks =\n-                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            List<LockDO> needLockDOS = convertToLockDO(rowLocks);\n+            if (needLockDOS.size() >= 1) {\n+                needLockDOS = needLockDOS.stream().\n+                        filter(LambdaUtils.distinctByKey(LockDO::getRowKey))\n+                        .collect(Collectors.toList());\n             }\n-            List<String> existedKeyList = new ArrayList<>();\n-            locks.forEach(lockDO -> {\n-                existedKeyList.add(getLockKey(lockDO.getRowKey()));\n-            });\n-            List<String> lockList = jedis.mget(existedKeyList.toArray(new String[0]));\n-            Map<String, String> map = new HashMap<>(existedKeyList.size(), 1);\n-            for (int i = 0; i < existedKeyList.size(); i++) {\n-                String existedValue = lockList.get(i);\n-                if (existedValue == null) {\n-                    String key = existedKeyList.get(i);\n-                    map.put(key, JSON.toJSONString(locks.get(i)));\n+            List<String> needLockKeys = new ArrayList<>();\n+            needLockDOS.forEach(lockDO -> needLockKeys.add(buildLockKey(lockDO.getRowKey())));\n+\n+            Pipeline pipeline1 = jedis.pipelined();\n+            needLockKeys.stream().forEachOrdered(\n+                    needLockKey -> pipeline1.hmget(needLockKey, XID, TABLE_NAME, PK, BRANCH_ID));\n+            List<Object> existedObjs = pipeline1.syncAndReturnAll();\n+            List<List<String>> existedLockInfos = (List<List<String>>) (List) existedObjs;\n+            Map<String, LockDO> needAddLock = new HashMap<>(needLockKeys.size(), 1);\n+\n+            for (int i = 0; i < needLockKeys.size(); i++) {\n+                List<String> existedLockInfo = existedLockInfos.get(i);\n+                if (CollectionUtils.isEmpty(existedLockInfo) ||\n+                        existedLockInfo.stream().allMatch(info -> info == null)) {\n+                    //If empty,we need to lock this row\n+                    needAddLock.put(needLockKeys.get(i), needLockDOS.get(i));\n                 } else {\n-                    LockDO existed = JSON.parseObject(existedValue, LockDO.class);\n-                    if (!StringUtils.equals(existed.getXid(), locks.get(i).getXid())) {\n+                    if (!StringUtils.equals(existedLockInfo.get(0), needLockXid)) {\n+                        //If not equals,means the rowkey is holding by another global transaction\n+                        LOGGER.error(\"Acquire lock failed,Global lock on [{}:{}] is holding by xid {} branchId {}\",\n+                                existedLockInfo.get(1), existedLockInfo.get(2),\n+                                existedLockInfo.get(0), existedLockInfo.get(3));\n                         return false;\n                     }\n                 }\n             }\n-            if (map.isEmpty()) {\n+\n+            if (needAddLock.isEmpty()) {\n                 return true;\n             }\n             Pipeline pipeline = jedis.pipelined();\n             List<String> readyKeys = new ArrayList<>();\n-            map.forEach((key, value) -> {\n-                pipeline.setnx(key, value);\n+            needAddLock.forEach((key, value) -> {\n+                pipeline.hsetnx(key, XID, value.getXid());\n+                pipeline.hsetnx(key, TRANSACTION_ID, value.getTransactionId().toString());\n+                pipeline.hsetnx(key, BRANCH_ID, value.getBranchId().toString());\n+                pipeline.hsetnx(key, RESOURCE_ID, value.getResourceId());\n+                pipeline.hsetnx(key, TABLE_NAME, value.getTableName());\n+                pipeline.hsetnx(key, ROW_KEY, value.getRowKey());\n+                pipeline.hsetnx(key, PK, value.getPk());\n                 readyKeys.add(key);\n             });\n             List<Object> results = pipeline.syncAndReturnAll();\n-            for (int i = 0; i < results.size(); i++) {\n-                Long result = (long)results.get(i);\n+            List<Integer> results2 = (List<Integer>) (List) results;\n+            List<List<Integer>> partitions = Lists.partition(results2, 7);\n+\n+            Set<String> successSet = new HashSet<>();\n+            for (int i = 0; i < partitions.size(); i++) {\n                 String key = readyKeys.get(i);\n-                if (result != 1) {\n-                    status = result;\n+                if (partitions.contains(FAILED)) {\n+                    status = FAILED;\n                 } else {\n-                    successList.add(key);\n+                    successSet.add(key);\n                 }\n             }\n-            if (status != 1) {\n-                String[] rms = successList.toArray(new String[0]);\n-                if (rms.length > 0) {\n-                    jedis.del(rms);\n+\n+            //If someone has failed,all the lockkey which has been added need to be delete.\n+            if (FAILED.equals(status)) {\n+                if (successSet.size() > 0) {\n+                    Pipeline pipeline2 = jedis.pipelined();\n+                    successSet.forEach(locKey ->\n+                            pipeline2.hdel(locKey, XID, TRANSACTION_ID, BRANCH_ID, RESOURCE_ID,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92275de275a98b11baf0ee39de54927d80faf659"}, "originalPosition": 188}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk5MTU0MA==", "bodyText": "only need to xid", "url": "https://github.com/seata/seata/pull/3016#discussion_r471991540", "createdAt": "2020-08-18T08:02:33Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -60,131 +87,179 @@\n      */\n     public RedisLocker() {\n         logQueryLimit =\n-            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+                ConfigurationFactory.getInstance()\n+                        .getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n     }\n \n     @Override\n     public boolean acquireLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        Set<String> successList = new HashSet<>();\n-        long status = 1;\n+        Integer status = SUCCEED;\n+        String needLockXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            List<LockDO> locks = convertToLockDO(rowLocks);\n-            if (locks.size() > 1) {\n-                locks =\n-                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            List<LockDO> needLockDOS = convertToLockDO(rowLocks);\n+            if (needLockDOS.size() >= 1) {\n+                needLockDOS = needLockDOS.stream().\n+                        filter(LambdaUtils.distinctByKey(LockDO::getRowKey))\n+                        .collect(Collectors.toList());\n             }\n-            List<String> existedKeyList = new ArrayList<>();\n-            locks.forEach(lockDO -> {\n-                existedKeyList.add(getLockKey(lockDO.getRowKey()));\n-            });\n-            List<String> lockList = jedis.mget(existedKeyList.toArray(new String[0]));\n-            Map<String, String> map = new HashMap<>(existedKeyList.size(), 1);\n-            for (int i = 0; i < existedKeyList.size(); i++) {\n-                String existedValue = lockList.get(i);\n-                if (existedValue == null) {\n-                    String key = existedKeyList.get(i);\n-                    map.put(key, JSON.toJSONString(locks.get(i)));\n+            List<String> needLockKeys = new ArrayList<>();\n+            needLockDOS.forEach(lockDO -> needLockKeys.add(buildLockKey(lockDO.getRowKey())));\n+\n+            Pipeline pipeline1 = jedis.pipelined();\n+            needLockKeys.stream().forEachOrdered(\n+                    needLockKey -> pipeline1.hmget(needLockKey, XID, TABLE_NAME, PK, BRANCH_ID));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f4cca9c462a0d18a58d8cdd23a7d97fdbaaeb4a"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk5Nzc4Nw==", "bodyText": "List< Integer > results = (List) (List) pipeline.syncAndReturnAll();", "url": "https://github.com/seata/seata/pull/3016#discussion_r471997787", "createdAt": "2020-08-18T08:13:32Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -60,131 +87,179 @@\n      */\n     public RedisLocker() {\n         logQueryLimit =\n-            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+                ConfigurationFactory.getInstance()\n+                        .getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n     }\n \n     @Override\n     public boolean acquireLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        Set<String> successList = new HashSet<>();\n-        long status = 1;\n+        Integer status = SUCCEED;\n+        String needLockXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            List<LockDO> locks = convertToLockDO(rowLocks);\n-            if (locks.size() > 1) {\n-                locks =\n-                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            List<LockDO> needLockDOS = convertToLockDO(rowLocks);\n+            if (needLockDOS.size() >= 1) {\n+                needLockDOS = needLockDOS.stream().\n+                        filter(LambdaUtils.distinctByKey(LockDO::getRowKey))\n+                        .collect(Collectors.toList());\n             }\n-            List<String> existedKeyList = new ArrayList<>();\n-            locks.forEach(lockDO -> {\n-                existedKeyList.add(getLockKey(lockDO.getRowKey()));\n-            });\n-            List<String> lockList = jedis.mget(existedKeyList.toArray(new String[0]));\n-            Map<String, String> map = new HashMap<>(existedKeyList.size(), 1);\n-            for (int i = 0; i < existedKeyList.size(); i++) {\n-                String existedValue = lockList.get(i);\n-                if (existedValue == null) {\n-                    String key = existedKeyList.get(i);\n-                    map.put(key, JSON.toJSONString(locks.get(i)));\n+            List<String> needLockKeys = new ArrayList<>();\n+            needLockDOS.forEach(lockDO -> needLockKeys.add(buildLockKey(lockDO.getRowKey())));\n+\n+            Pipeline pipeline1 = jedis.pipelined();\n+            needLockKeys.stream().forEachOrdered(\n+                    needLockKey -> pipeline1.hmget(needLockKey, XID, TABLE_NAME, PK, BRANCH_ID));\n+            List<Object> existedObjs = pipeline1.syncAndReturnAll();\n+            List<List<String>> existedLockInfos = (List<List<String>>) (List) existedObjs;\n+            Map<String, LockDO> needAddLock = new HashMap<>(needLockKeys.size(), 1);\n+\n+            for (int i = 0; i < needLockKeys.size(); i++) {\n+                List<String> existedLockInfo = existedLockInfos.get(i);\n+                if (CollectionUtils.isEmpty(existedLockInfo) ||\n+                        existedLockInfo.stream().allMatch(info -> info == null)) {\n+                    //If empty,we need to lock this row\n+                    needAddLock.put(needLockKeys.get(i), needLockDOS.get(i));\n                 } else {\n-                    LockDO existed = JSON.parseObject(existedValue, LockDO.class);\n-                    if (!StringUtils.equals(existed.getXid(), locks.get(i).getXid())) {\n+                    if (!StringUtils.equals(existedLockInfo.get(0), needLockXid)) {\n+                        //If not equals,means the rowkey is holding by another global transaction\n+                        LOGGER.error(\n+                                \"Acquire lock failed,Global lock on [{}:{}] is holding by xid {} branchId {}\",\n+                                existedLockInfo.get(1), existedLockInfo.get(2),\n+                                existedLockInfo.get(0), existedLockInfo.get(3));\n                         return false;\n                     }\n                 }\n             }\n-            if (map.isEmpty()) {\n+\n+            if (needAddLock.isEmpty()) {\n                 return true;\n             }\n             Pipeline pipeline = jedis.pipelined();\n             List<String> readyKeys = new ArrayList<>();\n-            map.forEach((key, value) -> {\n-                pipeline.setnx(key, value);\n+            needAddLock.forEach((key, value) -> {\n+                pipeline.hsetnx(key, XID, value.getXid());\n+                pipeline.hsetnx(key, TRANSACTION_ID, value.getTransactionId().toString());\n+                pipeline.hsetnx(key, BRANCH_ID, value.getBranchId().toString());\n+                pipeline.hsetnx(key, RESOURCE_ID, value.getResourceId());\n+                pipeline.hsetnx(key, TABLE_NAME, value.getTableName());\n+                pipeline.hsetnx(key, ROW_KEY, value.getRowKey());\n+                pipeline.hsetnx(key, PK, value.getPk());\n                 readyKeys.add(key);\n             });\n             List<Object> results = pipeline.syncAndReturnAll();\n-            for (int i = 0; i < results.size(); i++) {\n-                Long result = (long)results.get(i);\n+            List<Integer> results2 = (List<Integer>) (List) results;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f4cca9c462a0d18a58d8cdd23a7d97fdbaaeb4a"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk5OTk2Ng==", "bodyText": "the lock can only be actively unlocked by the owner without having to retrieve it again", "url": "https://github.com/seata/seata/pull/3016#discussion_r471999966", "createdAt": "2020-08-18T08:17:15Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -60,131 +87,179 @@\n      */\n     public RedisLocker() {\n         logQueryLimit =\n-            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+                ConfigurationFactory.getInstance()\n+                        .getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n     }\n \n     @Override\n     public boolean acquireLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        Set<String> successList = new HashSet<>();\n-        long status = 1;\n+        Integer status = SUCCEED;\n+        String needLockXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            List<LockDO> locks = convertToLockDO(rowLocks);\n-            if (locks.size() > 1) {\n-                locks =\n-                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            List<LockDO> needLockDOS = convertToLockDO(rowLocks);\n+            if (needLockDOS.size() >= 1) {\n+                needLockDOS = needLockDOS.stream().\n+                        filter(LambdaUtils.distinctByKey(LockDO::getRowKey))\n+                        .collect(Collectors.toList());\n             }\n-            List<String> existedKeyList = new ArrayList<>();\n-            locks.forEach(lockDO -> {\n-                existedKeyList.add(getLockKey(lockDO.getRowKey()));\n-            });\n-            List<String> lockList = jedis.mget(existedKeyList.toArray(new String[0]));\n-            Map<String, String> map = new HashMap<>(existedKeyList.size(), 1);\n-            for (int i = 0; i < existedKeyList.size(); i++) {\n-                String existedValue = lockList.get(i);\n-                if (existedValue == null) {\n-                    String key = existedKeyList.get(i);\n-                    map.put(key, JSON.toJSONString(locks.get(i)));\n+            List<String> needLockKeys = new ArrayList<>();\n+            needLockDOS.forEach(lockDO -> needLockKeys.add(buildLockKey(lockDO.getRowKey())));\n+\n+            Pipeline pipeline1 = jedis.pipelined();\n+            needLockKeys.stream().forEachOrdered(\n+                    needLockKey -> pipeline1.hmget(needLockKey, XID, TABLE_NAME, PK, BRANCH_ID));\n+            List<Object> existedObjs = pipeline1.syncAndReturnAll();\n+            List<List<String>> existedLockInfos = (List<List<String>>) (List) existedObjs;\n+            Map<String, LockDO> needAddLock = new HashMap<>(needLockKeys.size(), 1);\n+\n+            for (int i = 0; i < needLockKeys.size(); i++) {\n+                List<String> existedLockInfo = existedLockInfos.get(i);\n+                if (CollectionUtils.isEmpty(existedLockInfo) ||\n+                        existedLockInfo.stream().allMatch(info -> info == null)) {\n+                    //If empty,we need to lock this row\n+                    needAddLock.put(needLockKeys.get(i), needLockDOS.get(i));\n                 } else {\n-                    LockDO existed = JSON.parseObject(existedValue, LockDO.class);\n-                    if (!StringUtils.equals(existed.getXid(), locks.get(i).getXid())) {\n+                    if (!StringUtils.equals(existedLockInfo.get(0), needLockXid)) {\n+                        //If not equals,means the rowkey is holding by another global transaction\n+                        LOGGER.error(\n+                                \"Acquire lock failed,Global lock on [{}:{}] is holding by xid {} branchId {}\",\n+                                existedLockInfo.get(1), existedLockInfo.get(2),\n+                                existedLockInfo.get(0), existedLockInfo.get(3));\n                         return false;\n                     }\n                 }\n             }\n-            if (map.isEmpty()) {\n+\n+            if (needAddLock.isEmpty()) {\n                 return true;\n             }\n             Pipeline pipeline = jedis.pipelined();\n             List<String> readyKeys = new ArrayList<>();\n-            map.forEach((key, value) -> {\n-                pipeline.setnx(key, value);\n+            needAddLock.forEach((key, value) -> {\n+                pipeline.hsetnx(key, XID, value.getXid());\n+                pipeline.hsetnx(key, TRANSACTION_ID, value.getTransactionId().toString());\n+                pipeline.hsetnx(key, BRANCH_ID, value.getBranchId().toString());\n+                pipeline.hsetnx(key, RESOURCE_ID, value.getResourceId());\n+                pipeline.hsetnx(key, TABLE_NAME, value.getTableName());\n+                pipeline.hsetnx(key, ROW_KEY, value.getRowKey());\n+                pipeline.hsetnx(key, PK, value.getPk());\n                 readyKeys.add(key);\n             });\n             List<Object> results = pipeline.syncAndReturnAll();\n-            for (int i = 0; i < results.size(); i++) {\n-                Long result = (long)results.get(i);\n+            List<Integer> results2 = (List<Integer>) (List) results;\n+            List<List<Integer>> partitions = Lists.partition(results2, 7);\n+\n+            Set<String> successSet = new HashSet<>();\n+            for (int i = 0; i < partitions.size(); i++) {\n                 String key = readyKeys.get(i);\n-                if (result != 1) {\n-                    status = result;\n+                if (partitions.get(i).contains(FAILED)) {\n+                    status = FAILED;\n                 } else {\n-                    successList.add(key);\n+                    successSet.add(key);\n                 }\n             }\n-            if (status != 1) {\n-                String[] rms = successList.toArray(new String[0]);\n-                if (rms.length > 0) {\n-                    jedis.del(rms);\n+\n+            //If someone has failed,all the lockkey which has been added need to be delete.\n+            if (FAILED.equals(status)) {\n+                if (successSet.size() > 0) {\n+                    Pipeline pipeline2 = jedis.pipelined();\n+                    successSet.forEach(locKey ->\n+                            pipeline2.hdel(locKey, XID, TRANSACTION_ID, BRANCH_ID, RESOURCE_ID,\n+                                    TABLE_NAME, ROW_KEY, PK));\n+                    pipeline2.sync();\n                 }\n                 return false;\n-            } else {\n-                try {\n-                    String xidLockKey = getXidLockKey(locks.get(0).getXid());\n-                    jedis.lpush(xidLockKey, readyKeys.toArray(new String[0]));\n-                } catch (Exception e) {\n-                    return false;\n-                }\n-                return true;\n             }\n+            String xidLockKey = buildXidLockKey(needLockXid);\n+            StringJoiner lockKeysString = new StringJoiner(SEMICOLON);\n+            needLockKeys.stream().forEach(lockKey -> lockKeysString.add(lockKey));\n+            jedis.hsetnx(xidLockKey, branchId.toString(), lockKeysString.toString());\n+            return true;\n         }\n     }\n \n     @Override\n     public boolean releaseLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        String[] keys = new String[rowLocks.size()];\n-        List<LockDO> locks = convertToLockDO(rowLocks);\n-        for (int i = 0; i < locks.size(); i++) {\n-            String key = getLockKey(locks.get(i).getRowKey());\n-            keys[i] = key;\n-        }\n+        String currentXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+        List<String> needReleaseKeys = new ArrayList<>(rowLocks.size());\n+        List<LockDO> needReleaseLocks = convertToLockDO(rowLocks);\n+        needReleaseLocks.stream()\n+                .forEach(lockDO -> needReleaseKeys.add(buildLockKey(lockDO.getRowKey())));\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String xidLockKey = getXidLockKey(locks.get(0).getXid());\n-            Pipeline pipeline = jedis.pipelined();\n-            pipeline.del(keys);\n-            Arrays.stream(keys).forEach(key -> pipeline.lrem(xidLockKey, 0, key));\n-            pipeline.sync();\n+            Pipeline pipelined = jedis.pipelined();\n+            needReleaseKeys.stream()\n+                    .forEach(key -> pipelined.hmget(key, XID, TABLE_NAME, PK, BRANCH_ID));\n+            List<Object> existedObjs = pipelined.syncAndReturnAll();\n+            List<List<String>> existedLockInfos = (List<List<String>>) (List) existedObjs;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f4cca9c462a0d18a58d8cdd23a7d97fdbaaeb4a"}, "originalPosition": 240}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjAwNDEzNg==", "bodyText": "only need to xid", "url": "https://github.com/seata/seata/pull/3016#discussion_r472004136", "createdAt": "2020-08-18T08:24:03Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -60,131 +87,179 @@\n      */\n     public RedisLocker() {\n         logQueryLimit =\n-            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+                ConfigurationFactory.getInstance()\n+                        .getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n     }\n \n     @Override\n     public boolean acquireLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        Set<String> successList = new HashSet<>();\n-        long status = 1;\n+        Integer status = SUCCEED;\n+        String needLockXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            List<LockDO> locks = convertToLockDO(rowLocks);\n-            if (locks.size() > 1) {\n-                locks =\n-                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            List<LockDO> needLockDOS = convertToLockDO(rowLocks);\n+            if (needLockDOS.size() >= 1) {\n+                needLockDOS = needLockDOS.stream().\n+                        filter(LambdaUtils.distinctByKey(LockDO::getRowKey))\n+                        .collect(Collectors.toList());\n             }\n-            List<String> existedKeyList = new ArrayList<>();\n-            locks.forEach(lockDO -> {\n-                existedKeyList.add(getLockKey(lockDO.getRowKey()));\n-            });\n-            List<String> lockList = jedis.mget(existedKeyList.toArray(new String[0]));\n-            Map<String, String> map = new HashMap<>(existedKeyList.size(), 1);\n-            for (int i = 0; i < existedKeyList.size(); i++) {\n-                String existedValue = lockList.get(i);\n-                if (existedValue == null) {\n-                    String key = existedKeyList.get(i);\n-                    map.put(key, JSON.toJSONString(locks.get(i)));\n+            List<String> needLockKeys = new ArrayList<>();\n+            needLockDOS.forEach(lockDO -> needLockKeys.add(buildLockKey(lockDO.getRowKey())));\n+\n+            Pipeline pipeline1 = jedis.pipelined();\n+            needLockKeys.stream().forEachOrdered(\n+                    needLockKey -> pipeline1.hmget(needLockKey, XID, TABLE_NAME, PK, BRANCH_ID));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f4cca9c462a0d18a58d8cdd23a7d97fdbaaeb4a"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjAwNDM0OQ==", "bodyText": "only need to xid", "url": "https://github.com/seata/seata/pull/3016#discussion_r472004349", "createdAt": "2020-08-18T08:24:24Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -60,131 +87,179 @@\n      */\n     public RedisLocker() {\n         logQueryLimit =\n-            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+                ConfigurationFactory.getInstance()\n+                        .getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n     }\n \n     @Override\n     public boolean acquireLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        Set<String> successList = new HashSet<>();\n-        long status = 1;\n+        Integer status = SUCCEED;\n+        String needLockXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            List<LockDO> locks = convertToLockDO(rowLocks);\n-            if (locks.size() > 1) {\n-                locks =\n-                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            List<LockDO> needLockDOS = convertToLockDO(rowLocks);\n+            if (needLockDOS.size() >= 1) {\n+                needLockDOS = needLockDOS.stream().\n+                        filter(LambdaUtils.distinctByKey(LockDO::getRowKey))\n+                        .collect(Collectors.toList());\n             }\n-            List<String> existedKeyList = new ArrayList<>();\n-            locks.forEach(lockDO -> {\n-                existedKeyList.add(getLockKey(lockDO.getRowKey()));\n-            });\n-            List<String> lockList = jedis.mget(existedKeyList.toArray(new String[0]));\n-            Map<String, String> map = new HashMap<>(existedKeyList.size(), 1);\n-            for (int i = 0; i < existedKeyList.size(); i++) {\n-                String existedValue = lockList.get(i);\n-                if (existedValue == null) {\n-                    String key = existedKeyList.get(i);\n-                    map.put(key, JSON.toJSONString(locks.get(i)));\n+            List<String> needLockKeys = new ArrayList<>();\n+            needLockDOS.forEach(lockDO -> needLockKeys.add(buildLockKey(lockDO.getRowKey())));\n+\n+            Pipeline pipeline1 = jedis.pipelined();\n+            needLockKeys.stream().forEachOrdered(\n+                    needLockKey -> pipeline1.hmget(needLockKey, XID, TABLE_NAME, PK, BRANCH_ID));\n+            List<Object> existedObjs = pipeline1.syncAndReturnAll();\n+            List<List<String>> existedLockInfos = (List<List<String>>) (List) existedObjs;\n+            Map<String, LockDO> needAddLock = new HashMap<>(needLockKeys.size(), 1);\n+\n+            for (int i = 0; i < needLockKeys.size(); i++) {\n+                List<String> existedLockInfo = existedLockInfos.get(i);\n+                if (CollectionUtils.isEmpty(existedLockInfo) ||\n+                        existedLockInfo.stream().allMatch(info -> info == null)) {\n+                    //If empty,we need to lock this row\n+                    needAddLock.put(needLockKeys.get(i), needLockDOS.get(i));\n                 } else {\n-                    LockDO existed = JSON.parseObject(existedValue, LockDO.class);\n-                    if (!StringUtils.equals(existed.getXid(), locks.get(i).getXid())) {\n+                    if (!StringUtils.equals(existedLockInfo.get(0), needLockXid)) {\n+                        //If not equals,means the rowkey is holding by another global transaction\n+                        LOGGER.error(\n+                                \"Acquire lock failed,Global lock on [{}:{}] is holding by xid {} branchId {}\",\n+                                existedLockInfo.get(1), existedLockInfo.get(2),\n+                                existedLockInfo.get(0), existedLockInfo.get(3));\n                         return false;\n                     }\n                 }\n             }\n-            if (map.isEmpty()) {\n+\n+            if (needAddLock.isEmpty()) {\n                 return true;\n             }\n             Pipeline pipeline = jedis.pipelined();\n             List<String> readyKeys = new ArrayList<>();\n-            map.forEach((key, value) -> {\n-                pipeline.setnx(key, value);\n+            needAddLock.forEach((key, value) -> {\n+                pipeline.hsetnx(key, XID, value.getXid());\n+                pipeline.hsetnx(key, TRANSACTION_ID, value.getTransactionId().toString());\n+                pipeline.hsetnx(key, BRANCH_ID, value.getBranchId().toString());\n+                pipeline.hsetnx(key, RESOURCE_ID, value.getResourceId());\n+                pipeline.hsetnx(key, TABLE_NAME, value.getTableName());\n+                pipeline.hsetnx(key, ROW_KEY, value.getRowKey());\n+                pipeline.hsetnx(key, PK, value.getPk());\n                 readyKeys.add(key);\n             });\n             List<Object> results = pipeline.syncAndReturnAll();\n-            for (int i = 0; i < results.size(); i++) {\n-                Long result = (long)results.get(i);\n+            List<Integer> results2 = (List<Integer>) (List) results;\n+            List<List<Integer>> partitions = Lists.partition(results2, 7);\n+\n+            Set<String> successSet = new HashSet<>();\n+            for (int i = 0; i < partitions.size(); i++) {\n                 String key = readyKeys.get(i);\n-                if (result != 1) {\n-                    status = result;\n+                if (partitions.get(i).contains(FAILED)) {\n+                    status = FAILED;\n                 } else {\n-                    successList.add(key);\n+                    successSet.add(key);\n                 }\n             }\n-            if (status != 1) {\n-                String[] rms = successList.toArray(new String[0]);\n-                if (rms.length > 0) {\n-                    jedis.del(rms);\n+\n+            //If someone has failed,all the lockkey which has been added need to be delete.\n+            if (FAILED.equals(status)) {\n+                if (successSet.size() > 0) {\n+                    Pipeline pipeline2 = jedis.pipelined();\n+                    successSet.forEach(locKey ->\n+                            pipeline2.hdel(locKey, XID, TRANSACTION_ID, BRANCH_ID, RESOURCE_ID,\n+                                    TABLE_NAME, ROW_KEY, PK));\n+                    pipeline2.sync();\n                 }\n                 return false;\n-            } else {\n-                try {\n-                    String xidLockKey = getXidLockKey(locks.get(0).getXid());\n-                    jedis.lpush(xidLockKey, readyKeys.toArray(new String[0]));\n-                } catch (Exception e) {\n-                    return false;\n-                }\n-                return true;\n             }\n+            String xidLockKey = buildXidLockKey(needLockXid);\n+            StringJoiner lockKeysString = new StringJoiner(SEMICOLON);\n+            needLockKeys.stream().forEach(lockKey -> lockKeysString.add(lockKey));\n+            jedis.hsetnx(xidLockKey, branchId.toString(), lockKeysString.toString());\n+            return true;\n         }\n     }\n \n     @Override\n     public boolean releaseLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        String[] keys = new String[rowLocks.size()];\n-        List<LockDO> locks = convertToLockDO(rowLocks);\n-        for (int i = 0; i < locks.size(); i++) {\n-            String key = getLockKey(locks.get(i).getRowKey());\n-            keys[i] = key;\n-        }\n+        String currentXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+        List<String> needReleaseKeys = new ArrayList<>(rowLocks.size());\n+        List<LockDO> needReleaseLocks = convertToLockDO(rowLocks);\n+        needReleaseLocks.stream()\n+                .forEach(lockDO -> needReleaseKeys.add(buildLockKey(lockDO.getRowKey())));\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String xidLockKey = getXidLockKey(locks.get(0).getXid());\n-            Pipeline pipeline = jedis.pipelined();\n-            pipeline.del(keys);\n-            Arrays.stream(keys).forEach(key -> pipeline.lrem(xidLockKey, 0, key));\n-            pipeline.sync();\n+            Pipeline pipelined = jedis.pipelined();\n+            needReleaseKeys.stream()\n+                    .forEach(key -> pipelined.hmget(key, XID, TABLE_NAME, PK, BRANCH_ID));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f4cca9c462a0d18a58d8cdd23a7d97fdbaaeb4a"}, "originalPosition": 238}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjAwNTU2NA==", "bodyText": "del needReleaseKeys. toArray (new String[0])", "url": "https://github.com/seata/seata/pull/3016#discussion_r472005564", "createdAt": "2020-08-18T08:26:19Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -60,131 +87,179 @@\n      */\n     public RedisLocker() {\n         logQueryLimit =\n-            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+                ConfigurationFactory.getInstance()\n+                        .getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n     }\n \n     @Override\n     public boolean acquireLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        Set<String> successList = new HashSet<>();\n-        long status = 1;\n+        Integer status = SUCCEED;\n+        String needLockXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            List<LockDO> locks = convertToLockDO(rowLocks);\n-            if (locks.size() > 1) {\n-                locks =\n-                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            List<LockDO> needLockDOS = convertToLockDO(rowLocks);\n+            if (needLockDOS.size() >= 1) {\n+                needLockDOS = needLockDOS.stream().\n+                        filter(LambdaUtils.distinctByKey(LockDO::getRowKey))\n+                        .collect(Collectors.toList());\n             }\n-            List<String> existedKeyList = new ArrayList<>();\n-            locks.forEach(lockDO -> {\n-                existedKeyList.add(getLockKey(lockDO.getRowKey()));\n-            });\n-            List<String> lockList = jedis.mget(existedKeyList.toArray(new String[0]));\n-            Map<String, String> map = new HashMap<>(existedKeyList.size(), 1);\n-            for (int i = 0; i < existedKeyList.size(); i++) {\n-                String existedValue = lockList.get(i);\n-                if (existedValue == null) {\n-                    String key = existedKeyList.get(i);\n-                    map.put(key, JSON.toJSONString(locks.get(i)));\n+            List<String> needLockKeys = new ArrayList<>();\n+            needLockDOS.forEach(lockDO -> needLockKeys.add(buildLockKey(lockDO.getRowKey())));\n+\n+            Pipeline pipeline1 = jedis.pipelined();\n+            needLockKeys.stream().forEachOrdered(\n+                    needLockKey -> pipeline1.hmget(needLockKey, XID, TABLE_NAME, PK, BRANCH_ID));\n+            List<Object> existedObjs = pipeline1.syncAndReturnAll();\n+            List<List<String>> existedLockInfos = (List<List<String>>) (List) existedObjs;\n+            Map<String, LockDO> needAddLock = new HashMap<>(needLockKeys.size(), 1);\n+\n+            for (int i = 0; i < needLockKeys.size(); i++) {\n+                List<String> existedLockInfo = existedLockInfos.get(i);\n+                if (CollectionUtils.isEmpty(existedLockInfo) ||\n+                        existedLockInfo.stream().allMatch(info -> info == null)) {\n+                    //If empty,we need to lock this row\n+                    needAddLock.put(needLockKeys.get(i), needLockDOS.get(i));\n                 } else {\n-                    LockDO existed = JSON.parseObject(existedValue, LockDO.class);\n-                    if (!StringUtils.equals(existed.getXid(), locks.get(i).getXid())) {\n+                    if (!StringUtils.equals(existedLockInfo.get(0), needLockXid)) {\n+                        //If not equals,means the rowkey is holding by another global transaction\n+                        LOGGER.error(\n+                                \"Acquire lock failed,Global lock on [{}:{}] is holding by xid {} branchId {}\",\n+                                existedLockInfo.get(1), existedLockInfo.get(2),\n+                                existedLockInfo.get(0), existedLockInfo.get(3));\n                         return false;\n                     }\n                 }\n             }\n-            if (map.isEmpty()) {\n+\n+            if (needAddLock.isEmpty()) {\n                 return true;\n             }\n             Pipeline pipeline = jedis.pipelined();\n             List<String> readyKeys = new ArrayList<>();\n-            map.forEach((key, value) -> {\n-                pipeline.setnx(key, value);\n+            needAddLock.forEach((key, value) -> {\n+                pipeline.hsetnx(key, XID, value.getXid());\n+                pipeline.hsetnx(key, TRANSACTION_ID, value.getTransactionId().toString());\n+                pipeline.hsetnx(key, BRANCH_ID, value.getBranchId().toString());\n+                pipeline.hsetnx(key, RESOURCE_ID, value.getResourceId());\n+                pipeline.hsetnx(key, TABLE_NAME, value.getTableName());\n+                pipeline.hsetnx(key, ROW_KEY, value.getRowKey());\n+                pipeline.hsetnx(key, PK, value.getPk());\n                 readyKeys.add(key);\n             });\n             List<Object> results = pipeline.syncAndReturnAll();\n-            for (int i = 0; i < results.size(); i++) {\n-                Long result = (long)results.get(i);\n+            List<Integer> results2 = (List<Integer>) (List) results;\n+            List<List<Integer>> partitions = Lists.partition(results2, 7);\n+\n+            Set<String> successSet = new HashSet<>();\n+            for (int i = 0; i < partitions.size(); i++) {\n                 String key = readyKeys.get(i);\n-                if (result != 1) {\n-                    status = result;\n+                if (partitions.get(i).contains(FAILED)) {\n+                    status = FAILED;\n                 } else {\n-                    successList.add(key);\n+                    successSet.add(key);\n                 }\n             }\n-            if (status != 1) {\n-                String[] rms = successList.toArray(new String[0]);\n-                if (rms.length > 0) {\n-                    jedis.del(rms);\n+\n+            //If someone has failed,all the lockkey which has been added need to be delete.\n+            if (FAILED.equals(status)) {\n+                if (successSet.size() > 0) {\n+                    Pipeline pipeline2 = jedis.pipelined();\n+                    successSet.forEach(locKey ->\n+                            pipeline2.hdel(locKey, XID, TRANSACTION_ID, BRANCH_ID, RESOURCE_ID,\n+                                    TABLE_NAME, ROW_KEY, PK));\n+                    pipeline2.sync();\n                 }\n                 return false;\n-            } else {\n-                try {\n-                    String xidLockKey = getXidLockKey(locks.get(0).getXid());\n-                    jedis.lpush(xidLockKey, readyKeys.toArray(new String[0]));\n-                } catch (Exception e) {\n-                    return false;\n-                }\n-                return true;\n             }\n+            String xidLockKey = buildXidLockKey(needLockXid);\n+            StringJoiner lockKeysString = new StringJoiner(SEMICOLON);\n+            needLockKeys.stream().forEach(lockKey -> lockKeysString.add(lockKey));\n+            jedis.hsetnx(xidLockKey, branchId.toString(), lockKeysString.toString());\n+            return true;\n         }\n     }\n \n     @Override\n     public boolean releaseLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        String[] keys = new String[rowLocks.size()];\n-        List<LockDO> locks = convertToLockDO(rowLocks);\n-        for (int i = 0; i < locks.size(); i++) {\n-            String key = getLockKey(locks.get(i).getRowKey());\n-            keys[i] = key;\n-        }\n+        String currentXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+        List<String> needReleaseKeys = new ArrayList<>(rowLocks.size());\n+        List<LockDO> needReleaseLocks = convertToLockDO(rowLocks);\n+        needReleaseLocks.stream()\n+                .forEach(lockDO -> needReleaseKeys.add(buildLockKey(lockDO.getRowKey())));\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String xidLockKey = getXidLockKey(locks.get(0).getXid());\n-            Pipeline pipeline = jedis.pipelined();\n-            pipeline.del(keys);\n-            Arrays.stream(keys).forEach(key -> pipeline.lrem(xidLockKey, 0, key));\n-            pipeline.sync();\n+            Pipeline pipelined = jedis.pipelined();\n+            needReleaseKeys.stream()\n+                    .forEach(key -> pipelined.hmget(key, XID, TABLE_NAME, PK, BRANCH_ID));\n+            List<Object> existedObjs = pipelined.syncAndReturnAll();\n+            List<List<String>> existedLockInfos = (List<List<String>>) (List) existedObjs;\n+\n+            for (int i = 0; i < existedLockInfos.size(); i++) {\n+                List<String> existedLockInfo = existedLockInfos.get(i);\n+                if (CollectionUtils.isNotEmpty(existedLockInfo) ||\n+                        existedLockInfo.stream().allMatch(info -> info != null)) {\n+                    if (!StringUtils.equals(currentXid, existedLockInfo.get(0))) {\n+                        LOGGER.error(\n+                                \"Release lock failed,Global lock on [{}:{}] is holding by xid {} branchId {}\",\n+                                existedLockInfo.get(1), existedLockInfo.get(2),\n+                                existedLockInfo.get(0), existedLockInfo.get(3));\n+                        return false;\n+                    }\n+                }\n+            }\n+\n+            Pipeline pipelined1 = jedis.pipelined();\n+            needReleaseKeys.stream().forEach(key ->\n+                    pipelined1.hdel(key, XID, TRANSACTION_ID, BRANCH_ID, RESOURCE_ID,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f4cca9c462a0d18a58d8cdd23a7d97fdbaaeb4a"}, "originalPosition": 258}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjAxMTU1NQ==", "bodyText": "del rowkey", "url": "https://github.com/seata/seata/pull/3016#discussion_r472011555", "createdAt": "2020-08-18T08:35:51Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -60,131 +87,179 @@\n      */\n     public RedisLocker() {\n         logQueryLimit =\n-            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+                ConfigurationFactory.getInstance()\n+                        .getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n     }\n \n     @Override\n     public boolean acquireLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        Set<String> successList = new HashSet<>();\n-        long status = 1;\n+        Integer status = SUCCEED;\n+        String needLockXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            List<LockDO> locks = convertToLockDO(rowLocks);\n-            if (locks.size() > 1) {\n-                locks =\n-                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            List<LockDO> needLockDOS = convertToLockDO(rowLocks);\n+            if (needLockDOS.size() >= 1) {\n+                needLockDOS = needLockDOS.stream().\n+                        filter(LambdaUtils.distinctByKey(LockDO::getRowKey))\n+                        .collect(Collectors.toList());\n             }\n-            List<String> existedKeyList = new ArrayList<>();\n-            locks.forEach(lockDO -> {\n-                existedKeyList.add(getLockKey(lockDO.getRowKey()));\n-            });\n-            List<String> lockList = jedis.mget(existedKeyList.toArray(new String[0]));\n-            Map<String, String> map = new HashMap<>(existedKeyList.size(), 1);\n-            for (int i = 0; i < existedKeyList.size(); i++) {\n-                String existedValue = lockList.get(i);\n-                if (existedValue == null) {\n-                    String key = existedKeyList.get(i);\n-                    map.put(key, JSON.toJSONString(locks.get(i)));\n+            List<String> needLockKeys = new ArrayList<>();\n+            needLockDOS.forEach(lockDO -> needLockKeys.add(buildLockKey(lockDO.getRowKey())));\n+\n+            Pipeline pipeline1 = jedis.pipelined();\n+            needLockKeys.stream().forEachOrdered(\n+                    needLockKey -> pipeline1.hmget(needLockKey, XID, TABLE_NAME, PK, BRANCH_ID));\n+            List<Object> existedObjs = pipeline1.syncAndReturnAll();\n+            List<List<String>> existedLockInfos = (List<List<String>>) (List) existedObjs;\n+            Map<String, LockDO> needAddLock = new HashMap<>(needLockKeys.size(), 1);\n+\n+            for (int i = 0; i < needLockKeys.size(); i++) {\n+                List<String> existedLockInfo = existedLockInfos.get(i);\n+                if (CollectionUtils.isEmpty(existedLockInfo) ||\n+                        existedLockInfo.stream().allMatch(info -> info == null)) {\n+                    //If empty,we need to lock this row\n+                    needAddLock.put(needLockKeys.get(i), needLockDOS.get(i));\n                 } else {\n-                    LockDO existed = JSON.parseObject(existedValue, LockDO.class);\n-                    if (!StringUtils.equals(existed.getXid(), locks.get(i).getXid())) {\n+                    if (!StringUtils.equals(existedLockInfo.get(0), needLockXid)) {\n+                        //If not equals,means the rowkey is holding by another global transaction\n+                        LOGGER.error(\n+                                \"Acquire lock failed,Global lock on [{}:{}] is holding by xid {} branchId {}\",\n+                                existedLockInfo.get(1), existedLockInfo.get(2),\n+                                existedLockInfo.get(0), existedLockInfo.get(3));\n                         return false;\n                     }\n                 }\n             }\n-            if (map.isEmpty()) {\n+\n+            if (needAddLock.isEmpty()) {\n                 return true;\n             }\n             Pipeline pipeline = jedis.pipelined();\n             List<String> readyKeys = new ArrayList<>();\n-            map.forEach((key, value) -> {\n-                pipeline.setnx(key, value);\n+            needAddLock.forEach((key, value) -> {\n+                pipeline.hsetnx(key, XID, value.getXid());\n+                pipeline.hsetnx(key, TRANSACTION_ID, value.getTransactionId().toString());\n+                pipeline.hsetnx(key, BRANCH_ID, value.getBranchId().toString());\n+                pipeline.hsetnx(key, RESOURCE_ID, value.getResourceId());\n+                pipeline.hsetnx(key, TABLE_NAME, value.getTableName());\n+                pipeline.hsetnx(key, ROW_KEY, value.getRowKey());\n+                pipeline.hsetnx(key, PK, value.getPk());\n                 readyKeys.add(key);\n             });\n             List<Object> results = pipeline.syncAndReturnAll();\n-            for (int i = 0; i < results.size(); i++) {\n-                Long result = (long)results.get(i);\n+            List<Integer> results2 = (List<Integer>) (List) results;\n+            List<List<Integer>> partitions = Lists.partition(results2, 7);\n+\n+            Set<String> successSet = new HashSet<>();\n+            for (int i = 0; i < partitions.size(); i++) {\n                 String key = readyKeys.get(i);\n-                if (result != 1) {\n-                    status = result;\n+                if (partitions.get(i).contains(FAILED)) {\n+                    status = FAILED;\n                 } else {\n-                    successList.add(key);\n+                    successSet.add(key);\n                 }\n             }\n-            if (status != 1) {\n-                String[] rms = successList.toArray(new String[0]);\n-                if (rms.length > 0) {\n-                    jedis.del(rms);\n+\n+            //If someone has failed,all the lockkey which has been added need to be delete.\n+            if (FAILED.equals(status)) {\n+                if (successSet.size() > 0) {\n+                    Pipeline pipeline2 = jedis.pipelined();\n+                    successSet.forEach(locKey ->\n+                            pipeline2.hdel(locKey, XID, TRANSACTION_ID, BRANCH_ID, RESOURCE_ID,\n+                                    TABLE_NAME, ROW_KEY, PK));\n+                    pipeline2.sync();\n                 }\n                 return false;\n-            } else {\n-                try {\n-                    String xidLockKey = getXidLockKey(locks.get(0).getXid());\n-                    jedis.lpush(xidLockKey, readyKeys.toArray(new String[0]));\n-                } catch (Exception e) {\n-                    return false;\n-                }\n-                return true;\n             }\n+            String xidLockKey = buildXidLockKey(needLockXid);\n+            StringJoiner lockKeysString = new StringJoiner(SEMICOLON);\n+            needLockKeys.stream().forEach(lockKey -> lockKeysString.add(lockKey));\n+            jedis.hsetnx(xidLockKey, branchId.toString(), lockKeysString.toString());\n+            return true;\n         }\n     }\n \n     @Override\n     public boolean releaseLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        String[] keys = new String[rowLocks.size()];\n-        List<LockDO> locks = convertToLockDO(rowLocks);\n-        for (int i = 0; i < locks.size(); i++) {\n-            String key = getLockKey(locks.get(i).getRowKey());\n-            keys[i] = key;\n-        }\n+        String currentXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+        List<String> needReleaseKeys = new ArrayList<>(rowLocks.size());\n+        List<LockDO> needReleaseLocks = convertToLockDO(rowLocks);\n+        needReleaseLocks.stream()\n+                .forEach(lockDO -> needReleaseKeys.add(buildLockKey(lockDO.getRowKey())));\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String xidLockKey = getXidLockKey(locks.get(0).getXid());\n-            Pipeline pipeline = jedis.pipelined();\n-            pipeline.del(keys);\n-            Arrays.stream(keys).forEach(key -> pipeline.lrem(xidLockKey, 0, key));\n-            pipeline.sync();\n+            Pipeline pipelined = jedis.pipelined();\n+            needReleaseKeys.stream()\n+                    .forEach(key -> pipelined.hmget(key, XID, TABLE_NAME, PK, BRANCH_ID));\n+            List<Object> existedObjs = pipelined.syncAndReturnAll();\n+            List<List<String>> existedLockInfos = (List<List<String>>) (List) existedObjs;\n+\n+            for (int i = 0; i < existedLockInfos.size(); i++) {\n+                List<String> existedLockInfo = existedLockInfos.get(i);\n+                if (CollectionUtils.isNotEmpty(existedLockInfo) ||\n+                        existedLockInfo.stream().allMatch(info -> info != null)) {\n+                    if (!StringUtils.equals(currentXid, existedLockInfo.get(0))) {\n+                        LOGGER.error(\n+                                \"Release lock failed,Global lock on [{}:{}] is holding by xid {} branchId {}\",\n+                                existedLockInfo.get(1), existedLockInfo.get(2),\n+                                existedLockInfo.get(0), existedLockInfo.get(3));\n+                        return false;\n+                    }\n+                }\n+            }\n+\n+            Pipeline pipelined1 = jedis.pipelined();\n+            needReleaseKeys.stream().forEach(key ->\n+                    pipelined1.hdel(key, XID, TRANSACTION_ID, BRANCH_ID, RESOURCE_ID,\n+                            TABLE_NAME, ROW_KEY, PK));\n+            pipelined1.hdel(buildXidLockKey(currentXid), branchId.toString());\n+            pipelined1.sync();\n             return true;\n         }\n     }\n \n     @Override\n     public boolean releaseLock(String xid, List<Long> branchIds) {\n         if (CollectionUtils.isEmpty(branchIds)) {\n-            // no lock\n             return true;\n         }\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String lockListKey = getXidLockKey(xid);\n-            Set<String> keys = lRange(jedis, lockListKey);\n-            if (CollectionUtils.isNotEmpty(keys)) {\n-                List<String> delKeys = new ArrayList<>();\n-                List<String> values = jedis.mget(keys.toArray(new String[0]));\n-                for (String value : values) {\n-                    Iterator<Long> it = branchIds.iterator();\n-                    LockDO lock = JSON.parseObject(value, LockDO.class);\n-                    while (it.hasNext()) {\n-                        Long branchId = it.next();\n-                        if (lock != null && Objects.equals(lock.getBranchId(), branchId)) {\n-                            delKeys.add(getLockKey(lock.getRowKey()));\n-                            break;\n+            String xidLockKey = buildXidLockKey(xid);\n+            String[] branchIdsArray = new String[branchIds.size()];\n+            for (int i = 0; i < branchIds.size(); i++) {\n+                branchIdsArray[i] = branchIds.get(i).toString();\n+            }\n+            List<String> rowKeys = jedis.hmget(xidLockKey, branchIdsArray);\n+\n+            if (CollectionUtils.isNotEmpty(rowKeys)) {\n+                Pipeline pipelined = jedis.pipelined();\n+                pipelined.hdel(xidLockKey, branchIdsArray);\n+                rowKeys.stream().forEach(rowKeyStr -> {\n+                    if (StringUtils.isNotEmpty(rowKeyStr)) {\n+                        if (rowKeyStr.contains(SEMICOLON)) {\n+                            String[] keys = rowKeyStr.split(SEMICOLON);\n+                            Arrays.asList(keys).stream().forEach(rowKey -> {\n+                                if (StringUtils.isNotEmpty(rowKey)) {\n+                                    pipelined.hdel(rowKey, XID, TRANSACTION_ID, BRANCH_ID,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f4cca9c462a0d18a58d8cdd23a7d97fdbaaeb4a"}, "originalPosition": 302}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjAxMTYzMQ==", "bodyText": "del rowkey", "url": "https://github.com/seata/seata/pull/3016#discussion_r472011631", "createdAt": "2020-08-18T08:35:58Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -60,131 +87,179 @@\n      */\n     public RedisLocker() {\n         logQueryLimit =\n-            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+                ConfigurationFactory.getInstance()\n+                        .getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n     }\n \n     @Override\n     public boolean acquireLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        Set<String> successList = new HashSet<>();\n-        long status = 1;\n+        Integer status = SUCCEED;\n+        String needLockXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            List<LockDO> locks = convertToLockDO(rowLocks);\n-            if (locks.size() > 1) {\n-                locks =\n-                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            List<LockDO> needLockDOS = convertToLockDO(rowLocks);\n+            if (needLockDOS.size() >= 1) {\n+                needLockDOS = needLockDOS.stream().\n+                        filter(LambdaUtils.distinctByKey(LockDO::getRowKey))\n+                        .collect(Collectors.toList());\n             }\n-            List<String> existedKeyList = new ArrayList<>();\n-            locks.forEach(lockDO -> {\n-                existedKeyList.add(getLockKey(lockDO.getRowKey()));\n-            });\n-            List<String> lockList = jedis.mget(existedKeyList.toArray(new String[0]));\n-            Map<String, String> map = new HashMap<>(existedKeyList.size(), 1);\n-            for (int i = 0; i < existedKeyList.size(); i++) {\n-                String existedValue = lockList.get(i);\n-                if (existedValue == null) {\n-                    String key = existedKeyList.get(i);\n-                    map.put(key, JSON.toJSONString(locks.get(i)));\n+            List<String> needLockKeys = new ArrayList<>();\n+            needLockDOS.forEach(lockDO -> needLockKeys.add(buildLockKey(lockDO.getRowKey())));\n+\n+            Pipeline pipeline1 = jedis.pipelined();\n+            needLockKeys.stream().forEachOrdered(\n+                    needLockKey -> pipeline1.hmget(needLockKey, XID, TABLE_NAME, PK, BRANCH_ID));\n+            List<Object> existedObjs = pipeline1.syncAndReturnAll();\n+            List<List<String>> existedLockInfos = (List<List<String>>) (List) existedObjs;\n+            Map<String, LockDO> needAddLock = new HashMap<>(needLockKeys.size(), 1);\n+\n+            for (int i = 0; i < needLockKeys.size(); i++) {\n+                List<String> existedLockInfo = existedLockInfos.get(i);\n+                if (CollectionUtils.isEmpty(existedLockInfo) ||\n+                        existedLockInfo.stream().allMatch(info -> info == null)) {\n+                    //If empty,we need to lock this row\n+                    needAddLock.put(needLockKeys.get(i), needLockDOS.get(i));\n                 } else {\n-                    LockDO existed = JSON.parseObject(existedValue, LockDO.class);\n-                    if (!StringUtils.equals(existed.getXid(), locks.get(i).getXid())) {\n+                    if (!StringUtils.equals(existedLockInfo.get(0), needLockXid)) {\n+                        //If not equals,means the rowkey is holding by another global transaction\n+                        LOGGER.error(\n+                                \"Acquire lock failed,Global lock on [{}:{}] is holding by xid {} branchId {}\",\n+                                existedLockInfo.get(1), existedLockInfo.get(2),\n+                                existedLockInfo.get(0), existedLockInfo.get(3));\n                         return false;\n                     }\n                 }\n             }\n-            if (map.isEmpty()) {\n+\n+            if (needAddLock.isEmpty()) {\n                 return true;\n             }\n             Pipeline pipeline = jedis.pipelined();\n             List<String> readyKeys = new ArrayList<>();\n-            map.forEach((key, value) -> {\n-                pipeline.setnx(key, value);\n+            needAddLock.forEach((key, value) -> {\n+                pipeline.hsetnx(key, XID, value.getXid());\n+                pipeline.hsetnx(key, TRANSACTION_ID, value.getTransactionId().toString());\n+                pipeline.hsetnx(key, BRANCH_ID, value.getBranchId().toString());\n+                pipeline.hsetnx(key, RESOURCE_ID, value.getResourceId());\n+                pipeline.hsetnx(key, TABLE_NAME, value.getTableName());\n+                pipeline.hsetnx(key, ROW_KEY, value.getRowKey());\n+                pipeline.hsetnx(key, PK, value.getPk());\n                 readyKeys.add(key);\n             });\n             List<Object> results = pipeline.syncAndReturnAll();\n-            for (int i = 0; i < results.size(); i++) {\n-                Long result = (long)results.get(i);\n+            List<Integer> results2 = (List<Integer>) (List) results;\n+            List<List<Integer>> partitions = Lists.partition(results2, 7);\n+\n+            Set<String> successSet = new HashSet<>();\n+            for (int i = 0; i < partitions.size(); i++) {\n                 String key = readyKeys.get(i);\n-                if (result != 1) {\n-                    status = result;\n+                if (partitions.get(i).contains(FAILED)) {\n+                    status = FAILED;\n                 } else {\n-                    successList.add(key);\n+                    successSet.add(key);\n                 }\n             }\n-            if (status != 1) {\n-                String[] rms = successList.toArray(new String[0]);\n-                if (rms.length > 0) {\n-                    jedis.del(rms);\n+\n+            //If someone has failed,all the lockkey which has been added need to be delete.\n+            if (FAILED.equals(status)) {\n+                if (successSet.size() > 0) {\n+                    Pipeline pipeline2 = jedis.pipelined();\n+                    successSet.forEach(locKey ->\n+                            pipeline2.hdel(locKey, XID, TRANSACTION_ID, BRANCH_ID, RESOURCE_ID,\n+                                    TABLE_NAME, ROW_KEY, PK));\n+                    pipeline2.sync();\n                 }\n                 return false;\n-            } else {\n-                try {\n-                    String xidLockKey = getXidLockKey(locks.get(0).getXid());\n-                    jedis.lpush(xidLockKey, readyKeys.toArray(new String[0]));\n-                } catch (Exception e) {\n-                    return false;\n-                }\n-                return true;\n             }\n+            String xidLockKey = buildXidLockKey(needLockXid);\n+            StringJoiner lockKeysString = new StringJoiner(SEMICOLON);\n+            needLockKeys.stream().forEach(lockKey -> lockKeysString.add(lockKey));\n+            jedis.hsetnx(xidLockKey, branchId.toString(), lockKeysString.toString());\n+            return true;\n         }\n     }\n \n     @Override\n     public boolean releaseLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        String[] keys = new String[rowLocks.size()];\n-        List<LockDO> locks = convertToLockDO(rowLocks);\n-        for (int i = 0; i < locks.size(); i++) {\n-            String key = getLockKey(locks.get(i).getRowKey());\n-            keys[i] = key;\n-        }\n+        String currentXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+        List<String> needReleaseKeys = new ArrayList<>(rowLocks.size());\n+        List<LockDO> needReleaseLocks = convertToLockDO(rowLocks);\n+        needReleaseLocks.stream()\n+                .forEach(lockDO -> needReleaseKeys.add(buildLockKey(lockDO.getRowKey())));\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String xidLockKey = getXidLockKey(locks.get(0).getXid());\n-            Pipeline pipeline = jedis.pipelined();\n-            pipeline.del(keys);\n-            Arrays.stream(keys).forEach(key -> pipeline.lrem(xidLockKey, 0, key));\n-            pipeline.sync();\n+            Pipeline pipelined = jedis.pipelined();\n+            needReleaseKeys.stream()\n+                    .forEach(key -> pipelined.hmget(key, XID, TABLE_NAME, PK, BRANCH_ID));\n+            List<Object> existedObjs = pipelined.syncAndReturnAll();\n+            List<List<String>> existedLockInfos = (List<List<String>>) (List) existedObjs;\n+\n+            for (int i = 0; i < existedLockInfos.size(); i++) {\n+                List<String> existedLockInfo = existedLockInfos.get(i);\n+                if (CollectionUtils.isNotEmpty(existedLockInfo) ||\n+                        existedLockInfo.stream().allMatch(info -> info != null)) {\n+                    if (!StringUtils.equals(currentXid, existedLockInfo.get(0))) {\n+                        LOGGER.error(\n+                                \"Release lock failed,Global lock on [{}:{}] is holding by xid {} branchId {}\",\n+                                existedLockInfo.get(1), existedLockInfo.get(2),\n+                                existedLockInfo.get(0), existedLockInfo.get(3));\n+                        return false;\n+                    }\n+                }\n+            }\n+\n+            Pipeline pipelined1 = jedis.pipelined();\n+            needReleaseKeys.stream().forEach(key ->\n+                    pipelined1.hdel(key, XID, TRANSACTION_ID, BRANCH_ID, RESOURCE_ID,\n+                            TABLE_NAME, ROW_KEY, PK));\n+            pipelined1.hdel(buildXidLockKey(currentXid), branchId.toString());\n+            pipelined1.sync();\n             return true;\n         }\n     }\n \n     @Override\n     public boolean releaseLock(String xid, List<Long> branchIds) {\n         if (CollectionUtils.isEmpty(branchIds)) {\n-            // no lock\n             return true;\n         }\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String lockListKey = getXidLockKey(xid);\n-            Set<String> keys = lRange(jedis, lockListKey);\n-            if (CollectionUtils.isNotEmpty(keys)) {\n-                List<String> delKeys = new ArrayList<>();\n-                List<String> values = jedis.mget(keys.toArray(new String[0]));\n-                for (String value : values) {\n-                    Iterator<Long> it = branchIds.iterator();\n-                    LockDO lock = JSON.parseObject(value, LockDO.class);\n-                    while (it.hasNext()) {\n-                        Long branchId = it.next();\n-                        if (lock != null && Objects.equals(lock.getBranchId(), branchId)) {\n-                            delKeys.add(getLockKey(lock.getRowKey()));\n-                            break;\n+            String xidLockKey = buildXidLockKey(xid);\n+            String[] branchIdsArray = new String[branchIds.size()];\n+            for (int i = 0; i < branchIds.size(); i++) {\n+                branchIdsArray[i] = branchIds.get(i).toString();\n+            }\n+            List<String> rowKeys = jedis.hmget(xidLockKey, branchIdsArray);\n+\n+            if (CollectionUtils.isNotEmpty(rowKeys)) {\n+                Pipeline pipelined = jedis.pipelined();\n+                pipelined.hdel(xidLockKey, branchIdsArray);\n+                rowKeys.stream().forEach(rowKeyStr -> {\n+                    if (StringUtils.isNotEmpty(rowKeyStr)) {\n+                        if (rowKeyStr.contains(SEMICOLON)) {\n+                            String[] keys = rowKeyStr.split(SEMICOLON);\n+                            Arrays.asList(keys).stream().forEach(rowKey -> {\n+                                if (StringUtils.isNotEmpty(rowKey)) {\n+                                    pipelined.hdel(rowKey, XID, TRANSACTION_ID, BRANCH_ID,\n+                                            RESOURCE_ID, TABLE_NAME, ROW_KEY, PK);\n+                                }\n+                            });\n+                        } else {\n+                            pipelined.hdel(rowKeyStr, XID, TRANSACTION_ID, BRANCH_ID, RESOURCE_ID,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f4cca9c462a0d18a58d8cdd23a7d97fdbaaeb4a"}, "originalPosition": 307}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjAxMjYxNw==", "bodyText": "List existedXids = (List) (List) pipeline.syncAndReturnAll();", "url": "https://github.com/seata/seata/pull/3016#discussion_r472012617", "createdAt": "2020-08-18T08:37:34Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -207,41 +282,23 @@ public boolean isLockable(List<RowLock> rowLocks) {\n             List<LockDO> locks = convertToLockDO(rowLocks);\n             Set<String> lockKeys = new HashSet<>();\n             for (LockDO rowlock : locks) {\n-                lockKeys.add(getLockKey(rowlock.getRowKey()));\n+                lockKeys.add(buildLockKey(rowlock.getRowKey()));\n             }\n-            List<String> rowlockJsons = jedis.mget(lockKeys.toArray(new String[0]));\n+\n             String xid = rowLocks.get(0).getXid();\n-            for (String rowlockJson : rowlockJsons) {\n-                if (!StringUtils.isEmpty(rowlockJson)) {\n-                    LockDO lock = JSON.parseObject(rowlockJson, LockDO.class);\n-                    if (lock != null && !Objects.equals(lock.getXid(), xid)) {\n-                        return false;\n-                    }\n-                }\n-            }\n+            Pipeline pipeline = jedis.pipelined();\n+            lockKeys.stream().forEach(key -> pipeline.hget(key, XID));\n+            List<Object> existedRowLockXid = pipeline.syncAndReturnAll();\n+            List<String> existedXids = (List<String>) (List) existedRowLockXid;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f4cca9c462a0d18a58d8cdd23a7d97fdbaaeb4a"}, "originalPosition": 347}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f4a0ebb5653704e50bccc07f0b39a60ec9f2d131", "author": {"user": {"login": "lightClouds917", "name": "IT\u4e91\u6e05"}}, "url": "https://github.com/seata/seata/commit/f4a0ebb5653704e50bccc07f0b39a60ec9f2d131", "committedDate": "2020-08-18T11:16:49Z", "message": "optimize:the code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "93bb511d77726bee31b4f21fbb72561314497ba6", "author": {"user": {"login": "lightClouds917", "name": "IT\u4e91\u6e05"}}, "url": "https://github.com/seata/seata/commit/93bb511d77726bee31b4f21fbb72561314497ba6", "committedDate": "2020-08-18T11:30:34Z", "message": "Merge branch 'develop' of github.com:seata/seata into refactor_redis"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5NDUzMzQ4", "url": "https://github.com/seata/seata/pull/3016#pullrequestreview-469453348", "createdAt": "2020-08-18T13:27:08Z", "commit": {"oid": "93bb511d77726bee31b4f21fbb72561314497ba6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMzoyNzowOFrOHCUgTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMzoyNzowOFrOHCUgTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjE5NTE1MQ==", "bodyText": "hset enough", "url": "https://github.com/seata/seata/pull/3016#discussion_r472195151", "createdAt": "2020-08-18T13:27:08Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -60,131 +82,139 @@\n      */\n     public RedisLocker() {\n         logQueryLimit =\n-            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+                ConfigurationFactory.getInstance()\n+                        .getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n     }\n \n     @Override\n     public boolean acquireLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        Set<String> successList = new HashSet<>();\n-        long status = 1;\n+        Integer status = SUCCEED;\n+        String needLockXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            List<LockDO> locks = convertToLockDO(rowLocks);\n-            if (locks.size() > 1) {\n-                locks =\n-                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            List<LockDO> needLockDOS = convertToLockDO(rowLocks);\n+            if (needLockDOS.size() >= 1) {\n+                needLockDOS = needLockDOS.stream().\n+                        filter(LambdaUtils.distinctByKey(LockDO::getRowKey))\n+                        .collect(Collectors.toList());\n             }\n-            List<String> existedKeyList = new ArrayList<>();\n-            locks.forEach(lockDO -> {\n-                existedKeyList.add(getLockKey(lockDO.getRowKey()));\n-            });\n-            List<String> lockList = jedis.mget(existedKeyList.toArray(new String[0]));\n-            Map<String, String> map = new HashMap<>(existedKeyList.size(), 1);\n-            for (int i = 0; i < existedKeyList.size(); i++) {\n-                String existedValue = lockList.get(i);\n-                if (existedValue == null) {\n-                    String key = existedKeyList.get(i);\n-                    map.put(key, JSON.toJSONString(locks.get(i)));\n+            List<String> needLockKeys = new ArrayList<>();\n+            needLockDOS.forEach(lockDO -> needLockKeys.add(buildLockKey(lockDO.getRowKey())));\n+\n+            Pipeline pipeline1 = jedis.pipelined();\n+            needLockKeys.stream().forEachOrdered(needLockKey -> pipeline1.hget(needLockKey, XID));\n+            List<String> existedLockInfos = (List<String>) (List) pipeline1.syncAndReturnAll();\n+            Map<String, LockDO> needAddLock = new HashMap<>(needLockKeys.size(), 1);\n+\n+            for (int i = 0; i < needLockKeys.size(); i++) {\n+                String existedLockXid = existedLockInfos.get(i);\n+                if (StringUtils.isEmpty(existedLockXid)) {\n+                    //If empty,we need to lock this row\n+                    needAddLock.put(needLockKeys.get(i), needLockDOS.get(i));\n                 } else {\n-                    LockDO existed = JSON.parseObject(existedValue, LockDO.class);\n-                    if (!StringUtils.equals(existed.getXid(), locks.get(i).getXid())) {\n+                    if (!StringUtils.equals(existedLockXid, needLockXid)) {\n+                        //If not equals,means the rowkey is holding by another global transaction\n                         return false;\n                     }\n                 }\n             }\n-            if (map.isEmpty()) {\n+\n+            if (needAddLock.isEmpty()) {\n                 return true;\n             }\n             Pipeline pipeline = jedis.pipelined();\n             List<String> readyKeys = new ArrayList<>();\n-            map.forEach((key, value) -> {\n-                pipeline.setnx(key, value);\n+            needAddLock.forEach((key, value) -> {\n+                pipeline.hsetnx(key, XID, value.getXid());\n+                pipeline.hsetnx(key, TRANSACTION_ID, value.getTransactionId().toString());\n+                pipeline.hsetnx(key, BRANCH_ID, value.getBranchId().toString());\n+                pipeline.hsetnx(key, RESOURCE_ID, value.getResourceId());\n+                pipeline.hsetnx(key, TABLE_NAME, value.getTableName());\n+                pipeline.hsetnx(key, ROW_KEY, value.getRowKey());\n+                pipeline.hsetnx(key, PK, value.getPk());\n                 readyKeys.add(key);\n             });\n-            List<Object> results = pipeline.syncAndReturnAll();\n-            for (int i = 0; i < results.size(); i++) {\n-                Long result = (long)results.get(i);\n+            List<Integer> results = (List<Integer>) (List) pipeline.syncAndReturnAll();\n+            List<List<Integer>> partitions = Lists.partition(results, 7);\n+\n+            String[] success = new String[partitions.size()];\n+            for (int i = 0; i < partitions.size(); i++) {\n                 String key = readyKeys.get(i);\n-                if (result != 1) {\n-                    status = result;\n+                if (partitions.get(i).contains(FAILED)) {\n+                    status = FAILED;\n                 } else {\n-                    successList.add(key);\n+                    success[0] = key;\n                 }\n             }\n-            if (status != 1) {\n-                String[] rms = successList.toArray(new String[0]);\n-                if (rms.length > 0) {\n-                    jedis.del(rms);\n+\n+            //If someone has failed,all the lockkey which has been added need to be delete.\n+            if (FAILED.equals(status)) {\n+                if (success.length > 0) {\n+                    jedis.del(success);\n                 }\n                 return false;\n-            } else {\n-                try {\n-                    String xidLockKey = getXidLockKey(locks.get(0).getXid());\n-                    jedis.lpush(xidLockKey, readyKeys.toArray(new String[0]));\n-                } catch (Exception e) {\n-                    return false;\n-                }\n-                return true;\n             }\n+            String xidLockKey = buildXidLockKey(needLockXid);\n+            StringJoiner lockKeysString = new StringJoiner(SEMICOLON);\n+            needLockKeys.stream().forEach(lockKey -> lockKeysString.add(lockKey));\n+            jedis.hsetnx(xidLockKey, branchId.toString(), lockKeysString.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93bb511d77726bee31b4f21fbb72561314497ba6"}, "originalPosition": 187}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5NTE0ODg3", "url": "https://github.com/seata/seata/pull/3016#pullrequestreview-469514887", "createdAt": "2020-08-18T14:31:26Z", "commit": {"oid": "93bb511d77726bee31b4f21fbb72561314497ba6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxNDozMToyNlrOHCXYQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxNDozMToyNlrOHCXYQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjI0MjI0Mw==", "bodyText": "please pay attention to this problem: list All elements are null\nexistedXids.size>0", "url": "https://github.com/seata/seata/pull/3016#discussion_r472242243", "createdAt": "2020-08-18T14:31:26Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -207,41 +237,22 @@ public boolean isLockable(List<RowLock> rowLocks) {\n             List<LockDO> locks = convertToLockDO(rowLocks);\n             Set<String> lockKeys = new HashSet<>();\n             for (LockDO rowlock : locks) {\n-                lockKeys.add(getLockKey(rowlock.getRowKey()));\n+                lockKeys.add(buildLockKey(rowlock.getRowKey()));\n             }\n-            List<String> rowlockJsons = jedis.mget(lockKeys.toArray(new String[0]));\n+\n             String xid = rowLocks.get(0).getXid();\n-            for (String rowlockJson : rowlockJsons) {\n-                if (!StringUtils.isEmpty(rowlockJson)) {\n-                    LockDO lock = JSON.parseObject(rowlockJson, LockDO.class);\n-                    if (lock != null && !Objects.equals(lock.getXid(), xid)) {\n-                        return false;\n-                    }\n-                }\n-            }\n+            Pipeline pipeline = jedis.pipelined();\n+            lockKeys.stream().forEach(key -> pipeline.hget(key, XID));\n+            List<String> existedXids = (List<String>) (List) pipeline.syncAndReturnAll();\n+            return existedXids.stream().allMatch(existedXid -> xid.equals(existedXid));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93bb511d77726bee31b4f21fbb72561314497ba6"}, "originalPosition": 299}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "01974758bf4ac6b928f6e53b8c1d02f904fa6fe0", "author": {"user": {"login": "lightClouds917", "name": "IT\u4e91\u6e05"}}, "url": "https://github.com/seata/seata/commit/01974758bf4ac6b928f6e53b8c1d02f904fa6fe0", "committedDate": "2020-08-19T01:04:12Z", "message": "fix:list All elements are null"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d83284f57fa41a676592c7561c742028e0034a44", "author": {"user": {"login": "lightClouds917", "name": "IT\u4e91\u6e05"}}, "url": "https://github.com/seata/seata/commit/d83284f57fa41a676592c7561c742028e0034a44", "committedDate": "2020-08-19T01:14:27Z", "message": "format:format the code"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcwMDE4ODg0", "url": "https://github.com/seata/seata/pull/3016#pullrequestreview-470018884", "createdAt": "2020-08-19T01:39:14Z", "commit": {"oid": "d83284f57fa41a676592c7561c742028e0034a44"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwMTozOToxNVrOHCsUjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwMTozOToxNVrOHCsUjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjU4NTM1OA==", "bodyText": "don't need the logQueryLimit", "url": "https://github.com/seata/seata/pull/3016#discussion_r472585358", "createdAt": "2020-08-19T01:39:15Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -60,131 +82,139 @@\n      */\n     public RedisLocker() {\n         logQueryLimit =\n-            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+                ConfigurationFactory.getInstance()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d83284f57fa41a676592c7561c742028e0034a44"}, "originalPosition": 67}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3897037fa6655229355028e6bcbef63bd0714bb4", "author": {"user": {"login": "lightClouds917", "name": "IT\u4e91\u6e05"}}, "url": "https://github.com/seata/seata/commit/3897037fa6655229355028e6bcbef63bd0714bb4", "committedDate": "2020-08-19T01:59:38Z", "message": "del:the logQueryLimit"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "91360c7adeeeb3d8bc6e0f58e82fb8946f9df2dc", "author": {"user": {"login": "lightClouds917", "name": "IT\u4e91\u6e05"}}, "url": "https://github.com/seata/seata/commit/91360c7adeeeb3d8bc6e0f58e82fb8946f9df2dc", "committedDate": "2020-08-19T03:09:02Z", "message": "Merge branch 'develop' of github.com:seata/seata into refactor_redis"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcwMTAxNDA5", "url": "https://github.com/seata/seata/pull/3016#pullrequestreview-470101409", "createdAt": "2020-08-19T03:35:50Z", "commit": {"oid": "91360c7adeeeb3d8bc6e0f58e82fb8946f9df2dc"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczMjk1NjQx", "url": "https://github.com/seata/seata/pull/3016#pullrequestreview-473295641", "createdAt": "2020-08-24T09:37:52Z", "commit": {"oid": "91360c7adeeeb3d8bc6e0f58e82fb8946f9df2dc"}, "state": "APPROVED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQwOTozNzo1MlrOHFclLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxMDowMTo0NVrOHFdZtw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ3MzE5OA==", "bodyText": "Can be completed or deleted", "url": "https://github.com/seata/seata/pull/3016#discussion_r475473198", "createdAt": "2020-08-24T09:37:52Z", "author": {"login": "ph3636"}, "path": "common/src/main/java/io/seata/common/Constants.java", "diffHunk": "@@ -40,8 +41,15 @@\n      */\n     public static final String DBKEYS_SPLIT_CHAR = \",\";\n \n-    /** the start time of transaction */\n-    public static final String START_TIME  = \"start-time\";\n+    /**\n+     * The constant ;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91360c7adeeeb3d8bc6e0f58e82fb8946f9df2dc"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ3NDA0MQ==", "bodyText": "Can be placed below", "url": "https://github.com/seata/seata/pull/3016#discussion_r475474041", "createdAt": "2020-08-24T09:38:54Z", "author": {"login": "ph3636"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -15,23 +15,21 @@\n  */\n package io.seata.server.storage.redis.lock;\n \n+import static io.seata.common.Constants.SEMICOLON;\n+\n+import com.google.common.collect.Lists;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91360c7adeeeb3d8bc6e0f58e82fb8946f9df2dc"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ3NTI3NQ==", "bodyText": "Remove equal to", "url": "https://github.com/seata/seata/pull/3016#discussion_r475475275", "createdAt": "2020-08-24T09:41:09Z", "author": {"login": "ph3636"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -40,151 +38,170 @@\n import redis.clients.jedis.Pipeline;\n \n /**\n+ * The redis lock store operation\n+ *\n  * @author funkye\n+ * @author wangzhongxiang\n  */\n public class RedisLocker extends AbstractLocker {\n \n-    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+    private static final Integer SUCCEED = 1;\n+\n+    private static final Integer FAILED = 0;\n \n     private static final String DEFAULT_REDIS_SEATA_LOCK_PREFIX = \"SEATA_LOCK_\";\n \n     private static final String DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX = \"SEATA_LOCK_XID_\";\n \n-    /**\n-     * The query limit.\n-     */\n-    private int logQueryLimit;\n+    private static final String XID = \"xid\";\n+\n+    private static final String TRANSACTION_ID = \"transactionId\";\n+\n+    private static final String BRANCH_ID = \"branchId\";\n+\n+    private static final String RESOURCE_ID = \"resourceId\";\n+\n+    private static final String TABLE_NAME = \"tableName\";\n+\n+    private static final String PK = \"pk\";\n+\n+    private static final String ROW_KEY = \"rowKey\";\n \n     /**\n      * Instantiates a new Redis locker.\n      */\n     public RedisLocker() {\n-        logQueryLimit =\n-            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n     }\n \n     @Override\n     public boolean acquireLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        Set<String> successList = new HashSet<>();\n-        long status = 1;\n+        Integer status = SUCCEED;\n+        String needLockXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            List<LockDO> locks = convertToLockDO(rowLocks);\n-            if (locks.size() > 1) {\n-                locks =\n-                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            List<LockDO> needLockDOS = convertToLockDO(rowLocks);\n+            if (needLockDOS.size() >= 1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91360c7adeeeb3d8bc6e0f58e82fb8946f9df2dc"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ4NjY0Nw==", "bodyText": "Change the names of these two keys for structure error", "url": "https://github.com/seata/seata/pull/3016#discussion_r475486647", "createdAt": "2020-08-24T10:01:45Z", "author": {"login": "ph3636"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -200,48 +217,28 @@ public boolean releaseLock(String xid, Long branchId) {\n     @Override\n     public boolean isLockable(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n             List<LockDO> locks = convertToLockDO(rowLocks);\n             Set<String> lockKeys = new HashSet<>();\n             for (LockDO rowlock : locks) {\n-                lockKeys.add(getLockKey(rowlock.getRowKey()));\n+                lockKeys.add(buildLockKey(rowlock.getRowKey()));\n             }\n-            List<String> rowlockJsons = jedis.mget(lockKeys.toArray(new String[0]));\n+\n             String xid = rowLocks.get(0).getXid();\n-            for (String rowlockJson : rowlockJsons) {\n-                if (!StringUtils.isEmpty(rowlockJson)) {\n-                    LockDO lock = JSON.parseObject(rowlockJson, LockDO.class);\n-                    if (lock != null && !Objects.equals(lock.getXid(), xid)) {\n-                        return false;\n-                    }\n-                }\n-            }\n+            Pipeline pipeline = jedis.pipelined();\n+            lockKeys.stream().forEach(key -> pipeline.hget(key, XID));\n+            List<String> existedXids = (List<String>) (List) pipeline.syncAndReturnAll();\n+            return existedXids.stream().allMatch(existedXid -> existedXid == null || xid.equals(existedXid));\n         }\n-        return true;\n-    }\n-\n-    private Set<String> lRange(Jedis jedis, String key) {\n-        Set<String> keys = new HashSet<>();\n-        List<String> redisLockJson;\n-        int start = 0;\n-        int stop = logQueryLimit;\n-        do {\n-            redisLockJson = jedis.lrange(key, start, stop);\n-            keys.addAll(redisLockJson);\n-            start = keys.size();\n-            stop = start + logQueryLimit;\n-        } while (CollectionUtils.isNotEmpty(redisLockJson));\n-        return keys;\n     }\n \n-    private String getXidLockKey(String xid) {\n+    private String buildXidLockKey(String xid) {\n         return DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX + xid;\n     }\n \n-    private String getLockKey(String rowKey) {\n+    private String buildLockKey(String rowKey) {\n         return DEFAULT_REDIS_SEATA_LOCK_PREFIX + rowKey;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91360c7adeeeb3d8bc6e0f58e82fb8946f9df2dc"}, "originalPosition": 335}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "024a7e6b2067273e1ab3b7125e7d4f943acc8fab", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/024a7e6b2067273e1ab3b7125e7d4f943acc8fab", "committedDate": "2020-08-25T02:06:38Z", "message": "Merge branch 'develop' into refactor_redis"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "12b8253c91a6a8ee18e17752fdd77c5d91c91060", "author": {"user": {"login": "lightClouds917", "name": "IT\u4e91\u6e05"}}, "url": "https://github.com/seata/seata/commit/12b8253c91a6a8ee18e17752fdd77c5d91c91060", "committedDate": "2020-08-26T06:14:43Z", "message": "Merge branch 'develop' of github.com:seata/seata into refactor_redis"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8d3f4cf1156e514f7209c10c3eb99ef4fd0349bb", "author": {"user": {"login": "lightClouds917", "name": "IT\u4e91\u6e05"}}, "url": "https://github.com/seata/seata/commit/8d3f4cf1156e514f7209c10c3eb99ef4fd0349bb", "committedDate": "2020-08-26T06:40:17Z", "message": "optimize:optimize the code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f0ddec3febb26ddedbecf1770b3ebfcb82f0a36f", "author": {"user": {"login": "lightClouds917", "name": "IT\u4e91\u6e05"}}, "url": "https://github.com/seata/seata/commit/f0ddec3febb26ddedbecf1770b3ebfcb82f0a36f", "committedDate": "2020-08-26T06:41:03Z", "message": "optimize:optimize the code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "79c9dc468c986a53210c9f2b194135f57ec2b0ac", "author": {"user": {"login": "lightClouds917", "name": "IT\u4e91\u6e05"}}, "url": "https://github.com/seata/seata/commit/79c9dc468c986a53210c9f2b194135f57ec2b0ac", "committedDate": "2020-08-26T06:42:16Z", "message": "Merge branch 'refactor_redis' of github.com:lightClouds917/seata into refactor_redis"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c226a3041749fc1470e6ad1cbb6da6a12b70d25b", "author": {"user": {"login": "lightClouds917", "name": "IT\u4e91\u6e05"}}, "url": "https://github.com/seata/seata/commit/c226a3041749fc1470e6ad1cbb6da6a12b70d25b", "committedDate": "2020-08-26T06:45:34Z", "message": "optimize:optimize the code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9978b936b199aa0b35e413e3a5944d5d4481d5b1", "author": {"user": {"login": "lightClouds917", "name": "IT\u4e91\u6e05"}}, "url": "https://github.com/seata/seata/commit/9978b936b199aa0b35e413e3a5944d5d4481d5b1", "committedDate": "2020-08-26T07:05:58Z", "message": "optimize:optimize the code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5da63d9fe355a42ba60ba6dcd042b0e7d63b0bb5", "author": {"user": {"login": "lightClouds917", "name": "IT\u4e91\u6e05"}}, "url": "https://github.com/seata/seata/commit/5da63d9fe355a42ba60ba6dcd042b0e7d63b0bb5", "committedDate": "2020-08-27T03:45:41Z", "message": "optimize:the code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aa93a678040c29ec10495de3b949011119b835d8", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/aa93a678040c29ec10495de3b949011119b835d8", "committedDate": "2020-08-28T09:51:45Z", "message": "Merge branch 'develop' into refactor_redis"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4913506665a834e2cd05b9560a3632c7df0963c1", "author": {"user": {"login": "l81893521", "name": "will"}}, "url": "https://github.com/seata/seata/commit/4913506665a834e2cd05b9560a3632c7df0963c1", "committedDate": "2020-09-03T05:51:06Z", "message": "Merge branch 'develop' into refactor_redis"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxNTEwNTM5", "url": "https://github.com/seata/seata/pull/3016#pullrequestreview-481510539", "createdAt": "2020-09-03T05:51:34Z", "commit": {"oid": "4913506665a834e2cd05b9560a3632c7df0963c1"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3616, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}