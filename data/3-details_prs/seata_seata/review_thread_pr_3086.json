{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDgwNjk0OTUx", "number": 3086, "reviewThreads": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxMzozNTozM1rOFAPrvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNjo0MTozNFrOFAWUTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1ODAxMjc5OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/seata/core/lock/RowLock.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxMzozNTozM1rOH-b8ww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNDo1MTo0MlrOH-gAJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTIzMTY4Mw==", "bodyText": "serialVersionUID", "url": "https://github.com/seata/seata/pull/3086#discussion_r535231683", "createdAt": "2020-12-03T13:35:33Z", "author": {"login": "caohdgege"}, "path": "core/src/main/java/io/seata/core/lock/RowLock.java", "diffHunk": "@@ -22,7 +22,7 @@\n  *\n  * @author zhangsen\n  */\n-public class RowLock {\n+public class RowLock implements java.io.Serializable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55ae70276b7236a52d00129d3e1707dff5445a0e"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTI5ODA4NA==", "bodyText": "ok", "url": "https://github.com/seata/seata/pull/3086#discussion_r535298084", "createdAt": "2020-12-03T14:51:42Z", "author": {"login": "a364176773"}, "path": "core/src/main/java/io/seata/core/lock/RowLock.java", "diffHunk": "@@ -22,7 +22,7 @@\n  *\n  * @author zhangsen\n  */\n-public class RowLock {\n+public class RowLock implements java.io.Serializable {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTIzMTY4Mw=="}, "originalCommit": {"oid": "55ae70276b7236a52d00129d3e1707dff5445a0e"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1ODA1NTU5OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/seata/core/raft/RaftServerFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxMzo0NDozOVrOH-cWFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNDo1MTozMFrOH-f_UA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTIzODE2NA==", "bodyText": "\u8fd9\u91cc\u53ef\u4ee5\u6539\u4e00\u4e0b\uff0c\u6709\u70b9\u96be\u61c2", "url": "https://github.com/seata/seata/pull/3086#discussion_r535238164", "createdAt": "2020-12-03T13:44:39Z", "author": {"login": "caohdgege"}, "path": "core/src/main/java/io/seata/core/raft/RaftServerFactory.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.core.raft;\n+\n+import java.io.IOException;\n+import com.alipay.sofa.jraft.conf.Configuration;\n+import com.alipay.sofa.jraft.entity.PeerId;\n+import com.alipay.sofa.jraft.option.NodeOptions;\n+import io.seata.common.loader.EnhancedServiceLoader;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.store.StoreMode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+import static io.seata.common.DefaultValues.SEATA_RAFT_GROUP;\n+import static io.seata.core.raft.AbstractRaftServer.RAFT_TAG;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RaftServerFactory {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(RaftServerFactory.class);\n+\n+    private AbstractRaftServer raftServer;\n+\n+    private AbstractRaftStateMachine stateMachine;\n+\n+    private Boolean raftMode = false;\n+\n+    public static RaftServerFactory getInstance() {\n+        return SingletonHandler.instance;\n+    }\n+\n+    public void init(String host, int port, String... defaultConf) throws IOException {\n+        String initConfStr = ConfigurationFactory.getInstance().getConfig(ConfigurationKeys.SERVER_RAFT_CLUSTER);\n+        if (StringUtils.isBlank(initConfStr)) {\n+            if (defaultConf == null || defaultConf.length == 0) {\n+                if (LOGGER.isWarnEnabled()) {\n+                    LOGGER.warn(\"initialize SofaJraft fail cluster is null\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55ae70276b7236a52d00129d3e1707dff5445a0e"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTI5Nzg3Mg==", "bodyText": "ok", "url": "https://github.com/seata/seata/pull/3086#discussion_r535297872", "createdAt": "2020-12-03T14:51:30Z", "author": {"login": "a364176773"}, "path": "core/src/main/java/io/seata/core/raft/RaftServerFactory.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.core.raft;\n+\n+import java.io.IOException;\n+import com.alipay.sofa.jraft.conf.Configuration;\n+import com.alipay.sofa.jraft.entity.PeerId;\n+import com.alipay.sofa.jraft.option.NodeOptions;\n+import io.seata.common.loader.EnhancedServiceLoader;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.store.StoreMode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+import static io.seata.common.DefaultValues.SEATA_RAFT_GROUP;\n+import static io.seata.core.raft.AbstractRaftServer.RAFT_TAG;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RaftServerFactory {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(RaftServerFactory.class);\n+\n+    private AbstractRaftServer raftServer;\n+\n+    private AbstractRaftStateMachine stateMachine;\n+\n+    private Boolean raftMode = false;\n+\n+    public static RaftServerFactory getInstance() {\n+        return SingletonHandler.instance;\n+    }\n+\n+    public void init(String host, int port, String... defaultConf) throws IOException {\n+        String initConfStr = ConfigurationFactory.getInstance().getConfig(ConfigurationKeys.SERVER_RAFT_CLUSTER);\n+        if (StringUtils.isBlank(initConfStr)) {\n+            if (defaultConf == null || defaultConf.length == 0) {\n+                if (LOGGER.isWarnEnabled()) {\n+                    LOGGER.warn(\"initialize SofaJraft fail cluster is null\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTIzODE2NA=="}, "originalCommit": {"oid": "55ae70276b7236a52d00129d3e1707dff5445a0e"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1ODA1NzczOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/seata/core/raft/RaftServerFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxMzo0NToxMVrOH-cXXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNToxODo0OVrOH-hgrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTIzODQ5Mw==", "bodyText": "sessionStore -> DEFAULT_SESSION_STORE_FILE_DIR", "url": "https://github.com/seata/seata/pull/3086#discussion_r535238493", "createdAt": "2020-12-03T13:45:11Z", "author": {"login": "caohdgege"}, "path": "core/src/main/java/io/seata/core/raft/RaftServerFactory.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.core.raft;\n+\n+import java.io.IOException;\n+import com.alipay.sofa.jraft.conf.Configuration;\n+import com.alipay.sofa.jraft.entity.PeerId;\n+import com.alipay.sofa.jraft.option.NodeOptions;\n+import io.seata.common.loader.EnhancedServiceLoader;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.store.StoreMode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+import static io.seata.common.DefaultValues.SEATA_RAFT_GROUP;\n+import static io.seata.core.raft.AbstractRaftServer.RAFT_TAG;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RaftServerFactory {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(RaftServerFactory.class);\n+\n+    private AbstractRaftServer raftServer;\n+\n+    private AbstractRaftStateMachine stateMachine;\n+\n+    private Boolean raftMode = false;\n+\n+    public static RaftServerFactory getInstance() {\n+        return SingletonHandler.instance;\n+    }\n+\n+    public void init(String host, int port, String... defaultConf) throws IOException {\n+        String initConfStr = ConfigurationFactory.getInstance().getConfig(ConfigurationKeys.SERVER_RAFT_CLUSTER);\n+        if (StringUtils.isBlank(initConfStr)) {\n+            if (defaultConf == null || defaultConf.length == 0) {\n+                if (LOGGER.isWarnEnabled()) {\n+                    LOGGER.warn(\"initialize SofaJraft fail cluster is null\");\n+                }\n+                return;\n+            } else {\n+                initConfStr = defaultConf[0];\n+            }\n+        }\n+        String mode = ConfigurationFactory.getInstance().getConfig(ConfigurationKeys.STORE_MODE);\n+        StoreMode storeMode = StoreMode.get(mode);\n+        if (storeMode.equals(StoreMode.RAFT)) {\n+            raftMode = true;\n+        }\n+        String colon = \":\";\n+        int constantInt = 100 * 10;\n+        String serverIdStr = host + colon + (port - constantInt);\n+        if (LOGGER.isInfoEnabled()) {\n+            LOGGER.info(\"initialize SofaJraft\");\n+        }\n+        final String dataPath =\n+            ConfigurationFactory.getInstance().getConfig(ConfigurationKeys.STORE_FILE_DIR, \"sessionStore\") + \"/\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55ae70276b7236a52d00129d3e1707dff5445a0e"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMyMjc5OA==", "bodyText": "ok", "url": "https://github.com/seata/seata/pull/3086#discussion_r535322798", "createdAt": "2020-12-03T15:18:49Z", "author": {"login": "a364176773"}, "path": "core/src/main/java/io/seata/core/raft/RaftServerFactory.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.core.raft;\n+\n+import java.io.IOException;\n+import com.alipay.sofa.jraft.conf.Configuration;\n+import com.alipay.sofa.jraft.entity.PeerId;\n+import com.alipay.sofa.jraft.option.NodeOptions;\n+import io.seata.common.loader.EnhancedServiceLoader;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.store.StoreMode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+import static io.seata.common.DefaultValues.SEATA_RAFT_GROUP;\n+import static io.seata.core.raft.AbstractRaftServer.RAFT_TAG;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RaftServerFactory {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(RaftServerFactory.class);\n+\n+    private AbstractRaftServer raftServer;\n+\n+    private AbstractRaftStateMachine stateMachine;\n+\n+    private Boolean raftMode = false;\n+\n+    public static RaftServerFactory getInstance() {\n+        return SingletonHandler.instance;\n+    }\n+\n+    public void init(String host, int port, String... defaultConf) throws IOException {\n+        String initConfStr = ConfigurationFactory.getInstance().getConfig(ConfigurationKeys.SERVER_RAFT_CLUSTER);\n+        if (StringUtils.isBlank(initConfStr)) {\n+            if (defaultConf == null || defaultConf.length == 0) {\n+                if (LOGGER.isWarnEnabled()) {\n+                    LOGGER.warn(\"initialize SofaJraft fail cluster is null\");\n+                }\n+                return;\n+            } else {\n+                initConfStr = defaultConf[0];\n+            }\n+        }\n+        String mode = ConfigurationFactory.getInstance().getConfig(ConfigurationKeys.STORE_MODE);\n+        StoreMode storeMode = StoreMode.get(mode);\n+        if (storeMode.equals(StoreMode.RAFT)) {\n+            raftMode = true;\n+        }\n+        String colon = \":\";\n+        int constantInt = 100 * 10;\n+        String serverIdStr = host + colon + (port - constantInt);\n+        if (LOGGER.isInfoEnabled()) {\n+            LOGGER.info(\"initialize SofaJraft\");\n+        }\n+        final String dataPath =\n+            ConfigurationFactory.getInstance().getConfig(ConfigurationKeys.STORE_FILE_DIR, \"sessionStore\") + \"/\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTIzODQ5Mw=="}, "originalCommit": {"oid": "55ae70276b7236a52d00129d3e1707dff5445a0e"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1ODExNzgwOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/seata/core/raft/RaftServerFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxMzo1ODowN1rOH-c77A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNToxODo1N1rOH-hhBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTI0Nzg1Mg==", "bodyText": "\u6839\u636e\u4f60\u7684\u6ce8\u91ca\uff0c\u4f60\u662f\u60f3\u5173\u95edcli\u6a21\u5f0f\n\u7136\u540e\u4f60disableCli=false\uff0c\u8d1f\u8d1f\u5f97\u6b63\u5c31\u662f\u6253\u5f00\u4e86\n\u6309\u7167\u6ce8\u91ca\uff0c\u8fd9\u91cc\u5e94\u8be5\u7528true\uff1f\u6216\u8005\u6ce8\u91ca\u6539\u6210enable the cli service?", "url": "https://github.com/seata/seata/pull/3086#discussion_r535247852", "createdAt": "2020-12-03T13:58:07Z", "author": {"login": "caohdgege"}, "path": "core/src/main/java/io/seata/core/raft/RaftServerFactory.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.core.raft;\n+\n+import java.io.IOException;\n+import com.alipay.sofa.jraft.conf.Configuration;\n+import com.alipay.sofa.jraft.entity.PeerId;\n+import com.alipay.sofa.jraft.option.NodeOptions;\n+import io.seata.common.loader.EnhancedServiceLoader;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.store.StoreMode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+import static io.seata.common.DefaultValues.SEATA_RAFT_GROUP;\n+import static io.seata.core.raft.AbstractRaftServer.RAFT_TAG;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RaftServerFactory {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(RaftServerFactory.class);\n+\n+    private AbstractRaftServer raftServer;\n+\n+    private AbstractRaftStateMachine stateMachine;\n+\n+    private Boolean raftMode = false;\n+\n+    public static RaftServerFactory getInstance() {\n+        return SingletonHandler.instance;\n+    }\n+\n+    public void init(String host, int port, String... defaultConf) throws IOException {\n+        String initConfStr = ConfigurationFactory.getInstance().getConfig(ConfigurationKeys.SERVER_RAFT_CLUSTER);\n+        if (StringUtils.isBlank(initConfStr)) {\n+            if (defaultConf == null || defaultConf.length == 0) {\n+                if (LOGGER.isWarnEnabled()) {\n+                    LOGGER.warn(\"initialize SofaJraft fail cluster is null\");\n+                }\n+                return;\n+            } else {\n+                initConfStr = defaultConf[0];\n+            }\n+        }\n+        String mode = ConfigurationFactory.getInstance().getConfig(ConfigurationKeys.STORE_MODE);\n+        StoreMode storeMode = StoreMode.get(mode);\n+        if (storeMode.equals(StoreMode.RAFT)) {\n+            raftMode = true;\n+        }\n+        String colon = \":\";\n+        int constantInt = 100 * 10;\n+        String serverIdStr = host + colon + (port - constantInt);\n+        if (LOGGER.isInfoEnabled()) {\n+            LOGGER.info(\"initialize SofaJraft\");\n+        }\n+        final String dataPath =\n+            ConfigurationFactory.getInstance().getConfig(ConfigurationKeys.STORE_FILE_DIR, \"sessionStore\") + \"/\"\n+                + serverIdStr.split(colon)[1];\n+        final NodeOptions nodeOptions = new NodeOptions();\n+        // Set the election timeout to 1 second\n+        nodeOptions.setElectionTimeoutMs(constantInt);\n+        // Close the CLI service.\n+        nodeOptions.setDisableCli(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55ae70276b7236a52d00129d3e1707dff5445a0e"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMyMjg4NQ==", "bodyText": "ok", "url": "https://github.com/seata/seata/pull/3086#discussion_r535322885", "createdAt": "2020-12-03T15:18:57Z", "author": {"login": "a364176773"}, "path": "core/src/main/java/io/seata/core/raft/RaftServerFactory.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.core.raft;\n+\n+import java.io.IOException;\n+import com.alipay.sofa.jraft.conf.Configuration;\n+import com.alipay.sofa.jraft.entity.PeerId;\n+import com.alipay.sofa.jraft.option.NodeOptions;\n+import io.seata.common.loader.EnhancedServiceLoader;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.store.StoreMode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+import static io.seata.common.DefaultValues.SEATA_RAFT_GROUP;\n+import static io.seata.core.raft.AbstractRaftServer.RAFT_TAG;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RaftServerFactory {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(RaftServerFactory.class);\n+\n+    private AbstractRaftServer raftServer;\n+\n+    private AbstractRaftStateMachine stateMachine;\n+\n+    private Boolean raftMode = false;\n+\n+    public static RaftServerFactory getInstance() {\n+        return SingletonHandler.instance;\n+    }\n+\n+    public void init(String host, int port, String... defaultConf) throws IOException {\n+        String initConfStr = ConfigurationFactory.getInstance().getConfig(ConfigurationKeys.SERVER_RAFT_CLUSTER);\n+        if (StringUtils.isBlank(initConfStr)) {\n+            if (defaultConf == null || defaultConf.length == 0) {\n+                if (LOGGER.isWarnEnabled()) {\n+                    LOGGER.warn(\"initialize SofaJraft fail cluster is null\");\n+                }\n+                return;\n+            } else {\n+                initConfStr = defaultConf[0];\n+            }\n+        }\n+        String mode = ConfigurationFactory.getInstance().getConfig(ConfigurationKeys.STORE_MODE);\n+        StoreMode storeMode = StoreMode.get(mode);\n+        if (storeMode.equals(StoreMode.RAFT)) {\n+            raftMode = true;\n+        }\n+        String colon = \":\";\n+        int constantInt = 100 * 10;\n+        String serverIdStr = host + colon + (port - constantInt);\n+        if (LOGGER.isInfoEnabled()) {\n+            LOGGER.info(\"initialize SofaJraft\");\n+        }\n+        final String dataPath =\n+            ConfigurationFactory.getInstance().getConfig(ConfigurationKeys.STORE_FILE_DIR, \"sessionStore\") + \"/\"\n+                + serverIdStr.split(colon)[1];\n+        final NodeOptions nodeOptions = new NodeOptions();\n+        // Set the election timeout to 1 second\n+        nodeOptions.setElectionTimeoutMs(constantInt);\n+        // Close the CLI service.\n+        nodeOptions.setDisableCli(false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTI0Nzg1Mg=="}, "originalCommit": {"oid": "55ae70276b7236a52d00129d3e1707dff5445a0e"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1ODEzNzE4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/seata/core/raft/RaftServerFactory.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNDowMjoxNFrOH-dH2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNToyNjoyMVrOH-h5FA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTI1MDkwNA==", "bodyText": "30?", "url": "https://github.com/seata/seata/pull/3086#discussion_r535250904", "createdAt": "2020-12-03T14:02:14Z", "author": {"login": "caohdgege"}, "path": "core/src/main/java/io/seata/core/raft/RaftServerFactory.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.core.raft;\n+\n+import java.io.IOException;\n+import com.alipay.sofa.jraft.conf.Configuration;\n+import com.alipay.sofa.jraft.entity.PeerId;\n+import com.alipay.sofa.jraft.option.NodeOptions;\n+import io.seata.common.loader.EnhancedServiceLoader;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.store.StoreMode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+import static io.seata.common.DefaultValues.SEATA_RAFT_GROUP;\n+import static io.seata.core.raft.AbstractRaftServer.RAFT_TAG;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RaftServerFactory {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(RaftServerFactory.class);\n+\n+    private AbstractRaftServer raftServer;\n+\n+    private AbstractRaftStateMachine stateMachine;\n+\n+    private Boolean raftMode = false;\n+\n+    public static RaftServerFactory getInstance() {\n+        return SingletonHandler.instance;\n+    }\n+\n+    public void init(String host, int port, String... defaultConf) throws IOException {\n+        String initConfStr = ConfigurationFactory.getInstance().getConfig(ConfigurationKeys.SERVER_RAFT_CLUSTER);\n+        if (StringUtils.isBlank(initConfStr)) {\n+            if (defaultConf == null || defaultConf.length == 0) {\n+                if (LOGGER.isWarnEnabled()) {\n+                    LOGGER.warn(\"initialize SofaJraft fail cluster is null\");\n+                }\n+                return;\n+            } else {\n+                initConfStr = defaultConf[0];\n+            }\n+        }\n+        String mode = ConfigurationFactory.getInstance().getConfig(ConfigurationKeys.STORE_MODE);\n+        StoreMode storeMode = StoreMode.get(mode);\n+        if (storeMode.equals(StoreMode.RAFT)) {\n+            raftMode = true;\n+        }\n+        String colon = \":\";\n+        int constantInt = 100 * 10;\n+        String serverIdStr = host + colon + (port - constantInt);\n+        if (LOGGER.isInfoEnabled()) {\n+            LOGGER.info(\"initialize SofaJraft\");\n+        }\n+        final String dataPath =\n+            ConfigurationFactory.getInstance().getConfig(ConfigurationKeys.STORE_FILE_DIR, \"sessionStore\") + \"/\"\n+                + serverIdStr.split(colon)[1];\n+        final NodeOptions nodeOptions = new NodeOptions();\n+        // Set the election timeout to 1 second\n+        nodeOptions.setElectionTimeoutMs(constantInt);\n+        // Close the CLI service.\n+        nodeOptions.setDisableCli(false);\n+        // Snapshot should be made every 30 seconds\n+        nodeOptions.setSnapshotIntervalSecs(60);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55ae70276b7236a52d00129d3e1707dff5445a0e"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMyNDc5NA==", "bodyText": "change to open configuration items later", "url": "https://github.com/seata/seata/pull/3086#discussion_r535324794", "createdAt": "2020-12-03T15:21:16Z", "author": {"login": "a364176773"}, "path": "core/src/main/java/io/seata/core/raft/RaftServerFactory.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.core.raft;\n+\n+import java.io.IOException;\n+import com.alipay.sofa.jraft.conf.Configuration;\n+import com.alipay.sofa.jraft.entity.PeerId;\n+import com.alipay.sofa.jraft.option.NodeOptions;\n+import io.seata.common.loader.EnhancedServiceLoader;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.store.StoreMode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+import static io.seata.common.DefaultValues.SEATA_RAFT_GROUP;\n+import static io.seata.core.raft.AbstractRaftServer.RAFT_TAG;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RaftServerFactory {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(RaftServerFactory.class);\n+\n+    private AbstractRaftServer raftServer;\n+\n+    private AbstractRaftStateMachine stateMachine;\n+\n+    private Boolean raftMode = false;\n+\n+    public static RaftServerFactory getInstance() {\n+        return SingletonHandler.instance;\n+    }\n+\n+    public void init(String host, int port, String... defaultConf) throws IOException {\n+        String initConfStr = ConfigurationFactory.getInstance().getConfig(ConfigurationKeys.SERVER_RAFT_CLUSTER);\n+        if (StringUtils.isBlank(initConfStr)) {\n+            if (defaultConf == null || defaultConf.length == 0) {\n+                if (LOGGER.isWarnEnabled()) {\n+                    LOGGER.warn(\"initialize SofaJraft fail cluster is null\");\n+                }\n+                return;\n+            } else {\n+                initConfStr = defaultConf[0];\n+            }\n+        }\n+        String mode = ConfigurationFactory.getInstance().getConfig(ConfigurationKeys.STORE_MODE);\n+        StoreMode storeMode = StoreMode.get(mode);\n+        if (storeMode.equals(StoreMode.RAFT)) {\n+            raftMode = true;\n+        }\n+        String colon = \":\";\n+        int constantInt = 100 * 10;\n+        String serverIdStr = host + colon + (port - constantInt);\n+        if (LOGGER.isInfoEnabled()) {\n+            LOGGER.info(\"initialize SofaJraft\");\n+        }\n+        final String dataPath =\n+            ConfigurationFactory.getInstance().getConfig(ConfigurationKeys.STORE_FILE_DIR, \"sessionStore\") + \"/\"\n+                + serverIdStr.split(colon)[1];\n+        final NodeOptions nodeOptions = new NodeOptions();\n+        // Set the election timeout to 1 second\n+        nodeOptions.setElectionTimeoutMs(constantInt);\n+        // Close the CLI service.\n+        nodeOptions.setDisableCli(false);\n+        // Snapshot should be made every 30 seconds\n+        nodeOptions.setSnapshotIntervalSecs(60);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTI1MDkwNA=="}, "originalCommit": {"oid": "55ae70276b7236a52d00129d3e1707dff5445a0e"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMyOTA0NA==", "bodyText": "change to open configuration items later", "url": "https://github.com/seata/seata/pull/3086#discussion_r535329044", "createdAt": "2020-12-03T15:26:21Z", "author": {"login": "a364176773"}, "path": "core/src/main/java/io/seata/core/raft/RaftServerFactory.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.core.raft;\n+\n+import java.io.IOException;\n+import com.alipay.sofa.jraft.conf.Configuration;\n+import com.alipay.sofa.jraft.entity.PeerId;\n+import com.alipay.sofa.jraft.option.NodeOptions;\n+import io.seata.common.loader.EnhancedServiceLoader;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.store.StoreMode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+import static io.seata.common.DefaultValues.SEATA_RAFT_GROUP;\n+import static io.seata.core.raft.AbstractRaftServer.RAFT_TAG;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RaftServerFactory {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(RaftServerFactory.class);\n+\n+    private AbstractRaftServer raftServer;\n+\n+    private AbstractRaftStateMachine stateMachine;\n+\n+    private Boolean raftMode = false;\n+\n+    public static RaftServerFactory getInstance() {\n+        return SingletonHandler.instance;\n+    }\n+\n+    public void init(String host, int port, String... defaultConf) throws IOException {\n+        String initConfStr = ConfigurationFactory.getInstance().getConfig(ConfigurationKeys.SERVER_RAFT_CLUSTER);\n+        if (StringUtils.isBlank(initConfStr)) {\n+            if (defaultConf == null || defaultConf.length == 0) {\n+                if (LOGGER.isWarnEnabled()) {\n+                    LOGGER.warn(\"initialize SofaJraft fail cluster is null\");\n+                }\n+                return;\n+            } else {\n+                initConfStr = defaultConf[0];\n+            }\n+        }\n+        String mode = ConfigurationFactory.getInstance().getConfig(ConfigurationKeys.STORE_MODE);\n+        StoreMode storeMode = StoreMode.get(mode);\n+        if (storeMode.equals(StoreMode.RAFT)) {\n+            raftMode = true;\n+        }\n+        String colon = \":\";\n+        int constantInt = 100 * 10;\n+        String serverIdStr = host + colon + (port - constantInt);\n+        if (LOGGER.isInfoEnabled()) {\n+            LOGGER.info(\"initialize SofaJraft\");\n+        }\n+        final String dataPath =\n+            ConfigurationFactory.getInstance().getConfig(ConfigurationKeys.STORE_FILE_DIR, \"sessionStore\") + \"/\"\n+                + serverIdStr.split(colon)[1];\n+        final NodeOptions nodeOptions = new NodeOptions();\n+        // Set the election timeout to 1 second\n+        nodeOptions.setElectionTimeoutMs(constantInt);\n+        // Close the CLI service.\n+        nodeOptions.setDisableCli(false);\n+        // Snapshot should be made every 30 seconds\n+        nodeOptions.setSnapshotIntervalSecs(60);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTI1MDkwNA=="}, "originalCommit": {"oid": "55ae70276b7236a52d00129d3e1707dff5445a0e"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1ODE4MzQ2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/seata/core/rpc/netty/AbstractNettyRemoting.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNDoxMTozNlrOH-djLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNToyMTowOFrOH-hoCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTI1NzkwMQ==", "bodyText": "\u8fd9\u91cc\u5e94\u8be5\u5c31\u53ea\u662f\u628anew Runnable\u6539\u6210lomdba\u8868\u8fbe\u5f0f\u5427\uff1f", "url": "https://github.com/seata/seata/pull/3086#discussion_r535257901", "createdAt": "2020-12-03T14:11:36Z", "author": {"login": "caohdgege"}, "path": "core/src/main/java/io/seata/core/rpc/netty/AbstractNettyRemoting.java", "diffHunk": "@@ -105,21 +111,18 @@\n     protected final List<RpcHook> rpcHooks = EnhancedServiceLoader.loadAll(RpcHook.class);\n \n     public void init() {\n-        timerExecutor.scheduleAtFixedRate(new Runnable() {\n-            @Override\n-            public void run() {\n-                for (Map.Entry<Integer, MessageFuture> entry : futures.entrySet()) {\n-                    if (entry.getValue().isTimeout()) {\n-                        futures.remove(entry.getKey());\n-                        entry.getValue().setResultMessage(null);\n-                        if (LOGGER.isDebugEnabled()) {\n-                            LOGGER.debug(\"timeout clear future: {}\", entry.getValue().getRequestMessage().getBody());\n-                        }\n+        timerExecutor.scheduleAtFixedRate(() -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55ae70276b7236a52d00129d3e1707dff5445a0e"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMyNDY4Mw==", "bodyText": "yes", "url": "https://github.com/seata/seata/pull/3086#discussion_r535324683", "createdAt": "2020-12-03T15:21:08Z", "author": {"login": "a364176773"}, "path": "core/src/main/java/io/seata/core/rpc/netty/AbstractNettyRemoting.java", "diffHunk": "@@ -105,21 +111,18 @@\n     protected final List<RpcHook> rpcHooks = EnhancedServiceLoader.loadAll(RpcHook.class);\n \n     public void init() {\n-        timerExecutor.scheduleAtFixedRate(new Runnable() {\n-            @Override\n-            public void run() {\n-                for (Map.Entry<Integer, MessageFuture> entry : futures.entrySet()) {\n-                    if (entry.getValue().isTimeout()) {\n-                        futures.remove(entry.getKey());\n-                        entry.getValue().setResultMessage(null);\n-                        if (LOGGER.isDebugEnabled()) {\n-                            LOGGER.debug(\"timeout clear future: {}\", entry.getValue().getRequestMessage().getBody());\n-                        }\n+        timerExecutor.scheduleAtFixedRate(() -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTI1NzkwMQ=="}, "originalCommit": {"oid": "55ae70276b7236a52d00129d3e1707dff5445a0e"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1ODI4NjA3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/seata/core/store/BranchTransactionDO.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNDozMDo1MFrOH-ehOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNToyNjoxOFrOH-h43w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTI3Mzc4NQ==", "bodyText": "serialVersionUID\uff1f", "url": "https://github.com/seata/seata/pull/3086#discussion_r535273785", "createdAt": "2020-12-03T14:30:50Z", "author": {"login": "caohdgege"}, "path": "core/src/main/java/io/seata/core/store/BranchTransactionDO.java", "diffHunk": "@@ -25,7 +25,7 @@\n  *\n  * @author zhangsen\n  */\n-public class BranchTransactionDO {\n+public class BranchTransactionDO implements java.io.Serializable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55ae70276b7236a52d00129d3e1707dff5445a0e"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMyNDgxNg==", "bodyText": "ok", "url": "https://github.com/seata/seata/pull/3086#discussion_r535324816", "createdAt": "2020-12-03T15:21:17Z", "author": {"login": "a364176773"}, "path": "core/src/main/java/io/seata/core/store/BranchTransactionDO.java", "diffHunk": "@@ -25,7 +25,7 @@\n  *\n  * @author zhangsen\n  */\n-public class BranchTransactionDO {\n+public class BranchTransactionDO implements java.io.Serializable {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTI3Mzc4NQ=="}, "originalCommit": {"oid": "55ae70276b7236a52d00129d3e1707dff5445a0e"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMyODk5MQ==", "bodyText": "ok", "url": "https://github.com/seata/seata/pull/3086#discussion_r535328991", "createdAt": "2020-12-03T15:26:18Z", "author": {"login": "a364176773"}, "path": "core/src/main/java/io/seata/core/store/BranchTransactionDO.java", "diffHunk": "@@ -25,7 +25,7 @@\n  *\n  * @author zhangsen\n  */\n-public class BranchTransactionDO {\n+public class BranchTransactionDO implements java.io.Serializable {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTI3Mzc4NQ=="}, "originalCommit": {"oid": "55ae70276b7236a52d00129d3e1707dff5445a0e"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1ODI5MDU1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/seata/core/store/GlobalTransactionDO.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNDozMToyMVrOH-ejjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNToyMTo0N1rOH-hqUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTI3NDM4MA==", "bodyText": "serialVersionUID", "url": "https://github.com/seata/seata/pull/3086#discussion_r535274380", "createdAt": "2020-12-03T14:31:21Z", "author": {"login": "caohdgege"}, "path": "core/src/main/java/io/seata/core/store/GlobalTransactionDO.java", "diffHunk": "@@ -15,16 +15,15 @@\n  */\n package io.seata.core.store;\n \n-import io.seata.common.util.StringUtils;\n-\n import java.util.Date;\n+import io.seata.common.util.StringUtils;\n \n /**\n  * Global Transaction data object\n  *\n  * @author zhangsen\n  */\n-public class GlobalTransactionDO {\n+public class GlobalTransactionDO implements java.io.Serializable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55ae70276b7236a52d00129d3e1707dff5445a0e"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMyNTI2NQ==", "bodyText": "ok", "url": "https://github.com/seata/seata/pull/3086#discussion_r535325265", "createdAt": "2020-12-03T15:21:47Z", "author": {"login": "a364176773"}, "path": "core/src/main/java/io/seata/core/store/GlobalTransactionDO.java", "diffHunk": "@@ -15,16 +15,15 @@\n  */\n package io.seata.core.store;\n \n-import io.seata.common.util.StringUtils;\n-\n import java.util.Date;\n+import io.seata.common.util.StringUtils;\n \n /**\n  * Global Transaction data object\n  *\n  * @author zhangsen\n  */\n-public class GlobalTransactionDO {\n+public class GlobalTransactionDO implements java.io.Serializable {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTI3NDM4MA=="}, "originalCommit": {"oid": "55ae70276b7236a52d00129d3e1707dff5445a0e"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1ODM0ODQ0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/raft/RaftSnapshotFile.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNDozNzo1MlrOH-fBzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNToyMTo0N1rOH-hqWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTI4MjEyNA==", "bodyText": "\u4e60\u60ef\u4e0a\u7528LOGGER\uff0c\u53ef\u4ee5\u7edf\u4e00\u4e00\u4e0b", "url": "https://github.com/seata/seata/pull/3086#discussion_r535282124", "createdAt": "2020-12-03T14:37:52Z", "author": {"login": "caohdgege"}, "path": "server/src/main/java/io/seata/server/raft/RaftSnapshotFile.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.raft;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Map;\n+import io.seata.serializer.kryo.KryoInnerSerializer;\n+import io.seata.serializer.kryo.KryoSerializerFactory;\n+import org.apache.commons.io.FileUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RaftSnapshotFile {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(RaftSnapshotFile.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55ae70276b7236a52d00129d3e1707dff5445a0e"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMyNTI3Mw==", "bodyText": "ok", "url": "https://github.com/seata/seata/pull/3086#discussion_r535325273", "createdAt": "2020-12-03T15:21:47Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/raft/RaftSnapshotFile.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.raft;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Map;\n+import io.seata.serializer.kryo.KryoInnerSerializer;\n+import io.seata.serializer.kryo.KryoSerializerFactory;\n+import org.apache.commons.io.FileUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RaftSnapshotFile {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(RaftSnapshotFile.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTI4MjEyNA=="}, "originalCommit": {"oid": "55ae70276b7236a52d00129d3e1707dff5445a0e"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1ODM2ODYwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/session/SessionHolder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNDo0MDoxN1rOH-fMaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNToyODowMlrOH-h-9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTI4NDg0Mw==", "bodyText": "LOGGER", "url": "https://github.com/seata/seata/pull/3086#discussion_r535284843", "createdAt": "2020-12-03T14:40:17Z", "author": {"login": "caohdgege"}, "path": "server/src/main/java/io/seata/server/session/SessionHolder.java", "diffHunk": "@@ -134,6 +148,14 @@ protected static void reload(StoreMode storeMode) {\n         }\n \n         Collection<GlobalSession> allSessions = ROOT_SESSION_MANAGER.allSessions();\n+        try {\n+            RaftServerFactory.getInstance().init(XID.getIpAddress(), XID.getPort());\n+        } catch (IOException e) {\n+            e.printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55ae70276b7236a52d00129d3e1707dff5445a0e"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMzMDU1MQ==", "bodyText": "ok", "url": "https://github.com/seata/seata/pull/3086#discussion_r535330551", "createdAt": "2020-12-03T15:28:02Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/session/SessionHolder.java", "diffHunk": "@@ -134,6 +148,14 @@ protected static void reload(StoreMode storeMode) {\n         }\n \n         Collection<GlobalSession> allSessions = ROOT_SESSION_MANAGER.allSessions();\n+        try {\n+            RaftServerFactory.getInstance().init(XID.getIpAddress(), XID.getPort());\n+        } catch (IOException e) {\n+            e.printStackTrace();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTI4NDg0Mw=="}, "originalCommit": {"oid": "55ae70276b7236a52d00129d3e1707dff5445a0e"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1ODM4ODQ4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/raft/RaftSessionSyncMsg.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNDo0MjoyN1rOH-fWtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNToyMjozMlrOH-hs3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTI4NzQ3Ng==", "bodyText": "serialVersionUID", "url": "https://github.com/seata/seata/pull/3086#discussion_r535287476", "createdAt": "2020-12-03T14:42:27Z", "author": {"login": "caohdgege"}, "path": "server/src/main/java/io/seata/server/storage/raft/RaftSessionSyncMsg.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.raft;\n+\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.raft.msg.RaftSyncMsg;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RaftSessionSyncMsg extends RaftSyncMsg implements java.io.Serializable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55ae70276b7236a52d00129d3e1707dff5445a0e"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMyNTkxNw==", "bodyText": "ok", "url": "https://github.com/seata/seata/pull/3086#discussion_r535325917", "createdAt": "2020-12-03T15:22:32Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/raft/RaftSessionSyncMsg.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.raft;\n+\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.raft.msg.RaftSyncMsg;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RaftSessionSyncMsg extends RaftSyncMsg implements java.io.Serializable {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTI4NzQ3Ng=="}, "originalCommit": {"oid": "55ae70276b7236a52d00129d3e1707dff5445a0e"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1ODQwMjI2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/raft/RaftTaskUtil.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNDo0NDowNlrOH-feBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNToyNzo1OFrOH-h-xA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTI4OTM1MA==", "bodyText": "LOGGER", "url": "https://github.com/seata/seata/pull/3086#discussion_r535289350", "createdAt": "2020-12-03T14:44:06Z", "author": {"login": "caohdgege"}, "path": "server/src/main/java/io/seata/server/storage/raft/RaftTaskUtil.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.raft;\n+\n+import java.nio.ByteBuffer;\n+import com.alipay.remoting.exception.CodecException;\n+import com.alipay.remoting.serialization.SerializerManager;\n+import com.alipay.sofa.jraft.Closure;\n+import com.alipay.sofa.jraft.entity.Task;\n+import io.seata.core.raft.RaftServerFactory;\n+\n+\n+import static com.alipay.remoting.serialization.SerializerManager.Hessian2;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RaftTaskUtil {\n+\n+    public static void createTask(Object data) {\n+        createTask(null, data);\n+    }\n+\n+    public static void createTask(Closure done, Object data) {\n+        final Task task = new Task();\n+        try {\n+            task.setData(ByteBuffer.wrap(SerializerManager.getSerializer(Hessian2).serialize(data)));\n+        } catch (CodecException e) {\n+            e.printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55ae70276b7236a52d00129d3e1707dff5445a0e"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMzMDUwMA==", "bodyText": "ok", "url": "https://github.com/seata/seata/pull/3086#discussion_r535330500", "createdAt": "2020-12-03T15:27:58Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/raft/RaftTaskUtil.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.raft;\n+\n+import java.nio.ByteBuffer;\n+import com.alipay.remoting.exception.CodecException;\n+import com.alipay.remoting.serialization.SerializerManager;\n+import com.alipay.sofa.jraft.Closure;\n+import com.alipay.sofa.jraft.entity.Task;\n+import io.seata.core.raft.RaftServerFactory;\n+\n+\n+import static com.alipay.remoting.serialization.SerializerManager.Hessian2;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RaftTaskUtil {\n+\n+    public static void createTask(Object data) {\n+        createTask(null, data);\n+    }\n+\n+    public static void createTask(Closure done, Object data) {\n+        final Task task = new Task();\n+        try {\n+            task.setData(ByteBuffer.wrap(SerializerManager.getSerializer(Hessian2).serialize(data)));\n+        } catch (CodecException e) {\n+            e.printStackTrace();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTI4OTM1MA=="}, "originalCommit": {"oid": "55ae70276b7236a52d00129d3e1707dff5445a0e"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1ODQzNjM2OnYy", "diffSide": "RIGHT", "path": "server/src/test/java/io/seata/server/coordinator/DefaultCoordinatorTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNDo0Nzo1OFrOH-fv1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNToyNzo1OFrOH-h-wg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTI5MzkxMA==", "bodyText": "File.separator ?", "url": "https://github.com/seata/seata/pull/3086#discussion_r535293910", "createdAt": "2020-12-03T14:47:58Z", "author": {"login": "caohdgege"}, "path": "server/src/test/java/io/seata/server/coordinator/DefaultCoordinatorTest.java", "diffHunk": "@@ -90,12 +90,13 @@\n \n     private static final Configuration CONFIG = ConfigurationFactory.getInstance();\n \n-    private static String sessionStorePath = CONFIG.getConfig(ConfigurationKeys.STORE_FILE_DIR,\n-        DEFAULT_SESSION_STORE_FILE_DIR);\n+    private static String sessionStorePath;\n \n     @BeforeAll\n     public static void beforeClass() throws Exception {\n         XID.setIpAddress(NetUtil.getLocalIp());\n+        sessionStorePath = CONFIG.getConfig(ConfigurationKeys.STORE_FILE_DIR, DEFAULT_SESSION_STORE_FILE_DIR)\n+            + \"/\" + XID.getPort();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55ae70276b7236a52d00129d3e1707dff5445a0e"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMzMDQ5OA==", "bodyText": "ok", "url": "https://github.com/seata/seata/pull/3086#discussion_r535330498", "createdAt": "2020-12-03T15:27:58Z", "author": {"login": "a364176773"}, "path": "server/src/test/java/io/seata/server/coordinator/DefaultCoordinatorTest.java", "diffHunk": "@@ -90,12 +90,13 @@\n \n     private static final Configuration CONFIG = ConfigurationFactory.getInstance();\n \n-    private static String sessionStorePath = CONFIG.getConfig(ConfigurationKeys.STORE_FILE_DIR,\n-        DEFAULT_SESSION_STORE_FILE_DIR);\n+    private static String sessionStorePath;\n \n     @BeforeAll\n     public static void beforeClass() throws Exception {\n         XID.setIpAddress(NetUtil.getLocalIp());\n+        sessionStorePath = CONFIG.getConfig(ConfigurationKeys.STORE_FILE_DIR, DEFAULT_SESSION_STORE_FILE_DIR)\n+            + \"/\" + XID.getPort();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTI5MzkxMA=="}, "originalCommit": {"oid": "55ae70276b7236a52d00129d3e1707dff5445a0e"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1ODQzNzQ0OnYy", "diffSide": "RIGHT", "path": "server/src/test/java/io/seata/server/session/SessionHolderTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNDo0ODowOFrOH-fwcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNToyODowNlrOH-h_Lw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTI5NDA2NA==", "bodyText": "File.separator", "url": "https://github.com/seata/seata/pull/3086#discussion_r535294064", "createdAt": "2020-12-03T14:48:08Z", "author": {"login": "caohdgege"}, "path": "server/src/test/java/io/seata/server/session/SessionHolderTest.java", "diffHunk": "@@ -37,7 +39,9 @@\n \n     @BeforeEach\n     public void before() {\n-        String sessionStorePath = SessionHolder.CONFIG.getConfig(ConfigurationKeys.STORE_FILE_DIR);\n+        String sessionStorePath =\n+            SessionHolder.CONFIG.getConfig(ConfigurationKeys.STORE_FILE_DIR, DEFAULT_SESSION_STORE_FILE_DIR) + \"/\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55ae70276b7236a52d00129d3e1707dff5445a0e"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMzMDYwNw==", "bodyText": "ok", "url": "https://github.com/seata/seata/pull/3086#discussion_r535330607", "createdAt": "2020-12-03T15:28:06Z", "author": {"login": "a364176773"}, "path": "server/src/test/java/io/seata/server/session/SessionHolderTest.java", "diffHunk": "@@ -37,7 +39,9 @@\n \n     @BeforeEach\n     public void before() {\n-        String sessionStorePath = SessionHolder.CONFIG.getConfig(ConfigurationKeys.STORE_FILE_DIR);\n+        String sessionStorePath =\n+            SessionHolder.CONFIG.getConfig(ConfigurationKeys.STORE_FILE_DIR, DEFAULT_SESSION_STORE_FILE_DIR) + \"/\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTI5NDA2NA=="}, "originalCommit": {"oid": "55ae70276b7236a52d00129d3e1707dff5445a0e"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1ODQzODMwOnYy", "diffSide": "RIGHT", "path": "server/src/test/java/io/seata/server/store/SessionStoreTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNDo0ODoxNVrOH-fw4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNToyODowOFrOH-h_Tw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTI5NDE3Ng==", "bodyText": "File.separator", "url": "https://github.com/seata/seata/pull/3086#discussion_r535294176", "createdAt": "2020-12-03T14:48:15Z", "author": {"login": "caohdgege"}, "path": "server/src/test/java/io/seata/server/store/SessionStoreTest.java", "diffHunk": "@@ -55,7 +56,8 @@\n      */\n     @BeforeEach\n     public void clean() throws Exception {\n-        String sessionStorePath = CONFIG.getConfig(ConfigurationKeys.STORE_FILE_DIR);\n+        String sessionStorePath = CONFIG.getConfig(ConfigurationKeys.STORE_FILE_DIR, DEFAULT_SESSION_STORE_FILE_DIR)\n+            + \"/\" + XID.getPort();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55ae70276b7236a52d00129d3e1707dff5445a0e"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMzMDYzOQ==", "bodyText": "ok", "url": "https://github.com/seata/seata/pull/3086#discussion_r535330639", "createdAt": "2020-12-03T15:28:08Z", "author": {"login": "a364176773"}, "path": "server/src/test/java/io/seata/server/store/SessionStoreTest.java", "diffHunk": "@@ -55,7 +56,8 @@\n      */\n     @BeforeEach\n     public void clean() throws Exception {\n-        String sessionStorePath = CONFIG.getConfig(ConfigurationKeys.STORE_FILE_DIR);\n+        String sessionStorePath = CONFIG.getConfig(ConfigurationKeys.STORE_FILE_DIR, DEFAULT_SESSION_STORE_FILE_DIR)\n+            + \"/\" + XID.getPort();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTI5NDE3Ng=="}, "originalCommit": {"oid": "55ae70276b7236a52d00129d3e1707dff5445a0e"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1OTAyNDcyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/raft/RaftStateMachine.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNjoyNzoxM1rOH-lSCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNjoyNzoxM1rOH-lSCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM4NDU4NQ==", "bodyText": "@OverRide", "url": "https://github.com/seata/seata/pull/3086#discussion_r535384585", "createdAt": "2020-12-03T16:27:13Z", "author": {"login": "caohdgege"}, "path": "server/src/main/java/io/seata/server/raft/RaftStateMachine.java", "diffHunk": "@@ -0,0 +1,348 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.raft;\n+\n+import java.io.File;\n+import java.nio.ByteBuffer;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import com.alipay.remoting.serialization.SerializerManager;\n+import com.alipay.sofa.jraft.Closure;\n+import com.alipay.sofa.jraft.Iterator;\n+import com.alipay.sofa.jraft.Status;\n+import com.alipay.sofa.jraft.error.RaftError;\n+import com.alipay.sofa.jraft.storage.snapshot.SnapshotReader;\n+import com.alipay.sofa.jraft.storage.snapshot.SnapshotWriter;\n+import com.alipay.sofa.jraft.util.Utils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.exception.TransactionException;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.raft.AbstractRaftStateMachine;\n+import io.seata.core.raft.RaftServerFactory;\n+import io.seata.core.rpc.processor.server.ServerOnRequestProcessor;\n+import io.seata.core.store.StoreMode;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionHelper;\n+import io.seata.server.session.SessionHolder;\n+import io.seata.server.session.SessionManager;\n+import io.seata.server.storage.SessionConverter;\n+import io.seata.server.storage.file.lock.FileLocker;\n+import io.seata.server.storage.raft.RaftSessionSyncMsg;\n+import io.seata.server.storage.raft.lock.RaftLockManager;\n+import io.seata.server.storage.raft.session.RaftSessionManager;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+import static com.alipay.remoting.serialization.SerializerManager.Hessian2;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.ACQUIRE_LOCK;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.ADD_BRANCH_SESSION;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.ADD_GLOBAL_SESSION;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.RELEASE_GLOBAL_SESSION_LOCK;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.REMOVE_BRANCH_SESSION;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.REMOVE_GLOBAL_SESSION;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.UPDATE_BRANCH_SESSION_STATUS;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.UPDATE_GLOBAL_SESSION_STATUS;\n+import static io.seata.server.session.SessionHolder.ASYNC_COMMITTING_SESSION_MANAGER_NAME;\n+import static io.seata.server.session.SessionHolder.RETRY_COMMITTING_SESSION_MANAGER_NAME;\n+import static io.seata.server.session.SessionHolder.RETRY_ROLLBACKING_SESSION_MANAGER_NAME;\n+import static io.seata.server.session.SessionHolder.ROOT_SESSION_MANAGER_NAME;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RaftStateMachine extends AbstractRaftStateMachine {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(RaftStateMachine.class);\n+\n+    /**\n+     * Leader term\n+     */\n+    private final AtomicLong leaderTerm = new AtomicLong(-1);\n+    /**\n+     * counter value\n+     */\n+\n+    public boolean isLeader() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55ae70276b7236a52d00129d3e1707dff5445a0e"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1OTAyNjM0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/raft/RaftStateMachine.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNjoyNzozMVrOH-lTBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNjoyNzozMVrOH-lTBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM4NDgzOA==", "bodyText": "\u5b57\u6bb5\u5b9a\u4e49\u632a\u5230\u65b9\u6cd5\u5b9a\u4e49\u4e0a\u9762", "url": "https://github.com/seata/seata/pull/3086#discussion_r535384838", "createdAt": "2020-12-03T16:27:31Z", "author": {"login": "caohdgege"}, "path": "server/src/main/java/io/seata/server/raft/RaftStateMachine.java", "diffHunk": "@@ -0,0 +1,348 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.raft;\n+\n+import java.io.File;\n+import java.nio.ByteBuffer;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import com.alipay.remoting.serialization.SerializerManager;\n+import com.alipay.sofa.jraft.Closure;\n+import com.alipay.sofa.jraft.Iterator;\n+import com.alipay.sofa.jraft.Status;\n+import com.alipay.sofa.jraft.error.RaftError;\n+import com.alipay.sofa.jraft.storage.snapshot.SnapshotReader;\n+import com.alipay.sofa.jraft.storage.snapshot.SnapshotWriter;\n+import com.alipay.sofa.jraft.util.Utils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.exception.TransactionException;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.raft.AbstractRaftStateMachine;\n+import io.seata.core.raft.RaftServerFactory;\n+import io.seata.core.rpc.processor.server.ServerOnRequestProcessor;\n+import io.seata.core.store.StoreMode;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionHelper;\n+import io.seata.server.session.SessionHolder;\n+import io.seata.server.session.SessionManager;\n+import io.seata.server.storage.SessionConverter;\n+import io.seata.server.storage.file.lock.FileLocker;\n+import io.seata.server.storage.raft.RaftSessionSyncMsg;\n+import io.seata.server.storage.raft.lock.RaftLockManager;\n+import io.seata.server.storage.raft.session.RaftSessionManager;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+import static com.alipay.remoting.serialization.SerializerManager.Hessian2;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.ACQUIRE_LOCK;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.ADD_BRANCH_SESSION;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.ADD_GLOBAL_SESSION;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.RELEASE_GLOBAL_SESSION_LOCK;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.REMOVE_BRANCH_SESSION;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.REMOVE_GLOBAL_SESSION;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.UPDATE_BRANCH_SESSION_STATUS;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.UPDATE_GLOBAL_SESSION_STATUS;\n+import static io.seata.server.session.SessionHolder.ASYNC_COMMITTING_SESSION_MANAGER_NAME;\n+import static io.seata.server.session.SessionHolder.RETRY_COMMITTING_SESSION_MANAGER_NAME;\n+import static io.seata.server.session.SessionHolder.RETRY_ROLLBACKING_SESSION_MANAGER_NAME;\n+import static io.seata.server.session.SessionHolder.ROOT_SESSION_MANAGER_NAME;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RaftStateMachine extends AbstractRaftStateMachine {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(RaftStateMachine.class);\n+\n+    /**\n+     * Leader term\n+     */\n+    private final AtomicLong leaderTerm = new AtomicLong(-1);\n+    /**\n+     * counter value\n+     */\n+\n+    public boolean isLeader() {\n+        return this.leaderTerm.get() > 0;\n+    }\n+\n+    RaftLockManager raftLockManager;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55ae70276b7236a52d00129d3e1707dff5445a0e"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1OTAyNzIwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/raft/RaftStateMachine.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNjoyNzo0MlrOH-lTgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwOTozNzoyNVrOIBP_bA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM4NDk2MA==", "bodyText": "\u8fd9\u4e2a\u6ce8\u91ca\u662f\uff1f", "url": "https://github.com/seata/seata/pull/3086#discussion_r535384960", "createdAt": "2020-12-03T16:27:42Z", "author": {"login": "caohdgege"}, "path": "server/src/main/java/io/seata/server/raft/RaftStateMachine.java", "diffHunk": "@@ -0,0 +1,348 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.raft;\n+\n+import java.io.File;\n+import java.nio.ByteBuffer;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import com.alipay.remoting.serialization.SerializerManager;\n+import com.alipay.sofa.jraft.Closure;\n+import com.alipay.sofa.jraft.Iterator;\n+import com.alipay.sofa.jraft.Status;\n+import com.alipay.sofa.jraft.error.RaftError;\n+import com.alipay.sofa.jraft.storage.snapshot.SnapshotReader;\n+import com.alipay.sofa.jraft.storage.snapshot.SnapshotWriter;\n+import com.alipay.sofa.jraft.util.Utils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.exception.TransactionException;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.raft.AbstractRaftStateMachine;\n+import io.seata.core.raft.RaftServerFactory;\n+import io.seata.core.rpc.processor.server.ServerOnRequestProcessor;\n+import io.seata.core.store.StoreMode;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionHelper;\n+import io.seata.server.session.SessionHolder;\n+import io.seata.server.session.SessionManager;\n+import io.seata.server.storage.SessionConverter;\n+import io.seata.server.storage.file.lock.FileLocker;\n+import io.seata.server.storage.raft.RaftSessionSyncMsg;\n+import io.seata.server.storage.raft.lock.RaftLockManager;\n+import io.seata.server.storage.raft.session.RaftSessionManager;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+import static com.alipay.remoting.serialization.SerializerManager.Hessian2;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.ACQUIRE_LOCK;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.ADD_BRANCH_SESSION;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.ADD_GLOBAL_SESSION;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.RELEASE_GLOBAL_SESSION_LOCK;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.REMOVE_BRANCH_SESSION;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.REMOVE_GLOBAL_SESSION;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.UPDATE_BRANCH_SESSION_STATUS;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.UPDATE_GLOBAL_SESSION_STATUS;\n+import static io.seata.server.session.SessionHolder.ASYNC_COMMITTING_SESSION_MANAGER_NAME;\n+import static io.seata.server.session.SessionHolder.RETRY_COMMITTING_SESSION_MANAGER_NAME;\n+import static io.seata.server.session.SessionHolder.RETRY_ROLLBACKING_SESSION_MANAGER_NAME;\n+import static io.seata.server.session.SessionHolder.ROOT_SESSION_MANAGER_NAME;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RaftStateMachine extends AbstractRaftStateMachine {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(RaftStateMachine.class);\n+\n+    /**\n+     * Leader term\n+     */\n+    private final AtomicLong leaderTerm = new AtomicLong(-1);\n+    /**\n+     * counter value", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55ae70276b7236a52d00129d3e1707dff5445a0e"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE4MTQ4NA==", "bodyText": "\u5fd8\u8bb0\u5220\u9664\u4e86\u3002\u3002\u3002\u3002", "url": "https://github.com/seata/seata/pull/3086#discussion_r538181484", "createdAt": "2020-12-08T09:37:25Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/raft/RaftStateMachine.java", "diffHunk": "@@ -0,0 +1,348 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.raft;\n+\n+import java.io.File;\n+import java.nio.ByteBuffer;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import com.alipay.remoting.serialization.SerializerManager;\n+import com.alipay.sofa.jraft.Closure;\n+import com.alipay.sofa.jraft.Iterator;\n+import com.alipay.sofa.jraft.Status;\n+import com.alipay.sofa.jraft.error.RaftError;\n+import com.alipay.sofa.jraft.storage.snapshot.SnapshotReader;\n+import com.alipay.sofa.jraft.storage.snapshot.SnapshotWriter;\n+import com.alipay.sofa.jraft.util.Utils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.exception.TransactionException;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.raft.AbstractRaftStateMachine;\n+import io.seata.core.raft.RaftServerFactory;\n+import io.seata.core.rpc.processor.server.ServerOnRequestProcessor;\n+import io.seata.core.store.StoreMode;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionHelper;\n+import io.seata.server.session.SessionHolder;\n+import io.seata.server.session.SessionManager;\n+import io.seata.server.storage.SessionConverter;\n+import io.seata.server.storage.file.lock.FileLocker;\n+import io.seata.server.storage.raft.RaftSessionSyncMsg;\n+import io.seata.server.storage.raft.lock.RaftLockManager;\n+import io.seata.server.storage.raft.session.RaftSessionManager;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+import static com.alipay.remoting.serialization.SerializerManager.Hessian2;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.ACQUIRE_LOCK;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.ADD_BRANCH_SESSION;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.ADD_GLOBAL_SESSION;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.RELEASE_GLOBAL_SESSION_LOCK;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.REMOVE_BRANCH_SESSION;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.REMOVE_GLOBAL_SESSION;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.UPDATE_BRANCH_SESSION_STATUS;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.UPDATE_GLOBAL_SESSION_STATUS;\n+import static io.seata.server.session.SessionHolder.ASYNC_COMMITTING_SESSION_MANAGER_NAME;\n+import static io.seata.server.session.SessionHolder.RETRY_COMMITTING_SESSION_MANAGER_NAME;\n+import static io.seata.server.session.SessionHolder.RETRY_ROLLBACKING_SESSION_MANAGER_NAME;\n+import static io.seata.server.session.SessionHolder.ROOT_SESSION_MANAGER_NAME;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RaftStateMachine extends AbstractRaftStateMachine {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(RaftStateMachine.class);\n+\n+    /**\n+     * Leader term\n+     */\n+    private final AtomicLong leaderTerm = new AtomicLong(-1);\n+    /**\n+     * counter value", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM4NDk2MA=="}, "originalCommit": {"oid": "55ae70276b7236a52d00129d3e1707dff5445a0e"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1OTAyODkwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/raft/RaftStateMachine.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNjoyODowMVrOH-lUkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwOTozNzozOVrOIBQADg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM4NTIzMw==", "bodyText": "\u632a\u4e0a\u53bb\uff1f", "url": "https://github.com/seata/seata/pull/3086#discussion_r535385233", "createdAt": "2020-12-03T16:28:01Z", "author": {"login": "caohdgege"}, "path": "server/src/main/java/io/seata/server/raft/RaftStateMachine.java", "diffHunk": "@@ -0,0 +1,348 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.raft;\n+\n+import java.io.File;\n+import java.nio.ByteBuffer;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import com.alipay.remoting.serialization.SerializerManager;\n+import com.alipay.sofa.jraft.Closure;\n+import com.alipay.sofa.jraft.Iterator;\n+import com.alipay.sofa.jraft.Status;\n+import com.alipay.sofa.jraft.error.RaftError;\n+import com.alipay.sofa.jraft.storage.snapshot.SnapshotReader;\n+import com.alipay.sofa.jraft.storage.snapshot.SnapshotWriter;\n+import com.alipay.sofa.jraft.util.Utils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.exception.TransactionException;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.raft.AbstractRaftStateMachine;\n+import io.seata.core.raft.RaftServerFactory;\n+import io.seata.core.rpc.processor.server.ServerOnRequestProcessor;\n+import io.seata.core.store.StoreMode;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionHelper;\n+import io.seata.server.session.SessionHolder;\n+import io.seata.server.session.SessionManager;\n+import io.seata.server.storage.SessionConverter;\n+import io.seata.server.storage.file.lock.FileLocker;\n+import io.seata.server.storage.raft.RaftSessionSyncMsg;\n+import io.seata.server.storage.raft.lock.RaftLockManager;\n+import io.seata.server.storage.raft.session.RaftSessionManager;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+import static com.alipay.remoting.serialization.SerializerManager.Hessian2;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.ACQUIRE_LOCK;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.ADD_BRANCH_SESSION;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.ADD_GLOBAL_SESSION;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.RELEASE_GLOBAL_SESSION_LOCK;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.REMOVE_BRANCH_SESSION;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.REMOVE_GLOBAL_SESSION;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.UPDATE_BRANCH_SESSION_STATUS;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.UPDATE_GLOBAL_SESSION_STATUS;\n+import static io.seata.server.session.SessionHolder.ASYNC_COMMITTING_SESSION_MANAGER_NAME;\n+import static io.seata.server.session.SessionHolder.RETRY_COMMITTING_SESSION_MANAGER_NAME;\n+import static io.seata.server.session.SessionHolder.RETRY_ROLLBACKING_SESSION_MANAGER_NAME;\n+import static io.seata.server.session.SessionHolder.ROOT_SESSION_MANAGER_NAME;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RaftStateMachine extends AbstractRaftStateMachine {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(RaftStateMachine.class);\n+\n+    /**\n+     * Leader term\n+     */\n+    private final AtomicLong leaderTerm = new AtomicLong(-1);\n+    /**\n+     * counter value\n+     */\n+\n+    public boolean isLeader() {\n+        return this.leaderTerm.get() > 0;\n+    }\n+\n+    RaftLockManager raftLockManager;\n+\n+    @Override\n+    public void setOnRequestProcessor(ServerOnRequestProcessor onRequestProcessor) {\n+        this.onRequestProcessor = onRequestProcessor;\n+        raftLockManager = new RaftLockManager();\n+    }\n+\n+    String mode;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55ae70276b7236a52d00129d3e1707dff5445a0e"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE4MTY0Ng==", "bodyText": "ok", "url": "https://github.com/seata/seata/pull/3086#discussion_r538181646", "createdAt": "2020-12-08T09:37:39Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/raft/RaftStateMachine.java", "diffHunk": "@@ -0,0 +1,348 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.raft;\n+\n+import java.io.File;\n+import java.nio.ByteBuffer;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import com.alipay.remoting.serialization.SerializerManager;\n+import com.alipay.sofa.jraft.Closure;\n+import com.alipay.sofa.jraft.Iterator;\n+import com.alipay.sofa.jraft.Status;\n+import com.alipay.sofa.jraft.error.RaftError;\n+import com.alipay.sofa.jraft.storage.snapshot.SnapshotReader;\n+import com.alipay.sofa.jraft.storage.snapshot.SnapshotWriter;\n+import com.alipay.sofa.jraft.util.Utils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.exception.TransactionException;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.raft.AbstractRaftStateMachine;\n+import io.seata.core.raft.RaftServerFactory;\n+import io.seata.core.rpc.processor.server.ServerOnRequestProcessor;\n+import io.seata.core.store.StoreMode;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionHelper;\n+import io.seata.server.session.SessionHolder;\n+import io.seata.server.session.SessionManager;\n+import io.seata.server.storage.SessionConverter;\n+import io.seata.server.storage.file.lock.FileLocker;\n+import io.seata.server.storage.raft.RaftSessionSyncMsg;\n+import io.seata.server.storage.raft.lock.RaftLockManager;\n+import io.seata.server.storage.raft.session.RaftSessionManager;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+import static com.alipay.remoting.serialization.SerializerManager.Hessian2;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.ACQUIRE_LOCK;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.ADD_BRANCH_SESSION;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.ADD_GLOBAL_SESSION;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.RELEASE_GLOBAL_SESSION_LOCK;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.REMOVE_BRANCH_SESSION;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.REMOVE_GLOBAL_SESSION;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.UPDATE_BRANCH_SESSION_STATUS;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.UPDATE_GLOBAL_SESSION_STATUS;\n+import static io.seata.server.session.SessionHolder.ASYNC_COMMITTING_SESSION_MANAGER_NAME;\n+import static io.seata.server.session.SessionHolder.RETRY_COMMITTING_SESSION_MANAGER_NAME;\n+import static io.seata.server.session.SessionHolder.RETRY_ROLLBACKING_SESSION_MANAGER_NAME;\n+import static io.seata.server.session.SessionHolder.ROOT_SESSION_MANAGER_NAME;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RaftStateMachine extends AbstractRaftStateMachine {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(RaftStateMachine.class);\n+\n+    /**\n+     * Leader term\n+     */\n+    private final AtomicLong leaderTerm = new AtomicLong(-1);\n+    /**\n+     * counter value\n+     */\n+\n+    public boolean isLeader() {\n+        return this.leaderTerm.get() > 0;\n+    }\n+\n+    RaftLockManager raftLockManager;\n+\n+    @Override\n+    public void setOnRequestProcessor(ServerOnRequestProcessor onRequestProcessor) {\n+        this.onRequestProcessor = onRequestProcessor;\n+        raftLockManager = new RaftLockManager();\n+    }\n+\n+    String mode;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM4NTIzMw=="}, "originalCommit": {"oid": "55ae70276b7236a52d00129d3e1707dff5445a0e"}, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1OTA2ODczOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/raft/RaftStateMachine.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNjozNjowMFrOH-lsgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwMzoxNDo0MFrOICzj0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM5MTM2MQ==", "bodyText": "\u4ec0\u4e48\u60c5\u51b5\u4e0b\u4f1a\u8fdb\u6765\u8fd9\u4e2a\u5206\u652f\uff1f", "url": "https://github.com/seata/seata/pull/3086#discussion_r535391361", "createdAt": "2020-12-03T16:36:00Z", "author": {"login": "caohdgege"}, "path": "server/src/main/java/io/seata/server/raft/RaftStateMachine.java", "diffHunk": "@@ -0,0 +1,348 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.raft;\n+\n+import java.io.File;\n+import java.nio.ByteBuffer;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import com.alipay.remoting.serialization.SerializerManager;\n+import com.alipay.sofa.jraft.Closure;\n+import com.alipay.sofa.jraft.Iterator;\n+import com.alipay.sofa.jraft.Status;\n+import com.alipay.sofa.jraft.error.RaftError;\n+import com.alipay.sofa.jraft.storage.snapshot.SnapshotReader;\n+import com.alipay.sofa.jraft.storage.snapshot.SnapshotWriter;\n+import com.alipay.sofa.jraft.util.Utils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.exception.TransactionException;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.raft.AbstractRaftStateMachine;\n+import io.seata.core.raft.RaftServerFactory;\n+import io.seata.core.rpc.processor.server.ServerOnRequestProcessor;\n+import io.seata.core.store.StoreMode;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionHelper;\n+import io.seata.server.session.SessionHolder;\n+import io.seata.server.session.SessionManager;\n+import io.seata.server.storage.SessionConverter;\n+import io.seata.server.storage.file.lock.FileLocker;\n+import io.seata.server.storage.raft.RaftSessionSyncMsg;\n+import io.seata.server.storage.raft.lock.RaftLockManager;\n+import io.seata.server.storage.raft.session.RaftSessionManager;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+import static com.alipay.remoting.serialization.SerializerManager.Hessian2;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.ACQUIRE_LOCK;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.ADD_BRANCH_SESSION;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.ADD_GLOBAL_SESSION;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.RELEASE_GLOBAL_SESSION_LOCK;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.REMOVE_BRANCH_SESSION;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.REMOVE_GLOBAL_SESSION;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.UPDATE_BRANCH_SESSION_STATUS;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.UPDATE_GLOBAL_SESSION_STATUS;\n+import static io.seata.server.session.SessionHolder.ASYNC_COMMITTING_SESSION_MANAGER_NAME;\n+import static io.seata.server.session.SessionHolder.RETRY_COMMITTING_SESSION_MANAGER_NAME;\n+import static io.seata.server.session.SessionHolder.RETRY_ROLLBACKING_SESSION_MANAGER_NAME;\n+import static io.seata.server.session.SessionHolder.ROOT_SESSION_MANAGER_NAME;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RaftStateMachine extends AbstractRaftStateMachine {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(RaftStateMachine.class);\n+\n+    /**\n+     * Leader term\n+     */\n+    private final AtomicLong leaderTerm = new AtomicLong(-1);\n+    /**\n+     * counter value\n+     */\n+\n+    public boolean isLeader() {\n+        return this.leaderTerm.get() > 0;\n+    }\n+\n+    RaftLockManager raftLockManager;\n+\n+    @Override\n+    public void setOnRequestProcessor(ServerOnRequestProcessor onRequestProcessor) {\n+        this.onRequestProcessor = onRequestProcessor;\n+        raftLockManager = new RaftLockManager();\n+    }\n+\n+    String mode;\n+\n+    public RaftStateMachine() {\n+        mode = ConfigurationFactory.getInstance().getConfig(ConfigurationKeys.STORE_MODE);\n+    }\n+\n+    @Override\n+    public void onApply(Iterator iterator) {\n+        while (iterator.hasNext()) {\n+            Closure processor = null;\n+            if (iterator.done() != null) {\n+                processor = iterator.done();\n+            } else {\n+                try {\n+                    ByteBuffer byteBuffer = iterator.getData();\n+                    if (byteBuffer != null) {\n+                        RaftSessionSyncMsg msg = SerializerManager.getSerializer(Hessian2)\n+                            .deserialize(iterator.getData().array(), RaftSessionSyncMsg.class.getName());\n+                        onExecuteRaft(msg);\n+                    }\n+                } catch (Exception e) {\n+                    LOG.error(\"Message synchronization failure\", e);\n+                }\n+            }\n+            if (processor != null) {\n+                processor.run(Status.OK());\n+            }\n+            iterator.next();\n+        }\n+    }\n+\n+\n+    @Override\n+    public void onSnapshotSave(final SnapshotWriter writer, final Closure done) {\n+        if (!StringUtils.equals(StoreMode.RAFT.getName(), mode)) {\n+            return;\n+        }\n+        Map<String, Object> maps = new HashMap<>();\n+        RaftSessionManager raftSessionManager = (RaftSessionManager)SessionHolder.getRootSessionManager();\n+        Map<String, GlobalSession> sessionMap = raftSessionManager.getSessionMap();\n+        Map<String, byte[]> sessionByteMap = new HashMap<>();\n+        sessionMap.forEach((k, v) -> sessionByteMap.put(v.getXid(), v.encode()));\n+        maps.put(ROOT_SESSION_MANAGER_NAME, sessionByteMap);\n+        ConcurrentMap<String/* resourceId */, ConcurrentMap<String/* tableName */,\n+            ConcurrentMap<Integer/* bucketId */, FileLocker.BucketLockMap>>>\n+            LOCK_MAP = FileLocker.LOCK_MAP;\n+        maps.put(\"LOCK_MAP\", LOCK_MAP);\n+        LOG.info(\"sessionmap size:{},lock map size:{}\",sessionMap.size(), LOCK_MAP.size());\n+        if (maps.isEmpty()) {\n+            return;\n+        }\n+        Utils.runInThread(() -> {\n+            final RaftSnapshotFile snapshot = new RaftSnapshotFile(writer.getPath() + File.separator + \"data\");\n+            if (snapshot.save(maps)) {\n+                if (writer.addFile(\"data\")) {\n+                    done.run(Status.OK());\n+                } else {\n+                    done.run(new Status(RaftError.EIO, \"Fail to add file to writer\"));\n+                }\n+            } else {\n+                done.run(new Status(RaftError.EIO, \"Fail to save counter snapshot %s\", snapshot.getPath()));\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public boolean onSnapshotLoad(final SnapshotReader reader) {\n+        if (!StringUtils.equals(StoreMode.RAFT.getName(), mode)) {\n+            return false;\n+        }\n+        if (isLeader()) {\n+            LOG.warn(\"Leader is not supposed to load snapshot\");\n+            return false;\n+        }\n+        if (reader.getFileMeta(\"data\") == null) {\n+            LOG.error(\"Fail to find data file in {}\", reader.getPath());\n+            return false;\n+        }\n+        final RaftSnapshotFile snapshot = new RaftSnapshotFile(reader.getPath() + File.separator + \"data\");\n+        try {\n+            Map<String, Object> maps = snapshot.load();\n+            RaftSessionManager raftSessionManager = (RaftSessionManager)SessionHolder.getRootSessionManager();\n+            FileLocker.LOCK_MAP.putAll((Map<? extends String,\n+                ? extends ConcurrentMap<String, ConcurrentMap<Integer, FileLocker.BucketLockMap>>>)maps\n+                    .get(\"LOCK_MAP\"));\n+            Map<String, byte[]> sessionByteMap = (Map<String, byte[]>)maps.get(ROOT_SESSION_MANAGER_NAME);\n+            Map<String, GlobalSession> rootSessionMap = raftSessionManager.getSessionMap();\n+            if (!sessionByteMap.isEmpty()) {\n+                Map<String, GlobalSession> sessionMap = new HashMap<>();\n+                sessionByteMap.forEach((k, v) -> {\n+                    GlobalSession session = new GlobalSession();\n+                    session.decode(v);\n+                    sessionMap.put(k, session);\n+                });\n+                rootSessionMap.putAll(sessionMap);\n+                sessionMap.forEach((k, v) -> {\n+                    GlobalStatus status = v.getStatus();\n+                    try {\n+                        if (status == GlobalStatus.AsyncCommitting) {\n+                            SessionHolder.getAsyncCommittingSessionManager().addGlobalSession(v);\n+                        } else if (status == GlobalStatus.CommitRetrying) {\n+                            SessionHolder.getRetryCommittingSessionManager().addGlobalSession(v);\n+                        } else if (status == GlobalStatus.RollbackRetrying) {\n+                            SessionHolder.getRetryRollbackingSessionManager().addGlobalSession(v);\n+                        }\n+                    } catch (TransactionException e) {\n+                        e.printStackTrace();\n+                    }\n+                });\n+            }\n+            return true;\n+        } catch (final Exception e) {\n+            LOG.error(\"Fail to load snapshot from {}\", snapshot.getPath());\n+            return false;\n+        }\n+\n+    }\n+\n+\n+    @Override\n+    public void onLeaderStart(final long term) {\n+        this.leaderTerm.set(term);\n+        if (RaftServerFactory.getInstance().isRaftMode()) {\n+            RaftSessionManager raftSessionManager = (RaftSessionManager)SessionHolder.getRootSessionManager();\n+            Map<String, GlobalSession> retryRollbackingMap =\n+                ((RaftSessionManager)SessionHolder.getRetryRollbackingSessionManager()).getSessionMap();\n+            Map<String, GlobalSession> sessionMap = raftSessionManager.getSessionMap();\n+            sessionMap.forEach((k, v) -> {\n+                GlobalStatus status = v.getStatus();\n+                if (status == GlobalStatus.RollbackRetrying || status == GlobalStatus.Rollbacking\n+                    || status == GlobalStatus.TimeoutRollbacking || status == GlobalStatus.TimeoutRollbackRetrying) {\n+                    retryRollbackingMap.computeIfAbsent(v.getXid(), session -> {\n+                        v.addSessionLifecycleListener(SessionHolder.getRetryRollbackingSessionManager());\n+                        return v;\n+                    });\n+                }\n+            });\n+        }\n+        super.onLeaderStart(term);\n+    }\n+\n+    @Override\n+    public void onLeaderStop(final Status status) {\n+        this.leaderTerm.set(-1);\n+        super.onLeaderStop(status);\n+    }\n+\n+    private void onExecuteRaft(RaftSessionSyncMsg msg) throws TransactionException {\n+        RaftSessionSyncMsg.MsgType msgType = msg.getMsgType();\n+        SessionManager sessionManager = null;\n+        String sessionName = msg.getSessionName();\n+        Boolean rootManager = false;\n+        if (Objects.equals(sessionName, ROOT_SESSION_MANAGER_NAME)) {\n+            sessionManager = SessionHolder.getRootSessionManager();\n+            rootManager = true;\n+        } else if (Objects.equals(sessionName, ASYNC_COMMITTING_SESSION_MANAGER_NAME)) {\n+            sessionManager = SessionHolder.getAsyncCommittingSessionManager();\n+        } else if (Objects.equals(sessionName, RETRY_COMMITTING_SESSION_MANAGER_NAME)) {\n+            sessionManager = SessionHolder.getRetryCommittingSessionManager();\n+        } else if (Objects.equals(sessionName, RETRY_ROLLBACKING_SESSION_MANAGER_NAME)) {\n+            sessionManager = SessionHolder.getRetryRollbackingSessionManager();\n+        }\n+        RaftSessionManager raftSessionManager = sessionManager != null ? (RaftSessionManager)sessionManager : null;\n+        LOG.info(\"state machine synchronization,task:{},sessionManager:{}\", msgType,\n+            sessionName != null ? sessionName : ROOT_SESSION_MANAGER_NAME);\n+        if (ADD_GLOBAL_SESSION.equals(msgType)) {\n+            GlobalSession globalSession;\n+            if (!rootManager) {\n+                globalSession =\n+                    SessionHolder.getRootSessionManager().findGlobalSession(msg.getGlobalSession().getXid());\n+            } else {\n+                globalSession = SessionConverter.convertGlobalSession(msg.getGlobalSession());\n+            }\n+            raftSessionManager.getFileSessionManager().addGlobalSession(globalSession);\n+        } else if (ACQUIRE_LOCK.equals(msgType)) {\n+            GlobalSession globalSession =\n+                SessionHolder.getRootSessionManager().findGlobalSession(msg.getBranchSession().getXid());\n+            BranchSession branchSession = globalSession.getBranch(msg.getBranchSession().getBranchId());\n+            boolean include = false;\n+            if (branchSession != null) {\n+                include = true;\n+                branchSession.setLockKey(msg.getBranchSession().getLockKey());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55ae70276b7236a52d00129d3e1707dff5445a0e"}, "originalPosition": 279}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTgxMjgxOA==", "bodyText": "\u6ce8\u518c\u5206\u652f\u65f6\uff0c\u5148\u8d70ACQUIRE_LOCK\u4f1a\u643a\u5e26branch\u4fe1\u606f\uff0c\u53ef\u5728\u6b64\u65f6\u5c31\u505a\u540c\u6b65", "url": "https://github.com/seata/seata/pull/3086#discussion_r539812818", "createdAt": "2020-12-10T03:14:40Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/raft/RaftStateMachine.java", "diffHunk": "@@ -0,0 +1,348 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.raft;\n+\n+import java.io.File;\n+import java.nio.ByteBuffer;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import com.alipay.remoting.serialization.SerializerManager;\n+import com.alipay.sofa.jraft.Closure;\n+import com.alipay.sofa.jraft.Iterator;\n+import com.alipay.sofa.jraft.Status;\n+import com.alipay.sofa.jraft.error.RaftError;\n+import com.alipay.sofa.jraft.storage.snapshot.SnapshotReader;\n+import com.alipay.sofa.jraft.storage.snapshot.SnapshotWriter;\n+import com.alipay.sofa.jraft.util.Utils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.exception.TransactionException;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.raft.AbstractRaftStateMachine;\n+import io.seata.core.raft.RaftServerFactory;\n+import io.seata.core.rpc.processor.server.ServerOnRequestProcessor;\n+import io.seata.core.store.StoreMode;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionHelper;\n+import io.seata.server.session.SessionHolder;\n+import io.seata.server.session.SessionManager;\n+import io.seata.server.storage.SessionConverter;\n+import io.seata.server.storage.file.lock.FileLocker;\n+import io.seata.server.storage.raft.RaftSessionSyncMsg;\n+import io.seata.server.storage.raft.lock.RaftLockManager;\n+import io.seata.server.storage.raft.session.RaftSessionManager;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+import static com.alipay.remoting.serialization.SerializerManager.Hessian2;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.ACQUIRE_LOCK;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.ADD_BRANCH_SESSION;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.ADD_GLOBAL_SESSION;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.RELEASE_GLOBAL_SESSION_LOCK;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.REMOVE_BRANCH_SESSION;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.REMOVE_GLOBAL_SESSION;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.UPDATE_BRANCH_SESSION_STATUS;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.UPDATE_GLOBAL_SESSION_STATUS;\n+import static io.seata.server.session.SessionHolder.ASYNC_COMMITTING_SESSION_MANAGER_NAME;\n+import static io.seata.server.session.SessionHolder.RETRY_COMMITTING_SESSION_MANAGER_NAME;\n+import static io.seata.server.session.SessionHolder.RETRY_ROLLBACKING_SESSION_MANAGER_NAME;\n+import static io.seata.server.session.SessionHolder.ROOT_SESSION_MANAGER_NAME;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RaftStateMachine extends AbstractRaftStateMachine {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(RaftStateMachine.class);\n+\n+    /**\n+     * Leader term\n+     */\n+    private final AtomicLong leaderTerm = new AtomicLong(-1);\n+    /**\n+     * counter value\n+     */\n+\n+    public boolean isLeader() {\n+        return this.leaderTerm.get() > 0;\n+    }\n+\n+    RaftLockManager raftLockManager;\n+\n+    @Override\n+    public void setOnRequestProcessor(ServerOnRequestProcessor onRequestProcessor) {\n+        this.onRequestProcessor = onRequestProcessor;\n+        raftLockManager = new RaftLockManager();\n+    }\n+\n+    String mode;\n+\n+    public RaftStateMachine() {\n+        mode = ConfigurationFactory.getInstance().getConfig(ConfigurationKeys.STORE_MODE);\n+    }\n+\n+    @Override\n+    public void onApply(Iterator iterator) {\n+        while (iterator.hasNext()) {\n+            Closure processor = null;\n+            if (iterator.done() != null) {\n+                processor = iterator.done();\n+            } else {\n+                try {\n+                    ByteBuffer byteBuffer = iterator.getData();\n+                    if (byteBuffer != null) {\n+                        RaftSessionSyncMsg msg = SerializerManager.getSerializer(Hessian2)\n+                            .deserialize(iterator.getData().array(), RaftSessionSyncMsg.class.getName());\n+                        onExecuteRaft(msg);\n+                    }\n+                } catch (Exception e) {\n+                    LOG.error(\"Message synchronization failure\", e);\n+                }\n+            }\n+            if (processor != null) {\n+                processor.run(Status.OK());\n+            }\n+            iterator.next();\n+        }\n+    }\n+\n+\n+    @Override\n+    public void onSnapshotSave(final SnapshotWriter writer, final Closure done) {\n+        if (!StringUtils.equals(StoreMode.RAFT.getName(), mode)) {\n+            return;\n+        }\n+        Map<String, Object> maps = new HashMap<>();\n+        RaftSessionManager raftSessionManager = (RaftSessionManager)SessionHolder.getRootSessionManager();\n+        Map<String, GlobalSession> sessionMap = raftSessionManager.getSessionMap();\n+        Map<String, byte[]> sessionByteMap = new HashMap<>();\n+        sessionMap.forEach((k, v) -> sessionByteMap.put(v.getXid(), v.encode()));\n+        maps.put(ROOT_SESSION_MANAGER_NAME, sessionByteMap);\n+        ConcurrentMap<String/* resourceId */, ConcurrentMap<String/* tableName */,\n+            ConcurrentMap<Integer/* bucketId */, FileLocker.BucketLockMap>>>\n+            LOCK_MAP = FileLocker.LOCK_MAP;\n+        maps.put(\"LOCK_MAP\", LOCK_MAP);\n+        LOG.info(\"sessionmap size:{},lock map size:{}\",sessionMap.size(), LOCK_MAP.size());\n+        if (maps.isEmpty()) {\n+            return;\n+        }\n+        Utils.runInThread(() -> {\n+            final RaftSnapshotFile snapshot = new RaftSnapshotFile(writer.getPath() + File.separator + \"data\");\n+            if (snapshot.save(maps)) {\n+                if (writer.addFile(\"data\")) {\n+                    done.run(Status.OK());\n+                } else {\n+                    done.run(new Status(RaftError.EIO, \"Fail to add file to writer\"));\n+                }\n+            } else {\n+                done.run(new Status(RaftError.EIO, \"Fail to save counter snapshot %s\", snapshot.getPath()));\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public boolean onSnapshotLoad(final SnapshotReader reader) {\n+        if (!StringUtils.equals(StoreMode.RAFT.getName(), mode)) {\n+            return false;\n+        }\n+        if (isLeader()) {\n+            LOG.warn(\"Leader is not supposed to load snapshot\");\n+            return false;\n+        }\n+        if (reader.getFileMeta(\"data\") == null) {\n+            LOG.error(\"Fail to find data file in {}\", reader.getPath());\n+            return false;\n+        }\n+        final RaftSnapshotFile snapshot = new RaftSnapshotFile(reader.getPath() + File.separator + \"data\");\n+        try {\n+            Map<String, Object> maps = snapshot.load();\n+            RaftSessionManager raftSessionManager = (RaftSessionManager)SessionHolder.getRootSessionManager();\n+            FileLocker.LOCK_MAP.putAll((Map<? extends String,\n+                ? extends ConcurrentMap<String, ConcurrentMap<Integer, FileLocker.BucketLockMap>>>)maps\n+                    .get(\"LOCK_MAP\"));\n+            Map<String, byte[]> sessionByteMap = (Map<String, byte[]>)maps.get(ROOT_SESSION_MANAGER_NAME);\n+            Map<String, GlobalSession> rootSessionMap = raftSessionManager.getSessionMap();\n+            if (!sessionByteMap.isEmpty()) {\n+                Map<String, GlobalSession> sessionMap = new HashMap<>();\n+                sessionByteMap.forEach((k, v) -> {\n+                    GlobalSession session = new GlobalSession();\n+                    session.decode(v);\n+                    sessionMap.put(k, session);\n+                });\n+                rootSessionMap.putAll(sessionMap);\n+                sessionMap.forEach((k, v) -> {\n+                    GlobalStatus status = v.getStatus();\n+                    try {\n+                        if (status == GlobalStatus.AsyncCommitting) {\n+                            SessionHolder.getAsyncCommittingSessionManager().addGlobalSession(v);\n+                        } else if (status == GlobalStatus.CommitRetrying) {\n+                            SessionHolder.getRetryCommittingSessionManager().addGlobalSession(v);\n+                        } else if (status == GlobalStatus.RollbackRetrying) {\n+                            SessionHolder.getRetryRollbackingSessionManager().addGlobalSession(v);\n+                        }\n+                    } catch (TransactionException e) {\n+                        e.printStackTrace();\n+                    }\n+                });\n+            }\n+            return true;\n+        } catch (final Exception e) {\n+            LOG.error(\"Fail to load snapshot from {}\", snapshot.getPath());\n+            return false;\n+        }\n+\n+    }\n+\n+\n+    @Override\n+    public void onLeaderStart(final long term) {\n+        this.leaderTerm.set(term);\n+        if (RaftServerFactory.getInstance().isRaftMode()) {\n+            RaftSessionManager raftSessionManager = (RaftSessionManager)SessionHolder.getRootSessionManager();\n+            Map<String, GlobalSession> retryRollbackingMap =\n+                ((RaftSessionManager)SessionHolder.getRetryRollbackingSessionManager()).getSessionMap();\n+            Map<String, GlobalSession> sessionMap = raftSessionManager.getSessionMap();\n+            sessionMap.forEach((k, v) -> {\n+                GlobalStatus status = v.getStatus();\n+                if (status == GlobalStatus.RollbackRetrying || status == GlobalStatus.Rollbacking\n+                    || status == GlobalStatus.TimeoutRollbacking || status == GlobalStatus.TimeoutRollbackRetrying) {\n+                    retryRollbackingMap.computeIfAbsent(v.getXid(), session -> {\n+                        v.addSessionLifecycleListener(SessionHolder.getRetryRollbackingSessionManager());\n+                        return v;\n+                    });\n+                }\n+            });\n+        }\n+        super.onLeaderStart(term);\n+    }\n+\n+    @Override\n+    public void onLeaderStop(final Status status) {\n+        this.leaderTerm.set(-1);\n+        super.onLeaderStop(status);\n+    }\n+\n+    private void onExecuteRaft(RaftSessionSyncMsg msg) throws TransactionException {\n+        RaftSessionSyncMsg.MsgType msgType = msg.getMsgType();\n+        SessionManager sessionManager = null;\n+        String sessionName = msg.getSessionName();\n+        Boolean rootManager = false;\n+        if (Objects.equals(sessionName, ROOT_SESSION_MANAGER_NAME)) {\n+            sessionManager = SessionHolder.getRootSessionManager();\n+            rootManager = true;\n+        } else if (Objects.equals(sessionName, ASYNC_COMMITTING_SESSION_MANAGER_NAME)) {\n+            sessionManager = SessionHolder.getAsyncCommittingSessionManager();\n+        } else if (Objects.equals(sessionName, RETRY_COMMITTING_SESSION_MANAGER_NAME)) {\n+            sessionManager = SessionHolder.getRetryCommittingSessionManager();\n+        } else if (Objects.equals(sessionName, RETRY_ROLLBACKING_SESSION_MANAGER_NAME)) {\n+            sessionManager = SessionHolder.getRetryRollbackingSessionManager();\n+        }\n+        RaftSessionManager raftSessionManager = sessionManager != null ? (RaftSessionManager)sessionManager : null;\n+        LOG.info(\"state machine synchronization,task:{},sessionManager:{}\", msgType,\n+            sessionName != null ? sessionName : ROOT_SESSION_MANAGER_NAME);\n+        if (ADD_GLOBAL_SESSION.equals(msgType)) {\n+            GlobalSession globalSession;\n+            if (!rootManager) {\n+                globalSession =\n+                    SessionHolder.getRootSessionManager().findGlobalSession(msg.getGlobalSession().getXid());\n+            } else {\n+                globalSession = SessionConverter.convertGlobalSession(msg.getGlobalSession());\n+            }\n+            raftSessionManager.getFileSessionManager().addGlobalSession(globalSession);\n+        } else if (ACQUIRE_LOCK.equals(msgType)) {\n+            GlobalSession globalSession =\n+                SessionHolder.getRootSessionManager().findGlobalSession(msg.getBranchSession().getXid());\n+            BranchSession branchSession = globalSession.getBranch(msg.getBranchSession().getBranchId());\n+            boolean include = false;\n+            if (branchSession != null) {\n+                include = true;\n+                branchSession.setLockKey(msg.getBranchSession().getLockKey());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM5MTM2MQ=="}, "originalCommit": {"oid": "55ae70276b7236a52d00129d3e1707dff5445a0e"}, "originalPosition": 279}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1OTA5OTY1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/raft/RaftStateMachine.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNjo0MTozNFrOH-l_GQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwMzoxNjowN1rOICzlsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM5NjEyMQ==", "bodyText": "\u8fd9\u6837\u7684\u8bdd\uff0c\u662f\u4e0d\u662f\u4ece\u8282\u70b9globalSession.add\u6bd4\u4e3b\u8282\u70b9\u65e9\uff1f\n\u5e76\u4e14\u4e3b\u8282\u70b9\u90a3\u8fb9\u662ftry_catch\u6765\u4fdd\u8bc1\u5982\u679cglobalSession.add\u7684\u65f6\u5019\u62a5\u9519\u4e86\u4f1aunlock\uff0c\u8fd9\u8fb9\u4fdd\u8bc1\u8fd9\u4e2a\u7684\u673a\u5236\u662f\uff1f\n\u662f\u4e0d\u662f\u9700\u8981unlock\u7684\u65f6\u5019\u4e5f\u8fdb\u884c\u540c\u6b65\uff1f", "url": "https://github.com/seata/seata/pull/3086#discussion_r535396121", "createdAt": "2020-12-03T16:41:34Z", "author": {"login": "caohdgege"}, "path": "server/src/main/java/io/seata/server/raft/RaftStateMachine.java", "diffHunk": "@@ -0,0 +1,348 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.raft;\n+\n+import java.io.File;\n+import java.nio.ByteBuffer;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import com.alipay.remoting.serialization.SerializerManager;\n+import com.alipay.sofa.jraft.Closure;\n+import com.alipay.sofa.jraft.Iterator;\n+import com.alipay.sofa.jraft.Status;\n+import com.alipay.sofa.jraft.error.RaftError;\n+import com.alipay.sofa.jraft.storage.snapshot.SnapshotReader;\n+import com.alipay.sofa.jraft.storage.snapshot.SnapshotWriter;\n+import com.alipay.sofa.jraft.util.Utils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.exception.TransactionException;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.raft.AbstractRaftStateMachine;\n+import io.seata.core.raft.RaftServerFactory;\n+import io.seata.core.rpc.processor.server.ServerOnRequestProcessor;\n+import io.seata.core.store.StoreMode;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionHelper;\n+import io.seata.server.session.SessionHolder;\n+import io.seata.server.session.SessionManager;\n+import io.seata.server.storage.SessionConverter;\n+import io.seata.server.storage.file.lock.FileLocker;\n+import io.seata.server.storage.raft.RaftSessionSyncMsg;\n+import io.seata.server.storage.raft.lock.RaftLockManager;\n+import io.seata.server.storage.raft.session.RaftSessionManager;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+import static com.alipay.remoting.serialization.SerializerManager.Hessian2;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.ACQUIRE_LOCK;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.ADD_BRANCH_SESSION;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.ADD_GLOBAL_SESSION;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.RELEASE_GLOBAL_SESSION_LOCK;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.REMOVE_BRANCH_SESSION;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.REMOVE_GLOBAL_SESSION;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.UPDATE_BRANCH_SESSION_STATUS;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.UPDATE_GLOBAL_SESSION_STATUS;\n+import static io.seata.server.session.SessionHolder.ASYNC_COMMITTING_SESSION_MANAGER_NAME;\n+import static io.seata.server.session.SessionHolder.RETRY_COMMITTING_SESSION_MANAGER_NAME;\n+import static io.seata.server.session.SessionHolder.RETRY_ROLLBACKING_SESSION_MANAGER_NAME;\n+import static io.seata.server.session.SessionHolder.ROOT_SESSION_MANAGER_NAME;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RaftStateMachine extends AbstractRaftStateMachine {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(RaftStateMachine.class);\n+\n+    /**\n+     * Leader term\n+     */\n+    private final AtomicLong leaderTerm = new AtomicLong(-1);\n+    /**\n+     * counter value\n+     */\n+\n+    public boolean isLeader() {\n+        return this.leaderTerm.get() > 0;\n+    }\n+\n+    RaftLockManager raftLockManager;\n+\n+    @Override\n+    public void setOnRequestProcessor(ServerOnRequestProcessor onRequestProcessor) {\n+        this.onRequestProcessor = onRequestProcessor;\n+        raftLockManager = new RaftLockManager();\n+    }\n+\n+    String mode;\n+\n+    public RaftStateMachine() {\n+        mode = ConfigurationFactory.getInstance().getConfig(ConfigurationKeys.STORE_MODE);\n+    }\n+\n+    @Override\n+    public void onApply(Iterator iterator) {\n+        while (iterator.hasNext()) {\n+            Closure processor = null;\n+            if (iterator.done() != null) {\n+                processor = iterator.done();\n+            } else {\n+                try {\n+                    ByteBuffer byteBuffer = iterator.getData();\n+                    if (byteBuffer != null) {\n+                        RaftSessionSyncMsg msg = SerializerManager.getSerializer(Hessian2)\n+                            .deserialize(iterator.getData().array(), RaftSessionSyncMsg.class.getName());\n+                        onExecuteRaft(msg);\n+                    }\n+                } catch (Exception e) {\n+                    LOG.error(\"Message synchronization failure\", e);\n+                }\n+            }\n+            if (processor != null) {\n+                processor.run(Status.OK());\n+            }\n+            iterator.next();\n+        }\n+    }\n+\n+\n+    @Override\n+    public void onSnapshotSave(final SnapshotWriter writer, final Closure done) {\n+        if (!StringUtils.equals(StoreMode.RAFT.getName(), mode)) {\n+            return;\n+        }\n+        Map<String, Object> maps = new HashMap<>();\n+        RaftSessionManager raftSessionManager = (RaftSessionManager)SessionHolder.getRootSessionManager();\n+        Map<String, GlobalSession> sessionMap = raftSessionManager.getSessionMap();\n+        Map<String, byte[]> sessionByteMap = new HashMap<>();\n+        sessionMap.forEach((k, v) -> sessionByteMap.put(v.getXid(), v.encode()));\n+        maps.put(ROOT_SESSION_MANAGER_NAME, sessionByteMap);\n+        ConcurrentMap<String/* resourceId */, ConcurrentMap<String/* tableName */,\n+            ConcurrentMap<Integer/* bucketId */, FileLocker.BucketLockMap>>>\n+            LOCK_MAP = FileLocker.LOCK_MAP;\n+        maps.put(\"LOCK_MAP\", LOCK_MAP);\n+        LOG.info(\"sessionmap size:{},lock map size:{}\",sessionMap.size(), LOCK_MAP.size());\n+        if (maps.isEmpty()) {\n+            return;\n+        }\n+        Utils.runInThread(() -> {\n+            final RaftSnapshotFile snapshot = new RaftSnapshotFile(writer.getPath() + File.separator + \"data\");\n+            if (snapshot.save(maps)) {\n+                if (writer.addFile(\"data\")) {\n+                    done.run(Status.OK());\n+                } else {\n+                    done.run(new Status(RaftError.EIO, \"Fail to add file to writer\"));\n+                }\n+            } else {\n+                done.run(new Status(RaftError.EIO, \"Fail to save counter snapshot %s\", snapshot.getPath()));\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public boolean onSnapshotLoad(final SnapshotReader reader) {\n+        if (!StringUtils.equals(StoreMode.RAFT.getName(), mode)) {\n+            return false;\n+        }\n+        if (isLeader()) {\n+            LOG.warn(\"Leader is not supposed to load snapshot\");\n+            return false;\n+        }\n+        if (reader.getFileMeta(\"data\") == null) {\n+            LOG.error(\"Fail to find data file in {}\", reader.getPath());\n+            return false;\n+        }\n+        final RaftSnapshotFile snapshot = new RaftSnapshotFile(reader.getPath() + File.separator + \"data\");\n+        try {\n+            Map<String, Object> maps = snapshot.load();\n+            RaftSessionManager raftSessionManager = (RaftSessionManager)SessionHolder.getRootSessionManager();\n+            FileLocker.LOCK_MAP.putAll((Map<? extends String,\n+                ? extends ConcurrentMap<String, ConcurrentMap<Integer, FileLocker.BucketLockMap>>>)maps\n+                    .get(\"LOCK_MAP\"));\n+            Map<String, byte[]> sessionByteMap = (Map<String, byte[]>)maps.get(ROOT_SESSION_MANAGER_NAME);\n+            Map<String, GlobalSession> rootSessionMap = raftSessionManager.getSessionMap();\n+            if (!sessionByteMap.isEmpty()) {\n+                Map<String, GlobalSession> sessionMap = new HashMap<>();\n+                sessionByteMap.forEach((k, v) -> {\n+                    GlobalSession session = new GlobalSession();\n+                    session.decode(v);\n+                    sessionMap.put(k, session);\n+                });\n+                rootSessionMap.putAll(sessionMap);\n+                sessionMap.forEach((k, v) -> {\n+                    GlobalStatus status = v.getStatus();\n+                    try {\n+                        if (status == GlobalStatus.AsyncCommitting) {\n+                            SessionHolder.getAsyncCommittingSessionManager().addGlobalSession(v);\n+                        } else if (status == GlobalStatus.CommitRetrying) {\n+                            SessionHolder.getRetryCommittingSessionManager().addGlobalSession(v);\n+                        } else if (status == GlobalStatus.RollbackRetrying) {\n+                            SessionHolder.getRetryRollbackingSessionManager().addGlobalSession(v);\n+                        }\n+                    } catch (TransactionException e) {\n+                        e.printStackTrace();\n+                    }\n+                });\n+            }\n+            return true;\n+        } catch (final Exception e) {\n+            LOG.error(\"Fail to load snapshot from {}\", snapshot.getPath());\n+            return false;\n+        }\n+\n+    }\n+\n+\n+    @Override\n+    public void onLeaderStart(final long term) {\n+        this.leaderTerm.set(term);\n+        if (RaftServerFactory.getInstance().isRaftMode()) {\n+            RaftSessionManager raftSessionManager = (RaftSessionManager)SessionHolder.getRootSessionManager();\n+            Map<String, GlobalSession> retryRollbackingMap =\n+                ((RaftSessionManager)SessionHolder.getRetryRollbackingSessionManager()).getSessionMap();\n+            Map<String, GlobalSession> sessionMap = raftSessionManager.getSessionMap();\n+            sessionMap.forEach((k, v) -> {\n+                GlobalStatus status = v.getStatus();\n+                if (status == GlobalStatus.RollbackRetrying || status == GlobalStatus.Rollbacking\n+                    || status == GlobalStatus.TimeoutRollbacking || status == GlobalStatus.TimeoutRollbackRetrying) {\n+                    retryRollbackingMap.computeIfAbsent(v.getXid(), session -> {\n+                        v.addSessionLifecycleListener(SessionHolder.getRetryRollbackingSessionManager());\n+                        return v;\n+                    });\n+                }\n+            });\n+        }\n+        super.onLeaderStart(term);\n+    }\n+\n+    @Override\n+    public void onLeaderStop(final Status status) {\n+        this.leaderTerm.set(-1);\n+        super.onLeaderStop(status);\n+    }\n+\n+    private void onExecuteRaft(RaftSessionSyncMsg msg) throws TransactionException {\n+        RaftSessionSyncMsg.MsgType msgType = msg.getMsgType();\n+        SessionManager sessionManager = null;\n+        String sessionName = msg.getSessionName();\n+        Boolean rootManager = false;\n+        if (Objects.equals(sessionName, ROOT_SESSION_MANAGER_NAME)) {\n+            sessionManager = SessionHolder.getRootSessionManager();\n+            rootManager = true;\n+        } else if (Objects.equals(sessionName, ASYNC_COMMITTING_SESSION_MANAGER_NAME)) {\n+            sessionManager = SessionHolder.getAsyncCommittingSessionManager();\n+        } else if (Objects.equals(sessionName, RETRY_COMMITTING_SESSION_MANAGER_NAME)) {\n+            sessionManager = SessionHolder.getRetryCommittingSessionManager();\n+        } else if (Objects.equals(sessionName, RETRY_ROLLBACKING_SESSION_MANAGER_NAME)) {\n+            sessionManager = SessionHolder.getRetryRollbackingSessionManager();\n+        }\n+        RaftSessionManager raftSessionManager = sessionManager != null ? (RaftSessionManager)sessionManager : null;\n+        LOG.info(\"state machine synchronization,task:{},sessionManager:{}\", msgType,\n+            sessionName != null ? sessionName : ROOT_SESSION_MANAGER_NAME);\n+        if (ADD_GLOBAL_SESSION.equals(msgType)) {\n+            GlobalSession globalSession;\n+            if (!rootManager) {\n+                globalSession =\n+                    SessionHolder.getRootSessionManager().findGlobalSession(msg.getGlobalSession().getXid());\n+            } else {\n+                globalSession = SessionConverter.convertGlobalSession(msg.getGlobalSession());\n+            }\n+            raftSessionManager.getFileSessionManager().addGlobalSession(globalSession);\n+        } else if (ACQUIRE_LOCK.equals(msgType)) {\n+            GlobalSession globalSession =\n+                SessionHolder.getRootSessionManager().findGlobalSession(msg.getBranchSession().getXid());\n+            BranchSession branchSession = globalSession.getBranch(msg.getBranchSession().getBranchId());\n+            boolean include = false;\n+            if (branchSession != null) {\n+                include = true;\n+                branchSession.setLockKey(msg.getBranchSession().getLockKey());\n+            } else {\n+                branchSession = SessionConverter.convertBranchSession(msg.getBranchSession());\n+            }\n+            Boolean owner = raftLockManager.acquireLock(branchSession);\n+            if (owner && !include) {\n+                globalSession.add(branchSession);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55ae70276b7236a52d00129d3e1707dff5445a0e"}, "originalPosition": 285}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTgxMzI5Nw==", "bodyText": "\u4e3b\u8282\u70b9\u7406\u8bba\u4e0a\u5148\u56e0\u4e3a\u72b6\u6001\u673a\u8ddf\u4e3b\u8282\u70b9\u6267\u884c\u7ebf\u7a0b\u4e0d\u662f\u540c\u4e00\u4e2a\uff0c\u4f46\u662f\u591a\u4e2a\u8282\u70b9\u6570\u636e\u662f\u4e00\u81f4\u7684\u72b6\u6001\u673a\u662f\u4e32\u884c\u7684\uff0c\u8981\u62a5\u9519\u5c31\u662f\u4e00\u8d77\u62a5\u9519\u3002", "url": "https://github.com/seata/seata/pull/3086#discussion_r539813297", "createdAt": "2020-12-10T03:16:07Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/raft/RaftStateMachine.java", "diffHunk": "@@ -0,0 +1,348 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.raft;\n+\n+import java.io.File;\n+import java.nio.ByteBuffer;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import com.alipay.remoting.serialization.SerializerManager;\n+import com.alipay.sofa.jraft.Closure;\n+import com.alipay.sofa.jraft.Iterator;\n+import com.alipay.sofa.jraft.Status;\n+import com.alipay.sofa.jraft.error.RaftError;\n+import com.alipay.sofa.jraft.storage.snapshot.SnapshotReader;\n+import com.alipay.sofa.jraft.storage.snapshot.SnapshotWriter;\n+import com.alipay.sofa.jraft.util.Utils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.exception.TransactionException;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.raft.AbstractRaftStateMachine;\n+import io.seata.core.raft.RaftServerFactory;\n+import io.seata.core.rpc.processor.server.ServerOnRequestProcessor;\n+import io.seata.core.store.StoreMode;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionHelper;\n+import io.seata.server.session.SessionHolder;\n+import io.seata.server.session.SessionManager;\n+import io.seata.server.storage.SessionConverter;\n+import io.seata.server.storage.file.lock.FileLocker;\n+import io.seata.server.storage.raft.RaftSessionSyncMsg;\n+import io.seata.server.storage.raft.lock.RaftLockManager;\n+import io.seata.server.storage.raft.session.RaftSessionManager;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+import static com.alipay.remoting.serialization.SerializerManager.Hessian2;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.ACQUIRE_LOCK;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.ADD_BRANCH_SESSION;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.ADD_GLOBAL_SESSION;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.RELEASE_GLOBAL_SESSION_LOCK;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.REMOVE_BRANCH_SESSION;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.REMOVE_GLOBAL_SESSION;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.UPDATE_BRANCH_SESSION_STATUS;\n+import static io.seata.core.raft.msg.RaftSyncMsg.MsgType.UPDATE_GLOBAL_SESSION_STATUS;\n+import static io.seata.server.session.SessionHolder.ASYNC_COMMITTING_SESSION_MANAGER_NAME;\n+import static io.seata.server.session.SessionHolder.RETRY_COMMITTING_SESSION_MANAGER_NAME;\n+import static io.seata.server.session.SessionHolder.RETRY_ROLLBACKING_SESSION_MANAGER_NAME;\n+import static io.seata.server.session.SessionHolder.ROOT_SESSION_MANAGER_NAME;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RaftStateMachine extends AbstractRaftStateMachine {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(RaftStateMachine.class);\n+\n+    /**\n+     * Leader term\n+     */\n+    private final AtomicLong leaderTerm = new AtomicLong(-1);\n+    /**\n+     * counter value\n+     */\n+\n+    public boolean isLeader() {\n+        return this.leaderTerm.get() > 0;\n+    }\n+\n+    RaftLockManager raftLockManager;\n+\n+    @Override\n+    public void setOnRequestProcessor(ServerOnRequestProcessor onRequestProcessor) {\n+        this.onRequestProcessor = onRequestProcessor;\n+        raftLockManager = new RaftLockManager();\n+    }\n+\n+    String mode;\n+\n+    public RaftStateMachine() {\n+        mode = ConfigurationFactory.getInstance().getConfig(ConfigurationKeys.STORE_MODE);\n+    }\n+\n+    @Override\n+    public void onApply(Iterator iterator) {\n+        while (iterator.hasNext()) {\n+            Closure processor = null;\n+            if (iterator.done() != null) {\n+                processor = iterator.done();\n+            } else {\n+                try {\n+                    ByteBuffer byteBuffer = iterator.getData();\n+                    if (byteBuffer != null) {\n+                        RaftSessionSyncMsg msg = SerializerManager.getSerializer(Hessian2)\n+                            .deserialize(iterator.getData().array(), RaftSessionSyncMsg.class.getName());\n+                        onExecuteRaft(msg);\n+                    }\n+                } catch (Exception e) {\n+                    LOG.error(\"Message synchronization failure\", e);\n+                }\n+            }\n+            if (processor != null) {\n+                processor.run(Status.OK());\n+            }\n+            iterator.next();\n+        }\n+    }\n+\n+\n+    @Override\n+    public void onSnapshotSave(final SnapshotWriter writer, final Closure done) {\n+        if (!StringUtils.equals(StoreMode.RAFT.getName(), mode)) {\n+            return;\n+        }\n+        Map<String, Object> maps = new HashMap<>();\n+        RaftSessionManager raftSessionManager = (RaftSessionManager)SessionHolder.getRootSessionManager();\n+        Map<String, GlobalSession> sessionMap = raftSessionManager.getSessionMap();\n+        Map<String, byte[]> sessionByteMap = new HashMap<>();\n+        sessionMap.forEach((k, v) -> sessionByteMap.put(v.getXid(), v.encode()));\n+        maps.put(ROOT_SESSION_MANAGER_NAME, sessionByteMap);\n+        ConcurrentMap<String/* resourceId */, ConcurrentMap<String/* tableName */,\n+            ConcurrentMap<Integer/* bucketId */, FileLocker.BucketLockMap>>>\n+            LOCK_MAP = FileLocker.LOCK_MAP;\n+        maps.put(\"LOCK_MAP\", LOCK_MAP);\n+        LOG.info(\"sessionmap size:{},lock map size:{}\",sessionMap.size(), LOCK_MAP.size());\n+        if (maps.isEmpty()) {\n+            return;\n+        }\n+        Utils.runInThread(() -> {\n+            final RaftSnapshotFile snapshot = new RaftSnapshotFile(writer.getPath() + File.separator + \"data\");\n+            if (snapshot.save(maps)) {\n+                if (writer.addFile(\"data\")) {\n+                    done.run(Status.OK());\n+                } else {\n+                    done.run(new Status(RaftError.EIO, \"Fail to add file to writer\"));\n+                }\n+            } else {\n+                done.run(new Status(RaftError.EIO, \"Fail to save counter snapshot %s\", snapshot.getPath()));\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public boolean onSnapshotLoad(final SnapshotReader reader) {\n+        if (!StringUtils.equals(StoreMode.RAFT.getName(), mode)) {\n+            return false;\n+        }\n+        if (isLeader()) {\n+            LOG.warn(\"Leader is not supposed to load snapshot\");\n+            return false;\n+        }\n+        if (reader.getFileMeta(\"data\") == null) {\n+            LOG.error(\"Fail to find data file in {}\", reader.getPath());\n+            return false;\n+        }\n+        final RaftSnapshotFile snapshot = new RaftSnapshotFile(reader.getPath() + File.separator + \"data\");\n+        try {\n+            Map<String, Object> maps = snapshot.load();\n+            RaftSessionManager raftSessionManager = (RaftSessionManager)SessionHolder.getRootSessionManager();\n+            FileLocker.LOCK_MAP.putAll((Map<? extends String,\n+                ? extends ConcurrentMap<String, ConcurrentMap<Integer, FileLocker.BucketLockMap>>>)maps\n+                    .get(\"LOCK_MAP\"));\n+            Map<String, byte[]> sessionByteMap = (Map<String, byte[]>)maps.get(ROOT_SESSION_MANAGER_NAME);\n+            Map<String, GlobalSession> rootSessionMap = raftSessionManager.getSessionMap();\n+            if (!sessionByteMap.isEmpty()) {\n+                Map<String, GlobalSession> sessionMap = new HashMap<>();\n+                sessionByteMap.forEach((k, v) -> {\n+                    GlobalSession session = new GlobalSession();\n+                    session.decode(v);\n+                    sessionMap.put(k, session);\n+                });\n+                rootSessionMap.putAll(sessionMap);\n+                sessionMap.forEach((k, v) -> {\n+                    GlobalStatus status = v.getStatus();\n+                    try {\n+                        if (status == GlobalStatus.AsyncCommitting) {\n+                            SessionHolder.getAsyncCommittingSessionManager().addGlobalSession(v);\n+                        } else if (status == GlobalStatus.CommitRetrying) {\n+                            SessionHolder.getRetryCommittingSessionManager().addGlobalSession(v);\n+                        } else if (status == GlobalStatus.RollbackRetrying) {\n+                            SessionHolder.getRetryRollbackingSessionManager().addGlobalSession(v);\n+                        }\n+                    } catch (TransactionException e) {\n+                        e.printStackTrace();\n+                    }\n+                });\n+            }\n+            return true;\n+        } catch (final Exception e) {\n+            LOG.error(\"Fail to load snapshot from {}\", snapshot.getPath());\n+            return false;\n+        }\n+\n+    }\n+\n+\n+    @Override\n+    public void onLeaderStart(final long term) {\n+        this.leaderTerm.set(term);\n+        if (RaftServerFactory.getInstance().isRaftMode()) {\n+            RaftSessionManager raftSessionManager = (RaftSessionManager)SessionHolder.getRootSessionManager();\n+            Map<String, GlobalSession> retryRollbackingMap =\n+                ((RaftSessionManager)SessionHolder.getRetryRollbackingSessionManager()).getSessionMap();\n+            Map<String, GlobalSession> sessionMap = raftSessionManager.getSessionMap();\n+            sessionMap.forEach((k, v) -> {\n+                GlobalStatus status = v.getStatus();\n+                if (status == GlobalStatus.RollbackRetrying || status == GlobalStatus.Rollbacking\n+                    || status == GlobalStatus.TimeoutRollbacking || status == GlobalStatus.TimeoutRollbackRetrying) {\n+                    retryRollbackingMap.computeIfAbsent(v.getXid(), session -> {\n+                        v.addSessionLifecycleListener(SessionHolder.getRetryRollbackingSessionManager());\n+                        return v;\n+                    });\n+                }\n+            });\n+        }\n+        super.onLeaderStart(term);\n+    }\n+\n+    @Override\n+    public void onLeaderStop(final Status status) {\n+        this.leaderTerm.set(-1);\n+        super.onLeaderStop(status);\n+    }\n+\n+    private void onExecuteRaft(RaftSessionSyncMsg msg) throws TransactionException {\n+        RaftSessionSyncMsg.MsgType msgType = msg.getMsgType();\n+        SessionManager sessionManager = null;\n+        String sessionName = msg.getSessionName();\n+        Boolean rootManager = false;\n+        if (Objects.equals(sessionName, ROOT_SESSION_MANAGER_NAME)) {\n+            sessionManager = SessionHolder.getRootSessionManager();\n+            rootManager = true;\n+        } else if (Objects.equals(sessionName, ASYNC_COMMITTING_SESSION_MANAGER_NAME)) {\n+            sessionManager = SessionHolder.getAsyncCommittingSessionManager();\n+        } else if (Objects.equals(sessionName, RETRY_COMMITTING_SESSION_MANAGER_NAME)) {\n+            sessionManager = SessionHolder.getRetryCommittingSessionManager();\n+        } else if (Objects.equals(sessionName, RETRY_ROLLBACKING_SESSION_MANAGER_NAME)) {\n+            sessionManager = SessionHolder.getRetryRollbackingSessionManager();\n+        }\n+        RaftSessionManager raftSessionManager = sessionManager != null ? (RaftSessionManager)sessionManager : null;\n+        LOG.info(\"state machine synchronization,task:{},sessionManager:{}\", msgType,\n+            sessionName != null ? sessionName : ROOT_SESSION_MANAGER_NAME);\n+        if (ADD_GLOBAL_SESSION.equals(msgType)) {\n+            GlobalSession globalSession;\n+            if (!rootManager) {\n+                globalSession =\n+                    SessionHolder.getRootSessionManager().findGlobalSession(msg.getGlobalSession().getXid());\n+            } else {\n+                globalSession = SessionConverter.convertGlobalSession(msg.getGlobalSession());\n+            }\n+            raftSessionManager.getFileSessionManager().addGlobalSession(globalSession);\n+        } else if (ACQUIRE_LOCK.equals(msgType)) {\n+            GlobalSession globalSession =\n+                SessionHolder.getRootSessionManager().findGlobalSession(msg.getBranchSession().getXid());\n+            BranchSession branchSession = globalSession.getBranch(msg.getBranchSession().getBranchId());\n+            boolean include = false;\n+            if (branchSession != null) {\n+                include = true;\n+                branchSession.setLockKey(msg.getBranchSession().getLockKey());\n+            } else {\n+                branchSession = SessionConverter.convertBranchSession(msg.getBranchSession());\n+            }\n+            Boolean owner = raftLockManager.acquireLock(branchSession);\n+            if (owner && !include) {\n+                globalSession.add(branchSession);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM5NjEyMQ=="}, "originalCommit": {"oid": "55ae70276b7236a52d00129d3e1707dff5445a0e"}, "originalPosition": 285}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1419, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}