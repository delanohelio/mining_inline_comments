{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE1NzcxMTEz", "number": 3258, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwMzo1Njo1M1rOE3i0Cw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxMDowMjo0NVrOFFgHYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2Njc3NTE1OnYy", "diffSide": "RIGHT", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwMzo1Njo1M1rOHw9Peg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwNDo0NjoxN1rOHw-FQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTA5NzA4Mg==", "bodyText": "error", "url": "https://github.com/seata/seata/pull/3258#discussion_r521097082", "createdAt": "2020-11-11T03:56:53Z", "author": {"login": "xingfudeshi"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java", "diffHunk": "@@ -59,8 +58,121 @@\n \n     private static final int UNDOLOG_DELETE_LIMIT_SIZE = 1000;\n \n+    private static final int ASYNC_COMMIT_BUFFER_LIMIT = ConfigurationFactory.getInstance().getInt(\n+        CLIENT_ASYNC_COMMIT_BUFFER_LIMIT, DEFAULT_CLIENT_ASYNC_COMMIT_BUFFER_LIMIT);\n+\n+    private final BlockingQueue<Phase2Context> commitQueue = new LinkedBlockingQueue<>(ASYNC_COMMIT_BUFFER_LIMIT);\n+\n+    @Override\n+    public BranchStatus branchCommit(BranchType branchType, String xid, long branchId, String resourceId,\n+                                     String applicationData) {\n+        if (!commitQueue.offer(new Phase2Context(branchType, xid, branchId, resourceId, applicationData))) {\n+            LOGGER.warn(\"Async commit buffer is FULL. Rejected branch [{}/{}] will be handled by housekeeping later.\", branchId, xid);\n+        }\n+        return BranchStatus.PhaseTwo_Committed;\n+    }\n+\n+    /**\n+     * Init worker thread to do branch commit\n+     */\n+    public void init() {\n+        LOGGER.info(\"Async Commit Buffer Limit: {}\", ASYNC_COMMIT_BUFFER_LIMIT);\n+        ScheduledExecutorService timerExecutor = new ScheduledThreadPoolExecutor(1, new NamedThreadFactory(\"AsyncWorker\", 1, true));\n+        timerExecutor.scheduleAtFixedRate(() -> {\n+            try {\n+\n+                doBranchCommits();\n+\n+            } catch (Throwable e) {\n+                LOGGER.info(\"Failed at async committing ... {}\", e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab9382750e63068b69958dec5f733c97047151a8"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTExMDg1MQ==", "bodyText": "updated.", "url": "https://github.com/seata/seata/pull/3258#discussion_r521110851", "createdAt": "2020-11-11T04:46:17Z", "author": {"login": "selfishlover"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java", "diffHunk": "@@ -59,8 +58,121 @@\n \n     private static final int UNDOLOG_DELETE_LIMIT_SIZE = 1000;\n \n+    private static final int ASYNC_COMMIT_BUFFER_LIMIT = ConfigurationFactory.getInstance().getInt(\n+        CLIENT_ASYNC_COMMIT_BUFFER_LIMIT, DEFAULT_CLIENT_ASYNC_COMMIT_BUFFER_LIMIT);\n+\n+    private final BlockingQueue<Phase2Context> commitQueue = new LinkedBlockingQueue<>(ASYNC_COMMIT_BUFFER_LIMIT);\n+\n+    @Override\n+    public BranchStatus branchCommit(BranchType branchType, String xid, long branchId, String resourceId,\n+                                     String applicationData) {\n+        if (!commitQueue.offer(new Phase2Context(branchType, xid, branchId, resourceId, applicationData))) {\n+            LOGGER.warn(\"Async commit buffer is FULL. Rejected branch [{}/{}] will be handled by housekeeping later.\", branchId, xid);\n+        }\n+        return BranchStatus.PhaseTwo_Committed;\n+    }\n+\n+    /**\n+     * Init worker thread to do branch commit\n+     */\n+    public void init() {\n+        LOGGER.info(\"Async Commit Buffer Limit: {}\", ASYNC_COMMIT_BUFFER_LIMIT);\n+        ScheduledExecutorService timerExecutor = new ScheduledThreadPoolExecutor(1, new NamedThreadFactory(\"AsyncWorker\", 1, true));\n+        timerExecutor.scheduleAtFixedRate(() -> {\n+            try {\n+\n+                doBranchCommits();\n+\n+            } catch (Throwable e) {\n+                LOGGER.info(\"Failed at async committing ... {}\", e.getMessage());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTA5NzA4Mg=="}, "originalCommit": {"oid": "ab9382750e63068b69958dec5f733c97047151a8"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2Njc3NTg4OnYy", "diffSide": "RIGHT", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwMzo1NzoyMlrOHw9P5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwNDo0NjozMVrOHw-Feg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTA5NzE5MQ==", "bodyText": "LOGGER.warn(\"Failed to get connection for async committing on:{} \"  resourceId, sqle);", "url": "https://github.com/seata/seata/pull/3258#discussion_r521097191", "createdAt": "2020-11-11T03:57:22Z", "author": {"login": "xingfudeshi"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java", "diffHunk": "@@ -59,8 +58,121 @@\n \n     private static final int UNDOLOG_DELETE_LIMIT_SIZE = 1000;\n \n+    private static final int ASYNC_COMMIT_BUFFER_LIMIT = ConfigurationFactory.getInstance().getInt(\n+        CLIENT_ASYNC_COMMIT_BUFFER_LIMIT, DEFAULT_CLIENT_ASYNC_COMMIT_BUFFER_LIMIT);\n+\n+    private final BlockingQueue<Phase2Context> commitQueue = new LinkedBlockingQueue<>(ASYNC_COMMIT_BUFFER_LIMIT);\n+\n+    @Override\n+    public BranchStatus branchCommit(BranchType branchType, String xid, long branchId, String resourceId,\n+                                     String applicationData) {\n+        if (!commitQueue.offer(new Phase2Context(branchType, xid, branchId, resourceId, applicationData))) {\n+            LOGGER.warn(\"Async commit buffer is FULL. Rejected branch [{}/{}] will be handled by housekeeping later.\", branchId, xid);\n+        }\n+        return BranchStatus.PhaseTwo_Committed;\n+    }\n+\n+    /**\n+     * Init worker thread to do branch commit\n+     */\n+    public void init() {\n+        LOGGER.info(\"Async Commit Buffer Limit: {}\", ASYNC_COMMIT_BUFFER_LIMIT);\n+        ScheduledExecutorService timerExecutor = new ScheduledThreadPoolExecutor(1, new NamedThreadFactory(\"AsyncWorker\", 1, true));\n+        timerExecutor.scheduleAtFixedRate(() -> {\n+            try {\n+\n+                doBranchCommits();\n+\n+            } catch (Throwable e) {\n+                LOGGER.info(\"Failed at async committing ... {}\", e.getMessage());\n+\n+            }\n+        }, 10, 1000, TimeUnit.MILLISECONDS);\n+    }\n+\n+    private void doBranchCommits() {\n+        if (commitQueue.isEmpty()) {\n+            return;\n+        }\n+\n+        // transfer all context currently received to this list\n+        List<Phase2Context> allContexts = new LinkedList<>();\n+        commitQueue.drainTo(allContexts);\n+\n+        // group context by their resourceId\n+        Map<String, List<Phase2Context>> groupedContexts = groupedByResourceId(allContexts);\n+\n+        groupedContexts.forEach(this::dealWithGroupedContexts);\n+    }\n \n-    private static class Phase2Context {\n+    Map<String, List<Phase2Context>> groupedByResourceId(List<Phase2Context> contexts) {\n+        Map<String, List<Phase2Context>> groupedContexts = new HashMap<>(DEFAULT_RESOURCE_SIZE);\n+        contexts.forEach(context -> {\n+            List<Phase2Context> group = groupedContexts.computeIfAbsent(context.resourceId, key -> new LinkedList<>());\n+            group.add(context);\n+        });\n+        return groupedContexts;\n+    }\n+\n+    private void dealWithGroupedContexts(String resourceId, List<Phase2Context> contexts) {\n+        DataSourceManager resourceManager = (DataSourceManager) DefaultResourceManager.get().getResourceManager(BranchType.AT);\n+        DataSourceProxy dataSourceProxy = resourceManager.get(resourceId);\n+        if (dataSourceProxy == null) {\n+            LOGGER.warn(\"Failed to find resource for {}\" + resourceId);\n+            return;\n+        }\n+\n+        Connection conn;\n+        try {\n+            conn = dataSourceProxy.getPlainConnection();\n+        } catch (SQLException sqle) {\n+            LOGGER.warn(\"Failed to get connection for async committing on \" + resourceId, sqle);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab9382750e63068b69958dec5f733c97047151a8"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTExMDkwNg==", "bodyText": "updated.", "url": "https://github.com/seata/seata/pull/3258#discussion_r521110906", "createdAt": "2020-11-11T04:46:31Z", "author": {"login": "selfishlover"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java", "diffHunk": "@@ -59,8 +58,121 @@\n \n     private static final int UNDOLOG_DELETE_LIMIT_SIZE = 1000;\n \n+    private static final int ASYNC_COMMIT_BUFFER_LIMIT = ConfigurationFactory.getInstance().getInt(\n+        CLIENT_ASYNC_COMMIT_BUFFER_LIMIT, DEFAULT_CLIENT_ASYNC_COMMIT_BUFFER_LIMIT);\n+\n+    private final BlockingQueue<Phase2Context> commitQueue = new LinkedBlockingQueue<>(ASYNC_COMMIT_BUFFER_LIMIT);\n+\n+    @Override\n+    public BranchStatus branchCommit(BranchType branchType, String xid, long branchId, String resourceId,\n+                                     String applicationData) {\n+        if (!commitQueue.offer(new Phase2Context(branchType, xid, branchId, resourceId, applicationData))) {\n+            LOGGER.warn(\"Async commit buffer is FULL. Rejected branch [{}/{}] will be handled by housekeeping later.\", branchId, xid);\n+        }\n+        return BranchStatus.PhaseTwo_Committed;\n+    }\n+\n+    /**\n+     * Init worker thread to do branch commit\n+     */\n+    public void init() {\n+        LOGGER.info(\"Async Commit Buffer Limit: {}\", ASYNC_COMMIT_BUFFER_LIMIT);\n+        ScheduledExecutorService timerExecutor = new ScheduledThreadPoolExecutor(1, new NamedThreadFactory(\"AsyncWorker\", 1, true));\n+        timerExecutor.scheduleAtFixedRate(() -> {\n+            try {\n+\n+                doBranchCommits();\n+\n+            } catch (Throwable e) {\n+                LOGGER.info(\"Failed at async committing ... {}\", e.getMessage());\n+\n+            }\n+        }, 10, 1000, TimeUnit.MILLISECONDS);\n+    }\n+\n+    private void doBranchCommits() {\n+        if (commitQueue.isEmpty()) {\n+            return;\n+        }\n+\n+        // transfer all context currently received to this list\n+        List<Phase2Context> allContexts = new LinkedList<>();\n+        commitQueue.drainTo(allContexts);\n+\n+        // group context by their resourceId\n+        Map<String, List<Phase2Context>> groupedContexts = groupedByResourceId(allContexts);\n+\n+        groupedContexts.forEach(this::dealWithGroupedContexts);\n+    }\n \n-    private static class Phase2Context {\n+    Map<String, List<Phase2Context>> groupedByResourceId(List<Phase2Context> contexts) {\n+        Map<String, List<Phase2Context>> groupedContexts = new HashMap<>(DEFAULT_RESOURCE_SIZE);\n+        contexts.forEach(context -> {\n+            List<Phase2Context> group = groupedContexts.computeIfAbsent(context.resourceId, key -> new LinkedList<>());\n+            group.add(context);\n+        });\n+        return groupedContexts;\n+    }\n+\n+    private void dealWithGroupedContexts(String resourceId, List<Phase2Context> contexts) {\n+        DataSourceManager resourceManager = (DataSourceManager) DefaultResourceManager.get().getResourceManager(BranchType.AT);\n+        DataSourceProxy dataSourceProxy = resourceManager.get(resourceId);\n+        if (dataSourceProxy == null) {\n+            LOGGER.warn(\"Failed to find resource for {}\" + resourceId);\n+            return;\n+        }\n+\n+        Connection conn;\n+        try {\n+            conn = dataSourceProxy.getPlainConnection();\n+        } catch (SQLException sqle) {\n+            LOGGER.warn(\"Failed to get connection for async committing on \" + resourceId, sqle);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTA5NzE5MQ=="}, "originalCommit": {"oid": "ab9382750e63068b69958dec5f733c97047151a8"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2Njc3NjIzOnYy", "diffSide": "RIGHT", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwMzo1NzozOFrOHw9QGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwNDo0NjozOVrOHw-FpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTA5NzI0Mg==", "bodyText": "LOGGER.warn(\"Failed to find resource for {}\" , resourceId);", "url": "https://github.com/seata/seata/pull/3258#discussion_r521097242", "createdAt": "2020-11-11T03:57:38Z", "author": {"login": "xingfudeshi"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java", "diffHunk": "@@ -59,8 +58,121 @@\n \n     private static final int UNDOLOG_DELETE_LIMIT_SIZE = 1000;\n \n+    private static final int ASYNC_COMMIT_BUFFER_LIMIT = ConfigurationFactory.getInstance().getInt(\n+        CLIENT_ASYNC_COMMIT_BUFFER_LIMIT, DEFAULT_CLIENT_ASYNC_COMMIT_BUFFER_LIMIT);\n+\n+    private final BlockingQueue<Phase2Context> commitQueue = new LinkedBlockingQueue<>(ASYNC_COMMIT_BUFFER_LIMIT);\n+\n+    @Override\n+    public BranchStatus branchCommit(BranchType branchType, String xid, long branchId, String resourceId,\n+                                     String applicationData) {\n+        if (!commitQueue.offer(new Phase2Context(branchType, xid, branchId, resourceId, applicationData))) {\n+            LOGGER.warn(\"Async commit buffer is FULL. Rejected branch [{}/{}] will be handled by housekeeping later.\", branchId, xid);\n+        }\n+        return BranchStatus.PhaseTwo_Committed;\n+    }\n+\n+    /**\n+     * Init worker thread to do branch commit\n+     */\n+    public void init() {\n+        LOGGER.info(\"Async Commit Buffer Limit: {}\", ASYNC_COMMIT_BUFFER_LIMIT);\n+        ScheduledExecutorService timerExecutor = new ScheduledThreadPoolExecutor(1, new NamedThreadFactory(\"AsyncWorker\", 1, true));\n+        timerExecutor.scheduleAtFixedRate(() -> {\n+            try {\n+\n+                doBranchCommits();\n+\n+            } catch (Throwable e) {\n+                LOGGER.info(\"Failed at async committing ... {}\", e.getMessage());\n+\n+            }\n+        }, 10, 1000, TimeUnit.MILLISECONDS);\n+    }\n+\n+    private void doBranchCommits() {\n+        if (commitQueue.isEmpty()) {\n+            return;\n+        }\n+\n+        // transfer all context currently received to this list\n+        List<Phase2Context> allContexts = new LinkedList<>();\n+        commitQueue.drainTo(allContexts);\n+\n+        // group context by their resourceId\n+        Map<String, List<Phase2Context>> groupedContexts = groupedByResourceId(allContexts);\n+\n+        groupedContexts.forEach(this::dealWithGroupedContexts);\n+    }\n \n-    private static class Phase2Context {\n+    Map<String, List<Phase2Context>> groupedByResourceId(List<Phase2Context> contexts) {\n+        Map<String, List<Phase2Context>> groupedContexts = new HashMap<>(DEFAULT_RESOURCE_SIZE);\n+        contexts.forEach(context -> {\n+            List<Phase2Context> group = groupedContexts.computeIfAbsent(context.resourceId, key -> new LinkedList<>());\n+            group.add(context);\n+        });\n+        return groupedContexts;\n+    }\n+\n+    private void dealWithGroupedContexts(String resourceId, List<Phase2Context> contexts) {\n+        DataSourceManager resourceManager = (DataSourceManager) DefaultResourceManager.get().getResourceManager(BranchType.AT);\n+        DataSourceProxy dataSourceProxy = resourceManager.get(resourceId);\n+        if (dataSourceProxy == null) {\n+            LOGGER.warn(\"Failed to find resource for {}\" + resourceId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab9382750e63068b69958dec5f733c97047151a8"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTExMDk0OA==", "bodyText": "updated.", "url": "https://github.com/seata/seata/pull/3258#discussion_r521110948", "createdAt": "2020-11-11T04:46:39Z", "author": {"login": "selfishlover"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java", "diffHunk": "@@ -59,8 +58,121 @@\n \n     private static final int UNDOLOG_DELETE_LIMIT_SIZE = 1000;\n \n+    private static final int ASYNC_COMMIT_BUFFER_LIMIT = ConfigurationFactory.getInstance().getInt(\n+        CLIENT_ASYNC_COMMIT_BUFFER_LIMIT, DEFAULT_CLIENT_ASYNC_COMMIT_BUFFER_LIMIT);\n+\n+    private final BlockingQueue<Phase2Context> commitQueue = new LinkedBlockingQueue<>(ASYNC_COMMIT_BUFFER_LIMIT);\n+\n+    @Override\n+    public BranchStatus branchCommit(BranchType branchType, String xid, long branchId, String resourceId,\n+                                     String applicationData) {\n+        if (!commitQueue.offer(new Phase2Context(branchType, xid, branchId, resourceId, applicationData))) {\n+            LOGGER.warn(\"Async commit buffer is FULL. Rejected branch [{}/{}] will be handled by housekeeping later.\", branchId, xid);\n+        }\n+        return BranchStatus.PhaseTwo_Committed;\n+    }\n+\n+    /**\n+     * Init worker thread to do branch commit\n+     */\n+    public void init() {\n+        LOGGER.info(\"Async Commit Buffer Limit: {}\", ASYNC_COMMIT_BUFFER_LIMIT);\n+        ScheduledExecutorService timerExecutor = new ScheduledThreadPoolExecutor(1, new NamedThreadFactory(\"AsyncWorker\", 1, true));\n+        timerExecutor.scheduleAtFixedRate(() -> {\n+            try {\n+\n+                doBranchCommits();\n+\n+            } catch (Throwable e) {\n+                LOGGER.info(\"Failed at async committing ... {}\", e.getMessage());\n+\n+            }\n+        }, 10, 1000, TimeUnit.MILLISECONDS);\n+    }\n+\n+    private void doBranchCommits() {\n+        if (commitQueue.isEmpty()) {\n+            return;\n+        }\n+\n+        // transfer all context currently received to this list\n+        List<Phase2Context> allContexts = new LinkedList<>();\n+        commitQueue.drainTo(allContexts);\n+\n+        // group context by their resourceId\n+        Map<String, List<Phase2Context>> groupedContexts = groupedByResourceId(allContexts);\n+\n+        groupedContexts.forEach(this::dealWithGroupedContexts);\n+    }\n \n-    private static class Phase2Context {\n+    Map<String, List<Phase2Context>> groupedByResourceId(List<Phase2Context> contexts) {\n+        Map<String, List<Phase2Context>> groupedContexts = new HashMap<>(DEFAULT_RESOURCE_SIZE);\n+        contexts.forEach(context -> {\n+            List<Phase2Context> group = groupedContexts.computeIfAbsent(context.resourceId, key -> new LinkedList<>());\n+            group.add(context);\n+        });\n+        return groupedContexts;\n+    }\n+\n+    private void dealWithGroupedContexts(String resourceId, List<Phase2Context> contexts) {\n+        DataSourceManager resourceManager = (DataSourceManager) DefaultResourceManager.get().getResourceManager(BranchType.AT);\n+        DataSourceProxy dataSourceProxy = resourceManager.get(resourceId);\n+        if (dataSourceProxy == null) {\n+            LOGGER.warn(\"Failed to find resource for {}\" + resourceId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTA5NzI0Mg=="}, "originalCommit": {"oid": "ab9382750e63068b69958dec5f733c97047151a8"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4MzM2MDUyOnYy", "diffSide": "RIGHT", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNVQwNDoxNzoyNVrOHzcbIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMlQxMjo1NTozMFrOH320DA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzcwNTEyMA==", "bodyText": "\u8fd9\u91ccoffer\u8fd4\u56de\u4e86false\u4e4b\u540e\uff0c\u8fd9\u91cc\u6253\u4e86\u4e2awarn\u7684\u65e5\u5fd7\uff0c\u4f46\u662f\u8fd8\u662f\u8fd4\u56de\u4e86\u4e8c\u9636\u6bb5\u63d0\u4ea4\u6210\u529f\u3002\u4f1a\u4e0d\u4f1a\u5bfc\u81f4seata\u8ba4\u4e3a\u8fd9\u6761\u5206\u652f\u5df2\u7ecf\u63d0\u4ea4\u6210\u529f\u4e86\uff0c\u4f46\u662f\u4e8b\u5b9e\u4e0a\u6ca1\u6709\u63d0\u4ea4\uff1f", "url": "https://github.com/seata/seata/pull/3258#discussion_r523705120", "createdAt": "2020-11-15T04:17:25Z", "author": {"login": "caohdgege"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java", "diffHunk": "@@ -59,8 +59,113 @@\n \n     private static final int UNDOLOG_DELETE_LIMIT_SIZE = 1000;\n \n+    private static final int ASYNC_COMMIT_BUFFER_LIMIT = ConfigurationFactory.getInstance().getInt(\n+        CLIENT_ASYNC_COMMIT_BUFFER_LIMIT, DEFAULT_CLIENT_ASYNC_COMMIT_BUFFER_LIMIT);\n+\n+    private final BlockingQueue<Phase2Context> commitQueue = new LinkedBlockingQueue<>(ASYNC_COMMIT_BUFFER_LIMIT);\n+\n+    @Override\n+    public BranchStatus branchCommit(BranchType branchType, String xid, long branchId, String resourceId,\n+                                     String applicationData) {\n+        if (!commitQueue.offer(new Phase2Context(branchType, xid, branchId, resourceId, applicationData))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0c8bca9e7499dfb1f4f9e93f696c9fb5b8ac92e"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzcwNjk4Ng==", "bodyText": "\u8fd9\u91cc\u63d0\u4ea4\u7684\u5185\u5bb9\u5c31\u662f\u5220\u9664\u56de\u6eda\u65e5\u5fd7\uff0c  \u4f1a\u53d1\u751f\u4f60\u8bf4\u7684\u60c5\u51b5\n\u8fd9\u4e5f\u662fAT\u6a21\u5f0f\u72ec\u6709\u7684\u63d0\u4ea4\u65b9\u5f0f\uff0c \u56de\u6eda\u65e5\u5fd7\u53ef\u4ee5\u4e0d\u5220\u9664\uff0c \u7b49\u5f85\u4e03\u5929\u540e\u5220\u9664\u3002\n\u6240\u4ee5\u8fd9\u91cc\u53ef\u4ee5\u7528\u5f02\u6b65\u63d0\u4ea4\u6027\u80fd\u3002 \u5176\u4ed6\u6a21\u5f0f\u7684\u63d0\u4ea4\u56de\u6eda\uff0c\u4ee5\u53caAT\u6a21\u5f0f\u7684\u56de\u6eda\u90fd\u5fc5\u987b\u8981\u540c\u6b65\u64cd\u4f5c\u5b8c\u6210\u624d\u884c\u3002", "url": "https://github.com/seata/seata/pull/3258#discussion_r523706986", "createdAt": "2020-11-15T04:43:36Z", "author": {"login": "ls9527"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java", "diffHunk": "@@ -59,8 +59,113 @@\n \n     private static final int UNDOLOG_DELETE_LIMIT_SIZE = 1000;\n \n+    private static final int ASYNC_COMMIT_BUFFER_LIMIT = ConfigurationFactory.getInstance().getInt(\n+        CLIENT_ASYNC_COMMIT_BUFFER_LIMIT, DEFAULT_CLIENT_ASYNC_COMMIT_BUFFER_LIMIT);\n+\n+    private final BlockingQueue<Phase2Context> commitQueue = new LinkedBlockingQueue<>(ASYNC_COMMIT_BUFFER_LIMIT);\n+\n+    @Override\n+    public BranchStatus branchCommit(BranchType branchType, String xid, long branchId, String resourceId,\n+                                     String applicationData) {\n+        if (!commitQueue.offer(new Phase2Context(branchType, xid, branchId, resourceId, applicationData))) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzcwNTEyMA=="}, "originalCommit": {"oid": "b0c8bca9e7499dfb1f4f9e93f696c9fb5b8ac92e"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODMzMTc4OA==", "bodyText": "\u8fd9\u91cc\u793e\u533a\u4e4b\u524d\u6709\u8ba8\u8bba\u8fc7\uff0c\u540e\u9762\u9700\u8981\u6539\u6210\uff0cstatus=1\u7684undo_log\u53ef\u4ee5\u76f4\u63a5\u7b49\u5f85\u4e03\u5929\u540e\u5220\u9664\uff0cstatus=0\u7684undo_log\u9700\u8981\u786e\u4fddlock_table\u7684\u6570\u636e\u5df2\u7ecf\u5220\u9664\u4e86\u624d\u80fd\u5220\u9664\uff0c\u8fd9\u4e2a\u5ef6\u6977\u54e5\u4e4b\u540e\u4e5f\u5173\u6ce8\u4e00\u4e0b\u3002", "url": "https://github.com/seata/seata/pull/3258#discussion_r528331788", "createdAt": "2020-11-22T12:55:30Z", "author": {"login": "caohdgege"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java", "diffHunk": "@@ -59,8 +59,113 @@\n \n     private static final int UNDOLOG_DELETE_LIMIT_SIZE = 1000;\n \n+    private static final int ASYNC_COMMIT_BUFFER_LIMIT = ConfigurationFactory.getInstance().getInt(\n+        CLIENT_ASYNC_COMMIT_BUFFER_LIMIT, DEFAULT_CLIENT_ASYNC_COMMIT_BUFFER_LIMIT);\n+\n+    private final BlockingQueue<Phase2Context> commitQueue = new LinkedBlockingQueue<>(ASYNC_COMMIT_BUFFER_LIMIT);\n+\n+    @Override\n+    public BranchStatus branchCommit(BranchType branchType, String xid, long branchId, String resourceId,\n+                                     String applicationData) {\n+        if (!commitQueue.offer(new Phase2Context(branchType, xid, branchId, resourceId, applicationData))) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzcwNTEyMA=="}, "originalCommit": {"oid": "b0c8bca9e7499dfb1f4f9e93f696c9fb5b8ac92e"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4MzM2MjcwOnYy", "diffSide": "RIGHT", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNVQwNDoyMTowMVrOHzccEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQwOToxMzowNVrOH9RJmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzcwNTM2Mw==", "bodyText": "\u8fd9\u91cc\u662f\u4e0d\u662f\u5e94\u8be5\u76f4\u63a5\u629b\u51fa\u5f02\u5e38\uff1f\u800c\u4e0d\u662f\u6253\u4e86\u65e5\u5fd7\u4e4b\u540ereturn\uff1f", "url": "https://github.com/seata/seata/pull/3258#discussion_r523705363", "createdAt": "2020-11-15T04:21:01Z", "author": {"login": "caohdgege"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java", "diffHunk": "@@ -59,8 +59,113 @@\n \n     private static final int UNDOLOG_DELETE_LIMIT_SIZE = 1000;\n \n+    private static final int ASYNC_COMMIT_BUFFER_LIMIT = ConfigurationFactory.getInstance().getInt(\n+        CLIENT_ASYNC_COMMIT_BUFFER_LIMIT, DEFAULT_CLIENT_ASYNC_COMMIT_BUFFER_LIMIT);\n+\n+    private final BlockingQueue<Phase2Context> commitQueue = new LinkedBlockingQueue<>(ASYNC_COMMIT_BUFFER_LIMIT);\n+\n+    @Override\n+    public BranchStatus branchCommit(BranchType branchType, String xid, long branchId, String resourceId,\n+                                     String applicationData) {\n+        if (!commitQueue.offer(new Phase2Context(branchType, xid, branchId, resourceId, applicationData))) {\n+            LOGGER.warn(\"Async commit buffer is FULL. Rejected branch [{}/{}] will be handled by housekeeping later.\", branchId, xid);\n+        }\n+        return BranchStatus.PhaseTwo_Committed;\n+    }\n+\n+    /**\n+     * Init worker thread to do branch commit\n+     */\n+    public void init() {\n+        LOGGER.info(\"Async Commit Buffer Limit: {}\", ASYNC_COMMIT_BUFFER_LIMIT);\n+        ThreadFactory threadFactory = new NamedThreadFactory(\"AsyncWorker\", 1, true);\n+        ScheduledExecutorService timerExecutor = new ScheduledThreadPoolExecutor(1, threadFactory);\n+        timerExecutor.scheduleAtFixedRate(this::doBranchCommits, 10, 1000, TimeUnit.MILLISECONDS);\n+    }\n+\n+    private void doBranchCommits() {\n+        if (commitQueue.isEmpty()) {\n+            return;\n+        }\n+\n+        // transfer all context currently received to this list\n+        List<Phase2Context> allContexts = new LinkedList<>();\n+        commitQueue.drainTo(allContexts);\n+\n+        // group context by their resourceId\n+        Map<String, List<Phase2Context>> groupedContexts = groupedByResourceId(allContexts);\n+\n+        groupedContexts.forEach(this::dealWithGroupedContexts);\n+    }\n+\n+    Map<String, List<Phase2Context>> groupedByResourceId(List<Phase2Context> contexts) {\n+        Map<String, List<Phase2Context>> groupedContexts = new HashMap<>(DEFAULT_RESOURCE_SIZE);\n+        contexts.forEach(context -> {\n+            List<Phase2Context> group = groupedContexts.computeIfAbsent(context.resourceId, key -> new LinkedList<>());\n+            group.add(context);\n+        });\n+        return groupedContexts;\n+    }\n+\n+    private void dealWithGroupedContexts(String resourceId, List<Phase2Context> contexts) {\n+        DataSourceManager resourceManager = (DataSourceManager) DefaultResourceManager.get().getResourceManager(BranchType.AT);\n+        DataSourceProxy dataSourceProxy = resourceManager.get(resourceId);\n+        if (dataSourceProxy == null) {\n+            LOGGER.warn(\"Failed to find resource for {}\", resourceId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0c8bca9e7499dfb1f4f9e93f696c9fb5b8ac92e"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzcxMjA3Mw==", "bodyText": "\u8fd9\u91cc\u5e94\u8be5\u4e0d\u80fd\u629b\u51fa\u5f02\u5e38\uff0c \u629b\u51fa\u5f02\u5e38\u7684\u8bddfor\u5faa\u73af\u5904\u7406\u5c31\u4e2d\u65ad\u4e86\u3002\n\u5728\u591a\u6570\u636e\u6e90\u7684\u573a\u666f\u4e0b\uff0c\u7b2c\u4e00\u4e2a\u6570\u636e\u6e90\u627e\u4e0d\u5230\u5f71\u54cd\u7b2c\u4e8c\u4e2a\u6570\u636e\u6e90\u65e0\u6cd5\u63d0\u4ea4\u4e5f\u4e0d\u5408\u7406\u3002\n\u662f\u4e0d\u662f\u641e\u4e2a\u5927catch\uff0c\u8ba9\u8fd9\u4e2adealWithGroupedContexts\u4e0d\u629b\u51fa\u5f02\u5e38\u6bd4\u8f83\u597d\uff1f", "url": "https://github.com/seata/seata/pull/3258#discussion_r523712073", "createdAt": "2020-11-15T05:52:59Z", "author": {"login": "ls9527"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java", "diffHunk": "@@ -59,8 +59,113 @@\n \n     private static final int UNDOLOG_DELETE_LIMIT_SIZE = 1000;\n \n+    private static final int ASYNC_COMMIT_BUFFER_LIMIT = ConfigurationFactory.getInstance().getInt(\n+        CLIENT_ASYNC_COMMIT_BUFFER_LIMIT, DEFAULT_CLIENT_ASYNC_COMMIT_BUFFER_LIMIT);\n+\n+    private final BlockingQueue<Phase2Context> commitQueue = new LinkedBlockingQueue<>(ASYNC_COMMIT_BUFFER_LIMIT);\n+\n+    @Override\n+    public BranchStatus branchCommit(BranchType branchType, String xid, long branchId, String resourceId,\n+                                     String applicationData) {\n+        if (!commitQueue.offer(new Phase2Context(branchType, xid, branchId, resourceId, applicationData))) {\n+            LOGGER.warn(\"Async commit buffer is FULL. Rejected branch [{}/{}] will be handled by housekeeping later.\", branchId, xid);\n+        }\n+        return BranchStatus.PhaseTwo_Committed;\n+    }\n+\n+    /**\n+     * Init worker thread to do branch commit\n+     */\n+    public void init() {\n+        LOGGER.info(\"Async Commit Buffer Limit: {}\", ASYNC_COMMIT_BUFFER_LIMIT);\n+        ThreadFactory threadFactory = new NamedThreadFactory(\"AsyncWorker\", 1, true);\n+        ScheduledExecutorService timerExecutor = new ScheduledThreadPoolExecutor(1, threadFactory);\n+        timerExecutor.scheduleAtFixedRate(this::doBranchCommits, 10, 1000, TimeUnit.MILLISECONDS);\n+    }\n+\n+    private void doBranchCommits() {\n+        if (commitQueue.isEmpty()) {\n+            return;\n+        }\n+\n+        // transfer all context currently received to this list\n+        List<Phase2Context> allContexts = new LinkedList<>();\n+        commitQueue.drainTo(allContexts);\n+\n+        // group context by their resourceId\n+        Map<String, List<Phase2Context>> groupedContexts = groupedByResourceId(allContexts);\n+\n+        groupedContexts.forEach(this::dealWithGroupedContexts);\n+    }\n+\n+    Map<String, List<Phase2Context>> groupedByResourceId(List<Phase2Context> contexts) {\n+        Map<String, List<Phase2Context>> groupedContexts = new HashMap<>(DEFAULT_RESOURCE_SIZE);\n+        contexts.forEach(context -> {\n+            List<Phase2Context> group = groupedContexts.computeIfAbsent(context.resourceId, key -> new LinkedList<>());\n+            group.add(context);\n+        });\n+        return groupedContexts;\n+    }\n+\n+    private void dealWithGroupedContexts(String resourceId, List<Phase2Context> contexts) {\n+        DataSourceManager resourceManager = (DataSourceManager) DefaultResourceManager.get().getResourceManager(BranchType.AT);\n+        DataSourceProxy dataSourceProxy = resourceManager.get(resourceId);\n+        if (dataSourceProxy == null) {\n+            LOGGER.warn(\"Failed to find resource for {}\", resourceId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzcwNTM2Mw=="}, "originalCommit": {"oid": "b0c8bca9e7499dfb1f4f9e93f696c9fb5b8ac92e"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzg1OTMzMQ==", "bodyText": "\u5927\u800c\u5168\u5730catch\u7684\u8bdd\uff0c\u4e0d\u597d\u533a\u5206\u5f02\u5e38\u53d1\u751f\u7684\u5730\u65b9(\u4ee5\u4fbf\u9488\u5bf9\u6027\u5730\u8f93\u51fa\u65e5\u5fd7)", "url": "https://github.com/seata/seata/pull/3258#discussion_r523859331", "createdAt": "2020-11-16T02:07:56Z", "author": {"login": "selfishlover"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java", "diffHunk": "@@ -59,8 +59,113 @@\n \n     private static final int UNDOLOG_DELETE_LIMIT_SIZE = 1000;\n \n+    private static final int ASYNC_COMMIT_BUFFER_LIMIT = ConfigurationFactory.getInstance().getInt(\n+        CLIENT_ASYNC_COMMIT_BUFFER_LIMIT, DEFAULT_CLIENT_ASYNC_COMMIT_BUFFER_LIMIT);\n+\n+    private final BlockingQueue<Phase2Context> commitQueue = new LinkedBlockingQueue<>(ASYNC_COMMIT_BUFFER_LIMIT);\n+\n+    @Override\n+    public BranchStatus branchCommit(BranchType branchType, String xid, long branchId, String resourceId,\n+                                     String applicationData) {\n+        if (!commitQueue.offer(new Phase2Context(branchType, xid, branchId, resourceId, applicationData))) {\n+            LOGGER.warn(\"Async commit buffer is FULL. Rejected branch [{}/{}] will be handled by housekeeping later.\", branchId, xid);\n+        }\n+        return BranchStatus.PhaseTwo_Committed;\n+    }\n+\n+    /**\n+     * Init worker thread to do branch commit\n+     */\n+    public void init() {\n+        LOGGER.info(\"Async Commit Buffer Limit: {}\", ASYNC_COMMIT_BUFFER_LIMIT);\n+        ThreadFactory threadFactory = new NamedThreadFactory(\"AsyncWorker\", 1, true);\n+        ScheduledExecutorService timerExecutor = new ScheduledThreadPoolExecutor(1, threadFactory);\n+        timerExecutor.scheduleAtFixedRate(this::doBranchCommits, 10, 1000, TimeUnit.MILLISECONDS);\n+    }\n+\n+    private void doBranchCommits() {\n+        if (commitQueue.isEmpty()) {\n+            return;\n+        }\n+\n+        // transfer all context currently received to this list\n+        List<Phase2Context> allContexts = new LinkedList<>();\n+        commitQueue.drainTo(allContexts);\n+\n+        // group context by their resourceId\n+        Map<String, List<Phase2Context>> groupedContexts = groupedByResourceId(allContexts);\n+\n+        groupedContexts.forEach(this::dealWithGroupedContexts);\n+    }\n+\n+    Map<String, List<Phase2Context>> groupedByResourceId(List<Phase2Context> contexts) {\n+        Map<String, List<Phase2Context>> groupedContexts = new HashMap<>(DEFAULT_RESOURCE_SIZE);\n+        contexts.forEach(context -> {\n+            List<Phase2Context> group = groupedContexts.computeIfAbsent(context.resourceId, key -> new LinkedList<>());\n+            group.add(context);\n+        });\n+        return groupedContexts;\n+    }\n+\n+    private void dealWithGroupedContexts(String resourceId, List<Phase2Context> contexts) {\n+        DataSourceManager resourceManager = (DataSourceManager) DefaultResourceManager.get().getResourceManager(BranchType.AT);\n+        DataSourceProxy dataSourceProxy = resourceManager.get(resourceId);\n+        if (dataSourceProxy == null) {\n+            LOGGER.warn(\"Failed to find resource for {}\", resourceId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzcwNTM2Mw=="}, "originalCommit": {"oid": "b0c8bca9e7499dfb1f4f9e93f696c9fb5b8ac92e"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDAwNjE2OA==", "bodyText": "\u5206\u7ec4\u51fd\u6570\u6709\u70b9\u4e11", "url": "https://github.com/seata/seata/pull/3258#discussion_r534006168", "createdAt": "2020-12-02T09:13:05Z", "author": {"login": "LiujunjieALiling"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java", "diffHunk": "@@ -59,8 +59,113 @@\n \n     private static final int UNDOLOG_DELETE_LIMIT_SIZE = 1000;\n \n+    private static final int ASYNC_COMMIT_BUFFER_LIMIT = ConfigurationFactory.getInstance().getInt(\n+        CLIENT_ASYNC_COMMIT_BUFFER_LIMIT, DEFAULT_CLIENT_ASYNC_COMMIT_BUFFER_LIMIT);\n+\n+    private final BlockingQueue<Phase2Context> commitQueue = new LinkedBlockingQueue<>(ASYNC_COMMIT_BUFFER_LIMIT);\n+\n+    @Override\n+    public BranchStatus branchCommit(BranchType branchType, String xid, long branchId, String resourceId,\n+                                     String applicationData) {\n+        if (!commitQueue.offer(new Phase2Context(branchType, xid, branchId, resourceId, applicationData))) {\n+            LOGGER.warn(\"Async commit buffer is FULL. Rejected branch [{}/{}] will be handled by housekeeping later.\", branchId, xid);\n+        }\n+        return BranchStatus.PhaseTwo_Committed;\n+    }\n+\n+    /**\n+     * Init worker thread to do branch commit\n+     */\n+    public void init() {\n+        LOGGER.info(\"Async Commit Buffer Limit: {}\", ASYNC_COMMIT_BUFFER_LIMIT);\n+        ThreadFactory threadFactory = new NamedThreadFactory(\"AsyncWorker\", 1, true);\n+        ScheduledExecutorService timerExecutor = new ScheduledThreadPoolExecutor(1, threadFactory);\n+        timerExecutor.scheduleAtFixedRate(this::doBranchCommits, 10, 1000, TimeUnit.MILLISECONDS);\n+    }\n+\n+    private void doBranchCommits() {\n+        if (commitQueue.isEmpty()) {\n+            return;\n+        }\n+\n+        // transfer all context currently received to this list\n+        List<Phase2Context> allContexts = new LinkedList<>();\n+        commitQueue.drainTo(allContexts);\n+\n+        // group context by their resourceId\n+        Map<String, List<Phase2Context>> groupedContexts = groupedByResourceId(allContexts);\n+\n+        groupedContexts.forEach(this::dealWithGroupedContexts);\n+    }\n+\n+    Map<String, List<Phase2Context>> groupedByResourceId(List<Phase2Context> contexts) {\n+        Map<String, List<Phase2Context>> groupedContexts = new HashMap<>(DEFAULT_RESOURCE_SIZE);\n+        contexts.forEach(context -> {\n+            List<Phase2Context> group = groupedContexts.computeIfAbsent(context.resourceId, key -> new LinkedList<>());\n+            group.add(context);\n+        });\n+        return groupedContexts;\n+    }\n+\n+    private void dealWithGroupedContexts(String resourceId, List<Phase2Context> contexts) {\n+        DataSourceManager resourceManager = (DataSourceManager) DefaultResourceManager.get().getResourceManager(BranchType.AT);\n+        DataSourceProxy dataSourceProxy = resourceManager.get(resourceId);\n+        if (dataSourceProxy == null) {\n+            LOGGER.warn(\"Failed to find resource for {}\", resourceId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzcwNTM2Mw=="}, "originalCommit": {"oid": "b0c8bca9e7499dfb1f4f9e93f696c9fb5b8ac92e"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4MzM2MzA5OnYy", "diffSide": "RIGHT", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNVQwNDoyMTo0NFrOHzccQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwOToyNDoxN1rOIGA_eQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzcwNTQwOQ==", "bodyText": "\u4e3a\u4ec0\u4e48\u4e0d\u628a\u5f02\u5e38\u629b\u51fa\u53bb\uff1f", "url": "https://github.com/seata/seata/pull/3258#discussion_r523705409", "createdAt": "2020-11-15T04:21:44Z", "author": {"login": "caohdgege"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java", "diffHunk": "@@ -59,8 +59,113 @@\n \n     private static final int UNDOLOG_DELETE_LIMIT_SIZE = 1000;\n \n+    private static final int ASYNC_COMMIT_BUFFER_LIMIT = ConfigurationFactory.getInstance().getInt(\n+        CLIENT_ASYNC_COMMIT_BUFFER_LIMIT, DEFAULT_CLIENT_ASYNC_COMMIT_BUFFER_LIMIT);\n+\n+    private final BlockingQueue<Phase2Context> commitQueue = new LinkedBlockingQueue<>(ASYNC_COMMIT_BUFFER_LIMIT);\n+\n+    @Override\n+    public BranchStatus branchCommit(BranchType branchType, String xid, long branchId, String resourceId,\n+                                     String applicationData) {\n+        if (!commitQueue.offer(new Phase2Context(branchType, xid, branchId, resourceId, applicationData))) {\n+            LOGGER.warn(\"Async commit buffer is FULL. Rejected branch [{}/{}] will be handled by housekeeping later.\", branchId, xid);\n+        }\n+        return BranchStatus.PhaseTwo_Committed;\n+    }\n+\n+    /**\n+     * Init worker thread to do branch commit\n+     */\n+    public void init() {\n+        LOGGER.info(\"Async Commit Buffer Limit: {}\", ASYNC_COMMIT_BUFFER_LIMIT);\n+        ThreadFactory threadFactory = new NamedThreadFactory(\"AsyncWorker\", 1, true);\n+        ScheduledExecutorService timerExecutor = new ScheduledThreadPoolExecutor(1, threadFactory);\n+        timerExecutor.scheduleAtFixedRate(this::doBranchCommits, 10, 1000, TimeUnit.MILLISECONDS);\n+    }\n+\n+    private void doBranchCommits() {\n+        if (commitQueue.isEmpty()) {\n+            return;\n+        }\n+\n+        // transfer all context currently received to this list\n+        List<Phase2Context> allContexts = new LinkedList<>();\n+        commitQueue.drainTo(allContexts);\n+\n+        // group context by their resourceId\n+        Map<String, List<Phase2Context>> groupedContexts = groupedByResourceId(allContexts);\n+\n+        groupedContexts.forEach(this::dealWithGroupedContexts);\n+    }\n+\n+    Map<String, List<Phase2Context>> groupedByResourceId(List<Phase2Context> contexts) {\n+        Map<String, List<Phase2Context>> groupedContexts = new HashMap<>(DEFAULT_RESOURCE_SIZE);\n+        contexts.forEach(context -> {\n+            List<Phase2Context> group = groupedContexts.computeIfAbsent(context.resourceId, key -> new LinkedList<>());\n+            group.add(context);\n+        });\n+        return groupedContexts;\n+    }\n+\n+    private void dealWithGroupedContexts(String resourceId, List<Phase2Context> contexts) {\n+        DataSourceManager resourceManager = (DataSourceManager) DefaultResourceManager.get().getResourceManager(BranchType.AT);\n+        DataSourceProxy dataSourceProxy = resourceManager.get(resourceId);\n+        if (dataSourceProxy == null) {\n+            LOGGER.warn(\"Failed to find resource for {}\", resourceId);\n+            return;\n+        }\n \n-    private static class Phase2Context {\n+        Connection conn;\n+        try {\n+            conn = dataSourceProxy.getPlainConnection();\n+        } catch (SQLException sqle) {\n+            LOGGER.warn(\"Failed to get connection for async committing on {}\", resourceId, sqle);\n+            return;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0c8bca9e7499dfb1f4f9e93f696c9fb5b8ac92e"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzg1OTQ3NA==", "bodyText": "\u540c\u4e0a", "url": "https://github.com/seata/seata/pull/3258#discussion_r523859474", "createdAt": "2020-11-16T02:08:40Z", "author": {"login": "selfishlover"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java", "diffHunk": "@@ -59,8 +59,113 @@\n \n     private static final int UNDOLOG_DELETE_LIMIT_SIZE = 1000;\n \n+    private static final int ASYNC_COMMIT_BUFFER_LIMIT = ConfigurationFactory.getInstance().getInt(\n+        CLIENT_ASYNC_COMMIT_BUFFER_LIMIT, DEFAULT_CLIENT_ASYNC_COMMIT_BUFFER_LIMIT);\n+\n+    private final BlockingQueue<Phase2Context> commitQueue = new LinkedBlockingQueue<>(ASYNC_COMMIT_BUFFER_LIMIT);\n+\n+    @Override\n+    public BranchStatus branchCommit(BranchType branchType, String xid, long branchId, String resourceId,\n+                                     String applicationData) {\n+        if (!commitQueue.offer(new Phase2Context(branchType, xid, branchId, resourceId, applicationData))) {\n+            LOGGER.warn(\"Async commit buffer is FULL. Rejected branch [{}/{}] will be handled by housekeeping later.\", branchId, xid);\n+        }\n+        return BranchStatus.PhaseTwo_Committed;\n+    }\n+\n+    /**\n+     * Init worker thread to do branch commit\n+     */\n+    public void init() {\n+        LOGGER.info(\"Async Commit Buffer Limit: {}\", ASYNC_COMMIT_BUFFER_LIMIT);\n+        ThreadFactory threadFactory = new NamedThreadFactory(\"AsyncWorker\", 1, true);\n+        ScheduledExecutorService timerExecutor = new ScheduledThreadPoolExecutor(1, threadFactory);\n+        timerExecutor.scheduleAtFixedRate(this::doBranchCommits, 10, 1000, TimeUnit.MILLISECONDS);\n+    }\n+\n+    private void doBranchCommits() {\n+        if (commitQueue.isEmpty()) {\n+            return;\n+        }\n+\n+        // transfer all context currently received to this list\n+        List<Phase2Context> allContexts = new LinkedList<>();\n+        commitQueue.drainTo(allContexts);\n+\n+        // group context by their resourceId\n+        Map<String, List<Phase2Context>> groupedContexts = groupedByResourceId(allContexts);\n+\n+        groupedContexts.forEach(this::dealWithGroupedContexts);\n+    }\n+\n+    Map<String, List<Phase2Context>> groupedByResourceId(List<Phase2Context> contexts) {\n+        Map<String, List<Phase2Context>> groupedContexts = new HashMap<>(DEFAULT_RESOURCE_SIZE);\n+        contexts.forEach(context -> {\n+            List<Phase2Context> group = groupedContexts.computeIfAbsent(context.resourceId, key -> new LinkedList<>());\n+            group.add(context);\n+        });\n+        return groupedContexts;\n+    }\n+\n+    private void dealWithGroupedContexts(String resourceId, List<Phase2Context> contexts) {\n+        DataSourceManager resourceManager = (DataSourceManager) DefaultResourceManager.get().getResourceManager(BranchType.AT);\n+        DataSourceProxy dataSourceProxy = resourceManager.get(resourceId);\n+        if (dataSourceProxy == null) {\n+            LOGGER.warn(\"Failed to find resource for {}\", resourceId);\n+            return;\n+        }\n \n-    private static class Phase2Context {\n+        Connection conn;\n+        try {\n+            conn = dataSourceProxy.getPlainConnection();\n+        } catch (SQLException sqle) {\n+            LOGGER.warn(\"Failed to get connection for async committing on {}\", resourceId, sqle);\n+            return;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzcwNTQwOQ=="}, "originalCommit": {"oid": "b0c8bca9e7499dfb1f4f9e93f696c9fb5b8ac92e"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODMzMTQwNg==", "bodyText": "\u90a3\u8fd9\u91cc\u7684LOGGER\u7ea7\u522b\u6709\u6ca1\u6709\u5fc5\u8981\u8c03\u9ad8\u4e00\u70b9\u5462\uff1f\u4e00\u822c\u65e5\u5fd7\u4e2d\u5fc3\u4e5f\u53ea\u662f\u76d1\u63a7error\u7ea7\u522b\u7684\u65e5\u5fd7\u3002", "url": "https://github.com/seata/seata/pull/3258#discussion_r528331406", "createdAt": "2020-11-22T12:52:14Z", "author": {"login": "caohdgege"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java", "diffHunk": "@@ -59,8 +59,113 @@\n \n     private static final int UNDOLOG_DELETE_LIMIT_SIZE = 1000;\n \n+    private static final int ASYNC_COMMIT_BUFFER_LIMIT = ConfigurationFactory.getInstance().getInt(\n+        CLIENT_ASYNC_COMMIT_BUFFER_LIMIT, DEFAULT_CLIENT_ASYNC_COMMIT_BUFFER_LIMIT);\n+\n+    private final BlockingQueue<Phase2Context> commitQueue = new LinkedBlockingQueue<>(ASYNC_COMMIT_BUFFER_LIMIT);\n+\n+    @Override\n+    public BranchStatus branchCommit(BranchType branchType, String xid, long branchId, String resourceId,\n+                                     String applicationData) {\n+        if (!commitQueue.offer(new Phase2Context(branchType, xid, branchId, resourceId, applicationData))) {\n+            LOGGER.warn(\"Async commit buffer is FULL. Rejected branch [{}/{}] will be handled by housekeeping later.\", branchId, xid);\n+        }\n+        return BranchStatus.PhaseTwo_Committed;\n+    }\n+\n+    /**\n+     * Init worker thread to do branch commit\n+     */\n+    public void init() {\n+        LOGGER.info(\"Async Commit Buffer Limit: {}\", ASYNC_COMMIT_BUFFER_LIMIT);\n+        ThreadFactory threadFactory = new NamedThreadFactory(\"AsyncWorker\", 1, true);\n+        ScheduledExecutorService timerExecutor = new ScheduledThreadPoolExecutor(1, threadFactory);\n+        timerExecutor.scheduleAtFixedRate(this::doBranchCommits, 10, 1000, TimeUnit.MILLISECONDS);\n+    }\n+\n+    private void doBranchCommits() {\n+        if (commitQueue.isEmpty()) {\n+            return;\n+        }\n+\n+        // transfer all context currently received to this list\n+        List<Phase2Context> allContexts = new LinkedList<>();\n+        commitQueue.drainTo(allContexts);\n+\n+        // group context by their resourceId\n+        Map<String, List<Phase2Context>> groupedContexts = groupedByResourceId(allContexts);\n+\n+        groupedContexts.forEach(this::dealWithGroupedContexts);\n+    }\n+\n+    Map<String, List<Phase2Context>> groupedByResourceId(List<Phase2Context> contexts) {\n+        Map<String, List<Phase2Context>> groupedContexts = new HashMap<>(DEFAULT_RESOURCE_SIZE);\n+        contexts.forEach(context -> {\n+            List<Phase2Context> group = groupedContexts.computeIfAbsent(context.resourceId, key -> new LinkedList<>());\n+            group.add(context);\n+        });\n+        return groupedContexts;\n+    }\n+\n+    private void dealWithGroupedContexts(String resourceId, List<Phase2Context> contexts) {\n+        DataSourceManager resourceManager = (DataSourceManager) DefaultResourceManager.get().getResourceManager(BranchType.AT);\n+        DataSourceProxy dataSourceProxy = resourceManager.get(resourceId);\n+        if (dataSourceProxy == null) {\n+            LOGGER.warn(\"Failed to find resource for {}\", resourceId);\n+            return;\n+        }\n \n-    private static class Phase2Context {\n+        Connection conn;\n+        try {\n+            conn = dataSourceProxy.getPlainConnection();\n+        } catch (SQLException sqle) {\n+            LOGGER.warn(\"Failed to get connection for async committing on {}\", resourceId, sqle);\n+            return;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzcwNTQwOQ=="}, "originalCommit": {"oid": "b0c8bca9e7499dfb1f4f9e93f696c9fb5b8ac92e"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE3ODYxNw==", "bodyText": "ok\uff0c\u8c03\u5230error\u4e86", "url": "https://github.com/seata/seata/pull/3258#discussion_r543178617", "createdAt": "2020-12-15T09:24:17Z", "author": {"login": "selfishlover"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java", "diffHunk": "@@ -59,8 +59,113 @@\n \n     private static final int UNDOLOG_DELETE_LIMIT_SIZE = 1000;\n \n+    private static final int ASYNC_COMMIT_BUFFER_LIMIT = ConfigurationFactory.getInstance().getInt(\n+        CLIENT_ASYNC_COMMIT_BUFFER_LIMIT, DEFAULT_CLIENT_ASYNC_COMMIT_BUFFER_LIMIT);\n+\n+    private final BlockingQueue<Phase2Context> commitQueue = new LinkedBlockingQueue<>(ASYNC_COMMIT_BUFFER_LIMIT);\n+\n+    @Override\n+    public BranchStatus branchCommit(BranchType branchType, String xid, long branchId, String resourceId,\n+                                     String applicationData) {\n+        if (!commitQueue.offer(new Phase2Context(branchType, xid, branchId, resourceId, applicationData))) {\n+            LOGGER.warn(\"Async commit buffer is FULL. Rejected branch [{}/{}] will be handled by housekeeping later.\", branchId, xid);\n+        }\n+        return BranchStatus.PhaseTwo_Committed;\n+    }\n+\n+    /**\n+     * Init worker thread to do branch commit\n+     */\n+    public void init() {\n+        LOGGER.info(\"Async Commit Buffer Limit: {}\", ASYNC_COMMIT_BUFFER_LIMIT);\n+        ThreadFactory threadFactory = new NamedThreadFactory(\"AsyncWorker\", 1, true);\n+        ScheduledExecutorService timerExecutor = new ScheduledThreadPoolExecutor(1, threadFactory);\n+        timerExecutor.scheduleAtFixedRate(this::doBranchCommits, 10, 1000, TimeUnit.MILLISECONDS);\n+    }\n+\n+    private void doBranchCommits() {\n+        if (commitQueue.isEmpty()) {\n+            return;\n+        }\n+\n+        // transfer all context currently received to this list\n+        List<Phase2Context> allContexts = new LinkedList<>();\n+        commitQueue.drainTo(allContexts);\n+\n+        // group context by their resourceId\n+        Map<String, List<Phase2Context>> groupedContexts = groupedByResourceId(allContexts);\n+\n+        groupedContexts.forEach(this::dealWithGroupedContexts);\n+    }\n+\n+    Map<String, List<Phase2Context>> groupedByResourceId(List<Phase2Context> contexts) {\n+        Map<String, List<Phase2Context>> groupedContexts = new HashMap<>(DEFAULT_RESOURCE_SIZE);\n+        contexts.forEach(context -> {\n+            List<Phase2Context> group = groupedContexts.computeIfAbsent(context.resourceId, key -> new LinkedList<>());\n+            group.add(context);\n+        });\n+        return groupedContexts;\n+    }\n+\n+    private void dealWithGroupedContexts(String resourceId, List<Phase2Context> contexts) {\n+        DataSourceManager resourceManager = (DataSourceManager) DefaultResourceManager.get().getResourceManager(BranchType.AT);\n+        DataSourceProxy dataSourceProxy = resourceManager.get(resourceId);\n+        if (dataSourceProxy == null) {\n+            LOGGER.warn(\"Failed to find resource for {}\", resourceId);\n+            return;\n+        }\n \n-    private static class Phase2Context {\n+        Connection conn;\n+        try {\n+            conn = dataSourceProxy.getPlainConnection();\n+        } catch (SQLException sqle) {\n+            LOGGER.warn(\"Failed to get connection for async committing on {}\", resourceId, sqle);\n+            return;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzcwNTQwOQ=="}, "originalCommit": {"oid": "b0c8bca9e7499dfb1f4f9e93f696c9fb5b8ac92e"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxMjYxNzE2OnYy", "diffSide": "RIGHT", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwODowOToxMlrOIF9-zQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwODowOToxMlrOIF9-zQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzEyOTI5Mw==", "bodyText": "why use LinkedList?", "url": "https://github.com/seata/seata/pull/3258#discussion_r543129293", "createdAt": "2020-12-15T08:09:12Z", "author": {"login": "jsbxyyx"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java", "diffHunk": "@@ -59,8 +59,113 @@\n \n     private static final int UNDOLOG_DELETE_LIMIT_SIZE = 1000;\n \n+    private static final int ASYNC_COMMIT_BUFFER_LIMIT = ConfigurationFactory.getInstance().getInt(\n+        CLIENT_ASYNC_COMMIT_BUFFER_LIMIT, DEFAULT_CLIENT_ASYNC_COMMIT_BUFFER_LIMIT);\n+\n+    private final BlockingQueue<Phase2Context> commitQueue = new LinkedBlockingQueue<>(ASYNC_COMMIT_BUFFER_LIMIT);\n+\n+    @Override\n+    public BranchStatus branchCommit(BranchType branchType, String xid, long branchId, String resourceId,\n+                                     String applicationData) {\n+        if (!commitQueue.offer(new Phase2Context(branchType, xid, branchId, resourceId, applicationData))) {\n+            LOGGER.warn(\"Async commit buffer is FULL. Rejected branch [{}/{}] will be handled by housekeeping later.\", branchId, xid);\n+        }\n+        return BranchStatus.PhaseTwo_Committed;\n+    }\n+\n+    /**\n+     * Init worker thread to do branch commit\n+     */\n+    public void init() {\n+        LOGGER.info(\"Async Commit Buffer Limit: {}\", ASYNC_COMMIT_BUFFER_LIMIT);\n+        ThreadFactory threadFactory = new NamedThreadFactory(\"AsyncWorker\", 1, true);\n+        ScheduledExecutorService timerExecutor = new ScheduledThreadPoolExecutor(1, threadFactory);\n+        timerExecutor.scheduleAtFixedRate(this::doBranchCommits, 10, 1000, TimeUnit.MILLISECONDS);\n+    }\n+\n+    private void doBranchCommits() {\n+        if (commitQueue.isEmpty()) {\n+            return;\n+        }\n+\n+        // transfer all context currently received to this list\n+        List<Phase2Context> allContexts = new LinkedList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "907a8aedad03e3d096ae54ab086611f535d026fc"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxMjY0MjQzOnYy", "diffSide": "RIGHT", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwODoxNTo0NFrOIF-NSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwODoxNTo0NFrOIF-NSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzEzMzAwMA==", "bodyText": "doBranchCommits must try catch.", "url": "https://github.com/seata/seata/pull/3258#discussion_r543133000", "createdAt": "2020-12-15T08:15:44Z", "author": {"login": "jsbxyyx"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java", "diffHunk": "@@ -59,8 +59,113 @@\n \n     private static final int UNDOLOG_DELETE_LIMIT_SIZE = 1000;\n \n+    private static final int ASYNC_COMMIT_BUFFER_LIMIT = ConfigurationFactory.getInstance().getInt(\n+        CLIENT_ASYNC_COMMIT_BUFFER_LIMIT, DEFAULT_CLIENT_ASYNC_COMMIT_BUFFER_LIMIT);\n+\n+    private final BlockingQueue<Phase2Context> commitQueue = new LinkedBlockingQueue<>(ASYNC_COMMIT_BUFFER_LIMIT);\n+\n+    @Override\n+    public BranchStatus branchCommit(BranchType branchType, String xid, long branchId, String resourceId,\n+                                     String applicationData) {\n+        if (!commitQueue.offer(new Phase2Context(branchType, xid, branchId, resourceId, applicationData))) {\n+            LOGGER.warn(\"Async commit buffer is FULL. Rejected branch [{}/{}] will be handled by housekeeping later.\", branchId, xid);\n+        }\n+        return BranchStatus.PhaseTwo_Committed;\n+    }\n+\n+    /**\n+     * Init worker thread to do branch commit\n+     */\n+    public void init() {\n+        LOGGER.info(\"Async Commit Buffer Limit: {}\", ASYNC_COMMIT_BUFFER_LIMIT);\n+        ThreadFactory threadFactory = new NamedThreadFactory(\"AsyncWorker\", 1, true);\n+        ScheduledExecutorService timerExecutor = new ScheduledThreadPoolExecutor(1, threadFactory);\n+        timerExecutor.scheduleAtFixedRate(this::doBranchCommits, 10, 1000, TimeUnit.MILLISECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "907a8aedad03e3d096ae54ab086611f535d026fc"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxMzEzMzc3OnYy", "diffSide": "RIGHT", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxMDowMjo0NVrOIGCtSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwMzoyMTo0NFrOIGr2Lw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzIwNjcyOA==", "bodyText": "may be throws thread interrupt exception or Error. suggest try catch Throwable.", "url": "https://github.com/seata/seata/pull/3258#discussion_r543206728", "createdAt": "2020-12-15T10:02:45Z", "author": {"login": "jsbxyyx"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java", "diffHunk": "@@ -59,8 +60,125 @@\n \n     private static final int UNDOLOG_DELETE_LIMIT_SIZE = 1000;\n \n+    private static final int ASYNC_COMMIT_BUFFER_LIMIT = ConfigurationFactory.getInstance().getInt(\n+        CLIENT_ASYNC_COMMIT_BUFFER_LIMIT, DEFAULT_CLIENT_ASYNC_COMMIT_BUFFER_LIMIT);\n+\n+    private final BlockingQueue<Phase2Context> commitQueue;\n+\n+    private final ScheduledExecutorService scheduledExecutor;\n+\n+    public AsyncWorker() {\n+        LOGGER.info(\"Async Commit Buffer Limit: {}\", ASYNC_COMMIT_BUFFER_LIMIT);\n+        commitQueue = new LinkedBlockingQueue<>(ASYNC_COMMIT_BUFFER_LIMIT);\n+\n+        ThreadFactory threadFactory = new NamedThreadFactory(\"AsyncWorker\", 2, true);\n+        scheduledExecutor = new ScheduledThreadPoolExecutor(2, threadFactory);\n+        scheduledExecutor.scheduleAtFixedRate(this::doBranchCommits, 10, 1000, TimeUnit.MILLISECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79d47739d5a5bd573a110c3f703303c1dad15229"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzg4MDc1MQ==", "bodyText": "fixed", "url": "https://github.com/seata/seata/pull/3258#discussion_r543880751", "createdAt": "2020-12-16T03:21:44Z", "author": {"login": "selfishlover"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java", "diffHunk": "@@ -59,8 +60,125 @@\n \n     private static final int UNDOLOG_DELETE_LIMIT_SIZE = 1000;\n \n+    private static final int ASYNC_COMMIT_BUFFER_LIMIT = ConfigurationFactory.getInstance().getInt(\n+        CLIENT_ASYNC_COMMIT_BUFFER_LIMIT, DEFAULT_CLIENT_ASYNC_COMMIT_BUFFER_LIMIT);\n+\n+    private final BlockingQueue<Phase2Context> commitQueue;\n+\n+    private final ScheduledExecutorService scheduledExecutor;\n+\n+    public AsyncWorker() {\n+        LOGGER.info(\"Async Commit Buffer Limit: {}\", ASYNC_COMMIT_BUFFER_LIMIT);\n+        commitQueue = new LinkedBlockingQueue<>(ASYNC_COMMIT_BUFFER_LIMIT);\n+\n+        ThreadFactory threadFactory = new NamedThreadFactory(\"AsyncWorker\", 2, true);\n+        scheduledExecutor = new ScheduledThreadPoolExecutor(2, threadFactory);\n+        scheduledExecutor.scheduleAtFixedRate(this::doBranchCommits, 10, 1000, TimeUnit.MILLISECONDS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzIwNjcyOA=="}, "originalCommit": {"oid": "79d47739d5a5bd573a110c3f703303c1dad15229"}, "originalPosition": 51}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1339, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}