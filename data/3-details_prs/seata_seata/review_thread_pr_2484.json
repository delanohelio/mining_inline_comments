{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk1NDMyODg4", "number": 2484, "reviewThreads": {"totalCount": 49, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQwOToyMTowM1rOD7KEAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMVQxMjozNzowN1rOEBLaiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzMzU3NDQxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQwOToyMTowM1rOGTT8vw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQwOTozMjoxOVrOGTUYEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjkwMjk3NQ==", "bodyText": "why 100?", "url": "https://github.com/seata/seata/pull/2484#discussion_r422902975", "createdAt": "2020-05-11T09:21:03Z", "author": {"login": "jsbxyyx"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.lock;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import com.alibaba.fastjson.JSON;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.core.lock.AbstractLocker;\n+import io.seata.core.lock.RowLock;\n+import io.seata.core.store.LockDO;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import redis.clients.jedis.Jedis;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisLocker extends AbstractLocker {\n+\n+    private static final Integer DEFAULT_SECONDS = 30;\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_PREFIX = \"SEATA_LOCK_\";\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX = \"SEATA_LOCK_XID_\";\n+\n+    /**\n+     * Instantiates a new Redis locker.\n+     *\n+     */\n+    public RedisLocker() {}\n+\n+    @Override\n+    public boolean acquireLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        List<String> successList = new ArrayList<>();\n+        long status = 0;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<LockDO> locks = convertToLockDO(rowLocks);\n+            for (LockDO lock : locks) {\n+                String key = DEFAULT_REDIS_SEATA_LOCK_PREFIX + lock.getRowKey();\n+                status = jedis.setnx(key, JSON.toJSONString(lock));\n+                if (status == 1) {\n+                    successList.add(key);\n+                    jedis.lpush(DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX + lock.getXid(), key);\n+                    jedis.expire(key, DEFAULT_SECONDS);\n+                } else {\n+                    break;\n+                }\n+            }\n+            if (status != 1) {\n+                String[] rms = successList.toArray(new String[successList.size()]);\n+                if (rms.length > 0) {\n+                    jedis.del(rms);\n+                }\n+                return false;\n+            } else {\n+                return true;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        String[] keys = new String[rowLocks.size()];\n+        List<LockDO> locks = convertToLockDO(rowLocks);\n+        for (int i = 0; i < locks.size(); i++) {\n+            String key = DEFAULT_REDIS_SEATA_LOCK_PREFIX + locks.get(i).getRowKey();\n+            keys[i] = key;\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            jedis.del(keys);\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(String xid, List<Long> branchIds) {\n+        if (CollectionUtils.isEmpty(branchIds)) {\n+            // no lock\n+            return true;\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String lockListKey = DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX + xid;\n+            List<String> keys = jedis.lrange(lockListKey, 0, 100);\n+            if (null != keys && keys.size() > 0) {\n+                Iterator<String> it = keys.iterator();\n+                while (it.hasNext()) {\n+                    String key = it.next();\n+                    LockDO lock = JSON.parseObject(jedis.get(key), LockDO.class);\n+                    for (int i = 0; i < branchIds.size(); i++) {\n+                        if (lock.getBranchId().equals(branchIds.get(i))) {\n+                            jedis.del(key);\n+                            jedis.lrem(lockListKey, 0, key);\n+                            it.remove();\n+                        }\n+                    }\n+                }\n+                if (keys.size() == 0) {\n+                    jedis.del(lockListKey);\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(String xid, Long branchId) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String lockListKey = DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX + xid;\n+            List<String> keys = jedis.lrange(lockListKey, 0, 100);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a0d1a49a78008deca406bfaa8f218950be3f0b5a"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjkwOTk2OA==", "bodyText": "why 100?\n\nok,i will optimize it", "url": "https://github.com/seata/seata/pull/2484#discussion_r422909968", "createdAt": "2020-05-11T09:32:19Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.lock;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import com.alibaba.fastjson.JSON;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.core.lock.AbstractLocker;\n+import io.seata.core.lock.RowLock;\n+import io.seata.core.store.LockDO;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import redis.clients.jedis.Jedis;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisLocker extends AbstractLocker {\n+\n+    private static final Integer DEFAULT_SECONDS = 30;\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_PREFIX = \"SEATA_LOCK_\";\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX = \"SEATA_LOCK_XID_\";\n+\n+    /**\n+     * Instantiates a new Redis locker.\n+     *\n+     */\n+    public RedisLocker() {}\n+\n+    @Override\n+    public boolean acquireLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        List<String> successList = new ArrayList<>();\n+        long status = 0;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<LockDO> locks = convertToLockDO(rowLocks);\n+            for (LockDO lock : locks) {\n+                String key = DEFAULT_REDIS_SEATA_LOCK_PREFIX + lock.getRowKey();\n+                status = jedis.setnx(key, JSON.toJSONString(lock));\n+                if (status == 1) {\n+                    successList.add(key);\n+                    jedis.lpush(DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX + lock.getXid(), key);\n+                    jedis.expire(key, DEFAULT_SECONDS);\n+                } else {\n+                    break;\n+                }\n+            }\n+            if (status != 1) {\n+                String[] rms = successList.toArray(new String[successList.size()]);\n+                if (rms.length > 0) {\n+                    jedis.del(rms);\n+                }\n+                return false;\n+            } else {\n+                return true;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        String[] keys = new String[rowLocks.size()];\n+        List<LockDO> locks = convertToLockDO(rowLocks);\n+        for (int i = 0; i < locks.size(); i++) {\n+            String key = DEFAULT_REDIS_SEATA_LOCK_PREFIX + locks.get(i).getRowKey();\n+            keys[i] = key;\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            jedis.del(keys);\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(String xid, List<Long> branchIds) {\n+        if (CollectionUtils.isEmpty(branchIds)) {\n+            // no lock\n+            return true;\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String lockListKey = DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX + xid;\n+            List<String> keys = jedis.lrange(lockListKey, 0, 100);\n+            if (null != keys && keys.size() > 0) {\n+                Iterator<String> it = keys.iterator();\n+                while (it.hasNext()) {\n+                    String key = it.next();\n+                    LockDO lock = JSON.parseObject(jedis.get(key), LockDO.class);\n+                    for (int i = 0; i < branchIds.size(); i++) {\n+                        if (lock.getBranchId().equals(branchIds.get(i))) {\n+                            jedis.del(key);\n+                            jedis.lrem(lockListKey, 0, key);\n+                            it.remove();\n+                        }\n+                    }\n+                }\n+                if (keys.size() == 0) {\n+                    jedis.del(lockListKey);\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(String xid, Long branchId) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String lockListKey = DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX + xid;\n+            List<String> keys = jedis.lrange(lockListKey, 0, 100);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjkwMjk3NQ=="}, "originalCommit": {"oid": "a0d1a49a78008deca406bfaa8f218950be3f0b5a"}, "originalPosition": 132}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzMzU3NTk4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQwOToyMToyNlrOGTT9qg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQwOTozMjoxNFrOGTUX3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjkwMzIxMA==", "bodyText": "why 100?", "url": "https://github.com/seata/seata/pull/2484#discussion_r422903210", "createdAt": "2020-05-11T09:21:26Z", "author": {"login": "jsbxyyx"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.lock;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import com.alibaba.fastjson.JSON;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.core.lock.AbstractLocker;\n+import io.seata.core.lock.RowLock;\n+import io.seata.core.store.LockDO;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import redis.clients.jedis.Jedis;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisLocker extends AbstractLocker {\n+\n+    private static final Integer DEFAULT_SECONDS = 30;\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_PREFIX = \"SEATA_LOCK_\";\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX = \"SEATA_LOCK_XID_\";\n+\n+    /**\n+     * Instantiates a new Redis locker.\n+     *\n+     */\n+    public RedisLocker() {}\n+\n+    @Override\n+    public boolean acquireLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        List<String> successList = new ArrayList<>();\n+        long status = 0;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<LockDO> locks = convertToLockDO(rowLocks);\n+            for (LockDO lock : locks) {\n+                String key = DEFAULT_REDIS_SEATA_LOCK_PREFIX + lock.getRowKey();\n+                status = jedis.setnx(key, JSON.toJSONString(lock));\n+                if (status == 1) {\n+                    successList.add(key);\n+                    jedis.lpush(DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX + lock.getXid(), key);\n+                    jedis.expire(key, DEFAULT_SECONDS);\n+                } else {\n+                    break;\n+                }\n+            }\n+            if (status != 1) {\n+                String[] rms = successList.toArray(new String[successList.size()]);\n+                if (rms.length > 0) {\n+                    jedis.del(rms);\n+                }\n+                return false;\n+            } else {\n+                return true;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        String[] keys = new String[rowLocks.size()];\n+        List<LockDO> locks = convertToLockDO(rowLocks);\n+        for (int i = 0; i < locks.size(); i++) {\n+            String key = DEFAULT_REDIS_SEATA_LOCK_PREFIX + locks.get(i).getRowKey();\n+            keys[i] = key;\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            jedis.del(keys);\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(String xid, List<Long> branchIds) {\n+        if (CollectionUtils.isEmpty(branchIds)) {\n+            // no lock\n+            return true;\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String lockListKey = DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX + xid;\n+            List<String> keys = jedis.lrange(lockListKey, 0, 100);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a0d1a49a78008deca406bfaa8f218950be3f0b5a"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjkwOTkxNw==", "bodyText": "ok,i will optimize it", "url": "https://github.com/seata/seata/pull/2484#discussion_r422909917", "createdAt": "2020-05-11T09:32:14Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.lock;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import com.alibaba.fastjson.JSON;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.core.lock.AbstractLocker;\n+import io.seata.core.lock.RowLock;\n+import io.seata.core.store.LockDO;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import redis.clients.jedis.Jedis;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisLocker extends AbstractLocker {\n+\n+    private static final Integer DEFAULT_SECONDS = 30;\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_PREFIX = \"SEATA_LOCK_\";\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX = \"SEATA_LOCK_XID_\";\n+\n+    /**\n+     * Instantiates a new Redis locker.\n+     *\n+     */\n+    public RedisLocker() {}\n+\n+    @Override\n+    public boolean acquireLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        List<String> successList = new ArrayList<>();\n+        long status = 0;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<LockDO> locks = convertToLockDO(rowLocks);\n+            for (LockDO lock : locks) {\n+                String key = DEFAULT_REDIS_SEATA_LOCK_PREFIX + lock.getRowKey();\n+                status = jedis.setnx(key, JSON.toJSONString(lock));\n+                if (status == 1) {\n+                    successList.add(key);\n+                    jedis.lpush(DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX + lock.getXid(), key);\n+                    jedis.expire(key, DEFAULT_SECONDS);\n+                } else {\n+                    break;\n+                }\n+            }\n+            if (status != 1) {\n+                String[] rms = successList.toArray(new String[successList.size()]);\n+                if (rms.length > 0) {\n+                    jedis.del(rms);\n+                }\n+                return false;\n+            } else {\n+                return true;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        String[] keys = new String[rowLocks.size()];\n+        List<LockDO> locks = convertToLockDO(rowLocks);\n+        for (int i = 0; i < locks.size(); i++) {\n+            String key = DEFAULT_REDIS_SEATA_LOCK_PREFIX + locks.get(i).getRowKey();\n+            keys[i] = key;\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            jedis.del(keys);\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(String xid, List<Long> branchIds) {\n+        if (CollectionUtils.isEmpty(branchIds)) {\n+            // no lock\n+            return true;\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String lockListKey = DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX + xid;\n+            List<String> keys = jedis.lrange(lockListKey, 0, 100);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjkwMzIxMA=="}, "originalCommit": {"oid": "a0d1a49a78008deca406bfaa8f218950be3f0b5a"}, "originalPosition": 106}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzNjc1ODc0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwMTozOToxMVrOGTzIZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwMTozOToxMVrOGTzIZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQxMzg2Mw==", "bodyText": "Objects.equals() ?", "url": "https://github.com/seata/seata/pull/2484#discussion_r423413863", "createdAt": "2020-05-12T01:39:11Z", "author": {"login": "jsbxyyx"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -135,7 +135,7 @@ public boolean releaseLock(String xid, Long branchId) {\n                 while (it.hasNext()) {\n                     String key = it.next();\n                     LockDO lock = JSON.parseObject(jedis.get(key), LockDO.class);\n-                    if (null != lock && lock.getBranchId().equals(branchId)) {\n+                    if (null != lock && branchId.equals(lock.getBranchId())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b8076a4d18384adbefd191dd28c197f3aae7b41"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MTg5NDUxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwNzo1MzowMlrOGUlpzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwNzo1MzowMlrOGUlpzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI0MTYxNQ==", "bodyText": "100 need change.", "url": "https://github.com/seata/seata/pull/2484#discussion_r424241615", "createdAt": "2020-05-13T07:53:02Z", "author": {"login": "jsbxyyx"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.lock;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.core.lock.AbstractLocker;\n+import io.seata.core.lock.RowLock;\n+import io.seata.core.store.LockDO;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import redis.clients.jedis.Jedis;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisLocker extends AbstractLocker {\n+\n+    private static final Integer DEFAULT_SECONDS = 30;\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_PREFIX = \"SEATA_LOCK_\";\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX = \"SEATA_LOCK_XID_\";\n+\n+    /**\n+     * Instantiates a new Redis locker.\n+     *\n+     */\n+    public RedisLocker() {}\n+\n+    @Override\n+    public boolean acquireLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        List<String> successList = new ArrayList<>();\n+        long status = 0;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<LockDO> locks = convertToLockDO(rowLocks);\n+            for (LockDO lock : locks) {\n+                String key = DEFAULT_REDIS_SEATA_LOCK_PREFIX + lock.getRowKey();\n+                status = jedis.setnx(key, JSON.toJSONString(lock));\n+                if (status == 1) {\n+                    successList.add(key);\n+                    jedis.lpush(DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX + lock.getXid(), key);\n+                    jedis.expire(key, DEFAULT_SECONDS);\n+                } else {\n+                    break;\n+                }\n+            }\n+            if (status != 1) {\n+                String[] rms = successList.toArray(new String[successList.size()]);\n+                if (rms.length > 0) {\n+                    jedis.del(rms);\n+                }\n+                return false;\n+            } else {\n+                return true;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        String[] keys = new String[rowLocks.size()];\n+        List<LockDO> locks = convertToLockDO(rowLocks);\n+        for (int i = 0; i < locks.size(); i++) {\n+            String key = DEFAULT_REDIS_SEATA_LOCK_PREFIX + locks.get(i).getRowKey();\n+            keys[i] = key;\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            jedis.del(keys);\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(String xid, List<Long> branchIds) {\n+        if (CollectionUtils.isEmpty(branchIds)) {\n+            // no lock\n+            return true;\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String lockListKey = DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX + xid;\n+            Set<String> keys = new HashSet<>();\n+            List<String> redisLockJson = null;\n+            int start = 0;\n+            do {\n+                redisLockJson = jedis.lrange(lockListKey, start, 100);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34bb3e1a86383a254ee4b33148f8b842518214e6"}, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MTg5NTE5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwNzo1MzoxM1rOGUlqOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwNzo1MzoxM1rOGUlqOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI0MTcyMg==", "bodyText": "100 need change.", "url": "https://github.com/seata/seata/pull/2484#discussion_r424241722", "createdAt": "2020-05-13T07:53:13Z", "author": {"login": "jsbxyyx"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.lock;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.core.lock.AbstractLocker;\n+import io.seata.core.lock.RowLock;\n+import io.seata.core.store.LockDO;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import redis.clients.jedis.Jedis;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisLocker extends AbstractLocker {\n+\n+    private static final Integer DEFAULT_SECONDS = 30;\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_PREFIX = \"SEATA_LOCK_\";\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX = \"SEATA_LOCK_XID_\";\n+\n+    /**\n+     * Instantiates a new Redis locker.\n+     *\n+     */\n+    public RedisLocker() {}\n+\n+    @Override\n+    public boolean acquireLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        List<String> successList = new ArrayList<>();\n+        long status = 0;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<LockDO> locks = convertToLockDO(rowLocks);\n+            for (LockDO lock : locks) {\n+                String key = DEFAULT_REDIS_SEATA_LOCK_PREFIX + lock.getRowKey();\n+                status = jedis.setnx(key, JSON.toJSONString(lock));\n+                if (status == 1) {\n+                    successList.add(key);\n+                    jedis.lpush(DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX + lock.getXid(), key);\n+                    jedis.expire(key, DEFAULT_SECONDS);\n+                } else {\n+                    break;\n+                }\n+            }\n+            if (status != 1) {\n+                String[] rms = successList.toArray(new String[successList.size()]);\n+                if (rms.length > 0) {\n+                    jedis.del(rms);\n+                }\n+                return false;\n+            } else {\n+                return true;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        String[] keys = new String[rowLocks.size()];\n+        List<LockDO> locks = convertToLockDO(rowLocks);\n+        for (int i = 0; i < locks.size(); i++) {\n+            String key = DEFAULT_REDIS_SEATA_LOCK_PREFIX + locks.get(i).getRowKey();\n+            keys[i] = key;\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            jedis.del(keys);\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(String xid, List<Long> branchIds) {\n+        if (CollectionUtils.isEmpty(branchIds)) {\n+            // no lock\n+            return true;\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String lockListKey = DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX + xid;\n+            Set<String> keys = new HashSet<>();\n+            List<String> redisLockJson = null;\n+            int start = 0;\n+            do {\n+                redisLockJson = jedis.lrange(lockListKey, start, 100);\n+                if (null != redisLockJson) {\n+                    keys.addAll(redisLockJson);\n+                    start = keys.size();\n+                }\n+            } while (null != redisLockJson && redisLockJson.size() >= 100);\n+            if (null != keys && keys.size() > 0) {\n+                Iterator<String> it = keys.iterator();\n+                while (it.hasNext()) {\n+                    String key = it.next();\n+                    LockDO lock = JSON.parseObject(jedis.get(key), LockDO.class);\n+                    for (int i = 0; i < branchIds.size(); i++) {\n+                        if (null != lock && Objects.equals(lock.getBranchId(), branchIds.get(i))) {\n+                            jedis.del(key);\n+                            jedis.lrem(lockListKey, 0, key);\n+                            it.remove();\n+                        }\n+                    }\n+                }\n+                if (keys.size() == 0) {\n+                    jedis.del(lockListKey);\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(String xid, Long branchId) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String lockListKey = DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX + xid;\n+            Set<String> keys = new HashSet<>();\n+            List<String> redisLockJson = null;\n+            int start = 0;\n+            do {\n+                redisLockJson = jedis.lrange(lockListKey, start, 100);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34bb3e1a86383a254ee4b33148f8b842518214e6"}, "originalPosition": 150}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MTg5NjU2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwNzo1MzozNFrOGUlrEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwNzo1MzozNFrOGUlrEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI0MTkzNg==", "bodyText": "100 need change.", "url": "https://github.com/seata/seata/pull/2484#discussion_r424241936", "createdAt": "2020-05-13T07:53:34Z", "author": {"login": "jsbxyyx"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,428 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO convertBranchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String branchsKey = DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + convertBranchTransactionDO.getXid();\n+            Set<String> branchs = new HashSet<>();\n+            List<String> redisBranchJson = null;\n+            int start = 0;\n+            do {\n+                redisBranchJson = jedis.lrange(branchsKey, start, 100);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34bb3e1a86383a254ee4b33148f8b842518214e6"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MTg5NzMwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwNzo1Mzo0NlrOGUlrhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwNzo1Mzo0NlrOGUlrhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI0MjA1NQ==", "bodyText": "100 need change.", "url": "https://github.com/seata/seata/pull/2484#discussion_r424242055", "createdAt": "2020-05-13T07:53:46Z", "author": {"login": "jsbxyyx"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,428 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO convertBranchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String branchsKey = DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + convertBranchTransactionDO.getXid();\n+            Set<String> branchs = new HashSet<>();\n+            List<String> redisBranchJson = null;\n+            int start = 0;\n+            do {\n+                redisBranchJson = jedis.lrange(branchsKey, start, 100);\n+                if (null != redisBranchJson) {\n+                    branchs.addAll(redisBranchJson);\n+                    start = branchs.size();\n+                }\n+            } while (null != redisBranchJson && redisBranchJson.size() >= 100);\n+            if (null != branchs && branchs.size() > 0) {\n+                String key = DEFAULT_REDIS_SEATA_BRANCH_PREFIX + convertBranchTransactionDO.getBranchId();\n+                Iterator<String> it = branchs.iterator();\n+                while (it.hasNext()) {\n+                    String s = it.next();\n+                    if (Objects.equals(s, key)) {\n+                        it.remove();\n+                        jedis.del(key);\n+                        jedis.lrem(branchsKey, 0, key);\n+                        break;\n+                    }\n+                }\n+                if (branchs.size() == 0) {\n+                    jedis.del(branchsKey);\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO convertBranchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = DEFAULT_REDIS_SEATA_BRANCH_PREFIX + convertBranchTransactionDO.getBranchId();\n+            if (jedis.get(key) == null) {\n+                jedis.lpush(DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + convertBranchTransactionDO.getXid(), key);\n+            }\n+            jedis.set(key, JSON.toJSONString(convertBranchTransactionDO));\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String[] keys = new String[3];\n+            keys[0] = DEFAULT_REDIS_SEATA_GLOBAL_PREFIX + convertGlobalTransactionDO.getXid();\n+            keys[1] = DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX + convertGlobalTransactionDO.getTransactionId();\n+            String branchsKey = DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + convertGlobalTransactionDO.getXid();\n+            List<String> redisBranchs = jedis.lrange(branchsKey, 0, 1);\n+            if (null == redisBranchs || redisBranchs.size() <= 0) {\n+                keys[2] = branchsKey;\n+            }\n+            jedis.del(keys);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String keys = DEFAULT_REDIS_SEATA_GLOBAL_PREFIX + convertGlobalTransactionDO.getXid();\n+            jedis.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            keys = DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX + convertGlobalTransactionDO.getTransactionId();\n+            jedis.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @param withBranchSessions\n+     *            the withBranchSessions\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid, boolean withBranchSessions) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            globalSessionJson = jedis.get(DEFAULT_REDIS_SEATA_GLOBAL_PREFIX + xid);\n+            if (StringUtils.isBlank(globalSessionJson)) {\n+                return null;\n+            }\n+            // global transaction\n+            GlobalTransactionDO globalTransactionDO = JSON.parseObject(globalSessionJson, GlobalTransactionDO.class);\n+            if (globalTransactionDO == null) {\n+                return null;\n+            }\n+            // branch transactions\n+            List<BranchTransactionDO> branchTransactionDOs = null;\n+            // reduce rpc with db when branchRegister and getGlobalStatus\n+            if (withBranchSessions) {\n+                Set<String> branchJson = new HashSet<>();\n+                int start = 0;\n+                List<String> redisBranchJson = null;\n+                do {\n+                    redisBranchJson =\n+                        jedis.lrange(DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + globalTransactionDO.getXid(), start, 100);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34bb3e1a86383a254ee4b33148f8b842518214e6"}, "originalPosition": 201}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MTg5ODEwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwNzo1Mzo1N1rOGUlr_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwNzo1Mzo1N1rOGUlr_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI0MjE3Mw==", "bodyText": "100 need change.", "url": "https://github.com/seata/seata/pull/2484#discussion_r424242173", "createdAt": "2020-05-13T07:53:57Z", "author": {"login": "jsbxyyx"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,428 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO convertBranchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String branchsKey = DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + convertBranchTransactionDO.getXid();\n+            Set<String> branchs = new HashSet<>();\n+            List<String> redisBranchJson = null;\n+            int start = 0;\n+            do {\n+                redisBranchJson = jedis.lrange(branchsKey, start, 100);\n+                if (null != redisBranchJson) {\n+                    branchs.addAll(redisBranchJson);\n+                    start = branchs.size();\n+                }\n+            } while (null != redisBranchJson && redisBranchJson.size() >= 100);\n+            if (null != branchs && branchs.size() > 0) {\n+                String key = DEFAULT_REDIS_SEATA_BRANCH_PREFIX + convertBranchTransactionDO.getBranchId();\n+                Iterator<String> it = branchs.iterator();\n+                while (it.hasNext()) {\n+                    String s = it.next();\n+                    if (Objects.equals(s, key)) {\n+                        it.remove();\n+                        jedis.del(key);\n+                        jedis.lrem(branchsKey, 0, key);\n+                        break;\n+                    }\n+                }\n+                if (branchs.size() == 0) {\n+                    jedis.del(branchsKey);\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO convertBranchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = DEFAULT_REDIS_SEATA_BRANCH_PREFIX + convertBranchTransactionDO.getBranchId();\n+            if (jedis.get(key) == null) {\n+                jedis.lpush(DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + convertBranchTransactionDO.getXid(), key);\n+            }\n+            jedis.set(key, JSON.toJSONString(convertBranchTransactionDO));\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String[] keys = new String[3];\n+            keys[0] = DEFAULT_REDIS_SEATA_GLOBAL_PREFIX + convertGlobalTransactionDO.getXid();\n+            keys[1] = DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX + convertGlobalTransactionDO.getTransactionId();\n+            String branchsKey = DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + convertGlobalTransactionDO.getXid();\n+            List<String> redisBranchs = jedis.lrange(branchsKey, 0, 1);\n+            if (null == redisBranchs || redisBranchs.size() <= 0) {\n+                keys[2] = branchsKey;\n+            }\n+            jedis.del(keys);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String keys = DEFAULT_REDIS_SEATA_GLOBAL_PREFIX + convertGlobalTransactionDO.getXid();\n+            jedis.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            keys = DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX + convertGlobalTransactionDO.getTransactionId();\n+            jedis.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @param withBranchSessions\n+     *            the withBranchSessions\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid, boolean withBranchSessions) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            globalSessionJson = jedis.get(DEFAULT_REDIS_SEATA_GLOBAL_PREFIX + xid);\n+            if (StringUtils.isBlank(globalSessionJson)) {\n+                return null;\n+            }\n+            // global transaction\n+            GlobalTransactionDO globalTransactionDO = JSON.parseObject(globalSessionJson, GlobalTransactionDO.class);\n+            if (globalTransactionDO == null) {\n+                return null;\n+            }\n+            // branch transactions\n+            List<BranchTransactionDO> branchTransactionDOs = null;\n+            // reduce rpc with db when branchRegister and getGlobalStatus\n+            if (withBranchSessions) {\n+                Set<String> branchJson = new HashSet<>();\n+                int start = 0;\n+                List<String> redisBranchJson = null;\n+                do {\n+                    redisBranchJson =\n+                        jedis.lrange(DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + globalTransactionDO.getXid(), start, 100);\n+                    if (null != redisBranchJson) {\n+                        branchJson.addAll(redisBranchJson);\n+                        start = branchJson.size();\n+                    }\n+                } while (null != redisBranchJson && redisBranchJson.size() >= 100);\n+                if (null != branchJson && branchJson.size() > 0) {\n+                    branchTransactionDOs = new ArrayList<>();\n+                    for (String s : branchJson) {\n+                        branchTransactionDOs.add(JSON.parseObject(jedis.get(s), BranchTransactionDO.class));\n+                    }\n+                }\n+            }\n+            return getGlobalSession(globalTransactionDO, branchTransactionDOs);\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid) {\n+        return this.readSession(xid, true);\n+    }\n+\n+    /**\n+     * Read session list.\n+     *\n+     * @param statuses\n+     *            the statuses\n+     * @return the list\n+     */\n+    public List<GlobalSession> readSession(GlobalStatus[] statuses) {\n+        List<Integer> states = new ArrayList<>();\n+        for (int i = 0; i < statuses.length; i++) {\n+            states.add(statuses[i].getCode());\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Set<String> keys = new HashSet<>();\n+            String cursor = \"0\";\n+            ScanParams params = new ScanParams();\n+            params.count(100);\n+            params.match(DEFAULT_REDIS_SEATA_GLOBAL_PREFIX + \"*\");\n+            ScanResult<String> scans;\n+            do {\n+                scans = jedis.scan(cursor, params);\n+                keys.addAll(scans.getResult().stream().collect(Collectors.toSet()));\n+                cursor = scans.getCursor();\n+            } while (!cursor.equalsIgnoreCase(\"0\"));\n+            if (null != keys && keys.size() > 0) {\n+                List<GlobalTransactionDO> globalTransactionDOs = new ArrayList<>();\n+                for (String globalKey : keys) {\n+                    GlobalTransactionDO globalTransactionDO =\n+                        JSON.parseObject(jedis.get(globalKey), GlobalTransactionDO.class);\n+                    if (null != globalTransactionDO && states.contains(globalTransactionDO.getStatus())) {\n+                        globalTransactionDOs.add(globalTransactionDO);\n+                    }\n+                }\n+                if (globalTransactionDOs.size() > 0) {\n+                    List<String> xids =\n+                        globalTransactionDOs.stream().map(GlobalTransactionDO::getXid).collect(Collectors.toList());\n+                    List<BranchTransactionDO> branchTransactionDOs = new ArrayList<>();\n+                    for (String xid : xids) {\n+                        Set<String> branchs = new HashSet<>();\n+                        int start = 0;\n+                        List<String> redisBranchs = null;\n+                        do {\n+                            redisBranchs = jedis.lrange(DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + xid, start, 100);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34bb3e1a86383a254ee4b33148f8b842518214e6"}, "originalPosition": 272}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MTg5ODk4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwNzo1NDoxMlrOGUlshQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwNzo1NDoxMlrOGUlshQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI0MjMwOQ==", "bodyText": "100 need change.", "url": "https://github.com/seata/seata/pull/2484#discussion_r424242309", "createdAt": "2020-05-13T07:54:12Z", "author": {"login": "jsbxyyx"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,428 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO convertBranchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String branchsKey = DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + convertBranchTransactionDO.getXid();\n+            Set<String> branchs = new HashSet<>();\n+            List<String> redisBranchJson = null;\n+            int start = 0;\n+            do {\n+                redisBranchJson = jedis.lrange(branchsKey, start, 100);\n+                if (null != redisBranchJson) {\n+                    branchs.addAll(redisBranchJson);\n+                    start = branchs.size();\n+                }\n+            } while (null != redisBranchJson && redisBranchJson.size() >= 100);\n+            if (null != branchs && branchs.size() > 0) {\n+                String key = DEFAULT_REDIS_SEATA_BRANCH_PREFIX + convertBranchTransactionDO.getBranchId();\n+                Iterator<String> it = branchs.iterator();\n+                while (it.hasNext()) {\n+                    String s = it.next();\n+                    if (Objects.equals(s, key)) {\n+                        it.remove();\n+                        jedis.del(key);\n+                        jedis.lrem(branchsKey, 0, key);\n+                        break;\n+                    }\n+                }\n+                if (branchs.size() == 0) {\n+                    jedis.del(branchsKey);\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO convertBranchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = DEFAULT_REDIS_SEATA_BRANCH_PREFIX + convertBranchTransactionDO.getBranchId();\n+            if (jedis.get(key) == null) {\n+                jedis.lpush(DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + convertBranchTransactionDO.getXid(), key);\n+            }\n+            jedis.set(key, JSON.toJSONString(convertBranchTransactionDO));\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String[] keys = new String[3];\n+            keys[0] = DEFAULT_REDIS_SEATA_GLOBAL_PREFIX + convertGlobalTransactionDO.getXid();\n+            keys[1] = DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX + convertGlobalTransactionDO.getTransactionId();\n+            String branchsKey = DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + convertGlobalTransactionDO.getXid();\n+            List<String> redisBranchs = jedis.lrange(branchsKey, 0, 1);\n+            if (null == redisBranchs || redisBranchs.size() <= 0) {\n+                keys[2] = branchsKey;\n+            }\n+            jedis.del(keys);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String keys = DEFAULT_REDIS_SEATA_GLOBAL_PREFIX + convertGlobalTransactionDO.getXid();\n+            jedis.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            keys = DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX + convertGlobalTransactionDO.getTransactionId();\n+            jedis.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @param withBranchSessions\n+     *            the withBranchSessions\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid, boolean withBranchSessions) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            globalSessionJson = jedis.get(DEFAULT_REDIS_SEATA_GLOBAL_PREFIX + xid);\n+            if (StringUtils.isBlank(globalSessionJson)) {\n+                return null;\n+            }\n+            // global transaction\n+            GlobalTransactionDO globalTransactionDO = JSON.parseObject(globalSessionJson, GlobalTransactionDO.class);\n+            if (globalTransactionDO == null) {\n+                return null;\n+            }\n+            // branch transactions\n+            List<BranchTransactionDO> branchTransactionDOs = null;\n+            // reduce rpc with db when branchRegister and getGlobalStatus\n+            if (withBranchSessions) {\n+                Set<String> branchJson = new HashSet<>();\n+                int start = 0;\n+                List<String> redisBranchJson = null;\n+                do {\n+                    redisBranchJson =\n+                        jedis.lrange(DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + globalTransactionDO.getXid(), start, 100);\n+                    if (null != redisBranchJson) {\n+                        branchJson.addAll(redisBranchJson);\n+                        start = branchJson.size();\n+                    }\n+                } while (null != redisBranchJson && redisBranchJson.size() >= 100);\n+                if (null != branchJson && branchJson.size() > 0) {\n+                    branchTransactionDOs = new ArrayList<>();\n+                    for (String s : branchJson) {\n+                        branchTransactionDOs.add(JSON.parseObject(jedis.get(s), BranchTransactionDO.class));\n+                    }\n+                }\n+            }\n+            return getGlobalSession(globalTransactionDO, branchTransactionDOs);\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid) {\n+        return this.readSession(xid, true);\n+    }\n+\n+    /**\n+     * Read session list.\n+     *\n+     * @param statuses\n+     *            the statuses\n+     * @return the list\n+     */\n+    public List<GlobalSession> readSession(GlobalStatus[] statuses) {\n+        List<Integer> states = new ArrayList<>();\n+        for (int i = 0; i < statuses.length; i++) {\n+            states.add(statuses[i].getCode());\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Set<String> keys = new HashSet<>();\n+            String cursor = \"0\";\n+            ScanParams params = new ScanParams();\n+            params.count(100);\n+            params.match(DEFAULT_REDIS_SEATA_GLOBAL_PREFIX + \"*\");\n+            ScanResult<String> scans;\n+            do {\n+                scans = jedis.scan(cursor, params);\n+                keys.addAll(scans.getResult().stream().collect(Collectors.toSet()));\n+                cursor = scans.getCursor();\n+            } while (!cursor.equalsIgnoreCase(\"0\"));\n+            if (null != keys && keys.size() > 0) {\n+                List<GlobalTransactionDO> globalTransactionDOs = new ArrayList<>();\n+                for (String globalKey : keys) {\n+                    GlobalTransactionDO globalTransactionDO =\n+                        JSON.parseObject(jedis.get(globalKey), GlobalTransactionDO.class);\n+                    if (null != globalTransactionDO && states.contains(globalTransactionDO.getStatus())) {\n+                        globalTransactionDOs.add(globalTransactionDO);\n+                    }\n+                }\n+                if (globalTransactionDOs.size() > 0) {\n+                    List<String> xids =\n+                        globalTransactionDOs.stream().map(GlobalTransactionDO::getXid).collect(Collectors.toList());\n+                    List<BranchTransactionDO> branchTransactionDOs = new ArrayList<>();\n+                    for (String xid : xids) {\n+                        Set<String> branchs = new HashSet<>();\n+                        int start = 0;\n+                        List<String> redisBranchs = null;\n+                        do {\n+                            redisBranchs = jedis.lrange(DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + xid, start, 100);\n+                            if (null != redisBranchs) {\n+                                branchs.addAll(redisBranchs);\n+                                start = branchs.size();\n+                            }\n+                        } while (null != redisBranchs && redisBranchs.size() >= 100);\n+                        if (null != branchs && branchs.size() > 0) {\n+                            for (String branchKey : branchs) {\n+                                String branchJson = jedis.get(branchKey);\n+                                if (StringUtils.isNotBlank(branchJson)) {\n+                                    branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                                }\n+                            }\n+                        }\n+                    }\n+                    Map<String, List<BranchTransactionDO>> branchTransactionDOsMap =\n+                        branchTransactionDOs.stream().collect(Collectors.groupingBy(BranchTransactionDO::getXid,\n+                            LinkedHashMap::new, Collectors.toList()));\n+                    return globalTransactionDOs.stream()\n+                        .map(globalTransactionDO -> getGlobalSession(globalTransactionDO,\n+                            branchTransactionDOsMap.get(globalTransactionDO.getXid())))\n+                        .collect(Collectors.toList());\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public List<GlobalSession> readSession(SessionCondition sessionCondition) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            if (StringUtils.isNotBlank(sessionCondition.getXid())) {\n+                globalSessionJson = jedis.get(DEFAULT_REDIS_SEATA_GLOBAL_PREFIX + sessionCondition.getXid());\n+                if (StringUtils.isNotBlank(globalSessionJson)) {\n+                    GlobalSession session =\n+                        convertGlobalSession(JSON.parseObject(globalSessionJson, GlobalTransactionDO.class));\n+                    List<GlobalSession> globalSessions = new ArrayList<>();\n+                    globalSessions.add(session);\n+                    return globalSessions;\n+                }\n+            } else if (sessionCondition.getTransactionId() != null) {\n+                String global =\n+                    jedis.get(DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX + sessionCondition.getTransactionId());\n+                if (StringUtils.isBlank(global)) {\n+                    return null;\n+                }\n+                GlobalTransactionDO globalTransactionDO = JSON.parseObject(global, GlobalTransactionDO.class);\n+                String branchsKey = DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + globalTransactionDO.getXid();\n+                int start = 0;\n+                Set<String> branchJson = new HashSet<>();\n+                List<String> redisBranchJson = null;\n+                do {\n+                    redisBranchJson = jedis.lrange(branchsKey, start, 100);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34bb3e1a86383a254ee4b33148f8b842518214e6"}, "originalPosition": 325}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1OTgzNzA4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwNjo1OTowNlrOGXSYxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwNjo1OTowNlrOGXSYxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA3MTY4Ng==", "bodyText": "100 define constant?", "url": "https://github.com/seata/seata/pull/2484#discussion_r427071686", "createdAt": "2020-05-19T06:59:06Z", "author": {"login": "jsbxyyx"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.lock;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.core.lock.AbstractLocker;\n+import io.seata.core.lock.RowLock;\n+import io.seata.core.store.LockDO;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import redis.clients.jedis.Jedis;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisLocker extends AbstractLocker {\n+\n+    private static final Integer DEFAULT_SECONDS = 30;\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_PREFIX = \"SEATA_LOCK_\";\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX = \"SEATA_LOCK_XID_\";\n+\n+    /**\n+     * Instantiates a new Redis locker.\n+     *\n+     */\n+    public RedisLocker() {}\n+\n+    @Override\n+    public boolean acquireLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        List<String> successList = new ArrayList<>();\n+        long status = 0;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<LockDO> locks = convertToLockDO(rowLocks);\n+            for (LockDO lock : locks) {\n+                String key = DEFAULT_REDIS_SEATA_LOCK_PREFIX + lock.getRowKey();\n+                status = jedis.setnx(key, JSON.toJSONString(lock));\n+                if (status == 1) {\n+                    successList.add(key);\n+                    jedis.lpush(DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX + lock.getXid(), key);\n+                    jedis.expire(key, DEFAULT_SECONDS);\n+                } else {\n+                    break;\n+                }\n+            }\n+            if (status != 1) {\n+                String[] rms = successList.toArray(new String[successList.size()]);\n+                if (rms.length > 0) {\n+                    jedis.del(rms);\n+                }\n+                return false;\n+            } else {\n+                return true;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        String[] keys = new String[rowLocks.size()];\n+        List<LockDO> locks = convertToLockDO(rowLocks);\n+        for (int i = 0; i < locks.size(); i++) {\n+            String key = DEFAULT_REDIS_SEATA_LOCK_PREFIX + locks.get(i).getRowKey();\n+            keys[i] = key;\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            jedis.del(keys);\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(String xid, List<Long> branchIds) {\n+        if (CollectionUtils.isEmpty(branchIds)) {\n+            // no lock\n+            return true;\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String lockListKey = DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX + xid;\n+            Set<String> keys = new HashSet<>();\n+            List<String> redisLockJson = null;\n+            int start = 0;\n+            int stop = 100;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c4737498cd04bf1d73a2bdff0581cec774e4852"}, "originalPosition": 114}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1OTgzOTE3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwNjo1OTo0N1rOGXSaCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwNjo1OTo0N1rOGXSaCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA3MjAxMQ==", "bodyText": "above.", "url": "https://github.com/seata/seata/pull/2484#discussion_r427072011", "createdAt": "2020-05-19T06:59:47Z", "author": {"login": "jsbxyyx"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.lock;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.core.lock.AbstractLocker;\n+import io.seata.core.lock.RowLock;\n+import io.seata.core.store.LockDO;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import redis.clients.jedis.Jedis;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisLocker extends AbstractLocker {\n+\n+    private static final Integer DEFAULT_SECONDS = 30;\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_PREFIX = \"SEATA_LOCK_\";\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX = \"SEATA_LOCK_XID_\";\n+\n+    /**\n+     * Instantiates a new Redis locker.\n+     *\n+     */\n+    public RedisLocker() {}\n+\n+    @Override\n+    public boolean acquireLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        List<String> successList = new ArrayList<>();\n+        long status = 0;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<LockDO> locks = convertToLockDO(rowLocks);\n+            for (LockDO lock : locks) {\n+                String key = DEFAULT_REDIS_SEATA_LOCK_PREFIX + lock.getRowKey();\n+                status = jedis.setnx(key, JSON.toJSONString(lock));\n+                if (status == 1) {\n+                    successList.add(key);\n+                    jedis.lpush(DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX + lock.getXid(), key);\n+                    jedis.expire(key, DEFAULT_SECONDS);\n+                } else {\n+                    break;\n+                }\n+            }\n+            if (status != 1) {\n+                String[] rms = successList.toArray(new String[successList.size()]);\n+                if (rms.length > 0) {\n+                    jedis.del(rms);\n+                }\n+                return false;\n+            } else {\n+                return true;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        String[] keys = new String[rowLocks.size()];\n+        List<LockDO> locks = convertToLockDO(rowLocks);\n+        for (int i = 0; i < locks.size(); i++) {\n+            String key = DEFAULT_REDIS_SEATA_LOCK_PREFIX + locks.get(i).getRowKey();\n+            keys[i] = key;\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            jedis.del(keys);\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(String xid, List<Long> branchIds) {\n+        if (CollectionUtils.isEmpty(branchIds)) {\n+            // no lock\n+            return true;\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String lockListKey = DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX + xid;\n+            Set<String> keys = new HashSet<>();\n+            List<String> redisLockJson = null;\n+            int start = 0;\n+            int stop = 100;\n+            for (;;) {\n+                redisLockJson = jedis.lrange(lockListKey, start, stop);\n+                if (null != redisLockJson) {\n+                    keys.addAll(redisLockJson);\n+                    start = keys.size();\n+                    stop = start + 100;\n+                } else {\n+                    break;\n+                }\n+            }\n+            if (null != keys && keys.size() > 0) {\n+                Iterator<String> it = keys.iterator();\n+                while (it.hasNext()) {\n+                    String key = it.next();\n+                    LockDO lock = JSON.parseObject(jedis.get(key), LockDO.class);\n+                    for (int i = 0; i < branchIds.size(); i++) {\n+                        if (null != lock && Objects.equals(lock.getBranchId(), branchIds.get(i))) {\n+                            jedis.del(key);\n+                            jedis.lrem(lockListKey, 0, key);\n+                            it.remove();\n+                        }\n+                    }\n+                }\n+                if (keys.size() == 0) {\n+                    jedis.del(lockListKey);\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(String xid, Long branchId) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String lockListKey = DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX + xid;\n+            Set<String> keys = new HashSet<>();\n+            List<String> redisLockJson = null;\n+            int start = 0;\n+            int stop = 100;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c4737498cd04bf1d73a2bdff0581cec774e4852"}, "originalPosition": 153}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1OTg0MjgxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwNzowMDo1OVrOGXScQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwNzowMDo1OVrOGXScQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA3MjU3Ng==", "bodyText": "above.", "url": "https://github.com/seata/seata/pull/2484#discussion_r427072576", "createdAt": "2020-05-19T07:00:59Z", "author": {"login": "jsbxyyx"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,443 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO convertBranchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String branchsKey = DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + convertBranchTransactionDO.getXid();\n+            Set<String> branchs = new HashSet<>();\n+            List<String> redisBranchJson = null;\n+            int start = 0;\n+            int stop = 100;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c4737498cd04bf1d73a2bdff0581cec774e4852"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1OTg0NTY2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwNzowMjowMFrOGXSeEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwNzowMjowMFrOGXSeEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA3MzA0Mw==", "bodyText": "extract common get key method?", "url": "https://github.com/seata/seata/pull/2484#discussion_r427073043", "createdAt": "2020-05-19T07:02:00Z", "author": {"login": "jsbxyyx"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,443 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO convertBranchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String branchsKey = DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + convertBranchTransactionDO.getXid();\n+            Set<String> branchs = new HashSet<>();\n+            List<String> redisBranchJson = null;\n+            int start = 0;\n+            int stop = 100;\n+            for (;;) {\n+                redisBranchJson = jedis.lrange(branchsKey, start, stop);\n+                if (null != redisBranchJson) {\n+                    branchs.addAll(redisBranchJson);\n+                    start = branchs.size();\n+                    stop = start + 100;\n+                } else {\n+                    break;\n+                }\n+            }\n+            if (null != branchs && branchs.size() > 0) {\n+                String key = DEFAULT_REDIS_SEATA_BRANCH_PREFIX + convertBranchTransactionDO.getBranchId();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c4737498cd04bf1d73a2bdff0581cec774e4852"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1OTg0NjczOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwNzowMjoyMlrOGXSexA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwNzowMjoyMlrOGXSexA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA3MzIyMA==", "bodyText": "extract common get key method?", "url": "https://github.com/seata/seata/pull/2484#discussion_r427073220", "createdAt": "2020-05-19T07:02:22Z", "author": {"login": "jsbxyyx"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,443 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO convertBranchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String branchsKey = DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + convertBranchTransactionDO.getXid();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c4737498cd04bf1d73a2bdff0581cec774e4852"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1OTg0OTk3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwNzowMzozM1rOGXSgzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwNzowMzozM1rOGXSgzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA3Mzc0Mw==", "bodyText": "extract define constant?", "url": "https://github.com/seata/seata/pull/2484#discussion_r427073743", "createdAt": "2020-05-19T07:03:33Z", "author": {"login": "jsbxyyx"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,443 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO convertBranchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String branchsKey = DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + convertBranchTransactionDO.getXid();\n+            Set<String> branchs = new HashSet<>();\n+            List<String> redisBranchJson = null;\n+            int start = 0;\n+            int stop = 100;\n+            for (;;) {\n+                redisBranchJson = jedis.lrange(branchsKey, start, stop);\n+                if (null != redisBranchJson) {\n+                    branchs.addAll(redisBranchJson);\n+                    start = branchs.size();\n+                    stop = start + 100;\n+                } else {\n+                    break;\n+                }\n+            }\n+            if (null != branchs && branchs.size() > 0) {\n+                String key = DEFAULT_REDIS_SEATA_BRANCH_PREFIX + convertBranchTransactionDO.getBranchId();\n+                Iterator<String> it = branchs.iterator();\n+                while (it.hasNext()) {\n+                    String s = it.next();\n+                    if (Objects.equals(s, key)) {\n+                        it.remove();\n+                        jedis.del(key);\n+                        jedis.lrem(branchsKey, 0, key);\n+                        break;\n+                    }\n+                }\n+                if (branchs.size() == 0) {\n+                    jedis.del(branchsKey);\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO convertBranchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = DEFAULT_REDIS_SEATA_BRANCH_PREFIX + convertBranchTransactionDO.getBranchId();\n+            if (jedis.get(key) == null) {\n+                jedis.lpush(DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + convertBranchTransactionDO.getXid(), key);\n+            }\n+            jedis.set(key, JSON.toJSONString(convertBranchTransactionDO));\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String[] keys = new String[3];\n+            keys[0] = DEFAULT_REDIS_SEATA_GLOBAL_PREFIX + convertGlobalTransactionDO.getXid();\n+            keys[1] = DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX + convertGlobalTransactionDO.getTransactionId();\n+            String branchsKey = DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + convertGlobalTransactionDO.getXid();\n+            List<String> redisBranchs = jedis.lrange(branchsKey, 0, 1);\n+            if (null == redisBranchs || redisBranchs.size() <= 0) {\n+                keys[2] = branchsKey;\n+            }\n+            jedis.del(keys);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String keys = DEFAULT_REDIS_SEATA_GLOBAL_PREFIX + convertGlobalTransactionDO.getXid();\n+            jedis.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            keys = DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX + convertGlobalTransactionDO.getTransactionId();\n+            jedis.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @param withBranchSessions\n+     *            the withBranchSessions\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid, boolean withBranchSessions) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            globalSessionJson = jedis.get(DEFAULT_REDIS_SEATA_GLOBAL_PREFIX + xid);\n+            if (StringUtils.isBlank(globalSessionJson)) {\n+                return null;\n+            }\n+            // global transaction\n+            GlobalTransactionDO globalTransactionDO = JSON.parseObject(globalSessionJson, GlobalTransactionDO.class);\n+            if (globalTransactionDO == null) {\n+                return null;\n+            }\n+            // branch transactions\n+            List<BranchTransactionDO> branchTransactionDOs = null;\n+            // reduce rpc with db when branchRegister and getGlobalStatus\n+            if (withBranchSessions) {\n+                Set<String> branchJson = new HashSet<>();\n+                int start = 0;\n+                List<String> redisBranchJson = null;\n+                int stop = 100;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c4737498cd04bf1d73a2bdff0581cec774e4852"}, "originalPosition": 203}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1OTg1MTIzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwNzowNDowM1rOGXShoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwNzowNDowM1rOGXShoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA3Mzk1Mg==", "bodyText": "extract define constant?", "url": "https://github.com/seata/seata/pull/2484#discussion_r427073952", "createdAt": "2020-05-19T07:04:03Z", "author": {"login": "jsbxyyx"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,443 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO convertBranchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String branchsKey = DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + convertBranchTransactionDO.getXid();\n+            Set<String> branchs = new HashSet<>();\n+            List<String> redisBranchJson = null;\n+            int start = 0;\n+            int stop = 100;\n+            for (;;) {\n+                redisBranchJson = jedis.lrange(branchsKey, start, stop);\n+                if (null != redisBranchJson) {\n+                    branchs.addAll(redisBranchJson);\n+                    start = branchs.size();\n+                    stop = start + 100;\n+                } else {\n+                    break;\n+                }\n+            }\n+            if (null != branchs && branchs.size() > 0) {\n+                String key = DEFAULT_REDIS_SEATA_BRANCH_PREFIX + convertBranchTransactionDO.getBranchId();\n+                Iterator<String> it = branchs.iterator();\n+                while (it.hasNext()) {\n+                    String s = it.next();\n+                    if (Objects.equals(s, key)) {\n+                        it.remove();\n+                        jedis.del(key);\n+                        jedis.lrem(branchsKey, 0, key);\n+                        break;\n+                    }\n+                }\n+                if (branchs.size() == 0) {\n+                    jedis.del(branchsKey);\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO convertBranchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = DEFAULT_REDIS_SEATA_BRANCH_PREFIX + convertBranchTransactionDO.getBranchId();\n+            if (jedis.get(key) == null) {\n+                jedis.lpush(DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + convertBranchTransactionDO.getXid(), key);\n+            }\n+            jedis.set(key, JSON.toJSONString(convertBranchTransactionDO));\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String[] keys = new String[3];\n+            keys[0] = DEFAULT_REDIS_SEATA_GLOBAL_PREFIX + convertGlobalTransactionDO.getXid();\n+            keys[1] = DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX + convertGlobalTransactionDO.getTransactionId();\n+            String branchsKey = DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + convertGlobalTransactionDO.getXid();\n+            List<String> redisBranchs = jedis.lrange(branchsKey, 0, 1);\n+            if (null == redisBranchs || redisBranchs.size() <= 0) {\n+                keys[2] = branchsKey;\n+            }\n+            jedis.del(keys);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String keys = DEFAULT_REDIS_SEATA_GLOBAL_PREFIX + convertGlobalTransactionDO.getXid();\n+            jedis.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            keys = DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX + convertGlobalTransactionDO.getTransactionId();\n+            jedis.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @param withBranchSessions\n+     *            the withBranchSessions\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid, boolean withBranchSessions) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            globalSessionJson = jedis.get(DEFAULT_REDIS_SEATA_GLOBAL_PREFIX + xid);\n+            if (StringUtils.isBlank(globalSessionJson)) {\n+                return null;\n+            }\n+            // global transaction\n+            GlobalTransactionDO globalTransactionDO = JSON.parseObject(globalSessionJson, GlobalTransactionDO.class);\n+            if (globalTransactionDO == null) {\n+                return null;\n+            }\n+            // branch transactions\n+            List<BranchTransactionDO> branchTransactionDOs = null;\n+            // reduce rpc with db when branchRegister and getGlobalStatus\n+            if (withBranchSessions) {\n+                Set<String> branchJson = new HashSet<>();\n+                int start = 0;\n+                List<String> redisBranchJson = null;\n+                int stop = 100;\n+                for (;;) {\n+                    redisBranchJson = jedis.lrange(DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + globalTransactionDO.getXid(), start, stop);\n+                    if (null != redisBranchJson) {\n+                        branchJson.addAll(redisBranchJson);\n+                        start = branchJson.size();\n+                        stop = start + 100;\n+                    } else {\n+                        break;\n+                    }\n+                }\n+                if (null != branchJson && branchJson.size() > 0) {\n+                    branchTransactionDOs = new ArrayList<>();\n+                    for (String s : branchJson) {\n+                        branchTransactionDOs.add(JSON.parseObject(jedis.get(s), BranchTransactionDO.class));\n+                    }\n+                }\n+            }\n+            return getGlobalSession(globalTransactionDO, branchTransactionDOs);\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid) {\n+        return this.readSession(xid, true);\n+    }\n+\n+    /**\n+     * Read session list.\n+     *\n+     * @param statuses\n+     *            the statuses\n+     * @return the list\n+     */\n+    public List<GlobalSession> readSession(GlobalStatus[] statuses) {\n+        List<Integer> states = new ArrayList<>();\n+        for (int i = 0; i < statuses.length; i++) {\n+            states.add(statuses[i].getCode());\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Set<String> keys = new HashSet<>();\n+            String cursor = \"0\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c4737498cd04bf1d73a2bdff0581cec774e4852"}, "originalPosition": 251}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1OTg1MTkyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwNzowNDoxOVrOGXSiHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwNzowNDoxOVrOGXSiHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA3NDA3OA==", "bodyText": "extract define constant?", "url": "https://github.com/seata/seata/pull/2484#discussion_r427074078", "createdAt": "2020-05-19T07:04:19Z", "author": {"login": "jsbxyyx"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,443 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO convertBranchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String branchsKey = DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + convertBranchTransactionDO.getXid();\n+            Set<String> branchs = new HashSet<>();\n+            List<String> redisBranchJson = null;\n+            int start = 0;\n+            int stop = 100;\n+            for (;;) {\n+                redisBranchJson = jedis.lrange(branchsKey, start, stop);\n+                if (null != redisBranchJson) {\n+                    branchs.addAll(redisBranchJson);\n+                    start = branchs.size();\n+                    stop = start + 100;\n+                } else {\n+                    break;\n+                }\n+            }\n+            if (null != branchs && branchs.size() > 0) {\n+                String key = DEFAULT_REDIS_SEATA_BRANCH_PREFIX + convertBranchTransactionDO.getBranchId();\n+                Iterator<String> it = branchs.iterator();\n+                while (it.hasNext()) {\n+                    String s = it.next();\n+                    if (Objects.equals(s, key)) {\n+                        it.remove();\n+                        jedis.del(key);\n+                        jedis.lrem(branchsKey, 0, key);\n+                        break;\n+                    }\n+                }\n+                if (branchs.size() == 0) {\n+                    jedis.del(branchsKey);\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO convertBranchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = DEFAULT_REDIS_SEATA_BRANCH_PREFIX + convertBranchTransactionDO.getBranchId();\n+            if (jedis.get(key) == null) {\n+                jedis.lpush(DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + convertBranchTransactionDO.getXid(), key);\n+            }\n+            jedis.set(key, JSON.toJSONString(convertBranchTransactionDO));\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String[] keys = new String[3];\n+            keys[0] = DEFAULT_REDIS_SEATA_GLOBAL_PREFIX + convertGlobalTransactionDO.getXid();\n+            keys[1] = DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX + convertGlobalTransactionDO.getTransactionId();\n+            String branchsKey = DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + convertGlobalTransactionDO.getXid();\n+            List<String> redisBranchs = jedis.lrange(branchsKey, 0, 1);\n+            if (null == redisBranchs || redisBranchs.size() <= 0) {\n+                keys[2] = branchsKey;\n+            }\n+            jedis.del(keys);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String keys = DEFAULT_REDIS_SEATA_GLOBAL_PREFIX + convertGlobalTransactionDO.getXid();\n+            jedis.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            keys = DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX + convertGlobalTransactionDO.getTransactionId();\n+            jedis.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @param withBranchSessions\n+     *            the withBranchSessions\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid, boolean withBranchSessions) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            globalSessionJson = jedis.get(DEFAULT_REDIS_SEATA_GLOBAL_PREFIX + xid);\n+            if (StringUtils.isBlank(globalSessionJson)) {\n+                return null;\n+            }\n+            // global transaction\n+            GlobalTransactionDO globalTransactionDO = JSON.parseObject(globalSessionJson, GlobalTransactionDO.class);\n+            if (globalTransactionDO == null) {\n+                return null;\n+            }\n+            // branch transactions\n+            List<BranchTransactionDO> branchTransactionDOs = null;\n+            // reduce rpc with db when branchRegister and getGlobalStatus\n+            if (withBranchSessions) {\n+                Set<String> branchJson = new HashSet<>();\n+                int start = 0;\n+                List<String> redisBranchJson = null;\n+                int stop = 100;\n+                for (;;) {\n+                    redisBranchJson = jedis.lrange(DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + globalTransactionDO.getXid(), start, stop);\n+                    if (null != redisBranchJson) {\n+                        branchJson.addAll(redisBranchJson);\n+                        start = branchJson.size();\n+                        stop = start + 100;\n+                    } else {\n+                        break;\n+                    }\n+                }\n+                if (null != branchJson && branchJson.size() > 0) {\n+                    branchTransactionDOs = new ArrayList<>();\n+                    for (String s : branchJson) {\n+                        branchTransactionDOs.add(JSON.parseObject(jedis.get(s), BranchTransactionDO.class));\n+                    }\n+                }\n+            }\n+            return getGlobalSession(globalTransactionDO, branchTransactionDOs);\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid) {\n+        return this.readSession(xid, true);\n+    }\n+\n+    /**\n+     * Read session list.\n+     *\n+     * @param statuses\n+     *            the statuses\n+     * @return the list\n+     */\n+    public List<GlobalSession> readSession(GlobalStatus[] statuses) {\n+        List<Integer> states = new ArrayList<>();\n+        for (int i = 0; i < statuses.length; i++) {\n+            states.add(statuses[i].getCode());\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Set<String> keys = new HashSet<>();\n+            String cursor = \"0\";\n+            ScanParams params = new ScanParams();\n+            params.count(100);\n+            params.match(DEFAULT_REDIS_SEATA_GLOBAL_PREFIX + \"*\");\n+            ScanResult<String> scans;\n+            do {\n+                scans = jedis.scan(cursor, params);\n+                keys.addAll(scans.getResult().stream().collect(Collectors.toSet()));\n+                cursor = scans.getCursor();\n+            } while (!cursor.equalsIgnoreCase(\"0\"));\n+            if (null != keys && keys.size() > 0) {\n+                List<GlobalTransactionDO> globalTransactionDOs = new ArrayList<>();\n+                for (String globalKey : keys) {\n+                    GlobalTransactionDO globalTransactionDO =\n+                        JSON.parseObject(jedis.get(globalKey), GlobalTransactionDO.class);\n+                    if (null != globalTransactionDO && states.contains(globalTransactionDO.getStatus())) {\n+                        globalTransactionDOs.add(globalTransactionDO);\n+                    }\n+                }\n+                if (globalTransactionDOs.size() > 0) {\n+                    List<String> xids =\n+                        globalTransactionDOs.stream().map(GlobalTransactionDO::getXid).collect(Collectors.toList());\n+                    List<BranchTransactionDO> branchTransactionDOs = new ArrayList<>();\n+                    for (String xid : xids) {\n+                        Set<String> branchs = new HashSet<>();\n+                        int start = 0;\n+                        int stop = 100;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c4737498cd04bf1d73a2bdff0581cec774e4852"}, "originalPosition": 277}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1OTg1NDAwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwNzowNTowM1rOGXSjVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwNzoxMDo1N1rOGXSt9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA3NDM5MA==", "bodyText": "extract common method?", "url": "https://github.com/seata/seata/pull/2484#discussion_r427074390", "createdAt": "2020-05-19T07:05:03Z", "author": {"login": "jsbxyyx"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,443 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO convertBranchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String branchsKey = DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + convertBranchTransactionDO.getXid();\n+            Set<String> branchs = new HashSet<>();\n+            List<String> redisBranchJson = null;\n+            int start = 0;\n+            int stop = 100;\n+            for (;;) {\n+                redisBranchJson = jedis.lrange(branchsKey, start, stop);\n+                if (null != redisBranchJson) {\n+                    branchs.addAll(redisBranchJson);\n+                    start = branchs.size();\n+                    stop = start + 100;\n+                } else {\n+                    break;\n+                }\n+            }\n+            if (null != branchs && branchs.size() > 0) {\n+                String key = DEFAULT_REDIS_SEATA_BRANCH_PREFIX + convertBranchTransactionDO.getBranchId();\n+                Iterator<String> it = branchs.iterator();\n+                while (it.hasNext()) {\n+                    String s = it.next();\n+                    if (Objects.equals(s, key)) {\n+                        it.remove();\n+                        jedis.del(key);\n+                        jedis.lrem(branchsKey, 0, key);\n+                        break;\n+                    }\n+                }\n+                if (branchs.size() == 0) {\n+                    jedis.del(branchsKey);\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO convertBranchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = DEFAULT_REDIS_SEATA_BRANCH_PREFIX + convertBranchTransactionDO.getBranchId();\n+            if (jedis.get(key) == null) {\n+                jedis.lpush(DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + convertBranchTransactionDO.getXid(), key);\n+            }\n+            jedis.set(key, JSON.toJSONString(convertBranchTransactionDO));\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String[] keys = new String[3];\n+            keys[0] = DEFAULT_REDIS_SEATA_GLOBAL_PREFIX + convertGlobalTransactionDO.getXid();\n+            keys[1] = DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX + convertGlobalTransactionDO.getTransactionId();\n+            String branchsKey = DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + convertGlobalTransactionDO.getXid();\n+            List<String> redisBranchs = jedis.lrange(branchsKey, 0, 1);\n+            if (null == redisBranchs || redisBranchs.size() <= 0) {\n+                keys[2] = branchsKey;\n+            }\n+            jedis.del(keys);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String keys = DEFAULT_REDIS_SEATA_GLOBAL_PREFIX + convertGlobalTransactionDO.getXid();\n+            jedis.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            keys = DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX + convertGlobalTransactionDO.getTransactionId();\n+            jedis.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @param withBranchSessions\n+     *            the withBranchSessions\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid, boolean withBranchSessions) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            globalSessionJson = jedis.get(DEFAULT_REDIS_SEATA_GLOBAL_PREFIX + xid);\n+            if (StringUtils.isBlank(globalSessionJson)) {\n+                return null;\n+            }\n+            // global transaction\n+            GlobalTransactionDO globalTransactionDO = JSON.parseObject(globalSessionJson, GlobalTransactionDO.class);\n+            if (globalTransactionDO == null) {\n+                return null;\n+            }\n+            // branch transactions\n+            List<BranchTransactionDO> branchTransactionDOs = null;\n+            // reduce rpc with db when branchRegister and getGlobalStatus\n+            if (withBranchSessions) {\n+                Set<String> branchJson = new HashSet<>();\n+                int start = 0;\n+                List<String> redisBranchJson = null;\n+                int stop = 100;\n+                for (;;) {\n+                    redisBranchJson = jedis.lrange(DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + globalTransactionDO.getXid(), start, stop);\n+                    if (null != redisBranchJson) {\n+                        branchJson.addAll(redisBranchJson);\n+                        start = branchJson.size();\n+                        stop = start + 100;\n+                    } else {\n+                        break;\n+                    }\n+                }\n+                if (null != branchJson && branchJson.size() > 0) {\n+                    branchTransactionDOs = new ArrayList<>();\n+                    for (String s : branchJson) {\n+                        branchTransactionDOs.add(JSON.parseObject(jedis.get(s), BranchTransactionDO.class));\n+                    }\n+                }\n+            }\n+            return getGlobalSession(globalTransactionDO, branchTransactionDOs);\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid) {\n+        return this.readSession(xid, true);\n+    }\n+\n+    /**\n+     * Read session list.\n+     *\n+     * @param statuses\n+     *            the statuses\n+     * @return the list\n+     */\n+    public List<GlobalSession> readSession(GlobalStatus[] statuses) {\n+        List<Integer> states = new ArrayList<>();\n+        for (int i = 0; i < statuses.length; i++) {\n+            states.add(statuses[i].getCode());\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Set<String> keys = new HashSet<>();\n+            String cursor = \"0\";\n+            ScanParams params = new ScanParams();\n+            params.count(100);\n+            params.match(DEFAULT_REDIS_SEATA_GLOBAL_PREFIX + \"*\");\n+            ScanResult<String> scans;\n+            do {\n+                scans = jedis.scan(cursor, params);\n+                keys.addAll(scans.getResult().stream().collect(Collectors.toSet()));\n+                cursor = scans.getCursor();\n+            } while (!cursor.equalsIgnoreCase(\"0\"));\n+            if (null != keys && keys.size() > 0) {\n+                List<GlobalTransactionDO> globalTransactionDOs = new ArrayList<>();\n+                for (String globalKey : keys) {\n+                    GlobalTransactionDO globalTransactionDO =\n+                        JSON.parseObject(jedis.get(globalKey), GlobalTransactionDO.class);\n+                    if (null != globalTransactionDO && states.contains(globalTransactionDO.getStatus())) {\n+                        globalTransactionDOs.add(globalTransactionDO);\n+                    }\n+                }\n+                if (globalTransactionDOs.size() > 0) {\n+                    List<String> xids =\n+                        globalTransactionDOs.stream().map(GlobalTransactionDO::getXid).collect(Collectors.toList());\n+                    List<BranchTransactionDO> branchTransactionDOs = new ArrayList<>();\n+                    for (String xid : xids) {\n+                        Set<String> branchs = new HashSet<>();\n+                        int start = 0;\n+                        int stop = 100;\n+                        List<String> redisBranchs = null;\n+                        for (;;) {\n+                            redisBranchs = jedis.lrange(DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + xid, start, stop);\n+                            if (null != redisBranchs) {\n+                                branchs.addAll(redisBranchs);\n+                                start = branchs.size();\n+                                stop = start + 100;\n+                            } else {\n+                                break;\n+                            }\n+                        }\n+                        if (null != branchs && branchs.size() > 0) {\n+                            for (String branchKey : branchs) {\n+                                String branchJson = jedis.get(branchKey);\n+                                if (StringUtils.isNotBlank(branchJson)) {\n+                                    branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                                }\n+                            }\n+                        }\n+                    }\n+                    Map<String, List<BranchTransactionDO>> branchTransactionDOsMap =\n+                        branchTransactionDOs.stream().collect(Collectors.groupingBy(BranchTransactionDO::getXid,\n+                            LinkedHashMap::new, Collectors.toList()));\n+                    return globalTransactionDOs.stream()\n+                        .map(globalTransactionDO -> getGlobalSession(globalTransactionDO,\n+                            branchTransactionDOsMap.get(globalTransactionDO.getXid())))\n+                        .collect(Collectors.toList());\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public List<GlobalSession> readSession(SessionCondition sessionCondition) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            if (StringUtils.isNotBlank(sessionCondition.getXid())) {\n+                globalSessionJson = jedis.get(DEFAULT_REDIS_SEATA_GLOBAL_PREFIX + sessionCondition.getXid());\n+                if (StringUtils.isNotBlank(globalSessionJson)) {\n+                    GlobalSession session =\n+                        convertGlobalSession(JSON.parseObject(globalSessionJson, GlobalTransactionDO.class));\n+                    List<GlobalSession> globalSessions = new ArrayList<>();\n+                    globalSessions.add(session);\n+                    return globalSessions;\n+                }\n+            } else if (sessionCondition.getTransactionId() != null) {\n+                String global =\n+                    jedis.get(DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX + sessionCondition.getTransactionId());\n+                if (StringUtils.isBlank(global)) {\n+                    return null;\n+                }\n+                GlobalTransactionDO globalTransactionDO = JSON.parseObject(global, GlobalTransactionDO.class);\n+                String branchsKey = DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + globalTransactionDO.getXid();\n+                Set<String> branchJson = new HashSet<>();\n+                List<String> redisBranchJson = null;\n+                int start = 0;\n+                int stop = 100;\n+                for (;;) {\n+                    redisBranchJson = jedis.lrange(branchsKey, start, stop);\n+                    if (null != redisBranchJson) {\n+                        branchJson.addAll(redisBranchJson);\n+                        start = branchJson.size();\n+                        stop = start + 100;\n+                    } else {\n+                        break;\n+                    }\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c4737498cd04bf1d73a2bdff0581cec774e4852"}, "originalPosition": 345}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA3NzExMQ==", "bodyText": "extract common method?\n\nok", "url": "https://github.com/seata/seata/pull/2484#discussion_r427077111", "createdAt": "2020-05-19T07:10:57Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,443 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO convertBranchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String branchsKey = DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + convertBranchTransactionDO.getXid();\n+            Set<String> branchs = new HashSet<>();\n+            List<String> redisBranchJson = null;\n+            int start = 0;\n+            int stop = 100;\n+            for (;;) {\n+                redisBranchJson = jedis.lrange(branchsKey, start, stop);\n+                if (null != redisBranchJson) {\n+                    branchs.addAll(redisBranchJson);\n+                    start = branchs.size();\n+                    stop = start + 100;\n+                } else {\n+                    break;\n+                }\n+            }\n+            if (null != branchs && branchs.size() > 0) {\n+                String key = DEFAULT_REDIS_SEATA_BRANCH_PREFIX + convertBranchTransactionDO.getBranchId();\n+                Iterator<String> it = branchs.iterator();\n+                while (it.hasNext()) {\n+                    String s = it.next();\n+                    if (Objects.equals(s, key)) {\n+                        it.remove();\n+                        jedis.del(key);\n+                        jedis.lrem(branchsKey, 0, key);\n+                        break;\n+                    }\n+                }\n+                if (branchs.size() == 0) {\n+                    jedis.del(branchsKey);\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO convertBranchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = DEFAULT_REDIS_SEATA_BRANCH_PREFIX + convertBranchTransactionDO.getBranchId();\n+            if (jedis.get(key) == null) {\n+                jedis.lpush(DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + convertBranchTransactionDO.getXid(), key);\n+            }\n+            jedis.set(key, JSON.toJSONString(convertBranchTransactionDO));\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String[] keys = new String[3];\n+            keys[0] = DEFAULT_REDIS_SEATA_GLOBAL_PREFIX + convertGlobalTransactionDO.getXid();\n+            keys[1] = DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX + convertGlobalTransactionDO.getTransactionId();\n+            String branchsKey = DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + convertGlobalTransactionDO.getXid();\n+            List<String> redisBranchs = jedis.lrange(branchsKey, 0, 1);\n+            if (null == redisBranchs || redisBranchs.size() <= 0) {\n+                keys[2] = branchsKey;\n+            }\n+            jedis.del(keys);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String keys = DEFAULT_REDIS_SEATA_GLOBAL_PREFIX + convertGlobalTransactionDO.getXid();\n+            jedis.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            keys = DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX + convertGlobalTransactionDO.getTransactionId();\n+            jedis.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @param withBranchSessions\n+     *            the withBranchSessions\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid, boolean withBranchSessions) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            globalSessionJson = jedis.get(DEFAULT_REDIS_SEATA_GLOBAL_PREFIX + xid);\n+            if (StringUtils.isBlank(globalSessionJson)) {\n+                return null;\n+            }\n+            // global transaction\n+            GlobalTransactionDO globalTransactionDO = JSON.parseObject(globalSessionJson, GlobalTransactionDO.class);\n+            if (globalTransactionDO == null) {\n+                return null;\n+            }\n+            // branch transactions\n+            List<BranchTransactionDO> branchTransactionDOs = null;\n+            // reduce rpc with db when branchRegister and getGlobalStatus\n+            if (withBranchSessions) {\n+                Set<String> branchJson = new HashSet<>();\n+                int start = 0;\n+                List<String> redisBranchJson = null;\n+                int stop = 100;\n+                for (;;) {\n+                    redisBranchJson = jedis.lrange(DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + globalTransactionDO.getXid(), start, stop);\n+                    if (null != redisBranchJson) {\n+                        branchJson.addAll(redisBranchJson);\n+                        start = branchJson.size();\n+                        stop = start + 100;\n+                    } else {\n+                        break;\n+                    }\n+                }\n+                if (null != branchJson && branchJson.size() > 0) {\n+                    branchTransactionDOs = new ArrayList<>();\n+                    for (String s : branchJson) {\n+                        branchTransactionDOs.add(JSON.parseObject(jedis.get(s), BranchTransactionDO.class));\n+                    }\n+                }\n+            }\n+            return getGlobalSession(globalTransactionDO, branchTransactionDOs);\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid) {\n+        return this.readSession(xid, true);\n+    }\n+\n+    /**\n+     * Read session list.\n+     *\n+     * @param statuses\n+     *            the statuses\n+     * @return the list\n+     */\n+    public List<GlobalSession> readSession(GlobalStatus[] statuses) {\n+        List<Integer> states = new ArrayList<>();\n+        for (int i = 0; i < statuses.length; i++) {\n+            states.add(statuses[i].getCode());\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Set<String> keys = new HashSet<>();\n+            String cursor = \"0\";\n+            ScanParams params = new ScanParams();\n+            params.count(100);\n+            params.match(DEFAULT_REDIS_SEATA_GLOBAL_PREFIX + \"*\");\n+            ScanResult<String> scans;\n+            do {\n+                scans = jedis.scan(cursor, params);\n+                keys.addAll(scans.getResult().stream().collect(Collectors.toSet()));\n+                cursor = scans.getCursor();\n+            } while (!cursor.equalsIgnoreCase(\"0\"));\n+            if (null != keys && keys.size() > 0) {\n+                List<GlobalTransactionDO> globalTransactionDOs = new ArrayList<>();\n+                for (String globalKey : keys) {\n+                    GlobalTransactionDO globalTransactionDO =\n+                        JSON.parseObject(jedis.get(globalKey), GlobalTransactionDO.class);\n+                    if (null != globalTransactionDO && states.contains(globalTransactionDO.getStatus())) {\n+                        globalTransactionDOs.add(globalTransactionDO);\n+                    }\n+                }\n+                if (globalTransactionDOs.size() > 0) {\n+                    List<String> xids =\n+                        globalTransactionDOs.stream().map(GlobalTransactionDO::getXid).collect(Collectors.toList());\n+                    List<BranchTransactionDO> branchTransactionDOs = new ArrayList<>();\n+                    for (String xid : xids) {\n+                        Set<String> branchs = new HashSet<>();\n+                        int start = 0;\n+                        int stop = 100;\n+                        List<String> redisBranchs = null;\n+                        for (;;) {\n+                            redisBranchs = jedis.lrange(DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + xid, start, stop);\n+                            if (null != redisBranchs) {\n+                                branchs.addAll(redisBranchs);\n+                                start = branchs.size();\n+                                stop = start + 100;\n+                            } else {\n+                                break;\n+                            }\n+                        }\n+                        if (null != branchs && branchs.size() > 0) {\n+                            for (String branchKey : branchs) {\n+                                String branchJson = jedis.get(branchKey);\n+                                if (StringUtils.isNotBlank(branchJson)) {\n+                                    branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                                }\n+                            }\n+                        }\n+                    }\n+                    Map<String, List<BranchTransactionDO>> branchTransactionDOsMap =\n+                        branchTransactionDOs.stream().collect(Collectors.groupingBy(BranchTransactionDO::getXid,\n+                            LinkedHashMap::new, Collectors.toList()));\n+                    return globalTransactionDOs.stream()\n+                        .map(globalTransactionDO -> getGlobalSession(globalTransactionDO,\n+                            branchTransactionDOsMap.get(globalTransactionDO.getXid())))\n+                        .collect(Collectors.toList());\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public List<GlobalSession> readSession(SessionCondition sessionCondition) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            if (StringUtils.isNotBlank(sessionCondition.getXid())) {\n+                globalSessionJson = jedis.get(DEFAULT_REDIS_SEATA_GLOBAL_PREFIX + sessionCondition.getXid());\n+                if (StringUtils.isNotBlank(globalSessionJson)) {\n+                    GlobalSession session =\n+                        convertGlobalSession(JSON.parseObject(globalSessionJson, GlobalTransactionDO.class));\n+                    List<GlobalSession> globalSessions = new ArrayList<>();\n+                    globalSessions.add(session);\n+                    return globalSessions;\n+                }\n+            } else if (sessionCondition.getTransactionId() != null) {\n+                String global =\n+                    jedis.get(DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX + sessionCondition.getTransactionId());\n+                if (StringUtils.isBlank(global)) {\n+                    return null;\n+                }\n+                GlobalTransactionDO globalTransactionDO = JSON.parseObject(global, GlobalTransactionDO.class);\n+                String branchsKey = DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + globalTransactionDO.getXid();\n+                Set<String> branchJson = new HashSet<>();\n+                List<String> redisBranchJson = null;\n+                int start = 0;\n+                int stop = 100;\n+                for (;;) {\n+                    redisBranchJson = jedis.lrange(branchsKey, start, stop);\n+                    if (null != redisBranchJson) {\n+                        branchJson.addAll(redisBranchJson);\n+                        start = branchJson.size();\n+                        stop = start + 100;\n+                    } else {\n+                        break;\n+                    }\n+                }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA3NDM5MA=="}, "originalCommit": {"oid": "1c4737498cd04bf1d73a2bdff0581cec774e4852"}, "originalPosition": 345}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MDI4NzY4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwOTowMToxOVrOGXWzAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwOTowMToxOVrOGXWzAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE0MzkzNg==", "bodyText": "do {} while(); ?", "url": "https://github.com/seata/seata/pull/2484#discussion_r427143936", "createdAt": "2020-05-19T09:01:19Z", "author": {"login": "jsbxyyx"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -227,4 +199,30 @@ public boolean isLockable(List<RowLock> rowLocks) {\n         return lockDOs;\n     }\n \n+    private Set<String> lRange(Jedis jedis, String Key) {\n+        Set<String> keys = new HashSet<>();\n+        List<String> redisLockJson = null;\n+        int start = 0;\n+        int stop = 100;\n+        for (;;) {\n+            redisLockJson = jedis.lrange(Key, start, stop);\n+            if (null != redisLockJson) {\n+                keys.addAll(redisLockJson);\n+                start = keys.size();\n+                stop = start + 100;\n+            } else {\n+                break;\n+            }\n+        }\n+        return keys;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3bfee07c08d436dba621627255d67f80a2a0f120"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MzY0NjcwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwMToxMzoyOVrOGX37nA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwMToxMzoyOVrOGX37nA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY4NjgxMg==", "bodyText": "do {} while(!CollectionUtils.isEmpty(redisLockJson))?", "url": "https://github.com/seata/seata/pull/2484#discussion_r427686812", "createdAt": "2020-05-20T01:13:29Z", "author": {"login": "jsbxyyx"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.lock;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.lock.AbstractLocker;\n+import io.seata.core.lock.RowLock;\n+import io.seata.core.store.LockDO;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import redis.clients.jedis.Jedis;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisLocker extends AbstractLocker {\n+\n+    private static final Integer DEFAULT_SECONDS = 30;\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_PREFIX = \"SEATA_LOCK_\";\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX = \"SEATA_LOCK_XID_\";\n+\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    /**\n+     * Instantiates a new Redis locker.\n+     *\n+     */\n+    public RedisLocker() {\n+        logQueryLimit = ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, 100);\n+    }\n+\n+    @Override\n+    public boolean acquireLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        List<String> successList = new ArrayList<>();\n+        long status = 0;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<LockDO> locks = convertToLockDO(rowLocks);\n+            for (LockDO lock : locks) {\n+                String key = getLockKey(lock.getRowKey());\n+                status = jedis.setnx(key, JSON.toJSONString(lock));\n+                if (status == 1) {\n+                    successList.add(key);\n+                    jedis.lpush(getXidLockKey(lock.getXid()), key);\n+                    jedis.expire(key, DEFAULT_SECONDS);\n+                } else {\n+                    break;\n+                }\n+            }\n+            if (status != 1) {\n+                String[] rms = successList.toArray(new String[successList.size()]);\n+                if (rms.length > 0) {\n+                    jedis.del(rms);\n+                }\n+                return false;\n+            } else {\n+                return true;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        String[] keys = new String[rowLocks.size()];\n+        List<LockDO> locks = convertToLockDO(rowLocks);\n+        for (int i = 0; i < locks.size(); i++) {\n+            String key = getLockKey(locks.get(i).getRowKey());\n+            keys[i] = key;\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            jedis.del(keys);\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(String xid, List<Long> branchIds) {\n+        if (CollectionUtils.isEmpty(branchIds)) {\n+            // no lock\n+            return true;\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String lockListKey = getXidLockKey(xid);\n+            Set<String> keys = lRange(jedis, lockListKey);\n+            if (null != keys && keys.size() > 0) {\n+                Iterator<String> it = keys.iterator();\n+                while (it.hasNext()) {\n+                    String key = it.next();\n+                    LockDO lock = JSON.parseObject(jedis.get(key), LockDO.class);\n+                    for (int i = 0; i < branchIds.size(); i++) {\n+                        if (null != lock && Objects.equals(lock.getBranchId(), branchIds.get(i))) {\n+                            jedis.del(key);\n+                            jedis.lrem(lockListKey, 0, key);\n+                            it.remove();\n+                        }\n+                    }\n+                }\n+                if (keys.size() == 0) {\n+                    jedis.del(lockListKey);\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(String xid, Long branchId) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String lockListKey = getXidLockKey(xid);\n+            Set<String> keys = lRange(jedis, lockListKey);\n+            if (null != keys && keys.size() > 0) {\n+                Iterator<String> it = keys.iterator();\n+                while (it.hasNext()) {\n+                    String key = it.next();\n+                    LockDO lock = JSON.parseObject(jedis.get(key), LockDO.class);\n+                    if (null != lock && Objects.equals(branchId, lock.getBranchId())) {\n+                        jedis.del(key);\n+                        jedis.lrem(lockListKey, 0, key);\n+                        it.remove();\n+                    }\n+                }\n+                if (keys.size() == 0) {\n+                    jedis.del(lockListKey);\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public boolean isLockable(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<LockDO> locks = convertToLockDO(rowLocks);\n+            for (LockDO rowlock : locks) {\n+                String rowlockJson = jedis.get(getLockKey(rowlock.getRowKey()));\n+                if (StringUtils.isNotBlank(rowlockJson)) {\n+                    LockDO lock = JSON.parseObject(rowlockJson, LockDO.class);\n+                    if (null != lock && !Objects.equals(lock.getXid(), rowlock.getXid())) {\n+                        return false;\n+                    }\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Convert to lock do list.\n+     *\n+     * @param locks\n+     *            the locks\n+     * @return the list\n+     */\n+    protected List<LockDO> convertToLockDO(List<RowLock> locks) {\n+        List<LockDO> lockDOs = new ArrayList<>();\n+        if (CollectionUtils.isEmpty(locks)) {\n+            return lockDOs;\n+        }\n+        for (RowLock rowLock : locks) {\n+            LockDO lockDO = new LockDO();\n+            lockDO.setBranchId(rowLock.getBranchId());\n+            lockDO.setPk(rowLock.getPk());\n+            lockDO.setResourceId(rowLock.getResourceId());\n+            lockDO.setRowKey(getRowKey(rowLock.getResourceId(), rowLock.getTableName(), rowLock.getPk()));\n+            lockDO.setXid(rowLock.getXid());\n+            lockDO.setTransactionId(rowLock.getTransactionId());\n+            lockDO.setTableName(rowLock.getTableName());\n+            lockDOs.add(lockDO);\n+        }\n+        return lockDOs;\n+    }\n+\n+    private Set<String> lRange(Jedis jedis, String key) {\n+        Set<String> keys = new HashSet<>();\n+        List<String> redisLockJson;\n+        int start = 0;\n+        int stop = logQueryLimit;\n+        for (;;) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "233e6f5238ec40b612df955cba1fc0ae6978ec0b"}, "originalPosition": 218}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MzY0ODc4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwMToxNDo1OFrOGX38-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwMTo1ODo0NFrOGX4q9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY4NzE2Mg==", "bodyText": "do {} while(!CollectionUtils.isEmpty(redisBranchJson)) ?", "url": "https://github.com/seata/seata/pull/2484#discussion_r427687162", "createdAt": "2020-05-20T01:14:58Z", "author": {"login": "jsbxyyx"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,436 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    private static final String INITIAL_CURSOR = \"0\";\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    public RedisTransactionStoreManager() {\n+        logQueryLimit = ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, 100);\n+    }\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO convertBranchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String branchesKey = getBranchListKeyByXid(convertBranchTransactionDO.getXid());\n+            Set<String> keys = lRange(jedis, branchesKey);\n+            if (null != keys && keys.size() > 0) {\n+                String key = getBranchKey(convertBranchTransactionDO.getBranchId());\n+                Iterator<String> it = keys.iterator();\n+                while (it.hasNext()) {\n+                    String s = it.next();\n+                    if (Objects.equals(s, key)) {\n+                        it.remove();\n+                        jedis.del(key);\n+                        jedis.lrem(branchesKey, 0, key);\n+                        break;\n+                    }\n+                }\n+                if (keys.size() == 0) {\n+                    jedis.del(branchesKey);\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO convertBranchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(convertBranchTransactionDO.getBranchId());\n+            if (jedis.get(key) == null) {\n+                jedis.lpush(getBranchListKeyByXid(convertBranchTransactionDO.getXid()), key);\n+            }\n+            jedis.set(key, JSON.toJSONString(convertBranchTransactionDO));\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String[] keys = new String[3];\n+            keys[0] = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n+            keys[1] = getGlobalKeyByTransactionId(convertGlobalTransactionDO.getTransactionId());\n+            String branchesKey = getBranchListKeyByXid(convertGlobalTransactionDO.getXid());\n+            List<String> redisBranches = jedis.lrange(branchesKey, 0, 1);\n+            if (null == redisBranches || redisBranches.size() <= 0) {\n+                keys[2] = branchesKey;\n+            }\n+            jedis.del(keys);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String keys = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n+            jedis.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            keys = getGlobalKeyByTransactionId(convertGlobalTransactionDO.getTransactionId());\n+            jedis.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @param withBranchSessions\n+     *            the withBranchSessions\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid, boolean withBranchSessions) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            globalSessionJson = jedis.get(getGlobalKeyByXid(xid));\n+            if (StringUtils.isBlank(globalSessionJson)) {\n+                return null;\n+            }\n+            // global transaction\n+            GlobalTransactionDO globalTransactionDO = JSON.parseObject(globalSessionJson, GlobalTransactionDO.class);\n+            if (globalTransactionDO == null) {\n+                return null;\n+            }\n+            // branch transactions\n+            List<BranchTransactionDO> branchTransactionDOs = null;\n+            // reduce rpc with db when branchRegister and getGlobalStatus\n+            if (withBranchSessions) {\n+                Set<String> keys = lRange(jedis, getBranchListKeyByXid(globalTransactionDO.getXid()));\n+                if (null != keys && keys.size() > 0) {\n+                    branchTransactionDOs = new ArrayList<>();\n+                    for (String s : keys) {\n+                        branchTransactionDOs.add(JSON.parseObject(jedis.get(s), BranchTransactionDO.class));\n+                    }\n+                }\n+            }\n+            return getGlobalSession(globalTransactionDO, branchTransactionDOs);\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid) {\n+        return this.readSession(xid, true);\n+    }\n+\n+    /**\n+     * Read session list.\n+     *\n+     * @param statuses\n+     *            the statuses\n+     * @return the list\n+     */\n+    public List<GlobalSession> readSession(GlobalStatus[] statuses) {\n+        List<Integer> states = new ArrayList<>();\n+        for (int i = 0; i < statuses.length; i++) {\n+            states.add(statuses[i].getCode());\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Set<String> keys = new HashSet<>();\n+            String cursor = INITIAL_CURSOR;\n+            ScanParams params = new ScanParams();\n+            params.count(logQueryLimit);\n+            params.match(getGlobalKeyByXid(\"*\"));\n+            ScanResult<String> scans;\n+            do {\n+                scans = jedis.scan(cursor, params);\n+                keys.addAll(scans.getResult().stream().collect(Collectors.toSet()));\n+                cursor = scans.getCursor();\n+            } while (!cursor.equalsIgnoreCase(INITIAL_CURSOR));\n+            if (null != keys && keys.size() > 0) {\n+                List<GlobalTransactionDO> globalTransactionDOs = new ArrayList<>();\n+                for (String globalKey : keys) {\n+                    GlobalTransactionDO globalTransactionDO =\n+                        JSON.parseObject(jedis.get(globalKey), GlobalTransactionDO.class);\n+                    if (null != globalTransactionDO && states.contains(globalTransactionDO.getStatus())) {\n+                        globalTransactionDOs.add(globalTransactionDO);\n+                    }\n+                }\n+                if (globalTransactionDOs.size() > 0) {\n+                    List<String> xids =\n+                        globalTransactionDOs.stream().map(GlobalTransactionDO::getXid).collect(Collectors.toList());\n+                    List<BranchTransactionDO> branchTransactionDOs = new ArrayList<>();\n+                    for (String xid : xids) {\n+                        Set<String> branches = lRange(jedis, getBranchListKeyByXid(xid));\n+                        if (null != branches && branches.size() > 0) {\n+                            for (String branchKey : branches) {\n+                                String branchJson = jedis.get(branchKey);\n+                                if (StringUtils.isNotBlank(branchJson)) {\n+                                    branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                                }\n+                            }\n+                        }\n+                    }\n+                    Map<String, List<BranchTransactionDO>> branchTransactionDOsMap =\n+                        branchTransactionDOs.stream().collect(Collectors.groupingBy(BranchTransactionDO::getXid,\n+                            LinkedHashMap::new, Collectors.toList()));\n+                    return globalTransactionDOs.stream()\n+                        .map(globalTransactionDO -> getGlobalSession(globalTransactionDO,\n+                            branchTransactionDOsMap.get(globalTransactionDO.getXid())))\n+                        .collect(Collectors.toList());\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public List<GlobalSession> readSession(SessionCondition sessionCondition) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            if (StringUtils.isNotBlank(sessionCondition.getXid())) {\n+                globalSessionJson = jedis.get(getGlobalKeyByXid(sessionCondition.getXid()));\n+                if (StringUtils.isNotBlank(globalSessionJson)) {\n+                    GlobalSession session =\n+                        convertGlobalSession(JSON.parseObject(globalSessionJson, GlobalTransactionDO.class));\n+                    List<GlobalSession> globalSessions = new ArrayList<>();\n+                    globalSessions.add(session);\n+                    return globalSessions;\n+                }\n+            } else if (sessionCondition.getTransactionId() != null) {\n+                String global = jedis.get(getGlobalKeyByTransactionId(sessionCondition.getTransactionId()));\n+                if (StringUtils.isBlank(global)) {\n+                    return null;\n+                }\n+                GlobalTransactionDO globalTransactionDO = JSON.parseObject(global, GlobalTransactionDO.class);\n+                String branchKey = getBranchListKeyByXid(globalTransactionDO.getXid());\n+                Set<String> keys = lRange(jedis, branchKey);\n+                List<BranchTransactionDO> branchTransactionDOS = new ArrayList<>();\n+                if (null != keys && keys.size() > 0) {\n+                    for (String s : keys) {\n+                        branchTransactionDOS.add(JSON.parseObject(jedis.get(s), BranchTransactionDO.class));\n+                    }\n+                    GlobalSession globalSession = getGlobalSession(globalTransactionDO, branchTransactionDOS);\n+                    if (globalSession != null) {\n+                        List<GlobalSession> globalSessions = new ArrayList<>();\n+                        globalSessions.add(globalSession);\n+                        return globalSessions;\n+                    }\n+                }\n+            } else if (CollectionUtils.isNotEmpty(sessionCondition.getStatuses())) {\n+                return readSession(sessionCondition.getStatuses());\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private GlobalTransactionDO convertGlobalTransactionDO(SessionStorable session) {\n+        if (session == null || !(session instanceof GlobalSession)) {\n+            throw new IllegalArgumentException(\n+                \"the parameter of SessionStorable is not available, SessionStorable:\" + StringUtils.toString(session));\n+        }\n+        GlobalSession globalSession = (GlobalSession)session;\n+\n+        GlobalTransactionDO globalTransactionDO = new GlobalTransactionDO();\n+        globalTransactionDO.setXid(globalSession.getXid());\n+        globalTransactionDO.setStatus(globalSession.getStatus().getCode());\n+        globalTransactionDO.setApplicationId(globalSession.getApplicationId());\n+        globalTransactionDO.setBeginTime(globalSession.getBeginTime());\n+        globalTransactionDO.setTimeout(globalSession.getTimeout());\n+        globalTransactionDO.setTransactionId(globalSession.getTransactionId());\n+        globalTransactionDO.setTransactionName(globalSession.getTransactionName());\n+        globalTransactionDO.setTransactionServiceGroup(globalSession.getTransactionServiceGroup());\n+        globalTransactionDO.setApplicationData(globalSession.getApplicationData());\n+        return globalTransactionDO;\n+    }\n+\n+    private BranchTransactionDO convertBranchTransactionDO(SessionStorable session) {\n+        if (session == null || !(session instanceof BranchSession)) {\n+            throw new IllegalArgumentException(\n+                \"the parameter of SessionStorable is not available, SessionStorable:\" + StringUtils.toString(session));\n+        }\n+        BranchSession branchSession = (BranchSession)session;\n+\n+        BranchTransactionDO branchTransactionDO = new BranchTransactionDO();\n+        branchTransactionDO.setXid(branchSession.getXid());\n+        branchTransactionDO.setBranchId(branchSession.getBranchId());\n+        branchTransactionDO.setBranchType(branchSession.getBranchType().name());\n+        branchTransactionDO.setClientId(branchSession.getClientId());\n+        branchTransactionDO.setResourceGroupId(branchSession.getResourceGroupId());\n+        branchTransactionDO.setTransactionId(branchSession.getTransactionId());\n+        branchTransactionDO.setApplicationData(branchSession.getApplicationData());\n+        branchTransactionDO.setResourceId(branchSession.getResourceId());\n+        branchTransactionDO.setStatus(branchSession.getStatus().getCode());\n+        return branchTransactionDO;\n+    }\n+\n+    private GlobalSession convertGlobalSession(GlobalTransactionDO globalTransactionDO) {\n+        GlobalSession session =\n+            new GlobalSession(globalTransactionDO.getApplicationId(), globalTransactionDO.getTransactionServiceGroup(),\n+                globalTransactionDO.getTransactionName(), globalTransactionDO.getTimeout());\n+        session.setTransactionId(globalTransactionDO.getTransactionId());\n+        session.setXid(globalTransactionDO.getXid());\n+        session.setStatus(GlobalStatus.get(globalTransactionDO.getStatus()));\n+        session.setApplicationData(globalTransactionDO.getApplicationData());\n+        session.setBeginTime(globalTransactionDO.getBeginTime());\n+        return session;\n+    }\n+\n+    private BranchSession convertBranchSession(BranchTransactionDO branchTransactionDO) {\n+        BranchSession branchSession = new BranchSession();\n+        branchSession.setXid(branchTransactionDO.getXid());\n+        branchSession.setTransactionId(branchTransactionDO.getTransactionId());\n+        branchSession.setApplicationData(branchTransactionDO.getApplicationData());\n+        branchSession.setBranchId(branchTransactionDO.getBranchId());\n+        branchSession.setBranchType(BranchType.valueOf(branchTransactionDO.getBranchType()));\n+        branchSession.setResourceId(branchTransactionDO.getResourceId());\n+        branchSession.setClientId(branchTransactionDO.getClientId());\n+        branchSession.setResourceGroupId(branchTransactionDO.getResourceGroupId());\n+        branchSession.setStatus(BranchStatus.get(branchTransactionDO.getStatus()));\n+        return branchSession;\n+    }\n+\n+    private GlobalSession getGlobalSession(GlobalTransactionDO globalTransactionDO,\n+        List<BranchTransactionDO> branchTransactionDOs) {\n+        GlobalSession globalSession = convertGlobalSession(globalTransactionDO);\n+        // branch transactions\n+        if (branchTransactionDOs != null && branchTransactionDOs.size() > 0) {\n+            for (BranchTransactionDO branchTransactionDO : branchTransactionDOs) {\n+                globalSession.add(convertBranchSession(branchTransactionDO));\n+            }\n+        }\n+        return globalSession;\n+    }\n+\n+    private Set<String> lRange(Jedis jedis, String key) {\n+        Set<String> keys = new HashSet<>();\n+        List<String> redisBranchJson;\n+        int start = 0;\n+        int stop = logQueryLimit;\n+        for (;;) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "233e6f5238ec40b612df955cba1fc0ae6978ec0b"}, "originalPosition": 407}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY5ODkzNA==", "bodyText": "ok", "url": "https://github.com/seata/seata/pull/2484#discussion_r427698934", "createdAt": "2020-05-20T01:58:44Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,436 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    private static final String INITIAL_CURSOR = \"0\";\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    public RedisTransactionStoreManager() {\n+        logQueryLimit = ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, 100);\n+    }\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO convertBranchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String branchesKey = getBranchListKeyByXid(convertBranchTransactionDO.getXid());\n+            Set<String> keys = lRange(jedis, branchesKey);\n+            if (null != keys && keys.size() > 0) {\n+                String key = getBranchKey(convertBranchTransactionDO.getBranchId());\n+                Iterator<String> it = keys.iterator();\n+                while (it.hasNext()) {\n+                    String s = it.next();\n+                    if (Objects.equals(s, key)) {\n+                        it.remove();\n+                        jedis.del(key);\n+                        jedis.lrem(branchesKey, 0, key);\n+                        break;\n+                    }\n+                }\n+                if (keys.size() == 0) {\n+                    jedis.del(branchesKey);\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO convertBranchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(convertBranchTransactionDO.getBranchId());\n+            if (jedis.get(key) == null) {\n+                jedis.lpush(getBranchListKeyByXid(convertBranchTransactionDO.getXid()), key);\n+            }\n+            jedis.set(key, JSON.toJSONString(convertBranchTransactionDO));\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String[] keys = new String[3];\n+            keys[0] = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n+            keys[1] = getGlobalKeyByTransactionId(convertGlobalTransactionDO.getTransactionId());\n+            String branchesKey = getBranchListKeyByXid(convertGlobalTransactionDO.getXid());\n+            List<String> redisBranches = jedis.lrange(branchesKey, 0, 1);\n+            if (null == redisBranches || redisBranches.size() <= 0) {\n+                keys[2] = branchesKey;\n+            }\n+            jedis.del(keys);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String keys = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n+            jedis.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            keys = getGlobalKeyByTransactionId(convertGlobalTransactionDO.getTransactionId());\n+            jedis.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @param withBranchSessions\n+     *            the withBranchSessions\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid, boolean withBranchSessions) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            globalSessionJson = jedis.get(getGlobalKeyByXid(xid));\n+            if (StringUtils.isBlank(globalSessionJson)) {\n+                return null;\n+            }\n+            // global transaction\n+            GlobalTransactionDO globalTransactionDO = JSON.parseObject(globalSessionJson, GlobalTransactionDO.class);\n+            if (globalTransactionDO == null) {\n+                return null;\n+            }\n+            // branch transactions\n+            List<BranchTransactionDO> branchTransactionDOs = null;\n+            // reduce rpc with db when branchRegister and getGlobalStatus\n+            if (withBranchSessions) {\n+                Set<String> keys = lRange(jedis, getBranchListKeyByXid(globalTransactionDO.getXid()));\n+                if (null != keys && keys.size() > 0) {\n+                    branchTransactionDOs = new ArrayList<>();\n+                    for (String s : keys) {\n+                        branchTransactionDOs.add(JSON.parseObject(jedis.get(s), BranchTransactionDO.class));\n+                    }\n+                }\n+            }\n+            return getGlobalSession(globalTransactionDO, branchTransactionDOs);\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid) {\n+        return this.readSession(xid, true);\n+    }\n+\n+    /**\n+     * Read session list.\n+     *\n+     * @param statuses\n+     *            the statuses\n+     * @return the list\n+     */\n+    public List<GlobalSession> readSession(GlobalStatus[] statuses) {\n+        List<Integer> states = new ArrayList<>();\n+        for (int i = 0; i < statuses.length; i++) {\n+            states.add(statuses[i].getCode());\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Set<String> keys = new HashSet<>();\n+            String cursor = INITIAL_CURSOR;\n+            ScanParams params = new ScanParams();\n+            params.count(logQueryLimit);\n+            params.match(getGlobalKeyByXid(\"*\"));\n+            ScanResult<String> scans;\n+            do {\n+                scans = jedis.scan(cursor, params);\n+                keys.addAll(scans.getResult().stream().collect(Collectors.toSet()));\n+                cursor = scans.getCursor();\n+            } while (!cursor.equalsIgnoreCase(INITIAL_CURSOR));\n+            if (null != keys && keys.size() > 0) {\n+                List<GlobalTransactionDO> globalTransactionDOs = new ArrayList<>();\n+                for (String globalKey : keys) {\n+                    GlobalTransactionDO globalTransactionDO =\n+                        JSON.parseObject(jedis.get(globalKey), GlobalTransactionDO.class);\n+                    if (null != globalTransactionDO && states.contains(globalTransactionDO.getStatus())) {\n+                        globalTransactionDOs.add(globalTransactionDO);\n+                    }\n+                }\n+                if (globalTransactionDOs.size() > 0) {\n+                    List<String> xids =\n+                        globalTransactionDOs.stream().map(GlobalTransactionDO::getXid).collect(Collectors.toList());\n+                    List<BranchTransactionDO> branchTransactionDOs = new ArrayList<>();\n+                    for (String xid : xids) {\n+                        Set<String> branches = lRange(jedis, getBranchListKeyByXid(xid));\n+                        if (null != branches && branches.size() > 0) {\n+                            for (String branchKey : branches) {\n+                                String branchJson = jedis.get(branchKey);\n+                                if (StringUtils.isNotBlank(branchJson)) {\n+                                    branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                                }\n+                            }\n+                        }\n+                    }\n+                    Map<String, List<BranchTransactionDO>> branchTransactionDOsMap =\n+                        branchTransactionDOs.stream().collect(Collectors.groupingBy(BranchTransactionDO::getXid,\n+                            LinkedHashMap::new, Collectors.toList()));\n+                    return globalTransactionDOs.stream()\n+                        .map(globalTransactionDO -> getGlobalSession(globalTransactionDO,\n+                            branchTransactionDOsMap.get(globalTransactionDO.getXid())))\n+                        .collect(Collectors.toList());\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public List<GlobalSession> readSession(SessionCondition sessionCondition) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            if (StringUtils.isNotBlank(sessionCondition.getXid())) {\n+                globalSessionJson = jedis.get(getGlobalKeyByXid(sessionCondition.getXid()));\n+                if (StringUtils.isNotBlank(globalSessionJson)) {\n+                    GlobalSession session =\n+                        convertGlobalSession(JSON.parseObject(globalSessionJson, GlobalTransactionDO.class));\n+                    List<GlobalSession> globalSessions = new ArrayList<>();\n+                    globalSessions.add(session);\n+                    return globalSessions;\n+                }\n+            } else if (sessionCondition.getTransactionId() != null) {\n+                String global = jedis.get(getGlobalKeyByTransactionId(sessionCondition.getTransactionId()));\n+                if (StringUtils.isBlank(global)) {\n+                    return null;\n+                }\n+                GlobalTransactionDO globalTransactionDO = JSON.parseObject(global, GlobalTransactionDO.class);\n+                String branchKey = getBranchListKeyByXid(globalTransactionDO.getXid());\n+                Set<String> keys = lRange(jedis, branchKey);\n+                List<BranchTransactionDO> branchTransactionDOS = new ArrayList<>();\n+                if (null != keys && keys.size() > 0) {\n+                    for (String s : keys) {\n+                        branchTransactionDOS.add(JSON.parseObject(jedis.get(s), BranchTransactionDO.class));\n+                    }\n+                    GlobalSession globalSession = getGlobalSession(globalTransactionDO, branchTransactionDOS);\n+                    if (globalSession != null) {\n+                        List<GlobalSession> globalSessions = new ArrayList<>();\n+                        globalSessions.add(globalSession);\n+                        return globalSessions;\n+                    }\n+                }\n+            } else if (CollectionUtils.isNotEmpty(sessionCondition.getStatuses())) {\n+                return readSession(sessionCondition.getStatuses());\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private GlobalTransactionDO convertGlobalTransactionDO(SessionStorable session) {\n+        if (session == null || !(session instanceof GlobalSession)) {\n+            throw new IllegalArgumentException(\n+                \"the parameter of SessionStorable is not available, SessionStorable:\" + StringUtils.toString(session));\n+        }\n+        GlobalSession globalSession = (GlobalSession)session;\n+\n+        GlobalTransactionDO globalTransactionDO = new GlobalTransactionDO();\n+        globalTransactionDO.setXid(globalSession.getXid());\n+        globalTransactionDO.setStatus(globalSession.getStatus().getCode());\n+        globalTransactionDO.setApplicationId(globalSession.getApplicationId());\n+        globalTransactionDO.setBeginTime(globalSession.getBeginTime());\n+        globalTransactionDO.setTimeout(globalSession.getTimeout());\n+        globalTransactionDO.setTransactionId(globalSession.getTransactionId());\n+        globalTransactionDO.setTransactionName(globalSession.getTransactionName());\n+        globalTransactionDO.setTransactionServiceGroup(globalSession.getTransactionServiceGroup());\n+        globalTransactionDO.setApplicationData(globalSession.getApplicationData());\n+        return globalTransactionDO;\n+    }\n+\n+    private BranchTransactionDO convertBranchTransactionDO(SessionStorable session) {\n+        if (session == null || !(session instanceof BranchSession)) {\n+            throw new IllegalArgumentException(\n+                \"the parameter of SessionStorable is not available, SessionStorable:\" + StringUtils.toString(session));\n+        }\n+        BranchSession branchSession = (BranchSession)session;\n+\n+        BranchTransactionDO branchTransactionDO = new BranchTransactionDO();\n+        branchTransactionDO.setXid(branchSession.getXid());\n+        branchTransactionDO.setBranchId(branchSession.getBranchId());\n+        branchTransactionDO.setBranchType(branchSession.getBranchType().name());\n+        branchTransactionDO.setClientId(branchSession.getClientId());\n+        branchTransactionDO.setResourceGroupId(branchSession.getResourceGroupId());\n+        branchTransactionDO.setTransactionId(branchSession.getTransactionId());\n+        branchTransactionDO.setApplicationData(branchSession.getApplicationData());\n+        branchTransactionDO.setResourceId(branchSession.getResourceId());\n+        branchTransactionDO.setStatus(branchSession.getStatus().getCode());\n+        return branchTransactionDO;\n+    }\n+\n+    private GlobalSession convertGlobalSession(GlobalTransactionDO globalTransactionDO) {\n+        GlobalSession session =\n+            new GlobalSession(globalTransactionDO.getApplicationId(), globalTransactionDO.getTransactionServiceGroup(),\n+                globalTransactionDO.getTransactionName(), globalTransactionDO.getTimeout());\n+        session.setTransactionId(globalTransactionDO.getTransactionId());\n+        session.setXid(globalTransactionDO.getXid());\n+        session.setStatus(GlobalStatus.get(globalTransactionDO.getStatus()));\n+        session.setApplicationData(globalTransactionDO.getApplicationData());\n+        session.setBeginTime(globalTransactionDO.getBeginTime());\n+        return session;\n+    }\n+\n+    private BranchSession convertBranchSession(BranchTransactionDO branchTransactionDO) {\n+        BranchSession branchSession = new BranchSession();\n+        branchSession.setXid(branchTransactionDO.getXid());\n+        branchSession.setTransactionId(branchTransactionDO.getTransactionId());\n+        branchSession.setApplicationData(branchTransactionDO.getApplicationData());\n+        branchSession.setBranchId(branchTransactionDO.getBranchId());\n+        branchSession.setBranchType(BranchType.valueOf(branchTransactionDO.getBranchType()));\n+        branchSession.setResourceId(branchTransactionDO.getResourceId());\n+        branchSession.setClientId(branchTransactionDO.getClientId());\n+        branchSession.setResourceGroupId(branchTransactionDO.getResourceGroupId());\n+        branchSession.setStatus(BranchStatus.get(branchTransactionDO.getStatus()));\n+        return branchSession;\n+    }\n+\n+    private GlobalSession getGlobalSession(GlobalTransactionDO globalTransactionDO,\n+        List<BranchTransactionDO> branchTransactionDOs) {\n+        GlobalSession globalSession = convertGlobalSession(globalTransactionDO);\n+        // branch transactions\n+        if (branchTransactionDOs != null && branchTransactionDOs.size() > 0) {\n+            for (BranchTransactionDO branchTransactionDO : branchTransactionDOs) {\n+                globalSession.add(convertBranchSession(branchTransactionDO));\n+            }\n+        }\n+        return globalSession;\n+    }\n+\n+    private Set<String> lRange(Jedis jedis, String key) {\n+        Set<String> keys = new HashSet<>();\n+        List<String> redisBranchJson;\n+        int start = 0;\n+        int stop = logQueryLimit;\n+        for (;;) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY4NzE2Mg=="}, "originalCommit": {"oid": "233e6f5238ec40b612df955cba1fc0ae6978ec0b"}, "originalPosition": 407}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MzY1MDExOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwMToxNTo1MlrOGX39yA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwMTo1ODo0MFrOGX4q4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY4NzM2OA==", "bodyText": "defaultValue define constant?", "url": "https://github.com/seata/seata/pull/2484#discussion_r427687368", "createdAt": "2020-05-20T01:15:52Z", "author": {"login": "jsbxyyx"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.lock;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.lock.AbstractLocker;\n+import io.seata.core.lock.RowLock;\n+import io.seata.core.store.LockDO;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import redis.clients.jedis.Jedis;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisLocker extends AbstractLocker {\n+\n+    private static final Integer DEFAULT_SECONDS = 30;\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_PREFIX = \"SEATA_LOCK_\";\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX = \"SEATA_LOCK_XID_\";\n+\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    /**\n+     * Instantiates a new Redis locker.\n+     *\n+     */\n+    public RedisLocker() {\n+        logQueryLimit = ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, 100);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "233e6f5238ec40b612df955cba1fc0ae6978ec0b"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY5ODkxMw==", "bodyText": "ok", "url": "https://github.com/seata/seata/pull/2484#discussion_r427698913", "createdAt": "2020-05-20T01:58:40Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.lock;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.lock.AbstractLocker;\n+import io.seata.core.lock.RowLock;\n+import io.seata.core.store.LockDO;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import redis.clients.jedis.Jedis;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisLocker extends AbstractLocker {\n+\n+    private static final Integer DEFAULT_SECONDS = 30;\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_PREFIX = \"SEATA_LOCK_\";\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX = \"SEATA_LOCK_XID_\";\n+\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    /**\n+     * Instantiates a new Redis locker.\n+     *\n+     */\n+    public RedisLocker() {\n+        logQueryLimit = ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, 100);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY4NzM2OA=="}, "originalCommit": {"oid": "233e6f5238ec40b612df955cba1fc0ae6978ec0b"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MzY2NTAyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwMToyNDo0N1rOGX4G1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwMTo1OTo1MlrOGX4sHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY4OTY4NQ==", "bodyText": "like db distinct by rowkey?", "url": "https://github.com/seata/seata/pull/2484#discussion_r427689685", "createdAt": "2020-05-20T01:24:47Z", "author": {"login": "jsbxyyx"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.lock;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.lock.AbstractLocker;\n+import io.seata.core.lock.RowLock;\n+import io.seata.core.store.LockDO;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import redis.clients.jedis.Jedis;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisLocker extends AbstractLocker {\n+\n+    private static final Integer DEFAULT_SECONDS = 30;\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_PREFIX = \"SEATA_LOCK_\";\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX = \"SEATA_LOCK_XID_\";\n+\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    /**\n+     * Instantiates a new Redis locker.\n+     *\n+     */\n+    public RedisLocker() {\n+        logQueryLimit = ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, 100);\n+    }\n+\n+    @Override\n+    public boolean acquireLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        List<String> successList = new ArrayList<>();\n+        long status = 0;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<LockDO> locks = convertToLockDO(rowLocks);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "233e6f5238ec40b612df955cba1fc0ae6978ec0b"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY5OTIzMQ==", "bodyText": "like db distinct by rowkey?\n\ni do not quite understand you", "url": "https://github.com/seata/seata/pull/2484#discussion_r427699231", "createdAt": "2020-05-20T01:59:52Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.lock;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.lock.AbstractLocker;\n+import io.seata.core.lock.RowLock;\n+import io.seata.core.store.LockDO;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import redis.clients.jedis.Jedis;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisLocker extends AbstractLocker {\n+\n+    private static final Integer DEFAULT_SECONDS = 30;\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_PREFIX = \"SEATA_LOCK_\";\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX = \"SEATA_LOCK_XID_\";\n+\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    /**\n+     * Instantiates a new Redis locker.\n+     *\n+     */\n+    public RedisLocker() {\n+        logQueryLimit = ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, 100);\n+    }\n+\n+    @Override\n+    public boolean acquireLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        List<String> successList = new ArrayList<>();\n+        long status = 0;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<LockDO> locks = convertToLockDO(rowLocks);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY4OTY4NQ=="}, "originalCommit": {"oid": "233e6f5238ec40b612df955cba1fc0ae6978ec0b"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NDQ4MjA2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwODowOToyN1rOGYACbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwODoyNTo1MlrOGYApzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgxOTYyOA==", "bodyText": "break?", "url": "https://github.com/seata/seata/pull/2484#discussion_r427819628", "createdAt": "2020-05-20T08:09:27Z", "author": {"login": "jsbxyyx"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -0,0 +1,256 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.lock;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.LambdaUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.lock.AbstractLocker;\n+import io.seata.core.lock.RowLock;\n+import io.seata.core.store.LockDO;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisLocker extends AbstractLocker {\n+\n+    private static final Integer DEFAULT_SECONDS = 30;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_PREFIX = \"SEATA_LOCK_\";\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX = \"SEATA_LOCK_XID_\";\n+\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    /**\n+     * Instantiates a new Redis locker.\n+     *\n+     */\n+    public RedisLocker() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    @Override\n+    public boolean acquireLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        List<String> successList = new ArrayList<>();\n+        long status = 1;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<LockDO> locks = convertToLockDO(rowLocks);\n+            if (locks.size() > 1) {\n+                locks =\n+                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            }\n+            Pipeline pipeline = jedis.pipelined();\n+            for (LockDO lock : locks) {\n+                String key = getLockKey(lock.getRowKey());\n+                pipeline.setnx(key, JSON.toJSONString(lock));\n+            }\n+            List<Object> results = pipeline.syncAndReturnAll();\n+            for (int i = 0; i < results.size(); i++) {\n+                Long result = (long)results.get(i);\n+                String key = getLockKey(locks.get(i).getRowKey());\n+                if (result != 1) {\n+                    status = result;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e9e7572cf863c8df368885f692ed08e109e0305"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgyNTY1NQ==", "bodyText": "break?\n\nmeed to record the successfully inserted key", "url": "https://github.com/seata/seata/pull/2484#discussion_r427825655", "createdAt": "2020-05-20T08:19:25Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -0,0 +1,256 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.lock;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.LambdaUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.lock.AbstractLocker;\n+import io.seata.core.lock.RowLock;\n+import io.seata.core.store.LockDO;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisLocker extends AbstractLocker {\n+\n+    private static final Integer DEFAULT_SECONDS = 30;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_PREFIX = \"SEATA_LOCK_\";\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX = \"SEATA_LOCK_XID_\";\n+\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    /**\n+     * Instantiates a new Redis locker.\n+     *\n+     */\n+    public RedisLocker() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    @Override\n+    public boolean acquireLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        List<String> successList = new ArrayList<>();\n+        long status = 1;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<LockDO> locks = convertToLockDO(rowLocks);\n+            if (locks.size() > 1) {\n+                locks =\n+                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            }\n+            Pipeline pipeline = jedis.pipelined();\n+            for (LockDO lock : locks) {\n+                String key = getLockKey(lock.getRowKey());\n+                pipeline.setnx(key, JSON.toJSONString(lock));\n+            }\n+            List<Object> results = pipeline.syncAndReturnAll();\n+            for (int i = 0; i < results.size(); i++) {\n+                Long result = (long)results.get(i);\n+                String key = getLockKey(locks.get(i).getRowKey());\n+                if (result != 1) {\n+                    status = result;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgxOTYyOA=="}, "originalCommit": {"oid": "3e9e7572cf863c8df368885f692ed08e109e0305"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgyOTcwOQ==", "bodyText": "my fault", "url": "https://github.com/seata/seata/pull/2484#discussion_r427829709", "createdAt": "2020-05-20T08:25:52Z", "author": {"login": "jsbxyyx"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -0,0 +1,256 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.lock;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.LambdaUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.lock.AbstractLocker;\n+import io.seata.core.lock.RowLock;\n+import io.seata.core.store.LockDO;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisLocker extends AbstractLocker {\n+\n+    private static final Integer DEFAULT_SECONDS = 30;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_PREFIX = \"SEATA_LOCK_\";\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX = \"SEATA_LOCK_XID_\";\n+\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    /**\n+     * Instantiates a new Redis locker.\n+     *\n+     */\n+    public RedisLocker() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    @Override\n+    public boolean acquireLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        List<String> successList = new ArrayList<>();\n+        long status = 1;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<LockDO> locks = convertToLockDO(rowLocks);\n+            if (locks.size() > 1) {\n+                locks =\n+                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            }\n+            Pipeline pipeline = jedis.pipelined();\n+            for (LockDO lock : locks) {\n+                String key = getLockKey(lock.getRowKey());\n+                pipeline.setnx(key, JSON.toJSONString(lock));\n+            }\n+            List<Object> results = pipeline.syncAndReturnAll();\n+            for (int i = 0; i < results.size(); i++) {\n+                Long result = (long)results.get(i);\n+                String key = getLockKey(locks.get(i).getRowKey());\n+                if (result != 1) {\n+                    status = result;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgxOTYyOA=="}, "originalCommit": {"oid": "3e9e7572cf863c8df368885f692ed08e109e0305"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NDQ4NTUwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwODoxMDoyM1rOGYAEgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwODoxOTo0N1rOGYAaxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgyMDE2Mg==", "bodyText": "judge result if success?", "url": "https://github.com/seata/seata/pull/2484#discussion_r427820162", "createdAt": "2020-05-20T08:10:23Z", "author": {"login": "jsbxyyx"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -0,0 +1,256 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.lock;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.LambdaUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.lock.AbstractLocker;\n+import io.seata.core.lock.RowLock;\n+import io.seata.core.store.LockDO;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisLocker extends AbstractLocker {\n+\n+    private static final Integer DEFAULT_SECONDS = 30;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_PREFIX = \"SEATA_LOCK_\";\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX = \"SEATA_LOCK_XID_\";\n+\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    /**\n+     * Instantiates a new Redis locker.\n+     *\n+     */\n+    public RedisLocker() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    @Override\n+    public boolean acquireLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        List<String> successList = new ArrayList<>();\n+        long status = 1;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<LockDO> locks = convertToLockDO(rowLocks);\n+            if (locks.size() > 1) {\n+                locks =\n+                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            }\n+            Pipeline pipeline = jedis.pipelined();\n+            for (LockDO lock : locks) {\n+                String key = getLockKey(lock.getRowKey());\n+                pipeline.setnx(key, JSON.toJSONString(lock));\n+            }\n+            List<Object> results = pipeline.syncAndReturnAll();\n+            for (int i = 0; i < results.size(); i++) {\n+                Long result = (long)results.get(i);\n+                String key = getLockKey(locks.get(i).getRowKey());\n+                if (result != 1) {\n+                    status = result;\n+                } else {\n+                    successList.add(key);\n+                }\n+            }\n+            if (status != 1) {\n+                String[] rms = successList.toArray(new String[successList.size()]);\n+                if (rms.length > 0) {\n+                    jedis.del(rms);\n+                }\n+                return false;\n+            } else {\n+                for (LockDO lock : locks) {\n+                    pipeline = jedis.pipelined();\n+                    String key = getLockKey(lock.getRowKey());\n+                    pipeline.lpush(getXidLockKey(lock.getXid()), key);\n+                    pipeline.expire(key, DEFAULT_SECONDS);\n+                }\n+                pipeline.syncAndReturnAll();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e9e7572cf863c8df368885f692ed08e109e0305"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgyNTg2Mg==", "bodyText": "judge result if success?\n\nok", "url": "https://github.com/seata/seata/pull/2484#discussion_r427825862", "createdAt": "2020-05-20T08:19:47Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -0,0 +1,256 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.lock;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.LambdaUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.lock.AbstractLocker;\n+import io.seata.core.lock.RowLock;\n+import io.seata.core.store.LockDO;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisLocker extends AbstractLocker {\n+\n+    private static final Integer DEFAULT_SECONDS = 30;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_PREFIX = \"SEATA_LOCK_\";\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX = \"SEATA_LOCK_XID_\";\n+\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    /**\n+     * Instantiates a new Redis locker.\n+     *\n+     */\n+    public RedisLocker() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    @Override\n+    public boolean acquireLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        List<String> successList = new ArrayList<>();\n+        long status = 1;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<LockDO> locks = convertToLockDO(rowLocks);\n+            if (locks.size() > 1) {\n+                locks =\n+                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            }\n+            Pipeline pipeline = jedis.pipelined();\n+            for (LockDO lock : locks) {\n+                String key = getLockKey(lock.getRowKey());\n+                pipeline.setnx(key, JSON.toJSONString(lock));\n+            }\n+            List<Object> results = pipeline.syncAndReturnAll();\n+            for (int i = 0; i < results.size(); i++) {\n+                Long result = (long)results.get(i);\n+                String key = getLockKey(locks.get(i).getRowKey());\n+                if (result != 1) {\n+                    status = result;\n+                } else {\n+                    successList.add(key);\n+                }\n+            }\n+            if (status != 1) {\n+                String[] rms = successList.toArray(new String[successList.size()]);\n+                if (rms.length > 0) {\n+                    jedis.del(rms);\n+                }\n+                return false;\n+            } else {\n+                for (LockDO lock : locks) {\n+                    pipeline = jedis.pipelined();\n+                    String key = getLockKey(lock.getRowKey());\n+                    pipeline.lpush(getXidLockKey(lock.getXid()), key);\n+                    pipeline.expire(key, DEFAULT_SECONDS);\n+                }\n+                pipeline.syncAndReturnAll();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgyMDE2Mg=="}, "originalCommit": {"oid": "3e9e7572cf863c8df368885f692ed08e109e0305"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NDQ5MDYwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwODoxMTo1MFrOGYAHtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwODoyMzo0MlrOGYAkdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgyMDk4Mg==", "bodyText": "call releaseLock(String xid, List branchIds)??", "url": "https://github.com/seata/seata/pull/2484#discussion_r427820982", "createdAt": "2020-05-20T08:11:50Z", "author": {"login": "jsbxyyx"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -0,0 +1,256 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.lock;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.LambdaUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.lock.AbstractLocker;\n+import io.seata.core.lock.RowLock;\n+import io.seata.core.store.LockDO;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisLocker extends AbstractLocker {\n+\n+    private static final Integer DEFAULT_SECONDS = 30;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_PREFIX = \"SEATA_LOCK_\";\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX = \"SEATA_LOCK_XID_\";\n+\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    /**\n+     * Instantiates a new Redis locker.\n+     *\n+     */\n+    public RedisLocker() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    @Override\n+    public boolean acquireLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        List<String> successList = new ArrayList<>();\n+        long status = 1;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<LockDO> locks = convertToLockDO(rowLocks);\n+            if (locks.size() > 1) {\n+                locks =\n+                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            }\n+            Pipeline pipeline = jedis.pipelined();\n+            for (LockDO lock : locks) {\n+                String key = getLockKey(lock.getRowKey());\n+                pipeline.setnx(key, JSON.toJSONString(lock));\n+            }\n+            List<Object> results = pipeline.syncAndReturnAll();\n+            for (int i = 0; i < results.size(); i++) {\n+                Long result = (long)results.get(i);\n+                String key = getLockKey(locks.get(i).getRowKey());\n+                if (result != 1) {\n+                    status = result;\n+                } else {\n+                    successList.add(key);\n+                }\n+            }\n+            if (status != 1) {\n+                String[] rms = successList.toArray(new String[successList.size()]);\n+                if (rms.length > 0) {\n+                    jedis.del(rms);\n+                }\n+                return false;\n+            } else {\n+                for (LockDO lock : locks) {\n+                    pipeline = jedis.pipelined();\n+                    String key = getLockKey(lock.getRowKey());\n+                    pipeline.lpush(getXidLockKey(lock.getXid()), key);\n+                    pipeline.expire(key, DEFAULT_SECONDS);\n+                }\n+                pipeline.syncAndReturnAll();\n+                return true;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        String[] keys = new String[rowLocks.size()];\n+        List<LockDO> locks = convertToLockDO(rowLocks);\n+        for (int i = 0; i < locks.size(); i++) {\n+            String key = getLockKey(locks.get(i).getRowKey());\n+            keys[i] = key;\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            jedis.del(keys);\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(String xid, List<Long> branchIds) {\n+        if (CollectionUtils.isEmpty(branchIds)) {\n+            // no lock\n+            return true;\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String lockListKey = getXidLockKey(xid);\n+            Set<String> keys = lRange(jedis, lockListKey);\n+            if (CollectionUtils.isNotEmpty(keys)) {\n+                Iterator<String> it = keys.iterator();\n+                while (it.hasNext()) {\n+                    String key = it.next();\n+                    LockDO lock = JSON.parseObject(jedis.get(key), LockDO.class);\n+                    for (int i = 0; i < branchIds.size(); i++) {\n+                        if (null != lock && Objects.equals(lock.getBranchId(), branchIds.get(i))) {\n+                            jedis.del(key);\n+                            jedis.lrem(lockListKey, 0, key);\n+                            it.remove();\n+                        }\n+                    }\n+                }\n+                if (keys.size() == 0) {\n+                    jedis.del(lockListKey);\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(String xid, Long branchId) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String lockListKey = getXidLockKey(xid);\n+            Set<String> keys = lRange(jedis, lockListKey);\n+            if (CollectionUtils.isNotEmpty(keys)) {\n+                Iterator<String> it = keys.iterator();\n+                while (it.hasNext()) {\n+                    String key = it.next();\n+                    LockDO lock = JSON.parseObject(jedis.get(key), LockDO.class);\n+                    if (null != lock && Objects.equals(branchId, lock.getBranchId())) {\n+                        jedis.del(key);\n+                        jedis.lrem(lockListKey, 0, key);\n+                        it.remove();\n+                    }\n+                }\n+                if (keys.size() == 0) {\n+                    jedis.del(lockListKey);\n+                }\n+            }\n+            return true;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e9e7572cf863c8df368885f692ed08e109e0305"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgyODM0Mw==", "bodyText": "ok", "url": "https://github.com/seata/seata/pull/2484#discussion_r427828343", "createdAt": "2020-05-20T08:23:42Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -0,0 +1,256 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.lock;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.LambdaUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.lock.AbstractLocker;\n+import io.seata.core.lock.RowLock;\n+import io.seata.core.store.LockDO;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisLocker extends AbstractLocker {\n+\n+    private static final Integer DEFAULT_SECONDS = 30;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_PREFIX = \"SEATA_LOCK_\";\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX = \"SEATA_LOCK_XID_\";\n+\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    /**\n+     * Instantiates a new Redis locker.\n+     *\n+     */\n+    public RedisLocker() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    @Override\n+    public boolean acquireLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        List<String> successList = new ArrayList<>();\n+        long status = 1;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<LockDO> locks = convertToLockDO(rowLocks);\n+            if (locks.size() > 1) {\n+                locks =\n+                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            }\n+            Pipeline pipeline = jedis.pipelined();\n+            for (LockDO lock : locks) {\n+                String key = getLockKey(lock.getRowKey());\n+                pipeline.setnx(key, JSON.toJSONString(lock));\n+            }\n+            List<Object> results = pipeline.syncAndReturnAll();\n+            for (int i = 0; i < results.size(); i++) {\n+                Long result = (long)results.get(i);\n+                String key = getLockKey(locks.get(i).getRowKey());\n+                if (result != 1) {\n+                    status = result;\n+                } else {\n+                    successList.add(key);\n+                }\n+            }\n+            if (status != 1) {\n+                String[] rms = successList.toArray(new String[successList.size()]);\n+                if (rms.length > 0) {\n+                    jedis.del(rms);\n+                }\n+                return false;\n+            } else {\n+                for (LockDO lock : locks) {\n+                    pipeline = jedis.pipelined();\n+                    String key = getLockKey(lock.getRowKey());\n+                    pipeline.lpush(getXidLockKey(lock.getXid()), key);\n+                    pipeline.expire(key, DEFAULT_SECONDS);\n+                }\n+                pipeline.syncAndReturnAll();\n+                return true;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        String[] keys = new String[rowLocks.size()];\n+        List<LockDO> locks = convertToLockDO(rowLocks);\n+        for (int i = 0; i < locks.size(); i++) {\n+            String key = getLockKey(locks.get(i).getRowKey());\n+            keys[i] = key;\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            jedis.del(keys);\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(String xid, List<Long> branchIds) {\n+        if (CollectionUtils.isEmpty(branchIds)) {\n+            // no lock\n+            return true;\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String lockListKey = getXidLockKey(xid);\n+            Set<String> keys = lRange(jedis, lockListKey);\n+            if (CollectionUtils.isNotEmpty(keys)) {\n+                Iterator<String> it = keys.iterator();\n+                while (it.hasNext()) {\n+                    String key = it.next();\n+                    LockDO lock = JSON.parseObject(jedis.get(key), LockDO.class);\n+                    for (int i = 0; i < branchIds.size(); i++) {\n+                        if (null != lock && Objects.equals(lock.getBranchId(), branchIds.get(i))) {\n+                            jedis.del(key);\n+                            jedis.lrem(lockListKey, 0, key);\n+                            it.remove();\n+                        }\n+                    }\n+                }\n+                if (keys.size() == 0) {\n+                    jedis.del(lockListKey);\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(String xid, Long branchId) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String lockListKey = getXidLockKey(xid);\n+            Set<String> keys = lRange(jedis, lockListKey);\n+            if (CollectionUtils.isNotEmpty(keys)) {\n+                Iterator<String> it = keys.iterator();\n+                while (it.hasNext()) {\n+                    String key = it.next();\n+                    LockDO lock = JSON.parseObject(jedis.get(key), LockDO.class);\n+                    if (null != lock && Objects.equals(branchId, lock.getBranchId())) {\n+                        jedis.del(key);\n+                        jedis.lrem(lockListKey, 0, key);\n+                        it.remove();\n+                    }\n+                }\n+                if (keys.size() == 0) {\n+                    jedis.del(lockListKey);\n+                }\n+            }\n+            return true;\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgyMDk4Mg=="}, "originalCommit": {"oid": "3e9e7572cf863c8df368885f692ed08e109e0305"}, "originalPosition": 184}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NDQ5Njg2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwODoxMzoyN1rOGYALkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwODoyNjo0NFrOGYAr0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgyMTk3MA==", "bodyText": "equalsIgnoreCase to equals ?", "url": "https://github.com/seata/seata/pull/2484#discussion_r427821970", "createdAt": "2020-05-20T08:13:27Z", "author": {"login": "jsbxyyx"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,440 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String INITIAL_CURSOR = \"0\";\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    public RedisTransactionStoreManager() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO convertBranchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String branchesKey = getBranchListKeyByXid(convertBranchTransactionDO.getXid());\n+            Set<String> keys = lRange(jedis, branchesKey);\n+            if (CollectionUtils.isNotEmpty(keys)) {\n+                String key = getBranchKey(convertBranchTransactionDO.getBranchId());\n+                Iterator<String> it = keys.iterator();\n+                while (it.hasNext()) {\n+                    String s = it.next();\n+                    if (Objects.equals(s, key)) {\n+                        it.remove();\n+                        jedis.del(key);\n+                        jedis.lrem(branchesKey, 0, key);\n+                        break;\n+                    }\n+                }\n+                if (keys.size() == 0) {\n+                    jedis.del(branchesKey);\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO convertBranchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(convertBranchTransactionDO.getBranchId());\n+            Pipeline pipeline = jedis.pipelined();\n+            if (jedis.get(key) == null) {\n+                pipeline.lpush(getBranchListKeyByXid(convertBranchTransactionDO.getXid()), key);\n+            }\n+            pipeline.set(key, JSON.toJSONString(convertBranchTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String[] keys = new String[3];\n+            keys[0] = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n+            keys[1] = getGlobalKeyByTransactionId(convertGlobalTransactionDO.getTransactionId());\n+            String branchesKey = getBranchListKeyByXid(convertGlobalTransactionDO.getXid());\n+            List<String> redisBranches = jedis.lrange(branchesKey, 0, 1);\n+            if (null == redisBranches || redisBranches.size() <= 0) {\n+                keys[2] = branchesKey;\n+            }\n+            jedis.del(keys);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String keys = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n+            Pipeline pipeline = jedis.pipelined();\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            keys = getGlobalKeyByTransactionId(convertGlobalTransactionDO.getTransactionId());\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @param withBranchSessions\n+     *            the withBranchSessions\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid, boolean withBranchSessions) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            globalSessionJson = jedis.get(getGlobalKeyByXid(xid));\n+            if (StringUtils.isBlank(globalSessionJson)) {\n+                return null;\n+            }\n+            // global transaction\n+            GlobalTransactionDO globalTransactionDO = JSON.parseObject(globalSessionJson, GlobalTransactionDO.class);\n+            if (globalTransactionDO == null) {\n+                return null;\n+            }\n+            // branch transactions\n+            List<BranchTransactionDO> branchTransactionDOs = null;\n+            // reduce rpc with db when branchRegister and getGlobalStatus\n+            if (withBranchSessions) {\n+                Set<String> keys = lRange(jedis, getBranchListKeyByXid(globalTransactionDO.getXid()));\n+                if (CollectionUtils.isNotEmpty(keys)) {\n+                    branchTransactionDOs = new ArrayList<>();\n+                    for (String s : keys) {\n+                        branchTransactionDOs.add(JSON.parseObject(jedis.get(s), BranchTransactionDO.class));\n+                    }\n+                }\n+            }\n+            return getGlobalSession(globalTransactionDO, branchTransactionDOs);\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid) {\n+        return this.readSession(xid, true);\n+    }\n+\n+    /**\n+     * Read session list.\n+     *\n+     * @param statuses\n+     *            the statuses\n+     * @return the list\n+     */\n+    public List<GlobalSession> readSession(GlobalStatus[] statuses) {\n+        List<Integer> states = new ArrayList<>();\n+        for (int i = 0; i < statuses.length; i++) {\n+            states.add(statuses[i].getCode());\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Set<String> keys = new HashSet<>();\n+            String cursor = INITIAL_CURSOR;\n+            ScanParams params = new ScanParams();\n+            params.count(logQueryLimit);\n+            params.match(getGlobalKeyByXid(\"*\"));\n+            ScanResult<String> scans;\n+            do {\n+                scans = jedis.scan(cursor, params);\n+                keys.addAll(scans.getResult().stream().collect(Collectors.toSet()));\n+                cursor = scans.getCursor();\n+            } while (!INITIAL_CURSOR.equalsIgnoreCase(cursor));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e9e7572cf863c8df368885f692ed08e109e0305"}, "originalPosition": 254}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgzMDIyNA==", "bodyText": "ok", "url": "https://github.com/seata/seata/pull/2484#discussion_r427830224", "createdAt": "2020-05-20T08:26:44Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,440 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String INITIAL_CURSOR = \"0\";\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    public RedisTransactionStoreManager() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO convertBranchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String branchesKey = getBranchListKeyByXid(convertBranchTransactionDO.getXid());\n+            Set<String> keys = lRange(jedis, branchesKey);\n+            if (CollectionUtils.isNotEmpty(keys)) {\n+                String key = getBranchKey(convertBranchTransactionDO.getBranchId());\n+                Iterator<String> it = keys.iterator();\n+                while (it.hasNext()) {\n+                    String s = it.next();\n+                    if (Objects.equals(s, key)) {\n+                        it.remove();\n+                        jedis.del(key);\n+                        jedis.lrem(branchesKey, 0, key);\n+                        break;\n+                    }\n+                }\n+                if (keys.size() == 0) {\n+                    jedis.del(branchesKey);\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO convertBranchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(convertBranchTransactionDO.getBranchId());\n+            Pipeline pipeline = jedis.pipelined();\n+            if (jedis.get(key) == null) {\n+                pipeline.lpush(getBranchListKeyByXid(convertBranchTransactionDO.getXid()), key);\n+            }\n+            pipeline.set(key, JSON.toJSONString(convertBranchTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String[] keys = new String[3];\n+            keys[0] = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n+            keys[1] = getGlobalKeyByTransactionId(convertGlobalTransactionDO.getTransactionId());\n+            String branchesKey = getBranchListKeyByXid(convertGlobalTransactionDO.getXid());\n+            List<String> redisBranches = jedis.lrange(branchesKey, 0, 1);\n+            if (null == redisBranches || redisBranches.size() <= 0) {\n+                keys[2] = branchesKey;\n+            }\n+            jedis.del(keys);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String keys = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n+            Pipeline pipeline = jedis.pipelined();\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            keys = getGlobalKeyByTransactionId(convertGlobalTransactionDO.getTransactionId());\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @param withBranchSessions\n+     *            the withBranchSessions\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid, boolean withBranchSessions) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            globalSessionJson = jedis.get(getGlobalKeyByXid(xid));\n+            if (StringUtils.isBlank(globalSessionJson)) {\n+                return null;\n+            }\n+            // global transaction\n+            GlobalTransactionDO globalTransactionDO = JSON.parseObject(globalSessionJson, GlobalTransactionDO.class);\n+            if (globalTransactionDO == null) {\n+                return null;\n+            }\n+            // branch transactions\n+            List<BranchTransactionDO> branchTransactionDOs = null;\n+            // reduce rpc with db when branchRegister and getGlobalStatus\n+            if (withBranchSessions) {\n+                Set<String> keys = lRange(jedis, getBranchListKeyByXid(globalTransactionDO.getXid()));\n+                if (CollectionUtils.isNotEmpty(keys)) {\n+                    branchTransactionDOs = new ArrayList<>();\n+                    for (String s : keys) {\n+                        branchTransactionDOs.add(JSON.parseObject(jedis.get(s), BranchTransactionDO.class));\n+                    }\n+                }\n+            }\n+            return getGlobalSession(globalTransactionDO, branchTransactionDOs);\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid) {\n+        return this.readSession(xid, true);\n+    }\n+\n+    /**\n+     * Read session list.\n+     *\n+     * @param statuses\n+     *            the statuses\n+     * @return the list\n+     */\n+    public List<GlobalSession> readSession(GlobalStatus[] statuses) {\n+        List<Integer> states = new ArrayList<>();\n+        for (int i = 0; i < statuses.length; i++) {\n+            states.add(statuses[i].getCode());\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Set<String> keys = new HashSet<>();\n+            String cursor = INITIAL_CURSOR;\n+            ScanParams params = new ScanParams();\n+            params.count(logQueryLimit);\n+            params.match(getGlobalKeyByXid(\"*\"));\n+            ScanResult<String> scans;\n+            do {\n+                scans = jedis.scan(cursor, params);\n+                keys.addAll(scans.getResult().stream().collect(Collectors.toSet()));\n+                cursor = scans.getCursor();\n+            } while (!INITIAL_CURSOR.equalsIgnoreCase(cursor));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgyMTk3MA=="}, "originalCommit": {"oid": "3e9e7572cf863c8df368885f692ed08e109e0305"}, "originalPosition": 254}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2ODQ4NDQwOnYy", "diffSide": "RIGHT", "path": "server/src/test/java/io/seata/server/lock/redis/RedisLockManagerTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwNjoxNjoyMlrOGYnduA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwOTozOTo0M1rOGYsonw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2NTU5Mg==", "bodyText": "directly throws Exception for test?", "url": "https://github.com/seata/seata/pull/2484#discussion_r428465592", "createdAt": "2020-05-21T06:16:22Z", "author": {"login": "jsbxyyx"}, "path": "server/src/test/java/io/seata/server/lock/redis/RedisLockManagerTest.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package io.seata.server.lock.redis;\n+\n+import java.io.IOException;\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+import com.github.fppt.jedismock.RedisServer;\n+\n+import io.seata.core.exception.TransactionException;\n+import io.seata.core.lock.Locker;\n+import io.seata.server.lock.LockManager;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.storage.file.lock.FileLockManager;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.storage.redis.lock.RedisLocker;\n+import redis.clients.jedis.JedisPool;\n+import redis.clients.jedis.JedisPoolConfig;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisLockManagerTest {\n+    static RedisServer server = null;\n+    static LockManager lockManager = null;\n+\n+    @BeforeAll\n+    public static void start() {\n+        try {\n+            server = RedisServer.newRedisServer(6789);\n+            server.start();\n+        } catch (IOException e) {\n+            e.printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f8d82e1db1bcf49818c5f819eda3f8304ae1195"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODU1MDMwMw==", "bodyText": "ok", "url": "https://github.com/seata/seata/pull/2484#discussion_r428550303", "createdAt": "2020-05-21T09:39:43Z", "author": {"login": "a364176773"}, "path": "server/src/test/java/io/seata/server/lock/redis/RedisLockManagerTest.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package io.seata.server.lock.redis;\n+\n+import java.io.IOException;\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+import com.github.fppt.jedismock.RedisServer;\n+\n+import io.seata.core.exception.TransactionException;\n+import io.seata.core.lock.Locker;\n+import io.seata.server.lock.LockManager;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.storage.file.lock.FileLockManager;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.storage.redis.lock.RedisLocker;\n+import redis.clients.jedis.JedisPool;\n+import redis.clients.jedis.JedisPoolConfig;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisLockManagerTest {\n+    static RedisServer server = null;\n+    static LockManager lockManager = null;\n+\n+    @BeforeAll\n+    public static void start() {\n+        try {\n+            server = RedisServer.newRedisServer(6789);\n+            server.start();\n+        } catch (IOException e) {\n+            e.printStackTrace();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2NTU5Mg=="}, "originalCommit": {"oid": "6f8d82e1db1bcf49818c5f819eda3f8304ae1195"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2ODQ4NTI3OnYy", "diffSide": "RIGHT", "path": "server/src/test/java/io/seata/server/session/redis/RedisSeesionManagerTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwNjoxNjo0MVrOGYneOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwOTozOTo1MFrOGYso2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2NTcyMg==", "bodyText": "directly throws exception for test?", "url": "https://github.com/seata/seata/pull/2484#discussion_r428465722", "createdAt": "2020-05-21T06:16:41Z", "author": {"login": "jsbxyyx"}, "path": "server/src/test/java/io/seata/server/session/redis/RedisSeesionManagerTest.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package io.seata.server.session.redis;\n+\n+import java.io.IOException;\n+import com.github.fppt.jedismock.RedisServer;\n+import io.seata.common.XID;\n+import io.seata.core.exception.TransactionException;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.server.UUIDGenerator;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionManager;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.storage.redis.session.RedisSessionManager;\n+import io.seata.server.storage.redis.store.RedisTransactionStoreManager;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import redis.clients.jedis.JedisPool;\n+import redis.clients.jedis.JedisPoolConfig;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisSeesionManagerTest {\n+    private static RedisServer server = null;\n+    private static SessionManager sessionManager = null;\n+\n+    @BeforeAll\n+    public static void start() {\n+        try {\n+            server = RedisServer.newRedisServer(6789);\n+            server.start();\n+        } catch (IOException e) {\n+            e.printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f8d82e1db1bcf49818c5f819eda3f8304ae1195"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODU1MDM2Mw==", "bodyText": "ok", "url": "https://github.com/seata/seata/pull/2484#discussion_r428550363", "createdAt": "2020-05-21T09:39:50Z", "author": {"login": "a364176773"}, "path": "server/src/test/java/io/seata/server/session/redis/RedisSeesionManagerTest.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package io.seata.server.session.redis;\n+\n+import java.io.IOException;\n+import com.github.fppt.jedismock.RedisServer;\n+import io.seata.common.XID;\n+import io.seata.core.exception.TransactionException;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.server.UUIDGenerator;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionManager;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.storage.redis.session.RedisSessionManager;\n+import io.seata.server.storage.redis.store.RedisTransactionStoreManager;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import redis.clients.jedis.JedisPool;\n+import redis.clients.jedis.JedisPoolConfig;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisSeesionManagerTest {\n+    private static RedisServer server = null;\n+    private static SessionManager sessionManager = null;\n+\n+    @BeforeAll\n+    public static void start() {\n+        try {\n+            server = RedisServer.newRedisServer(6789);\n+            server.start();\n+        } catch (IOException e) {\n+            e.printStackTrace();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2NTcyMg=="}, "originalCommit": {"oid": "6f8d82e1db1bcf49818c5f819eda3f8304ae1195"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NTk2MzIxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQxMzowNDo0MFrOGcydvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQxMzowNDo0MFrOGcydvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg0MDEyNw==", "bodyText": "private constructor, logQueryLimit assignment can be put on it", "url": "https://github.com/seata/seata/pull/2484#discussion_r432840127", "createdAt": "2020-05-30T13:04:40Z", "author": {"login": "ph3636"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import com.alibaba.fastjson.JSON;\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String INITIAL_CURSOR = \"0\";\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    public RedisTransactionStoreManager() {\n+        logQueryLimit =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NTk2MzkwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQxMzowNTozNlrOGcyeEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQxMzowNTozNlrOGcyeEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg0MDIxMA==", "bodyText": "Is array better", "url": "https://github.com/seata/seata/pull/2484#discussion_r432840210", "createdAt": "2020-05-30T13:05:36Z", "author": {"login": "ph3636"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import com.alibaba.fastjson.JSON;\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String INITIAL_CURSOR = \"0\";\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    public RedisTransactionStoreManager() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            jedis.del(key);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            Pipeline pipeline = jedis.pipelined();\n+            if (jedis.get(key) == null) {\n+                pipeline.lpush(getBranchListKeyByXid(branchTransactionDO.getXid()), key);\n+            }\n+            pipeline.set(key, JSON.toJSONString(branchTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<String> keys = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 136}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NTk2NDMyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQxMzowNjo0M1rOGcyeTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMVQwNToxMzo0OVrOGc2xJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg0MDI3MQ==", "bodyText": "Convert JSON once", "url": "https://github.com/seata/seata/pull/2484#discussion_r432840271", "createdAt": "2020-05-30T13:06:43Z", "author": {"login": "ph3636"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import com.alibaba.fastjson.JSON;\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String INITIAL_CURSOR = \"0\";\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    public RedisTransactionStoreManager() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            jedis.del(key);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            Pipeline pipeline = jedis.pipelined();\n+            if (jedis.get(key) == null) {\n+                pipeline.lpush(getBranchListKeyByXid(branchTransactionDO.getXid()), key);\n+            }\n+            pipeline.set(key, JSON.toJSONString(branchTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<String> keys = new ArrayList<>();\n+            keys.add(getGlobalKeyByXid(globalTransactionDO.getXid()));\n+            keys.add(getGlobalKeyByTransactionId(globalTransactionDO.getTransactionId()));\n+            keys.add(getBranchListKeyByXid(globalTransactionDO.getXid()));\n+            jedis.del(keys.toArray(new String[keys.size()]));\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String keys = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n+            Pipeline pipeline = jedis.pipelined();\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3MTU2NQ==", "bodyText": "Convert JSON once\n\nwhat is the purpose of this", "url": "https://github.com/seata/seata/pull/2484#discussion_r432871565", "createdAt": "2020-05-30T17:19:52Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import com.alibaba.fastjson.JSON;\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String INITIAL_CURSOR = \"0\";\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    public RedisTransactionStoreManager() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            jedis.del(key);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            Pipeline pipeline = jedis.pipelined();\n+            if (jedis.get(key) == null) {\n+                pipeline.lpush(getBranchListKeyByXid(branchTransactionDO.getXid()), key);\n+            }\n+            pipeline.set(key, JSON.toJSONString(branchTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<String> keys = new ArrayList<>();\n+            keys.add(getGlobalKeyByXid(globalTransactionDO.getXid()));\n+            keys.add(getGlobalKeyByTransactionId(globalTransactionDO.getTransactionId()));\n+            keys.add(getBranchListKeyByXid(globalTransactionDO.getXid()));\n+            jedis.del(keys.toArray(new String[keys.size()]));\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String keys = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n+            Pipeline pipeline = jedis.pipelined();\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg0MDI3MQ=="}, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkxMDYzMQ==", "bodyText": "This object has been converted to JSON twice", "url": "https://github.com/seata/seata/pull/2484#discussion_r432910631", "createdAt": "2020-05-31T05:13:49Z", "author": {"login": "ph3636"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import com.alibaba.fastjson.JSON;\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String INITIAL_CURSOR = \"0\";\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    public RedisTransactionStoreManager() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            jedis.del(key);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            Pipeline pipeline = jedis.pipelined();\n+            if (jedis.get(key) == null) {\n+                pipeline.lpush(getBranchListKeyByXid(branchTransactionDO.getXid()), key);\n+            }\n+            pipeline.set(key, JSON.toJSONString(branchTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<String> keys = new ArrayList<>();\n+            keys.add(getGlobalKeyByXid(globalTransactionDO.getXid()));\n+            keys.add(getGlobalKeyByTransactionId(globalTransactionDO.getTransactionId()));\n+            keys.add(getBranchListKeyByXid(globalTransactionDO.getXid()));\n+            jedis.del(keys.toArray(new String[keys.size()]));\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String keys = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n+            Pipeline pipeline = jedis.pipelined();\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg0MDI3MQ=="}, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 149}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NTk2NTYxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQxMzowOTowMFrOGcye8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQxNzoyMTo1OVrOGc0ZIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg0MDQzMg==", "bodyText": "Judge whether it is empty", "url": "https://github.com/seata/seata/pull/2484#discussion_r432840432", "createdAt": "2020-05-30T13:09:00Z", "author": {"login": "ph3636"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import com.alibaba.fastjson.JSON;\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String INITIAL_CURSOR = \"0\";\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    public RedisTransactionStoreManager() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            jedis.del(key);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            Pipeline pipeline = jedis.pipelined();\n+            if (jedis.get(key) == null) {\n+                pipeline.lpush(getBranchListKeyByXid(branchTransactionDO.getXid()), key);\n+            }\n+            pipeline.set(key, JSON.toJSONString(branchTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<String> keys = new ArrayList<>();\n+            keys.add(getGlobalKeyByXid(globalTransactionDO.getXid()));\n+            keys.add(getGlobalKeyByTransactionId(globalTransactionDO.getTransactionId()));\n+            keys.add(getBranchListKeyByXid(globalTransactionDO.getXid()));\n+            jedis.del(keys.toArray(new String[keys.size()]));\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String keys = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n+            Pipeline pipeline = jedis.pipelined();\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            keys = getGlobalKeyByTransactionId(convertGlobalTransactionDO.getTransactionId());\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @param withBranchSessions\n+     *            the withBranchSessions\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid, boolean withBranchSessions) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            globalSessionJson = jedis.get(getGlobalKeyByXid(xid));\n+            if (StringUtils.isBlank(globalSessionJson)) {\n+                return null;\n+            }\n+            // global transaction\n+            GlobalTransactionDO globalTransactionDO = JSON.parseObject(globalSessionJson, GlobalTransactionDO.class);\n+            if (globalTransactionDO == null) {\n+                return null;\n+            }\n+            // branch transactions\n+            List<BranchTransactionDO> branchTransactionDOs = null;\n+            // reduce rpc with db when branchRegister and getGlobalStatus\n+            if (withBranchSessions) {\n+                Set<String> keys = lRange(jedis, getBranchListKeyByXid(globalTransactionDO.getXid()));\n+                if (CollectionUtils.isNotEmpty(keys)) {\n+                    branchTransactionDOs = new ArrayList<>();\n+                    for (String s : keys) {\n+                        String branchJson = jedis.get(s);\n+                        if (StringUtils.isNotBlank(branchJson)) {\n+                            branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3MTcxMg==", "bodyText": "Judge whether it is empty\n\nok", "url": "https://github.com/seata/seata/pull/2484#discussion_r432871712", "createdAt": "2020-05-30T17:21:59Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import com.alibaba.fastjson.JSON;\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String INITIAL_CURSOR = \"0\";\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    public RedisTransactionStoreManager() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            jedis.del(key);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            Pipeline pipeline = jedis.pipelined();\n+            if (jedis.get(key) == null) {\n+                pipeline.lpush(getBranchListKeyByXid(branchTransactionDO.getXid()), key);\n+            }\n+            pipeline.set(key, JSON.toJSONString(branchTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<String> keys = new ArrayList<>();\n+            keys.add(getGlobalKeyByXid(globalTransactionDO.getXid()));\n+            keys.add(getGlobalKeyByTransactionId(globalTransactionDO.getTransactionId()));\n+            keys.add(getBranchListKeyByXid(globalTransactionDO.getXid()));\n+            jedis.del(keys.toArray(new String[keys.size()]));\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String keys = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n+            Pipeline pipeline = jedis.pipelined();\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            keys = getGlobalKeyByTransactionId(convertGlobalTransactionDO.getTransactionId());\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @param withBranchSessions\n+     *            the withBranchSessions\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid, boolean withBranchSessions) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            globalSessionJson = jedis.get(getGlobalKeyByXid(xid));\n+            if (StringUtils.isBlank(globalSessionJson)) {\n+                return null;\n+            }\n+            // global transaction\n+            GlobalTransactionDO globalTransactionDO = JSON.parseObject(globalSessionJson, GlobalTransactionDO.class);\n+            if (globalTransactionDO == null) {\n+                return null;\n+            }\n+            // branch transactions\n+            List<BranchTransactionDO> branchTransactionDOs = null;\n+            // reduce rpc with db when branchRegister and getGlobalStatus\n+            if (withBranchSessions) {\n+                Set<String> keys = lRange(jedis, getBranchListKeyByXid(globalTransactionDO.getXid()));\n+                if (CollectionUtils.isNotEmpty(keys)) {\n+                    branchTransactionDOs = new ArrayList<>();\n+                    for (String s : keys) {\n+                        String branchJson = jedis.get(s);\n+                        if (StringUtils.isNotBlank(branchJson)) {\n+                            branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg0MDQzMg=="}, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 189}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NTk2ODgxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQxMzoxNDo1NFrOGcygmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMVQxMjozODozNVrOGc4vHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg0MDg1OQ==", "bodyText": "Judge whether it is empty", "url": "https://github.com/seata/seata/pull/2484#discussion_r432840859", "createdAt": "2020-05-30T13:14:54Z", "author": {"login": "ph3636"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import com.alibaba.fastjson.JSON;\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String INITIAL_CURSOR = \"0\";\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    public RedisTransactionStoreManager() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            jedis.del(key);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            Pipeline pipeline = jedis.pipelined();\n+            if (jedis.get(key) == null) {\n+                pipeline.lpush(getBranchListKeyByXid(branchTransactionDO.getXid()), key);\n+            }\n+            pipeline.set(key, JSON.toJSONString(branchTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<String> keys = new ArrayList<>();\n+            keys.add(getGlobalKeyByXid(globalTransactionDO.getXid()));\n+            keys.add(getGlobalKeyByTransactionId(globalTransactionDO.getTransactionId()));\n+            keys.add(getBranchListKeyByXid(globalTransactionDO.getXid()));\n+            jedis.del(keys.toArray(new String[keys.size()]));\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String keys = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n+            Pipeline pipeline = jedis.pipelined();\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            keys = getGlobalKeyByTransactionId(convertGlobalTransactionDO.getTransactionId());\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @param withBranchSessions\n+     *            the withBranchSessions\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid, boolean withBranchSessions) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            globalSessionJson = jedis.get(getGlobalKeyByXid(xid));\n+            if (StringUtils.isBlank(globalSessionJson)) {\n+                return null;\n+            }\n+            // global transaction\n+            GlobalTransactionDO globalTransactionDO = JSON.parseObject(globalSessionJson, GlobalTransactionDO.class);\n+            if (globalTransactionDO == null) {\n+                return null;\n+            }\n+            // branch transactions\n+            List<BranchTransactionDO> branchTransactionDOs = null;\n+            // reduce rpc with db when branchRegister and getGlobalStatus\n+            if (withBranchSessions) {\n+                Set<String> keys = lRange(jedis, getBranchListKeyByXid(globalTransactionDO.getXid()));\n+                if (CollectionUtils.isNotEmpty(keys)) {\n+                    branchTransactionDOs = new ArrayList<>();\n+                    for (String s : keys) {\n+                        String branchJson = jedis.get(s);\n+                        if (StringUtils.isNotBlank(branchJson)) {\n+                            branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                        }\n+                    }\n+                }\n+            }\n+            return getGlobalSession(globalTransactionDO, branchTransactionDOs);\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid) {\n+        return this.readSession(xid, true);\n+    }\n+\n+    /**\n+     * Read session list.\n+     *\n+     * @param statuses\n+     *            the statuses\n+     * @return the list\n+     */\n+    public List<GlobalSession> readSession(GlobalStatus[] statuses) {\n+        List<Integer> states = new ArrayList<>();\n+        for (int i = 0; i < statuses.length; i++) {\n+            states.add(statuses[i].getCode());\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Set<String> keys = new HashSet<>();\n+            String cursor = INITIAL_CURSOR;\n+            ScanParams params = new ScanParams();\n+            params.count(logQueryLimit);\n+            params.match(getGlobalKeyByXid(\"*\"));\n+            ScanResult<String> scans;\n+            do {\n+                scans = jedis.scan(cursor, params);\n+                keys.addAll(scans.getResult().stream().collect(Collectors.toSet()));\n+                cursor = scans.getCursor();\n+            } while (!INITIAL_CURSOR.equals(cursor));\n+            if (CollectionUtils.isNotEmpty(keys)) {\n+                List<GlobalTransactionDO> globalTransactionDOs = new ArrayList<>();\n+                for (String globalKey : keys) {\n+                    GlobalTransactionDO globalTransactionDO =\n+                        JSON.parseObject(jedis.get(globalKey), GlobalTransactionDO.class);\n+                    if (null != globalTransactionDO && states.contains(globalTransactionDO.getStatus())) {\n+                        globalTransactionDOs.add(globalTransactionDO);\n+                    }\n+                }\n+                if (CollectionUtils.isNotEmpty(globalTransactionDOs)) {\n+                    List<String> xids =\n+                        globalTransactionDOs.stream().map(GlobalTransactionDO::getXid).collect(Collectors.toList());\n+                    List<BranchTransactionDO> branchTransactionDOs = new ArrayList<>();\n+                    for (String xid : xids) {\n+                        Set<String> branches = lRange(jedis, getBranchListKeyByXid(xid));\n+                        if (CollectionUtils.isNotEmpty(branches)) {\n+                            for (String branchKey : branches) {\n+                                String branchJson = jedis.get(branchKey);\n+                                if (StringUtils.isNotBlank(branchJson)) {\n+                                    branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                                }\n+                            }\n+                        }\n+                    }\n+                    Map<String, List<BranchTransactionDO>> branchTransactionDOsMap =\n+                        branchTransactionDOs.stream().collect(Collectors.groupingBy(BranchTransactionDO::getXid,\n+                            LinkedHashMap::new, Collectors.toList()));\n+                    return globalTransactionDOs.stream()\n+                        .map(globalTransactionDO -> getGlobalSession(globalTransactionDO,\n+                            branchTransactionDOsMap.get(globalTransactionDO.getXid())))\n+                        .collect(Collectors.toList());\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public List<GlobalSession> readSession(SessionCondition sessionCondition) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            if (StringUtils.isNotBlank(sessionCondition.getXid())) {\n+                globalSessionJson = jedis.get(getGlobalKeyByXid(sessionCondition.getXid()));\n+                if (StringUtils.isNotBlank(globalSessionJson)) {\n+                    GlobalSession session =\n+                        convertGlobalSession(JSON.parseObject(globalSessionJson, GlobalTransactionDO.class));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 279}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3MTUyMg==", "bodyText": "Judge whether it is empty\n\nok", "url": "https://github.com/seata/seata/pull/2484#discussion_r432871522", "createdAt": "2020-05-30T17:19:00Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import com.alibaba.fastjson.JSON;\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String INITIAL_CURSOR = \"0\";\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    public RedisTransactionStoreManager() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            jedis.del(key);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            Pipeline pipeline = jedis.pipelined();\n+            if (jedis.get(key) == null) {\n+                pipeline.lpush(getBranchListKeyByXid(branchTransactionDO.getXid()), key);\n+            }\n+            pipeline.set(key, JSON.toJSONString(branchTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<String> keys = new ArrayList<>();\n+            keys.add(getGlobalKeyByXid(globalTransactionDO.getXid()));\n+            keys.add(getGlobalKeyByTransactionId(globalTransactionDO.getTransactionId()));\n+            keys.add(getBranchListKeyByXid(globalTransactionDO.getXid()));\n+            jedis.del(keys.toArray(new String[keys.size()]));\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String keys = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n+            Pipeline pipeline = jedis.pipelined();\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            keys = getGlobalKeyByTransactionId(convertGlobalTransactionDO.getTransactionId());\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @param withBranchSessions\n+     *            the withBranchSessions\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid, boolean withBranchSessions) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            globalSessionJson = jedis.get(getGlobalKeyByXid(xid));\n+            if (StringUtils.isBlank(globalSessionJson)) {\n+                return null;\n+            }\n+            // global transaction\n+            GlobalTransactionDO globalTransactionDO = JSON.parseObject(globalSessionJson, GlobalTransactionDO.class);\n+            if (globalTransactionDO == null) {\n+                return null;\n+            }\n+            // branch transactions\n+            List<BranchTransactionDO> branchTransactionDOs = null;\n+            // reduce rpc with db when branchRegister and getGlobalStatus\n+            if (withBranchSessions) {\n+                Set<String> keys = lRange(jedis, getBranchListKeyByXid(globalTransactionDO.getXid()));\n+                if (CollectionUtils.isNotEmpty(keys)) {\n+                    branchTransactionDOs = new ArrayList<>();\n+                    for (String s : keys) {\n+                        String branchJson = jedis.get(s);\n+                        if (StringUtils.isNotBlank(branchJson)) {\n+                            branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                        }\n+                    }\n+                }\n+            }\n+            return getGlobalSession(globalTransactionDO, branchTransactionDOs);\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid) {\n+        return this.readSession(xid, true);\n+    }\n+\n+    /**\n+     * Read session list.\n+     *\n+     * @param statuses\n+     *            the statuses\n+     * @return the list\n+     */\n+    public List<GlobalSession> readSession(GlobalStatus[] statuses) {\n+        List<Integer> states = new ArrayList<>();\n+        for (int i = 0; i < statuses.length; i++) {\n+            states.add(statuses[i].getCode());\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Set<String> keys = new HashSet<>();\n+            String cursor = INITIAL_CURSOR;\n+            ScanParams params = new ScanParams();\n+            params.count(logQueryLimit);\n+            params.match(getGlobalKeyByXid(\"*\"));\n+            ScanResult<String> scans;\n+            do {\n+                scans = jedis.scan(cursor, params);\n+                keys.addAll(scans.getResult().stream().collect(Collectors.toSet()));\n+                cursor = scans.getCursor();\n+            } while (!INITIAL_CURSOR.equals(cursor));\n+            if (CollectionUtils.isNotEmpty(keys)) {\n+                List<GlobalTransactionDO> globalTransactionDOs = new ArrayList<>();\n+                for (String globalKey : keys) {\n+                    GlobalTransactionDO globalTransactionDO =\n+                        JSON.parseObject(jedis.get(globalKey), GlobalTransactionDO.class);\n+                    if (null != globalTransactionDO && states.contains(globalTransactionDO.getStatus())) {\n+                        globalTransactionDOs.add(globalTransactionDO);\n+                    }\n+                }\n+                if (CollectionUtils.isNotEmpty(globalTransactionDOs)) {\n+                    List<String> xids =\n+                        globalTransactionDOs.stream().map(GlobalTransactionDO::getXid).collect(Collectors.toList());\n+                    List<BranchTransactionDO> branchTransactionDOs = new ArrayList<>();\n+                    for (String xid : xids) {\n+                        Set<String> branches = lRange(jedis, getBranchListKeyByXid(xid));\n+                        if (CollectionUtils.isNotEmpty(branches)) {\n+                            for (String branchKey : branches) {\n+                                String branchJson = jedis.get(branchKey);\n+                                if (StringUtils.isNotBlank(branchJson)) {\n+                                    branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                                }\n+                            }\n+                        }\n+                    }\n+                    Map<String, List<BranchTransactionDO>> branchTransactionDOsMap =\n+                        branchTransactionDOs.stream().collect(Collectors.groupingBy(BranchTransactionDO::getXid,\n+                            LinkedHashMap::new, Collectors.toList()));\n+                    return globalTransactionDOs.stream()\n+                        .map(globalTransactionDO -> getGlobalSession(globalTransactionDO,\n+                            branchTransactionDOsMap.get(globalTransactionDO.getXid())))\n+                        .collect(Collectors.toList());\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public List<GlobalSession> readSession(SessionCondition sessionCondition) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            if (StringUtils.isNotBlank(sessionCondition.getXid())) {\n+                globalSessionJson = jedis.get(getGlobalKeyByXid(sessionCondition.getXid()));\n+                if (StringUtils.isNotBlank(globalSessionJson)) {\n+                    GlobalSession session =\n+                        convertGlobalSession(JSON.parseObject(globalSessionJson, GlobalTransactionDO.class));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg0MDg1OQ=="}, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 279}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk0Mjg3Nw==", "bodyText": "this", "url": "https://github.com/seata/seata/pull/2484#discussion_r432942877", "createdAt": "2020-05-31T12:38:35Z", "author": {"login": "ph3636"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import com.alibaba.fastjson.JSON;\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String INITIAL_CURSOR = \"0\";\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    public RedisTransactionStoreManager() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            jedis.del(key);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            Pipeline pipeline = jedis.pipelined();\n+            if (jedis.get(key) == null) {\n+                pipeline.lpush(getBranchListKeyByXid(branchTransactionDO.getXid()), key);\n+            }\n+            pipeline.set(key, JSON.toJSONString(branchTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<String> keys = new ArrayList<>();\n+            keys.add(getGlobalKeyByXid(globalTransactionDO.getXid()));\n+            keys.add(getGlobalKeyByTransactionId(globalTransactionDO.getTransactionId()));\n+            keys.add(getBranchListKeyByXid(globalTransactionDO.getXid()));\n+            jedis.del(keys.toArray(new String[keys.size()]));\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String keys = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n+            Pipeline pipeline = jedis.pipelined();\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            keys = getGlobalKeyByTransactionId(convertGlobalTransactionDO.getTransactionId());\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @param withBranchSessions\n+     *            the withBranchSessions\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid, boolean withBranchSessions) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            globalSessionJson = jedis.get(getGlobalKeyByXid(xid));\n+            if (StringUtils.isBlank(globalSessionJson)) {\n+                return null;\n+            }\n+            // global transaction\n+            GlobalTransactionDO globalTransactionDO = JSON.parseObject(globalSessionJson, GlobalTransactionDO.class);\n+            if (globalTransactionDO == null) {\n+                return null;\n+            }\n+            // branch transactions\n+            List<BranchTransactionDO> branchTransactionDOs = null;\n+            // reduce rpc with db when branchRegister and getGlobalStatus\n+            if (withBranchSessions) {\n+                Set<String> keys = lRange(jedis, getBranchListKeyByXid(globalTransactionDO.getXid()));\n+                if (CollectionUtils.isNotEmpty(keys)) {\n+                    branchTransactionDOs = new ArrayList<>();\n+                    for (String s : keys) {\n+                        String branchJson = jedis.get(s);\n+                        if (StringUtils.isNotBlank(branchJson)) {\n+                            branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                        }\n+                    }\n+                }\n+            }\n+            return getGlobalSession(globalTransactionDO, branchTransactionDOs);\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid) {\n+        return this.readSession(xid, true);\n+    }\n+\n+    /**\n+     * Read session list.\n+     *\n+     * @param statuses\n+     *            the statuses\n+     * @return the list\n+     */\n+    public List<GlobalSession> readSession(GlobalStatus[] statuses) {\n+        List<Integer> states = new ArrayList<>();\n+        for (int i = 0; i < statuses.length; i++) {\n+            states.add(statuses[i].getCode());\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Set<String> keys = new HashSet<>();\n+            String cursor = INITIAL_CURSOR;\n+            ScanParams params = new ScanParams();\n+            params.count(logQueryLimit);\n+            params.match(getGlobalKeyByXid(\"*\"));\n+            ScanResult<String> scans;\n+            do {\n+                scans = jedis.scan(cursor, params);\n+                keys.addAll(scans.getResult().stream().collect(Collectors.toSet()));\n+                cursor = scans.getCursor();\n+            } while (!INITIAL_CURSOR.equals(cursor));\n+            if (CollectionUtils.isNotEmpty(keys)) {\n+                List<GlobalTransactionDO> globalTransactionDOs = new ArrayList<>();\n+                for (String globalKey : keys) {\n+                    GlobalTransactionDO globalTransactionDO =\n+                        JSON.parseObject(jedis.get(globalKey), GlobalTransactionDO.class);\n+                    if (null != globalTransactionDO && states.contains(globalTransactionDO.getStatus())) {\n+                        globalTransactionDOs.add(globalTransactionDO);\n+                    }\n+                }\n+                if (CollectionUtils.isNotEmpty(globalTransactionDOs)) {\n+                    List<String> xids =\n+                        globalTransactionDOs.stream().map(GlobalTransactionDO::getXid).collect(Collectors.toList());\n+                    List<BranchTransactionDO> branchTransactionDOs = new ArrayList<>();\n+                    for (String xid : xids) {\n+                        Set<String> branches = lRange(jedis, getBranchListKeyByXid(xid));\n+                        if (CollectionUtils.isNotEmpty(branches)) {\n+                            for (String branchKey : branches) {\n+                                String branchJson = jedis.get(branchKey);\n+                                if (StringUtils.isNotBlank(branchJson)) {\n+                                    branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                                }\n+                            }\n+                        }\n+                    }\n+                    Map<String, List<BranchTransactionDO>> branchTransactionDOsMap =\n+                        branchTransactionDOs.stream().collect(Collectors.groupingBy(BranchTransactionDO::getXid,\n+                            LinkedHashMap::new, Collectors.toList()));\n+                    return globalTransactionDOs.stream()\n+                        .map(globalTransactionDO -> getGlobalSession(globalTransactionDO,\n+                            branchTransactionDOsMap.get(globalTransactionDO.getXid())))\n+                        .collect(Collectors.toList());\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public List<GlobalSession> readSession(SessionCondition sessionCondition) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            if (StringUtils.isNotBlank(sessionCondition.getXid())) {\n+                globalSessionJson = jedis.get(getGlobalKeyByXid(sessionCondition.getXid()));\n+                if (StringUtils.isNotBlank(globalSessionJson)) {\n+                    GlobalSession session =\n+                        convertGlobalSession(JSON.parseObject(globalSessionJson, GlobalTransactionDO.class));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg0MDg1OQ=="}, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 279}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NTk3MTI1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQxMzoxOTozM1rOGcyh6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQxNzoyMjoyNlrOGc0ZRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg0MTE5Mg==", "bodyText": "mget", "url": "https://github.com/seata/seata/pull/2484#discussion_r432841192", "createdAt": "2020-05-30T13:19:33Z", "author": {"login": "ph3636"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import com.alibaba.fastjson.JSON;\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String INITIAL_CURSOR = \"0\";\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    public RedisTransactionStoreManager() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            jedis.del(key);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            Pipeline pipeline = jedis.pipelined();\n+            if (jedis.get(key) == null) {\n+                pipeline.lpush(getBranchListKeyByXid(branchTransactionDO.getXid()), key);\n+            }\n+            pipeline.set(key, JSON.toJSONString(branchTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<String> keys = new ArrayList<>();\n+            keys.add(getGlobalKeyByXid(globalTransactionDO.getXid()));\n+            keys.add(getGlobalKeyByTransactionId(globalTransactionDO.getTransactionId()));\n+            keys.add(getBranchListKeyByXid(globalTransactionDO.getXid()));\n+            jedis.del(keys.toArray(new String[keys.size()]));\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String keys = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n+            Pipeline pipeline = jedis.pipelined();\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            keys = getGlobalKeyByTransactionId(convertGlobalTransactionDO.getTransactionId());\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @param withBranchSessions\n+     *            the withBranchSessions\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid, boolean withBranchSessions) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            globalSessionJson = jedis.get(getGlobalKeyByXid(xid));\n+            if (StringUtils.isBlank(globalSessionJson)) {\n+                return null;\n+            }\n+            // global transaction\n+            GlobalTransactionDO globalTransactionDO = JSON.parseObject(globalSessionJson, GlobalTransactionDO.class);\n+            if (globalTransactionDO == null) {\n+                return null;\n+            }\n+            // branch transactions\n+            List<BranchTransactionDO> branchTransactionDOs = null;\n+            // reduce rpc with db when branchRegister and getGlobalStatus\n+            if (withBranchSessions) {\n+                Set<String> keys = lRange(jedis, getBranchListKeyByXid(globalTransactionDO.getXid()));\n+                if (CollectionUtils.isNotEmpty(keys)) {\n+                    branchTransactionDOs = new ArrayList<>();\n+                    for (String s : keys) {\n+                        String branchJson = jedis.get(s);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 187}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3MTc1MQ==", "bodyText": "mget\n\nok", "url": "https://github.com/seata/seata/pull/2484#discussion_r432871751", "createdAt": "2020-05-30T17:22:26Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import com.alibaba.fastjson.JSON;\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String INITIAL_CURSOR = \"0\";\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    public RedisTransactionStoreManager() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            jedis.del(key);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            Pipeline pipeline = jedis.pipelined();\n+            if (jedis.get(key) == null) {\n+                pipeline.lpush(getBranchListKeyByXid(branchTransactionDO.getXid()), key);\n+            }\n+            pipeline.set(key, JSON.toJSONString(branchTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<String> keys = new ArrayList<>();\n+            keys.add(getGlobalKeyByXid(globalTransactionDO.getXid()));\n+            keys.add(getGlobalKeyByTransactionId(globalTransactionDO.getTransactionId()));\n+            keys.add(getBranchListKeyByXid(globalTransactionDO.getXid()));\n+            jedis.del(keys.toArray(new String[keys.size()]));\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String keys = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n+            Pipeline pipeline = jedis.pipelined();\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            keys = getGlobalKeyByTransactionId(convertGlobalTransactionDO.getTransactionId());\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @param withBranchSessions\n+     *            the withBranchSessions\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid, boolean withBranchSessions) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            globalSessionJson = jedis.get(getGlobalKeyByXid(xid));\n+            if (StringUtils.isBlank(globalSessionJson)) {\n+                return null;\n+            }\n+            // global transaction\n+            GlobalTransactionDO globalTransactionDO = JSON.parseObject(globalSessionJson, GlobalTransactionDO.class);\n+            if (globalTransactionDO == null) {\n+                return null;\n+            }\n+            // branch transactions\n+            List<BranchTransactionDO> branchTransactionDOs = null;\n+            // reduce rpc with db when branchRegister and getGlobalStatus\n+            if (withBranchSessions) {\n+                Set<String> keys = lRange(jedis, getBranchListKeyByXid(globalTransactionDO.getXid()));\n+                if (CollectionUtils.isNotEmpty(keys)) {\n+                    branchTransactionDOs = new ArrayList<>();\n+                    for (String s : keys) {\n+                        String branchJson = jedis.get(s);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg0MTE5Mg=="}, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 187}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NTk3MjE4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQxMzoyMTozN1rOGcyibA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQxNzoyNDo0N1rOGc0Z3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg0MTMyNA==", "bodyText": "The scope of globalSessionJson and global is clear", "url": "https://github.com/seata/seata/pull/2484#discussion_r432841324", "createdAt": "2020-05-30T13:21:37Z", "author": {"login": "ph3636"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import com.alibaba.fastjson.JSON;\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String INITIAL_CURSOR = \"0\";\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    public RedisTransactionStoreManager() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            jedis.del(key);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            Pipeline pipeline = jedis.pipelined();\n+            if (jedis.get(key) == null) {\n+                pipeline.lpush(getBranchListKeyByXid(branchTransactionDO.getXid()), key);\n+            }\n+            pipeline.set(key, JSON.toJSONString(branchTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<String> keys = new ArrayList<>();\n+            keys.add(getGlobalKeyByXid(globalTransactionDO.getXid()));\n+            keys.add(getGlobalKeyByTransactionId(globalTransactionDO.getTransactionId()));\n+            keys.add(getBranchListKeyByXid(globalTransactionDO.getXid()));\n+            jedis.del(keys.toArray(new String[keys.size()]));\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String keys = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n+            Pipeline pipeline = jedis.pipelined();\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            keys = getGlobalKeyByTransactionId(convertGlobalTransactionDO.getTransactionId());\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @param withBranchSessions\n+     *            the withBranchSessions\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid, boolean withBranchSessions) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            globalSessionJson = jedis.get(getGlobalKeyByXid(xid));\n+            if (StringUtils.isBlank(globalSessionJson)) {\n+                return null;\n+            }\n+            // global transaction\n+            GlobalTransactionDO globalTransactionDO = JSON.parseObject(globalSessionJson, GlobalTransactionDO.class);\n+            if (globalTransactionDO == null) {\n+                return null;\n+            }\n+            // branch transactions\n+            List<BranchTransactionDO> branchTransactionDOs = null;\n+            // reduce rpc with db when branchRegister and getGlobalStatus\n+            if (withBranchSessions) {\n+                Set<String> keys = lRange(jedis, getBranchListKeyByXid(globalTransactionDO.getXid()));\n+                if (CollectionUtils.isNotEmpty(keys)) {\n+                    branchTransactionDOs = new ArrayList<>();\n+                    for (String s : keys) {\n+                        String branchJson = jedis.get(s);\n+                        if (StringUtils.isNotBlank(branchJson)) {\n+                            branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                        }\n+                    }\n+                }\n+            }\n+            return getGlobalSession(globalTransactionDO, branchTransactionDOs);\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid) {\n+        return this.readSession(xid, true);\n+    }\n+\n+    /**\n+     * Read session list.\n+     *\n+     * @param statuses\n+     *            the statuses\n+     * @return the list\n+     */\n+    public List<GlobalSession> readSession(GlobalStatus[] statuses) {\n+        List<Integer> states = new ArrayList<>();\n+        for (int i = 0; i < statuses.length; i++) {\n+            states.add(statuses[i].getCode());\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Set<String> keys = new HashSet<>();\n+            String cursor = INITIAL_CURSOR;\n+            ScanParams params = new ScanParams();\n+            params.count(logQueryLimit);\n+            params.match(getGlobalKeyByXid(\"*\"));\n+            ScanResult<String> scans;\n+            do {\n+                scans = jedis.scan(cursor, params);\n+                keys.addAll(scans.getResult().stream().collect(Collectors.toSet()));\n+                cursor = scans.getCursor();\n+            } while (!INITIAL_CURSOR.equals(cursor));\n+            if (CollectionUtils.isNotEmpty(keys)) {\n+                List<GlobalTransactionDO> globalTransactionDOs = new ArrayList<>();\n+                for (String globalKey : keys) {\n+                    GlobalTransactionDO globalTransactionDO =\n+                        JSON.parseObject(jedis.get(globalKey), GlobalTransactionDO.class);\n+                    if (null != globalTransactionDO && states.contains(globalTransactionDO.getStatus())) {\n+                        globalTransactionDOs.add(globalTransactionDO);\n+                    }\n+                }\n+                if (CollectionUtils.isNotEmpty(globalTransactionDOs)) {\n+                    List<String> xids =\n+                        globalTransactionDOs.stream().map(GlobalTransactionDO::getXid).collect(Collectors.toList());\n+                    List<BranchTransactionDO> branchTransactionDOs = new ArrayList<>();\n+                    for (String xid : xids) {\n+                        Set<String> branches = lRange(jedis, getBranchListKeyByXid(xid));\n+                        if (CollectionUtils.isNotEmpty(branches)) {\n+                            for (String branchKey : branches) {\n+                                String branchJson = jedis.get(branchKey);\n+                                if (StringUtils.isNotBlank(branchJson)) {\n+                                    branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                                }\n+                            }\n+                        }\n+                    }\n+                    Map<String, List<BranchTransactionDO>> branchTransactionDOsMap =\n+                        branchTransactionDOs.stream().collect(Collectors.groupingBy(BranchTransactionDO::getXid,\n+                            LinkedHashMap::new, Collectors.toList()));\n+                    return globalTransactionDOs.stream()\n+                        .map(globalTransactionDO -> getGlobalSession(globalTransactionDO,\n+                            branchTransactionDOsMap.get(globalTransactionDO.getXid())))\n+                        .collect(Collectors.toList());\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public List<GlobalSession> readSession(SessionCondition sessionCondition) {\n+        String globalSessionJson;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 273}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3MTkwMg==", "bodyText": "ok", "url": "https://github.com/seata/seata/pull/2484#discussion_r432871902", "createdAt": "2020-05-30T17:24:47Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import com.alibaba.fastjson.JSON;\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String INITIAL_CURSOR = \"0\";\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    public RedisTransactionStoreManager() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            jedis.del(key);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            Pipeline pipeline = jedis.pipelined();\n+            if (jedis.get(key) == null) {\n+                pipeline.lpush(getBranchListKeyByXid(branchTransactionDO.getXid()), key);\n+            }\n+            pipeline.set(key, JSON.toJSONString(branchTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<String> keys = new ArrayList<>();\n+            keys.add(getGlobalKeyByXid(globalTransactionDO.getXid()));\n+            keys.add(getGlobalKeyByTransactionId(globalTransactionDO.getTransactionId()));\n+            keys.add(getBranchListKeyByXid(globalTransactionDO.getXid()));\n+            jedis.del(keys.toArray(new String[keys.size()]));\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String keys = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n+            Pipeline pipeline = jedis.pipelined();\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            keys = getGlobalKeyByTransactionId(convertGlobalTransactionDO.getTransactionId());\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @param withBranchSessions\n+     *            the withBranchSessions\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid, boolean withBranchSessions) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            globalSessionJson = jedis.get(getGlobalKeyByXid(xid));\n+            if (StringUtils.isBlank(globalSessionJson)) {\n+                return null;\n+            }\n+            // global transaction\n+            GlobalTransactionDO globalTransactionDO = JSON.parseObject(globalSessionJson, GlobalTransactionDO.class);\n+            if (globalTransactionDO == null) {\n+                return null;\n+            }\n+            // branch transactions\n+            List<BranchTransactionDO> branchTransactionDOs = null;\n+            // reduce rpc with db when branchRegister and getGlobalStatus\n+            if (withBranchSessions) {\n+                Set<String> keys = lRange(jedis, getBranchListKeyByXid(globalTransactionDO.getXid()));\n+                if (CollectionUtils.isNotEmpty(keys)) {\n+                    branchTransactionDOs = new ArrayList<>();\n+                    for (String s : keys) {\n+                        String branchJson = jedis.get(s);\n+                        if (StringUtils.isNotBlank(branchJson)) {\n+                            branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                        }\n+                    }\n+                }\n+            }\n+            return getGlobalSession(globalTransactionDO, branchTransactionDOs);\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid) {\n+        return this.readSession(xid, true);\n+    }\n+\n+    /**\n+     * Read session list.\n+     *\n+     * @param statuses\n+     *            the statuses\n+     * @return the list\n+     */\n+    public List<GlobalSession> readSession(GlobalStatus[] statuses) {\n+        List<Integer> states = new ArrayList<>();\n+        for (int i = 0; i < statuses.length; i++) {\n+            states.add(statuses[i].getCode());\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Set<String> keys = new HashSet<>();\n+            String cursor = INITIAL_CURSOR;\n+            ScanParams params = new ScanParams();\n+            params.count(logQueryLimit);\n+            params.match(getGlobalKeyByXid(\"*\"));\n+            ScanResult<String> scans;\n+            do {\n+                scans = jedis.scan(cursor, params);\n+                keys.addAll(scans.getResult().stream().collect(Collectors.toSet()));\n+                cursor = scans.getCursor();\n+            } while (!INITIAL_CURSOR.equals(cursor));\n+            if (CollectionUtils.isNotEmpty(keys)) {\n+                List<GlobalTransactionDO> globalTransactionDOs = new ArrayList<>();\n+                for (String globalKey : keys) {\n+                    GlobalTransactionDO globalTransactionDO =\n+                        JSON.parseObject(jedis.get(globalKey), GlobalTransactionDO.class);\n+                    if (null != globalTransactionDO && states.contains(globalTransactionDO.getStatus())) {\n+                        globalTransactionDOs.add(globalTransactionDO);\n+                    }\n+                }\n+                if (CollectionUtils.isNotEmpty(globalTransactionDOs)) {\n+                    List<String> xids =\n+                        globalTransactionDOs.stream().map(GlobalTransactionDO::getXid).collect(Collectors.toList());\n+                    List<BranchTransactionDO> branchTransactionDOs = new ArrayList<>();\n+                    for (String xid : xids) {\n+                        Set<String> branches = lRange(jedis, getBranchListKeyByXid(xid));\n+                        if (CollectionUtils.isNotEmpty(branches)) {\n+                            for (String branchKey : branches) {\n+                                String branchJson = jedis.get(branchKey);\n+                                if (StringUtils.isNotBlank(branchJson)) {\n+                                    branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                                }\n+                            }\n+                        }\n+                    }\n+                    Map<String, List<BranchTransactionDO>> branchTransactionDOsMap =\n+                        branchTransactionDOs.stream().collect(Collectors.groupingBy(BranchTransactionDO::getXid,\n+                            LinkedHashMap::new, Collectors.toList()));\n+                    return globalTransactionDOs.stream()\n+                        .map(globalTransactionDO -> getGlobalSession(globalTransactionDO,\n+                            branchTransactionDOsMap.get(globalTransactionDO.getXid())))\n+                        .collect(Collectors.toList());\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public List<GlobalSession> readSession(SessionCondition sessionCondition) {\n+        String globalSessionJson;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg0MTMyNA=="}, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 273}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NTk3MjU3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQxMzoyMjowNVrOGcyimQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMVQxMjozNjowM1rOGc4uVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg0MTM2OQ==", "bodyText": "Judge whether it is empty", "url": "https://github.com/seata/seata/pull/2484#discussion_r432841369", "createdAt": "2020-05-30T13:22:05Z", "author": {"login": "ph3636"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import com.alibaba.fastjson.JSON;\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String INITIAL_CURSOR = \"0\";\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    public RedisTransactionStoreManager() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            jedis.del(key);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            Pipeline pipeline = jedis.pipelined();\n+            if (jedis.get(key) == null) {\n+                pipeline.lpush(getBranchListKeyByXid(branchTransactionDO.getXid()), key);\n+            }\n+            pipeline.set(key, JSON.toJSONString(branchTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<String> keys = new ArrayList<>();\n+            keys.add(getGlobalKeyByXid(globalTransactionDO.getXid()));\n+            keys.add(getGlobalKeyByTransactionId(globalTransactionDO.getTransactionId()));\n+            keys.add(getBranchListKeyByXid(globalTransactionDO.getXid()));\n+            jedis.del(keys.toArray(new String[keys.size()]));\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String keys = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n+            Pipeline pipeline = jedis.pipelined();\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            keys = getGlobalKeyByTransactionId(convertGlobalTransactionDO.getTransactionId());\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @param withBranchSessions\n+     *            the withBranchSessions\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid, boolean withBranchSessions) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            globalSessionJson = jedis.get(getGlobalKeyByXid(xid));\n+            if (StringUtils.isBlank(globalSessionJson)) {\n+                return null;\n+            }\n+            // global transaction\n+            GlobalTransactionDO globalTransactionDO = JSON.parseObject(globalSessionJson, GlobalTransactionDO.class);\n+            if (globalTransactionDO == null) {\n+                return null;\n+            }\n+            // branch transactions\n+            List<BranchTransactionDO> branchTransactionDOs = null;\n+            // reduce rpc with db when branchRegister and getGlobalStatus\n+            if (withBranchSessions) {\n+                Set<String> keys = lRange(jedis, getBranchListKeyByXid(globalTransactionDO.getXid()));\n+                if (CollectionUtils.isNotEmpty(keys)) {\n+                    branchTransactionDOs = new ArrayList<>();\n+                    for (String s : keys) {\n+                        String branchJson = jedis.get(s);\n+                        if (StringUtils.isNotBlank(branchJson)) {\n+                            branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                        }\n+                    }\n+                }\n+            }\n+            return getGlobalSession(globalTransactionDO, branchTransactionDOs);\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid) {\n+        return this.readSession(xid, true);\n+    }\n+\n+    /**\n+     * Read session list.\n+     *\n+     * @param statuses\n+     *            the statuses\n+     * @return the list\n+     */\n+    public List<GlobalSession> readSession(GlobalStatus[] statuses) {\n+        List<Integer> states = new ArrayList<>();\n+        for (int i = 0; i < statuses.length; i++) {\n+            states.add(statuses[i].getCode());\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Set<String> keys = new HashSet<>();\n+            String cursor = INITIAL_CURSOR;\n+            ScanParams params = new ScanParams();\n+            params.count(logQueryLimit);\n+            params.match(getGlobalKeyByXid(\"*\"));\n+            ScanResult<String> scans;\n+            do {\n+                scans = jedis.scan(cursor, params);\n+                keys.addAll(scans.getResult().stream().collect(Collectors.toSet()));\n+                cursor = scans.getCursor();\n+            } while (!INITIAL_CURSOR.equals(cursor));\n+            if (CollectionUtils.isNotEmpty(keys)) {\n+                List<GlobalTransactionDO> globalTransactionDOs = new ArrayList<>();\n+                for (String globalKey : keys) {\n+                    GlobalTransactionDO globalTransactionDO =\n+                        JSON.parseObject(jedis.get(globalKey), GlobalTransactionDO.class);\n+                    if (null != globalTransactionDO && states.contains(globalTransactionDO.getStatus())) {\n+                        globalTransactionDOs.add(globalTransactionDO);\n+                    }\n+                }\n+                if (CollectionUtils.isNotEmpty(globalTransactionDOs)) {\n+                    List<String> xids =\n+                        globalTransactionDOs.stream().map(GlobalTransactionDO::getXid).collect(Collectors.toList());\n+                    List<BranchTransactionDO> branchTransactionDOs = new ArrayList<>();\n+                    for (String xid : xids) {\n+                        Set<String> branches = lRange(jedis, getBranchListKeyByXid(xid));\n+                        if (CollectionUtils.isNotEmpty(branches)) {\n+                            for (String branchKey : branches) {\n+                                String branchJson = jedis.get(branchKey);\n+                                if (StringUtils.isNotBlank(branchJson)) {\n+                                    branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                                }\n+                            }\n+                        }\n+                    }\n+                    Map<String, List<BranchTransactionDO>> branchTransactionDOsMap =\n+                        branchTransactionDOs.stream().collect(Collectors.groupingBy(BranchTransactionDO::getXid,\n+                            LinkedHashMap::new, Collectors.toList()));\n+                    return globalTransactionDOs.stream()\n+                        .map(globalTransactionDO -> getGlobalSession(globalTransactionDO,\n+                            branchTransactionDOsMap.get(globalTransactionDO.getXid())))\n+                        .collect(Collectors.toList());\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public List<GlobalSession> readSession(SessionCondition sessionCondition) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            if (StringUtils.isNotBlank(sessionCondition.getXid())) {\n+                globalSessionJson = jedis.get(getGlobalKeyByXid(sessionCondition.getXid()));\n+                if (StringUtils.isNotBlank(globalSessionJson)) {\n+                    GlobalSession session =\n+                        convertGlobalSession(JSON.parseObject(globalSessionJson, GlobalTransactionDO.class));\n+                    List<GlobalSession> globalSessions = new ArrayList<>();\n+                    globalSessions.add(session);\n+                    return globalSessions;\n+                }\n+            } else if (sessionCondition.getTransactionId() != null) {\n+                String global = jedis.get(getGlobalKeyByTransactionId(sessionCondition.getTransactionId()));\n+                if (StringUtils.isBlank(global)) {\n+                    return null;\n+                }\n+                GlobalTransactionDO globalTransactionDO = JSON.parseObject(global, GlobalTransactionDO.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 289}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3MTkwNg==", "bodyText": "ok", "url": "https://github.com/seata/seata/pull/2484#discussion_r432871906", "createdAt": "2020-05-30T17:24:57Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import com.alibaba.fastjson.JSON;\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String INITIAL_CURSOR = \"0\";\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    public RedisTransactionStoreManager() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            jedis.del(key);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            Pipeline pipeline = jedis.pipelined();\n+            if (jedis.get(key) == null) {\n+                pipeline.lpush(getBranchListKeyByXid(branchTransactionDO.getXid()), key);\n+            }\n+            pipeline.set(key, JSON.toJSONString(branchTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<String> keys = new ArrayList<>();\n+            keys.add(getGlobalKeyByXid(globalTransactionDO.getXid()));\n+            keys.add(getGlobalKeyByTransactionId(globalTransactionDO.getTransactionId()));\n+            keys.add(getBranchListKeyByXid(globalTransactionDO.getXid()));\n+            jedis.del(keys.toArray(new String[keys.size()]));\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String keys = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n+            Pipeline pipeline = jedis.pipelined();\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            keys = getGlobalKeyByTransactionId(convertGlobalTransactionDO.getTransactionId());\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @param withBranchSessions\n+     *            the withBranchSessions\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid, boolean withBranchSessions) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            globalSessionJson = jedis.get(getGlobalKeyByXid(xid));\n+            if (StringUtils.isBlank(globalSessionJson)) {\n+                return null;\n+            }\n+            // global transaction\n+            GlobalTransactionDO globalTransactionDO = JSON.parseObject(globalSessionJson, GlobalTransactionDO.class);\n+            if (globalTransactionDO == null) {\n+                return null;\n+            }\n+            // branch transactions\n+            List<BranchTransactionDO> branchTransactionDOs = null;\n+            // reduce rpc with db when branchRegister and getGlobalStatus\n+            if (withBranchSessions) {\n+                Set<String> keys = lRange(jedis, getBranchListKeyByXid(globalTransactionDO.getXid()));\n+                if (CollectionUtils.isNotEmpty(keys)) {\n+                    branchTransactionDOs = new ArrayList<>();\n+                    for (String s : keys) {\n+                        String branchJson = jedis.get(s);\n+                        if (StringUtils.isNotBlank(branchJson)) {\n+                            branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                        }\n+                    }\n+                }\n+            }\n+            return getGlobalSession(globalTransactionDO, branchTransactionDOs);\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid) {\n+        return this.readSession(xid, true);\n+    }\n+\n+    /**\n+     * Read session list.\n+     *\n+     * @param statuses\n+     *            the statuses\n+     * @return the list\n+     */\n+    public List<GlobalSession> readSession(GlobalStatus[] statuses) {\n+        List<Integer> states = new ArrayList<>();\n+        for (int i = 0; i < statuses.length; i++) {\n+            states.add(statuses[i].getCode());\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Set<String> keys = new HashSet<>();\n+            String cursor = INITIAL_CURSOR;\n+            ScanParams params = new ScanParams();\n+            params.count(logQueryLimit);\n+            params.match(getGlobalKeyByXid(\"*\"));\n+            ScanResult<String> scans;\n+            do {\n+                scans = jedis.scan(cursor, params);\n+                keys.addAll(scans.getResult().stream().collect(Collectors.toSet()));\n+                cursor = scans.getCursor();\n+            } while (!INITIAL_CURSOR.equals(cursor));\n+            if (CollectionUtils.isNotEmpty(keys)) {\n+                List<GlobalTransactionDO> globalTransactionDOs = new ArrayList<>();\n+                for (String globalKey : keys) {\n+                    GlobalTransactionDO globalTransactionDO =\n+                        JSON.parseObject(jedis.get(globalKey), GlobalTransactionDO.class);\n+                    if (null != globalTransactionDO && states.contains(globalTransactionDO.getStatus())) {\n+                        globalTransactionDOs.add(globalTransactionDO);\n+                    }\n+                }\n+                if (CollectionUtils.isNotEmpty(globalTransactionDOs)) {\n+                    List<String> xids =\n+                        globalTransactionDOs.stream().map(GlobalTransactionDO::getXid).collect(Collectors.toList());\n+                    List<BranchTransactionDO> branchTransactionDOs = new ArrayList<>();\n+                    for (String xid : xids) {\n+                        Set<String> branches = lRange(jedis, getBranchListKeyByXid(xid));\n+                        if (CollectionUtils.isNotEmpty(branches)) {\n+                            for (String branchKey : branches) {\n+                                String branchJson = jedis.get(branchKey);\n+                                if (StringUtils.isNotBlank(branchJson)) {\n+                                    branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                                }\n+                            }\n+                        }\n+                    }\n+                    Map<String, List<BranchTransactionDO>> branchTransactionDOsMap =\n+                        branchTransactionDOs.stream().collect(Collectors.groupingBy(BranchTransactionDO::getXid,\n+                            LinkedHashMap::new, Collectors.toList()));\n+                    return globalTransactionDOs.stream()\n+                        .map(globalTransactionDO -> getGlobalSession(globalTransactionDO,\n+                            branchTransactionDOsMap.get(globalTransactionDO.getXid())))\n+                        .collect(Collectors.toList());\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public List<GlobalSession> readSession(SessionCondition sessionCondition) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            if (StringUtils.isNotBlank(sessionCondition.getXid())) {\n+                globalSessionJson = jedis.get(getGlobalKeyByXid(sessionCondition.getXid()));\n+                if (StringUtils.isNotBlank(globalSessionJson)) {\n+                    GlobalSession session =\n+                        convertGlobalSession(JSON.parseObject(globalSessionJson, GlobalTransactionDO.class));\n+                    List<GlobalSession> globalSessions = new ArrayList<>();\n+                    globalSessions.add(session);\n+                    return globalSessions;\n+                }\n+            } else if (sessionCondition.getTransactionId() != null) {\n+                String global = jedis.get(getGlobalKeyByTransactionId(sessionCondition.getTransactionId()));\n+                if (StringUtils.isBlank(global)) {\n+                    return null;\n+                }\n+                GlobalTransactionDO globalTransactionDO = JSON.parseObject(global, GlobalTransactionDO.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg0MTM2OQ=="}, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 289}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk0MjY3OA==", "bodyText": "this", "url": "https://github.com/seata/seata/pull/2484#discussion_r432942678", "createdAt": "2020-05-31T12:36:03Z", "author": {"login": "ph3636"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import com.alibaba.fastjson.JSON;\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String INITIAL_CURSOR = \"0\";\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    public RedisTransactionStoreManager() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            jedis.del(key);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            Pipeline pipeline = jedis.pipelined();\n+            if (jedis.get(key) == null) {\n+                pipeline.lpush(getBranchListKeyByXid(branchTransactionDO.getXid()), key);\n+            }\n+            pipeline.set(key, JSON.toJSONString(branchTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<String> keys = new ArrayList<>();\n+            keys.add(getGlobalKeyByXid(globalTransactionDO.getXid()));\n+            keys.add(getGlobalKeyByTransactionId(globalTransactionDO.getTransactionId()));\n+            keys.add(getBranchListKeyByXid(globalTransactionDO.getXid()));\n+            jedis.del(keys.toArray(new String[keys.size()]));\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String keys = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n+            Pipeline pipeline = jedis.pipelined();\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            keys = getGlobalKeyByTransactionId(convertGlobalTransactionDO.getTransactionId());\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @param withBranchSessions\n+     *            the withBranchSessions\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid, boolean withBranchSessions) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            globalSessionJson = jedis.get(getGlobalKeyByXid(xid));\n+            if (StringUtils.isBlank(globalSessionJson)) {\n+                return null;\n+            }\n+            // global transaction\n+            GlobalTransactionDO globalTransactionDO = JSON.parseObject(globalSessionJson, GlobalTransactionDO.class);\n+            if (globalTransactionDO == null) {\n+                return null;\n+            }\n+            // branch transactions\n+            List<BranchTransactionDO> branchTransactionDOs = null;\n+            // reduce rpc with db when branchRegister and getGlobalStatus\n+            if (withBranchSessions) {\n+                Set<String> keys = lRange(jedis, getBranchListKeyByXid(globalTransactionDO.getXid()));\n+                if (CollectionUtils.isNotEmpty(keys)) {\n+                    branchTransactionDOs = new ArrayList<>();\n+                    for (String s : keys) {\n+                        String branchJson = jedis.get(s);\n+                        if (StringUtils.isNotBlank(branchJson)) {\n+                            branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                        }\n+                    }\n+                }\n+            }\n+            return getGlobalSession(globalTransactionDO, branchTransactionDOs);\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid) {\n+        return this.readSession(xid, true);\n+    }\n+\n+    /**\n+     * Read session list.\n+     *\n+     * @param statuses\n+     *            the statuses\n+     * @return the list\n+     */\n+    public List<GlobalSession> readSession(GlobalStatus[] statuses) {\n+        List<Integer> states = new ArrayList<>();\n+        for (int i = 0; i < statuses.length; i++) {\n+            states.add(statuses[i].getCode());\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Set<String> keys = new HashSet<>();\n+            String cursor = INITIAL_CURSOR;\n+            ScanParams params = new ScanParams();\n+            params.count(logQueryLimit);\n+            params.match(getGlobalKeyByXid(\"*\"));\n+            ScanResult<String> scans;\n+            do {\n+                scans = jedis.scan(cursor, params);\n+                keys.addAll(scans.getResult().stream().collect(Collectors.toSet()));\n+                cursor = scans.getCursor();\n+            } while (!INITIAL_CURSOR.equals(cursor));\n+            if (CollectionUtils.isNotEmpty(keys)) {\n+                List<GlobalTransactionDO> globalTransactionDOs = new ArrayList<>();\n+                for (String globalKey : keys) {\n+                    GlobalTransactionDO globalTransactionDO =\n+                        JSON.parseObject(jedis.get(globalKey), GlobalTransactionDO.class);\n+                    if (null != globalTransactionDO && states.contains(globalTransactionDO.getStatus())) {\n+                        globalTransactionDOs.add(globalTransactionDO);\n+                    }\n+                }\n+                if (CollectionUtils.isNotEmpty(globalTransactionDOs)) {\n+                    List<String> xids =\n+                        globalTransactionDOs.stream().map(GlobalTransactionDO::getXid).collect(Collectors.toList());\n+                    List<BranchTransactionDO> branchTransactionDOs = new ArrayList<>();\n+                    for (String xid : xids) {\n+                        Set<String> branches = lRange(jedis, getBranchListKeyByXid(xid));\n+                        if (CollectionUtils.isNotEmpty(branches)) {\n+                            for (String branchKey : branches) {\n+                                String branchJson = jedis.get(branchKey);\n+                                if (StringUtils.isNotBlank(branchJson)) {\n+                                    branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                                }\n+                            }\n+                        }\n+                    }\n+                    Map<String, List<BranchTransactionDO>> branchTransactionDOsMap =\n+                        branchTransactionDOs.stream().collect(Collectors.groupingBy(BranchTransactionDO::getXid,\n+                            LinkedHashMap::new, Collectors.toList()));\n+                    return globalTransactionDOs.stream()\n+                        .map(globalTransactionDO -> getGlobalSession(globalTransactionDO,\n+                            branchTransactionDOsMap.get(globalTransactionDO.getXid())))\n+                        .collect(Collectors.toList());\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public List<GlobalSession> readSession(SessionCondition sessionCondition) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            if (StringUtils.isNotBlank(sessionCondition.getXid())) {\n+                globalSessionJson = jedis.get(getGlobalKeyByXid(sessionCondition.getXid()));\n+                if (StringUtils.isNotBlank(globalSessionJson)) {\n+                    GlobalSession session =\n+                        convertGlobalSession(JSON.parseObject(globalSessionJson, GlobalTransactionDO.class));\n+                    List<GlobalSession> globalSessions = new ArrayList<>();\n+                    globalSessions.add(session);\n+                    return globalSessions;\n+                }\n+            } else if (sessionCondition.getTransactionId() != null) {\n+                String global = jedis.get(getGlobalKeyByTransactionId(sessionCondition.getTransactionId()));\n+                if (StringUtils.isBlank(global)) {\n+                    return null;\n+                }\n+                GlobalTransactionDO globalTransactionDO = JSON.parseObject(global, GlobalTransactionDO.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg0MTM2OQ=="}, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 289}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NTk3MzIwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQxMzoyMjo1OVrOGcyi6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQxNzoyNDo1N1rOGc0Z4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg0MTQ0OA==", "bodyText": "Judge whether it is empty", "url": "https://github.com/seata/seata/pull/2484#discussion_r432841448", "createdAt": "2020-05-30T13:22:59Z", "author": {"login": "ph3636"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import com.alibaba.fastjson.JSON;\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String INITIAL_CURSOR = \"0\";\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    public RedisTransactionStoreManager() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            jedis.del(key);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            Pipeline pipeline = jedis.pipelined();\n+            if (jedis.get(key) == null) {\n+                pipeline.lpush(getBranchListKeyByXid(branchTransactionDO.getXid()), key);\n+            }\n+            pipeline.set(key, JSON.toJSONString(branchTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<String> keys = new ArrayList<>();\n+            keys.add(getGlobalKeyByXid(globalTransactionDO.getXid()));\n+            keys.add(getGlobalKeyByTransactionId(globalTransactionDO.getTransactionId()));\n+            keys.add(getBranchListKeyByXid(globalTransactionDO.getXid()));\n+            jedis.del(keys.toArray(new String[keys.size()]));\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String keys = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n+            Pipeline pipeline = jedis.pipelined();\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            keys = getGlobalKeyByTransactionId(convertGlobalTransactionDO.getTransactionId());\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @param withBranchSessions\n+     *            the withBranchSessions\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid, boolean withBranchSessions) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            globalSessionJson = jedis.get(getGlobalKeyByXid(xid));\n+            if (StringUtils.isBlank(globalSessionJson)) {\n+                return null;\n+            }\n+            // global transaction\n+            GlobalTransactionDO globalTransactionDO = JSON.parseObject(globalSessionJson, GlobalTransactionDO.class);\n+            if (globalTransactionDO == null) {\n+                return null;\n+            }\n+            // branch transactions\n+            List<BranchTransactionDO> branchTransactionDOs = null;\n+            // reduce rpc with db when branchRegister and getGlobalStatus\n+            if (withBranchSessions) {\n+                Set<String> keys = lRange(jedis, getBranchListKeyByXid(globalTransactionDO.getXid()));\n+                if (CollectionUtils.isNotEmpty(keys)) {\n+                    branchTransactionDOs = new ArrayList<>();\n+                    for (String s : keys) {\n+                        String branchJson = jedis.get(s);\n+                        if (StringUtils.isNotBlank(branchJson)) {\n+                            branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                        }\n+                    }\n+                }\n+            }\n+            return getGlobalSession(globalTransactionDO, branchTransactionDOs);\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid) {\n+        return this.readSession(xid, true);\n+    }\n+\n+    /**\n+     * Read session list.\n+     *\n+     * @param statuses\n+     *            the statuses\n+     * @return the list\n+     */\n+    public List<GlobalSession> readSession(GlobalStatus[] statuses) {\n+        List<Integer> states = new ArrayList<>();\n+        for (int i = 0; i < statuses.length; i++) {\n+            states.add(statuses[i].getCode());\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Set<String> keys = new HashSet<>();\n+            String cursor = INITIAL_CURSOR;\n+            ScanParams params = new ScanParams();\n+            params.count(logQueryLimit);\n+            params.match(getGlobalKeyByXid(\"*\"));\n+            ScanResult<String> scans;\n+            do {\n+                scans = jedis.scan(cursor, params);\n+                keys.addAll(scans.getResult().stream().collect(Collectors.toSet()));\n+                cursor = scans.getCursor();\n+            } while (!INITIAL_CURSOR.equals(cursor));\n+            if (CollectionUtils.isNotEmpty(keys)) {\n+                List<GlobalTransactionDO> globalTransactionDOs = new ArrayList<>();\n+                for (String globalKey : keys) {\n+                    GlobalTransactionDO globalTransactionDO =\n+                        JSON.parseObject(jedis.get(globalKey), GlobalTransactionDO.class);\n+                    if (null != globalTransactionDO && states.contains(globalTransactionDO.getStatus())) {\n+                        globalTransactionDOs.add(globalTransactionDO);\n+                    }\n+                }\n+                if (CollectionUtils.isNotEmpty(globalTransactionDOs)) {\n+                    List<String> xids =\n+                        globalTransactionDOs.stream().map(GlobalTransactionDO::getXid).collect(Collectors.toList());\n+                    List<BranchTransactionDO> branchTransactionDOs = new ArrayList<>();\n+                    for (String xid : xids) {\n+                        Set<String> branches = lRange(jedis, getBranchListKeyByXid(xid));\n+                        if (CollectionUtils.isNotEmpty(branches)) {\n+                            for (String branchKey : branches) {\n+                                String branchJson = jedis.get(branchKey);\n+                                if (StringUtils.isNotBlank(branchJson)) {\n+                                    branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                                }\n+                            }\n+                        }\n+                    }\n+                    Map<String, List<BranchTransactionDO>> branchTransactionDOsMap =\n+                        branchTransactionDOs.stream().collect(Collectors.groupingBy(BranchTransactionDO::getXid,\n+                            LinkedHashMap::new, Collectors.toList()));\n+                    return globalTransactionDOs.stream()\n+                        .map(globalTransactionDO -> getGlobalSession(globalTransactionDO,\n+                            branchTransactionDOsMap.get(globalTransactionDO.getXid())))\n+                        .collect(Collectors.toList());\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public List<GlobalSession> readSession(SessionCondition sessionCondition) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            if (StringUtils.isNotBlank(sessionCondition.getXid())) {\n+                globalSessionJson = jedis.get(getGlobalKeyByXid(sessionCondition.getXid()));\n+                if (StringUtils.isNotBlank(globalSessionJson)) {\n+                    GlobalSession session =\n+                        convertGlobalSession(JSON.parseObject(globalSessionJson, GlobalTransactionDO.class));\n+                    List<GlobalSession> globalSessions = new ArrayList<>();\n+                    globalSessions.add(session);\n+                    return globalSessions;\n+                }\n+            } else if (sessionCondition.getTransactionId() != null) {\n+                String global = jedis.get(getGlobalKeyByTransactionId(sessionCondition.getTransactionId()));\n+                if (StringUtils.isBlank(global)) {\n+                    return null;\n+                }\n+                GlobalTransactionDO globalTransactionDO = JSON.parseObject(global, GlobalTransactionDO.class);\n+                String branchKey = getBranchListKeyByXid(globalTransactionDO.getXid());\n+                Set<String> keys = lRange(jedis, branchKey);\n+                List<BranchTransactionDO> branchTransactionDOs = new ArrayList<>();\n+                if (CollectionUtils.isNotEmpty(keys)) {\n+                    for (String s : keys) {\n+                        String branchJson = jedis.get(s);\n+                        if (StringUtils.isNotBlank(branchJson)) {\n+                            branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 297}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3MTkwNw==", "bodyText": "ok", "url": "https://github.com/seata/seata/pull/2484#discussion_r432871907", "createdAt": "2020-05-30T17:24:57Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import com.alibaba.fastjson.JSON;\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String INITIAL_CURSOR = \"0\";\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    public RedisTransactionStoreManager() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            jedis.del(key);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            Pipeline pipeline = jedis.pipelined();\n+            if (jedis.get(key) == null) {\n+                pipeline.lpush(getBranchListKeyByXid(branchTransactionDO.getXid()), key);\n+            }\n+            pipeline.set(key, JSON.toJSONString(branchTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<String> keys = new ArrayList<>();\n+            keys.add(getGlobalKeyByXid(globalTransactionDO.getXid()));\n+            keys.add(getGlobalKeyByTransactionId(globalTransactionDO.getTransactionId()));\n+            keys.add(getBranchListKeyByXid(globalTransactionDO.getXid()));\n+            jedis.del(keys.toArray(new String[keys.size()]));\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String keys = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n+            Pipeline pipeline = jedis.pipelined();\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            keys = getGlobalKeyByTransactionId(convertGlobalTransactionDO.getTransactionId());\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @param withBranchSessions\n+     *            the withBranchSessions\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid, boolean withBranchSessions) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            globalSessionJson = jedis.get(getGlobalKeyByXid(xid));\n+            if (StringUtils.isBlank(globalSessionJson)) {\n+                return null;\n+            }\n+            // global transaction\n+            GlobalTransactionDO globalTransactionDO = JSON.parseObject(globalSessionJson, GlobalTransactionDO.class);\n+            if (globalTransactionDO == null) {\n+                return null;\n+            }\n+            // branch transactions\n+            List<BranchTransactionDO> branchTransactionDOs = null;\n+            // reduce rpc with db when branchRegister and getGlobalStatus\n+            if (withBranchSessions) {\n+                Set<String> keys = lRange(jedis, getBranchListKeyByXid(globalTransactionDO.getXid()));\n+                if (CollectionUtils.isNotEmpty(keys)) {\n+                    branchTransactionDOs = new ArrayList<>();\n+                    for (String s : keys) {\n+                        String branchJson = jedis.get(s);\n+                        if (StringUtils.isNotBlank(branchJson)) {\n+                            branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                        }\n+                    }\n+                }\n+            }\n+            return getGlobalSession(globalTransactionDO, branchTransactionDOs);\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid) {\n+        return this.readSession(xid, true);\n+    }\n+\n+    /**\n+     * Read session list.\n+     *\n+     * @param statuses\n+     *            the statuses\n+     * @return the list\n+     */\n+    public List<GlobalSession> readSession(GlobalStatus[] statuses) {\n+        List<Integer> states = new ArrayList<>();\n+        for (int i = 0; i < statuses.length; i++) {\n+            states.add(statuses[i].getCode());\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Set<String> keys = new HashSet<>();\n+            String cursor = INITIAL_CURSOR;\n+            ScanParams params = new ScanParams();\n+            params.count(logQueryLimit);\n+            params.match(getGlobalKeyByXid(\"*\"));\n+            ScanResult<String> scans;\n+            do {\n+                scans = jedis.scan(cursor, params);\n+                keys.addAll(scans.getResult().stream().collect(Collectors.toSet()));\n+                cursor = scans.getCursor();\n+            } while (!INITIAL_CURSOR.equals(cursor));\n+            if (CollectionUtils.isNotEmpty(keys)) {\n+                List<GlobalTransactionDO> globalTransactionDOs = new ArrayList<>();\n+                for (String globalKey : keys) {\n+                    GlobalTransactionDO globalTransactionDO =\n+                        JSON.parseObject(jedis.get(globalKey), GlobalTransactionDO.class);\n+                    if (null != globalTransactionDO && states.contains(globalTransactionDO.getStatus())) {\n+                        globalTransactionDOs.add(globalTransactionDO);\n+                    }\n+                }\n+                if (CollectionUtils.isNotEmpty(globalTransactionDOs)) {\n+                    List<String> xids =\n+                        globalTransactionDOs.stream().map(GlobalTransactionDO::getXid).collect(Collectors.toList());\n+                    List<BranchTransactionDO> branchTransactionDOs = new ArrayList<>();\n+                    for (String xid : xids) {\n+                        Set<String> branches = lRange(jedis, getBranchListKeyByXid(xid));\n+                        if (CollectionUtils.isNotEmpty(branches)) {\n+                            for (String branchKey : branches) {\n+                                String branchJson = jedis.get(branchKey);\n+                                if (StringUtils.isNotBlank(branchJson)) {\n+                                    branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                                }\n+                            }\n+                        }\n+                    }\n+                    Map<String, List<BranchTransactionDO>> branchTransactionDOsMap =\n+                        branchTransactionDOs.stream().collect(Collectors.groupingBy(BranchTransactionDO::getXid,\n+                            LinkedHashMap::new, Collectors.toList()));\n+                    return globalTransactionDOs.stream()\n+                        .map(globalTransactionDO -> getGlobalSession(globalTransactionDO,\n+                            branchTransactionDOsMap.get(globalTransactionDO.getXid())))\n+                        .collect(Collectors.toList());\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public List<GlobalSession> readSession(SessionCondition sessionCondition) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            if (StringUtils.isNotBlank(sessionCondition.getXid())) {\n+                globalSessionJson = jedis.get(getGlobalKeyByXid(sessionCondition.getXid()));\n+                if (StringUtils.isNotBlank(globalSessionJson)) {\n+                    GlobalSession session =\n+                        convertGlobalSession(JSON.parseObject(globalSessionJson, GlobalTransactionDO.class));\n+                    List<GlobalSession> globalSessions = new ArrayList<>();\n+                    globalSessions.add(session);\n+                    return globalSessions;\n+                }\n+            } else if (sessionCondition.getTransactionId() != null) {\n+                String global = jedis.get(getGlobalKeyByTransactionId(sessionCondition.getTransactionId()));\n+                if (StringUtils.isBlank(global)) {\n+                    return null;\n+                }\n+                GlobalTransactionDO globalTransactionDO = JSON.parseObject(global, GlobalTransactionDO.class);\n+                String branchKey = getBranchListKeyByXid(globalTransactionDO.getXid());\n+                Set<String> keys = lRange(jedis, branchKey);\n+                List<BranchTransactionDO> branchTransactionDOs = new ArrayList<>();\n+                if (CollectionUtils.isNotEmpty(keys)) {\n+                    for (String s : keys) {\n+                        String branchJson = jedis.get(s);\n+                        if (StringUtils.isNotBlank(branchJson)) {\n+                            branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg0MTQ0OA=="}, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 297}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NTk3MzMzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQxMzoyMzowOFrOGcyi-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQxNzoyNTowNFrOGc0Z9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg0MTQ2Ng==", "bodyText": "mget", "url": "https://github.com/seata/seata/pull/2484#discussion_r432841466", "createdAt": "2020-05-30T13:23:08Z", "author": {"login": "ph3636"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import com.alibaba.fastjson.JSON;\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String INITIAL_CURSOR = \"0\";\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    public RedisTransactionStoreManager() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            jedis.del(key);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            Pipeline pipeline = jedis.pipelined();\n+            if (jedis.get(key) == null) {\n+                pipeline.lpush(getBranchListKeyByXid(branchTransactionDO.getXid()), key);\n+            }\n+            pipeline.set(key, JSON.toJSONString(branchTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<String> keys = new ArrayList<>();\n+            keys.add(getGlobalKeyByXid(globalTransactionDO.getXid()));\n+            keys.add(getGlobalKeyByTransactionId(globalTransactionDO.getTransactionId()));\n+            keys.add(getBranchListKeyByXid(globalTransactionDO.getXid()));\n+            jedis.del(keys.toArray(new String[keys.size()]));\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String keys = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n+            Pipeline pipeline = jedis.pipelined();\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            keys = getGlobalKeyByTransactionId(convertGlobalTransactionDO.getTransactionId());\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @param withBranchSessions\n+     *            the withBranchSessions\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid, boolean withBranchSessions) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            globalSessionJson = jedis.get(getGlobalKeyByXid(xid));\n+            if (StringUtils.isBlank(globalSessionJson)) {\n+                return null;\n+            }\n+            // global transaction\n+            GlobalTransactionDO globalTransactionDO = JSON.parseObject(globalSessionJson, GlobalTransactionDO.class);\n+            if (globalTransactionDO == null) {\n+                return null;\n+            }\n+            // branch transactions\n+            List<BranchTransactionDO> branchTransactionDOs = null;\n+            // reduce rpc with db when branchRegister and getGlobalStatus\n+            if (withBranchSessions) {\n+                Set<String> keys = lRange(jedis, getBranchListKeyByXid(globalTransactionDO.getXid()));\n+                if (CollectionUtils.isNotEmpty(keys)) {\n+                    branchTransactionDOs = new ArrayList<>();\n+                    for (String s : keys) {\n+                        String branchJson = jedis.get(s);\n+                        if (StringUtils.isNotBlank(branchJson)) {\n+                            branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                        }\n+                    }\n+                }\n+            }\n+            return getGlobalSession(globalTransactionDO, branchTransactionDOs);\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid) {\n+        return this.readSession(xid, true);\n+    }\n+\n+    /**\n+     * Read session list.\n+     *\n+     * @param statuses\n+     *            the statuses\n+     * @return the list\n+     */\n+    public List<GlobalSession> readSession(GlobalStatus[] statuses) {\n+        List<Integer> states = new ArrayList<>();\n+        for (int i = 0; i < statuses.length; i++) {\n+            states.add(statuses[i].getCode());\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Set<String> keys = new HashSet<>();\n+            String cursor = INITIAL_CURSOR;\n+            ScanParams params = new ScanParams();\n+            params.count(logQueryLimit);\n+            params.match(getGlobalKeyByXid(\"*\"));\n+            ScanResult<String> scans;\n+            do {\n+                scans = jedis.scan(cursor, params);\n+                keys.addAll(scans.getResult().stream().collect(Collectors.toSet()));\n+                cursor = scans.getCursor();\n+            } while (!INITIAL_CURSOR.equals(cursor));\n+            if (CollectionUtils.isNotEmpty(keys)) {\n+                List<GlobalTransactionDO> globalTransactionDOs = new ArrayList<>();\n+                for (String globalKey : keys) {\n+                    GlobalTransactionDO globalTransactionDO =\n+                        JSON.parseObject(jedis.get(globalKey), GlobalTransactionDO.class);\n+                    if (null != globalTransactionDO && states.contains(globalTransactionDO.getStatus())) {\n+                        globalTransactionDOs.add(globalTransactionDO);\n+                    }\n+                }\n+                if (CollectionUtils.isNotEmpty(globalTransactionDOs)) {\n+                    List<String> xids =\n+                        globalTransactionDOs.stream().map(GlobalTransactionDO::getXid).collect(Collectors.toList());\n+                    List<BranchTransactionDO> branchTransactionDOs = new ArrayList<>();\n+                    for (String xid : xids) {\n+                        Set<String> branches = lRange(jedis, getBranchListKeyByXid(xid));\n+                        if (CollectionUtils.isNotEmpty(branches)) {\n+                            for (String branchKey : branches) {\n+                                String branchJson = jedis.get(branchKey);\n+                                if (StringUtils.isNotBlank(branchJson)) {\n+                                    branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                                }\n+                            }\n+                        }\n+                    }\n+                    Map<String, List<BranchTransactionDO>> branchTransactionDOsMap =\n+                        branchTransactionDOs.stream().collect(Collectors.groupingBy(BranchTransactionDO::getXid,\n+                            LinkedHashMap::new, Collectors.toList()));\n+                    return globalTransactionDOs.stream()\n+                        .map(globalTransactionDO -> getGlobalSession(globalTransactionDO,\n+                            branchTransactionDOsMap.get(globalTransactionDO.getXid())))\n+                        .collect(Collectors.toList());\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public List<GlobalSession> readSession(SessionCondition sessionCondition) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            if (StringUtils.isNotBlank(sessionCondition.getXid())) {\n+                globalSessionJson = jedis.get(getGlobalKeyByXid(sessionCondition.getXid()));\n+                if (StringUtils.isNotBlank(globalSessionJson)) {\n+                    GlobalSession session =\n+                        convertGlobalSession(JSON.parseObject(globalSessionJson, GlobalTransactionDO.class));\n+                    List<GlobalSession> globalSessions = new ArrayList<>();\n+                    globalSessions.add(session);\n+                    return globalSessions;\n+                }\n+            } else if (sessionCondition.getTransactionId() != null) {\n+                String global = jedis.get(getGlobalKeyByTransactionId(sessionCondition.getTransactionId()));\n+                if (StringUtils.isBlank(global)) {\n+                    return null;\n+                }\n+                GlobalTransactionDO globalTransactionDO = JSON.parseObject(global, GlobalTransactionDO.class);\n+                String branchKey = getBranchListKeyByXid(globalTransactionDO.getXid());\n+                Set<String> keys = lRange(jedis, branchKey);\n+                List<BranchTransactionDO> branchTransactionDOs = new ArrayList<>();\n+                if (CollectionUtils.isNotEmpty(keys)) {\n+                    for (String s : keys) {\n+                        String branchJson = jedis.get(s);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 295}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3MTkyNg==", "bodyText": "ok", "url": "https://github.com/seata/seata/pull/2484#discussion_r432871926", "createdAt": "2020-05-30T17:25:04Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import com.alibaba.fastjson.JSON;\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String INITIAL_CURSOR = \"0\";\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    public RedisTransactionStoreManager() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            jedis.del(key);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            Pipeline pipeline = jedis.pipelined();\n+            if (jedis.get(key) == null) {\n+                pipeline.lpush(getBranchListKeyByXid(branchTransactionDO.getXid()), key);\n+            }\n+            pipeline.set(key, JSON.toJSONString(branchTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<String> keys = new ArrayList<>();\n+            keys.add(getGlobalKeyByXid(globalTransactionDO.getXid()));\n+            keys.add(getGlobalKeyByTransactionId(globalTransactionDO.getTransactionId()));\n+            keys.add(getBranchListKeyByXid(globalTransactionDO.getXid()));\n+            jedis.del(keys.toArray(new String[keys.size()]));\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String keys = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n+            Pipeline pipeline = jedis.pipelined();\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            keys = getGlobalKeyByTransactionId(convertGlobalTransactionDO.getTransactionId());\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @param withBranchSessions\n+     *            the withBranchSessions\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid, boolean withBranchSessions) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            globalSessionJson = jedis.get(getGlobalKeyByXid(xid));\n+            if (StringUtils.isBlank(globalSessionJson)) {\n+                return null;\n+            }\n+            // global transaction\n+            GlobalTransactionDO globalTransactionDO = JSON.parseObject(globalSessionJson, GlobalTransactionDO.class);\n+            if (globalTransactionDO == null) {\n+                return null;\n+            }\n+            // branch transactions\n+            List<BranchTransactionDO> branchTransactionDOs = null;\n+            // reduce rpc with db when branchRegister and getGlobalStatus\n+            if (withBranchSessions) {\n+                Set<String> keys = lRange(jedis, getBranchListKeyByXid(globalTransactionDO.getXid()));\n+                if (CollectionUtils.isNotEmpty(keys)) {\n+                    branchTransactionDOs = new ArrayList<>();\n+                    for (String s : keys) {\n+                        String branchJson = jedis.get(s);\n+                        if (StringUtils.isNotBlank(branchJson)) {\n+                            branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                        }\n+                    }\n+                }\n+            }\n+            return getGlobalSession(globalTransactionDO, branchTransactionDOs);\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid) {\n+        return this.readSession(xid, true);\n+    }\n+\n+    /**\n+     * Read session list.\n+     *\n+     * @param statuses\n+     *            the statuses\n+     * @return the list\n+     */\n+    public List<GlobalSession> readSession(GlobalStatus[] statuses) {\n+        List<Integer> states = new ArrayList<>();\n+        for (int i = 0; i < statuses.length; i++) {\n+            states.add(statuses[i].getCode());\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Set<String> keys = new HashSet<>();\n+            String cursor = INITIAL_CURSOR;\n+            ScanParams params = new ScanParams();\n+            params.count(logQueryLimit);\n+            params.match(getGlobalKeyByXid(\"*\"));\n+            ScanResult<String> scans;\n+            do {\n+                scans = jedis.scan(cursor, params);\n+                keys.addAll(scans.getResult().stream().collect(Collectors.toSet()));\n+                cursor = scans.getCursor();\n+            } while (!INITIAL_CURSOR.equals(cursor));\n+            if (CollectionUtils.isNotEmpty(keys)) {\n+                List<GlobalTransactionDO> globalTransactionDOs = new ArrayList<>();\n+                for (String globalKey : keys) {\n+                    GlobalTransactionDO globalTransactionDO =\n+                        JSON.parseObject(jedis.get(globalKey), GlobalTransactionDO.class);\n+                    if (null != globalTransactionDO && states.contains(globalTransactionDO.getStatus())) {\n+                        globalTransactionDOs.add(globalTransactionDO);\n+                    }\n+                }\n+                if (CollectionUtils.isNotEmpty(globalTransactionDOs)) {\n+                    List<String> xids =\n+                        globalTransactionDOs.stream().map(GlobalTransactionDO::getXid).collect(Collectors.toList());\n+                    List<BranchTransactionDO> branchTransactionDOs = new ArrayList<>();\n+                    for (String xid : xids) {\n+                        Set<String> branches = lRange(jedis, getBranchListKeyByXid(xid));\n+                        if (CollectionUtils.isNotEmpty(branches)) {\n+                            for (String branchKey : branches) {\n+                                String branchJson = jedis.get(branchKey);\n+                                if (StringUtils.isNotBlank(branchJson)) {\n+                                    branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                                }\n+                            }\n+                        }\n+                    }\n+                    Map<String, List<BranchTransactionDO>> branchTransactionDOsMap =\n+                        branchTransactionDOs.stream().collect(Collectors.groupingBy(BranchTransactionDO::getXid,\n+                            LinkedHashMap::new, Collectors.toList()));\n+                    return globalTransactionDOs.stream()\n+                        .map(globalTransactionDO -> getGlobalSession(globalTransactionDO,\n+                            branchTransactionDOsMap.get(globalTransactionDO.getXid())))\n+                        .collect(Collectors.toList());\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public List<GlobalSession> readSession(SessionCondition sessionCondition) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            if (StringUtils.isNotBlank(sessionCondition.getXid())) {\n+                globalSessionJson = jedis.get(getGlobalKeyByXid(sessionCondition.getXid()));\n+                if (StringUtils.isNotBlank(globalSessionJson)) {\n+                    GlobalSession session =\n+                        convertGlobalSession(JSON.parseObject(globalSessionJson, GlobalTransactionDO.class));\n+                    List<GlobalSession> globalSessions = new ArrayList<>();\n+                    globalSessions.add(session);\n+                    return globalSessions;\n+                }\n+            } else if (sessionCondition.getTransactionId() != null) {\n+                String global = jedis.get(getGlobalKeyByTransactionId(sessionCondition.getTransactionId()));\n+                if (StringUtils.isBlank(global)) {\n+                    return null;\n+                }\n+                GlobalTransactionDO globalTransactionDO = JSON.parseObject(global, GlobalTransactionDO.class);\n+                String branchKey = getBranchListKeyByXid(globalTransactionDO.getXid());\n+                Set<String> keys = lRange(jedis, branchKey);\n+                List<BranchTransactionDO> branchTransactionDOs = new ArrayList<>();\n+                if (CollectionUtils.isNotEmpty(keys)) {\n+                    for (String s : keys) {\n+                        String branchJson = jedis.get(s);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg0MTQ2Ng=="}, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 295}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NTk3NDY5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQxMzoyNToyNVrOGcyjrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMVQxMjozNjoxOFrOGc4uZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg0MTY0NA==", "bodyText": "Put the above six lines of code to the next level", "url": "https://github.com/seata/seata/pull/2484#discussion_r432841644", "createdAt": "2020-05-30T13:25:25Z", "author": {"login": "ph3636"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import com.alibaba.fastjson.JSON;\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String INITIAL_CURSOR = \"0\";\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    public RedisTransactionStoreManager() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            jedis.del(key);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            Pipeline pipeline = jedis.pipelined();\n+            if (jedis.get(key) == null) {\n+                pipeline.lpush(getBranchListKeyByXid(branchTransactionDO.getXid()), key);\n+            }\n+            pipeline.set(key, JSON.toJSONString(branchTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<String> keys = new ArrayList<>();\n+            keys.add(getGlobalKeyByXid(globalTransactionDO.getXid()));\n+            keys.add(getGlobalKeyByTransactionId(globalTransactionDO.getTransactionId()));\n+            keys.add(getBranchListKeyByXid(globalTransactionDO.getXid()));\n+            jedis.del(keys.toArray(new String[keys.size()]));\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String keys = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n+            Pipeline pipeline = jedis.pipelined();\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            keys = getGlobalKeyByTransactionId(convertGlobalTransactionDO.getTransactionId());\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @param withBranchSessions\n+     *            the withBranchSessions\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid, boolean withBranchSessions) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            globalSessionJson = jedis.get(getGlobalKeyByXid(xid));\n+            if (StringUtils.isBlank(globalSessionJson)) {\n+                return null;\n+            }\n+            // global transaction\n+            GlobalTransactionDO globalTransactionDO = JSON.parseObject(globalSessionJson, GlobalTransactionDO.class);\n+            if (globalTransactionDO == null) {\n+                return null;\n+            }\n+            // branch transactions\n+            List<BranchTransactionDO> branchTransactionDOs = null;\n+            // reduce rpc with db when branchRegister and getGlobalStatus\n+            if (withBranchSessions) {\n+                Set<String> keys = lRange(jedis, getBranchListKeyByXid(globalTransactionDO.getXid()));\n+                if (CollectionUtils.isNotEmpty(keys)) {\n+                    branchTransactionDOs = new ArrayList<>();\n+                    for (String s : keys) {\n+                        String branchJson = jedis.get(s);\n+                        if (StringUtils.isNotBlank(branchJson)) {\n+                            branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                        }\n+                    }\n+                }\n+            }\n+            return getGlobalSession(globalTransactionDO, branchTransactionDOs);\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid) {\n+        return this.readSession(xid, true);\n+    }\n+\n+    /**\n+     * Read session list.\n+     *\n+     * @param statuses\n+     *            the statuses\n+     * @return the list\n+     */\n+    public List<GlobalSession> readSession(GlobalStatus[] statuses) {\n+        List<Integer> states = new ArrayList<>();\n+        for (int i = 0; i < statuses.length; i++) {\n+            states.add(statuses[i].getCode());\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Set<String> keys = new HashSet<>();\n+            String cursor = INITIAL_CURSOR;\n+            ScanParams params = new ScanParams();\n+            params.count(logQueryLimit);\n+            params.match(getGlobalKeyByXid(\"*\"));\n+            ScanResult<String> scans;\n+            do {\n+                scans = jedis.scan(cursor, params);\n+                keys.addAll(scans.getResult().stream().collect(Collectors.toSet()));\n+                cursor = scans.getCursor();\n+            } while (!INITIAL_CURSOR.equals(cursor));\n+            if (CollectionUtils.isNotEmpty(keys)) {\n+                List<GlobalTransactionDO> globalTransactionDOs = new ArrayList<>();\n+                for (String globalKey : keys) {\n+                    GlobalTransactionDO globalTransactionDO =\n+                        JSON.parseObject(jedis.get(globalKey), GlobalTransactionDO.class);\n+                    if (null != globalTransactionDO && states.contains(globalTransactionDO.getStatus())) {\n+                        globalTransactionDOs.add(globalTransactionDO);\n+                    }\n+                }\n+                if (CollectionUtils.isNotEmpty(globalTransactionDOs)) {\n+                    List<String> xids =\n+                        globalTransactionDOs.stream().map(GlobalTransactionDO::getXid).collect(Collectors.toList());\n+                    List<BranchTransactionDO> branchTransactionDOs = new ArrayList<>();\n+                    for (String xid : xids) {\n+                        Set<String> branches = lRange(jedis, getBranchListKeyByXid(xid));\n+                        if (CollectionUtils.isNotEmpty(branches)) {\n+                            for (String branchKey : branches) {\n+                                String branchJson = jedis.get(branchKey);\n+                                if (StringUtils.isNotBlank(branchJson)) {\n+                                    branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                                }\n+                            }\n+                        }\n+                    }\n+                    Map<String, List<BranchTransactionDO>> branchTransactionDOsMap =\n+                        branchTransactionDOs.stream().collect(Collectors.groupingBy(BranchTransactionDO::getXid,\n+                            LinkedHashMap::new, Collectors.toList()));\n+                    return globalTransactionDOs.stream()\n+                        .map(globalTransactionDO -> getGlobalSession(globalTransactionDO,\n+                            branchTransactionDOsMap.get(globalTransactionDO.getXid())))\n+                        .collect(Collectors.toList());\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public List<GlobalSession> readSession(SessionCondition sessionCondition) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            if (StringUtils.isNotBlank(sessionCondition.getXid())) {\n+                globalSessionJson = jedis.get(getGlobalKeyByXid(sessionCondition.getXid()));\n+                if (StringUtils.isNotBlank(globalSessionJson)) {\n+                    GlobalSession session =\n+                        convertGlobalSession(JSON.parseObject(globalSessionJson, GlobalTransactionDO.class));\n+                    List<GlobalSession> globalSessions = new ArrayList<>();\n+                    globalSessions.add(session);\n+                    return globalSessions;\n+                }\n+            } else if (sessionCondition.getTransactionId() != null) {\n+                String global = jedis.get(getGlobalKeyByTransactionId(sessionCondition.getTransactionId()));\n+                if (StringUtils.isBlank(global)) {\n+                    return null;\n+                }\n+                GlobalTransactionDO globalTransactionDO = JSON.parseObject(global, GlobalTransactionDO.class);\n+                String branchKey = getBranchListKeyByXid(globalTransactionDO.getXid());\n+                Set<String> keys = lRange(jedis, branchKey);\n+                List<BranchTransactionDO> branchTransactionDOs = new ArrayList<>();\n+                if (CollectionUtils.isNotEmpty(keys)) {\n+                    for (String s : keys) {\n+                        String branchJson = jedis.get(s);\n+                        if (StringUtils.isNotBlank(branchJson)) {\n+                            branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                        }\n+                    }\n+                    GlobalSession globalSession = getGlobalSession(globalTransactionDO, branchTransactionDOs);\n+                    if (globalSession != null) {\n+                        List<GlobalSession> globalSessions = new ArrayList<>();\n+                        globalSessions.add(globalSession);\n+                        return globalSessions;\n+                    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 305}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3MjQ1MQ==", "bodyText": "ok", "url": "https://github.com/seata/seata/pull/2484#discussion_r432872451", "createdAt": "2020-05-30T17:32:52Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import com.alibaba.fastjson.JSON;\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String INITIAL_CURSOR = \"0\";\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    public RedisTransactionStoreManager() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            jedis.del(key);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            Pipeline pipeline = jedis.pipelined();\n+            if (jedis.get(key) == null) {\n+                pipeline.lpush(getBranchListKeyByXid(branchTransactionDO.getXid()), key);\n+            }\n+            pipeline.set(key, JSON.toJSONString(branchTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<String> keys = new ArrayList<>();\n+            keys.add(getGlobalKeyByXid(globalTransactionDO.getXid()));\n+            keys.add(getGlobalKeyByTransactionId(globalTransactionDO.getTransactionId()));\n+            keys.add(getBranchListKeyByXid(globalTransactionDO.getXid()));\n+            jedis.del(keys.toArray(new String[keys.size()]));\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String keys = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n+            Pipeline pipeline = jedis.pipelined();\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            keys = getGlobalKeyByTransactionId(convertGlobalTransactionDO.getTransactionId());\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @param withBranchSessions\n+     *            the withBranchSessions\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid, boolean withBranchSessions) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            globalSessionJson = jedis.get(getGlobalKeyByXid(xid));\n+            if (StringUtils.isBlank(globalSessionJson)) {\n+                return null;\n+            }\n+            // global transaction\n+            GlobalTransactionDO globalTransactionDO = JSON.parseObject(globalSessionJson, GlobalTransactionDO.class);\n+            if (globalTransactionDO == null) {\n+                return null;\n+            }\n+            // branch transactions\n+            List<BranchTransactionDO> branchTransactionDOs = null;\n+            // reduce rpc with db when branchRegister and getGlobalStatus\n+            if (withBranchSessions) {\n+                Set<String> keys = lRange(jedis, getBranchListKeyByXid(globalTransactionDO.getXid()));\n+                if (CollectionUtils.isNotEmpty(keys)) {\n+                    branchTransactionDOs = new ArrayList<>();\n+                    for (String s : keys) {\n+                        String branchJson = jedis.get(s);\n+                        if (StringUtils.isNotBlank(branchJson)) {\n+                            branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                        }\n+                    }\n+                }\n+            }\n+            return getGlobalSession(globalTransactionDO, branchTransactionDOs);\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid) {\n+        return this.readSession(xid, true);\n+    }\n+\n+    /**\n+     * Read session list.\n+     *\n+     * @param statuses\n+     *            the statuses\n+     * @return the list\n+     */\n+    public List<GlobalSession> readSession(GlobalStatus[] statuses) {\n+        List<Integer> states = new ArrayList<>();\n+        for (int i = 0; i < statuses.length; i++) {\n+            states.add(statuses[i].getCode());\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Set<String> keys = new HashSet<>();\n+            String cursor = INITIAL_CURSOR;\n+            ScanParams params = new ScanParams();\n+            params.count(logQueryLimit);\n+            params.match(getGlobalKeyByXid(\"*\"));\n+            ScanResult<String> scans;\n+            do {\n+                scans = jedis.scan(cursor, params);\n+                keys.addAll(scans.getResult().stream().collect(Collectors.toSet()));\n+                cursor = scans.getCursor();\n+            } while (!INITIAL_CURSOR.equals(cursor));\n+            if (CollectionUtils.isNotEmpty(keys)) {\n+                List<GlobalTransactionDO> globalTransactionDOs = new ArrayList<>();\n+                for (String globalKey : keys) {\n+                    GlobalTransactionDO globalTransactionDO =\n+                        JSON.parseObject(jedis.get(globalKey), GlobalTransactionDO.class);\n+                    if (null != globalTransactionDO && states.contains(globalTransactionDO.getStatus())) {\n+                        globalTransactionDOs.add(globalTransactionDO);\n+                    }\n+                }\n+                if (CollectionUtils.isNotEmpty(globalTransactionDOs)) {\n+                    List<String> xids =\n+                        globalTransactionDOs.stream().map(GlobalTransactionDO::getXid).collect(Collectors.toList());\n+                    List<BranchTransactionDO> branchTransactionDOs = new ArrayList<>();\n+                    for (String xid : xids) {\n+                        Set<String> branches = lRange(jedis, getBranchListKeyByXid(xid));\n+                        if (CollectionUtils.isNotEmpty(branches)) {\n+                            for (String branchKey : branches) {\n+                                String branchJson = jedis.get(branchKey);\n+                                if (StringUtils.isNotBlank(branchJson)) {\n+                                    branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                                }\n+                            }\n+                        }\n+                    }\n+                    Map<String, List<BranchTransactionDO>> branchTransactionDOsMap =\n+                        branchTransactionDOs.stream().collect(Collectors.groupingBy(BranchTransactionDO::getXid,\n+                            LinkedHashMap::new, Collectors.toList()));\n+                    return globalTransactionDOs.stream()\n+                        .map(globalTransactionDO -> getGlobalSession(globalTransactionDO,\n+                            branchTransactionDOsMap.get(globalTransactionDO.getXid())))\n+                        .collect(Collectors.toList());\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public List<GlobalSession> readSession(SessionCondition sessionCondition) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            if (StringUtils.isNotBlank(sessionCondition.getXid())) {\n+                globalSessionJson = jedis.get(getGlobalKeyByXid(sessionCondition.getXid()));\n+                if (StringUtils.isNotBlank(globalSessionJson)) {\n+                    GlobalSession session =\n+                        convertGlobalSession(JSON.parseObject(globalSessionJson, GlobalTransactionDO.class));\n+                    List<GlobalSession> globalSessions = new ArrayList<>();\n+                    globalSessions.add(session);\n+                    return globalSessions;\n+                }\n+            } else if (sessionCondition.getTransactionId() != null) {\n+                String global = jedis.get(getGlobalKeyByTransactionId(sessionCondition.getTransactionId()));\n+                if (StringUtils.isBlank(global)) {\n+                    return null;\n+                }\n+                GlobalTransactionDO globalTransactionDO = JSON.parseObject(global, GlobalTransactionDO.class);\n+                String branchKey = getBranchListKeyByXid(globalTransactionDO.getXid());\n+                Set<String> keys = lRange(jedis, branchKey);\n+                List<BranchTransactionDO> branchTransactionDOs = new ArrayList<>();\n+                if (CollectionUtils.isNotEmpty(keys)) {\n+                    for (String s : keys) {\n+                        String branchJson = jedis.get(s);\n+                        if (StringUtils.isNotBlank(branchJson)) {\n+                            branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                        }\n+                    }\n+                    GlobalSession globalSession = getGlobalSession(globalTransactionDO, branchTransactionDOs);\n+                    if (globalSession != null) {\n+                        List<GlobalSession> globalSessions = new ArrayList<>();\n+                        globalSessions.add(globalSession);\n+                        return globalSessions;\n+                    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg0MTY0NA=="}, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 305}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk0MjY5Mg==", "bodyText": "this", "url": "https://github.com/seata/seata/pull/2484#discussion_r432942692", "createdAt": "2020-05-31T12:36:18Z", "author": {"login": "ph3636"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import com.alibaba.fastjson.JSON;\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String INITIAL_CURSOR = \"0\";\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    public RedisTransactionStoreManager() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            jedis.del(key);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            Pipeline pipeline = jedis.pipelined();\n+            if (jedis.get(key) == null) {\n+                pipeline.lpush(getBranchListKeyByXid(branchTransactionDO.getXid()), key);\n+            }\n+            pipeline.set(key, JSON.toJSONString(branchTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<String> keys = new ArrayList<>();\n+            keys.add(getGlobalKeyByXid(globalTransactionDO.getXid()));\n+            keys.add(getGlobalKeyByTransactionId(globalTransactionDO.getTransactionId()));\n+            keys.add(getBranchListKeyByXid(globalTransactionDO.getXid()));\n+            jedis.del(keys.toArray(new String[keys.size()]));\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String keys = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n+            Pipeline pipeline = jedis.pipelined();\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            keys = getGlobalKeyByTransactionId(convertGlobalTransactionDO.getTransactionId());\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @param withBranchSessions\n+     *            the withBranchSessions\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid, boolean withBranchSessions) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            globalSessionJson = jedis.get(getGlobalKeyByXid(xid));\n+            if (StringUtils.isBlank(globalSessionJson)) {\n+                return null;\n+            }\n+            // global transaction\n+            GlobalTransactionDO globalTransactionDO = JSON.parseObject(globalSessionJson, GlobalTransactionDO.class);\n+            if (globalTransactionDO == null) {\n+                return null;\n+            }\n+            // branch transactions\n+            List<BranchTransactionDO> branchTransactionDOs = null;\n+            // reduce rpc with db when branchRegister and getGlobalStatus\n+            if (withBranchSessions) {\n+                Set<String> keys = lRange(jedis, getBranchListKeyByXid(globalTransactionDO.getXid()));\n+                if (CollectionUtils.isNotEmpty(keys)) {\n+                    branchTransactionDOs = new ArrayList<>();\n+                    for (String s : keys) {\n+                        String branchJson = jedis.get(s);\n+                        if (StringUtils.isNotBlank(branchJson)) {\n+                            branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                        }\n+                    }\n+                }\n+            }\n+            return getGlobalSession(globalTransactionDO, branchTransactionDOs);\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid) {\n+        return this.readSession(xid, true);\n+    }\n+\n+    /**\n+     * Read session list.\n+     *\n+     * @param statuses\n+     *            the statuses\n+     * @return the list\n+     */\n+    public List<GlobalSession> readSession(GlobalStatus[] statuses) {\n+        List<Integer> states = new ArrayList<>();\n+        for (int i = 0; i < statuses.length; i++) {\n+            states.add(statuses[i].getCode());\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Set<String> keys = new HashSet<>();\n+            String cursor = INITIAL_CURSOR;\n+            ScanParams params = new ScanParams();\n+            params.count(logQueryLimit);\n+            params.match(getGlobalKeyByXid(\"*\"));\n+            ScanResult<String> scans;\n+            do {\n+                scans = jedis.scan(cursor, params);\n+                keys.addAll(scans.getResult().stream().collect(Collectors.toSet()));\n+                cursor = scans.getCursor();\n+            } while (!INITIAL_CURSOR.equals(cursor));\n+            if (CollectionUtils.isNotEmpty(keys)) {\n+                List<GlobalTransactionDO> globalTransactionDOs = new ArrayList<>();\n+                for (String globalKey : keys) {\n+                    GlobalTransactionDO globalTransactionDO =\n+                        JSON.parseObject(jedis.get(globalKey), GlobalTransactionDO.class);\n+                    if (null != globalTransactionDO && states.contains(globalTransactionDO.getStatus())) {\n+                        globalTransactionDOs.add(globalTransactionDO);\n+                    }\n+                }\n+                if (CollectionUtils.isNotEmpty(globalTransactionDOs)) {\n+                    List<String> xids =\n+                        globalTransactionDOs.stream().map(GlobalTransactionDO::getXid).collect(Collectors.toList());\n+                    List<BranchTransactionDO> branchTransactionDOs = new ArrayList<>();\n+                    for (String xid : xids) {\n+                        Set<String> branches = lRange(jedis, getBranchListKeyByXid(xid));\n+                        if (CollectionUtils.isNotEmpty(branches)) {\n+                            for (String branchKey : branches) {\n+                                String branchJson = jedis.get(branchKey);\n+                                if (StringUtils.isNotBlank(branchJson)) {\n+                                    branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                                }\n+                            }\n+                        }\n+                    }\n+                    Map<String, List<BranchTransactionDO>> branchTransactionDOsMap =\n+                        branchTransactionDOs.stream().collect(Collectors.groupingBy(BranchTransactionDO::getXid,\n+                            LinkedHashMap::new, Collectors.toList()));\n+                    return globalTransactionDOs.stream()\n+                        .map(globalTransactionDO -> getGlobalSession(globalTransactionDO,\n+                            branchTransactionDOsMap.get(globalTransactionDO.getXid())))\n+                        .collect(Collectors.toList());\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public List<GlobalSession> readSession(SessionCondition sessionCondition) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            if (StringUtils.isNotBlank(sessionCondition.getXid())) {\n+                globalSessionJson = jedis.get(getGlobalKeyByXid(sessionCondition.getXid()));\n+                if (StringUtils.isNotBlank(globalSessionJson)) {\n+                    GlobalSession session =\n+                        convertGlobalSession(JSON.parseObject(globalSessionJson, GlobalTransactionDO.class));\n+                    List<GlobalSession> globalSessions = new ArrayList<>();\n+                    globalSessions.add(session);\n+                    return globalSessions;\n+                }\n+            } else if (sessionCondition.getTransactionId() != null) {\n+                String global = jedis.get(getGlobalKeyByTransactionId(sessionCondition.getTransactionId()));\n+                if (StringUtils.isBlank(global)) {\n+                    return null;\n+                }\n+                GlobalTransactionDO globalTransactionDO = JSON.parseObject(global, GlobalTransactionDO.class);\n+                String branchKey = getBranchListKeyByXid(globalTransactionDO.getXid());\n+                Set<String> keys = lRange(jedis, branchKey);\n+                List<BranchTransactionDO> branchTransactionDOs = new ArrayList<>();\n+                if (CollectionUtils.isNotEmpty(keys)) {\n+                    for (String s : keys) {\n+                        String branchJson = jedis.get(s);\n+                        if (StringUtils.isNotBlank(branchJson)) {\n+                            branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                        }\n+                    }\n+                    GlobalSession globalSession = getGlobalSession(globalTransactionDO, branchTransactionDOs);\n+                    if (globalSession != null) {\n+                        List<GlobalSession> globalSessions = new ArrayList<>();\n+                        globalSessions.add(globalSession);\n+                        return globalSessions;\n+                    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg0MTY0NA=="}, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 305}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NTk3NzQwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQxMzozMToyOVrOGcylHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMVQwNTowOTo0NlrOGc2wXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg0MjAxNQ==", "bodyText": "keys.addAll(scans.getResult());", "url": "https://github.com/seata/seata/pull/2484#discussion_r432842015", "createdAt": "2020-05-30T13:31:29Z", "author": {"login": "ph3636"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import com.alibaba.fastjson.JSON;\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String INITIAL_CURSOR = \"0\";\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    public RedisTransactionStoreManager() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            jedis.del(key);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            Pipeline pipeline = jedis.pipelined();\n+            if (jedis.get(key) == null) {\n+                pipeline.lpush(getBranchListKeyByXid(branchTransactionDO.getXid()), key);\n+            }\n+            pipeline.set(key, JSON.toJSONString(branchTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<String> keys = new ArrayList<>();\n+            keys.add(getGlobalKeyByXid(globalTransactionDO.getXid()));\n+            keys.add(getGlobalKeyByTransactionId(globalTransactionDO.getTransactionId()));\n+            keys.add(getBranchListKeyByXid(globalTransactionDO.getXid()));\n+            jedis.del(keys.toArray(new String[keys.size()]));\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String keys = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n+            Pipeline pipeline = jedis.pipelined();\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            keys = getGlobalKeyByTransactionId(convertGlobalTransactionDO.getTransactionId());\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @param withBranchSessions\n+     *            the withBranchSessions\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid, boolean withBranchSessions) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            globalSessionJson = jedis.get(getGlobalKeyByXid(xid));\n+            if (StringUtils.isBlank(globalSessionJson)) {\n+                return null;\n+            }\n+            // global transaction\n+            GlobalTransactionDO globalTransactionDO = JSON.parseObject(globalSessionJson, GlobalTransactionDO.class);\n+            if (globalTransactionDO == null) {\n+                return null;\n+            }\n+            // branch transactions\n+            List<BranchTransactionDO> branchTransactionDOs = null;\n+            // reduce rpc with db when branchRegister and getGlobalStatus\n+            if (withBranchSessions) {\n+                Set<String> keys = lRange(jedis, getBranchListKeyByXid(globalTransactionDO.getXid()));\n+                if (CollectionUtils.isNotEmpty(keys)) {\n+                    branchTransactionDOs = new ArrayList<>();\n+                    for (String s : keys) {\n+                        String branchJson = jedis.get(s);\n+                        if (StringUtils.isNotBlank(branchJson)) {\n+                            branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                        }\n+                    }\n+                }\n+            }\n+            return getGlobalSession(globalTransactionDO, branchTransactionDOs);\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid) {\n+        return this.readSession(xid, true);\n+    }\n+\n+    /**\n+     * Read session list.\n+     *\n+     * @param statuses\n+     *            the statuses\n+     * @return the list\n+     */\n+    public List<GlobalSession> readSession(GlobalStatus[] statuses) {\n+        List<Integer> states = new ArrayList<>();\n+        for (int i = 0; i < statuses.length; i++) {\n+            states.add(statuses[i].getCode());\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Set<String> keys = new HashSet<>();\n+            String cursor = INITIAL_CURSOR;\n+            ScanParams params = new ScanParams();\n+            params.count(logQueryLimit);\n+            params.match(getGlobalKeyByXid(\"*\"));\n+            ScanResult<String> scans;\n+            do {\n+                scans = jedis.scan(cursor, params);\n+                keys.addAll(scans.getResult().stream().collect(Collectors.toSet()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 231}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3MjAyMQ==", "bodyText": "keys.addAll(scans.getResult());\n\nthis to get rid of duplicate keys", "url": "https://github.com/seata/seata/pull/2484#discussion_r432872021", "createdAt": "2020-05-30T17:26:15Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import com.alibaba.fastjson.JSON;\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String INITIAL_CURSOR = \"0\";\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    public RedisTransactionStoreManager() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            jedis.del(key);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            Pipeline pipeline = jedis.pipelined();\n+            if (jedis.get(key) == null) {\n+                pipeline.lpush(getBranchListKeyByXid(branchTransactionDO.getXid()), key);\n+            }\n+            pipeline.set(key, JSON.toJSONString(branchTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<String> keys = new ArrayList<>();\n+            keys.add(getGlobalKeyByXid(globalTransactionDO.getXid()));\n+            keys.add(getGlobalKeyByTransactionId(globalTransactionDO.getTransactionId()));\n+            keys.add(getBranchListKeyByXid(globalTransactionDO.getXid()));\n+            jedis.del(keys.toArray(new String[keys.size()]));\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String keys = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n+            Pipeline pipeline = jedis.pipelined();\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            keys = getGlobalKeyByTransactionId(convertGlobalTransactionDO.getTransactionId());\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @param withBranchSessions\n+     *            the withBranchSessions\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid, boolean withBranchSessions) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            globalSessionJson = jedis.get(getGlobalKeyByXid(xid));\n+            if (StringUtils.isBlank(globalSessionJson)) {\n+                return null;\n+            }\n+            // global transaction\n+            GlobalTransactionDO globalTransactionDO = JSON.parseObject(globalSessionJson, GlobalTransactionDO.class);\n+            if (globalTransactionDO == null) {\n+                return null;\n+            }\n+            // branch transactions\n+            List<BranchTransactionDO> branchTransactionDOs = null;\n+            // reduce rpc with db when branchRegister and getGlobalStatus\n+            if (withBranchSessions) {\n+                Set<String> keys = lRange(jedis, getBranchListKeyByXid(globalTransactionDO.getXid()));\n+                if (CollectionUtils.isNotEmpty(keys)) {\n+                    branchTransactionDOs = new ArrayList<>();\n+                    for (String s : keys) {\n+                        String branchJson = jedis.get(s);\n+                        if (StringUtils.isNotBlank(branchJson)) {\n+                            branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                        }\n+                    }\n+                }\n+            }\n+            return getGlobalSession(globalTransactionDO, branchTransactionDOs);\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid) {\n+        return this.readSession(xid, true);\n+    }\n+\n+    /**\n+     * Read session list.\n+     *\n+     * @param statuses\n+     *            the statuses\n+     * @return the list\n+     */\n+    public List<GlobalSession> readSession(GlobalStatus[] statuses) {\n+        List<Integer> states = new ArrayList<>();\n+        for (int i = 0; i < statuses.length; i++) {\n+            states.add(statuses[i].getCode());\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Set<String> keys = new HashSet<>();\n+            String cursor = INITIAL_CURSOR;\n+            ScanParams params = new ScanParams();\n+            params.count(logQueryLimit);\n+            params.match(getGlobalKeyByXid(\"*\"));\n+            ScanResult<String> scans;\n+            do {\n+                scans = jedis.scan(cursor, params);\n+                keys.addAll(scans.getResult().stream().collect(Collectors.toSet()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg0MjAxNQ=="}, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 231}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkxMDQzMQ==", "bodyText": "Set keys = new HashSet<>();", "url": "https://github.com/seata/seata/pull/2484#discussion_r432910431", "createdAt": "2020-05-31T05:09:46Z", "author": {"login": "ph3636"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import com.alibaba.fastjson.JSON;\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String INITIAL_CURSOR = \"0\";\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    public RedisTransactionStoreManager() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            jedis.del(key);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            Pipeline pipeline = jedis.pipelined();\n+            if (jedis.get(key) == null) {\n+                pipeline.lpush(getBranchListKeyByXid(branchTransactionDO.getXid()), key);\n+            }\n+            pipeline.set(key, JSON.toJSONString(branchTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<String> keys = new ArrayList<>();\n+            keys.add(getGlobalKeyByXid(globalTransactionDO.getXid()));\n+            keys.add(getGlobalKeyByTransactionId(globalTransactionDO.getTransactionId()));\n+            keys.add(getBranchListKeyByXid(globalTransactionDO.getXid()));\n+            jedis.del(keys.toArray(new String[keys.size()]));\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String keys = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n+            Pipeline pipeline = jedis.pipelined();\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            keys = getGlobalKeyByTransactionId(convertGlobalTransactionDO.getTransactionId());\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @param withBranchSessions\n+     *            the withBranchSessions\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid, boolean withBranchSessions) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            globalSessionJson = jedis.get(getGlobalKeyByXid(xid));\n+            if (StringUtils.isBlank(globalSessionJson)) {\n+                return null;\n+            }\n+            // global transaction\n+            GlobalTransactionDO globalTransactionDO = JSON.parseObject(globalSessionJson, GlobalTransactionDO.class);\n+            if (globalTransactionDO == null) {\n+                return null;\n+            }\n+            // branch transactions\n+            List<BranchTransactionDO> branchTransactionDOs = null;\n+            // reduce rpc with db when branchRegister and getGlobalStatus\n+            if (withBranchSessions) {\n+                Set<String> keys = lRange(jedis, getBranchListKeyByXid(globalTransactionDO.getXid()));\n+                if (CollectionUtils.isNotEmpty(keys)) {\n+                    branchTransactionDOs = new ArrayList<>();\n+                    for (String s : keys) {\n+                        String branchJson = jedis.get(s);\n+                        if (StringUtils.isNotBlank(branchJson)) {\n+                            branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                        }\n+                    }\n+                }\n+            }\n+            return getGlobalSession(globalTransactionDO, branchTransactionDOs);\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid) {\n+        return this.readSession(xid, true);\n+    }\n+\n+    /**\n+     * Read session list.\n+     *\n+     * @param statuses\n+     *            the statuses\n+     * @return the list\n+     */\n+    public List<GlobalSession> readSession(GlobalStatus[] statuses) {\n+        List<Integer> states = new ArrayList<>();\n+        for (int i = 0; i < statuses.length; i++) {\n+            states.add(statuses[i].getCode());\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Set<String> keys = new HashSet<>();\n+            String cursor = INITIAL_CURSOR;\n+            ScanParams params = new ScanParams();\n+            params.count(logQueryLimit);\n+            params.match(getGlobalKeyByXid(\"*\"));\n+            ScanResult<String> scans;\n+            do {\n+                scans = jedis.scan(cursor, params);\n+                keys.addAll(scans.getResult().stream().collect(Collectors.toSet()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg0MjAxNQ=="}, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 231}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NTk3OTMyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQxMzozNjo0NFrOGcymMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQxNzoyNjoyMlrOGc0aXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg0MjI4OQ==", "bodyText": "Judge whether it is empty", "url": "https://github.com/seata/seata/pull/2484#discussion_r432842289", "createdAt": "2020-05-30T13:36:44Z", "author": {"login": "ph3636"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import com.alibaba.fastjson.JSON;\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String INITIAL_CURSOR = \"0\";\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    public RedisTransactionStoreManager() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            jedis.del(key);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            Pipeline pipeline = jedis.pipelined();\n+            if (jedis.get(key) == null) {\n+                pipeline.lpush(getBranchListKeyByXid(branchTransactionDO.getXid()), key);\n+            }\n+            pipeline.set(key, JSON.toJSONString(branchTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<String> keys = new ArrayList<>();\n+            keys.add(getGlobalKeyByXid(globalTransactionDO.getXid()));\n+            keys.add(getGlobalKeyByTransactionId(globalTransactionDO.getTransactionId()));\n+            keys.add(getBranchListKeyByXid(globalTransactionDO.getXid()));\n+            jedis.del(keys.toArray(new String[keys.size()]));\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String keys = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n+            Pipeline pipeline = jedis.pipelined();\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            keys = getGlobalKeyByTransactionId(convertGlobalTransactionDO.getTransactionId());\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @param withBranchSessions\n+     *            the withBranchSessions\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid, boolean withBranchSessions) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            globalSessionJson = jedis.get(getGlobalKeyByXid(xid));\n+            if (StringUtils.isBlank(globalSessionJson)) {\n+                return null;\n+            }\n+            // global transaction\n+            GlobalTransactionDO globalTransactionDO = JSON.parseObject(globalSessionJson, GlobalTransactionDO.class);\n+            if (globalTransactionDO == null) {\n+                return null;\n+            }\n+            // branch transactions\n+            List<BranchTransactionDO> branchTransactionDOs = null;\n+            // reduce rpc with db when branchRegister and getGlobalStatus\n+            if (withBranchSessions) {\n+                Set<String> keys = lRange(jedis, getBranchListKeyByXid(globalTransactionDO.getXid()));\n+                if (CollectionUtils.isNotEmpty(keys)) {\n+                    branchTransactionDOs = new ArrayList<>();\n+                    for (String s : keys) {\n+                        String branchJson = jedis.get(s);\n+                        if (StringUtils.isNotBlank(branchJson)) {\n+                            branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                        }\n+                    }\n+                }\n+            }\n+            return getGlobalSession(globalTransactionDO, branchTransactionDOs);\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid) {\n+        return this.readSession(xid, true);\n+    }\n+\n+    /**\n+     * Read session list.\n+     *\n+     * @param statuses\n+     *            the statuses\n+     * @return the list\n+     */\n+    public List<GlobalSession> readSession(GlobalStatus[] statuses) {\n+        List<Integer> states = new ArrayList<>();\n+        for (int i = 0; i < statuses.length; i++) {\n+            states.add(statuses[i].getCode());\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Set<String> keys = new HashSet<>();\n+            String cursor = INITIAL_CURSOR;\n+            ScanParams params = new ScanParams();\n+            params.count(logQueryLimit);\n+            params.match(getGlobalKeyByXid(\"*\"));\n+            ScanResult<String> scans;\n+            do {\n+                scans = jedis.scan(cursor, params);\n+                keys.addAll(scans.getResult().stream().collect(Collectors.toSet()));\n+                cursor = scans.getCursor();\n+            } while (!INITIAL_CURSOR.equals(cursor));\n+            if (CollectionUtils.isNotEmpty(keys)) {\n+                List<GlobalTransactionDO> globalTransactionDOs = new ArrayList<>();\n+                for (String globalKey : keys) {\n+                    GlobalTransactionDO globalTransactionDO =\n+                        JSON.parseObject(jedis.get(globalKey), GlobalTransactionDO.class);\n+                    if (null != globalTransactionDO && states.contains(globalTransactionDO.getStatus())) {\n+                        globalTransactionDOs.add(globalTransactionDO);\n+                    }\n+                }\n+                if (CollectionUtils.isNotEmpty(globalTransactionDOs)) {\n+                    List<String> xids =\n+                        globalTransactionDOs.stream().map(GlobalTransactionDO::getXid).collect(Collectors.toList());\n+                    List<BranchTransactionDO> branchTransactionDOs = new ArrayList<>();\n+                    for (String xid : xids) {\n+                        Set<String> branches = lRange(jedis, getBranchListKeyByXid(xid));\n+                        if (CollectionUtils.isNotEmpty(branches)) {\n+                            for (String branchKey : branches) {\n+                                String branchJson = jedis.get(branchKey);\n+                                if (StringUtils.isNotBlank(branchJson)) {\n+                                    branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 253}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3MjAyOQ==", "bodyText": "ok", "url": "https://github.com/seata/seata/pull/2484#discussion_r432872029", "createdAt": "2020-05-30T17:26:22Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import com.alibaba.fastjson.JSON;\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String INITIAL_CURSOR = \"0\";\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    public RedisTransactionStoreManager() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            jedis.del(key);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            Pipeline pipeline = jedis.pipelined();\n+            if (jedis.get(key) == null) {\n+                pipeline.lpush(getBranchListKeyByXid(branchTransactionDO.getXid()), key);\n+            }\n+            pipeline.set(key, JSON.toJSONString(branchTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<String> keys = new ArrayList<>();\n+            keys.add(getGlobalKeyByXid(globalTransactionDO.getXid()));\n+            keys.add(getGlobalKeyByTransactionId(globalTransactionDO.getTransactionId()));\n+            keys.add(getBranchListKeyByXid(globalTransactionDO.getXid()));\n+            jedis.del(keys.toArray(new String[keys.size()]));\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String keys = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n+            Pipeline pipeline = jedis.pipelined();\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            keys = getGlobalKeyByTransactionId(convertGlobalTransactionDO.getTransactionId());\n+            pipeline.set(keys, JSON.toJSONString(convertGlobalTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @param withBranchSessions\n+     *            the withBranchSessions\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid, boolean withBranchSessions) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            globalSessionJson = jedis.get(getGlobalKeyByXid(xid));\n+            if (StringUtils.isBlank(globalSessionJson)) {\n+                return null;\n+            }\n+            // global transaction\n+            GlobalTransactionDO globalTransactionDO = JSON.parseObject(globalSessionJson, GlobalTransactionDO.class);\n+            if (globalTransactionDO == null) {\n+                return null;\n+            }\n+            // branch transactions\n+            List<BranchTransactionDO> branchTransactionDOs = null;\n+            // reduce rpc with db when branchRegister and getGlobalStatus\n+            if (withBranchSessions) {\n+                Set<String> keys = lRange(jedis, getBranchListKeyByXid(globalTransactionDO.getXid()));\n+                if (CollectionUtils.isNotEmpty(keys)) {\n+                    branchTransactionDOs = new ArrayList<>();\n+                    for (String s : keys) {\n+                        String branchJson = jedis.get(s);\n+                        if (StringUtils.isNotBlank(branchJson)) {\n+                            branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+                        }\n+                    }\n+                }\n+            }\n+            return getGlobalSession(globalTransactionDO, branchTransactionDOs);\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid) {\n+        return this.readSession(xid, true);\n+    }\n+\n+    /**\n+     * Read session list.\n+     *\n+     * @param statuses\n+     *            the statuses\n+     * @return the list\n+     */\n+    public List<GlobalSession> readSession(GlobalStatus[] statuses) {\n+        List<Integer> states = new ArrayList<>();\n+        for (int i = 0; i < statuses.length; i++) {\n+            states.add(statuses[i].getCode());\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Set<String> keys = new HashSet<>();\n+            String cursor = INITIAL_CURSOR;\n+            ScanParams params = new ScanParams();\n+            params.count(logQueryLimit);\n+            params.match(getGlobalKeyByXid(\"*\"));\n+            ScanResult<String> scans;\n+            do {\n+                scans = jedis.scan(cursor, params);\n+                keys.addAll(scans.getResult().stream().collect(Collectors.toSet()));\n+                cursor = scans.getCursor();\n+            } while (!INITIAL_CURSOR.equals(cursor));\n+            if (CollectionUtils.isNotEmpty(keys)) {\n+                List<GlobalTransactionDO> globalTransactionDOs = new ArrayList<>();\n+                for (String globalKey : keys) {\n+                    GlobalTransactionDO globalTransactionDO =\n+                        JSON.parseObject(jedis.get(globalKey), GlobalTransactionDO.class);\n+                    if (null != globalTransactionDO && states.contains(globalTransactionDO.getStatus())) {\n+                        globalTransactionDOs.add(globalTransactionDO);\n+                    }\n+                }\n+                if (CollectionUtils.isNotEmpty(globalTransactionDOs)) {\n+                    List<String> xids =\n+                        globalTransactionDOs.stream().map(GlobalTransactionDO::getXid).collect(Collectors.toList());\n+                    List<BranchTransactionDO> branchTransactionDOs = new ArrayList<>();\n+                    for (String xid : xids) {\n+                        Set<String> branches = lRange(jedis, getBranchListKeyByXid(xid));\n+                        if (CollectionUtils.isNotEmpty(branches)) {\n+                            for (String branchKey : branches) {\n+                                String branchJson = jedis.get(branchKey);\n+                                if (StringUtils.isNotBlank(branchJson)) {\n+                                    branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg0MjI4OQ=="}, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 253}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NTk4NjI4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQxMzo1MTozNFrOGcyp1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQxNzoyNjozMFrOGc0aZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg0MzIyMA==", "bodyText": "This method can be deleted", "url": "https://github.com/seata/seata/pull/2484#discussion_r432843220", "createdAt": "2020-05-30T13:51:34Z", "author": {"login": "ph3636"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.lock;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.LambdaUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.lock.AbstractLocker;\n+import io.seata.core.lock.RowLock;\n+import io.seata.core.store.LockDO;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.Transaction;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisLocker extends AbstractLocker {\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_PREFIX = \"SEATA_LOCK_\";\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX = \"SEATA_LOCK_XID_\";\n+\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    /**\n+     * Instantiates a new Redis locker.\n+     *\n+     */\n+    public RedisLocker() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    @Override\n+    public boolean acquireLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        Set<String> successList = new HashSet<>();\n+        long status = 1;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<LockDO> locks = convertToLockDO(rowLocks);\n+            if (locks.size() > 1) {\n+                locks =\n+                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            }\n+            Pipeline pipeline = jedis.pipelined();\n+            List<String> readyKeys = new ArrayList<>();\n+            for (LockDO lock : locks) {\n+                String key = getLockKey(lock.getRowKey());\n+                pipeline.setnx(key, JSON.toJSONString(lock));\n+                readyKeys.add(key);\n+            }\n+            List<Object> results = pipeline.syncAndReturnAll();\n+            for (int i = 0; i < results.size(); i++) {\n+                Long result = (long)results.get(i);\n+                String key = readyKeys.get(i);\n+                if (result != 1) {\n+                    status = result;\n+                } else {\n+                    successList.add(key);\n+                }\n+            }\n+            if (status != 1) {\n+                String[] rms = successList.toArray(new String[successList.size()]);\n+                if (rms.length > 0) {\n+                    jedis.del(rms);\n+                }\n+                return false;\n+            } else {\n+                Transaction multi = jedis.multi();\n+                try {\n+                    for (LockDO lock : locks) {\n+                        String xidLockKey = getXidLockKey(lock.getXid());\n+                        String key = getLockKey(lock.getRowKey());\n+                        multi.lpush(xidLockKey, key);\n+                    }\n+                } catch (Exception e) {\n+                    multi.discard();\n+                    return false;\n+                }\n+                multi.exec();\n+                return true;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        String[] keys = new String[rowLocks.size()];\n+        List<LockDO> locks = convertToLockDO(rowLocks);\n+        for (int i = 0; i < locks.size(); i++) {\n+            String key = getLockKey(locks.get(i).getRowKey());\n+            keys[i] = key;\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            jedis.del(keys);\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(String xid, List<Long> branchIds) {\n+        if (CollectionUtils.isEmpty(branchIds)) {\n+            // no lock\n+            return true;\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String lockListKey = getXidLockKey(xid);\n+            Set<String> keys = lRange(jedis, lockListKey);\n+            if (CollectionUtils.isNotEmpty(keys)) {\n+                Iterator<String> it = keys.iterator();\n+                while (it.hasNext()) {\n+                    String key = it.next();\n+                    LockDO lock = JSON.parseObject(jedis.get(key), LockDO.class);\n+                    for (int i = 0; i < branchIds.size(); i++) {\n+                        if (null != lock && Objects.equals(lock.getBranchId(), branchIds.get(i))) {\n+                            jedis.del(key);\n+                            jedis.lrem(lockListKey, 0, key);\n+                            it.remove();\n+                        }\n+                    }\n+                }\n+                if (keys.size() == 0) {\n+                    jedis.del(lockListKey);\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(String xid, Long branchId) {\n+        List<Long> branchIds = new ArrayList<>();\n+        branchIds.add(branchId);\n+        return releaseLock(xid, branchIds);\n+    }\n+\n+    @Override\n+    public boolean isLockable(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<LockDO> locks = convertToLockDO(rowLocks);\n+            for (LockDO rowlock : locks) {\n+                String rowlockJson = jedis.get(getLockKey(rowlock.getRowKey()));\n+                if (StringUtils.isNotBlank(rowlockJson)) {\n+                    LockDO lock = JSON.parseObject(rowlockJson, LockDO.class);\n+                    if (null != lock && !Objects.equals(lock.getXid(), rowlock.getXid())) {\n+                        return false;\n+                    }\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Convert to lock do list.\n+     *\n+     * @param locks\n+     *            the locks\n+     * @return the list\n+     */\n+    protected List<LockDO> convertToLockDO(List<RowLock> locks) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 204}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3MjAzNg==", "bodyText": "ok", "url": "https://github.com/seata/seata/pull/2484#discussion_r432872036", "createdAt": "2020-05-30T17:26:30Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.lock;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.LambdaUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.lock.AbstractLocker;\n+import io.seata.core.lock.RowLock;\n+import io.seata.core.store.LockDO;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.Transaction;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisLocker extends AbstractLocker {\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_PREFIX = \"SEATA_LOCK_\";\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX = \"SEATA_LOCK_XID_\";\n+\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    /**\n+     * Instantiates a new Redis locker.\n+     *\n+     */\n+    public RedisLocker() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    @Override\n+    public boolean acquireLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        Set<String> successList = new HashSet<>();\n+        long status = 1;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<LockDO> locks = convertToLockDO(rowLocks);\n+            if (locks.size() > 1) {\n+                locks =\n+                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            }\n+            Pipeline pipeline = jedis.pipelined();\n+            List<String> readyKeys = new ArrayList<>();\n+            for (LockDO lock : locks) {\n+                String key = getLockKey(lock.getRowKey());\n+                pipeline.setnx(key, JSON.toJSONString(lock));\n+                readyKeys.add(key);\n+            }\n+            List<Object> results = pipeline.syncAndReturnAll();\n+            for (int i = 0; i < results.size(); i++) {\n+                Long result = (long)results.get(i);\n+                String key = readyKeys.get(i);\n+                if (result != 1) {\n+                    status = result;\n+                } else {\n+                    successList.add(key);\n+                }\n+            }\n+            if (status != 1) {\n+                String[] rms = successList.toArray(new String[successList.size()]);\n+                if (rms.length > 0) {\n+                    jedis.del(rms);\n+                }\n+                return false;\n+            } else {\n+                Transaction multi = jedis.multi();\n+                try {\n+                    for (LockDO lock : locks) {\n+                        String xidLockKey = getXidLockKey(lock.getXid());\n+                        String key = getLockKey(lock.getRowKey());\n+                        multi.lpush(xidLockKey, key);\n+                    }\n+                } catch (Exception e) {\n+                    multi.discard();\n+                    return false;\n+                }\n+                multi.exec();\n+                return true;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        String[] keys = new String[rowLocks.size()];\n+        List<LockDO> locks = convertToLockDO(rowLocks);\n+        for (int i = 0; i < locks.size(); i++) {\n+            String key = getLockKey(locks.get(i).getRowKey());\n+            keys[i] = key;\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            jedis.del(keys);\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(String xid, List<Long> branchIds) {\n+        if (CollectionUtils.isEmpty(branchIds)) {\n+            // no lock\n+            return true;\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String lockListKey = getXidLockKey(xid);\n+            Set<String> keys = lRange(jedis, lockListKey);\n+            if (CollectionUtils.isNotEmpty(keys)) {\n+                Iterator<String> it = keys.iterator();\n+                while (it.hasNext()) {\n+                    String key = it.next();\n+                    LockDO lock = JSON.parseObject(jedis.get(key), LockDO.class);\n+                    for (int i = 0; i < branchIds.size(); i++) {\n+                        if (null != lock && Objects.equals(lock.getBranchId(), branchIds.get(i))) {\n+                            jedis.del(key);\n+                            jedis.lrem(lockListKey, 0, key);\n+                            it.remove();\n+                        }\n+                    }\n+                }\n+                if (keys.size() == 0) {\n+                    jedis.del(lockListKey);\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(String xid, Long branchId) {\n+        List<Long> branchIds = new ArrayList<>();\n+        branchIds.add(branchId);\n+        return releaseLock(xid, branchIds);\n+    }\n+\n+    @Override\n+    public boolean isLockable(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<LockDO> locks = convertToLockDO(rowLocks);\n+            for (LockDO rowlock : locks) {\n+                String rowlockJson = jedis.get(getLockKey(rowlock.getRowKey()));\n+                if (StringUtils.isNotBlank(rowlockJson)) {\n+                    LockDO lock = JSON.parseObject(rowlockJson, LockDO.class);\n+                    if (null != lock && !Objects.equals(lock.getXid(), rowlock.getXid())) {\n+                        return false;\n+                    }\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Convert to lock do list.\n+     *\n+     * @param locks\n+     *            the locks\n+     * @return the list\n+     */\n+    protected List<LockDO> convertToLockDO(List<RowLock> locks) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg0MzIyMA=="}, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 204}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NTk5ODc3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQxNDoxNTozMFrOGcywYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMVQxMjowNzozMlrOGc4lAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg0NDg5OA==", "bodyText": "change to [ String xidLockKey = getXidLockKey(locks.get(0).getXid());\nmulti.lpush(xidLockKey, readyKeys.toArray(new String[0]));]", "url": "https://github.com/seata/seata/pull/2484#discussion_r432844898", "createdAt": "2020-05-30T14:15:30Z", "author": {"login": "ph3636"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.lock;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.LambdaUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.lock.AbstractLocker;\n+import io.seata.core.lock.RowLock;\n+import io.seata.core.store.LockDO;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.Transaction;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisLocker extends AbstractLocker {\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_PREFIX = \"SEATA_LOCK_\";\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX = \"SEATA_LOCK_XID_\";\n+\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    /**\n+     * Instantiates a new Redis locker.\n+     *\n+     */\n+    public RedisLocker() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    @Override\n+    public boolean acquireLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        Set<String> successList = new HashSet<>();\n+        long status = 1;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<LockDO> locks = convertToLockDO(rowLocks);\n+            if (locks.size() > 1) {\n+                locks =\n+                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            }\n+            Pipeline pipeline = jedis.pipelined();\n+            List<String> readyKeys = new ArrayList<>();\n+            for (LockDO lock : locks) {\n+                String key = getLockKey(lock.getRowKey());\n+                pipeline.setnx(key, JSON.toJSONString(lock));\n+                readyKeys.add(key);\n+            }\n+            List<Object> results = pipeline.syncAndReturnAll();\n+            for (int i = 0; i < results.size(); i++) {\n+                Long result = (long)results.get(i);\n+                String key = readyKeys.get(i);\n+                if (result != 1) {\n+                    status = result;\n+                } else {\n+                    successList.add(key);\n+                }\n+            }\n+            if (status != 1) {\n+                String[] rms = successList.toArray(new String[successList.size()]);\n+                if (rms.length > 0) {\n+                    jedis.del(rms);\n+                }\n+                return false;\n+            } else {\n+                Transaction multi = jedis.multi();\n+                try {\n+                    for (LockDO lock : locks) {\n+                        String xidLockKey = getXidLockKey(lock.getXid());\n+                        String key = getLockKey(lock.getRowKey());\n+                        multi.lpush(xidLockKey, key);\n+                    }\n+                } catch (Exception e) {\n+                    multi.discard();\n+                    return false;\n+                }\n+                multi.exec();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3MjM0Ng==", "bodyText": "ok", "url": "https://github.com/seata/seata/pull/2484#discussion_r432872346", "createdAt": "2020-05-30T17:31:20Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.lock;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.LambdaUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.lock.AbstractLocker;\n+import io.seata.core.lock.RowLock;\n+import io.seata.core.store.LockDO;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.Transaction;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisLocker extends AbstractLocker {\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_PREFIX = \"SEATA_LOCK_\";\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX = \"SEATA_LOCK_XID_\";\n+\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    /**\n+     * Instantiates a new Redis locker.\n+     *\n+     */\n+    public RedisLocker() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    @Override\n+    public boolean acquireLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        Set<String> successList = new HashSet<>();\n+        long status = 1;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<LockDO> locks = convertToLockDO(rowLocks);\n+            if (locks.size() > 1) {\n+                locks =\n+                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            }\n+            Pipeline pipeline = jedis.pipelined();\n+            List<String> readyKeys = new ArrayList<>();\n+            for (LockDO lock : locks) {\n+                String key = getLockKey(lock.getRowKey());\n+                pipeline.setnx(key, JSON.toJSONString(lock));\n+                readyKeys.add(key);\n+            }\n+            List<Object> results = pipeline.syncAndReturnAll();\n+            for (int i = 0; i < results.size(); i++) {\n+                Long result = (long)results.get(i);\n+                String key = readyKeys.get(i);\n+                if (result != 1) {\n+                    status = result;\n+                } else {\n+                    successList.add(key);\n+                }\n+            }\n+            if (status != 1) {\n+                String[] rms = successList.toArray(new String[successList.size()]);\n+                if (rms.length > 0) {\n+                    jedis.del(rms);\n+                }\n+                return false;\n+            } else {\n+                Transaction multi = jedis.multi();\n+                try {\n+                    for (LockDO lock : locks) {\n+                        String xidLockKey = getXidLockKey(lock.getXid());\n+                        String key = getLockKey(lock.getRowKey());\n+                        multi.lpush(xidLockKey, key);\n+                    }\n+                } catch (Exception e) {\n+                    multi.discard();\n+                    return false;\n+                }\n+                multi.exec();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg0NDg5OA=="}, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk0MDI4OA==", "bodyText": "Transaction unnecessary", "url": "https://github.com/seata/seata/pull/2484#discussion_r432940288", "createdAt": "2020-05-31T12:07:32Z", "author": {"login": "ph3636"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.lock;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.LambdaUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.lock.AbstractLocker;\n+import io.seata.core.lock.RowLock;\n+import io.seata.core.store.LockDO;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.Transaction;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisLocker extends AbstractLocker {\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_PREFIX = \"SEATA_LOCK_\";\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX = \"SEATA_LOCK_XID_\";\n+\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    /**\n+     * Instantiates a new Redis locker.\n+     *\n+     */\n+    public RedisLocker() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    @Override\n+    public boolean acquireLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        Set<String> successList = new HashSet<>();\n+        long status = 1;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<LockDO> locks = convertToLockDO(rowLocks);\n+            if (locks.size() > 1) {\n+                locks =\n+                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            }\n+            Pipeline pipeline = jedis.pipelined();\n+            List<String> readyKeys = new ArrayList<>();\n+            for (LockDO lock : locks) {\n+                String key = getLockKey(lock.getRowKey());\n+                pipeline.setnx(key, JSON.toJSONString(lock));\n+                readyKeys.add(key);\n+            }\n+            List<Object> results = pipeline.syncAndReturnAll();\n+            for (int i = 0; i < results.size(); i++) {\n+                Long result = (long)results.get(i);\n+                String key = readyKeys.get(i);\n+                if (result != 1) {\n+                    status = result;\n+                } else {\n+                    successList.add(key);\n+                }\n+            }\n+            if (status != 1) {\n+                String[] rms = successList.toArray(new String[successList.size()]);\n+                if (rms.length > 0) {\n+                    jedis.del(rms);\n+                }\n+                return false;\n+            } else {\n+                Transaction multi = jedis.multi();\n+                try {\n+                    for (LockDO lock : locks) {\n+                        String xidLockKey = getXidLockKey(lock.getXid());\n+                        String key = getLockKey(lock.getRowKey());\n+                        multi.lpush(xidLockKey, key);\n+                    }\n+                } catch (Exception e) {\n+                    multi.discard();\n+                    return false;\n+                }\n+                multi.exec();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg0NDg5OA=="}, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NjEzNTE1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQxNjoxMzozM1rOGc0Gwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMVQwNToxNjozNlrOGc2xow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg2NzAxMA==", "bodyText": "change to [Pipeline pipeline = jedis.pipelined();\npipeline.lrem(getBranchListKeyByXid(branchTransactionDO.getXid()), 0, key);\npipeline.del(key);\npipeline.sync();]", "url": "https://github.com/seata/seata/pull/2484#discussion_r432867010", "createdAt": "2020-05-30T16:13:33Z", "author": {"login": "ph3636"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import com.alibaba.fastjson.JSON;\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String INITIAL_CURSOR = \"0\";\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    public RedisTransactionStoreManager() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            jedis.del(key);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3MjExOA==", "bodyText": "global transactions are deleted when they are deleted, so it doesn't seem to have a bad effect", "url": "https://github.com/seata/seata/pull/2484#discussion_r432872118", "createdAt": "2020-05-30T17:27:52Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import com.alibaba.fastjson.JSON;\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String INITIAL_CURSOR = \"0\";\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    public RedisTransactionStoreManager() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            jedis.del(key);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg2NzAxMA=="}, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkxMDc1NQ==", "bodyText": "The intermediate process may be inconsistent because deleting a branch does not necessarily delete the transaction immediately", "url": "https://github.com/seata/seata/pull/2484#discussion_r432910755", "createdAt": "2020-05-31T05:16:36Z", "author": {"login": "ph3636"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import com.alibaba.fastjson.JSON;\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String INITIAL_CURSOR = \"0\";\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    public RedisTransactionStoreManager() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            jedis.del(key);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg2NzAxMA=="}, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 116}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NjEzOTkwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQxNjoyMjoyOFrOGc0JGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQxNzoyODo1MlrOGc0a9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg2NzYwOQ==", "bodyText": "change to [String xidLockKey = getXidLockKey(locks.get(0).getXid());\nPipeline pipeline = jedis.pipelined();\npipeline.del(keys);\nArrays.stream(keys).forEach(key -> pipeline.lrem(xidLockKey, 0, key));\npipeline.exec();]", "url": "https://github.com/seata/seata/pull/2484#discussion_r432867609", "createdAt": "2020-05-30T16:22:28Z", "author": {"login": "ph3636"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.lock;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.LambdaUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.lock.AbstractLocker;\n+import io.seata.core.lock.RowLock;\n+import io.seata.core.store.LockDO;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.Transaction;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisLocker extends AbstractLocker {\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_PREFIX = \"SEATA_LOCK_\";\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX = \"SEATA_LOCK_XID_\";\n+\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    /**\n+     * Instantiates a new Redis locker.\n+     *\n+     */\n+    public RedisLocker() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    @Override\n+    public boolean acquireLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        Set<String> successList = new HashSet<>();\n+        long status = 1;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<LockDO> locks = convertToLockDO(rowLocks);\n+            if (locks.size() > 1) {\n+                locks =\n+                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            }\n+            Pipeline pipeline = jedis.pipelined();\n+            List<String> readyKeys = new ArrayList<>();\n+            for (LockDO lock : locks) {\n+                String key = getLockKey(lock.getRowKey());\n+                pipeline.setnx(key, JSON.toJSONString(lock));\n+                readyKeys.add(key);\n+            }\n+            List<Object> results = pipeline.syncAndReturnAll();\n+            for (int i = 0; i < results.size(); i++) {\n+                Long result = (long)results.get(i);\n+                String key = readyKeys.get(i);\n+                if (result != 1) {\n+                    status = result;\n+                } else {\n+                    successList.add(key);\n+                }\n+            }\n+            if (status != 1) {\n+                String[] rms = successList.toArray(new String[successList.size()]);\n+                if (rms.length > 0) {\n+                    jedis.del(rms);\n+                }\n+                return false;\n+            } else {\n+                Transaction multi = jedis.multi();\n+                try {\n+                    for (LockDO lock : locks) {\n+                        String xidLockKey = getXidLockKey(lock.getXid());\n+                        String key = getLockKey(lock.getRowKey());\n+                        multi.lpush(xidLockKey, key);\n+                    }\n+                } catch (Exception e) {\n+                    multi.discard();\n+                    return false;\n+                }\n+                multi.exec();\n+                return true;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        String[] keys = new String[rowLocks.size()];\n+        List<LockDO> locks = convertToLockDO(rowLocks);\n+        for (int i = 0; i < locks.size(); i++) {\n+            String key = getLockKey(locks.get(i).getRowKey());\n+            keys[i] = key;\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            jedis.del(keys);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3MjE4Mg==", "bodyText": "ok", "url": "https://github.com/seata/seata/pull/2484#discussion_r432872182", "createdAt": "2020-05-30T17:28:52Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.lock;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.LambdaUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.lock.AbstractLocker;\n+import io.seata.core.lock.RowLock;\n+import io.seata.core.store.LockDO;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.Transaction;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisLocker extends AbstractLocker {\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_PREFIX = \"SEATA_LOCK_\";\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX = \"SEATA_LOCK_XID_\";\n+\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    /**\n+     * Instantiates a new Redis locker.\n+     *\n+     */\n+    public RedisLocker() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    @Override\n+    public boolean acquireLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        Set<String> successList = new HashSet<>();\n+        long status = 1;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<LockDO> locks = convertToLockDO(rowLocks);\n+            if (locks.size() > 1) {\n+                locks =\n+                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            }\n+            Pipeline pipeline = jedis.pipelined();\n+            List<String> readyKeys = new ArrayList<>();\n+            for (LockDO lock : locks) {\n+                String key = getLockKey(lock.getRowKey());\n+                pipeline.setnx(key, JSON.toJSONString(lock));\n+                readyKeys.add(key);\n+            }\n+            List<Object> results = pipeline.syncAndReturnAll();\n+            for (int i = 0; i < results.size(); i++) {\n+                Long result = (long)results.get(i);\n+                String key = readyKeys.get(i);\n+                if (result != 1) {\n+                    status = result;\n+                } else {\n+                    successList.add(key);\n+                }\n+            }\n+            if (status != 1) {\n+                String[] rms = successList.toArray(new String[successList.size()]);\n+                if (rms.length > 0) {\n+                    jedis.del(rms);\n+                }\n+                return false;\n+            } else {\n+                Transaction multi = jedis.multi();\n+                try {\n+                    for (LockDO lock : locks) {\n+                        String xidLockKey = getXidLockKey(lock.getXid());\n+                        String key = getLockKey(lock.getRowKey());\n+                        multi.lpush(xidLockKey, key);\n+                    }\n+                } catch (Exception e) {\n+                    multi.discard();\n+                    return false;\n+                }\n+                multi.exec();\n+                return true;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        String[] keys = new String[rowLocks.size()];\n+        List<LockDO> locks = convertToLockDO(rowLocks);\n+        for (int i = 0; i < locks.size(); i++) {\n+            String key = getLockKey(locks.get(i).getRowKey());\n+            keys[i] = key;\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            jedis.del(keys);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg2NzYwOQ=="}, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 134}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NjE2NTIyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQxNzoxMDo0M1rOGc0V-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQxNzozMDoyM1rOGc0bVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3MDkwNw==", "bodyText": "Change the following to [List list = jedis.mget(keys.toArray(new String[0]));\nif (CollectionUtils.isNotEmpty(list)) {\nPipeline pipeline = null;\nSet branchIdSet = new HashSet<>(branchIds);\nint i = 0;\nfor (String key : keys) {\nLockDO lock = JSON.parseObject(jedis.get(list.get(i)), LockDO.class);\nif (null != lock && branchIdSet.contains(lock.getBranchId())) {\nif (pipeline == null) {\npipeline = jedis.pipelined();\n}\njedis.del(key);\njedis.lrem(lockListKey, 0, key);\n}\ni++;\n}\nif (pipeline != null) {\npipeline.exec();\n}\n}]", "url": "https://github.com/seata/seata/pull/2484#discussion_r432870907", "createdAt": "2020-05-30T17:10:43Z", "author": {"login": "ph3636"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.lock;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.LambdaUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.lock.AbstractLocker;\n+import io.seata.core.lock.RowLock;\n+import io.seata.core.store.LockDO;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.Transaction;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisLocker extends AbstractLocker {\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_PREFIX = \"SEATA_LOCK_\";\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX = \"SEATA_LOCK_XID_\";\n+\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    /**\n+     * Instantiates a new Redis locker.\n+     *\n+     */\n+    public RedisLocker() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    @Override\n+    public boolean acquireLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        Set<String> successList = new HashSet<>();\n+        long status = 1;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<LockDO> locks = convertToLockDO(rowLocks);\n+            if (locks.size() > 1) {\n+                locks =\n+                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            }\n+            Pipeline pipeline = jedis.pipelined();\n+            List<String> readyKeys = new ArrayList<>();\n+            for (LockDO lock : locks) {\n+                String key = getLockKey(lock.getRowKey());\n+                pipeline.setnx(key, JSON.toJSONString(lock));\n+                readyKeys.add(key);\n+            }\n+            List<Object> results = pipeline.syncAndReturnAll();\n+            for (int i = 0; i < results.size(); i++) {\n+                Long result = (long)results.get(i);\n+                String key = readyKeys.get(i);\n+                if (result != 1) {\n+                    status = result;\n+                } else {\n+                    successList.add(key);\n+                }\n+            }\n+            if (status != 1) {\n+                String[] rms = successList.toArray(new String[successList.size()]);\n+                if (rms.length > 0) {\n+                    jedis.del(rms);\n+                }\n+                return false;\n+            } else {\n+                Transaction multi = jedis.multi();\n+                try {\n+                    for (LockDO lock : locks) {\n+                        String xidLockKey = getXidLockKey(lock.getXid());\n+                        String key = getLockKey(lock.getRowKey());\n+                        multi.lpush(xidLockKey, key);\n+                    }\n+                } catch (Exception e) {\n+                    multi.discard();\n+                    return false;\n+                }\n+                multi.exec();\n+                return true;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        String[] keys = new String[rowLocks.size()];\n+        List<LockDO> locks = convertToLockDO(rowLocks);\n+        for (int i = 0; i < locks.size(); i++) {\n+            String key = getLockKey(locks.get(i).getRowKey());\n+            keys[i] = key;\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            jedis.del(keys);\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(String xid, List<Long> branchIds) {\n+        if (CollectionUtils.isEmpty(branchIds)) {\n+            // no lock\n+            return true;\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String lockListKey = getXidLockKey(xid);\n+            Set<String> keys = lRange(jedis, lockListKey);\n+            if (CollectionUtils.isNotEmpty(keys)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3MjI3OA==", "bodyText": "ok", "url": "https://github.com/seata/seata/pull/2484#discussion_r432872278", "createdAt": "2020-05-30T17:30:23Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.lock;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.LambdaUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.lock.AbstractLocker;\n+import io.seata.core.lock.RowLock;\n+import io.seata.core.store.LockDO;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.Transaction;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisLocker extends AbstractLocker {\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_PREFIX = \"SEATA_LOCK_\";\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX = \"SEATA_LOCK_XID_\";\n+\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    /**\n+     * Instantiates a new Redis locker.\n+     *\n+     */\n+    public RedisLocker() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    @Override\n+    public boolean acquireLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        Set<String> successList = new HashSet<>();\n+        long status = 1;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<LockDO> locks = convertToLockDO(rowLocks);\n+            if (locks.size() > 1) {\n+                locks =\n+                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            }\n+            Pipeline pipeline = jedis.pipelined();\n+            List<String> readyKeys = new ArrayList<>();\n+            for (LockDO lock : locks) {\n+                String key = getLockKey(lock.getRowKey());\n+                pipeline.setnx(key, JSON.toJSONString(lock));\n+                readyKeys.add(key);\n+            }\n+            List<Object> results = pipeline.syncAndReturnAll();\n+            for (int i = 0; i < results.size(); i++) {\n+                Long result = (long)results.get(i);\n+                String key = readyKeys.get(i);\n+                if (result != 1) {\n+                    status = result;\n+                } else {\n+                    successList.add(key);\n+                }\n+            }\n+            if (status != 1) {\n+                String[] rms = successList.toArray(new String[successList.size()]);\n+                if (rms.length > 0) {\n+                    jedis.del(rms);\n+                }\n+                return false;\n+            } else {\n+                Transaction multi = jedis.multi();\n+                try {\n+                    for (LockDO lock : locks) {\n+                        String xidLockKey = getXidLockKey(lock.getXid());\n+                        String key = getLockKey(lock.getRowKey());\n+                        multi.lpush(xidLockKey, key);\n+                    }\n+                } catch (Exception e) {\n+                    multi.discard();\n+                    return false;\n+                }\n+                multi.exec();\n+                return true;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        String[] keys = new String[rowLocks.size()];\n+        List<LockDO> locks = convertToLockDO(rowLocks);\n+        for (int i = 0; i < locks.size(); i++) {\n+            String key = getLockKey(locks.get(i).getRowKey());\n+            keys[i] = key;\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            jedis.del(keys);\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(String xid, List<Long> branchIds) {\n+        if (CollectionUtils.isEmpty(branchIds)) {\n+            // no lock\n+            return true;\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String lockListKey = getXidLockKey(xid);\n+            Set<String> keys = lRange(jedis, lockListKey);\n+            if (CollectionUtils.isNotEmpty(keys)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3MDkwNw=="}, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 148}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NjE2ODc3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQxNzoxNjo0MlrOGc0Xqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQxNzoyOTo1MVrOGc0bKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3MTMzOQ==", "bodyText": "mget", "url": "https://github.com/seata/seata/pull/2484#discussion_r432871339", "createdAt": "2020-05-30T17:16:42Z", "author": {"login": "ph3636"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.lock;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.LambdaUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.lock.AbstractLocker;\n+import io.seata.core.lock.RowLock;\n+import io.seata.core.store.LockDO;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.Transaction;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisLocker extends AbstractLocker {\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_PREFIX = \"SEATA_LOCK_\";\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX = \"SEATA_LOCK_XID_\";\n+\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    /**\n+     * Instantiates a new Redis locker.\n+     *\n+     */\n+    public RedisLocker() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    @Override\n+    public boolean acquireLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        Set<String> successList = new HashSet<>();\n+        long status = 1;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<LockDO> locks = convertToLockDO(rowLocks);\n+            if (locks.size() > 1) {\n+                locks =\n+                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            }\n+            Pipeline pipeline = jedis.pipelined();\n+            List<String> readyKeys = new ArrayList<>();\n+            for (LockDO lock : locks) {\n+                String key = getLockKey(lock.getRowKey());\n+                pipeline.setnx(key, JSON.toJSONString(lock));\n+                readyKeys.add(key);\n+            }\n+            List<Object> results = pipeline.syncAndReturnAll();\n+            for (int i = 0; i < results.size(); i++) {\n+                Long result = (long)results.get(i);\n+                String key = readyKeys.get(i);\n+                if (result != 1) {\n+                    status = result;\n+                } else {\n+                    successList.add(key);\n+                }\n+            }\n+            if (status != 1) {\n+                String[] rms = successList.toArray(new String[successList.size()]);\n+                if (rms.length > 0) {\n+                    jedis.del(rms);\n+                }\n+                return false;\n+            } else {\n+                Transaction multi = jedis.multi();\n+                try {\n+                    for (LockDO lock : locks) {\n+                        String xidLockKey = getXidLockKey(lock.getXid());\n+                        String key = getLockKey(lock.getRowKey());\n+                        multi.lpush(xidLockKey, key);\n+                    }\n+                } catch (Exception e) {\n+                    multi.discard();\n+                    return false;\n+                }\n+                multi.exec();\n+                return true;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        String[] keys = new String[rowLocks.size()];\n+        List<LockDO> locks = convertToLockDO(rowLocks);\n+        for (int i = 0; i < locks.size(); i++) {\n+            String key = getLockKey(locks.get(i).getRowKey());\n+            keys[i] = key;\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            jedis.del(keys);\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(String xid, List<Long> branchIds) {\n+        if (CollectionUtils.isEmpty(branchIds)) {\n+            // no lock\n+            return true;\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String lockListKey = getXidLockKey(xid);\n+            Set<String> keys = lRange(jedis, lockListKey);\n+            if (CollectionUtils.isNotEmpty(keys)) {\n+                Iterator<String> it = keys.iterator();\n+                while (it.hasNext()) {\n+                    String key = it.next();\n+                    LockDO lock = JSON.parseObject(jedis.get(key), LockDO.class);\n+                    for (int i = 0; i < branchIds.size(); i++) {\n+                        if (null != lock && Objects.equals(lock.getBranchId(), branchIds.get(i))) {\n+                            jedis.del(key);\n+                            jedis.lrem(lockListKey, 0, key);\n+                            it.remove();\n+                        }\n+                    }\n+                }\n+                if (keys.size() == 0) {\n+                    jedis.del(lockListKey);\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(String xid, Long branchId) {\n+        List<Long> branchIds = new ArrayList<>();\n+        branchIds.add(branchId);\n+        return releaseLock(xid, branchIds);\n+    }\n+\n+    @Override\n+    public boolean isLockable(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<LockDO> locks = convertToLockDO(rowLocks);\n+            for (LockDO rowlock : locks) {\n+                String rowlockJson = jedis.get(getLockKey(rowlock.getRowKey()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 185}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3MjIzNA==", "bodyText": "ok", "url": "https://github.com/seata/seata/pull/2484#discussion_r432872234", "createdAt": "2020-05-30T17:29:51Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.lock;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.alibaba.fastjson.JSON;\n+\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.LambdaUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.lock.AbstractLocker;\n+import io.seata.core.lock.RowLock;\n+import io.seata.core.store.LockDO;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.Transaction;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisLocker extends AbstractLocker {\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_PREFIX = \"SEATA_LOCK_\";\n+\n+    private static final String DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX = \"SEATA_LOCK_XID_\";\n+\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit;\n+\n+    /**\n+     * Instantiates a new Redis locker.\n+     *\n+     */\n+    public RedisLocker() {\n+        logQueryLimit =\n+            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+    }\n+\n+    @Override\n+    public boolean acquireLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        Set<String> successList = new HashSet<>();\n+        long status = 1;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<LockDO> locks = convertToLockDO(rowLocks);\n+            if (locks.size() > 1) {\n+                locks =\n+                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            }\n+            Pipeline pipeline = jedis.pipelined();\n+            List<String> readyKeys = new ArrayList<>();\n+            for (LockDO lock : locks) {\n+                String key = getLockKey(lock.getRowKey());\n+                pipeline.setnx(key, JSON.toJSONString(lock));\n+                readyKeys.add(key);\n+            }\n+            List<Object> results = pipeline.syncAndReturnAll();\n+            for (int i = 0; i < results.size(); i++) {\n+                Long result = (long)results.get(i);\n+                String key = readyKeys.get(i);\n+                if (result != 1) {\n+                    status = result;\n+                } else {\n+                    successList.add(key);\n+                }\n+            }\n+            if (status != 1) {\n+                String[] rms = successList.toArray(new String[successList.size()]);\n+                if (rms.length > 0) {\n+                    jedis.del(rms);\n+                }\n+                return false;\n+            } else {\n+                Transaction multi = jedis.multi();\n+                try {\n+                    for (LockDO lock : locks) {\n+                        String xidLockKey = getXidLockKey(lock.getXid());\n+                        String key = getLockKey(lock.getRowKey());\n+                        multi.lpush(xidLockKey, key);\n+                    }\n+                } catch (Exception e) {\n+                    multi.discard();\n+                    return false;\n+                }\n+                multi.exec();\n+                return true;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        String[] keys = new String[rowLocks.size()];\n+        List<LockDO> locks = convertToLockDO(rowLocks);\n+        for (int i = 0; i < locks.size(); i++) {\n+            String key = getLockKey(locks.get(i).getRowKey());\n+            keys[i] = key;\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            jedis.del(keys);\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(String xid, List<Long> branchIds) {\n+        if (CollectionUtils.isEmpty(branchIds)) {\n+            // no lock\n+            return true;\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String lockListKey = getXidLockKey(xid);\n+            Set<String> keys = lRange(jedis, lockListKey);\n+            if (CollectionUtils.isNotEmpty(keys)) {\n+                Iterator<String> it = keys.iterator();\n+                while (it.hasNext()) {\n+                    String key = it.next();\n+                    LockDO lock = JSON.parseObject(jedis.get(key), LockDO.class);\n+                    for (int i = 0; i < branchIds.size(); i++) {\n+                        if (null != lock && Objects.equals(lock.getBranchId(), branchIds.get(i))) {\n+                            jedis.del(key);\n+                            jedis.lrem(lockListKey, 0, key);\n+                            it.remove();\n+                        }\n+                    }\n+                }\n+                if (keys.size() == 0) {\n+                    jedis.del(lockListKey);\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public boolean releaseLock(String xid, Long branchId) {\n+        List<Long> branchIds = new ArrayList<>();\n+        branchIds.add(branchId);\n+        return releaseLock(xid, branchIds);\n+    }\n+\n+    @Override\n+    public boolean isLockable(List<RowLock> rowLocks) {\n+        if (CollectionUtils.isEmpty(rowLocks)) {\n+            // no lock\n+            return true;\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            List<LockDO> locks = convertToLockDO(rowLocks);\n+            for (LockDO rowlock : locks) {\n+                String rowlockJson = jedis.get(getLockKey(rowlock.getRowKey()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3MTMzOQ=="}, "originalCommit": {"oid": "e150d1b5472a1eb3ae50b5291d6a8cf691a0d56b"}, "originalPosition": 185}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NjcxMDQ4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMVQxMjozNzowN1rOGc4ukw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMVQxMjo0NjozM1rOGc4xwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk0MjczOQ==", "bodyText": "The object converted by JSON needs to be judged to be empty", "url": "https://github.com/seata/seata/pull/2484#discussion_r432942739", "createdAt": "2020-05-31T12:37:07Z", "author": {"login": "ph3636"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,413 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import com.alibaba.fastjson.JSON;\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String INITIAL_CURSOR = \"0\";\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit =\n+        ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);;\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            jedis.del(key);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            Pipeline pipeline = jedis.pipelined();\n+            if (jedis.get(key) == null) {\n+                pipeline.lpush(getBranchListKeyByXid(branchTransactionDO.getXid()), key);\n+            }\n+            pipeline.set(key, JSON.toJSONString(branchTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String[] keys = new String[3];\n+            keys[0] = getGlobalKeyByXid(globalTransactionDO.getXid());\n+            keys[1] = getGlobalKeyByTransactionId(globalTransactionDO.getTransactionId());\n+            keys[2] = getBranchListKeyByXid(globalTransactionDO.getXid());\n+            jedis.del(keys);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String keys = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n+            Pipeline pipeline = jedis.pipelined();\n+            String json = JSON.toJSONString(convertGlobalTransactionDO);\n+            pipeline.set(keys, json);\n+            keys = getGlobalKeyByTransactionId(convertGlobalTransactionDO.getTransactionId());\n+            pipeline.set(keys, json);\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @param withBranchSessions\n+     *            the withBranchSessions\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid, boolean withBranchSessions) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            globalSessionJson = jedis.get(getGlobalKeyByXid(xid));\n+            if (StringUtils.isBlank(globalSessionJson)) {\n+                return null;\n+            }\n+            // global transaction\n+            GlobalTransactionDO globalTransactionDO = JSON.parseObject(globalSessionJson, GlobalTransactionDO.class);\n+            if (globalTransactionDO == null) {\n+                return null;\n+            }\n+            // branch transactions\n+            List<BranchTransactionDO> branchTransactionDOs = null;\n+            // reduce rpc with db when branchRegister and getGlobalStatus\n+            if (withBranchSessions) {\n+                Set<String> keys = lRange(jedis, getBranchListKeyByXid(globalTransactionDO.getXid()));\n+                if (CollectionUtils.isNotEmpty(keys)) {\n+                    branchTransactionDOs = getBranchJsons(jedis, keys);\n+                }\n+            }\n+            return getGlobalSession(globalTransactionDO, branchTransactionDOs);\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid) {\n+        return this.readSession(xid, true);\n+    }\n+\n+    /**\n+     * Read session list.\n+     *\n+     * @param statuses\n+     *            the statuses\n+     * @return the list\n+     */\n+    public List<GlobalSession> readSession(GlobalStatus[] statuses) {\n+        List<Integer> states = new ArrayList<>();\n+        for (int i = 0; i < statuses.length; i++) {\n+            states.add(statuses[i].getCode());\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Set<String> keys = new HashSet<>();\n+            String cursor = INITIAL_CURSOR;\n+            ScanParams params = new ScanParams();\n+            params.count(logQueryLimit);\n+            params.match(getGlobalKeyByXid(\"*\"));\n+            ScanResult<String> scans;\n+            do {\n+                scans = jedis.scan(cursor, params);\n+                keys.addAll(scans.getResult());\n+                cursor = scans.getCursor();\n+            } while (!INITIAL_CURSOR.equals(cursor));\n+            if (CollectionUtils.isNotEmpty(keys)) {\n+                List<GlobalTransactionDO> globalTransactionDOs = new ArrayList<>();\n+                for (String globalKey : keys) {\n+                    GlobalTransactionDO globalTransactionDO =\n+                        JSON.parseObject(jedis.get(globalKey), GlobalTransactionDO.class);\n+                    if (null != globalTransactionDO && states.contains(globalTransactionDO.getStatus())) {\n+                        globalTransactionDOs.add(globalTransactionDO);\n+                    }\n+                }\n+                if (CollectionUtils.isNotEmpty(globalTransactionDOs)) {\n+                    List<String> xids =\n+                        globalTransactionDOs.stream().map(GlobalTransactionDO::getXid).collect(Collectors.toList());\n+                    List<BranchTransactionDO> branchTransactionDOs = new ArrayList<>();\n+                    for (String xid : xids) {\n+                        Set<String> branches = lRange(jedis, getBranchListKeyByXid(xid));\n+                        if (CollectionUtils.isNotEmpty(branches)) {\n+                            branchTransactionDOs.addAll(getBranchJsons(jedis, branches));\n+                        }\n+                    }\n+                    Map<String, List<BranchTransactionDO>> branchTransactionDOsMap =\n+                        branchTransactionDOs.stream().collect(Collectors.groupingBy(BranchTransactionDO::getXid,\n+                            LinkedHashMap::new, Collectors.toList()));\n+                    return globalTransactionDOs.stream()\n+                        .map(globalTransactionDO -> getGlobalSession(globalTransactionDO,\n+                            branchTransactionDOsMap.get(globalTransactionDO.getXid())))\n+                        .collect(Collectors.toList());\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public List<GlobalSession> readSession(SessionCondition sessionCondition) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            if (!StringUtils.isEmpty(sessionCondition.getXid())) {\n+                String globalSessionJson = jedis.get(getGlobalKeyByXid(sessionCondition.getXid()));\n+                if (!StringUtils.isEmpty(globalSessionJson)) {\n+                    GlobalSession session =\n+                        convertGlobalSession(JSON.parseObject(globalSessionJson, GlobalTransactionDO.class));\n+                    List<GlobalSession> globalSessions = new ArrayList<>();\n+                    globalSessions.add(session);\n+                    return globalSessions;\n+                }\n+            } else if (sessionCondition.getTransactionId() != null) {\n+                String global = jedis.get(getGlobalKeyByTransactionId(sessionCondition.getTransactionId()));\n+                if (StringUtils.isEmpty(global)) {\n+                    return null;\n+                }\n+                GlobalTransactionDO globalTransactionDO = JSON.parseObject(global, GlobalTransactionDO.class);\n+                String branchKey = getBranchListKeyByXid(globalTransactionDO.getXid());\n+                Set<String> keys = lRange(jedis, branchKey);\n+                List<BranchTransactionDO> branchTransactionDOs;\n+                if (CollectionUtils.isNotEmpty(keys)) {\n+                    branchTransactionDOs = getBranchJsons(jedis, keys);\n+                    GlobalSession globalSession = getGlobalSession(globalTransactionDO, branchTransactionDOs);\n+                    if (globalSession != null) {\n+                        List<GlobalSession> globalSessions = new ArrayList<>();\n+                        globalSessions.add(globalSession);\n+                        return globalSessions;\n+                    }\n+                }\n+            } else if (CollectionUtils.isNotEmpty(sessionCondition.getStatuses())) {\n+                return readSession(sessionCondition.getStatuses());\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private List<BranchTransactionDO> getBranchJsons(Jedis jedis, Set<String> keys) {\n+        List<BranchTransactionDO> branchTransactionDOs = new ArrayList<>();\n+        List<String> branchJsons = jedis.mget(keys.toArray(new String[0]));\n+        for (String branchJson : branchJsons) {\n+            if (!StringUtils.isEmpty(branchJson)) {\n+                branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d22ce2ff2675d57c5883d57a6da6f6cf1883299c"}, "originalPosition": 299}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk0MzU1Mg==", "bodyText": "The object converted by JSON needs to be judged to be empty\n\nbranchJson not empty,that should be enough", "url": "https://github.com/seata/seata/pull/2484#discussion_r432943552", "createdAt": "2020-05-31T12:46:33Z", "author": {"login": "a364176773"}, "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -0,0 +1,413 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.storage.redis.store;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import com.alibaba.fastjson.JSON;\n+import io.seata.common.exception.StoreException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.StringUtils;\n+import io.seata.config.ConfigurationFactory;\n+import io.seata.core.constants.ConfigurationKeys;\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.session.SessionCondition;\n+import io.seata.server.storage.redis.JedisPooledFactory;\n+import io.seata.server.store.AbstractTransactionStoreManager;\n+import io.seata.server.store.SessionStorable;\n+import io.seata.server.store.TransactionStoreManager;\n+import redis.clients.jedis.Jedis;\n+import redis.clients.jedis.Pipeline;\n+import redis.clients.jedis.ScanParams;\n+import redis.clients.jedis.ScanResult;\n+\n+/**\n+ * @author funkye\n+ */\n+public class RedisTransactionStoreManager extends AbstractTransactionStoreManager implements TransactionStoreManager {\n+\n+    // global transaction prefix\n+    private static final String DEFAULT_REDIS_SEATA_GLOBAL_PREFIX = \"SEATA_GLOBAL_\";\n+\n+    // the prefix of the branchs transaction\n+    private static final String DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX = \"SEATA_XID_BRANCHS_\";\n+\n+    // the prefix of the branch transaction\n+    private static final String DEFAULT_REDIS_SEATA_BRANCH_PREFIX = \"SEATA_BRANCH_\";\n+\n+    // global transaction id PREFIX\n+    private static final String DEFAULT_SEATA_TRANSACTION_ID_GLOBAL_PREFIX = \"SEATA_TRANSACTION_ID_GLOBAL_\";\n+\n+    private static volatile RedisTransactionStoreManager instance;\n+\n+    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+\n+    private static final String INITIAL_CURSOR = \"0\";\n+    /**\n+     * The query limit.\n+     */\n+    private int logQueryLimit =\n+        ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);;\n+\n+    /**\n+     * Get the instance.\n+     */\n+    public static RedisTransactionStoreManager getInstance() {\n+        if (null == instance) {\n+            synchronized (RedisTransactionStoreManager.class) {\n+                if (null == instance) {\n+                    instance = new RedisTransactionStoreManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n+        if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n+            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+        } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n+            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n+            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+        } else {\n+            throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n+        }\n+    }\n+\n+    private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            jedis.del(key);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String key = getBranchKey(branchTransactionDO.getBranchId());\n+            Pipeline pipeline = jedis.pipelined();\n+            if (jedis.get(key) == null) {\n+                pipeline.lpush(getBranchListKeyByXid(branchTransactionDO.getXid()), key);\n+            }\n+            pipeline.set(key, JSON.toJSONString(branchTransactionDO));\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    private boolean deleteGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String[] keys = new String[3];\n+            keys[0] = getGlobalKeyByXid(globalTransactionDO.getXid());\n+            keys[1] = getGlobalKeyByTransactionId(globalTransactionDO.getTransactionId());\n+            keys[2] = getBranchListKeyByXid(globalTransactionDO.getXid());\n+            jedis.del(keys);\n+            return true;\n+        }\n+    }\n+\n+    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            String keys = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n+            Pipeline pipeline = jedis.pipelined();\n+            String json = JSON.toJSONString(convertGlobalTransactionDO);\n+            pipeline.set(keys, json);\n+            keys = getGlobalKeyByTransactionId(convertGlobalTransactionDO.getTransactionId());\n+            pipeline.set(keys, json);\n+            pipeline.sync();\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @param withBranchSessions\n+     *            the withBranchSessions\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid, boolean withBranchSessions) {\n+        String globalSessionJson;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            globalSessionJson = jedis.get(getGlobalKeyByXid(xid));\n+            if (StringUtils.isBlank(globalSessionJson)) {\n+                return null;\n+            }\n+            // global transaction\n+            GlobalTransactionDO globalTransactionDO = JSON.parseObject(globalSessionJson, GlobalTransactionDO.class);\n+            if (globalTransactionDO == null) {\n+                return null;\n+            }\n+            // branch transactions\n+            List<BranchTransactionDO> branchTransactionDOs = null;\n+            // reduce rpc with db when branchRegister and getGlobalStatus\n+            if (withBranchSessions) {\n+                Set<String> keys = lRange(jedis, getBranchListKeyByXid(globalTransactionDO.getXid()));\n+                if (CollectionUtils.isNotEmpty(keys)) {\n+                    branchTransactionDOs = getBranchJsons(jedis, keys);\n+                }\n+            }\n+            return getGlobalSession(globalTransactionDO, branchTransactionDOs);\n+        }\n+    }\n+\n+    /**\n+     * Read session global session.\n+     *\n+     * @param xid\n+     *            the xid\n+     * @return the global session\n+     */\n+    @Override\n+    public GlobalSession readSession(String xid) {\n+        return this.readSession(xid, true);\n+    }\n+\n+    /**\n+     * Read session list.\n+     *\n+     * @param statuses\n+     *            the statuses\n+     * @return the list\n+     */\n+    public List<GlobalSession> readSession(GlobalStatus[] statuses) {\n+        List<Integer> states = new ArrayList<>();\n+        for (int i = 0; i < statuses.length; i++) {\n+            states.add(statuses[i].getCode());\n+        }\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Set<String> keys = new HashSet<>();\n+            String cursor = INITIAL_CURSOR;\n+            ScanParams params = new ScanParams();\n+            params.count(logQueryLimit);\n+            params.match(getGlobalKeyByXid(\"*\"));\n+            ScanResult<String> scans;\n+            do {\n+                scans = jedis.scan(cursor, params);\n+                keys.addAll(scans.getResult());\n+                cursor = scans.getCursor();\n+            } while (!INITIAL_CURSOR.equals(cursor));\n+            if (CollectionUtils.isNotEmpty(keys)) {\n+                List<GlobalTransactionDO> globalTransactionDOs = new ArrayList<>();\n+                for (String globalKey : keys) {\n+                    GlobalTransactionDO globalTransactionDO =\n+                        JSON.parseObject(jedis.get(globalKey), GlobalTransactionDO.class);\n+                    if (null != globalTransactionDO && states.contains(globalTransactionDO.getStatus())) {\n+                        globalTransactionDOs.add(globalTransactionDO);\n+                    }\n+                }\n+                if (CollectionUtils.isNotEmpty(globalTransactionDOs)) {\n+                    List<String> xids =\n+                        globalTransactionDOs.stream().map(GlobalTransactionDO::getXid).collect(Collectors.toList());\n+                    List<BranchTransactionDO> branchTransactionDOs = new ArrayList<>();\n+                    for (String xid : xids) {\n+                        Set<String> branches = lRange(jedis, getBranchListKeyByXid(xid));\n+                        if (CollectionUtils.isNotEmpty(branches)) {\n+                            branchTransactionDOs.addAll(getBranchJsons(jedis, branches));\n+                        }\n+                    }\n+                    Map<String, List<BranchTransactionDO>> branchTransactionDOsMap =\n+                        branchTransactionDOs.stream().collect(Collectors.groupingBy(BranchTransactionDO::getXid,\n+                            LinkedHashMap::new, Collectors.toList()));\n+                    return globalTransactionDOs.stream()\n+                        .map(globalTransactionDO -> getGlobalSession(globalTransactionDO,\n+                            branchTransactionDOsMap.get(globalTransactionDO.getXid())))\n+                        .collect(Collectors.toList());\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public List<GlobalSession> readSession(SessionCondition sessionCondition) {\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            if (!StringUtils.isEmpty(sessionCondition.getXid())) {\n+                String globalSessionJson = jedis.get(getGlobalKeyByXid(sessionCondition.getXid()));\n+                if (!StringUtils.isEmpty(globalSessionJson)) {\n+                    GlobalSession session =\n+                        convertGlobalSession(JSON.parseObject(globalSessionJson, GlobalTransactionDO.class));\n+                    List<GlobalSession> globalSessions = new ArrayList<>();\n+                    globalSessions.add(session);\n+                    return globalSessions;\n+                }\n+            } else if (sessionCondition.getTransactionId() != null) {\n+                String global = jedis.get(getGlobalKeyByTransactionId(sessionCondition.getTransactionId()));\n+                if (StringUtils.isEmpty(global)) {\n+                    return null;\n+                }\n+                GlobalTransactionDO globalTransactionDO = JSON.parseObject(global, GlobalTransactionDO.class);\n+                String branchKey = getBranchListKeyByXid(globalTransactionDO.getXid());\n+                Set<String> keys = lRange(jedis, branchKey);\n+                List<BranchTransactionDO> branchTransactionDOs;\n+                if (CollectionUtils.isNotEmpty(keys)) {\n+                    branchTransactionDOs = getBranchJsons(jedis, keys);\n+                    GlobalSession globalSession = getGlobalSession(globalTransactionDO, branchTransactionDOs);\n+                    if (globalSession != null) {\n+                        List<GlobalSession> globalSessions = new ArrayList<>();\n+                        globalSessions.add(globalSession);\n+                        return globalSessions;\n+                    }\n+                }\n+            } else if (CollectionUtils.isNotEmpty(sessionCondition.getStatuses())) {\n+                return readSession(sessionCondition.getStatuses());\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private List<BranchTransactionDO> getBranchJsons(Jedis jedis, Set<String> keys) {\n+        List<BranchTransactionDO> branchTransactionDOs = new ArrayList<>();\n+        List<String> branchJsons = jedis.mget(keys.toArray(new String[0]));\n+        for (String branchJson : branchJsons) {\n+            if (!StringUtils.isEmpty(branchJson)) {\n+                branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk0MjczOQ=="}, "originalCommit": {"oid": "d22ce2ff2675d57c5883d57a6da6f6cf1883299c"}, "originalPosition": 299}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1510, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}