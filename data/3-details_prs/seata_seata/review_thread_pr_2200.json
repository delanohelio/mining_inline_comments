{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY0Mzk0NjY4", "number": 2200, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQwNjo0NToxMlrODZHGZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwOTo0ODo1NVrODfHE4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NjU3MzE5OnYy", "diffSide": "RIGHT", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/sql/struct/cache/PostgresqlTableMetaCache.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQwNjo0NToxMlrOFfUr2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQwNjo0NToxMlrOFfUr2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODM4OTA4MQ==", "bodyText": "Why not create instance init", "url": "https://github.com/seata/seata/pull/2200#discussion_r368389081", "createdAt": "2020-01-20T06:45:12Z", "author": {"login": "jaspercloud"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/sql/struct/cache/PostgresqlTableMetaCache.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.sql.struct.cache;\n+\n+import io.seata.common.exception.ShouldNeverHappenException;\n+import io.seata.common.util.StringUtils;\n+import io.seata.rm.datasource.sql.struct.ColumnMeta;\n+import io.seata.rm.datasource.sql.struct.IndexMeta;\n+import io.seata.rm.datasource.sql.struct.IndexType;\n+import io.seata.rm.datasource.sql.struct.TableMeta;\n+import io.seata.rm.datasource.sql.struct.TableMetaCache;\n+\n+import java.sql.Connection;\n+import java.sql.DatabaseMetaData;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+\n+/**\n+ * The type Table meta cache.\n+ *\n+ * @author jaspercloud\n+ */\n+public class PostgresqlTableMetaCache extends AbstractTableMetaCache {\n+\n+    private static volatile TableMetaCache tableMetaCache = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ca84266bec5e937b70aab28ce45c035334d20f3"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxMjE1MzMxOnYy", "diffSide": "RIGHT", "path": "core/pom.xml", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QwMjowMTo0NlrOFkk66g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QwMjowMTo0NlrOFkk66g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzg5Nzk2Mg==", "bodyText": "Why put postgres's dependencies in the core module instead of the rm-datasource module\uff1f", "url": "https://github.com/seata/seata/pull/2200#discussion_r373897962", "createdAt": "2020-02-03T02:01:46Z", "author": {"login": "slievrly"}, "path": "core/pom.xml", "diffHunk": "@@ -69,6 +69,12 @@\n             <artifactId>h2</artifactId>\n             <scope>test</scope>\n         </dependency>\n+        <dependency>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c254ec3b7380d8e2087270f5310eb9295c3530fe"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzODg3NTMxOnYy", "diffSide": "RIGHT", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwNTozNDo1NlrOFoiOOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwNTo1MToyMVrOFoicww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0ODA1Ng==", "bodyText": "why autocommit=false? single sql", "url": "https://github.com/seata/seata/pull/2200#discussion_r378048056", "createdAt": "2020-02-12T05:34:56Z", "author": {"login": "slievrly"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java", "diffHunk": "@@ -158,6 +158,9 @@ private void doBranchCommits() {\n                         throw new ShouldNeverHappenException(\"Failed to find resource on \" + entry.getKey());\n                     }\n                     conn = dataSourceProxy.getPlainConnection();\n+                    if (conn.getAutoCommit()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc0de3c9c17ff0fe791ba1ca84ff4f5c3c09a805"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA1MTc3OQ==", "bodyText": "when dataSource autoCommit=false\uff0cmust commit", "url": "https://github.com/seata/seata/pull/2200#discussion_r378051779", "createdAt": "2020-02-12T05:51:21Z", "author": {"login": "jaspercloud"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java", "diffHunk": "@@ -158,6 +158,9 @@ private void doBranchCommits() {\n                         throw new ShouldNeverHappenException(\"Failed to find resource on \" + entry.getKey());\n                     }\n                     conn = dataSourceProxy.getPlainConnection();\n+                    if (conn.getAutoCommit()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0ODA1Ng=="}, "originalCommit": {"oid": "fc0de3c9c17ff0fe791ba1ca84ff4f5c3c09a805"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzODk4MzIxOnYy", "diffSide": "RIGHT", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/undo/postgresql/PostgresqlUndoDeleteExecutor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwNjo0NTo1N1rOFojQDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxMTozNDo1NVrOForSyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA2NDkxMA==", "bodyText": "Can refer to MySQLUndoDeleteExecutor#buildUndoSQL, more concise.", "url": "https://github.com/seata/seata/pull/2200#discussion_r378064910", "createdAt": "2020-02-12T06:45:57Z", "author": {"login": "jsbxyyx"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/undo/postgresql/PostgresqlUndoDeleteExecutor.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.undo.postgresql;\n+\n+import io.seata.common.exception.ShouldNeverHappenException;\n+import io.seata.rm.datasource.sql.struct.Field;\n+import io.seata.rm.datasource.sql.struct.KeyType;\n+import io.seata.rm.datasource.sql.struct.Row;\n+import io.seata.rm.datasource.sql.struct.TableRecords;\n+import io.seata.rm.datasource.undo.AbstractUndoExecutor;\n+import io.seata.rm.datasource.undo.KeywordChecker;\n+import io.seata.rm.datasource.undo.KeywordCheckerFactory;\n+import io.seata.rm.datasource.undo.SQLUndoLog;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import java.util.List;\n+\n+/**\n+ * The type postgresql undo delete executor.\n+ *\n+ * @author japsercloud\n+ */\n+public class PostgresqlUndoDeleteExecutor extends AbstractUndoExecutor {\n+\n+    /**\n+     * Instantiates a new postgresql undo delete executor.\n+     *\n+     * @param sqlUndoLog the sql undo log\n+     */\n+    public PostgresqlUndoDeleteExecutor(SQLUndoLog sqlUndoLog) {\n+        super(sqlUndoLog);\n+    }\n+\n+    @Override\n+    protected String buildUndoSQL() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "537477ca94ec8283fbf243e9170a66dabba4b704"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODE5NjY4Mw==", "bodyText": "fix", "url": "https://github.com/seata/seata/pull/2200#discussion_r378196683", "createdAt": "2020-02-12T11:34:55Z", "author": {"login": "jaspercloud"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/undo/postgresql/PostgresqlUndoDeleteExecutor.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.undo.postgresql;\n+\n+import io.seata.common.exception.ShouldNeverHappenException;\n+import io.seata.rm.datasource.sql.struct.Field;\n+import io.seata.rm.datasource.sql.struct.KeyType;\n+import io.seata.rm.datasource.sql.struct.Row;\n+import io.seata.rm.datasource.sql.struct.TableRecords;\n+import io.seata.rm.datasource.undo.AbstractUndoExecutor;\n+import io.seata.rm.datasource.undo.KeywordChecker;\n+import io.seata.rm.datasource.undo.KeywordCheckerFactory;\n+import io.seata.rm.datasource.undo.SQLUndoLog;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import java.util.List;\n+\n+/**\n+ * The type postgresql undo delete executor.\n+ *\n+ * @author japsercloud\n+ */\n+public class PostgresqlUndoDeleteExecutor extends AbstractUndoExecutor {\n+\n+    /**\n+     * Instantiates a new postgresql undo delete executor.\n+     *\n+     * @param sqlUndoLog the sql undo log\n+     */\n+    public PostgresqlUndoDeleteExecutor(SQLUndoLog sqlUndoLog) {\n+        super(sqlUndoLog);\n+    }\n+\n+    @Override\n+    protected String buildUndoSQL() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA2NDkxMA=="}, "originalCommit": {"oid": "537477ca94ec8283fbf243e9170a66dabba4b704"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzODk5MzkzOnYy", "diffSide": "RIGHT", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/undo/postgresql/PostgresqlUndoInsertExecutor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwNjo1MToxOVrOFojWGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxMTozNTowMlrOForS8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA2NjQ1OQ==", "bodyText": "Can refer to MySQLUndoInsertExecutor#buildUndoSQL, more concise.", "url": "https://github.com/seata/seata/pull/2200#discussion_r378066459", "createdAt": "2020-02-12T06:51:19Z", "author": {"login": "jsbxyyx"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/undo/postgresql/PostgresqlUndoInsertExecutor.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.undo.postgresql;\n+\n+import io.seata.common.exception.ShouldNeverHappenException;\n+import io.seata.rm.datasource.sql.struct.Field;\n+import io.seata.rm.datasource.sql.struct.KeyType;\n+import io.seata.rm.datasource.sql.struct.Row;\n+import io.seata.rm.datasource.sql.struct.TableRecords;\n+import io.seata.rm.datasource.undo.AbstractUndoExecutor;\n+import io.seata.rm.datasource.undo.KeywordChecker;\n+import io.seata.rm.datasource.undo.KeywordCheckerFactory;\n+import io.seata.rm.datasource.undo.SQLUndoLog;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import java.sql.PreparedStatement;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * The type postgresql undo insert executor.\n+ *\n+ * @author japsercloud\n+ */\n+public class PostgresqlUndoInsertExecutor extends AbstractUndoExecutor {\n+\n+    @Override\n+    protected String buildUndoSQL() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "537477ca94ec8283fbf243e9170a66dabba4b704"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODE5NjcyMg==", "bodyText": "fix", "url": "https://github.com/seata/seata/pull/2200#discussion_r378196722", "createdAt": "2020-02-12T11:35:02Z", "author": {"login": "jaspercloud"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/undo/postgresql/PostgresqlUndoInsertExecutor.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.undo.postgresql;\n+\n+import io.seata.common.exception.ShouldNeverHappenException;\n+import io.seata.rm.datasource.sql.struct.Field;\n+import io.seata.rm.datasource.sql.struct.KeyType;\n+import io.seata.rm.datasource.sql.struct.Row;\n+import io.seata.rm.datasource.sql.struct.TableRecords;\n+import io.seata.rm.datasource.undo.AbstractUndoExecutor;\n+import io.seata.rm.datasource.undo.KeywordChecker;\n+import io.seata.rm.datasource.undo.KeywordCheckerFactory;\n+import io.seata.rm.datasource.undo.SQLUndoLog;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import java.sql.PreparedStatement;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * The type postgresql undo insert executor.\n+ *\n+ * @author japsercloud\n+ */\n+public class PostgresqlUndoInsertExecutor extends AbstractUndoExecutor {\n+\n+    @Override\n+    protected String buildUndoSQL() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA2NjQ1OQ=="}, "originalCommit": {"oid": "537477ca94ec8283fbf243e9170a66dabba4b704"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzODk5NTk2OnYy", "diffSide": "RIGHT", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/undo/postgresql/PostgresqlUndoUpdateExecutor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwNjo1MjoxMVrOFojXOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxMTozNTowNlrOForTFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA2Njc0Nw==", "bodyText": "Can refer to MySQLUndoUpdateExecutor#buildUndoSQL, more concise.", "url": "https://github.com/seata/seata/pull/2200#discussion_r378066747", "createdAt": "2020-02-12T06:52:11Z", "author": {"login": "jsbxyyx"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/undo/postgresql/PostgresqlUndoUpdateExecutor.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.undo.postgresql;\n+\n+import io.seata.common.exception.ShouldNeverHappenException;\n+import io.seata.rm.datasource.sql.struct.Field;\n+import io.seata.rm.datasource.sql.struct.KeyType;\n+import io.seata.rm.datasource.sql.struct.Row;\n+import io.seata.rm.datasource.sql.struct.TableRecords;\n+import io.seata.rm.datasource.undo.AbstractUndoExecutor;\n+import io.seata.rm.datasource.undo.KeywordChecker;\n+import io.seata.rm.datasource.undo.KeywordCheckerFactory;\n+import io.seata.rm.datasource.undo.SQLUndoLog;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import java.util.List;\n+\n+/**\n+ * @author japsercloud\n+ */\n+public class PostgresqlUndoUpdateExecutor extends AbstractUndoExecutor {\n+\n+    @Override\n+    protected String buildUndoSQL() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "537477ca94ec8283fbf243e9170a66dabba4b704"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODE5Njc1Ng==", "bodyText": "fix", "url": "https://github.com/seata/seata/pull/2200#discussion_r378196756", "createdAt": "2020-02-12T11:35:06Z", "author": {"login": "jaspercloud"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/undo/postgresql/PostgresqlUndoUpdateExecutor.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.undo.postgresql;\n+\n+import io.seata.common.exception.ShouldNeverHappenException;\n+import io.seata.rm.datasource.sql.struct.Field;\n+import io.seata.rm.datasource.sql.struct.KeyType;\n+import io.seata.rm.datasource.sql.struct.Row;\n+import io.seata.rm.datasource.sql.struct.TableRecords;\n+import io.seata.rm.datasource.undo.AbstractUndoExecutor;\n+import io.seata.rm.datasource.undo.KeywordChecker;\n+import io.seata.rm.datasource.undo.KeywordCheckerFactory;\n+import io.seata.rm.datasource.undo.SQLUndoLog;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import java.util.List;\n+\n+/**\n+ * @author japsercloud\n+ */\n+public class PostgresqlUndoUpdateExecutor extends AbstractUndoExecutor {\n+\n+    @Override\n+    protected String buildUndoSQL() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA2Njc0Nw=="}, "originalCommit": {"oid": "537477ca94ec8283fbf243e9170a66dabba4b704"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzOTQ3ODc1OnYy", "diffSide": "RIGHT", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/sql/struct/cache/PostgresqlTableMetaCache.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwOTo0NzozM1rOFon2ZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxMTozNzo0MFrOForX0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODE0MDI2MA==", "bodyText": "why toLowerCase?", "url": "https://github.com/seata/seata/pull/2200#discussion_r378140260", "createdAt": "2020-02-12T09:47:33Z", "author": {"login": "jsbxyyx"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/sql/struct/cache/PostgresqlTableMetaCache.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.sql.struct.cache;\n+\n+import io.seata.common.exception.ShouldNeverHappenException;\n+import io.seata.common.loader.LoadLevel;\n+import io.seata.common.util.StringUtils;\n+import io.seata.rm.datasource.sql.struct.ColumnMeta;\n+import io.seata.rm.datasource.sql.struct.IndexMeta;\n+import io.seata.rm.datasource.sql.struct.IndexType;\n+import io.seata.rm.datasource.sql.struct.TableMeta;\n+import io.seata.rm.datasource.undo.KeywordChecker;\n+import io.seata.rm.datasource.undo.KeywordCheckerFactory;\n+import io.seata.sqlparser.util.JdbcConstants;\n+\n+import java.sql.Connection;\n+import java.sql.DatabaseMetaData;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+\n+/**\n+ * The type Table meta cache.\n+ *\n+ * @author jaspercloud\n+ */\n+@LoadLevel(name = JdbcConstants.POSTGRESQL)\n+public class PostgresqlTableMetaCache extends AbstractTableMetaCache {\n+\n+    private static KeywordChecker keywordChecker = KeywordCheckerFactory.getKeywordChecker(JdbcConstants.POSTGRESQL);\n+\n+    @Override\n+    protected String getCacheKey(Connection connection, String tableName, String resourceId) {\n+        StringBuilder cacheKey = new StringBuilder(resourceId);\n+        cacheKey.append(\".\");\n+\n+        //separate it to schemaName and tableName\n+        String[] tableNameWithSchema = tableName.split(\"\\\\.\");\n+        String defaultTableName = tableNameWithSchema.length > 1 ? tableNameWithSchema[1] : tableNameWithSchema[0];\n+\n+        //postgres does not implement supportsMixedCaseIdentifiers in DatabaseMetadata\n+        if (defaultTableName.contains(\"\\\"\")) {\n+            cacheKey.append(defaultTableName.replace(\"\\\"\", \"\"));\n+        } else {\n+            //postgres default store in lower case\n+            cacheKey.append(defaultTableName.toLowerCase());\n+        }\n+\n+        return cacheKey.toString();\n+    }\n+\n+    @Override\n+    protected TableMeta fetchSchema(Connection connection, String tableName) throws SQLException {\n+        Statement stmt = null;\n+        try {\n+            stmt = connection.createStatement();\n+            DatabaseMetaData dbmd = connection.getMetaData();\n+            tableName = keywordChecker.checkAndReplace(tableName);\n+            return resultSetMetaToSchema(dbmd, tableName);\n+        } catch (Exception e) {\n+            if (e instanceof SQLException) {\n+                throw e;\n+            }\n+            throw new SQLException(\"Failed to fetch schema of \" + tableName, e);\n+        } finally {\n+            if (stmt != null) {\n+                stmt.close();\n+            }\n+        }\n+    }\n+\n+    private TableMeta resultSetMetaToSchema(DatabaseMetaData dbmd, String tableName) throws SQLException {\n+        TableMeta tm = new TableMeta();\n+        tm.setTableName(tableName);\n+        String[] schemaTable = tableName.split(\"\\\\.\");\n+        String schemaName = schemaTable.length > 1 ? schemaTable[0] : null;\n+        tableName = schemaTable.length > 1 ? schemaTable[1] : tableName;\n+        if (null != schemaName) {\n+            schemaName = schemaName.replace(\"\\\"\", \"\").toLowerCase();\n+        }\n+        tableName = tableName.replace(\"\\\"\", \"\").toLowerCase();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19d186a22fd03129c7ffa5fba42225461d9f3b33"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODE5Nzk3MA==", "bodyText": "fix", "url": "https://github.com/seata/seata/pull/2200#discussion_r378197970", "createdAt": "2020-02-12T11:37:40Z", "author": {"login": "jaspercloud"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/sql/struct/cache/PostgresqlTableMetaCache.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.sql.struct.cache;\n+\n+import io.seata.common.exception.ShouldNeverHappenException;\n+import io.seata.common.loader.LoadLevel;\n+import io.seata.common.util.StringUtils;\n+import io.seata.rm.datasource.sql.struct.ColumnMeta;\n+import io.seata.rm.datasource.sql.struct.IndexMeta;\n+import io.seata.rm.datasource.sql.struct.IndexType;\n+import io.seata.rm.datasource.sql.struct.TableMeta;\n+import io.seata.rm.datasource.undo.KeywordChecker;\n+import io.seata.rm.datasource.undo.KeywordCheckerFactory;\n+import io.seata.sqlparser.util.JdbcConstants;\n+\n+import java.sql.Connection;\n+import java.sql.DatabaseMetaData;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+\n+/**\n+ * The type Table meta cache.\n+ *\n+ * @author jaspercloud\n+ */\n+@LoadLevel(name = JdbcConstants.POSTGRESQL)\n+public class PostgresqlTableMetaCache extends AbstractTableMetaCache {\n+\n+    private static KeywordChecker keywordChecker = KeywordCheckerFactory.getKeywordChecker(JdbcConstants.POSTGRESQL);\n+\n+    @Override\n+    protected String getCacheKey(Connection connection, String tableName, String resourceId) {\n+        StringBuilder cacheKey = new StringBuilder(resourceId);\n+        cacheKey.append(\".\");\n+\n+        //separate it to schemaName and tableName\n+        String[] tableNameWithSchema = tableName.split(\"\\\\.\");\n+        String defaultTableName = tableNameWithSchema.length > 1 ? tableNameWithSchema[1] : tableNameWithSchema[0];\n+\n+        //postgres does not implement supportsMixedCaseIdentifiers in DatabaseMetadata\n+        if (defaultTableName.contains(\"\\\"\")) {\n+            cacheKey.append(defaultTableName.replace(\"\\\"\", \"\"));\n+        } else {\n+            //postgres default store in lower case\n+            cacheKey.append(defaultTableName.toLowerCase());\n+        }\n+\n+        return cacheKey.toString();\n+    }\n+\n+    @Override\n+    protected TableMeta fetchSchema(Connection connection, String tableName) throws SQLException {\n+        Statement stmt = null;\n+        try {\n+            stmt = connection.createStatement();\n+            DatabaseMetaData dbmd = connection.getMetaData();\n+            tableName = keywordChecker.checkAndReplace(tableName);\n+            return resultSetMetaToSchema(dbmd, tableName);\n+        } catch (Exception e) {\n+            if (e instanceof SQLException) {\n+                throw e;\n+            }\n+            throw new SQLException(\"Failed to fetch schema of \" + tableName, e);\n+        } finally {\n+            if (stmt != null) {\n+                stmt.close();\n+            }\n+        }\n+    }\n+\n+    private TableMeta resultSetMetaToSchema(DatabaseMetaData dbmd, String tableName) throws SQLException {\n+        TableMeta tm = new TableMeta();\n+        tm.setTableName(tableName);\n+        String[] schemaTable = tableName.split(\"\\\\.\");\n+        String schemaName = schemaTable.length > 1 ? schemaTable[0] : null;\n+        tableName = schemaTable.length > 1 ? schemaTable[1] : tableName;\n+        if (null != schemaName) {\n+            schemaName = schemaName.replace(\"\\\"\", \"\").toLowerCase();\n+        }\n+        tableName = tableName.replace(\"\\\"\", \"\").toLowerCase();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODE0MDI2MA=="}, "originalCommit": {"oid": "19d186a22fd03129c7ffa5fba42225461d9f3b33"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzOTQ4Mzg3OnYy", "diffSide": "RIGHT", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/sql/struct/cache/PostgresqlTableMetaCache.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwOTo0ODo1NVrOFon5aA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxMTozNToxOVrOForTsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODE0MTAzMg==", "bodyText": "IOUtil.close(rsColumns, rsIndex, rsPrimary);", "url": "https://github.com/seata/seata/pull/2200#discussion_r378141032", "createdAt": "2020-02-12T09:48:55Z", "author": {"login": "jsbxyyx"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/sql/struct/cache/PostgresqlTableMetaCache.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.sql.struct.cache;\n+\n+import io.seata.common.exception.ShouldNeverHappenException;\n+import io.seata.common.loader.LoadLevel;\n+import io.seata.common.util.StringUtils;\n+import io.seata.rm.datasource.sql.struct.ColumnMeta;\n+import io.seata.rm.datasource.sql.struct.IndexMeta;\n+import io.seata.rm.datasource.sql.struct.IndexType;\n+import io.seata.rm.datasource.sql.struct.TableMeta;\n+import io.seata.rm.datasource.undo.KeywordChecker;\n+import io.seata.rm.datasource.undo.KeywordCheckerFactory;\n+import io.seata.sqlparser.util.JdbcConstants;\n+\n+import java.sql.Connection;\n+import java.sql.DatabaseMetaData;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+\n+/**\n+ * The type Table meta cache.\n+ *\n+ * @author jaspercloud\n+ */\n+@LoadLevel(name = JdbcConstants.POSTGRESQL)\n+public class PostgresqlTableMetaCache extends AbstractTableMetaCache {\n+\n+    private static KeywordChecker keywordChecker = KeywordCheckerFactory.getKeywordChecker(JdbcConstants.POSTGRESQL);\n+\n+    @Override\n+    protected String getCacheKey(Connection connection, String tableName, String resourceId) {\n+        StringBuilder cacheKey = new StringBuilder(resourceId);\n+        cacheKey.append(\".\");\n+\n+        //separate it to schemaName and tableName\n+        String[] tableNameWithSchema = tableName.split(\"\\\\.\");\n+        String defaultTableName = tableNameWithSchema.length > 1 ? tableNameWithSchema[1] : tableNameWithSchema[0];\n+\n+        //postgres does not implement supportsMixedCaseIdentifiers in DatabaseMetadata\n+        if (defaultTableName.contains(\"\\\"\")) {\n+            cacheKey.append(defaultTableName.replace(\"\\\"\", \"\"));\n+        } else {\n+            //postgres default store in lower case\n+            cacheKey.append(defaultTableName.toLowerCase());\n+        }\n+\n+        return cacheKey.toString();\n+    }\n+\n+    @Override\n+    protected TableMeta fetchSchema(Connection connection, String tableName) throws SQLException {\n+        Statement stmt = null;\n+        try {\n+            stmt = connection.createStatement();\n+            DatabaseMetaData dbmd = connection.getMetaData();\n+            tableName = keywordChecker.checkAndReplace(tableName);\n+            return resultSetMetaToSchema(dbmd, tableName);\n+        } catch (Exception e) {\n+            if (e instanceof SQLException) {\n+                throw e;\n+            }\n+            throw new SQLException(\"Failed to fetch schema of \" + tableName, e);\n+        } finally {\n+            if (stmt != null) {\n+                stmt.close();\n+            }\n+        }\n+    }\n+\n+    private TableMeta resultSetMetaToSchema(DatabaseMetaData dbmd, String tableName) throws SQLException {\n+        TableMeta tm = new TableMeta();\n+        tm.setTableName(tableName);\n+        String[] schemaTable = tableName.split(\"\\\\.\");\n+        String schemaName = schemaTable.length > 1 ? schemaTable[0] : null;\n+        tableName = schemaTable.length > 1 ? schemaTable[1] : tableName;\n+        if (null != schemaName) {\n+            schemaName = schemaName.replace(\"\\\"\", \"\").toLowerCase();\n+        }\n+        tableName = tableName.replace(\"\\\"\", \"\").toLowerCase();\n+\n+        ResultSet rsColumns = dbmd.getColumns(null, schemaName, tableName, \"%\");\n+        ResultSet rsIndex = dbmd.getIndexInfo(null, schemaName, tableName, false, true);\n+        ResultSet rsPrimary = dbmd.getPrimaryKeys(null, schemaName, tableName);\n+\n+        try {\n+            while (rsColumns.next()) {\n+                ColumnMeta col = new ColumnMeta();\n+                col.setTableCat(rsColumns.getString(\"TABLE_CAT\"));\n+                col.setTableSchemaName(rsColumns.getString(\"TABLE_SCHEM\"));\n+                col.setTableName(rsColumns.getString(\"TABLE_NAME\"));\n+                col.setColumnName(rsColumns.getString(\"COLUMN_NAME\"));\n+                col.setDataType(rsColumns.getInt(\"DATA_TYPE\"));\n+                col.setDataTypeName(rsColumns.getString(\"TYPE_NAME\"));\n+                col.setColumnSize(rsColumns.getInt(\"COLUMN_SIZE\"));\n+                col.setDecimalDigits(rsColumns.getInt(\"DECIMAL_DIGITS\"));\n+                col.setNumPrecRadix(rsColumns.getInt(\"NUM_PREC_RADIX\"));\n+                col.setNullAble(rsColumns.getInt(\"NULLABLE\"));\n+                col.setRemarks(rsColumns.getString(\"REMARKS\"));\n+                col.setColumnDef(rsColumns.getString(\"COLUMN_DEF\"));\n+                col.setSqlDataType(rsColumns.getInt(\"SQL_DATA_TYPE\"));\n+                col.setSqlDatetimeSub(rsColumns.getInt(\"SQL_DATETIME_SUB\"));\n+                col.setCharOctetLength(rsColumns.getInt(\"CHAR_OCTET_LENGTH\"));\n+                col.setOrdinalPosition(rsColumns.getInt(\"ORDINAL_POSITION\"));\n+                col.setIsNullAble(rsColumns.getString(\"IS_NULLABLE\"));\n+                col.setIsAutoincrement(rsColumns.getString(\"IS_AUTOINCREMENT\"));\n+                tm.getAllColumns().put(col.getColumnName(), col);\n+            }\n+\n+            while (rsIndex.next()) {\n+                String indexName = rsIndex.getString(\"INDEX_NAME\");\n+                if (StringUtils.isNullOrEmpty(indexName)) {\n+                    continue;\n+                }\n+                String colName = rsIndex.getString(\"COLUMN_NAME\");\n+                ColumnMeta col = tm.getAllColumns().get(colName);\n+                if (tm.getAllIndexes().containsKey(indexName)) {\n+                    IndexMeta index = tm.getAllIndexes().get(indexName);\n+                    index.getValues().add(col);\n+                } else {\n+                    IndexMeta index = new IndexMeta();\n+                    index.setIndexName(indexName);\n+                    index.setNonUnique(rsIndex.getBoolean(\"NON_UNIQUE\"));\n+                    index.setIndexQualifier(rsIndex.getString(\"INDEX_QUALIFIER\"));\n+                    index.setIndexName(rsIndex.getString(\"INDEX_NAME\"));\n+                    index.setType(rsIndex.getShort(\"TYPE\"));\n+                    index.setOrdinalPosition(rsIndex.getShort(\"ORDINAL_POSITION\"));\n+                    index.setAscOrDesc(rsIndex.getString(\"ASC_OR_DESC\"));\n+                    index.setCardinality(rsIndex.getInt(\"CARDINALITY\"));\n+                    index.getValues().add(col);\n+                    if (!index.isNonUnique()) {\n+                        index.setIndextype(IndexType.UNIQUE);\n+                    } else {\n+                        index.setIndextype(IndexType.NORMAL);\n+                    }\n+                    tm.getAllIndexes().put(indexName, index);\n+\n+                }\n+            }\n+\n+            while (rsPrimary.next()) {\n+                String pkIndexName = rsPrimary.getString(\"PK_NAME\");\n+                if (tm.getAllIndexes().containsKey(pkIndexName)) {\n+                    IndexMeta index = tm.getAllIndexes().get(pkIndexName);\n+                    index.setIndextype(IndexType.PRIMARY);\n+                }\n+            }\n+            if (tm.getAllIndexes().isEmpty()) {\n+                throw new ShouldNeverHappenException(\"Could not found any index in the table: \" + tableName);\n+            }\n+        } finally {\n+            if (rsColumns != null) {\n+                rsColumns.close();\n+            }\n+            if (rsIndex != null) {\n+                rsIndex.close();\n+            }\n+            if (rsPrimary != null) {\n+                rsPrimary.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19d186a22fd03129c7ffa5fba42225461d9f3b33"}, "originalPosition": 173}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODE5NjkxMw==", "bodyText": "fix", "url": "https://github.com/seata/seata/pull/2200#discussion_r378196913", "createdAt": "2020-02-12T11:35:19Z", "author": {"login": "jaspercloud"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/sql/struct/cache/PostgresqlTableMetaCache.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.sql.struct.cache;\n+\n+import io.seata.common.exception.ShouldNeverHappenException;\n+import io.seata.common.loader.LoadLevel;\n+import io.seata.common.util.StringUtils;\n+import io.seata.rm.datasource.sql.struct.ColumnMeta;\n+import io.seata.rm.datasource.sql.struct.IndexMeta;\n+import io.seata.rm.datasource.sql.struct.IndexType;\n+import io.seata.rm.datasource.sql.struct.TableMeta;\n+import io.seata.rm.datasource.undo.KeywordChecker;\n+import io.seata.rm.datasource.undo.KeywordCheckerFactory;\n+import io.seata.sqlparser.util.JdbcConstants;\n+\n+import java.sql.Connection;\n+import java.sql.DatabaseMetaData;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+\n+/**\n+ * The type Table meta cache.\n+ *\n+ * @author jaspercloud\n+ */\n+@LoadLevel(name = JdbcConstants.POSTGRESQL)\n+public class PostgresqlTableMetaCache extends AbstractTableMetaCache {\n+\n+    private static KeywordChecker keywordChecker = KeywordCheckerFactory.getKeywordChecker(JdbcConstants.POSTGRESQL);\n+\n+    @Override\n+    protected String getCacheKey(Connection connection, String tableName, String resourceId) {\n+        StringBuilder cacheKey = new StringBuilder(resourceId);\n+        cacheKey.append(\".\");\n+\n+        //separate it to schemaName and tableName\n+        String[] tableNameWithSchema = tableName.split(\"\\\\.\");\n+        String defaultTableName = tableNameWithSchema.length > 1 ? tableNameWithSchema[1] : tableNameWithSchema[0];\n+\n+        //postgres does not implement supportsMixedCaseIdentifiers in DatabaseMetadata\n+        if (defaultTableName.contains(\"\\\"\")) {\n+            cacheKey.append(defaultTableName.replace(\"\\\"\", \"\"));\n+        } else {\n+            //postgres default store in lower case\n+            cacheKey.append(defaultTableName.toLowerCase());\n+        }\n+\n+        return cacheKey.toString();\n+    }\n+\n+    @Override\n+    protected TableMeta fetchSchema(Connection connection, String tableName) throws SQLException {\n+        Statement stmt = null;\n+        try {\n+            stmt = connection.createStatement();\n+            DatabaseMetaData dbmd = connection.getMetaData();\n+            tableName = keywordChecker.checkAndReplace(tableName);\n+            return resultSetMetaToSchema(dbmd, tableName);\n+        } catch (Exception e) {\n+            if (e instanceof SQLException) {\n+                throw e;\n+            }\n+            throw new SQLException(\"Failed to fetch schema of \" + tableName, e);\n+        } finally {\n+            if (stmt != null) {\n+                stmt.close();\n+            }\n+        }\n+    }\n+\n+    private TableMeta resultSetMetaToSchema(DatabaseMetaData dbmd, String tableName) throws SQLException {\n+        TableMeta tm = new TableMeta();\n+        tm.setTableName(tableName);\n+        String[] schemaTable = tableName.split(\"\\\\.\");\n+        String schemaName = schemaTable.length > 1 ? schemaTable[0] : null;\n+        tableName = schemaTable.length > 1 ? schemaTable[1] : tableName;\n+        if (null != schemaName) {\n+            schemaName = schemaName.replace(\"\\\"\", \"\").toLowerCase();\n+        }\n+        tableName = tableName.replace(\"\\\"\", \"\").toLowerCase();\n+\n+        ResultSet rsColumns = dbmd.getColumns(null, schemaName, tableName, \"%\");\n+        ResultSet rsIndex = dbmd.getIndexInfo(null, schemaName, tableName, false, true);\n+        ResultSet rsPrimary = dbmd.getPrimaryKeys(null, schemaName, tableName);\n+\n+        try {\n+            while (rsColumns.next()) {\n+                ColumnMeta col = new ColumnMeta();\n+                col.setTableCat(rsColumns.getString(\"TABLE_CAT\"));\n+                col.setTableSchemaName(rsColumns.getString(\"TABLE_SCHEM\"));\n+                col.setTableName(rsColumns.getString(\"TABLE_NAME\"));\n+                col.setColumnName(rsColumns.getString(\"COLUMN_NAME\"));\n+                col.setDataType(rsColumns.getInt(\"DATA_TYPE\"));\n+                col.setDataTypeName(rsColumns.getString(\"TYPE_NAME\"));\n+                col.setColumnSize(rsColumns.getInt(\"COLUMN_SIZE\"));\n+                col.setDecimalDigits(rsColumns.getInt(\"DECIMAL_DIGITS\"));\n+                col.setNumPrecRadix(rsColumns.getInt(\"NUM_PREC_RADIX\"));\n+                col.setNullAble(rsColumns.getInt(\"NULLABLE\"));\n+                col.setRemarks(rsColumns.getString(\"REMARKS\"));\n+                col.setColumnDef(rsColumns.getString(\"COLUMN_DEF\"));\n+                col.setSqlDataType(rsColumns.getInt(\"SQL_DATA_TYPE\"));\n+                col.setSqlDatetimeSub(rsColumns.getInt(\"SQL_DATETIME_SUB\"));\n+                col.setCharOctetLength(rsColumns.getInt(\"CHAR_OCTET_LENGTH\"));\n+                col.setOrdinalPosition(rsColumns.getInt(\"ORDINAL_POSITION\"));\n+                col.setIsNullAble(rsColumns.getString(\"IS_NULLABLE\"));\n+                col.setIsAutoincrement(rsColumns.getString(\"IS_AUTOINCREMENT\"));\n+                tm.getAllColumns().put(col.getColumnName(), col);\n+            }\n+\n+            while (rsIndex.next()) {\n+                String indexName = rsIndex.getString(\"INDEX_NAME\");\n+                if (StringUtils.isNullOrEmpty(indexName)) {\n+                    continue;\n+                }\n+                String colName = rsIndex.getString(\"COLUMN_NAME\");\n+                ColumnMeta col = tm.getAllColumns().get(colName);\n+                if (tm.getAllIndexes().containsKey(indexName)) {\n+                    IndexMeta index = tm.getAllIndexes().get(indexName);\n+                    index.getValues().add(col);\n+                } else {\n+                    IndexMeta index = new IndexMeta();\n+                    index.setIndexName(indexName);\n+                    index.setNonUnique(rsIndex.getBoolean(\"NON_UNIQUE\"));\n+                    index.setIndexQualifier(rsIndex.getString(\"INDEX_QUALIFIER\"));\n+                    index.setIndexName(rsIndex.getString(\"INDEX_NAME\"));\n+                    index.setType(rsIndex.getShort(\"TYPE\"));\n+                    index.setOrdinalPosition(rsIndex.getShort(\"ORDINAL_POSITION\"));\n+                    index.setAscOrDesc(rsIndex.getString(\"ASC_OR_DESC\"));\n+                    index.setCardinality(rsIndex.getInt(\"CARDINALITY\"));\n+                    index.getValues().add(col);\n+                    if (!index.isNonUnique()) {\n+                        index.setIndextype(IndexType.UNIQUE);\n+                    } else {\n+                        index.setIndextype(IndexType.NORMAL);\n+                    }\n+                    tm.getAllIndexes().put(indexName, index);\n+\n+                }\n+            }\n+\n+            while (rsPrimary.next()) {\n+                String pkIndexName = rsPrimary.getString(\"PK_NAME\");\n+                if (tm.getAllIndexes().containsKey(pkIndexName)) {\n+                    IndexMeta index = tm.getAllIndexes().get(pkIndexName);\n+                    index.setIndextype(IndexType.PRIMARY);\n+                }\n+            }\n+            if (tm.getAllIndexes().isEmpty()) {\n+                throw new ShouldNeverHappenException(\"Could not found any index in the table: \" + tableName);\n+            }\n+        } finally {\n+            if (rsColumns != null) {\n+                rsColumns.close();\n+            }\n+            if (rsIndex != null) {\n+                rsIndex.close();\n+            }\n+            if (rsPrimary != null) {\n+                rsPrimary.close();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODE0MTAzMg=="}, "originalCommit": {"oid": "19d186a22fd03129c7ffa5fba42225461d9f3b33"}, "originalPosition": 173}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1760, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}