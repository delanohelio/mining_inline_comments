{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc4NTY5MDMx", "number": 2280, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNDoyNjoxM1rODvljqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwNTo1MzoxMlrOD9pWVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMjI1MDAyOnYy", "diffSide": "RIGHT", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/postgresql/PostgresqlInsertExecutor.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNDoyNjoxM1rOGCGLtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQwMzoxMDozMFrOGDv2ug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg1MTYzNw==", "bodyText": "\u6d4b\u8bd5\u7ed3\u679c\u53d6\u4e0d\u5230\u503c\u6ca1\u6709next", "url": "https://github.com/seata/seata/pull/2280#discussion_r404851637", "createdAt": "2020-04-07T14:26:13Z", "author": {"login": "jaspercloud"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/postgresql/PostgresqlInsertExecutor.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec.postgresql;\n+\n+import io.seata.common.exception.NotSupportYetException;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.BaseInsertExecutor;\n+import io.seata.rm.datasource.exec.StatementCallback;\n+import io.seata.rm.datasource.sql.struct.ColumnMeta;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.struct.SqlDefaultExpr;\n+import io.seata.sqlparser.struct.SqlMethodExpr;\n+import io.seata.sqlparser.struct.SqlSequenceExpr;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * @author jsbxyyx\n+ */\n+public class PostgresqlInsertExecutor extends BaseInsertExecutor {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PostgresqlInsertExecutor.class);\n+\n+    public PostgresqlInsertExecutor(StatementProxy statementProxy, StatementCallback statementCallback, SQLRecognizer sqlRecognizer) {\n+        super(statementProxy, statementCallback, sqlRecognizer);\n+    }\n+\n+    @Override\n+    protected List<Object> getPkValues() throws SQLException {\n+        return containsPK() ? getPkValuesByColumn() :\n+                (containsColumns() ? getPkValuesByAuto() : getPkValuesByColumn());\n+    }\n+\n+    public List<Object> getPkValuesByAuto() throws SQLException {\n+        // PK is just auto generated\n+        Map<String, ColumnMeta> pkMetaMap = getTableMeta().getPrimaryKeyMap();\n+        if (pkMetaMap.size() != 1) {\n+            throw new NotSupportYetException();\n+        }\n+        ResultSet genKeys = statementProxy.getTargetStatement().getGeneratedKeys();\n+        List<Object> pkValues = new ArrayList<>();\n+        while (genKeys.next()) {\n+            Object v = genKeys.getObject(1);\n+            pkValues.add(v);\n+        }\n+        return pkValues;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62135d24cef6807d4efefcc820e2e368c4aafbb4"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg1MTkzOQ==", "bodyText": "insert into access_log (id) values (nextval('access_log_id_seq'))", "url": "https://github.com/seata/seata/pull/2280#discussion_r404851939", "createdAt": "2020-04-07T14:26:35Z", "author": {"login": "jaspercloud"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/postgresql/PostgresqlInsertExecutor.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec.postgresql;\n+\n+import io.seata.common.exception.NotSupportYetException;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.BaseInsertExecutor;\n+import io.seata.rm.datasource.exec.StatementCallback;\n+import io.seata.rm.datasource.sql.struct.ColumnMeta;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.struct.SqlDefaultExpr;\n+import io.seata.sqlparser.struct.SqlMethodExpr;\n+import io.seata.sqlparser.struct.SqlSequenceExpr;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * @author jsbxyyx\n+ */\n+public class PostgresqlInsertExecutor extends BaseInsertExecutor {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PostgresqlInsertExecutor.class);\n+\n+    public PostgresqlInsertExecutor(StatementProxy statementProxy, StatementCallback statementCallback, SQLRecognizer sqlRecognizer) {\n+        super(statementProxy, statementCallback, sqlRecognizer);\n+    }\n+\n+    @Override\n+    protected List<Object> getPkValues() throws SQLException {\n+        return containsPK() ? getPkValuesByColumn() :\n+                (containsColumns() ? getPkValuesByAuto() : getPkValuesByColumn());\n+    }\n+\n+    public List<Object> getPkValuesByAuto() throws SQLException {\n+        // PK is just auto generated\n+        Map<String, ColumnMeta> pkMetaMap = getTableMeta().getPrimaryKeyMap();\n+        if (pkMetaMap.size() != 1) {\n+            throw new NotSupportYetException();\n+        }\n+        ResultSet genKeys = statementProxy.getTargetStatement().getGeneratedKeys();\n+        List<Object> pkValues = new ArrayList<>();\n+        while (genKeys.next()) {\n+            Object v = genKeys.getObject(1);\n+            pkValues.add(v);\n+        }\n+        return pkValues;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg1MTYzNw=="}, "originalCommit": {"oid": "62135d24cef6807d4efefcc820e2e368c4aafbb4"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU4Mjk3MA==", "bodyText": "fix it.", "url": "https://github.com/seata/seata/pull/2280#discussion_r406582970", "createdAt": "2020-04-10T03:10:30Z", "author": {"login": "jsbxyyx"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/postgresql/PostgresqlInsertExecutor.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec.postgresql;\n+\n+import io.seata.common.exception.NotSupportYetException;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.BaseInsertExecutor;\n+import io.seata.rm.datasource.exec.StatementCallback;\n+import io.seata.rm.datasource.sql.struct.ColumnMeta;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.struct.SqlDefaultExpr;\n+import io.seata.sqlparser.struct.SqlMethodExpr;\n+import io.seata.sqlparser.struct.SqlSequenceExpr;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * @author jsbxyyx\n+ */\n+public class PostgresqlInsertExecutor extends BaseInsertExecutor {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PostgresqlInsertExecutor.class);\n+\n+    public PostgresqlInsertExecutor(StatementProxy statementProxy, StatementCallback statementCallback, SQLRecognizer sqlRecognizer) {\n+        super(statementProxy, statementCallback, sqlRecognizer);\n+    }\n+\n+    @Override\n+    protected List<Object> getPkValues() throws SQLException {\n+        return containsPK() ? getPkValuesByColumn() :\n+                (containsColumns() ? getPkValuesByAuto() : getPkValuesByColumn());\n+    }\n+\n+    public List<Object> getPkValuesByAuto() throws SQLException {\n+        // PK is just auto generated\n+        Map<String, ColumnMeta> pkMetaMap = getTableMeta().getPrimaryKeyMap();\n+        if (pkMetaMap.size() != 1) {\n+            throw new NotSupportYetException();\n+        }\n+        ResultSet genKeys = statementProxy.getTargetStatement().getGeneratedKeys();\n+        List<Object> pkValues = new ArrayList<>();\n+        while (genKeys.next()) {\n+            Object v = genKeys.getObject(1);\n+            pkValues.add(v);\n+        }\n+        return pkValues;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg1MTYzNw=="}, "originalCommit": {"oid": "62135d24cef6807d4efefcc820e2e368c4aafbb4"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MjM0MTY4OnYy", "diffSide": "RIGHT", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/ExecuteTemplate.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNDo1NjozNFrOGKsj6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNDo1NjozNFrOGKsj6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzg2OTAzMw==", "bodyText": "recommended to use PROTOTYPE spi", "url": "https://github.com/seata/seata/pull/2280#discussion_r413869033", "createdAt": "2020-04-23T14:56:34Z", "author": {"login": "zjinlei"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/ExecuteTemplate.java", "diffHunk": "@@ -69,18 +69,19 @@\n             return statementCallback.execute(statementProxy.getTargetStatement(), args);\n         }\n \n+        String dbType = statementProxy.getConnectionProxy().getDbType();\n         if (sqlRecognizer == null) {\n             sqlRecognizer = SQLVisitorFactory.get(\n                     statementProxy.getTargetSQL(),\n-                    statementProxy.getConnectionProxy().getDbType());\n+                    dbType);\n         }\n         Executor<T> executor;\n         if (sqlRecognizer == null) {\n             executor = new PlainExecutor<>(statementProxy, statementCallback);\n         } else {\n             switch (sqlRecognizer.getSQLType()) {\n                 case INSERT:\n-                    executor = new InsertExecutor<>(statementProxy, statementCallback, sqlRecognizer);\n+                    executor = InsertExecutorFactory.createInsertExecutor(statementProxy, statementCallback, sqlRecognizer, dbType);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cdc79f351955f7ffa236cc046720b6259b3cf409"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3NzA2MTkxOnYy", "diffSide": "RIGHT", "path": "sqlparser/seata-sqlparser-core/src/main/java/io/seata/sqlparser/struct/SqlDefaultExpr.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxMzoxMjo1NFrOGLXCNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxMzoxMjo1NFrOGLXCNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDU2NDkxOA==", "bodyText": "?", "url": "https://github.com/seata/seata/pull/2280#discussion_r414564918", "createdAt": "2020-04-24T13:12:54Z", "author": {"login": "zjinlei"}, "path": "sqlparser/seata-sqlparser-core/src/main/java/io/seata/sqlparser/struct/SqlDefaultExpr.java", "diffHunk": "@@ -25,7 +26,7 @@\n     /**\n      * Get SqlDefaultExpr.\n      *\n-     * @return the SqlDefaultExpr\n+     * @return the sqlDefaultExpr", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29ef7a60e7779ded2d1823244c6429fa2f006f25"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3NzA2Mjc3OnYy", "diffSide": "RIGHT", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/ExecuteTemplate.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxMzoxMzowNFrOGLXCrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQwMzowMjozMFrOGLvQxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDU2NTAzNw==", "bodyText": "can use EnhancedServiceLoader.load directly.", "url": "https://github.com/seata/seata/pull/2280#discussion_r414565037", "createdAt": "2020-04-24T13:13:04Z", "author": {"login": "zjinlei"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/ExecuteTemplate.java", "diffHunk": "@@ -84,7 +85,8 @@\n                 SQLRecognizer sqlRecognizer = sqlRecognizers.get(0);\n                 switch (sqlRecognizer.getSQLType()) {\n                     case INSERT:\n-                        executor = new InsertExecutor<>(statementProxy, statementCallback, sqlRecognizer);\n+                        executor = InsertExecutorFactory.createInsertExecutor(statementProxy, statementCallback,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29ef7a60e7779ded2d1823244c6429fa2f006f25"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDk2MTg2MA==", "bodyText": "done.", "url": "https://github.com/seata/seata/pull/2280#discussion_r414961860", "createdAt": "2020-04-25T03:02:30Z", "author": {"login": "jsbxyyx"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/ExecuteTemplate.java", "diffHunk": "@@ -84,7 +85,8 @@\n                 SQLRecognizer sqlRecognizer = sqlRecognizers.get(0);\n                 switch (sqlRecognizer.getSQLType()) {\n                     case INSERT:\n-                        executor = new InsertExecutor<>(statementProxy, statementCallback, sqlRecognizer);\n+                        executor = InsertExecutorFactory.createInsertExecutor(statementProxy, statementCallback,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDU2NTAzNw=="}, "originalCommit": {"oid": "29ef7a60e7779ded2d1823244c6429fa2f006f25"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwNjM5NDQ4OnYy", "diffSide": "RIGHT", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertExecutor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMlQwMjo1MjowM1rOGPcZrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwMToxOTo1MVrOGRBI0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODg0NzE0OQ==", "bodyText": "Defaultable  may be only use in Pg.", "url": "https://github.com/seata/seata/pull/2280#discussion_r418847149", "createdAt": "2020-05-02T02:52:03Z", "author": {"login": "zjinlei"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertExecutor.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec.mysql;\n+\n+import io.seata.common.exception.ShouldNeverHappenException;\n+import io.seata.common.loader.LoadLevel;\n+import io.seata.common.loader.Scope;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.BaseInsertExecutor;\n+import io.seata.rm.datasource.exec.StatementCallback;\n+import io.seata.rm.datasource.sql.struct.ColumnMeta;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.struct.Defaultable;\n+import io.seata.sqlparser.struct.Null;\n+import io.seata.sqlparser.struct.SqlMethodExpr;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * @author jsbxyyx\n+ */\n+@LoadLevel(name = JdbcConstants.MYSQL, scope = Scope.PROTOTYPE)\n+public class MySQLInsertExecutor extends BaseInsertExecutor implements Defaultable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d3af79500c19848125d8bb1a3e42d9c4b9921d3"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ5NzYxNg==", "bodyText": "mysql has default keyword too.", "url": "https://github.com/seata/seata/pull/2280#discussion_r420497616", "createdAt": "2020-05-06T01:19:51Z", "author": {"login": "jsbxyyx"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertExecutor.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec.mysql;\n+\n+import io.seata.common.exception.ShouldNeverHappenException;\n+import io.seata.common.loader.LoadLevel;\n+import io.seata.common.loader.Scope;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.BaseInsertExecutor;\n+import io.seata.rm.datasource.exec.StatementCallback;\n+import io.seata.rm.datasource.sql.struct.ColumnMeta;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.struct.Defaultable;\n+import io.seata.sqlparser.struct.Null;\n+import io.seata.sqlparser.struct.SqlMethodExpr;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * @author jsbxyyx\n+ */\n+@LoadLevel(name = JdbcConstants.MYSQL, scope = Scope.PROTOTYPE)\n+public class MySQLInsertExecutor extends BaseInsertExecutor implements Defaultable {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODg0NzE0OQ=="}, "originalCommit": {"oid": "8d3af79500c19848125d8bb1a3e42d9c4b9921d3"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwNjM5NjkwOnYy", "diffSide": "RIGHT", "path": "sqlparser/seata-sqlparser-core/src/main/java/io/seata/sqlparser/struct/Defaultable.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMlQwMjo1Mjo0MlrOGPcaww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMlQwMjo1Mjo0MlrOGPcaww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODg0NzQyNw==", "bodyText": "add getPkValuesByDefault()", "url": "https://github.com/seata/seata/pull/2280#discussion_r418847427", "createdAt": "2020-05-02T02:52:42Z", "author": {"login": "zjinlei"}, "path": "sqlparser/seata-sqlparser-core/src/main/java/io/seata/sqlparser/struct/Defaultable.java", "diffHunk": "@@ -0,0 +1,23 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.sqlparser.struct;\n+\n+/**\n+ * The default expr able.\n+ * @author jsbxyyx\n+ */\n+public interface Defaultable {\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d3af79500c19848125d8bb1a3e42d9c4b9921d3"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwNjM5OTc2OnYy", "diffSide": "RIGHT", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/InsertExecutor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMlQwMjo1MzozNlrOGPcb8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMlQwMjo1MzozNlrOGPcb8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODg0NzczMA==", "bodyText": "getPkValuesByColumn may be can as a common interface.", "url": "https://github.com/seata/seata/pull/2280#discussion_r418847730", "createdAt": "2020-05-02T02:53:36Z", "author": {"login": "zjinlei"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/InsertExecutor.java", "diffHunk": "@@ -13,380 +13,22 @@\n  *  See the License for the specific language governing permissions and\n  *  limitations under the License.\n  */\n+\n package io.seata.rm.datasource.exec;\n \n-import java.sql.ResultSet;\n import java.sql.SQLException;\n-import java.sql.Statement;\n-import java.util.ArrayList;\n import java.util.List;\n-import java.util.Map;\n-import java.util.stream.Collectors;\n-\n-import io.seata.common.exception.NotSupportYetException;\n-import io.seata.common.exception.ShouldNeverHappenException;\n-import io.seata.common.util.CollectionUtils;\n-import io.seata.common.util.StringUtils;\n-import io.seata.rm.datasource.PreparedStatementProxy;\n-import io.seata.rm.datasource.StatementProxy;\n-import io.seata.rm.datasource.sql.struct.ColumnMeta;\n-import io.seata.rm.datasource.sql.struct.TableRecords;\n-import io.seata.sqlparser.SQLInsertRecognizer;\n-import io.seata.sqlparser.SQLRecognizer;\n-import io.seata.sqlparser.struct.Null;\n-import io.seata.sqlparser.struct.SqlDefaultExpr;\n-import io.seata.sqlparser.struct.SqlMethodExpr;\n-import io.seata.sqlparser.struct.SqlSequenceExpr;\n-import io.seata.sqlparser.util.JdbcConstants;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n /**\n- * The type Insert executor.\n- *\n- * @param <T> the type parameter\n- * @param <S> the type parameter\n- * @author yuanguoyao\n+ * @author jsbxyyx\n  */\n-public class InsertExecutor<T, S extends Statement> extends AbstractDMLBaseExecutor<T, S> {\n-\n-    private static final Logger LOGGER = LoggerFactory.getLogger(InsertExecutor.class);\n-    protected static final String ERR_SQL_STATE = \"S1009\";\n-\n-    private static final String PLACEHOLDER = \"?\";\n-\n-    /**\n-     * Instantiates a new Insert executor.\n-     *\n-     * @param statementProxy    the statement proxy\n-     * @param statementCallback the statement callback\n-     * @param sqlRecognizer     the sql recognizer\n-     */\n-    public InsertExecutor(StatementProxy<S> statementProxy, StatementCallback<T,S> statementCallback,\n-                          SQLRecognizer sqlRecognizer) {\n-        super(statementProxy, statementCallback, sqlRecognizer);\n-    }\n-\n-    @Override\n-    protected TableRecords beforeImage() throws SQLException {\n-        return TableRecords.empty(getTableMeta());\n-    }\n-\n-    @Override\n-    protected TableRecords afterImage(TableRecords beforeImage) throws SQLException {\n-        //Pk column exists or PK is just auto generated\n-        List<Object> pkValues = containsPK() ? getPkValuesByColumn() :\n-                (containsColumns() ? getPkValuesByAuto() : getPkValuesByColumn());\n-\n-        TableRecords afterImage = buildTableRecords(pkValues);\n-\n-        if (afterImage == null) {\n-            throw new SQLException(\"Failed to build after-image for insert\");\n-        }\n-\n-        return afterImage;\n-    }\n-\n-    protected boolean containsPK() {\n-        SQLInsertRecognizer recognizer = (SQLInsertRecognizer) sqlRecognizer;\n-        List<String> insertColumns = recognizer.getInsertColumns();\n-        if (CollectionUtils.isEmpty(insertColumns)) {\n-            return false;\n-        }\n-        return containsPK(insertColumns);\n-    }\n-\n-    protected boolean containsColumns() {\n-        SQLInsertRecognizer recognizer = (SQLInsertRecognizer) sqlRecognizer;\n-        List<String> insertColumns = recognizer.getInsertColumns();\n-        return insertColumns != null && !insertColumns.isEmpty();\n-    }\n-\n-    protected List<Object> getPkValuesByColumn() throws SQLException {\n-        // insert values including PK\n-        SQLInsertRecognizer recognizer = (SQLInsertRecognizer) sqlRecognizer;\n-        final int pkIndex = getPkIndex();\n-        if (pkIndex == -1) {\n-            throw new ShouldNeverHappenException(String.format(\"pkIndex is %d\", pkIndex));\n-        }\n-        List<Object> pkValues = null;\n-        if (statementProxy instanceof PreparedStatementProxy) {\n-            PreparedStatementProxy preparedStatementProxy = (PreparedStatementProxy) statementProxy;\n-\n-            List<List<Object>> insertRows = recognizer.getInsertRows();\n-            if (insertRows != null && !insertRows.isEmpty()) {\n-                ArrayList<Object>[] parameters = preparedStatementProxy.getParameters();\n-                final int rowSize = insertRows.size();\n-\n-                if (rowSize == 1) {\n-                    Object pkValue = insertRows.get(0).get(pkIndex);\n-                    if (PLACEHOLDER.equals(pkValue)) {\n-                        pkValues = parameters[pkIndex];\n-                    } else {\n-                        pkValues = insertRows.stream().map(insertRow -> insertRow.get(pkIndex)).collect(Collectors.toList());\n-                    }\n-                } else {\n-                    int totalPlaceholderNum = -1;\n-                    pkValues = new ArrayList<>(rowSize);\n-                    for (int i = 0; i < rowSize; i++) {\n-                        List<Object> row = insertRows.get(i);\n-                        // oracle insert sql statement specify RETURN_GENERATED_KEYS will append :rowid on sql end\n-                        // insert parameter count will than the actual +1\n-                        if (row.isEmpty()) {\n-                            continue;\n-                        }\n-                        Object pkValue = row.get(pkIndex);\n-                        int currentRowPlaceholderNum = -1;\n-                        for (Object r : row) {\n-                            if (PLACEHOLDER.equals(r)) {\n-                                totalPlaceholderNum += 1;\n-                                currentRowPlaceholderNum += 1;\n-                            }\n-                        }\n-                        if (PLACEHOLDER.equals(pkValue)) {\n-                            int idx = pkIndex;\n-                            if (i != 0) {\n-                                idx = totalPlaceholderNum - currentRowPlaceholderNum + pkIndex;\n-                            }\n-                            ArrayList<Object> parameter = parameters[idx];\n-                            pkValues.addAll(parameter);\n-                        } else {\n-                            pkValues.add(pkValue);\n-                        }\n-                    }\n-                }\n-            }\n-        } else {\n-            List<List<Object>> insertRows = recognizer.getInsertRows();\n-            pkValues = new ArrayList<>(insertRows.size());\n-            for (List<Object> row : insertRows) {\n-                pkValues.add(row.get(pkIndex));\n-            }\n-        }\n-        if (pkValues == null) {\n-            throw new ShouldNeverHappenException();\n-        }\n-        boolean b = this.checkPkValues(pkValues);\n-        if (!b) {\n-            throw new NotSupportYetException(String.format(\"not support sql [%s]\", sqlRecognizer.getOriginalSQL()));\n-        }\n-        if (!pkValues.isEmpty() && pkValues.get(0) instanceof SqlSequenceExpr) {\n-            pkValues = getPkValuesBySequence(pkValues.get(0));\n-        }\n-        else if (!pkValues.isEmpty() && pkValues.get(0) instanceof SqlDefaultExpr) {\n-            pkValues = getPkValuesByDefault();\n-        }\n-        // pk auto generated while column exists and value is null\n-        else if (!pkValues.isEmpty() && pkValues.get(0) instanceof Null) {\n-            pkValues = getPkValuesByAuto();\n-        }\n-        return pkValues;\n-    }\n-\n-    /**\n-     * get primary key values by default\n-     * @return\n-     * @throws SQLException\n-     */\n-    private List<Object> getPkValuesByDefault() throws SQLException {\n-        // current version 1.2 only support postgresql.\n-        // mysql default keyword the logic not support. (sample: insert into test(id, name) values(default, 'xx'))\n-        Map<String, ColumnMeta> pkMetaMap = getTableMeta().getPrimaryKeyMap();\n-        ColumnMeta pkMeta = pkMetaMap.values().iterator().next();\n-        String columnDef = pkMeta.getColumnDef();\n-        // sample: nextval('test_id_seq'::regclass)\n-        String seq = org.apache.commons.lang.StringUtils.substringBetween(columnDef, \"'\", \"'\");\n-        String function = org.apache.commons.lang.StringUtils.substringBetween(columnDef, \"\", \"(\");\n-        if (StringUtils.isBlank(seq)) {\n-            throw new ShouldNeverHappenException(\"get primary key value failed, cause columnDef is \" + columnDef);\n-        }\n-        return getPkValuesBySequence(new SqlSequenceExpr(\"'\" + seq + \"'\", function));\n-    }\n+public interface InsertExecutor<T> extends Executor<T> {\n \n     /**\n-     * get primary key values by sequence.\n-     * @param expr\n-     * @return\n+     * get primary key values.\n+     * @return The primary key value.\n      * @throws SQLException\n      */\n-    protected List<Object> getPkValuesBySequence(Object expr) throws SQLException {\n-        // priority use defaultGeneratedKeys\n-        List<Object> pkValues = null;\n-        try {\n-            pkValues = defaultGeneratedKeys();\n-        } catch (NotSupportYetException | SQLException ignore) {\n-        }\n-\n-        if (!CollectionUtils.isEmpty(pkValues)) {\n-            return pkValues;\n-        }\n-\n-        ResultSet genKeys;\n-        if (expr instanceof SqlSequenceExpr) {\n-            SqlSequenceExpr sequenceExpr = (SqlSequenceExpr) expr;\n-            String sql = \"SELECT \" + sequenceExpr.getSequence() + \".currval FROM DUAL\";\n-            if (StringUtils.equalsIgnoreCase(JdbcConstants.POSTGRESQL, getDbType())) {\n-                sql = \"SELECT currval(\" + sequenceExpr.getSequence() + \")\";\n-            }\n-            LOGGER.warn(\"Fail to get auto-generated keys, use '{}' instead. Be cautious, statement could be polluted. Recommend you set the statement to return generated keys.\", sql);\n-            genKeys = statementProxy.getConnection().createStatement().executeQuery(sql);\n-        } else {\n-            throw new NotSupportYetException(String.format(\"not support expr [%s]\", expr.getClass().getName()));\n-        }\n-        pkValues = new ArrayList<>();\n-        while (genKeys.next()) {\n-            Object v = genKeys.getObject(1);\n-            pkValues.add(v);\n-        }\n-        return pkValues;\n-    }\n-\n-    protected List<Object> getPkValuesByAuto() throws SQLException {\n-        boolean mysql = StringUtils.equalsIgnoreCase(JdbcConstants.MYSQL, getDbType());\n-        if (mysql) {\n-            return mysqlGeneratedKeys();\n-        }\n-        return defaultGeneratedKeys();\n-    }\n-\n-    /**\n-     * get pk index\n-     * @return -1 not found pk index\n-     */\n-    protected int getPkIndex() {\n-        SQLInsertRecognizer recognizer = (SQLInsertRecognizer) sqlRecognizer;\n-        List<String> insertColumns = recognizer.getInsertColumns();\n-        if (CollectionUtils.isNotEmpty(insertColumns)) {\n-            final int insertColumnsSize = insertColumns.size();\n-            int pkIndex = -1;\n-            for (int paramIdx = 0; paramIdx < insertColumnsSize; paramIdx++) {\n-                if (equalsPK(insertColumns.get(paramIdx))) {\n-                    pkIndex = paramIdx;\n-                    break;\n-                }\n-            }\n-            return pkIndex;\n-        }\n-        int pkIndex = -1;\n-        Map<String, ColumnMeta> allColumns = getTableMeta().getAllColumns();\n-        for (Map.Entry<String, ColumnMeta> entry : allColumns.entrySet()) {\n-            pkIndex++;\n-            if (equalsPK(entry.getValue().getColumnName())) {\n-                break;\n-            }\n-        }\n-        return pkIndex;\n-    }\n-\n-    /**\n-     * check pk values\n-     * @param pkValues\n-     * @return true: support. false: not support.\n-     */\n-    protected boolean checkPkValues(List<Object> pkValues) {\n-        /*\n-        -----------------------------------------------\n-                  one    more\n-        null       O      O\n-        value      O      O\n-        method     X      X\n-        sequence   O      X\n-        -----------------------------------------------\n-                  null    value    method    sequence\n-        null       O        X         X         X\n-        value      X        O         X         X\n-        method     X        X         X         X\n-        sequence   X        X         X         X\n-        -----------------------------------------------\n-        */\n-        int n = 0, v = 0, m = 0, s = 0;\n-        for (Object pkValue : pkValues) {\n-            if (pkValue instanceof Null) {\n-                n++;\n-                continue;\n-            }\n-            if (pkValue instanceof SqlMethodExpr) {\n-                m++;\n-                break;\n-            }\n-            if (pkValue instanceof SqlSequenceExpr) {\n-                s++;\n-                continue;\n-            }\n-            v++;\n-        }\n-        // not support sql primary key is function.\n-        if (m > 0) {\n-            return false;\n-        }\n-        if (n > 0 && v == 0 && s == 0) {\n-            return true;\n-        }\n-        if (n == 0 && v > 0 && s == 0) {\n-            return true;\n-        }\n-        if (n == 0 && v == 0 && s == 1) {\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    /**\n-     * mysql get generated keys\n-     * @return the primary key value\n-     * @throws SQLException the SQL exception\n-     */\n-    private List<Object> mysqlGeneratedKeys() throws SQLException {\n-        // PK is just auto generated\n-        Map<String, ColumnMeta> pkMetaMap = getTableMeta().getPrimaryKeyMap();\n-        ColumnMeta pkMeta = pkMetaMap.values().iterator().next();\n-        if (!pkMeta.isAutoincrement()) {\n-            throw new ShouldNeverHappenException();\n-        }\n-\n-        ResultSet genKeys;\n-        try {\n-            genKeys = statementProxy.getTargetStatement().getGeneratedKeys();\n-        } catch (SQLException e) {\n-            // java.sql.SQLException: Generated keys not requested. You need to\n-            // specify Statement.RETURN_GENERATED_KEYS to\n-            // Statement.executeUpdate() or Connection.prepareStatement().\n-            if (ERR_SQL_STATE.equalsIgnoreCase(e.getSQLState())) {\n-                LOGGER.warn(\"Fail to get auto-generated keys, use 'SELECT LAST_INSERT_ID()' instead. Be cautious, statement could be polluted. Recommend you set the statement to return generated keys.\");\n-                genKeys = statementProxy.getTargetStatement().executeQuery(\"SELECT LAST_INSERT_ID()\");\n-            } else {\n-                throw e;\n-            }\n-        }\n-        List<Object> pkValues = new ArrayList<>();\n-        while (genKeys.next()) {\n-            Object v = genKeys.getObject(1);\n-            pkValues.add(v);\n-        }\n-        try {\n-            genKeys.beforeFirst();\n-        } catch (SQLException e) {\n-            LOGGER.warn(\"Fail to reset ResultSet cursor. can not get primary key value\");\n-        }\n-        return pkValues;\n-    }\n-\n-    /**\n-     * default get generated keys\n-     * @return the primary key value\n-     * @throws SQLException the SQL exception\n-     */\n-    private List<Object> defaultGeneratedKeys() throws SQLException {\n-        ResultSet genKeys = statementProxy.getTargetStatement().getGeneratedKeys();\n-        List<Object> pkValues = new ArrayList<>();\n-        while (genKeys.next()) {\n-            Object v = genKeys.getObject(1);\n-            pkValues.add(v);\n-        }\n-        if (pkValues.isEmpty()) {\n-            throw new NotSupportYetException(String.format(\"not support sql [%s]\", sqlRecognizer.getOriginalSQL()));\n-        }\n-        return pkValues;\n-    }\n+    List<Object> getPkValues() throws SQLException;\n ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d3af79500c19848125d8bb1a3e42d9c4b9921d3"}, "originalPosition": 385}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwNjY2MDI5OnYy", "diffSide": "RIGHT", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/BaseInsertExecutor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMlQwNDowNTozNVrOGPeO1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMlQwNDowNTozNVrOGPeO1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODg3NzE0MA==", "bodyText": "Just judge that it is not empty, can simplify the implementation.", "url": "https://github.com/seata/seata/pull/2280#discussion_r418877140", "createdAt": "2020-05-02T04:05:35Z", "author": {"login": "zjinlei"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/BaseInsertExecutor.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec;\n+\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import io.seata.common.exception.NotSupportYetException;\n+import io.seata.common.exception.ShouldNeverHappenException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.rm.datasource.PreparedStatementProxy;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.sql.struct.ColumnMeta;\n+import io.seata.rm.datasource.sql.struct.TableRecords;\n+import io.seata.sqlparser.SQLInsertRecognizer;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.struct.Null;\n+import io.seata.sqlparser.struct.Sequenceable;\n+import io.seata.sqlparser.struct.SqlMethodExpr;\n+import io.seata.sqlparser.struct.SqlSequenceExpr;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The Base Insert Executor.\n+ * @author jsbxyyx\n+ */\n+public abstract class BaseInsertExecutor<T, S extends Statement> extends AbstractDMLBaseExecutor<T, S> implements InsertExecutor<T> {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(BaseInsertExecutor.class);\n+\n+    protected static final String PLACEHOLDER = \"?\";\n+\n+    /**\n+     * Instantiates a new Abstract dml base executor.\n+     *\n+     * @param statementProxy    the statement proxy\n+     * @param statementCallback the statement callback\n+     * @param sqlRecognizer     the sql recognizer\n+     */\n+    public BaseInsertExecutor(StatementProxy<S> statementProxy, StatementCallback<T, S> statementCallback,\n+                              SQLRecognizer sqlRecognizer) {\n+        super(statementProxy, statementCallback, sqlRecognizer);\n+    }\n+\n+    @Override\n+    protected TableRecords beforeImage() throws SQLException {\n+        return TableRecords.empty(getTableMeta());\n+    }\n+\n+    @Override\n+    protected TableRecords afterImage(TableRecords beforeImage) throws SQLException {\n+        List<Object> pkValues = getPkValues();\n+        TableRecords afterImage = buildTableRecords(pkValues);\n+        if (afterImage == null) {\n+            throw new SQLException(\"Failed to build after-image for insert\");\n+        }\n+        return afterImage;\n+    }\n+\n+    protected boolean containsPK() {\n+        SQLInsertRecognizer recognizer = (SQLInsertRecognizer) sqlRecognizer;\n+        List<String> insertColumns = recognizer.getInsertColumns();\n+        if (CollectionUtils.isEmpty(insertColumns)) {\n+            return false;\n+        }\n+        return containsPK(insertColumns);\n+    }\n+\n+    /**\n+     * judge sql specify column\n+     * @return true: contains column. false: not contains column.\n+     */\n+    protected boolean containsColumns() {\n+        SQLInsertRecognizer recognizer = (SQLInsertRecognizer) sqlRecognizer;\n+        List<String> insertColumns = recognizer.getInsertColumns();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d3af79500c19848125d8bb1a3e42d9c4b9921d3"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NzcwMDE2OnYy", "diffSide": "RIGHT", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/BaseInsertExecutor.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNDoyODo0OFrOGVfAag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNDoyODo0OFrOGVfAag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTE4MTI5MA==", "bodyText": "Reduce coupling and implement in 3 steps\n1.getInsertRows\n2.get pkIndex list from rows\n3.get pkValue list from parameters", "url": "https://github.com/seata/seata/pull/2280#discussion_r425181290", "createdAt": "2020-05-14T14:28:48Z", "author": {"login": "zjinlei"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/BaseInsertExecutor.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec;\n+\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import io.seata.common.exception.NotSupportYetException;\n+import io.seata.common.exception.ShouldNeverHappenException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.rm.datasource.PreparedStatementProxy;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.sql.struct.ColumnMeta;\n+import io.seata.rm.datasource.sql.struct.TableRecords;\n+import io.seata.sqlparser.SQLInsertRecognizer;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.struct.Null;\n+import io.seata.sqlparser.struct.Sequenceable;\n+import io.seata.sqlparser.struct.SqlMethodExpr;\n+import io.seata.sqlparser.struct.SqlSequenceExpr;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The Base Insert Executor.\n+ * @author jsbxyyx\n+ */\n+public abstract class BaseInsertExecutor<T, S extends Statement> extends AbstractDMLBaseExecutor<T, S> implements InsertExecutor<T> {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(BaseInsertExecutor.class);\n+\n+    protected static final String PLACEHOLDER = \"?\";\n+\n+    /**\n+     * Instantiates a new Abstract dml base executor.\n+     *\n+     * @param statementProxy    the statement proxy\n+     * @param statementCallback the statement callback\n+     * @param sqlRecognizer     the sql recognizer\n+     */\n+    public BaseInsertExecutor(StatementProxy<S> statementProxy, StatementCallback<T, S> statementCallback,\n+                              SQLRecognizer sqlRecognizer) {\n+        super(statementProxy, statementCallback, sqlRecognizer);\n+    }\n+\n+    @Override\n+    protected TableRecords beforeImage() throws SQLException {\n+        return TableRecords.empty(getTableMeta());\n+    }\n+\n+    @Override\n+    protected TableRecords afterImage(TableRecords beforeImage) throws SQLException {\n+        List<Object> pkValues = getPkValues();\n+        TableRecords afterImage = buildTableRecords(pkValues);\n+        if (afterImage == null) {\n+            throw new SQLException(\"Failed to build after-image for insert\");\n+        }\n+        return afterImage;\n+    }\n+\n+    protected boolean containsPK() {\n+        SQLInsertRecognizer recognizer = (SQLInsertRecognizer) sqlRecognizer;\n+        List<String> insertColumns = recognizer.getInsertColumns();\n+        if (CollectionUtils.isEmpty(insertColumns)) {\n+            return false;\n+        }\n+        return containsPK(insertColumns);\n+    }\n+\n+    /**\n+     * judge sql specify column\n+     * @return true: contains column. false: not contains column.\n+     */\n+    protected boolean containsColumns() {\n+        return !((SQLInsertRecognizer) sqlRecognizer).insertColumnsIsEmpty();\n+    }\n+\n+    /**\n+     * get primary key column index.\n+     * @return -1: not found.\n+     */\n+    protected int getPkIndex() {\n+        SQLInsertRecognizer recognizer = (SQLInsertRecognizer) sqlRecognizer;\n+        List<String> insertColumns = recognizer.getInsertColumns();\n+        if (CollectionUtils.isNotEmpty(insertColumns)) {\n+            final int insertColumnsSize = insertColumns.size();\n+            int pkIndex = -1;\n+            for (int paramIdx = 0; paramIdx < insertColumnsSize; paramIdx++) {\n+                if (equalsPK(insertColumns.get(paramIdx))) {\n+                    pkIndex = paramIdx;\n+                    break;\n+                }\n+            }\n+            return pkIndex;\n+        }\n+        int pkIndex = -1;\n+        Map<String, ColumnMeta> allColumns = getTableMeta().getAllColumns();\n+        for (Map.Entry<String, ColumnMeta> entry : allColumns.entrySet()) {\n+            pkIndex++;\n+            if (equalsPK(entry.getValue().getColumnName())) {\n+                break;\n+            }\n+        }\n+        return pkIndex;\n+    }\n+\n+    /**\n+     * parse primary key value from statement.\n+     * @return\n+     */\n+    protected List<Object> parsePkValuesFromStatement() {\n+        // insert values including PK\n+        SQLInsertRecognizer recognizer = (SQLInsertRecognizer) sqlRecognizer;\n+        final int pkIndex = getPkIndex();\n+        if (pkIndex == -1) {\n+            throw new ShouldNeverHappenException(String.format(\"pkIndex is %d\", pkIndex));\n+        }\n+        List<Object> pkValues = null;\n+        if (statementProxy instanceof PreparedStatementProxy) {\n+            PreparedStatementProxy preparedStatementProxy = (PreparedStatementProxy) statementProxy;\n+\n+            List<List<Object>> insertRows = recognizer.getInsertRows();\n+            if (insertRows != null && !insertRows.isEmpty()) {\n+                ArrayList<Object>[] parameters = preparedStatementProxy.getParameters();\n+                final int rowSize = insertRows.size();\n+\n+                if (rowSize == 1) {\n+                    Object pkValue = insertRows.get(0).get(pkIndex);\n+                    if (PLACEHOLDER.equals(pkValue)) {\n+                        pkValues = parameters[pkIndex];\n+                    } else {\n+                        pkValues = insertRows.stream().map(insertRow -> insertRow.get(pkIndex)).collect(Collectors.toList());\n+                    }\n+                } else {\n+                    int totalPlaceholderNum = -1;\n+                    pkValues = new ArrayList<>(rowSize);\n+                    for (int i = 0; i < rowSize; i++) {\n+                        List<Object> row = insertRows.get(i);\n+                        // oracle insert sql statement specify RETURN_GENERATED_KEYS will append :rowid on sql end\n+                        // insert parameter count will than the actual +1\n+                        if (row.isEmpty()) {\n+                            continue;\n+                        }\n+                        Object pkValue = row.get(pkIndex);\n+                        int currentRowPlaceholderNum = -1;\n+                        for (Object r : row) {\n+                            if (PLACEHOLDER.equals(r)) {\n+                                totalPlaceholderNum += 1;\n+                                currentRowPlaceholderNum += 1;\n+                            }\n+                        }\n+                        if (PLACEHOLDER.equals(pkValue)) {\n+                            int idx = pkIndex;\n+                            if (i != 0) {\n+                                idx = totalPlaceholderNum - currentRowPlaceholderNum + pkIndex;\n+                            }\n+                            ArrayList<Object> parameter = parameters[idx];\n+                            pkValues.addAll(parameter);\n+                        } else {\n+                            pkValues.add(pkValue);\n+                        }\n+                    }\n+                }\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de5768dd6f338583ff49c5c5310157c55439af4d"}, "originalPosition": 182}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1OTY3MDU1OnYy", "diffSide": "RIGHT", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/oracle/OracleInsertExecutor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwNTo1MjozN1rOGXQyVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwNTo1MjozN1rOGXQyVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA0NTQ2Mg==", "bodyText": "How about turn the sql into constant.", "url": "https://github.com/seata/seata/pull/2280#discussion_r427045462", "createdAt": "2020-05-19T05:52:37Z", "author": {"login": "l81893521"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/oracle/OracleInsertExecutor.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec.oracle;\n+\n+import io.seata.common.exception.NotSupportYetException;\n+import io.seata.common.loader.LoadLevel;\n+import io.seata.common.loader.Scope;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.BaseInsertExecutor;\n+import io.seata.rm.datasource.exec.StatementCallback;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.struct.Null;\n+import io.seata.sqlparser.struct.Sequenceable;\n+import io.seata.sqlparser.struct.SqlMethodExpr;\n+import io.seata.sqlparser.struct.SqlSequenceExpr;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.sql.SQLException;\n+import java.util.List;\n+\n+/**\n+ * @author jsbxyyx\n+ */\n+@LoadLevel(name = JdbcConstants.ORACLE, scope = Scope.PROTOTYPE)\n+public class OracleInsertExecutor extends BaseInsertExecutor implements Sequenceable {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(OracleInsertExecutor.class);\n+\n+    /**\n+     * Instantiates a new Abstract dml base executor.\n+     *\n+     * @param statementProxy    the statement proxy\n+     * @param statementCallback the statement callback\n+     * @param sqlRecognizer     the sql recognizer\n+     */\n+    public OracleInsertExecutor(StatementProxy statementProxy, StatementCallback statementCallback,\n+                                SQLRecognizer sqlRecognizer) {\n+        super(statementProxy, statementCallback, sqlRecognizer);\n+    }\n+\n+    @Override\n+    public List<Object> getPkValues() throws SQLException {\n+        return containsPK() ? getPkValuesByColumn() :\n+                (containsColumns() ? getGeneratedKeys() : getPkValuesByColumn());\n+    }\n+\n+    @Override\n+    public List<Object> getPkValuesByColumn() throws SQLException {\n+        List<Object> pkValues = parsePkValuesFromStatement();\n+        if (!pkValues.isEmpty() && pkValues.get(0) instanceof SqlSequenceExpr) {\n+            pkValues = getPkValuesBySequence((SqlSequenceExpr) pkValues.get(0));\n+        } else if (pkValues.size() == 1 && pkValues.get(0) instanceof SqlMethodExpr) {\n+            pkValues = getGeneratedKeys();\n+        } else if (pkValues.size() == 1 && pkValues.get(0) instanceof Null) {\n+            throw new NotSupportYetException(\"oracle not support null\");\n+        }\n+        return pkValues;\n+    }\n+\n+    @Override\n+    public String getSequenceSql(SqlSequenceExpr expr) {\n+        return \"SELECT \" + expr.getSequence() + \".currval FROM DUAL\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de5768dd6f338583ff49c5c5310157c55439af4d"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1OTY3MTg5OnYy", "diffSide": "RIGHT", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/postgresql/PostgresqlInsertExecutor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwNTo1MzoxMlrOGXQzIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwNTo1MzoxMlrOGXQzIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA0NTY2Nw==", "bodyText": "How about turn the sql into constant.", "url": "https://github.com/seata/seata/pull/2280#discussion_r427045667", "createdAt": "2020-05-19T05:53:12Z", "author": {"login": "l81893521"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/postgresql/PostgresqlInsertExecutor.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec.postgresql;\n+\n+import io.seata.common.exception.ShouldNeverHappenException;\n+import io.seata.common.loader.LoadLevel;\n+import io.seata.common.loader.Scope;\n+import io.seata.common.util.StringUtils;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.BaseInsertExecutor;\n+import io.seata.rm.datasource.exec.StatementCallback;\n+import io.seata.rm.datasource.sql.struct.ColumnMeta;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.struct.Defaultable;\n+import io.seata.sqlparser.struct.Sequenceable;\n+import io.seata.sqlparser.struct.SqlDefaultExpr;\n+import io.seata.sqlparser.struct.SqlMethodExpr;\n+import io.seata.sqlparser.struct.SqlSequenceExpr;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * @author jsbxyyx\n+ */\n+@LoadLevel(name = JdbcConstants.POSTGRESQL, scope = Scope.PROTOTYPE)\n+public class PostgresqlInsertExecutor extends BaseInsertExecutor implements Sequenceable, Defaultable {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PostgresqlInsertExecutor.class);\n+\n+    /**\n+     * Instantiates a new Abstract dml base executor.\n+     *\n+     * @param statementProxy    the statement proxy\n+     * @param statementCallback the statement callback\n+     * @param sqlRecognizer     the sql recognizer\n+     */\n+    public PostgresqlInsertExecutor(StatementProxy statementProxy, StatementCallback statementCallback,\n+                                    SQLRecognizer sqlRecognizer) {\n+        super(statementProxy, statementCallback, sqlRecognizer);\n+    }\n+\n+    @Override\n+    public List<Object> getPkValues() throws SQLException {\n+        return containsPK() ? getPkValuesByColumn() :\n+                (containsColumns() ? getGeneratedKeys() : getPkValuesByColumn());\n+    }\n+\n+    @Override\n+    public List<Object> getPkValuesByColumn() throws SQLException {\n+        List<Object> pkValues = parsePkValuesFromStatement();\n+        if (!pkValues.isEmpty() && pkValues.get(0) instanceof SqlSequenceExpr) {\n+            pkValues = getPkValuesBySequence((SqlSequenceExpr) pkValues.get(0));\n+        } else if (!pkValues.isEmpty() && pkValues.get(0) instanceof SqlMethodExpr) {\n+            pkValues = getGeneratedKeys();\n+        } else if (!pkValues.isEmpty() && pkValues.get(0) instanceof SqlDefaultExpr) {\n+            pkValues = getPkValuesByDefault();\n+        }\n+        return pkValues;\n+    }\n+\n+    /**\n+     * get primary key values by default\n+     * @return\n+     * @throws SQLException\n+     */\n+    @Override\n+    public List<Object> getPkValuesByDefault() throws SQLException {\n+        // current version 1.2 only support postgresql.\n+        Map<String, ColumnMeta> pkMetaMap = getTableMeta().getPrimaryKeyMap();\n+        ColumnMeta pkMeta = pkMetaMap.values().iterator().next();\n+        String columnDef = pkMeta.getColumnDef();\n+        // sample: nextval('test_id_seq'::regclass)\n+        String seq = org.apache.commons.lang.StringUtils.substringBetween(columnDef, \"'\", \"'\");\n+        String function = org.apache.commons.lang.StringUtils.substringBetween(columnDef, \"\", \"(\");\n+        if (StringUtils.isBlank(seq)) {\n+            throw new ShouldNeverHappenException(\"get primary key value failed, cause columnDef is \" + columnDef);\n+        }\n+        return getPkValuesBySequence(new SqlSequenceExpr(\"'\" + seq + \"'\", function));\n+    }\n+\n+    @Override\n+    public String getSequenceSql(SqlSequenceExpr expr) {\n+        return \"SELECT currval(\" + expr.getSequence() + \")\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de5768dd6f338583ff49c5c5310157c55439af4d"}, "originalPosition": 101}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1630, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}