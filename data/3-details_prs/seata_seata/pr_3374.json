{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM5NDA0NDkw", "number": 3374, "title": "feature: add a Executor for INSERT ON DUPLICATE KEY UPDATE", "bodyText": "\u2160. Describe what this PR did\n\u65b0\u52a0\u4e00\u4e2aExecutor, \u6267\u884cINSERT ON DUPLICATE KEY UPDATE\n\u2161. Does this pull request fix one issue?\n\nINSERT ON DUPLICATE KEY UPDATE\u5f53update\u65f6\u4f1a\u629b\u5f02\u5e38\n\u2162. Why don't you add test cases (unit test/integration test)?\n\u2163. Describe how to verify it\n\u5982\u679c\u542b\u6709ON DUPLICATE KEY UPDATE\u5219\u8d70\u65b0\u7684\u6267\u884c\u5668\uff0c\u5229\u7528\u552f\u4e00\u7d22\u5f15\u67e5\u524d\u7f6e\u548c\u540e\u7f6e\u955c\u50cf\uff0c\u5982\u679c\u6709\u524d\u7f6e\u955c\u50cf\u5219\u5305\u542bupdate\uff0c\u6ca1\u6709\u524d\u7f6e\u955c\u50cf\u5219\u4e3ainsert\n\u5982\u679c\u91c7\u7528foreach\uff0c\u4e00\u6761sql\u53ef\u80fd\u6709\u4e09\u79cd\u60c5\u51b5\uff1a\n1.\u53ea\u6709insert\uff0cSQLUndoLog\u7684sqlType\u662finsert\uff08\u552f\u4e00\u7d22\u5f15\u90fd\u4e0d\u5b58\u5728\uff09\n2.\u53ea\u6709update\uff0cSQLUndoLog\u7684sqlType\u662fupdate\uff08\u552f\u4e00\u7d22\u5f15\u5df2\u5168\u90e8\u5b58\u5728\uff09\n3.\u65e2\u6709insert\uff0c\u53c8\u6709\u6709update\uff0c\u4e24\u4e2aSQLUndoLog\uff0csqlType\u5206\u522b\u662finsert\u3001update\uff08\u552f\u4e00\u7d22\u5f15\u68c0\u9a8c\u90e8\u5206\u5b58\u5728\uff09\n\u2164. Special notes for reviews", "createdAt": "2020-12-14T12:10:41Z", "url": "https://github.com/seata/seata/pull/3374", "merged": true, "mergeCommit": {"oid": "38226bae14dd99a4058e5121c10a1821530db083"}, "closed": true, "closedAt": "2021-05-03T13:27:33Z", "author": {"login": "huan415"}, "timelineItems": {"totalCount": 90, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdmEjonAH2gAyNTM5NDA0NDkwOjg4YWRiNDVhNjkwMTZiMTY5YjZkMjNlOTEzNGRkOTQ2MTczNjgxNWI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABeTJfPUgFqTY1MDMzOTI2NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "88adb45a69016b169b6d23e9134dd9461736815b", "author": {"user": {"login": "huan415", "name": null}}, "url": "https://github.com/seata/seata/commit/88adb45a69016b169b6d23e9134dd9461736815b", "committedDate": "2020-12-14T12:04:54Z", "message": "bugfix:INSERT ON DUPLICATE KEY UPDATE\u5f53update\u65f6\u4f1a\u629b\u5f02\u5e38\uff0c\u65b0\u52a0\u4e00\u4e2aExecutor"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUxMzMyMjE1", "url": "https://github.com/seata/seata/pull/3374#pullrequestreview-551332215", "createdAt": "2020-12-14T12:47:27Z", "commit": {"oid": "88adb45a69016b169b6d23e9134dd9461736815b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMjo0NzoyN1rOIFO0Ag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMjo0NzoyN1rOIFO0Ag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM1NjQ4Mg==", "bodyText": "ON DUPLICATE KEY UPDATE It should be set to a constant", "url": "https://github.com/seata/seata/pull/3374#discussion_r542356482", "createdAt": "2020-12-14T12:47:27Z", "author": {"login": "a364176773"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/ExecuteTemplate.java", "diffHunk": "@@ -85,9 +86,13 @@\n                 SQLRecognizer sqlRecognizer = sqlRecognizers.get(0);\n                 switch (sqlRecognizer.getSQLType()) {\n                     case INSERT:\n-                        executor = EnhancedServiceLoader.load(InsertExecutor.class, dbType,\n-                                new Class[]{StatementProxy.class, StatementCallback.class, SQLRecognizer.class},\n-                                new Object[]{statementProxy, statementCallback, sqlRecognizer});\n+                        if(sqlRecognizer.getOriginalSQL().toUpperCase().trim().contains(\"ON DUPLICATE KEY UPDATE\".trim()) && \"mysql\".equals(dbType)){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88adb45a69016b169b6d23e9134dd9461736815b"}, "originalPosition": 15}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUxMzU2MTg3", "url": "https://github.com/seata/seata/pull/3374#pullrequestreview-551356187", "createdAt": "2020-12-14T13:19:38Z", "commit": {"oid": "88adb45a69016b169b6d23e9134dd9461736815b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMzoxOTozOFrOIFQCwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMzoxOTozOFrOIFQCwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM3NjY0MQ==", "bodyText": "\u600e\u4e48\u4fdd\u8bc1ON DUPLICATE KEY UPDATE\u6bcf\u4e2a\u5355\u8bcd\u4e4b\u95f4\u53ea\u6709\u4e00\u4e2a\u7a7a\u683c\uff1f\u901a\u8fc7druid\u751f\u6210\u7684\u8bed\u6cd5\u6811\u6765\u5224\u65ad\u4f1a\u4e0d\u4f1a\u597d\u4e00\u70b9\uff1f\u770b\u5230\u91cc\u9762\u662f\u6709\u5bf9\u5e94\u7684\u5b57\u6bb5\u7684\u3002", "url": "https://github.com/seata/seata/pull/3374#discussion_r542376641", "createdAt": "2020-12-14T13:19:38Z", "author": {"login": "caohdgege"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/ExecuteTemplate.java", "diffHunk": "@@ -85,9 +86,13 @@\n                 SQLRecognizer sqlRecognizer = sqlRecognizers.get(0);\n                 switch (sqlRecognizer.getSQLType()) {\n                     case INSERT:\n-                        executor = EnhancedServiceLoader.load(InsertExecutor.class, dbType,\n-                                new Class[]{StatementProxy.class, StatementCallback.class, SQLRecognizer.class},\n-                                new Object[]{statementProxy, statementCallback, sqlRecognizer});\n+                        if(sqlRecognizer.getOriginalSQL().toUpperCase().trim().contains(\"ON DUPLICATE KEY UPDATE\".trim()) && \"mysql\".equals(dbType)){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88adb45a69016b169b6d23e9134dd9461736815b"}, "originalPosition": 15}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0dcb1f30c8156b2774ca27b5a4b2f1146e555836", "author": {"user": {"login": "huan415", "name": null}}, "url": "https://github.com/seata/seata/commit/0dcb1f30c8156b2774ca27b5a4b2f1146e555836", "committedDate": "2020-12-15T00:30:45Z", "message": "bug:checkStyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7d2b96fcc204445759eae380d1dce1e3f28dd48f", "author": {"user": {"login": "huan415", "name": null}}, "url": "https://github.com/seata/seata/commit/7d2b96fcc204445759eae380d1dce1e3f28dd48f", "committedDate": "2020-12-18T14:59:25Z", "message": "Not allow chinese character ! [RegexpSingleline]"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "46d514af91e63542c6aabd205eeb3925e823ef61", "author": {"user": {"login": "huan415", "name": null}}, "url": "https://github.com/seata/seata/commit/46d514af91e63542c6aabd205eeb3925e823ef61", "committedDate": "2020-12-18T15:13:24Z", "message": "'->' is not preceded with whitespace"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fd5b44328e16a23722c8f6230b1158402e87007c", "author": {"user": {"login": "huan415", "name": null}}, "url": "https://github.com/seata/seata/commit/fd5b44328e16a23722c8f6230b1158402e87007c", "committedDate": "2020-12-18T15:23:57Z", "message": "'for' is not followed by whitespace"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f8deb06b6912e721f70ddc984dcc505490c31e60", "author": {"user": {"login": "huan415", "name": null}}, "url": "https://github.com/seata/seata/commit/f8deb06b6912e721f70ddc984dcc505490c31e60", "committedDate": "2020-12-18T15:35:01Z", "message": "is not followed by whitespace"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6fe3166e197f7aadfab2cdb8d28d1643c599e5c1", "author": {"user": {"login": "huan415", "name": null}}, "url": "https://github.com/seata/seata/commit/6fe3166e197f7aadfab2cdb8d28d1643c599e5c1", "committedDate": "2020-12-18T15:43:34Z", "message": "is not preceded with whitespace"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "635ab95adf556dde6a4731d9fdea1896b31013e9", "author": {"user": {"login": "huan415", "name": null}}, "url": "https://github.com/seata/seata/commit/635ab95adf556dde6a4731d9fdea1896b31013e9", "committedDate": "2020-12-18T15:49:33Z", "message": "is not preceded with whitespace. [WhitespaceAround]"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3MDcwOTky", "url": "https://github.com/seata/seata/pull/3374#pullrequestreview-557070992", "createdAt": "2020-12-22T13:16:15Z", "commit": {"oid": "635ab95adf556dde6a4731d9fdea1896b31013e9"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxMzoxNjoxNlrOIJ60qg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxNDowNToxNFrOIJ8STQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI3MTg1MA==", "bodyText": "\u8fd9\u4e2a\u62fc\u51fa\u6765\u7684\u662f\u4e0d\u662f\u4e0d\u7b26\u5408SQL\u8bed\u6cd5\u4e86\uff1f", "url": "https://github.com/seata/seata/pull/3374#discussion_r547271850", "createdAt": "2020-12-22T13:16:16Z", "author": {"login": "caohdgege"}, "path": "sqlparser/seata-sqlparser-core/src/main/java/io/seata/sqlparser/SQLInsertRecognizer.java", "diffHunk": "@@ -45,4 +45,11 @@\n      * @return the insert rows\n      */\n     List<List<Object>> getInsertRows(Collection<Integer> primaryKeyIndex);\n+\n+    /**\n+     * Gets insert\n+     *\n+     * @return  VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)   VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)\n+     */\n+    List<String> getInsertParamsValue();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "635ab95adf556dde6a4731d9fdea1896b31013e9"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI5Mzc0NQ==", "bodyText": "\u8fd9\u91cc\u4e3a\u4ec0\u4e48\u8df3\u8fc7\u4e86\u4e3b\u952e\uff1f\u4e3b\u952e\u4e5f\u5177\u6709\u552f\u4e00\u6027\uff0c\u4e5f\u5e94\u8be5\u89e6\u53d1\u8fd9\u4e2a\u624d\u5bf9\u5440\uff1f", "url": "https://github.com/seata/seata/pull/3374#discussion_r547293745", "createdAt": "2020-12-22T14:01:08Z", "author": {"login": "caohdgege"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "diffHunk": "@@ -0,0 +1,354 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec.mysql;\n+\n+import com.google.common.base.Joiner;\n+import io.seata.common.exception.NotSupportYetException;\n+import io.seata.common.loader.LoadLevel;\n+import io.seata.common.loader.Scope;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.IOUtil;\n+import io.seata.common.util.StringUtils;\n+import io.seata.rm.datasource.ConnectionProxy;\n+import io.seata.rm.datasource.PreparedStatementProxy;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.StatementCallback;\n+import io.seata.rm.datasource.sql.struct.Field;\n+import io.seata.rm.datasource.sql.struct.Row;\n+import io.seata.rm.datasource.sql.struct.TableMeta;\n+import io.seata.rm.datasource.sql.struct.TableRecords;\n+import io.seata.rm.datasource.undo.SQLUndoLog;\n+import io.seata.sqlparser.SQLInsertRecognizer;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.SQLType;\n+import io.seata.sqlparser.struct.Defaultable;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+\n+/**\n+ * @version: 1.00.00\n+ * @description:\n+ * @author: yangyicong\n+ * @date: 2020-11-26 09:06\n+ */\n+@LoadLevel(name = JdbcConstants.MYSQL, scope = Scope.PROTOTYPE)\n+public class MySQLInsertOrUpdateExecutor extends MySQLInsertExecutor implements Defaultable {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MySQLInsertOrUpdateExecutor.class);\n+\n+    //is updated or not\n+    private boolean isUpdateFlag = false;\n+\n+    //before image sql and after image sql,condition is unique index\n+    private String selectSQL;\n+\n+    //the params of selectSQL, value is the unique index\n+    private ArrayList<List<Object>> paramAppenderList;\n+\n+    //key is unique index name, value is unique index\n+    private Map<String, List<String>> beforeUniqueIndexMap = new HashMap<>();\n+\n+    public MySQLInsertOrUpdateExecutor(StatementProxy statementProxy, StatementCallback statementCallback, SQLRecognizer sqlRecognizer) {\n+        super(statementProxy, statementCallback, sqlRecognizer);\n+    }\n+\n+    /**\n+     * Execute auto commit false t.\n+     *\n+     * @param args the args\n+     * @return the t\n+     * @throws Exception the exception\n+     */\n+    @Override\n+    protected Object executeAutoCommitFalse(Object[] args) throws Exception {\n+        if (!JdbcConstants.MYSQL.equalsIgnoreCase(getDbType()) && getTableMeta().getPrimaryKeyOnlyName().size() > 1) {\n+            throw new NotSupportYetException(\"multi pk only support mysql!\");\n+        }\n+        TableRecords beforeImage = beforeImage();\n+        if (CollectionUtils.isNotEmpty(beforeImage.getRows())) {\n+            isUpdateFlag = true;\n+        } else {\n+            beforeImage = TableRecords.empty(getTableMeta());\n+        }\n+        Object result = statementCallback.execute(statementProxy.getTargetStatement(), args);\n+        TableRecords afterImage = afterImage(beforeImage);\n+        prepareUndoLog2(beforeImage, afterImage);\n+        return result;\n+    }\n+\n+    /**\n+     * prepare undo log.\n+     *\n+     * @param beforeImage the before image\n+     * @param afterImage  the after image\n+     * @throws SQLException the sql exception\n+     */\n+    protected void prepareUndoLog2(TableRecords beforeImage, TableRecords afterImage) {\n+        if (beforeImage.getRows().isEmpty() && afterImage.getRows().isEmpty()) {\n+            return;\n+        }\n+        ConnectionProxy connectionProxy = statementProxy.getConnectionProxy();\n+        TableRecords lockKeyRecords = sqlRecognizer.getSQLType() == SQLType.DELETE ? beforeImage : afterImage;\n+        String lockKeys = buildLockKey(lockKeyRecords);\n+        connectionProxy.appendLockKey(lockKeys);\n+        buildUndoItemAll(connectionProxy,beforeImage, afterImage);\n+    }\n+\n+    /**\n+     * build a SQLUndoLog\n+     *\n+     * @param beforeImage the before image\n+     * @param afterImage  the after image\n+     * @return sql undo log\n+     */\n+    protected void buildUndoItemAll(ConnectionProxy connectionProxy, TableRecords beforeImage, TableRecords afterImage) {\n+        if (!isUpdateFlag) {\n+            SQLUndoLog sqlUndoLog = buildUndoItem(TableRecords.empty(getTableMeta()), afterImage);\n+            connectionProxy.appendUndoLog(sqlUndoLog);\n+            return;\n+        }\n+        List<Row> beforeImageRows = beforeImage.getRows();\n+        for (Row r : beforeImageRows) {\n+            getTableMeta().getAllIndexes().forEach((k, v) -> {\n+                if (!\"PRIMARY\".equals(k.toUpperCase()) && !v.isNonUnique()) {\n+                    StringBuilder everyRowIndex = new StringBuilder();\n+                    v.getValues().forEach(m -> {\n+                        for (Field f : r.getFields()) {\n+                            if (m.getColumnName().equals(f.getName())) {\n+                                everyRowIndex.append(f.getValue());\n+                            }\n+                        }\n+                    });\n+                    List<String> indexList = beforeUniqueIndexMap.get(k.toUpperCase());\n+                    if (CollectionUtils.isEmpty(indexList)) {\n+                        indexList = new ArrayList<>();\n+                    }\n+                    indexList.add(everyRowIndex.toString());\n+                    beforeUniqueIndexMap.put(k.toUpperCase(), indexList);\n+                }\n+            });\n+        }\n+        List<Row> insertRows = new ArrayList<>();\n+        List<Row> updateRows = new ArrayList<>();\n+        List<Row> afterImageRows = afterImage.getRows();\n+        for (Row r : afterImageRows) {\n+            Boolean[] isUpdateRows = {false};\n+            getTableMeta().getAllIndexes().forEach((k, v) -> {\n+                if (!\"PRIMARY\".equals(k.toUpperCase()) && !v.isNonUnique()) {\n+                    StringBuilder everyRowIndex = new StringBuilder();\n+                    v.getValues().forEach(m -> {\n+                        for (Field f : r.getFields()) {\n+                            if (m.getColumnName().equals(f.getName())) {\n+                                everyRowIndex.append(f.getValue());\n+                            }\n+                        }\n+                    });\n+                    List<String> indexList = beforeUniqueIndexMap.get(k.toUpperCase());\n+                    if (CollectionUtils.isNotEmpty(indexList)) {\n+                        indexList.forEach(m -> {\n+                            if (m.equals(everyRowIndex.toString())) {\n+                                isUpdateRows[0] = true;\n+                            }\n+                        });\n+                    }\n+                }\n+            });\n+            if (isUpdateRows[0]) {\n+                updateRows.add(r);\n+            } else {\n+                insertRows.add(r);\n+            }\n+        }\n+        if (CollectionUtils.isNotEmpty(updateRows)) {\n+            TableRecords partAfterImage = new TableRecords(afterImage.getTableMeta());\n+            partAfterImage.setTableName(afterImage.getTableName());\n+            partAfterImage.setRows(updateRows);\n+            connectionProxy.appendUndoLog(buildUndoItem(SQLType.UPDATE, beforeImage, partAfterImage));\n+        }\n+        if (CollectionUtils.isNotEmpty(insertRows)) {\n+            TableRecords partAfterImage = new TableRecords(afterImage.getTableMeta());\n+            partAfterImage.setTableName(afterImage.getTableName());\n+            partAfterImage.setRows(insertRows);\n+            connectionProxy.appendUndoLog(buildUndoItem(TableRecords.empty(getTableMeta()), partAfterImage));\n+        }\n+    }\n+\n+    /**\n+     * build a SQLUndoLog\n+     * @param sqlType\n+     * @param beforeImage\n+     * @param afterImage\n+     * @return\n+     */\n+    protected SQLUndoLog buildUndoItem(SQLType sqlType, TableRecords beforeImage, TableRecords afterImage) {\n+        String tableName = sqlRecognizer.getTableName();\n+        SQLUndoLog sqlUndoLog = new SQLUndoLog();\n+        sqlUndoLog.setSqlType(sqlType);\n+        sqlUndoLog.setTableName(tableName);\n+        sqlUndoLog.setBeforeImage(beforeImage);\n+        sqlUndoLog.setAfterImage(afterImage);\n+        return sqlUndoLog;\n+    }\n+\n+\n+    @Override\n+    protected TableRecords afterImage(TableRecords beforeImage) throws SQLException {\n+        Map<String, List<Object>> pkValues = getPkValues();\n+        if (isUpdateFlag) {\n+            return buildImage();\n+        } else {\n+            return afterImageInsert(pkValues);\n+        }\n+    }\n+\n+    private TableRecords afterImageInsert(Map<String, List<Object>> pkValues) throws SQLException {\n+        TableRecords afterImage = buildTableRecords(pkValues);\n+        if (afterImage == null) {\n+            throw new SQLException(\"Failed to build after-image for insert\");\n+        }\n+        return afterImage;\n+    }\n+\n+    @Override\n+    protected TableRecords beforeImage() throws SQLException {\n+        return buildImage();\n+    }\n+\n+    /**\n+     * build before image and after image\n+     * @return\n+     * @throws SQLException\n+     */\n+    protected TableRecords buildImage() throws SQLException {\n+        TableMeta tmeta = getTableMeta();\n+        //after image sql the same of before image\n+        if (StringUtils.isBlank(selectSQL)) {\n+            paramAppenderList = new ArrayList<>();\n+            selectSQL = buildImageSQL(tmeta);\n+        }\n+        return buildTableRecords2(tmeta, selectSQL, paramAppenderList);\n+    }\n+\n+    /**\n+     *  build TableRecords\n+     * @param tableMeta\n+     * @param selectSQL\n+     * @param paramAppenderList\n+     * @return\n+     * @throws SQLException\n+     */\n+    protected TableRecords buildTableRecords2(TableMeta tableMeta, String selectSQL, ArrayList<List<Object>> paramAppenderList) throws SQLException {\n+        ResultSet rs = null;\n+        try (PreparedStatement ps = statementProxy.getConnection().prepareStatement(selectSQL)) {\n+            if (CollectionUtils.isNotEmpty(paramAppenderList)) {\n+                for (int i = 0, ts = paramAppenderList.size(); i < ts; i++) {\n+                    List<Object> paramAppender = paramAppenderList.get(i);\n+                    for (int j = 0, ds = paramAppender.size(); j < ds; j++) {\n+                        ps.setObject(i * ds + j + 1, \"NULL\".equals(paramAppender.get(j).toString()) ? null : paramAppender.get(j));\n+                    }\n+                }\n+            }\n+            rs = ps.executeQuery();\n+            return TableRecords.buildRecords(tableMeta, rs);\n+        } finally {\n+            IOUtil.close(rs);\n+        }\n+    }\n+\n+    /**\n+     * build image sql\n+     * @param tableMeta\n+     * @return\n+     */\n+    private String buildImageSQL(TableMeta tableMeta) {\n+        if (CollectionUtils.isEmpty(paramAppenderList)) {\n+            paramAppenderList = new ArrayList<>();\n+        }\n+        SQLInsertRecognizer recognizer = (SQLInsertRecognizer) sqlRecognizer;\n+        Map<String, ArrayList<Object>> imageParamperterMap = new HashMap<>();\n+        int insertNum = buildImageParamperters(recognizer, imageParamperterMap);\n+        StringBuilder prefix = new StringBuilder(\"SELECT * \");\n+        StringBuilder suffix = new StringBuilder(\" FROM \").append(getFromTableInSQL());\n+        for (int i = 0; i < insertNum; i++) {\n+            int finalI = i;\n+            List<Object> paramAppenderTempList = new ArrayList<>();\n+            tableMeta.getAllIndexes().forEach((k, v) -> {\n+                if (!\"PRIMARY\".equals(k.toUpperCase()) && !v.isNonUnique()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "635ab95adf556dde6a4731d9fdea1896b31013e9"}, "originalPosition": 299}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI5NTgyMQ==", "bodyText": "\u8fd9\u91cc\u7528contains\u7684\u6027\u80fd\u662f\u4e0d\u662f\u4f1a\u5dee\u4e00\u70b9\uff1f\u5e76\u4e14contains\u7684\u8bdd\uff0c\u662f\u4e0d\u662f\u6709\u53ef\u80fd\u8bef\u5224\uff1f", "url": "https://github.com/seata/seata/pull/3374#discussion_r547295821", "createdAt": "2020-12-22T14:05:14Z", "author": {"login": "caohdgege"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "diffHunk": "@@ -0,0 +1,354 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec.mysql;\n+\n+import com.google.common.base.Joiner;\n+import io.seata.common.exception.NotSupportYetException;\n+import io.seata.common.loader.LoadLevel;\n+import io.seata.common.loader.Scope;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.IOUtil;\n+import io.seata.common.util.StringUtils;\n+import io.seata.rm.datasource.ConnectionProxy;\n+import io.seata.rm.datasource.PreparedStatementProxy;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.StatementCallback;\n+import io.seata.rm.datasource.sql.struct.Field;\n+import io.seata.rm.datasource.sql.struct.Row;\n+import io.seata.rm.datasource.sql.struct.TableMeta;\n+import io.seata.rm.datasource.sql.struct.TableRecords;\n+import io.seata.rm.datasource.undo.SQLUndoLog;\n+import io.seata.sqlparser.SQLInsertRecognizer;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.SQLType;\n+import io.seata.sqlparser.struct.Defaultable;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+\n+/**\n+ * @version: 1.00.00\n+ * @description:\n+ * @author: yangyicong\n+ * @date: 2020-11-26 09:06\n+ */\n+@LoadLevel(name = JdbcConstants.MYSQL, scope = Scope.PROTOTYPE)\n+public class MySQLInsertOrUpdateExecutor extends MySQLInsertExecutor implements Defaultable {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MySQLInsertOrUpdateExecutor.class);\n+\n+    //is updated or not\n+    private boolean isUpdateFlag = false;\n+\n+    //before image sql and after image sql,condition is unique index\n+    private String selectSQL;\n+\n+    //the params of selectSQL, value is the unique index\n+    private ArrayList<List<Object>> paramAppenderList;\n+\n+    //key is unique index name, value is unique index\n+    private Map<String, List<String>> beforeUniqueIndexMap = new HashMap<>();\n+\n+    public MySQLInsertOrUpdateExecutor(StatementProxy statementProxy, StatementCallback statementCallback, SQLRecognizer sqlRecognizer) {\n+        super(statementProxy, statementCallback, sqlRecognizer);\n+    }\n+\n+    /**\n+     * Execute auto commit false t.\n+     *\n+     * @param args the args\n+     * @return the t\n+     * @throws Exception the exception\n+     */\n+    @Override\n+    protected Object executeAutoCommitFalse(Object[] args) throws Exception {\n+        if (!JdbcConstants.MYSQL.equalsIgnoreCase(getDbType()) && getTableMeta().getPrimaryKeyOnlyName().size() > 1) {\n+            throw new NotSupportYetException(\"multi pk only support mysql!\");\n+        }\n+        TableRecords beforeImage = beforeImage();\n+        if (CollectionUtils.isNotEmpty(beforeImage.getRows())) {\n+            isUpdateFlag = true;\n+        } else {\n+            beforeImage = TableRecords.empty(getTableMeta());\n+        }\n+        Object result = statementCallback.execute(statementProxy.getTargetStatement(), args);\n+        TableRecords afterImage = afterImage(beforeImage);\n+        prepareUndoLog2(beforeImage, afterImage);\n+        return result;\n+    }\n+\n+    /**\n+     * prepare undo log.\n+     *\n+     * @param beforeImage the before image\n+     * @param afterImage  the after image\n+     * @throws SQLException the sql exception\n+     */\n+    protected void prepareUndoLog2(TableRecords beforeImage, TableRecords afterImage) {\n+        if (beforeImage.getRows().isEmpty() && afterImage.getRows().isEmpty()) {\n+            return;\n+        }\n+        ConnectionProxy connectionProxy = statementProxy.getConnectionProxy();\n+        TableRecords lockKeyRecords = sqlRecognizer.getSQLType() == SQLType.DELETE ? beforeImage : afterImage;\n+        String lockKeys = buildLockKey(lockKeyRecords);\n+        connectionProxy.appendLockKey(lockKeys);\n+        buildUndoItemAll(connectionProxy,beforeImage, afterImage);\n+    }\n+\n+    /**\n+     * build a SQLUndoLog\n+     *\n+     * @param beforeImage the before image\n+     * @param afterImage  the after image\n+     * @return sql undo log\n+     */\n+    protected void buildUndoItemAll(ConnectionProxy connectionProxy, TableRecords beforeImage, TableRecords afterImage) {\n+        if (!isUpdateFlag) {\n+            SQLUndoLog sqlUndoLog = buildUndoItem(TableRecords.empty(getTableMeta()), afterImage);\n+            connectionProxy.appendUndoLog(sqlUndoLog);\n+            return;\n+        }\n+        List<Row> beforeImageRows = beforeImage.getRows();\n+        for (Row r : beforeImageRows) {\n+            getTableMeta().getAllIndexes().forEach((k, v) -> {\n+                if (!\"PRIMARY\".equals(k.toUpperCase()) && !v.isNonUnique()) {\n+                    StringBuilder everyRowIndex = new StringBuilder();\n+                    v.getValues().forEach(m -> {\n+                        for (Field f : r.getFields()) {\n+                            if (m.getColumnName().equals(f.getName())) {\n+                                everyRowIndex.append(f.getValue());\n+                            }\n+                        }\n+                    });\n+                    List<String> indexList = beforeUniqueIndexMap.get(k.toUpperCase());\n+                    if (CollectionUtils.isEmpty(indexList)) {\n+                        indexList = new ArrayList<>();\n+                    }\n+                    indexList.add(everyRowIndex.toString());\n+                    beforeUniqueIndexMap.put(k.toUpperCase(), indexList);\n+                }\n+            });\n+        }\n+        List<Row> insertRows = new ArrayList<>();\n+        List<Row> updateRows = new ArrayList<>();\n+        List<Row> afterImageRows = afterImage.getRows();\n+        for (Row r : afterImageRows) {\n+            Boolean[] isUpdateRows = {false};\n+            getTableMeta().getAllIndexes().forEach((k, v) -> {\n+                if (!\"PRIMARY\".equals(k.toUpperCase()) && !v.isNonUnique()) {\n+                    StringBuilder everyRowIndex = new StringBuilder();\n+                    v.getValues().forEach(m -> {\n+                        for (Field f : r.getFields()) {\n+                            if (m.getColumnName().equals(f.getName())) {\n+                                everyRowIndex.append(f.getValue());\n+                            }\n+                        }\n+                    });\n+                    List<String> indexList = beforeUniqueIndexMap.get(k.toUpperCase());\n+                    if (CollectionUtils.isNotEmpty(indexList)) {\n+                        indexList.forEach(m -> {\n+                            if (m.equals(everyRowIndex.toString())) {\n+                                isUpdateRows[0] = true;\n+                            }\n+                        });\n+                    }\n+                }\n+            });\n+            if (isUpdateRows[0]) {\n+                updateRows.add(r);\n+            } else {\n+                insertRows.add(r);\n+            }\n+        }\n+        if (CollectionUtils.isNotEmpty(updateRows)) {\n+            TableRecords partAfterImage = new TableRecords(afterImage.getTableMeta());\n+            partAfterImage.setTableName(afterImage.getTableName());\n+            partAfterImage.setRows(updateRows);\n+            connectionProxy.appendUndoLog(buildUndoItem(SQLType.UPDATE, beforeImage, partAfterImage));\n+        }\n+        if (CollectionUtils.isNotEmpty(insertRows)) {\n+            TableRecords partAfterImage = new TableRecords(afterImage.getTableMeta());\n+            partAfterImage.setTableName(afterImage.getTableName());\n+            partAfterImage.setRows(insertRows);\n+            connectionProxy.appendUndoLog(buildUndoItem(TableRecords.empty(getTableMeta()), partAfterImage));\n+        }\n+    }\n+\n+    /**\n+     * build a SQLUndoLog\n+     * @param sqlType\n+     * @param beforeImage\n+     * @param afterImage\n+     * @return\n+     */\n+    protected SQLUndoLog buildUndoItem(SQLType sqlType, TableRecords beforeImage, TableRecords afterImage) {\n+        String tableName = sqlRecognizer.getTableName();\n+        SQLUndoLog sqlUndoLog = new SQLUndoLog();\n+        sqlUndoLog.setSqlType(sqlType);\n+        sqlUndoLog.setTableName(tableName);\n+        sqlUndoLog.setBeforeImage(beforeImage);\n+        sqlUndoLog.setAfterImage(afterImage);\n+        return sqlUndoLog;\n+    }\n+\n+\n+    @Override\n+    protected TableRecords afterImage(TableRecords beforeImage) throws SQLException {\n+        Map<String, List<Object>> pkValues = getPkValues();\n+        if (isUpdateFlag) {\n+            return buildImage();\n+        } else {\n+            return afterImageInsert(pkValues);\n+        }\n+    }\n+\n+    private TableRecords afterImageInsert(Map<String, List<Object>> pkValues) throws SQLException {\n+        TableRecords afterImage = buildTableRecords(pkValues);\n+        if (afterImage == null) {\n+            throw new SQLException(\"Failed to build after-image for insert\");\n+        }\n+        return afterImage;\n+    }\n+\n+    @Override\n+    protected TableRecords beforeImage() throws SQLException {\n+        return buildImage();\n+    }\n+\n+    /**\n+     * build before image and after image\n+     * @return\n+     * @throws SQLException\n+     */\n+    protected TableRecords buildImage() throws SQLException {\n+        TableMeta tmeta = getTableMeta();\n+        //after image sql the same of before image\n+        if (StringUtils.isBlank(selectSQL)) {\n+            paramAppenderList = new ArrayList<>();\n+            selectSQL = buildImageSQL(tmeta);\n+        }\n+        return buildTableRecords2(tmeta, selectSQL, paramAppenderList);\n+    }\n+\n+    /**\n+     *  build TableRecords\n+     * @param tableMeta\n+     * @param selectSQL\n+     * @param paramAppenderList\n+     * @return\n+     * @throws SQLException\n+     */\n+    protected TableRecords buildTableRecords2(TableMeta tableMeta, String selectSQL, ArrayList<List<Object>> paramAppenderList) throws SQLException {\n+        ResultSet rs = null;\n+        try (PreparedStatement ps = statementProxy.getConnection().prepareStatement(selectSQL)) {\n+            if (CollectionUtils.isNotEmpty(paramAppenderList)) {\n+                for (int i = 0, ts = paramAppenderList.size(); i < ts; i++) {\n+                    List<Object> paramAppender = paramAppenderList.get(i);\n+                    for (int j = 0, ds = paramAppender.size(); j < ds; j++) {\n+                        ps.setObject(i * ds + j + 1, \"NULL\".equals(paramAppender.get(j).toString()) ? null : paramAppender.get(j));\n+                    }\n+                }\n+            }\n+            rs = ps.executeQuery();\n+            return TableRecords.buildRecords(tableMeta, rs);\n+        } finally {\n+            IOUtil.close(rs);\n+        }\n+    }\n+\n+    /**\n+     * build image sql\n+     * @param tableMeta\n+     * @return\n+     */\n+    private String buildImageSQL(TableMeta tableMeta) {\n+        if (CollectionUtils.isEmpty(paramAppenderList)) {\n+            paramAppenderList = new ArrayList<>();\n+        }\n+        SQLInsertRecognizer recognizer = (SQLInsertRecognizer) sqlRecognizer;\n+        Map<String, ArrayList<Object>> imageParamperterMap = new HashMap<>();\n+        int insertNum = buildImageParamperters(recognizer, imageParamperterMap);\n+        StringBuilder prefix = new StringBuilder(\"SELECT * \");\n+        StringBuilder suffix = new StringBuilder(\" FROM \").append(getFromTableInSQL());\n+        for (int i = 0; i < insertNum; i++) {\n+            int finalI = i;\n+            List<Object> paramAppenderTempList = new ArrayList<>();\n+            tableMeta.getAllIndexes().forEach((k, v) -> {\n+                if (!\"PRIMARY\".equals(k.toUpperCase()) && !v.isNonUnique()) {\n+                    List<String> uniqueList = new ArrayList<>();\n+                    v.getValues().forEach(m -> {\n+                        String columnName = m.getColumnName();\n+                        uniqueList.add(columnName + \" = ? \");\n+                        paramAppenderTempList.add(imageParamperterMap.get(m.getColumnName()).get(finalI));\n+                    });\n+                    if (suffix.toString().contains(\"WHERE\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "635ab95adf556dde6a4731d9fdea1896b31013e9"}, "originalPosition": 306}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4155abda8d203b151adfae0b84f75cb7e40f0671", "author": {"user": {"login": "huan415", "name": null}}, "url": "https://github.com/seata/seata/commit/4155abda8d203b151adfae0b84f75cb7e40f0671", "committedDate": "2020-12-22T15:10:36Z", "message": "It should be set to a constant"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5c9f07493360d4f69236454a598881329c673158", "author": {"user": {"login": "huan415", "name": null}}, "url": "https://github.com/seata/seata/commit/5c9f07493360d4f69236454a598881329c673158", "committedDate": "2020-12-24T13:29:03Z", "message": "bugfix:insertParams is characterstring constant"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6202dea6bc04415bf0a278ae19bfe873cb53ec79", "author": {"user": {"login": "huan415", "name": null}}, "url": "https://github.com/seata/seata/commit/6202dea6bc04415bf0a278ae19bfe873cb53ec79", "committedDate": "2020-12-24T13:57:27Z", "message": "bugfix:insert params is characterstring constant"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0c89f8c8ee1148edbd28670def2e2fbd0ac8fbf8", "author": {"user": {"login": "huan415", "name": null}}, "url": "https://github.com/seata/seata/commit/0c89f8c8ee1148edbd28670def2e2fbd0ac8fbf8", "committedDate": "2020-12-26T09:23:33Z", "message": "bugfix:when buildImage support index is PRIMARY"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ad5d24e646ba9255495632540a4c88a130dcaa1a", "author": {"user": {"login": "huan415", "name": null}}, "url": "https://github.com/seata/seata/commit/ad5d24e646ba9255495632540a4c88a130dcaa1a", "committedDate": "2020-12-26T10:53:56Z", "message": "Merge pull request #1 from seata/develop\n\nmerge origin seata project"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d4db6da983e29960e8d8b6a3bce5b3bbad807eed", "author": {"user": {"login": "huan415", "name": null}}, "url": "https://github.com/seata/seata/commit/d4db6da983e29960e8d8b6a3bce5b3bbad807eed", "committedDate": "2020-12-26T11:14:45Z", "message": "'>' is not followed by whitespace"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5323f259b7c4782f81f47657e1ccfcda2f751873", "author": {"user": {"login": "huan415", "name": null}}, "url": "https://github.com/seata/seata/commit/5323f259b7c4782f81f47657e1ccfcda2f751873", "committedDate": "2020-12-26T11:25:43Z", "message": "')' is preceded with whitespace"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "326a058fafc46d70462fd25dd10207ec511f1b80", "author": {"user": {"login": "huan415", "name": null}}, "url": "https://github.com/seata/seata/commit/326a058fafc46d70462fd25dd10207ec511f1b80", "committedDate": "2020-12-26T11:31:19Z", "message": "'.*' form of import should be avoide"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU4OTM5MzYx", "url": "https://github.com/seata/seata/pull/3374#pullrequestreview-558939361", "createdAt": "2020-12-27T16:03:58Z", "commit": {"oid": "326a058fafc46d70462fd25dd10207ec511f1b80"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yN1QxNjowMzo1OFrOILsOcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yN1QxNjowNzowMFrOILsP0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTEyOTg0Mw==", "bodyText": "java\u5f00\u5934\u7684import\u8981\u8c03\u5230\u4e0a\u9762\u3002", "url": "https://github.com/seata/seata/pull/3374#discussion_r549129843", "createdAt": "2020-12-27T16:03:58Z", "author": {"login": "caohdgege"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec.mysql;\n+\n+import com.google.common.base.Joiner;\n+import io.seata.common.exception.NotSupportYetException;\n+import io.seata.common.loader.LoadLevel;\n+import io.seata.common.loader.Scope;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.IOUtil;\n+import io.seata.common.util.StringUtils;\n+import io.seata.rm.datasource.ConnectionProxy;\n+import io.seata.rm.datasource.PreparedStatementProxy;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.StatementCallback;\n+import io.seata.rm.datasource.sql.struct.ColumnMeta;\n+import io.seata.rm.datasource.sql.struct.Field;\n+import io.seata.rm.datasource.sql.struct.Row;\n+import io.seata.rm.datasource.sql.struct.TableMeta;\n+import io.seata.rm.datasource.sql.struct.TableRecords;\n+import io.seata.rm.datasource.undo.SQLUndoLog;\n+import io.seata.sqlparser.SQLInsertRecognizer;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.SQLType;\n+import io.seata.sqlparser.struct.Defaultable;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "326a058fafc46d70462fd25dd10207ec511f1b80"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTEzMDAzOA==", "bodyText": "\u7528\u4ee5\u4e0b\u7684\u6ce8\u91ca\u65b9\u5f0f\n/**\n*\n*/", "url": "https://github.com/seata/seata/pull/3374#discussion_r549130038", "createdAt": "2020-12-27T16:05:54Z", "author": {"login": "caohdgege"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec.mysql;\n+\n+import com.google.common.base.Joiner;\n+import io.seata.common.exception.NotSupportYetException;\n+import io.seata.common.loader.LoadLevel;\n+import io.seata.common.loader.Scope;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.IOUtil;\n+import io.seata.common.util.StringUtils;\n+import io.seata.rm.datasource.ConnectionProxy;\n+import io.seata.rm.datasource.PreparedStatementProxy;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.StatementCallback;\n+import io.seata.rm.datasource.sql.struct.ColumnMeta;\n+import io.seata.rm.datasource.sql.struct.Field;\n+import io.seata.rm.datasource.sql.struct.Row;\n+import io.seata.rm.datasource.sql.struct.TableMeta;\n+import io.seata.rm.datasource.sql.struct.TableRecords;\n+import io.seata.rm.datasource.undo.SQLUndoLog;\n+import io.seata.sqlparser.SQLInsertRecognizer;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.SQLType;\n+import io.seata.sqlparser.struct.Defaultable;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+\n+/**\n+ * @version: 1.00.00\n+ * @description:\n+ * @author: yangyicong\n+ * @date: 2020-11-26 09:06\n+ */\n+@LoadLevel(name = JdbcConstants.MYSQL, scope = Scope.PROTOTYPE)\n+public class MySQLInsertOrUpdateExecutor extends MySQLInsertExecutor implements Defaultable {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MySQLInsertOrUpdateExecutor.class);\n+\n+    //is updated or not", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "326a058fafc46d70462fd25dd10207ec511f1b80"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTEzMDE5Mg==", "bodyText": "\u8fd9\u4e2a\u65b9\u6cd5\u540d\u80fd\u4e0d\u80fd\u4f18\u5316\u4e00\u4e0b\uff1f", "url": "https://github.com/seata/seata/pull/3374#discussion_r549130192", "createdAt": "2020-12-27T16:07:00Z", "author": {"login": "caohdgege"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec.mysql;\n+\n+import com.google.common.base.Joiner;\n+import io.seata.common.exception.NotSupportYetException;\n+import io.seata.common.loader.LoadLevel;\n+import io.seata.common.loader.Scope;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.IOUtil;\n+import io.seata.common.util.StringUtils;\n+import io.seata.rm.datasource.ConnectionProxy;\n+import io.seata.rm.datasource.PreparedStatementProxy;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.StatementCallback;\n+import io.seata.rm.datasource.sql.struct.ColumnMeta;\n+import io.seata.rm.datasource.sql.struct.Field;\n+import io.seata.rm.datasource.sql.struct.Row;\n+import io.seata.rm.datasource.sql.struct.TableMeta;\n+import io.seata.rm.datasource.sql.struct.TableRecords;\n+import io.seata.rm.datasource.undo.SQLUndoLog;\n+import io.seata.sqlparser.SQLInsertRecognizer;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.SQLType;\n+import io.seata.sqlparser.struct.Defaultable;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+\n+/**\n+ * @version: 1.00.00\n+ * @description:\n+ * @author: yangyicong\n+ * @date: 2020-11-26 09:06\n+ */\n+@LoadLevel(name = JdbcConstants.MYSQL, scope = Scope.PROTOTYPE)\n+public class MySQLInsertOrUpdateExecutor extends MySQLInsertExecutor implements Defaultable {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MySQLInsertOrUpdateExecutor.class);\n+\n+    //is updated or not\n+    private boolean isUpdateFlag = false;\n+\n+    //before image sql and after image sql,condition is unique index\n+    private String selectSQL;\n+\n+    //the params of selectSQL, value is the unique index\n+    private ArrayList<List<Object>> paramAppenderList;\n+\n+    //key is unique index name, value is unique index\n+    private Map<String, List<String>> beforeUniqueIndexMap = new HashMap<>();\n+\n+    public MySQLInsertOrUpdateExecutor(StatementProxy statementProxy, StatementCallback statementCallback, SQLRecognizer sqlRecognizer) {\n+        super(statementProxy, statementCallback, sqlRecognizer);\n+    }\n+\n+    /**\n+     * Execute auto commit false t.\n+     *\n+     * @param args the args\n+     * @return the t\n+     * @throws Exception the exception\n+     */\n+    @Override\n+    protected Object executeAutoCommitFalse(Object[] args) throws Exception {\n+        if (!JdbcConstants.MYSQL.equalsIgnoreCase(getDbType()) && getTableMeta().getPrimaryKeyOnlyName().size() > 1) {\n+            throw new NotSupportYetException(\"multi pk only support mysql!\");\n+        }\n+        TableRecords beforeImage = beforeImage();\n+        if (CollectionUtils.isNotEmpty(beforeImage.getRows())) {\n+            isUpdateFlag = true;\n+        } else {\n+            beforeImage = TableRecords.empty(getTableMeta());\n+        }\n+        Object result = statementCallback.execute(statementProxy.getTargetStatement(), args);\n+        TableRecords afterImage = afterImage(beforeImage);\n+        prepareUndoLog2(beforeImage, afterImage);\n+        return result;\n+    }\n+\n+    /**\n+     * prepare undo log.\n+     *\n+     * @param beforeImage the before image\n+     * @param afterImage  the after image\n+     * @throws SQLException the sql exception\n+     */\n+    protected void prepareUndoLog2(TableRecords beforeImage, TableRecords afterImage) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "326a058fafc46d70462fd25dd10207ec511f1b80"}, "originalPosition": 110}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU4OTM5OTI1", "url": "https://github.com/seata/seata/pull/3374#pullrequestreview-558939925", "createdAt": "2020-12-27T16:12:32Z", "commit": {"oid": "326a058fafc46d70462fd25dd10207ec511f1b80"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yN1QxNjoxMjozMlrOILsR5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yN1QxNjoxMjozMlrOILsR5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTEzMDcyNA==", "bodyText": "\u8fd9\u91cc\u4e3a\u4ec0\u4e48\u662f\u4e2a\u6570\u7ec4\u6765\u7684\uff1f", "url": "https://github.com/seata/seata/pull/3374#discussion_r549130724", "createdAt": "2020-12-27T16:12:32Z", "author": {"login": "caohdgege"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec.mysql;\n+\n+import com.google.common.base.Joiner;\n+import io.seata.common.exception.NotSupportYetException;\n+import io.seata.common.loader.LoadLevel;\n+import io.seata.common.loader.Scope;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.IOUtil;\n+import io.seata.common.util.StringUtils;\n+import io.seata.rm.datasource.ConnectionProxy;\n+import io.seata.rm.datasource.PreparedStatementProxy;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.StatementCallback;\n+import io.seata.rm.datasource.sql.struct.ColumnMeta;\n+import io.seata.rm.datasource.sql.struct.Field;\n+import io.seata.rm.datasource.sql.struct.Row;\n+import io.seata.rm.datasource.sql.struct.TableMeta;\n+import io.seata.rm.datasource.sql.struct.TableRecords;\n+import io.seata.rm.datasource.undo.SQLUndoLog;\n+import io.seata.sqlparser.SQLInsertRecognizer;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.SQLType;\n+import io.seata.sqlparser.struct.Defaultable;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+\n+/**\n+ * @version: 1.00.00\n+ * @description:\n+ * @author: yangyicong\n+ * @date: 2020-11-26 09:06\n+ */\n+@LoadLevel(name = JdbcConstants.MYSQL, scope = Scope.PROTOTYPE)\n+public class MySQLInsertOrUpdateExecutor extends MySQLInsertExecutor implements Defaultable {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MySQLInsertOrUpdateExecutor.class);\n+\n+    //is updated or not\n+    private boolean isUpdateFlag = false;\n+\n+    //before image sql and after image sql,condition is unique index\n+    private String selectSQL;\n+\n+    //the params of selectSQL, value is the unique index\n+    private ArrayList<List<Object>> paramAppenderList;\n+\n+    //key is unique index name, value is unique index\n+    private Map<String, List<String>> beforeUniqueIndexMap = new HashMap<>();\n+\n+    public MySQLInsertOrUpdateExecutor(StatementProxy statementProxy, StatementCallback statementCallback, SQLRecognizer sqlRecognizer) {\n+        super(statementProxy, statementCallback, sqlRecognizer);\n+    }\n+\n+    /**\n+     * Execute auto commit false t.\n+     *\n+     * @param args the args\n+     * @return the t\n+     * @throws Exception the exception\n+     */\n+    @Override\n+    protected Object executeAutoCommitFalse(Object[] args) throws Exception {\n+        if (!JdbcConstants.MYSQL.equalsIgnoreCase(getDbType()) && getTableMeta().getPrimaryKeyOnlyName().size() > 1) {\n+            throw new NotSupportYetException(\"multi pk only support mysql!\");\n+        }\n+        TableRecords beforeImage = beforeImage();\n+        if (CollectionUtils.isNotEmpty(beforeImage.getRows())) {\n+            isUpdateFlag = true;\n+        } else {\n+            beforeImage = TableRecords.empty(getTableMeta());\n+        }\n+        Object result = statementCallback.execute(statementProxy.getTargetStatement(), args);\n+        TableRecords afterImage = afterImage(beforeImage);\n+        prepareUndoLog2(beforeImage, afterImage);\n+        return result;\n+    }\n+\n+    /**\n+     * prepare undo log.\n+     *\n+     * @param beforeImage the before image\n+     * @param afterImage  the after image\n+     * @throws SQLException the sql exception\n+     */\n+    protected void prepareUndoLog2(TableRecords beforeImage, TableRecords afterImage) {\n+        if (beforeImage.getRows().isEmpty() && afterImage.getRows().isEmpty()) {\n+            return;\n+        }\n+        ConnectionProxy connectionProxy = statementProxy.getConnectionProxy();\n+        TableRecords lockKeyRecords = sqlRecognizer.getSQLType() == SQLType.DELETE ? beforeImage : afterImage;\n+        String lockKeys = buildLockKey(lockKeyRecords);\n+        connectionProxy.appendLockKey(lockKeys);\n+        buildUndoItemAll(connectionProxy,beforeImage, afterImage);\n+    }\n+\n+    /**\n+     * build a SQLUndoLog\n+     *\n+     * @param beforeImage the before image\n+     * @param afterImage  the after image\n+     * @return sql undo log\n+     */\n+    protected void buildUndoItemAll(ConnectionProxy connectionProxy, TableRecords beforeImage, TableRecords afterImage) {\n+        if (!isUpdateFlag) {\n+            SQLUndoLog sqlUndoLog = buildUndoItem(TableRecords.empty(getTableMeta()), afterImage);\n+            connectionProxy.appendUndoLog(sqlUndoLog);\n+            return;\n+        }\n+        List<Row> beforeImageRows = beforeImage.getRows();\n+        for (Row r : beforeImageRows) {\n+            getTableMeta().getAllIndexes().forEach((k, v) -> {\n+                if (!\"PRIMARY\".equals(k.toUpperCase()) && !v.isNonUnique()) {\n+                    StringBuilder everyRowIndex = new StringBuilder();\n+                    v.getValues().forEach(m -> {\n+                        for (Field f : r.getFields()) {\n+                            if (m.getColumnName().equals(f.getName())) {\n+                                everyRowIndex.append(f.getValue());\n+                            }\n+                        }\n+                    });\n+                    List<String> indexList = beforeUniqueIndexMap.get(k.toUpperCase());\n+                    if (CollectionUtils.isEmpty(indexList)) {\n+                        indexList = new ArrayList<>();\n+                    }\n+                    indexList.add(everyRowIndex.toString());\n+                    beforeUniqueIndexMap.put(k.toUpperCase(), indexList);\n+                }\n+            });\n+        }\n+        List<Row> insertRows = new ArrayList<>();\n+        List<Row> updateRows = new ArrayList<>();\n+        List<Row> afterImageRows = afterImage.getRows();\n+        for (Row r : afterImageRows) {\n+            Boolean[] isUpdateRows = {false};", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "326a058fafc46d70462fd25dd10207ec511f1b80"}, "originalPosition": 159}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "32b0318010e39dfbaba18b6379cf7be0214e3ada", "author": {"user": {"login": "huan415", "name": null}}, "url": "https://github.com/seata/seata/commit/32b0318010e39dfbaba18b6379cf7be0214e3ada", "committedDate": "2020-12-28T13:38:41Z", "message": "formatcode pattern"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYzNTY3MjUx", "url": "https://github.com/seata/seata/pull/3374#pullrequestreview-563567251", "createdAt": "2021-01-07T15:14:08Z", "commit": {"oid": "32b0318010e39dfbaba18b6379cf7be0214e3ada"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxNToxNDowOFrOIPwOOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxNToxNDowOFrOIPwOOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzM4OTYyNg==", "bodyText": "\u8fd9\u91cc\u76f4\u63a5\u7528afterImage\u5c31\u597d\u4e86\u5427", "url": "https://github.com/seata/seata/pull/3374#discussion_r553389626", "createdAt": "2021-01-07T15:14:08Z", "author": {"login": "caohdgege"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "diffHunk": "@@ -0,0 +1,376 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec.mysql;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import com.google.common.base.Joiner;\n+import io.seata.common.exception.NotSupportYetException;\n+import io.seata.common.loader.LoadLevel;\n+import io.seata.common.loader.Scope;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.IOUtil;\n+import io.seata.common.util.StringUtils;\n+import io.seata.rm.datasource.ConnectionProxy;\n+import io.seata.rm.datasource.PreparedStatementProxy;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.StatementCallback;\n+import io.seata.rm.datasource.sql.struct.ColumnMeta;\n+import io.seata.rm.datasource.sql.struct.Field;\n+import io.seata.rm.datasource.sql.struct.Row;\n+import io.seata.rm.datasource.sql.struct.TableMeta;\n+import io.seata.rm.datasource.sql.struct.TableRecords;\n+import io.seata.rm.datasource.undo.SQLUndoLog;\n+import io.seata.sqlparser.SQLInsertRecognizer;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.SQLType;\n+import io.seata.sqlparser.struct.Defaultable;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * @version: 1.00.00\n+ * @description:\n+ * @author: yangyicong\n+ * @date: 2020-11-26 09:06\n+ */\n+@LoadLevel(name = JdbcConstants.MYSQL, scope = Scope.PROTOTYPE)\n+public class MySQLInsertOrUpdateExecutor extends MySQLInsertExecutor implements Defaultable {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MySQLInsertOrUpdateExecutor.class);\n+\n+    /**\n+     * is updated or not\n+     */\n+    private boolean isUpdateFlag = false;\n+\n+    /**\n+     * before image sql and after image sql,condition is unique index\n+     */\n+    private String selectSQL;\n+\n+    /**\n+     * the params of selectSQL, value is the unique index\n+     */\n+    private ArrayList<List<Object>> paramAppenderList;\n+\n+    /**\n+     * key is unique index name, value is unique index\n+     */\n+    private Map<String, List<String>> beforeUniqueIndexMap = new HashMap<>();\n+\n+    public MySQLInsertOrUpdateExecutor(StatementProxy statementProxy, StatementCallback statementCallback, SQLRecognizer sqlRecognizer) {\n+        super(statementProxy, statementCallback, sqlRecognizer);\n+    }\n+\n+    /**\n+     * Execute auto commit false t.\n+     *\n+     * @param args the args\n+     * @return the t\n+     * @throws Exception the exception\n+     */\n+    @Override\n+    protected Object executeAutoCommitFalse(Object[] args) throws Exception {\n+        if (!JdbcConstants.MYSQL.equalsIgnoreCase(getDbType()) && getTableMeta().getPrimaryKeyOnlyName().size() > 1) {\n+            throw new NotSupportYetException(\"multi pk only support mysql!\");\n+        }\n+        TableRecords beforeImage = beforeImage();\n+        if (CollectionUtils.isNotEmpty(beforeImage.getRows())) {\n+            isUpdateFlag = true;\n+        } else {\n+            beforeImage = TableRecords.empty(getTableMeta());\n+        }\n+        Object result = statementCallback.execute(statementProxy.getTargetStatement(), args);\n+        TableRecords afterImage = afterImage(beforeImage);\n+        prepareUndoLogAll(beforeImage, afterImage);\n+        return result;\n+    }\n+\n+    /**\n+     * prepare undo log.\n+     *\n+     * @param beforeImage the before image\n+     * @param afterImage  the after image\n+     * @throws SQLException the sql exception\n+     */\n+    protected void prepareUndoLogAll(TableRecords beforeImage, TableRecords afterImage) {\n+        if (beforeImage.getRows().isEmpty() && afterImage.getRows().isEmpty()) {\n+            return;\n+        }\n+        ConnectionProxy connectionProxy = statementProxy.getConnectionProxy();\n+        TableRecords lockKeyRecords = sqlRecognizer.getSQLType() == SQLType.DELETE ? beforeImage : afterImage;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32b0318010e39dfbaba18b6379cf7be0214e3ada"}, "originalPosition": 124}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYzNDg4ODU3", "url": "https://github.com/seata/seata/pull/3374#pullrequestreview-563488857", "createdAt": "2021-01-07T13:36:39Z", "commit": {"oid": "32b0318010e39dfbaba18b6379cf7be0214e3ada"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxMzozNjozOVrOIPsnLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxMzozNjozOVrOIPsnLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMzMDQ3Nw==", "bodyText": "\u4ec5\u7559@author\u5373\u53ef", "url": "https://github.com/seata/seata/pull/3374#discussion_r553330477", "createdAt": "2021-01-07T13:36:39Z", "author": {"login": "a364176773"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "diffHunk": "@@ -0,0 +1,376 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec.mysql;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import com.google.common.base.Joiner;\n+import io.seata.common.exception.NotSupportYetException;\n+import io.seata.common.loader.LoadLevel;\n+import io.seata.common.loader.Scope;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.IOUtil;\n+import io.seata.common.util.StringUtils;\n+import io.seata.rm.datasource.ConnectionProxy;\n+import io.seata.rm.datasource.PreparedStatementProxy;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.StatementCallback;\n+import io.seata.rm.datasource.sql.struct.ColumnMeta;\n+import io.seata.rm.datasource.sql.struct.Field;\n+import io.seata.rm.datasource.sql.struct.Row;\n+import io.seata.rm.datasource.sql.struct.TableMeta;\n+import io.seata.rm.datasource.sql.struct.TableRecords;\n+import io.seata.rm.datasource.undo.SQLUndoLog;\n+import io.seata.sqlparser.SQLInsertRecognizer;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.SQLType;\n+import io.seata.sqlparser.struct.Defaultable;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * @version: 1.00.00\n+ * @description:\n+ * @author: yangyicong\n+ * @date: 2020-11-26 09:06", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32b0318010e39dfbaba18b6379cf7be0214e3ada"}, "originalPosition": 57}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e8b4494ef2b8de8660e629aab88261df5a8d0603", "author": {"user": {"login": "huan415", "name": null}}, "url": "https://github.com/seata/seata/commit/e8b4494ef2b8de8660e629aab88261df5a8d0603", "committedDate": "2021-01-09T13:58:37Z", "message": "add the test case of insertorUpdate"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "45b69e4496adb1f93b3ad9301b9c934190c189c5", "author": {"user": {"login": "huan415", "name": null}}, "url": "https://github.com/seata/seata/commit/45b69e4496adb1f93b3ad9301b9c934190c189c5", "committedDate": "2021-01-10T05:37:58Z", "message": "Optimize code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3e5b6175b1f891d6253d4aa742687572d6d5442c", "author": {"user": {"login": "huan415", "name": null}}, "url": "https://github.com/seata/seata/commit/3e5b6175b1f891d6253d4aa742687572d6d5442c", "committedDate": "2021-01-10T05:46:42Z", "message": "remmove redundant import"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcxOTYxOTA2", "url": "https://github.com/seata/seata/pull/3374#pullrequestreview-571961906", "createdAt": "2021-01-20T08:17:16Z", "commit": {"oid": "3e5b6175b1f891d6253d4aa742687572d6d5442c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMFQwODoxNzoxNlrOIWxxlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMFQwODoxNzoxNlrOIWxxlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDc1NTA5Mg==", "bodyText": "imageParamperterMap.computeIfAbsent(m,k->new ArrayList<>())", "url": "https://github.com/seata/seata/pull/3374#discussion_r560755092", "createdAt": "2021-01-20T08:17:16Z", "author": {"login": "a364176773"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "diffHunk": "@@ -0,0 +1,381 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec.mysql;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import com.google.common.base.Joiner;\n+import io.seata.common.exception.NotSupportYetException;\n+import io.seata.common.loader.LoadLevel;\n+import io.seata.common.loader.Scope;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.IOUtil;\n+import io.seata.common.util.StringUtils;\n+import io.seata.rm.datasource.ConnectionProxy;\n+import io.seata.rm.datasource.PreparedStatementProxy;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.StatementCallback;\n+import io.seata.rm.datasource.sql.struct.ColumnMeta;\n+import io.seata.rm.datasource.sql.struct.Field;\n+import io.seata.rm.datasource.sql.struct.Row;\n+import io.seata.rm.datasource.sql.struct.TableMeta;\n+import io.seata.rm.datasource.sql.struct.TableRecords;\n+import io.seata.rm.datasource.undo.SQLUndoLog;\n+import io.seata.sqlparser.SQLInsertRecognizer;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.SQLType;\n+import io.seata.sqlparser.struct.Defaultable;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * @author: yangyicong\n+ */\n+@LoadLevel(name = JdbcConstants.MYSQL, scope = Scope.PROTOTYPE)\n+public class MySQLInsertOrUpdateExecutor extends MySQLInsertExecutor implements Defaultable {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MySQLInsertOrUpdateExecutor.class);\n+\n+    /**\n+     * is updated or not\n+     */\n+    private boolean isUpdateFlag = false;\n+\n+    public String getSelectSQL() {\n+        return selectSQL;\n+    }\n+\n+    /**\n+     * before image sql and after image sql,condition is unique index\n+     */\n+    private String selectSQL;\n+\n+    public ArrayList<List<Object>> getParamAppenderList() {\n+        return paramAppenderList;\n+    }\n+\n+    /**\n+     * the params of selectSQL, value is the unique index\n+     */\n+    private ArrayList<List<Object>> paramAppenderList;\n+\n+    /**\n+     * key is unique index name, value is unique index\n+     */\n+    private Map<String, List<String>> beforeUniqueIndexMap = new HashMap<>();\n+\n+    public MySQLInsertOrUpdateExecutor(StatementProxy statementProxy, StatementCallback statementCallback, SQLRecognizer sqlRecognizer) {\n+        super(statementProxy, statementCallback, sqlRecognizer);\n+    }\n+\n+    /**\n+     * Execute auto commit false t.\n+     *\n+     * @param args the args\n+     * @return the t\n+     * @throws Exception the exception\n+     */\n+    @Override\n+    protected Object executeAutoCommitFalse(Object[] args) throws Exception {\n+        if (!JdbcConstants.MYSQL.equalsIgnoreCase(getDbType()) && getTableMeta().getPrimaryKeyOnlyName().size() > 1) {\n+            throw new NotSupportYetException(\"multi pk only support mysql!\");\n+        }\n+        TableRecords beforeImage = beforeImage();\n+        if (CollectionUtils.isNotEmpty(beforeImage.getRows())) {\n+            isUpdateFlag = true;\n+        } else {\n+            beforeImage = TableRecords.empty(getTableMeta());\n+        }\n+        Object result = statementCallback.execute(statementProxy.getTargetStatement(), args);\n+        TableRecords afterImage = afterImage(beforeImage);\n+        prepareUndoLogAll(beforeImage, afterImage);\n+        return result;\n+    }\n+\n+    /**\n+     * prepare undo log.\n+     *\n+     * @param beforeImage the before image\n+     * @param afterImage  the after image\n+     * @throws SQLException the sql exception\n+     */\n+    protected void prepareUndoLogAll(TableRecords beforeImage, TableRecords afterImage) {\n+        if (beforeImage.getRows().isEmpty() && afterImage.getRows().isEmpty()) {\n+            return;\n+        }\n+        ConnectionProxy connectionProxy = statementProxy.getConnectionProxy();\n+        TableRecords lockKeyRecords = afterImage;\n+        String lockKeys = buildLockKey(lockKeyRecords);\n+        connectionProxy.appendLockKey(lockKeys);\n+        buildUndoItemAll(connectionProxy,beforeImage, afterImage);\n+    }\n+\n+    /**\n+     * build a SQLUndoLog\n+     *\n+     * @param beforeImage the before image\n+     * @param afterImage  the after image\n+     * @return sql undo log\n+     */\n+    protected void buildUndoItemAll(ConnectionProxy connectionProxy, TableRecords beforeImage, TableRecords afterImage) {\n+        if (!isUpdateFlag) {\n+            SQLUndoLog sqlUndoLog = buildUndoItem(TableRecords.empty(getTableMeta()), afterImage);\n+            connectionProxy.appendUndoLog(sqlUndoLog);\n+            return;\n+        }\n+        List<Row> beforeImageRows = beforeImage.getRows();\n+        for (Row r : beforeImageRows) {\n+            getTableMeta().getAllIndexes().forEach((k, v) -> {\n+                if (!\"PRIMARY\".equals(k.toUpperCase()) && !v.isNonUnique()) {\n+                    StringBuilder everyRowIndex = new StringBuilder();\n+                    v.getValues().forEach(m -> {\n+                        for (Field f : r.getFields()) {\n+                            if (m.getColumnName().equals(f.getName())) {\n+                                everyRowIndex.append(f.getValue());\n+                            }\n+                        }\n+                    });\n+                    List<String> indexList = beforeUniqueIndexMap.get(k.toUpperCase());\n+                    if (CollectionUtils.isEmpty(indexList)) {\n+                        indexList = new ArrayList<>();\n+                    }\n+                    indexList.add(everyRowIndex.toString());\n+                    beforeUniqueIndexMap.put(k.toUpperCase(), indexList);\n+                }\n+            });\n+        }\n+        List<Row> insertRows = new ArrayList<>();\n+        List<Row> updateRows = new ArrayList<>();\n+        List<Row> afterImageRows = afterImage.getRows();\n+        for (Row r : afterImageRows) {\n+            AtomicBoolean isUpdateRowsFlag = new AtomicBoolean(false);\n+            getTableMeta().getAllIndexes().forEach((k, v) -> {\n+                if (!\"PRIMARY\".equals(k.toUpperCase()) && !v.isNonUnique()) {\n+                    StringBuilder everyRowIndex = new StringBuilder();\n+                    v.getValues().forEach(m -> {\n+                        for (Field f : r.getFields()) {\n+                            if (m.getColumnName().equals(f.getName())) {\n+                                everyRowIndex.append(f.getValue());\n+                            }\n+                        }\n+                    });\n+                    List<String> indexList = beforeUniqueIndexMap.get(k.toUpperCase());\n+                    if (CollectionUtils.isNotEmpty(indexList)) {\n+                        indexList.forEach(m -> {\n+                            if (m.equals(everyRowIndex.toString())) {\n+                                isUpdateRowsFlag.set(true);\n+                            }\n+                        });\n+                    }\n+                }\n+            });\n+            if (isUpdateRowsFlag.get()) {\n+                updateRows.add(r);\n+            } else {\n+                insertRows.add(r);\n+            }\n+        }\n+        if (CollectionUtils.isNotEmpty(updateRows)) {\n+            TableRecords partAfterImage = new TableRecords(afterImage.getTableMeta());\n+            partAfterImage.setTableName(afterImage.getTableName());\n+            partAfterImage.setRows(updateRows);\n+            connectionProxy.appendUndoLog(buildUndoItem(SQLType.UPDATE, beforeImage, partAfterImage));\n+        }\n+        if (CollectionUtils.isNotEmpty(insertRows)) {\n+            TableRecords partAfterImage = new TableRecords(afterImage.getTableMeta());\n+            partAfterImage.setTableName(afterImage.getTableName());\n+            partAfterImage.setRows(insertRows);\n+            connectionProxy.appendUndoLog(buildUndoItem(TableRecords.empty(getTableMeta()), partAfterImage));\n+        }\n+    }\n+\n+    /**\n+     * build a SQLUndoLog\n+     * @param sqlType\n+     * @param beforeImage\n+     * @param afterImage\n+     * @return\n+     */\n+    protected SQLUndoLog buildUndoItem(SQLType sqlType, TableRecords beforeImage, TableRecords afterImage) {\n+        String tableName = sqlRecognizer.getTableName();\n+        SQLUndoLog sqlUndoLog = new SQLUndoLog();\n+        sqlUndoLog.setSqlType(sqlType);\n+        sqlUndoLog.setTableName(tableName);\n+        sqlUndoLog.setBeforeImage(beforeImage);\n+        sqlUndoLog.setAfterImage(afterImage);\n+        return sqlUndoLog;\n+    }\n+\n+\n+    @Override\n+    protected TableRecords afterImage(TableRecords beforeImage) throws SQLException {\n+        if (isUpdateFlag) {\n+            return buildImage();\n+        } else {\n+            Map<String, List<Object>> pkValues = getPkValues();\n+            return afterImageInsert(pkValues);\n+        }\n+    }\n+\n+    private TableRecords afterImageInsert(Map<String, List<Object>> pkValues) throws SQLException {\n+        TableRecords afterImage = buildTableRecords(pkValues);\n+        if (afterImage == null) {\n+            throw new SQLException(\"Failed to build after-image for insert\");\n+        }\n+        return afterImage;\n+    }\n+\n+    @Override\n+    public TableRecords beforeImage() throws SQLException {\n+        return buildImage();\n+    }\n+\n+    /**\n+     * build before image and after image\n+     * @return\n+     * @throws SQLException\n+     */\n+    protected TableRecords buildImage() throws SQLException {\n+        TableMeta tmeta = getTableMeta();\n+        //after image sql the same of before image\n+        if (StringUtils.isBlank(selectSQL)) {\n+            paramAppenderList = new ArrayList<>();\n+            selectSQL = buildImageSQL(tmeta);\n+        }\n+        return buildTableRecords2(tmeta, selectSQL, paramAppenderList);\n+    }\n+\n+    /**\n+     *  build TableRecords\n+     * @param tableMeta\n+     * @param selectSQL\n+     * @param paramAppenderList\n+     * @return\n+     * @throws SQLException\n+     */\n+    public TableRecords buildTableRecords2(TableMeta tableMeta, String selectSQL, ArrayList<List<Object>> paramAppenderList) throws SQLException {\n+        ResultSet rs = null;\n+        try (PreparedStatement ps = statementProxy.getConnection().prepareStatement(selectSQL)) {\n+            if (CollectionUtils.isNotEmpty(paramAppenderList)) {\n+                for (int i = 0, ts = paramAppenderList.size(); i < ts; i++) {\n+                    List<Object> paramAppender = paramAppenderList.get(i);\n+                    for (int j = 0, ds = paramAppender.size(); j < ds; j++) {\n+                        ps.setObject(i * ds + j + 1, \"NULL\".equals(paramAppender.get(j).toString()) ? null : paramAppender.get(j));\n+                    }\n+                }\n+            }\n+            rs = ps.executeQuery();\n+            return TableRecords.buildRecords(tableMeta, rs);\n+        } finally {\n+            IOUtil.close(rs);\n+        }\n+    }\n+\n+    /**\n+     * build image sql\n+     * @param tableMeta\n+     * @return\n+     */\n+    public String buildImageSQL(TableMeta tableMeta) {\n+        if (CollectionUtils.isEmpty(paramAppenderList)) {\n+            paramAppenderList = new ArrayList<>();\n+        }\n+        SQLInsertRecognizer recognizer = (SQLInsertRecognizer) sqlRecognizer;\n+        int insertNum = recognizer.getInsertParamsValue().size();\n+        Map<String, ArrayList<Object>> imageParamperterMap =  buildImageParamperters(recognizer);\n+        StringBuilder prefix = new StringBuilder(\"SELECT * \");\n+        StringBuilder suffix = new StringBuilder(\" FROM \").append(getFromTableInSQL());\n+        boolean[] isContainWhere = {false};\n+        for (int i = 0; i < insertNum; i++) {\n+            int finalI = i;\n+            List<Object> paramAppenderTempList = new ArrayList<>();\n+            tableMeta.getAllIndexes().forEach((k, v) -> {\n+                if (!v.isNonUnique()) {\n+                    List<String> uniqueList = new ArrayList<>();\n+                    for (ColumnMeta m : v.getValues()) {\n+                        String columnName = m.getColumnName();\n+                        if (imageParamperterMap.get(columnName) == null || imageParamperterMap.get(columnName).get(finalI) == null) {\n+                            continue;\n+                        }\n+                        uniqueList.add(columnName + \" = ? \");\n+                        paramAppenderTempList.add(imageParamperterMap.get(columnName).get(finalI));\n+                    }\n+                    if (isContainWhere[0]) {\n+                        suffix.append(\" OR (\").append(Joiner.on(\" and \").join(uniqueList)).append(\") \");\n+                    } else {\n+                        suffix.append(\" WHERE (\").append(Joiner.on(\" and \").join(uniqueList)).append(\") \");\n+                        isContainWhere[0] = true;\n+                    }\n+                }\n+            });\n+            paramAppenderList.add(paramAppenderTempList);\n+        }\n+        suffix.append(\" FOR UPDATE\");\n+        StringJoiner selectSQLJoin = new StringJoiner(\", \", prefix.toString(), suffix.toString());\n+        return selectSQLJoin.toString();\n+    }\n+\n+    /**\n+     * build sql params\n+     * @param recognizer\n+     * @return\n+     */\n+    public Map<String, ArrayList<Object>> buildImageParamperters(SQLInsertRecognizer recognizer) {\n+        Map<String, ArrayList<Object>> imageParamperterMap = new HashMap<>();\n+        Map<Integer, ArrayList<Object>> parameters = ((PreparedStatementProxy) statementProxy).getParameters();\n+        //  VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)   VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)\n+        List<String> insertParamsList = recognizer.getInsertParamsValue();\n+        List<String> insertColumns = recognizer.getInsertColumns();\n+        int paramsindex = 1;\n+        for (String insertParams : insertParamsList) {\n+            String[] insertParamsArray = insertParams.split(\",\");\n+            for (int i = 0; i < insertColumns.size(); i++) {\n+                String m = insertColumns.get(i);\n+                String params = insertParamsArray[i];\n+                ArrayList<Object> imageListTemp = imageParamperterMap.get(m);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e5b6175b1f891d6253d4aa742687572d6d5442c"}, "originalPosition": 357}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a3145349c98669a58f2513b61e58e9667c9f1e79", "author": {"user": {"login": "huan415", "name": null}}, "url": "https://github.com/seata/seata/commit/a3145349c98669a58f2513b61e58e9667c9f1e79", "committedDate": "2021-01-23T00:39:59Z", "message": "optimize code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0fb31f43da21f8bed23906748688bb7061a9b7ea", "author": {"user": {"login": "huan415", "name": null}}, "url": "https://github.com/seata/seata/commit/0fb31f43da21f8bed23906748688bb7061a9b7ea", "committedDate": "2021-01-23T00:48:40Z", "message": "optimize code"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTg0Mjk4NzI0", "url": "https://github.com/seata/seata/pull/3374#pullrequestreview-584298724", "createdAt": "2021-02-05T12:37:41Z", "commit": {"oid": "0fb31f43da21f8bed23906748688bb7061a9b7ea"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNVQxMjozNzo0MVrOIgfV9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNVQxMjo0Njo0N1rOIgfogQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDkzODg2OA==", "bodyText": "else throw new NotSupportYetException ?", "url": "https://github.com/seata/seata/pull/3374#discussion_r570938868", "createdAt": "2021-02-05T12:37:41Z", "author": {"login": "caohdgege"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/ExecuteTemplate.java", "diffHunk": "@@ -98,6 +101,11 @@\n                     case SELECT_FOR_UPDATE:\n                         executor = new SelectForUpdateExecutor<>(statementProxy, statementCallback, sqlRecognizer);\n                         break;\n+                    case INSERT_ON_DUPLICATE_UPDATE:\n+                        if (JdbcConstants.MYSQL.equals(dbType)) {\n+                            executor = new MySQLInsertOrUpdateExecutor(statementProxy,statementCallback,sqlRecognizer);\n+                        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fb31f43da21f8bed23906748688bb7061a9b7ea"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDkzOTA1MA==", "bodyText": "\u8fd9\u91cc\u4e3a\u4ec0\u4e48\u6ce8\u91ca\u6389\u7684\uff1f", "url": "https://github.com/seata/seata/pull/3374#discussion_r570939050", "createdAt": "2021-02-05T12:38:03Z", "author": {"login": "caohdgege"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/ExecuteTemplate.java", "diffHunk": "@@ -98,6 +101,11 @@\n                     case SELECT_FOR_UPDATE:\n                         executor = new SelectForUpdateExecutor<>(statementProxy, statementCallback, sqlRecognizer);\n                         break;\n+                    case INSERT_ON_DUPLICATE_UPDATE:\n+                        if (JdbcConstants.MYSQL.equals(dbType)) {\n+                            executor = new MySQLInsertOrUpdateExecutor(statementProxy,statementCallback,sqlRecognizer);\n+                        }\n+                        //  break;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fb31f43da21f8bed23906748688bb7061a9b7ea"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDk0MzYxNw==", "bodyText": "\u8fd9\u91cc\u7684\u67e5\u8be2\u7684\u5b57\u6bb5\uff0c\u662f\u5426\u9700\u8981\u53d7onlyCareUpdateColumns\u8fd9\u4e2a\u53c2\u6570\u7684\u5f71\u54cd\uff1f", "url": "https://github.com/seata/seata/pull/3374#discussion_r570943617", "createdAt": "2021-02-05T12:46:47Z", "author": {"login": "caohdgege"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "diffHunk": "@@ -0,0 +1,375 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec.mysql;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import com.google.common.base.Joiner;\n+import io.seata.common.exception.NotSupportYetException;\n+import io.seata.common.loader.LoadLevel;\n+import io.seata.common.loader.Scope;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.IOUtil;\n+import io.seata.common.util.StringUtils;\n+import io.seata.rm.datasource.ConnectionProxy;\n+import io.seata.rm.datasource.PreparedStatementProxy;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.StatementCallback;\n+import io.seata.rm.datasource.sql.struct.ColumnMeta;\n+import io.seata.rm.datasource.sql.struct.Field;\n+import io.seata.rm.datasource.sql.struct.Row;\n+import io.seata.rm.datasource.sql.struct.TableMeta;\n+import io.seata.rm.datasource.sql.struct.TableRecords;\n+import io.seata.rm.datasource.undo.SQLUndoLog;\n+import io.seata.sqlparser.SQLInsertRecognizer;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.SQLType;\n+import io.seata.sqlparser.struct.Defaultable;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * @author: yangyicong\n+ */\n+@LoadLevel(name = JdbcConstants.MYSQL, scope = Scope.PROTOTYPE)\n+public class MySQLInsertOrUpdateExecutor extends MySQLInsertExecutor implements Defaultable {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MySQLInsertOrUpdateExecutor.class);\n+\n+    /**\n+     * is updated or not\n+     */\n+    private boolean isUpdateFlag = false;\n+\n+    public String getSelectSQL() {\n+        return selectSQL;\n+    }\n+\n+    /**\n+     * before image sql and after image sql,condition is unique index\n+     */\n+    private String selectSQL;\n+\n+    public ArrayList<List<Object>> getParamAppenderList() {\n+        return paramAppenderList;\n+    }\n+\n+    /**\n+     * the params of selectSQL, value is the unique index\n+     */\n+    private ArrayList<List<Object>> paramAppenderList;\n+\n+    /**\n+     * key is unique index name, value is unique index\n+     */\n+    private Map<String, List<String>> beforeUniqueIndexMap = new HashMap<>();\n+\n+    public MySQLInsertOrUpdateExecutor(StatementProxy statementProxy, StatementCallback statementCallback, SQLRecognizer sqlRecognizer) {\n+        super(statementProxy, statementCallback, sqlRecognizer);\n+    }\n+\n+    /**\n+     * Execute auto commit false t.\n+     *\n+     * @param args the args\n+     * @return the t\n+     * @throws Exception the exception\n+     */\n+    @Override\n+    protected Object executeAutoCommitFalse(Object[] args) throws Exception {\n+        if (!JdbcConstants.MYSQL.equalsIgnoreCase(getDbType()) && getTableMeta().getPrimaryKeyOnlyName().size() > 1) {\n+            throw new NotSupportYetException(\"multi pk only support mysql!\");\n+        }\n+        TableRecords beforeImage = beforeImage();\n+        if (CollectionUtils.isNotEmpty(beforeImage.getRows())) {\n+            isUpdateFlag = true;\n+        } else {\n+            beforeImage = TableRecords.empty(getTableMeta());\n+        }\n+        Object result = statementCallback.execute(statementProxy.getTargetStatement(), args);\n+        TableRecords afterImage = afterImage(beforeImage);\n+        prepareUndoLogAll(beforeImage, afterImage);\n+        return result;\n+    }\n+\n+    /**\n+     * prepare undo log.\n+     *\n+     * @param beforeImage the before image\n+     * @param afterImage  the after image\n+     * @throws SQLException the sql exception\n+     */\n+    protected void prepareUndoLogAll(TableRecords beforeImage, TableRecords afterImage) {\n+        if (beforeImage.getRows().isEmpty() && afterImage.getRows().isEmpty()) {\n+            return;\n+        }\n+        ConnectionProxy connectionProxy = statementProxy.getConnectionProxy();\n+        TableRecords lockKeyRecords = afterImage;\n+        String lockKeys = buildLockKey(lockKeyRecords);\n+        connectionProxy.appendLockKey(lockKeys);\n+        buildUndoItemAll(connectionProxy,beforeImage, afterImage);\n+    }\n+\n+    /**\n+     * build a SQLUndoLog\n+     *\n+     * @param beforeImage the before image\n+     * @param afterImage  the after image\n+     * @return sql undo log\n+     */\n+    protected void buildUndoItemAll(ConnectionProxy connectionProxy, TableRecords beforeImage, TableRecords afterImage) {\n+        if (!isUpdateFlag) {\n+            SQLUndoLog sqlUndoLog = buildUndoItem(TableRecords.empty(getTableMeta()), afterImage);\n+            connectionProxy.appendUndoLog(sqlUndoLog);\n+            return;\n+        }\n+        List<Row> beforeImageRows = beforeImage.getRows();\n+        for (Row r : beforeImageRows) {\n+            getTableMeta().getAllIndexes().forEach((k, v) -> {\n+                if (!\"PRIMARY\".equals(k.toUpperCase()) && !v.isNonUnique()) {\n+                    StringBuilder everyRowIndex = new StringBuilder();\n+                    v.getValues().forEach(m -> {\n+                        for (Field f : r.getFields()) {\n+                            if (m.getColumnName().equals(f.getName())) {\n+                                everyRowIndex.append(f.getValue());\n+                            }\n+                        }\n+                    });\n+                    List<String> indexList = beforeUniqueIndexMap.computeIfAbsent(k.toUpperCase(),key -> new ArrayList<>());\n+                    indexList.add(everyRowIndex.toString());\n+                    beforeUniqueIndexMap.put(k.toUpperCase(), indexList);\n+                }\n+            });\n+        }\n+        List<Row> insertRows = new ArrayList<>();\n+        List<Row> updateRows = new ArrayList<>();\n+        List<Row> afterImageRows = afterImage.getRows();\n+        for (Row r : afterImageRows) {\n+            AtomicBoolean isUpdateRowsFlag = new AtomicBoolean(false);\n+            getTableMeta().getAllIndexes().forEach((k, v) -> {\n+                if (!\"PRIMARY\".equals(k.toUpperCase()) && !v.isNonUnique()) {\n+                    StringBuilder everyRowIndex = new StringBuilder();\n+                    v.getValues().forEach(m -> {\n+                        for (Field f : r.getFields()) {\n+                            if (m.getColumnName().equals(f.getName())) {\n+                                everyRowIndex.append(f.getValue());\n+                            }\n+                        }\n+                    });\n+                    List<String> indexList = beforeUniqueIndexMap.get(k.toUpperCase());\n+                    if (CollectionUtils.isNotEmpty(indexList)) {\n+                        indexList.forEach(m -> {\n+                            if (m.equals(everyRowIndex.toString())) {\n+                                isUpdateRowsFlag.set(true);\n+                            }\n+                        });\n+                    }\n+                }\n+            });\n+            if (isUpdateRowsFlag.get()) {\n+                updateRows.add(r);\n+            } else {\n+                insertRows.add(r);\n+            }\n+        }\n+        if (CollectionUtils.isNotEmpty(updateRows)) {\n+            TableRecords partAfterImage = new TableRecords(afterImage.getTableMeta());\n+            partAfterImage.setTableName(afterImage.getTableName());\n+            partAfterImage.setRows(updateRows);\n+            connectionProxy.appendUndoLog(buildUndoItem(SQLType.UPDATE, beforeImage, partAfterImage));\n+        }\n+        if (CollectionUtils.isNotEmpty(insertRows)) {\n+            TableRecords partAfterImage = new TableRecords(afterImage.getTableMeta());\n+            partAfterImage.setTableName(afterImage.getTableName());\n+            partAfterImage.setRows(insertRows);\n+            connectionProxy.appendUndoLog(buildUndoItem(TableRecords.empty(getTableMeta()), partAfterImage));\n+        }\n+    }\n+\n+    /**\n+     * build a SQLUndoLog\n+     * @param sqlType\n+     * @param beforeImage\n+     * @param afterImage\n+     * @return\n+     */\n+    protected SQLUndoLog buildUndoItem(SQLType sqlType, TableRecords beforeImage, TableRecords afterImage) {\n+        String tableName = sqlRecognizer.getTableName();\n+        SQLUndoLog sqlUndoLog = new SQLUndoLog();\n+        sqlUndoLog.setSqlType(sqlType);\n+        sqlUndoLog.setTableName(tableName);\n+        sqlUndoLog.setBeforeImage(beforeImage);\n+        sqlUndoLog.setAfterImage(afterImage);\n+        return sqlUndoLog;\n+    }\n+\n+\n+    @Override\n+    protected TableRecords afterImage(TableRecords beforeImage) throws SQLException {\n+        if (isUpdateFlag) {\n+            return buildImage();\n+        } else {\n+            Map<String, List<Object>> pkValues = getPkValues();\n+            return afterImageInsert(pkValues);\n+        }\n+    }\n+\n+    private TableRecords afterImageInsert(Map<String, List<Object>> pkValues) throws SQLException {\n+        TableRecords afterImage = buildTableRecords(pkValues);\n+        if (afterImage == null) {\n+            throw new SQLException(\"Failed to build after-image for insert\");\n+        }\n+        return afterImage;\n+    }\n+\n+    @Override\n+    public TableRecords beforeImage() throws SQLException {\n+        return buildImage();\n+    }\n+\n+    /**\n+     * build before image and after image\n+     * @return\n+     * @throws SQLException\n+     */\n+    protected TableRecords buildImage() throws SQLException {\n+        TableMeta tmeta = getTableMeta();\n+        //after image sql the same of before image\n+        if (StringUtils.isBlank(selectSQL)) {\n+            paramAppenderList = new ArrayList<>();\n+            selectSQL = buildImageSQL(tmeta);\n+        }\n+        return buildTableRecords2(tmeta, selectSQL, paramAppenderList);\n+    }\n+\n+    /**\n+     *  build TableRecords\n+     * @param tableMeta\n+     * @param selectSQL\n+     * @param paramAppenderList\n+     * @return\n+     * @throws SQLException\n+     */\n+    public TableRecords buildTableRecords2(TableMeta tableMeta, String selectSQL, ArrayList<List<Object>> paramAppenderList) throws SQLException {\n+        ResultSet rs = null;\n+        try (PreparedStatement ps = statementProxy.getConnection().prepareStatement(selectSQL)) {\n+            if (CollectionUtils.isNotEmpty(paramAppenderList)) {\n+                for (int i = 0, ts = paramAppenderList.size(); i < ts; i++) {\n+                    List<Object> paramAppender = paramAppenderList.get(i);\n+                    for (int j = 0, ds = paramAppender.size(); j < ds; j++) {\n+                        ps.setObject(i * ds + j + 1, \"NULL\".equals(paramAppender.get(j).toString()) ? null : paramAppender.get(j));\n+                    }\n+                }\n+            }\n+            rs = ps.executeQuery();\n+            return TableRecords.buildRecords(tableMeta, rs);\n+        } finally {\n+            IOUtil.close(rs);\n+        }\n+    }\n+\n+    /**\n+     * build image sql\n+     * @param tableMeta\n+     * @return\n+     */\n+    public String buildImageSQL(TableMeta tableMeta) {\n+        if (CollectionUtils.isEmpty(paramAppenderList)) {\n+            paramAppenderList = new ArrayList<>();\n+        }\n+        SQLInsertRecognizer recognizer = (SQLInsertRecognizer) sqlRecognizer;\n+        int insertNum = recognizer.getInsertParamsValue().size();\n+        Map<String, ArrayList<Object>> imageParamperterMap =  buildImageParamperters(recognizer);\n+        StringBuilder prefix = new StringBuilder(\"SELECT * \");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fb31f43da21f8bed23906748688bb7061a9b7ea"}, "originalPosition": 305}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cb3dc6a44f363f7cc7510b870e762d8cf80d20c0", "author": {"user": {"login": "huan415", "name": null}}, "url": "https://github.com/seata/seata/commit/cb3dc6a44f363f7cc7510b870e762d8cf80d20c0", "committedDate": "2021-02-09T14:34:57Z", "message": "throw new NotSupportYetException when oracle INSERT_ON_DUPLICATE_UPDATE"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "71ecfa47f6116eb20b44e39b78bf42910c9654c7", "author": {"user": {"login": "huan415", "name": null}}, "url": "https://github.com/seata/seata/commit/71ecfa47f6116eb20b44e39b78bf42910c9654c7", "committedDate": "2021-02-09T15:47:45Z", "message": "Specification code"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTg2NjkxNDc0", "url": "https://github.com/seata/seata/pull/3374#pullrequestreview-586691474", "createdAt": "2021-02-09T15:44:05Z", "commit": {"oid": "cb3dc6a44f363f7cc7510b870e762d8cf80d20c0"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wOVQxNTo0NDowNVrOIic_NA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wOVQxNTo0NTowMlrOIidCUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mjk5NzQyOA==", "bodyText": "\u8fd9\u91cc\u62fc\u63a5\u5b57\u7b26\u4e32\u4f1a\u4e0d\u4f1a\u4e0d\u662f\u5f88\u597d\uff1f\u50cf\u90a3\u79cd(a,b)\u7684\u8054\u5408\u552f\u4e00\u7d22\u5f15\uff0ca=1,b=22 \u548c a=12,b=2\u7684\u8bdd\uff0c\u662f\u4e0d\u662f\u4f1a\u5bfc\u81f4\u8bef\u5224\uff1f", "url": "https://github.com/seata/seata/pull/3374#discussion_r572997428", "createdAt": "2021-02-09T15:44:05Z", "author": {"login": "caohdgege"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "diffHunk": "@@ -0,0 +1,375 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec.mysql;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import com.google.common.base.Joiner;\n+import io.seata.common.exception.NotSupportYetException;\n+import io.seata.common.loader.LoadLevel;\n+import io.seata.common.loader.Scope;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.IOUtil;\n+import io.seata.common.util.StringUtils;\n+import io.seata.rm.datasource.ConnectionProxy;\n+import io.seata.rm.datasource.PreparedStatementProxy;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.StatementCallback;\n+import io.seata.rm.datasource.sql.struct.ColumnMeta;\n+import io.seata.rm.datasource.sql.struct.Field;\n+import io.seata.rm.datasource.sql.struct.Row;\n+import io.seata.rm.datasource.sql.struct.TableMeta;\n+import io.seata.rm.datasource.sql.struct.TableRecords;\n+import io.seata.rm.datasource.undo.SQLUndoLog;\n+import io.seata.sqlparser.SQLInsertRecognizer;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.SQLType;\n+import io.seata.sqlparser.struct.Defaultable;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * @author: yangyicong\n+ */\n+@LoadLevel(name = JdbcConstants.MYSQL, scope = Scope.PROTOTYPE)\n+public class MySQLInsertOrUpdateExecutor extends MySQLInsertExecutor implements Defaultable {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MySQLInsertOrUpdateExecutor.class);\n+\n+    /**\n+     * is updated or not\n+     */\n+    private boolean isUpdateFlag = false;\n+\n+    public String getSelectSQL() {\n+        return selectSQL;\n+    }\n+\n+    /**\n+     * before image sql and after image sql,condition is unique index\n+     */\n+    private String selectSQL;\n+\n+    public ArrayList<List<Object>> getParamAppenderList() {\n+        return paramAppenderList;\n+    }\n+\n+    /**\n+     * the params of selectSQL, value is the unique index\n+     */\n+    private ArrayList<List<Object>> paramAppenderList;\n+\n+    /**\n+     * key is unique index name, value is unique index\n+     */\n+    private Map<String, List<String>> beforeUniqueIndexMap = new HashMap<>();\n+\n+    public MySQLInsertOrUpdateExecutor(StatementProxy statementProxy, StatementCallback statementCallback, SQLRecognizer sqlRecognizer) {\n+        super(statementProxy, statementCallback, sqlRecognizer);\n+    }\n+\n+    /**\n+     * Execute auto commit false t.\n+     *\n+     * @param args the args\n+     * @return the t\n+     * @throws Exception the exception\n+     */\n+    @Override\n+    protected Object executeAutoCommitFalse(Object[] args) throws Exception {\n+        if (!JdbcConstants.MYSQL.equalsIgnoreCase(getDbType()) && getTableMeta().getPrimaryKeyOnlyName().size() > 1) {\n+            throw new NotSupportYetException(\"multi pk only support mysql!\");\n+        }\n+        TableRecords beforeImage = beforeImage();\n+        if (CollectionUtils.isNotEmpty(beforeImage.getRows())) {\n+            isUpdateFlag = true;\n+        } else {\n+            beforeImage = TableRecords.empty(getTableMeta());\n+        }\n+        Object result = statementCallback.execute(statementProxy.getTargetStatement(), args);\n+        TableRecords afterImage = afterImage(beforeImage);\n+        prepareUndoLogAll(beforeImage, afterImage);\n+        return result;\n+    }\n+\n+    /**\n+     * prepare undo log.\n+     *\n+     * @param beforeImage the before image\n+     * @param afterImage  the after image\n+     * @throws SQLException the sql exception\n+     */\n+    protected void prepareUndoLogAll(TableRecords beforeImage, TableRecords afterImage) {\n+        if (beforeImage.getRows().isEmpty() && afterImage.getRows().isEmpty()) {\n+            return;\n+        }\n+        ConnectionProxy connectionProxy = statementProxy.getConnectionProxy();\n+        TableRecords lockKeyRecords = afterImage;\n+        String lockKeys = buildLockKey(lockKeyRecords);\n+        connectionProxy.appendLockKey(lockKeys);\n+        buildUndoItemAll(connectionProxy,beforeImage, afterImage);\n+    }\n+\n+    /**\n+     * build a SQLUndoLog\n+     *\n+     * @param beforeImage the before image\n+     * @param afterImage  the after image\n+     * @return sql undo log\n+     */\n+    protected void buildUndoItemAll(ConnectionProxy connectionProxy, TableRecords beforeImage, TableRecords afterImage) {\n+        if (!isUpdateFlag) {\n+            SQLUndoLog sqlUndoLog = buildUndoItem(TableRecords.empty(getTableMeta()), afterImage);\n+            connectionProxy.appendUndoLog(sqlUndoLog);\n+            return;\n+        }\n+        List<Row> beforeImageRows = beforeImage.getRows();\n+        for (Row r : beforeImageRows) {\n+            getTableMeta().getAllIndexes().forEach((k, v) -> {\n+                if (!\"PRIMARY\".equals(k.toUpperCase()) && !v.isNonUnique()) {\n+                    StringBuilder everyRowIndex = new StringBuilder();\n+                    v.getValues().forEach(m -> {\n+                        for (Field f : r.getFields()) {\n+                            if (m.getColumnName().equals(f.getName())) {\n+                                everyRowIndex.append(f.getValue());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb3dc6a44f363f7cc7510b870e762d8cf80d20c0"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mjk5ODIyNA==", "bodyText": "\u8fd9\u4e00\u884c\u662f\u5426\u662f\u591a\u4f59\u7684\uff1f", "url": "https://github.com/seata/seata/pull/3374#discussion_r572998224", "createdAt": "2021-02-09T15:45:02Z", "author": {"login": "caohdgege"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "diffHunk": "@@ -0,0 +1,375 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec.mysql;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import com.google.common.base.Joiner;\n+import io.seata.common.exception.NotSupportYetException;\n+import io.seata.common.loader.LoadLevel;\n+import io.seata.common.loader.Scope;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.IOUtil;\n+import io.seata.common.util.StringUtils;\n+import io.seata.rm.datasource.ConnectionProxy;\n+import io.seata.rm.datasource.PreparedStatementProxy;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.StatementCallback;\n+import io.seata.rm.datasource.sql.struct.ColumnMeta;\n+import io.seata.rm.datasource.sql.struct.Field;\n+import io.seata.rm.datasource.sql.struct.Row;\n+import io.seata.rm.datasource.sql.struct.TableMeta;\n+import io.seata.rm.datasource.sql.struct.TableRecords;\n+import io.seata.rm.datasource.undo.SQLUndoLog;\n+import io.seata.sqlparser.SQLInsertRecognizer;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.SQLType;\n+import io.seata.sqlparser.struct.Defaultable;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * @author: yangyicong\n+ */\n+@LoadLevel(name = JdbcConstants.MYSQL, scope = Scope.PROTOTYPE)\n+public class MySQLInsertOrUpdateExecutor extends MySQLInsertExecutor implements Defaultable {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MySQLInsertOrUpdateExecutor.class);\n+\n+    /**\n+     * is updated or not\n+     */\n+    private boolean isUpdateFlag = false;\n+\n+    public String getSelectSQL() {\n+        return selectSQL;\n+    }\n+\n+    /**\n+     * before image sql and after image sql,condition is unique index\n+     */\n+    private String selectSQL;\n+\n+    public ArrayList<List<Object>> getParamAppenderList() {\n+        return paramAppenderList;\n+    }\n+\n+    /**\n+     * the params of selectSQL, value is the unique index\n+     */\n+    private ArrayList<List<Object>> paramAppenderList;\n+\n+    /**\n+     * key is unique index name, value is unique index\n+     */\n+    private Map<String, List<String>> beforeUniqueIndexMap = new HashMap<>();\n+\n+    public MySQLInsertOrUpdateExecutor(StatementProxy statementProxy, StatementCallback statementCallback, SQLRecognizer sqlRecognizer) {\n+        super(statementProxy, statementCallback, sqlRecognizer);\n+    }\n+\n+    /**\n+     * Execute auto commit false t.\n+     *\n+     * @param args the args\n+     * @return the t\n+     * @throws Exception the exception\n+     */\n+    @Override\n+    protected Object executeAutoCommitFalse(Object[] args) throws Exception {\n+        if (!JdbcConstants.MYSQL.equalsIgnoreCase(getDbType()) && getTableMeta().getPrimaryKeyOnlyName().size() > 1) {\n+            throw new NotSupportYetException(\"multi pk only support mysql!\");\n+        }\n+        TableRecords beforeImage = beforeImage();\n+        if (CollectionUtils.isNotEmpty(beforeImage.getRows())) {\n+            isUpdateFlag = true;\n+        } else {\n+            beforeImage = TableRecords.empty(getTableMeta());\n+        }\n+        Object result = statementCallback.execute(statementProxy.getTargetStatement(), args);\n+        TableRecords afterImage = afterImage(beforeImage);\n+        prepareUndoLogAll(beforeImage, afterImage);\n+        return result;\n+    }\n+\n+    /**\n+     * prepare undo log.\n+     *\n+     * @param beforeImage the before image\n+     * @param afterImage  the after image\n+     * @throws SQLException the sql exception\n+     */\n+    protected void prepareUndoLogAll(TableRecords beforeImage, TableRecords afterImage) {\n+        if (beforeImage.getRows().isEmpty() && afterImage.getRows().isEmpty()) {\n+            return;\n+        }\n+        ConnectionProxy connectionProxy = statementProxy.getConnectionProxy();\n+        TableRecords lockKeyRecords = afterImage;\n+        String lockKeys = buildLockKey(lockKeyRecords);\n+        connectionProxy.appendLockKey(lockKeys);\n+        buildUndoItemAll(connectionProxy,beforeImage, afterImage);\n+    }\n+\n+    /**\n+     * build a SQLUndoLog\n+     *\n+     * @param beforeImage the before image\n+     * @param afterImage  the after image\n+     * @return sql undo log\n+     */\n+    protected void buildUndoItemAll(ConnectionProxy connectionProxy, TableRecords beforeImage, TableRecords afterImage) {\n+        if (!isUpdateFlag) {\n+            SQLUndoLog sqlUndoLog = buildUndoItem(TableRecords.empty(getTableMeta()), afterImage);\n+            connectionProxy.appendUndoLog(sqlUndoLog);\n+            return;\n+        }\n+        List<Row> beforeImageRows = beforeImage.getRows();\n+        for (Row r : beforeImageRows) {\n+            getTableMeta().getAllIndexes().forEach((k, v) -> {\n+                if (!\"PRIMARY\".equals(k.toUpperCase()) && !v.isNonUnique()) {\n+                    StringBuilder everyRowIndex = new StringBuilder();\n+                    v.getValues().forEach(m -> {\n+                        for (Field f : r.getFields()) {\n+                            if (m.getColumnName().equals(f.getName())) {\n+                                everyRowIndex.append(f.getValue());\n+                            }\n+                        }\n+                    });\n+                    List<String> indexList = beforeUniqueIndexMap.computeIfAbsent(k.toUpperCase(),key -> new ArrayList<>());\n+                    indexList.add(everyRowIndex.toString());\n+                    beforeUniqueIndexMap.put(k.toUpperCase(), indexList);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb3dc6a44f363f7cc7510b870e762d8cf80d20c0"}, "originalPosition": 162}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6f503bbdcf402cc720ea484d36d01166d41fa9ce", "author": {"user": {"login": "huan415", "name": null}}, "url": "https://github.com/seata/seata/commit/6f503bbdcf402cc720ea484d36d01166d41fa9ce", "committedDate": "2021-02-10T00:39:25Z", "message": "resove unique value is conflict"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b3f2852e1d7ded3edaa9bfda14af935ac8be0896", "author": {"user": {"login": "huan415", "name": null}}, "url": "https://github.com/seata/seata/commit/b3f2852e1d7ded3edaa9bfda14af935ac8be0896", "committedDate": "2021-02-10T08:18:18Z", "message": "Merge pull request #2 from seata/develop\n\nmerge origin seata project"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f30c2a9d6940566e20765cadb6842fee173020df", "author": {"user": {"login": "huan415", "name": null}}, "url": "https://github.com/seata/seata/commit/f30c2a9d6940566e20765cadb6842fee173020df", "committedDate": "2021-02-10T09:19:36Z", "message": "changes/1.5.0.md"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "15f016a7424683edb3be869b18591b8fe179d919", "author": {"user": {"login": "xingfudeshi", "name": "xingfudeshi"}}, "url": "https://github.com/seata/seata/commit/15f016a7424683edb3be869b18591b8fe179d919", "committedDate": "2021-02-18T08:17:43Z", "message": "Merge branch 'develop' into develop"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkyOTU3MzE5", "url": "https://github.com/seata/seata/pull/3374#pullrequestreview-592957319", "createdAt": "2021-02-18T08:28:37Z", "commit": {"oid": "15f016a7424683edb3be869b18591b8fe179d919"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xOFQwODoyODozN1rOInbv7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xOFQwODoyODozN1rOInbv7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3ODIyMDAxMg==", "bodyText": "please remove :", "url": "https://github.com/seata/seata/pull/3374#discussion_r578220012", "createdAt": "2021-02-18T08:28:37Z", "author": {"login": "xingfudeshi"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "diffHunk": "@@ -0,0 +1,380 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec.mysql;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import com.google.common.base.Joiner;\n+import io.seata.common.exception.NotSupportYetException;\n+import io.seata.common.loader.LoadLevel;\n+import io.seata.common.loader.Scope;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.IOUtil;\n+import io.seata.common.util.StringUtils;\n+import io.seata.rm.datasource.ConnectionProxy;\n+import io.seata.rm.datasource.PreparedStatementProxy;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.StatementCallback;\n+import io.seata.rm.datasource.sql.struct.ColumnMeta;\n+import io.seata.rm.datasource.sql.struct.Field;\n+import io.seata.rm.datasource.sql.struct.Row;\n+import io.seata.rm.datasource.sql.struct.TableMeta;\n+import io.seata.rm.datasource.sql.struct.TableRecords;\n+import io.seata.rm.datasource.undo.SQLUndoLog;\n+import io.seata.sqlparser.SQLInsertRecognizer;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.SQLType;\n+import io.seata.sqlparser.struct.Defaultable;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * @author: yangyicong", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15f016a7424683edb3be869b18591b8fe179d919"}, "originalPosition": 54}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkyOTU3OTQ4", "url": "https://github.com/seata/seata/pull/3374#pullrequestreview-592957948", "createdAt": "2021-02-18T08:29:20Z", "commit": {"oid": "15f016a7424683edb3be869b18591b8fe179d919"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xOFQwODoyOToyMFrOInbx5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xOFQwODoyOToyMFrOInbx5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3ODIyMDUxNw==", "bodyText": "please remove :", "url": "https://github.com/seata/seata/pull/3374#discussion_r578220517", "createdAt": "2021-02-18T08:29:20Z", "author": {"login": "xingfudeshi"}, "path": "rm-datasource/src/test/java/io/seata/rm/datasource/exec/MySQLInsertOrUpdateExecutorTest.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec;\n+\n+import com.google.common.collect.Lists;\n+import io.seata.common.exception.ShouldNeverHappenException;\n+import io.seata.rm.datasource.ConnectionProxy;\n+import io.seata.rm.datasource.PreparedStatementProxy;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.mysql.MySQLInsertExecutor;\n+import io.seata.rm.datasource.exec.mysql.MySQLInsertOrUpdateExecutor;\n+import io.seata.rm.datasource.sql.struct.*;\n+import io.seata.sqlparser.SQLInsertRecognizer;\n+import io.seata.sqlparser.struct.Null;\n+import io.seata.sqlparser.struct.SqlDefaultExpr;\n+import io.seata.sqlparser.struct.SqlMethodExpr;\n+import io.seata.sqlparser.struct.SqlSequenceExpr;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mockito;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.*;\n+\n+import static org.mockito.Mockito.*;\n+\n+/**\n+ * @author: yangyicong", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15f016a7424683edb3be869b18591b8fe179d919"}, "originalPosition": 45}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkyOTU4MTMx", "url": "https://github.com/seata/seata/pull/3374#pullrequestreview-592958131", "createdAt": "2021-02-18T08:29:32Z", "commit": {"oid": "15f016a7424683edb3be869b18591b8fe179d919"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xOFQwODoyOTozMlrOInbyYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xOFQwODoyOTozMlrOInbyYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3ODIyMDY0MA==", "bodyText": "Please do not use *.", "url": "https://github.com/seata/seata/pull/3374#discussion_r578220640", "createdAt": "2021-02-18T08:29:32Z", "author": {"login": "xingfudeshi"}, "path": "rm-datasource/src/test/java/io/seata/rm/datasource/exec/MySQLInsertOrUpdateExecutorTest.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec;\n+\n+import com.google.common.collect.Lists;\n+import io.seata.common.exception.ShouldNeverHappenException;\n+import io.seata.rm.datasource.ConnectionProxy;\n+import io.seata.rm.datasource.PreparedStatementProxy;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.mysql.MySQLInsertExecutor;\n+import io.seata.rm.datasource.exec.mysql.MySQLInsertOrUpdateExecutor;\n+import io.seata.rm.datasource.sql.struct.*;\n+import io.seata.sqlparser.SQLInsertRecognizer;\n+import io.seata.sqlparser.struct.Null;\n+import io.seata.sqlparser.struct.SqlDefaultExpr;\n+import io.seata.sqlparser.struct.SqlMethodExpr;\n+import io.seata.sqlparser.struct.SqlSequenceExpr;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mockito;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.*;\n+\n+import static org.mockito.Mockito.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15f016a7424683edb3be869b18591b8fe179d919"}, "originalPosition": 42}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cfe2eec4357b7e4c9986c8f97e7d96d4e9fc5afb", "author": {"user": {"login": "huan415", "name": null}}, "url": "https://github.com/seata/seata/commit/cfe2eec4357b7e4c9986c8f97e7d96d4e9fc5afb", "committedDate": "2021-02-19T04:08:46Z", "message": "remove unnecessary dependentment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5967922f87c2f0f99cb0e35504c46f92d2c1e1f8", "author": {"user": {"login": "huan415", "name": null}}, "url": "https://github.com/seata/seata/commit/5967922f87c2f0f99cb0e35504c46f92d2c1e1f8", "committedDate": "2021-02-19T04:09:42Z", "message": "Merge branch 'develop' of https://github.com/huan415/seata into develop"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a246d3f665f44da6f3776e44fad560b46ea20f34", "author": {"user": {"login": "xingfudeshi", "name": "xingfudeshi"}}, "url": "https://github.com/seata/seata/commit/a246d3f665f44da6f3776e44fad560b46ea20f34", "committedDate": "2021-02-20T03:02:08Z", "message": "Merge branch 'develop' into develop"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk0NzAzMTUy", "url": "https://github.com/seata/seata/pull/3374#pullrequestreview-594703152", "createdAt": "2021-02-20T03:02:43Z", "commit": {"oid": "a246d3f665f44da6f3776e44fad560b46ea20f34"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "57d93d4e74cf77c26f3ebfa82558326afa6e94c2", "author": {"user": {"login": "huan415", "name": null}}, "url": "https://github.com/seata/seata/commit/57d93d4e74cf77c26f3ebfa82558326afa6e94c2", "committedDate": "2021-02-20T13:59:04Z", "message": "temp resove confit"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "376f33b2738a1c73f94dd3080a355071af67c4e4", "author": {"user": {"login": "huan415", "name": null}}, "url": "https://github.com/seata/seata/commit/376f33b2738a1c73f94dd3080a355071af67c4e4", "committedDate": "2021-02-20T16:25:44Z", "message": "changes/1.5.0.md"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7d5193287afbb5cb201f8edf574146afc16d8aa8", "author": {"user": {"login": "huan415", "name": null}}, "url": "https://github.com/seata/seata/commit/7d5193287afbb5cb201f8edf574146afc16d8aa8", "committedDate": "2021-02-21T13:36:38Z", "message": "resove pk auto_increment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1d914745ed18f83bf11ed9ec504a75eba4a0a524", "author": {"user": {"login": "huan415", "name": null}}, "url": "https://github.com/seata/seata/commit/1d914745ed18f83bf11ed9ec504a75eba4a0a524", "committedDate": "2021-02-21T14:08:20Z", "message": "add blank space"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "921d0c6509c8a4df2d122a0990416a04a514bc80", "author": {"user": {"login": "huan415", "name": null}}, "url": "https://github.com/seata/seata/commit/921d0c6509c8a4df2d122a0990416a04a514bc80", "committedDate": "2021-02-21T14:13:40Z", "message": "add blank space"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a2d77f63f5fc2c21f4c4ab5ef54e7033300729da", "author": {"user": {"login": "huan415", "name": null}}, "url": "https://github.com/seata/seata/commit/a2d77f63f5fc2c21f4c4ab5ef54e7033300729da", "committedDate": "2021-02-21T14:19:03Z", "message": "remove blank space"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0998d1d75e185bdd83e103c60b8e22cee49afb14", "author": {"user": {"login": "slievrly", "name": "jimin"}}, "url": "https://github.com/seata/seata/commit/0998d1d75e185bdd83e103c60b8e22cee49afb14", "committedDate": "2021-02-21T14:32:45Z", "message": "Merge branch 'develop' into develop"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2dfe24fed681e2879857b7a6d2c3be9109986e6b", "author": {"user": {"login": "huan415", "name": null}}, "url": "https://github.com/seata/seata/commit/2dfe24fed681e2879857b7a6d2c3be9109986e6b", "committedDate": "2021-02-21T14:40:03Z", "message": "resove whitespace"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d290fbcc1f82bc596f6e1da546e8e5ea0c5ad3fa", "author": {"user": {"login": "huan415", "name": null}}, "url": "https://github.com/seata/seata/commit/d290fbcc1f82bc596f6e1da546e8e5ea0c5ad3fa", "committedDate": "2021-02-21T14:41:14Z", "message": "Merge branch 'develop' of https://github.com/huan415/seata into develop"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8dc98136efbc29bcea43cebedf975f4c81ea7e87", "author": {"user": {"login": "huan415", "name": null}}, "url": "https://github.com/seata/seata/commit/8dc98136efbc29bcea43cebedf975f4c81ea7e87", "committedDate": "2021-02-22T12:20:23Z", "message": "unique column value is null"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "df056d1601a376cfbeef43d132e3ff919aad1075", "author": {"user": {"login": "huan415", "name": null}}, "url": "https://github.com/seata/seata/commit/df056d1601a376cfbeef43d132e3ff919aad1075", "committedDate": "2021-02-22T15:40:34Z", "message": "Merge branch 'develop' of https://github.com/huan415/seata into develop"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6d021f554d388a6c7b822efc63f77bf0a7bd31b9", "author": {"user": {"login": "huan415", "name": null}}, "url": "https://github.com/seata/seata/commit/6d021f554d388a6c7b822efc63f77bf0a7bd31b9", "committedDate": "2021-02-22T15:57:27Z", "message": "unique index column deafult"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "29d45cc145efa288f86cac5da34f67651d4d817d", "author": {"user": {"login": "huan415", "name": null}}, "url": "https://github.com/seata/seata/commit/29d45cc145efa288f86cac5da34f67651d4d817d", "committedDate": "2021-02-23T05:05:03Z", "message": "resove sqlType is INSERT_ON_DUPLICATE_UPDATE"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "996e4fd4e29b509df989fe5abcdb7cf0221e99a4", "author": {"user": {"login": "huan415", "name": null}}, "url": "https://github.com/seata/seata/commit/996e4fd4e29b509df989fe5abcdb7cf0221e99a4", "committedDate": "2021-02-23T05:10:29Z", "message": "Merge branch 'develop' into develop"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5f6b4031284719a505c483e8814138e0dd30394a", "author": {"user": {"login": "huan415", "name": null}}, "url": "https://github.com/seata/seata/commit/5f6b4031284719a505c483e8814138e0dd30394a", "committedDate": "2021-02-23T08:34:17Z", "message": "resove unique cloumn have default"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2960c7a7e5ed3cbb519a1f8f9301293c79565ddd", "author": {"user": {"login": "huan415", "name": null}}, "url": "https://github.com/seata/seata/commit/2960c7a7e5ed3cbb519a1f8f9301293c79565ddd", "committedDate": "2021-02-23T08:35:11Z", "message": "Merge branch 'develop' of https://github.com/huan415/seata into develop"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3c519f9bb80969e196d6b14befbe44762744ec89", "author": {"user": {"login": "huan415", "name": null}}, "url": "https://github.com/seata/seata/commit/3c519f9bb80969e196d6b14befbe44762744ec89", "committedDate": "2021-02-23T08:52:45Z", "message": "resove unique column have default"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "33e2d0efe32453eaf544e5bb31f38ceade8534f7", "author": {"user": {"login": "huan415", "name": null}}, "url": "https://github.com/seata/seata/commit/33e2d0efe32453eaf544e5bb31f38ceade8534f7", "committedDate": "2021-02-23T09:13:19Z", "message": "resove unique column have default"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e32f78613ad614deb2e17e48c9f7aabc2fafb0e9", "author": {"user": {"login": "huan415", "name": null}}, "url": "https://github.com/seata/seata/commit/e32f78613ad614deb2e17e48c9f7aabc2fafb0e9", "committedDate": "2021-02-24T10:37:04Z", "message": "resove update column is unique index"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "51aa61dfd127dc1aed33c5aa6c014e3ac8df79ab", "author": {"user": {"login": "huan415", "name": null}}, "url": "https://github.com/seata/seata/commit/51aa61dfd127dc1aed33c5aa6c014e3ac8df79ab", "committedDate": "2021-02-24T10:48:48Z", "message": "resove whitespace"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b470adaae1dbb382169736630f8e0ae642c03083", "author": {"user": {"login": "huan415", "name": null}}, "url": "https://github.com/seata/seata/commit/b470adaae1dbb382169736630f8e0ae642c03083", "committedDate": "2021-02-24T10:54:30Z", "message": "remove Unused import"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "34b399233b0fc80c8662dd8d35399efccb22fdcd", "author": {"user": {"login": "xingfudeshi", "name": "xingfudeshi"}}, "url": "https://github.com/seata/seata/commit/34b399233b0fc80c8662dd8d35399efccb22fdcd", "committedDate": "2021-03-04T09:22:20Z", "message": "Merge branch 'develop' into develop"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "528633754d60809dae30dcfd2b4866e30e6e6a92", "author": {"user": {"login": "huan415", "name": null}}, "url": "https://github.com/seata/seata/commit/528633754d60809dae30dcfd2b4866e30e6e6a92", "committedDate": "2021-03-14T10:43:56Z", "message": "Merge pull request #3 from seata/develop\n\nmerge seata develop"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4c6b844b5413b3d003088bcfa98b603044f5d5ba", "author": {"user": {"login": "huan415", "name": null}}, "url": "https://github.com/seata/seata/commit/4c6b844b5413b3d003088bcfa98b603044f5d5ba", "committedDate": "2021-03-14T12:13:31Z", "message": "resove test case"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ae35ac1fcd77fb2616d3a5e7c4533e2d0ebfb838", "author": {"user": {"login": "xingfudeshi", "name": "xingfudeshi"}}, "url": "https://github.com/seata/seata/commit/ae35ac1fcd77fb2616d3a5e7c4533e2d0ebfb838", "committedDate": "2021-03-15T01:45:08Z", "message": "Merge branch 'develop' into develop"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5891b9adbd4dc25eecb5abc971620b3059eb164e", "author": {"user": {"login": "xingfudeshi", "name": "xingfudeshi"}}, "url": "https://github.com/seata/seata/commit/5891b9adbd4dc25eecb5abc971620b3059eb164e", "committedDate": "2021-03-15T09:29:12Z", "message": "Merge branch 'develop' into develop"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjEzOTg2ODM0", "url": "https://github.com/seata/seata/pull/3374#pullrequestreview-613986834", "createdAt": "2021-03-17T07:28:22Z", "commit": {"oid": "5891b9adbd4dc25eecb5abc971620b3059eb164e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5e88d857ab10108378cdfddfae72463423b24874", "author": {"user": {"login": "xingfudeshi", "name": "xingfudeshi"}}, "url": "https://github.com/seata/seata/commit/5e88d857ab10108378cdfddfae72463423b24874", "committedDate": "2021-03-19T02:16:50Z", "message": "Merge branch 'develop' into develop"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "541571559fdb233bdc322bb23af9818a4923512c", "author": {"user": {"login": "huan415", "name": null}}, "url": "https://github.com/seata/seata/commit/541571559fdb233bdc322bb23af9818a4923512c", "committedDate": "2021-03-28T14:06:22Z", "message": "afterImage=beforeImageId+uniqueIndex"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bff2baffbb8b6f744c5cd130276344ba23565755", "author": {"user": {"login": "huan415", "name": null}}, "url": "https://github.com/seata/seata/commit/bff2baffbb8b6f744c5cd130276344ba23565755", "committedDate": "2021-03-28T14:15:32Z", "message": "Merge branch 'develop' of https://github.com/huan415/seata into develop"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "054846286321470256b6a8f7cc163295c157ccf4", "author": {"user": {"login": "xingfudeshi", "name": "xingfudeshi"}}, "url": "https://github.com/seata/seata/commit/054846286321470256b6a8f7cc163295c157ccf4", "committedDate": "2021-03-29T04:24:29Z", "message": "Merge branch 'develop' into develop"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI4NTg4MzU5", "url": "https://github.com/seata/seata/pull/3374#pullrequestreview-628588359", "createdAt": "2021-04-06T05:38:51Z", "commit": {"oid": "054846286321470256b6a8f7cc163295c157ccf4"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wNlQwNTozODo1MVrOJDYR1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wNlQwNTozODo1MVrOJDYR1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNzUyMzI4NA==", "bodyText": "\u6709\u4e00\u4e9b\u5730\u65b9\u901a\u8fc7\u5224\u65ad sqlRecognizer.getSQLType() == SQLType.INSERT \u505a\u76f8\u5e94\u5904\u7406\uff0c\u8fd9\u6837\u7684\u5730\u65b9\u53ef\u80fd\u4e5f\u9700\u8981\u4e00\u8d77\u6539\u4e0b\uff0c\u6bd4\u5982\uff1aio.seata.rm.datasource.AbstractConnectionProxy#prepareStatement(java.lang.String)", "url": "https://github.com/seata/seata/pull/3374#discussion_r607523284", "createdAt": "2021-04-06T05:38:51Z", "author": {"login": "ymwangzq"}, "path": "sqlparser/seata-sqlparser-druid/src/main/java/io/seata/sqlparser/druid/mysql/MySQLInsertRecognizer.java", "diffHunk": "@@ -61,7 +61,7 @@ public MySQLInsertRecognizer(String originalSQL, SQLStatement ast) {\n \n     @Override\n     public SQLType getSQLType() {\n-        return SQLType.INSERT;\n+        return isDuplicateKeyUpdate() ? SQLType.INSERT_ON_DUPLICATE_UPDATE : SQLType.INSERT;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "054846286321470256b6a8f7cc163295c157ccf4"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI5NTUxODYw", "url": "https://github.com/seata/seata/pull/3374#pullrequestreview-629551860", "createdAt": "2021-04-07T02:45:57Z", "commit": {"oid": "054846286321470256b6a8f7cc163295c157ccf4"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wN1QwMjo0NTo1N1rOJEH2dQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wN1QwMjo0NTo1N1rOJEH2dQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwODMwMjcwOQ==", "bodyText": "\u5982\u679cupdate \u64cd\u4f5c\u91cc\u6709\u4fee\u6539\u4e3b\u952e\uff0c\u53ef\u80fd\u8fd8\u9700\u8981\u62e6\u622a\u6389\u3002", "url": "https://github.com/seata/seata/pull/3374#discussion_r608302709", "createdAt": "2021-04-07T02:45:57Z", "author": {"login": "ymwangzq"}, "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "diffHunk": "@@ -0,0 +1,363 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec.mysql;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+import com.google.common.base.Joiner;\n+import io.seata.common.exception.NotSupportYetException;\n+import io.seata.common.loader.LoadLevel;\n+import io.seata.common.loader.Scope;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.IOUtil;\n+import io.seata.common.util.StringUtils;\n+import io.seata.rm.datasource.ConnectionProxy;\n+import io.seata.rm.datasource.PreparedStatementProxy;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.StatementCallback;\n+import io.seata.rm.datasource.sql.struct.ColumnMeta;\n+import io.seata.rm.datasource.sql.struct.Field;\n+import io.seata.rm.datasource.sql.struct.Row;\n+import io.seata.rm.datasource.sql.struct.TableMeta;\n+import io.seata.rm.datasource.sql.struct.TableRecords;\n+import io.seata.rm.datasource.undo.SQLUndoLog;\n+import io.seata.sqlparser.SQLInsertRecognizer;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.SQLType;\n+import io.seata.sqlparser.struct.Defaultable;\n+import io.seata.sqlparser.struct.Null;\n+import io.seata.sqlparser.util.JdbcConstants;\n+\n+/**\n+ * @author: yangyicong\n+ */\n+@LoadLevel(name = JdbcConstants.MYSQL, scope = Scope.PROTOTYPE)\n+public class MySQLInsertOrUpdateExecutor extends MySQLInsertExecutor implements Defaultable {\n+\n+\n+    private static final String COLUMN_SEPARATOR = \"|\";\n+\n+    /**\n+     * is updated or not\n+     */\n+    private boolean isUpdateFlag = false;\n+\n+    public String getSelectSQL() {\n+        return selectSQL;\n+    }\n+\n+    /**\n+     * before image sql and after image sql,condition is unique index\n+     */\n+    private String selectSQL;\n+\n+    public ArrayList<List<Object>> getParamAppenderList() {\n+        return paramAppenderList;\n+    }\n+\n+    /**\n+     * the params of selectSQL, value is the unique index\n+     */\n+    private ArrayList<List<Object>> paramAppenderList;\n+\n+    /**\n+     * key is unique index name, value is unique index\n+     */\n+    private Map<String, List<String>> beforeUniqueIndexMap = new HashMap<>();\n+\n+    public MySQLInsertOrUpdateExecutor(StatementProxy statementProxy, StatementCallback statementCallback, SQLRecognizer sqlRecognizer) {\n+        super(statementProxy, statementCallback, sqlRecognizer);\n+    }\n+\n+    /**\n+     * Execute auto commit false t.\n+     *\n+     * @param args the args\n+     * @return the t\n+     * @throws Exception the exception\n+     */\n+    @Override\n+    protected Object executeAutoCommitFalse(Object[] args) throws Exception {\n+        if (!JdbcConstants.MYSQL.equalsIgnoreCase(getDbType()) && getTableMeta().getPrimaryKeyOnlyName().size() > 1) {\n+            throw new NotSupportYetException(\"multi pk only support mysql!\");\n+        }\n+        TableRecords beforeImage = beforeImage();\n+        if (CollectionUtils.isNotEmpty(beforeImage.getRows())) {\n+            isUpdateFlag = true;\n+        } else {\n+            beforeImage = TableRecords.empty(getTableMeta());\n+        }\n+        Object result = statementCallback.execute(statementProxy.getTargetStatement(), args);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "054846286321470256b6a8f7cc163295c157ccf4"}, "originalPosition": 109}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7b4408cc05364f9164f24378905ffb5c25768d92", "author": {"user": {"login": "xingfudeshi", "name": "xingfudeshi"}}, "url": "https://github.com/seata/seata/commit/7b4408cc05364f9164f24378905ffb5c25768d92", "committedDate": "2021-04-16T09:13:06Z", "message": "Merge branch 'develop' into develop"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "918c5372a7b0b5b76fb4ac3cb6d3aa3a64af83fd", "author": {"user": {"login": "huan415", "name": null}}, "url": "https://github.com/seata/seata/commit/918c5372a7b0b5b76fb4ac3cb6d3aa3a64af83fd", "committedDate": "2021-04-21T14:27:50Z", "message": "fix bug when update primaryKey"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a1af8dbc9a7bd706b91594728a7dc782faf8f7d3", "author": {"user": {"login": "huan415", "name": null}}, "url": "https://github.com/seata/seata/commit/a1af8dbc9a7bd706b91594728a7dc782faf8f7d3", "committedDate": "2021-04-22T01:49:52Z", "message": "Merge branch 'develop' into develop"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fdaf16bb979de4877c8b1ca8dd5ce58009682751", "author": {"user": {"login": "huan415", "name": null}}, "url": "https://github.com/seata/seata/commit/fdaf16bb979de4877c8b1ca8dd5ce58009682751", "committedDate": "2021-04-22T02:45:25Z", "message": "import class"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fe2281517e305e7a20b33e83c778fa9dcf91e055", "author": {"user": {"login": "huan415", "name": null}}, "url": "https://github.com/seata/seata/commit/fe2281517e305e7a20b33e83c778fa9dcf91e055", "committedDate": "2021-04-24T05:42:28Z", "message": "fix bug of update pk"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "54875f40855ab62eb58ff07e9dfd74094920480f", "author": {"user": {"login": "huan415", "name": null}}, "url": "https://github.com/seata/seata/commit/54875f40855ab62eb58ff07e9dfd74094920480f", "committedDate": "2021-04-27T05:18:19Z", "message": "Merge branch 'develop' into develop"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b9e0a55a0a4feac0f256c11fe828381508f3f10f", "author": {"user": {"login": "huan415", "name": null}}, "url": "https://github.com/seata/seata/commit/b9e0a55a0a4feac0f256c11fe828381508f3f10f", "committedDate": "2021-05-02T14:44:17Z", "message": "Merge branch 'develop' into develop"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjUwMTAwMjU1", "url": "https://github.com/seata/seata/pull/3374#pullrequestreview-650100255", "createdAt": "2021-05-03T06:07:57Z", "commit": {"oid": "b9e0a55a0a4feac0f256c11fe828381508f3f10f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjUwMTA1NDg1", "url": "https://github.com/seata/seata/pull/3374#pullrequestreview-650105485", "createdAt": "2021-05-03T06:21:55Z", "commit": {"oid": "b9e0a55a0a4feac0f256c11fe828381508f3f10f"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0wM1QwNjoyMTo1NVrOJT8kiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0wM1QwNjoyMTo1NVrOJT8kiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNDg5NTExNQ==", "bodyText": "\u4e0d\u5141\u8bb8import *", "url": "https://github.com/seata/seata/pull/3374#discussion_r624895115", "createdAt": "2021-05-03T06:21:55Z", "author": {"login": "a364176773"}, "path": "sqlparser/seata-sqlparser-druid/src/main/java/io/seata/sqlparser/druid/mysql/MySQLInsertRecognizer.java", "diffHunk": "@@ -17,11 +17,7 @@\n \n import com.alibaba.druid.sql.ast.SQLExpr;\n import com.alibaba.druid.sql.ast.SQLStatement;\n-import com.alibaba.druid.sql.ast.expr.SQLIdentifierExpr;\n-import com.alibaba.druid.sql.ast.expr.SQLMethodInvokeExpr;\n-import com.alibaba.druid.sql.ast.expr.SQLNullExpr;\n-import com.alibaba.druid.sql.ast.expr.SQLValuableExpr;\n-import com.alibaba.druid.sql.ast.expr.SQLVariantRefExpr;\n+import com.alibaba.druid.sql.ast.expr.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b9e0a55a0a4feac0f256c11fe828381508f3f10f"}, "originalPosition": 9}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "090c84cc1352ae80a303f4b06aba92610fb70969", "author": {"user": {"login": "huan415", "name": null}}, "url": "https://github.com/seata/seata/commit/090c84cc1352ae80a303f4b06aba92610fb70969", "committedDate": "2021-05-03T08:00:57Z", "message": "resove proplem of ci"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "442b7959f324c808f3b0a04dae67f78bf078168e", "author": {"user": {"login": "a364176773", "name": "FUNKYE"}}, "url": "https://github.com/seata/seata/commit/442b7959f324c808f3b0a04dae67f78bf078168e", "committedDate": "2021-05-03T12:11:37Z", "message": "Merge branch 'develop' into develop"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjUwMzM5MjY0", "url": "https://github.com/seata/seata/pull/3374#pullrequestreview-650339264", "createdAt": "2021-05-03T13:16:13Z", "commit": {"oid": "442b7959f324c808f3b0a04dae67f78bf078168e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3557, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}