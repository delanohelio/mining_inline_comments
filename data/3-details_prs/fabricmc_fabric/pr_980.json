{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYwNzc5Nzk3", "number": 980, "title": "Block break event", "bodyText": "Just a simple block break event, code is from OneEvents.", "createdAt": "2020-08-01T04:44:59Z", "url": "https://github.com/FabricMC/fabric/pull/980", "merged": true, "mergeCommit": {"oid": "e2e6cdad60f5a43c3f4c226eab80eb96c1743f17"}, "closed": true, "closedAt": "2020-08-21T16:22:11Z", "author": {"login": "Geometrically"}, "timelineItems": {"totalCount": 55, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc6hVoXgH2gAyNDYwNzc5Nzk3OmQwZWNlYmI1MjQzNDZjZGYzYjdkZDUwNjhmM2FhNjM5NjhmZGE4MTM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdA0CSkAFqTQ3MTg1MzEyNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "d0ecebb524346cdf3b7dd5068f3aa63968fda813", "author": {"user": {"login": "Geometrically", "name": "Geometrically"}}, "url": "https://github.com/FabricMC/fabric/commit/d0ecebb524346cdf3b7dd5068f3aa63968fda813", "committedDate": "2020-08-01T04:44:11Z", "message": "Block break event"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5NTUyNjAy", "url": "https://github.com/FabricMC/fabric/pull/980#pullrequestreview-459552602", "createdAt": "2020-08-01T04:46:21Z", "commit": {"oid": "d0ecebb524346cdf3b7dd5068f3aa63968fda813"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5NTUyNjM4", "url": "https://github.com/FabricMC/fabric/pull/980#pullrequestreview-459552638", "createdAt": "2020-08-01T04:47:03Z", "commit": {"oid": "d0ecebb524346cdf3b7dd5068f3aa63968fda813"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMVQwNDo0NzowM1rOG6bi7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMVQwNDo0NzowM1rOG6bi7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzkyMTkwMQ==", "bodyText": "Imo we also need a After event so mods can react to the block being broken if it occurs.\nSo this would probably become a Before event\nEDIT: The after event should not be cancellable.", "url": "https://github.com/FabricMC/fabric/pull/980#discussion_r463921901", "createdAt": "2020-08-01T04:47:03Z", "author": {"login": "i509VCB"}, "path": "fabric-events-interaction-v0/src/main/java/net/fabricmc/fabric/api/event/player/BreakBlockCallback.java", "diffHunk": "@@ -0,0 +1,40 @@\n+package net.fabricmc.fabric.api.event.player;\n+\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+import net.minecraft.block.Block;\n+import net.minecraft.block.BlockState;\n+import net.minecraft.block.entity.BlockEntity;\n+import net.minecraft.entity.player.PlayerEntity;\n+import net.minecraft.util.ActionResult;\n+import net.minecraft.util.Hand;\n+import net.minecraft.util.hit.BlockHitResult;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.world.World;\n+import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;\n+\n+/**\n+ * Callback for when a block is broken.\n+ * Only called on the server, however updates are synced with the client.\n+ *\n+ * <p>Upon return:\n+ * <ul><li>SUCCESS/PASS/CONSUME continues the default code for breaking the block\n+ * <li>FAIL cancels the block breaking action\n+ */\n+public interface BreakBlockCallback {\n+\tEvent<BreakBlockCallback> EVENT = EventFactory.createArrayBacked(BreakBlockCallback.class,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0ecebb524346cdf3b7dd5068f3aa63968fda813"}, "originalPosition": 25}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "38554143290eb2761b23d3bc27efa96cce5d54e3", "author": {"user": {"login": "Geometrically", "name": "Geometrically"}}, "url": "https://github.com/FabricMC/fabric/commit/38554143290eb2761b23d3bc27efa96cce5d54e3", "committedDate": "2020-08-01T05:21:39Z", "message": "License headers + after event"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b044d490241a23fdeac8e14d4d4bd8fb1f89bb3a", "author": {"user": {"login": "Geometrically", "name": "Geometrically"}}, "url": "https://github.com/FabricMC/fabric/commit/b044d490241a23fdeac8e14d4d4bd8fb1f89bb3a", "committedDate": "2020-08-01T15:44:58Z", "message": "Before and after events, testmod"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "328f32cccfca4316ba352ebdba4966181f82ad51", "author": {"user": {"login": "Geometrically", "name": "Geometrically"}}, "url": "https://github.com/FabricMC/fabric/commit/328f32cccfca4316ba352ebdba4966181f82ad51", "committedDate": "2020-08-01T16:00:12Z", "message": "Fix checkstyle"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5NTg3NzQ0", "url": "https://github.com/FabricMC/fabric/pull/980#pullrequestreview-459587744", "createdAt": "2020-08-01T16:07:34Z", "commit": {"oid": "328f32cccfca4316ba352ebdba4966181f82ad51"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5NTg4Mjky", "url": "https://github.com/FabricMC/fabric/pull/980#pullrequestreview-459588292", "createdAt": "2020-08-01T16:16:47Z", "commit": {"oid": "328f32cccfca4316ba352ebdba4966181f82ad51"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMVQxNjoxNjo0N1rOG6e5XA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMVQxNjoxNjo0N1rOG6e5XA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk3Njc5Ng==", "bodyText": "toShortString() is client-only.", "url": "https://github.com/FabricMC/fabric/pull/980#discussion_r463976796", "createdAt": "2020-08-01T16:16:47Z", "author": {"login": "Shnupbups"}, "path": "fabric-events-interaction-v0/src/testmod/java/net/fabricmc/fabric/test/event/interaction/InteractionEventsTest.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.test.event.interaction;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import net.minecraft.block.Blocks;\n+import net.minecraft.util.ActionResult;\n+\n+import net.fabricmc.api.ModInitializer;\n+import net.fabricmc.fabric.api.event.player.AfterBreakBlockCallback;\n+import net.fabricmc.fabric.api.event.player.BeforeBreakBlockCallback;\n+\n+public class InteractionEventsTest implements ModInitializer {\n+\tpublic static final Logger LOGGER = LogManager.getLogger(\"InteractionEventsTest\");\n+\n+\t@Override\n+\tpublic void onInitialize() {\n+\t\tBeforeBreakBlockCallback.EVENT.register(((pos, state, entity, block) -> {\n+\t\t\treturn block == Blocks.BEDROCK ? ActionResult.FAIL : ActionResult.PASS;\n+\t\t}));\n+\n+\t\tAfterBreakBlockCallback.EVENT.register(((pos, state, entity, block) -> {\n+\t\t\tLOGGER.info(\"Block broken at \" + pos.toShortString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "328f32cccfca4316ba352ebdba4966181f82ad51"}, "originalPosition": 39}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5NTg4ODc0", "url": "https://github.com/FabricMC/fabric/pull/980#pullrequestreview-459588874", "createdAt": "2020-08-01T16:28:16Z", "commit": {"oid": "328f32cccfca4316ba352ebdba4966181f82ad51"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "640185e26c20e4fca486d6068071667a1edd23f2", "author": {"user": {"login": "Geometrically", "name": "Geometrically"}}, "url": "https://github.com/FabricMC/fabric/commit/640185e26c20e4fca486d6068071667a1edd23f2", "committedDate": "2020-08-01T16:54:31Z", "message": "Version bump, fix client method call"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5NTkwODUw", "url": "https://github.com/FabricMC/fabric/pull/980#pullrequestreview-459590850", "createdAt": "2020-08-01T17:03:20Z", "commit": {"oid": "640185e26c20e4fca486d6068071667a1edd23f2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMVQxNzowMzoyMFrOG6fIaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMVQxNzowMzoyMFrOG6fIaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk4MDY0OA==", "bodyText": "Named post but the event is called before? Something is wrong here.", "url": "https://github.com/FabricMC/fabric/pull/980#discussion_r463980648", "createdAt": "2020-08-01T17:03:20Z", "author": {"login": "LambdAurora"}, "path": "fabric-events-interaction-v0/src/main/java/net/fabricmc/fabric/api/event/player/PostBreakBlockCallback.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.event.player;\n+\n+import net.minecraft.block.Block;\n+import net.minecraft.block.BlockState;\n+import net.minecraft.block.entity.BlockEntity;\n+import net.minecraft.util.ActionResult;\n+import net.minecraft.util.math.BlockPos;\n+\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+\n+/**\n+ * Callback before a block is broken.\n+ * Only called on the server, however updates are synced with the client.\n+ *\n+ * <p>Upon return:\n+ * <ul><li>SUCCESS/PASS/CONSUME continues the default code for breaking the block\n+ * <li>FAIL cancels the block breaking action</ul>\n+ */\n+public interface PostBreakBlockCallback {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "640185e26c20e4fca486d6068071667a1edd23f2"}, "originalPosition": 36}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5NTkwODU0", "url": "https://github.com/FabricMC/fabric/pull/980#pullrequestreview-459590854", "createdAt": "2020-08-01T17:03:25Z", "commit": {"oid": "640185e26c20e4fca486d6068071667a1edd23f2"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMVQxNzowMzoyNVrOG6fIdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMVQxNzowMzoyOVrOG6fIdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk4MDY2MA==", "bodyText": "The injection point of the event is in ServerPlayerInteractionManager, why the event doesn't give the player handle as its triggered when the player does the action?", "url": "https://github.com/FabricMC/fabric/pull/980#discussion_r463980660", "createdAt": "2020-08-01T17:03:25Z", "author": {"login": "LambdAurora"}, "path": "fabric-events-interaction-v0/src/main/java/net/fabricmc/fabric/api/event/player/PostBreakBlockCallback.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.event.player;\n+\n+import net.minecraft.block.Block;\n+import net.minecraft.block.BlockState;\n+import net.minecraft.block.entity.BlockEntity;\n+import net.minecraft.util.ActionResult;\n+import net.minecraft.util.math.BlockPos;\n+\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+\n+/**\n+ * Callback before a block is broken.\n+ * Only called on the server, however updates are synced with the client.\n+ *\n+ * <p>Upon return:\n+ * <ul><li>SUCCESS/PASS/CONSUME continues the default code for breaking the block\n+ * <li>FAIL cancels the block breaking action</ul>\n+ */\n+public interface PostBreakBlockCallback {\n+\tEvent<PostBreakBlockCallback> EVENT = EventFactory.createArrayBacked(PostBreakBlockCallback.class,\n+\t\t\t(listeners) -> (pos, state, entity, block) -> {\n+\t\t\t\tfor (PostBreakBlockCallback event : listeners) {\n+\t\t\t\t\tActionResult result = event.beforeBlockBreak(pos, state, entity, block);\n+\n+\t\t\t\t\tif (result != ActionResult.PASS) {\n+\t\t\t\t\t\treturn result;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\treturn ActionResult.PASS;\n+\t\t\t}\n+\t);\n+\n+\tActionResult beforeBlockBreak(BlockPos pos, BlockState state, BlockEntity entity, Block block);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "640185e26c20e4fca486d6068071667a1edd23f2"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk4MDY2Mg==", "bodyText": "Same issue with player handle.", "url": "https://github.com/FabricMC/fabric/pull/980#discussion_r463980662", "createdAt": "2020-08-01T17:03:29Z", "author": {"login": "LambdAurora"}, "path": "fabric-events-interaction-v0/src/main/java/net/fabricmc/fabric/api/event/player/PreBreakBlockCallback.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.event.player;\n+\n+import net.minecraft.block.Block;\n+import net.minecraft.block.BlockState;\n+import net.minecraft.block.entity.BlockEntity;\n+import net.minecraft.util.math.BlockPos;\n+\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+\n+/**\n+ * Callback after a block is broken.\n+ * Only called on the server, however updates are synced with the client.\n+ */\n+public interface PreBreakBlockCallback {\n+\tEvent<PreBreakBlockCallback> EVENT = EventFactory.createArrayBacked(PreBreakBlockCallback.class,\n+\t\t\t(listeners) -> (pos, state, entity, block) -> {\n+\t\t\t\tfor (PreBreakBlockCallback event : listeners) {\n+\t\t\t\t\tevent.afterBlockBreak(pos, state, entity, block);\n+\t\t\t\t}\n+\t\t\t}\n+\t);\n+\n+\tvoid afterBlockBreak(BlockPos pos, BlockState state, BlockEntity entity, Block block);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "640185e26c20e4fca486d6068071667a1edd23f2"}, "originalPosition": 40}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5NTkxODgx", "url": "https://github.com/FabricMC/fabric/pull/980#pullrequestreview-459591881", "createdAt": "2020-08-01T17:23:27Z", "commit": {"oid": "640185e26c20e4fca486d6068071667a1edd23f2"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMVQxNzoyMzoyN1rOG6fOkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMVQxNzoyNzo1MVrOG6fQHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk4MjIyNg==", "bodyText": "Imo just make a BlockBreakEvents class and move the individual callback interfaces to subclasses there with simple names like Pre Post. Btw @Geometrically you messed up pre and post as lambd said", "url": "https://github.com/FabricMC/fabric/pull/980#discussion_r463982226", "createdAt": "2020-08-01T17:23:27Z", "author": {"login": "liach"}, "path": "fabric-events-interaction-v0/src/main/java/net/fabricmc/fabric/api/event/player/PostBreakBlockCallback.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.event.player;\n+\n+import net.minecraft.block.Block;\n+import net.minecraft.block.BlockState;\n+import net.minecraft.block.entity.BlockEntity;\n+import net.minecraft.util.ActionResult;\n+import net.minecraft.util.math.BlockPos;\n+\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+\n+/**\n+ * Callback before a block is broken.\n+ * Only called on the server, however updates are synced with the client.\n+ *\n+ * <p>Upon return:\n+ * <ul><li>SUCCESS/PASS/CONSUME continues the default code for breaking the block\n+ * <li>FAIL cancels the block breaking action</ul>\n+ */\n+public interface PostBreakBlockCallback {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk4MDY0OA=="}, "originalCommit": {"oid": "640185e26c20e4fca486d6068071667a1edd23f2"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk4MjYyMg==", "bodyText": "Are we really to send 27 packets? Like is 7 packets not sufficient (send packet at pos and do a for loop for direction values and send packet for pos offset at each direction)\nAlso if you do need to send by radius, there is method in block pos that allow you to iterate block pos in a radius (3d) from closest to furthest.", "url": "https://github.com/FabricMC/fabric/pull/980#discussion_r463982622", "createdAt": "2020-08-01T17:27:51Z", "author": {"login": "liach"}, "path": "fabric-events-interaction-v0/src/main/java/net/fabricmc/fabric/mixin/event/interaction/MixinServerPlayerInteractionManager.java", "diffHunk": "@@ -81,4 +87,28 @@ public void interactItem(ServerPlayerEntity player, World world, ItemStack stack\n \t\t\treturn;\n \t\t}\n \t}\n+\n+\t@Inject(at = @At(value = \"INVOKE\", target = \"Lnet/minecraft/block/Block;onBreak(Lnet/minecraft/world/World;Lnet/minecraft/util/math/BlockPos;Lnet/minecraft/block/BlockState;Lnet/minecraft/entity/player/PlayerEntity;)V\"), method = \"tryBreakBlock\", locals = LocalCapture.CAPTURE_FAILHARD, cancellable = true)\n+\tprivate void breakBlock(BlockPos pos, CallbackInfoReturnable<Boolean> cir, BlockState state, BlockEntity entity, Block block) {\n+\t\tActionResult result = PostBreakBlockCallback.EVENT.invoker().beforeBlockBreak(pos, state, entity, block);\n+\n+\t\tif (result == ActionResult.FAIL) {\n+\t\t\tBlockPos cornerPos = pos.add(-1, -1, -1);\n+\n+\t\t\tfor (int x = 0; x < 3; x++) {\n+\t\t\t\tfor (int y = 0; y < 3; y++) {\n+\t\t\t\t\tfor (int z = 0; z < 3; z++) {\n+\t\t\t\t\t\tthis.player.networkHandler.sendPacket(new BlockUpdateS2CPacket(world, cornerPos.add(x, y, z)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "640185e26c20e4fca486d6068071667a1edd23f2"}, "originalPosition": 36}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c37539787f4ca20ae8baadf45a26bad38b957ebf", "author": {"user": {"login": "Geometrically", "name": "Geometrically"}}, "url": "https://github.com/FabricMC/fabric/commit/c37539787f4ca20ae8baadf45a26bad38b957ebf", "committedDate": "2020-08-02T01:27:03Z", "message": "Move to one event class"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5NjEzNTM3", "url": "https://github.com/FabricMC/fabric/pull/980#pullrequestreview-459613537", "createdAt": "2020-08-02T01:32:59Z", "commit": {"oid": "c37539787f4ca20ae8baadf45a26bad38b957ebf"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQwMTozMjo1OVrOG6hbyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQwMTo0MjoyOFrOG6heIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDAxODM3OQ==", "bodyText": "You know you can set IJ to not static import and order imports properly.", "url": "https://github.com/FabricMC/fabric/pull/980#discussion_r464018379", "createdAt": "2020-08-02T01:32:59Z", "author": {"login": "i509VCB"}, "path": "fabric-events-interaction-v0/src/main/java/net/fabricmc/fabric/mixin/event/interaction/MixinClientPlayerInteractionManager.java", "diffHunk": "@@ -16,6 +16,11 @@\n \n package net.fabricmc.fabric.mixin.event.interaction;\n \n+import net.fabricmc.fabric.api.event.player.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c37539787f4ca20ae8baadf45a26bad38b957ebf"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDAxODYxNA==", "bodyText": "I think we should pass the world in the parameters.\nThe BlockEntity can be obtained using getBlockEntity in world. Also I don't think the block param at the end is really necessary since you can get that from the block state.\nAlso please document the fields, I have no idea whether the block state is the state being broken or the resulting state.", "url": "https://github.com/FabricMC/fabric/pull/980#discussion_r464018614", "createdAt": "2020-08-02T01:36:33Z", "author": {"login": "i509VCB"}, "path": "fabric-events-interaction-v0/src/main/java/net/fabricmc/fabric/api/event/player/BlockBreakEvents.java", "diffHunk": "@@ -0,0 +1,56 @@\n+package net.fabricmc.fabric.api.event.player;\n+\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+import net.minecraft.block.Block;\n+import net.minecraft.block.BlockState;\n+import net.minecraft.block.entity.BlockEntity;\n+import net.minecraft.entity.player.PlayerEntity;\n+import net.minecraft.util.ActionResult;\n+import net.minecraft.util.math.BlockPos;\n+\n+public class BlockBreakEvents {\n+\t/**\n+\t * Callback before a block is broken.\n+\t * Only called on the server, however updates are synced with the client.\n+\t *\n+\t * <p>Upon return:\n+\t * <ul><li>SUCCESS/PASS/CONSUME continues the default code for breaking the block\n+\t * <li>FAIL cancels the block breaking action</ul>\n+\t */\n+\tpublic static final Event<BeforeBreakBlockCallback> BEFORE = EventFactory.createArrayBacked(BeforeBreakBlockCallback.class,\n+\t\t\t(listeners) -> (player, pos, state, entity, block) -> {\n+\t\t\t\tfor (BeforeBreakBlockCallback event : listeners) {\n+\t\t\t\t\tActionResult result = event.beforeBlockBreak(player, pos, state, entity, block);\n+\n+\t\t\t\t\tif (result != ActionResult.FAIL) {\n+\t\t\t\t\t\treturn result;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\treturn ActionResult.FAIL;\n+\t\t\t}\n+\t);\n+\n+\t/**\n+\t * Callback after a block is broken.\n+\t * Called on both Client and Server\n+\t */\n+\tpublic static final Event<AfterBreakBlockCallback> AFTER = EventFactory.createArrayBacked(AfterBreakBlockCallback.class,\n+\t\t\t(listeners) -> (player, pos, state, entity, block) -> {\n+\t\t\t\tfor (AfterBreakBlockCallback event : listeners) {\n+\t\t\t\t\tevent.afterBlockBreak(player, pos, state, entity, block);\n+\t\t\t\t}\n+\t\t\t}\n+\t);\n+\n+\t@FunctionalInterface\n+\tpublic interface BeforeBreakBlockCallback {\n+\t\tActionResult beforeBlockBreak(PlayerEntity player, BlockPos pos, BlockState state, /* Nullable */ BlockEntity entity, Block block);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c37539787f4ca20ae8baadf45a26bad38b957ebf"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDAxODcwNQ==", "bodyText": "Would a mutable block pos be possible to use here if it's beneficial for performance.", "url": "https://github.com/FabricMC/fabric/pull/980#discussion_r464018705", "createdAt": "2020-08-02T01:38:13Z", "author": {"login": "i509VCB"}, "path": "fabric-events-interaction-v0/src/main/java/net/fabricmc/fabric/mixin/event/interaction/MixinServerPlayerInteractionManager.java", "diffHunk": "@@ -81,4 +82,28 @@ public void interactItem(ServerPlayerEntity player, World world, ItemStack stack\n \t\t\treturn;\n \t\t}\n \t}\n+\n+\t@Inject(at = @At(value = \"INVOKE\", target = \"Lnet/minecraft/block/Block;onBreak(Lnet/minecraft/world/World;Lnet/minecraft/util/math/BlockPos;Lnet/minecraft/block/BlockState;Lnet/minecraft/entity/player/PlayerEntity;)V\"), method = \"tryBreakBlock\", locals = LocalCapture.CAPTURE_FAILHARD, cancellable = true)\n+\tprivate void breakBlock(BlockPos pos, CallbackInfoReturnable<Boolean> cir, BlockState state, BlockEntity entity, Block block) {\n+\t\tActionResult result = BlockBreakEvents.BEFORE.invoker().beforeBlockBreak(this.player, pos, state, entity, block);\n+\n+\t\tif (result == ActionResult.FAIL) {\n+\t\t\tBlockPos cornerPos = pos.add(-1, -1, -1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c37539787f4ca20ae8baadf45a26bad38b957ebf"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDAxODgxNA==", "bodyText": "I'd test the item in the player's main hand if it's bedrock imo.", "url": "https://github.com/FabricMC/fabric/pull/980#discussion_r464018814", "createdAt": "2020-08-02T01:39:57Z", "author": {"login": "i509VCB"}, "path": "fabric-events-interaction-v0/src/testmod/java/net/fabricmc/fabric/test/event/interaction/InteractionEventsTest.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.test.event.interaction;\n+\n+import net.fabricmc.fabric.api.event.player.BlockBreakEvents;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import net.minecraft.block.Blocks;\n+import net.minecraft.util.ActionResult;\n+\n+import net.fabricmc.api.ModInitializer;\n+\n+public class InteractionEventsTest implements ModInitializer {\n+\tpublic static final Logger LOGGER = LogManager.getLogger(\"InteractionEventsTest\");\n+\n+\t@Override\n+\tpublic void onInitialize() {\n+\t\tBlockBreakEvents.BEFORE.register(((player, pos, state, entity, block) -> {\n+\t\t\treturn block == Blocks.BEDROCK ? ActionResult.FAIL : ActionResult.PASS;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c37539787f4ca20ae8baadf45a26bad38b957ebf"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDAxODk3Nw==", "bodyText": "Bump minor, so 0.4.0", "url": "https://github.com/FabricMC/fabric/pull/980#discussion_r464018977", "createdAt": "2020-08-02T01:42:28Z", "author": {"login": "i509VCB"}, "path": "fabric-events-interaction-v0/build.gradle", "diffHunk": "@@ -1,5 +1,5 @@\n archivesBaseName = \"fabric-events-interaction-v0\"\n-version = getSubprojectVersion(project, \"0.3.3\")\n+version = getSubprojectVersion(project, \"0.3.4\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c37539787f4ca20ae8baadf45a26bad38b957ebf"}, "originalPosition": 3}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "35509367dbbe84f6aa04cafecb8b899ad241c680", "author": {"user": {"login": "Geometrically", "name": "Geometrically"}}, "url": "https://github.com/FabricMC/fabric/commit/35509367dbbe84f6aa04cafecb8b899ad241c680", "committedDate": "2020-08-02T03:30:15Z", "message": "Expand event parameters + javadoc"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5NjIzMzkw", "url": "https://github.com/FabricMC/fabric/pull/980#pullrequestreview-459623390", "createdAt": "2020-08-02T06:18:12Z", "commit": {"oid": "35509367dbbe84f6aa04cafecb8b899ad241c680"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQwNjoxODoxMlrOG6imoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQwNjoyMjo0OVrOG6ioOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDAzNzUzNg==", "bodyText": "FAIL as default? what?", "url": "https://github.com/FabricMC/fabric/pull/980#discussion_r464037536", "createdAt": "2020-08-02T06:18:12Z", "author": {"login": "shedaniel"}, "path": "fabric-events-interaction-v0/src/main/java/net/fabricmc/fabric/api/event/player/BlockBreakEvents.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.event.player;\n+\n+import net.minecraft.block.Block;\n+import net.minecraft.block.BlockState;\n+import net.minecraft.block.entity.BlockEntity;\n+import net.minecraft.entity.player.PlayerEntity;\n+import net.minecraft.util.ActionResult;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.world.World;\n+\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+\n+public class BlockBreakEvents {\n+\t/**\n+\t * Callback before a block is broken.\n+\t * Only called on the server, however updates are synced with the client.\n+\t *\n+\t * <p>Upon return:\n+\t * <ul><li>SUCCESS/PASS/CONSUME continues the default code for breaking the block\n+\t * <li>FAIL cancels the block breaking action</ul>\n+\t *\n+\t * <p>Fields:\n+\t * <ul><li> world - The world at which the block is being broken\n+\t * <li> player - The player who is breaking the block\n+\t * <li> pos - The position at which the block is being broken\n+\t * <li> state - The block state from BEFORE the block is broken\n+\t * <li> entity - The block entity from BEFORE the block is broken (can be null)\n+\t * <li> block - The block instance of the block that is being broken</ul>\n+\t */\n+\tpublic static final Event<BeforeBreakBlockCallback> BEFORE = EventFactory.createArrayBacked(BeforeBreakBlockCallback.class,\n+\t\t\t(listeners) -> (world, player, pos, state, entity, block) -> {\n+\t\t\t\tfor (BeforeBreakBlockCallback event : listeners) {\n+\t\t\t\t\tActionResult result = event.beforeBlockBreak(world, player, pos, state, entity, block);\n+\n+\t\t\t\t\tif (result != ActionResult.FAIL) {\n+\t\t\t\t\t\treturn result;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\treturn ActionResult.FAIL;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35509367dbbe84f6aa04cafecb8b899ad241c680"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDAzNzU4NQ==", "bodyText": "shouldn't this check with PASS? PASS should pass the callback to the next one.", "url": "https://github.com/FabricMC/fabric/pull/980#discussion_r464037585", "createdAt": "2020-08-02T06:18:55Z", "author": {"login": "shedaniel"}, "path": "fabric-events-interaction-v0/src/main/java/net/fabricmc/fabric/api/event/player/BlockBreakEvents.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.event.player;\n+\n+import net.minecraft.block.Block;\n+import net.minecraft.block.BlockState;\n+import net.minecraft.block.entity.BlockEntity;\n+import net.minecraft.entity.player.PlayerEntity;\n+import net.minecraft.util.ActionResult;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.world.World;\n+\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+\n+public class BlockBreakEvents {\n+\t/**\n+\t * Callback before a block is broken.\n+\t * Only called on the server, however updates are synced with the client.\n+\t *\n+\t * <p>Upon return:\n+\t * <ul><li>SUCCESS/PASS/CONSUME continues the default code for breaking the block\n+\t * <li>FAIL cancels the block breaking action</ul>\n+\t *\n+\t * <p>Fields:\n+\t * <ul><li> world - The world at which the block is being broken\n+\t * <li> player - The player who is breaking the block\n+\t * <li> pos - The position at which the block is being broken\n+\t * <li> state - The block state from BEFORE the block is broken\n+\t * <li> entity - The block entity from BEFORE the block is broken (can be null)\n+\t * <li> block - The block instance of the block that is being broken</ul>\n+\t */\n+\tpublic static final Event<BeforeBreakBlockCallback> BEFORE = EventFactory.createArrayBacked(BeforeBreakBlockCallback.class,\n+\t\t\t(listeners) -> (world, player, pos, state, entity, block) -> {\n+\t\t\t\tfor (BeforeBreakBlockCallback event : listeners) {\n+\t\t\t\t\tActionResult result = event.beforeBlockBreak(world, player, pos, state, entity, block);\n+\n+\t\t\t\t\tif (result != ActionResult.FAIL) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35509367dbbe84f6aa04cafecb8b899ad241c680"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDAzNzc2Mw==", "bodyText": "didn't you change it to pre/post", "url": "https://github.com/FabricMC/fabric/pull/980#discussion_r464037763", "createdAt": "2020-08-02T06:20:33Z", "author": {"login": "shedaniel"}, "path": "fabric-events-interaction-v0/src/main/java/net/fabricmc/fabric/api/event/player/BlockBreakEvents.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.event.player;\n+\n+import net.minecraft.block.Block;\n+import net.minecraft.block.BlockState;\n+import net.minecraft.block.entity.BlockEntity;\n+import net.minecraft.entity.player.PlayerEntity;\n+import net.minecraft.util.ActionResult;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.world.World;\n+\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+\n+public class BlockBreakEvents {\n+\t/**\n+\t * Callback before a block is broken.\n+\t * Only called on the server, however updates are synced with the client.\n+\t *\n+\t * <p>Upon return:\n+\t * <ul><li>SUCCESS/PASS/CONSUME continues the default code for breaking the block\n+\t * <li>FAIL cancels the block breaking action</ul>\n+\t *\n+\t * <p>Fields:\n+\t * <ul><li> world - The world at which the block is being broken\n+\t * <li> player - The player who is breaking the block\n+\t * <li> pos - The position at which the block is being broken\n+\t * <li> state - The block state from BEFORE the block is broken\n+\t * <li> entity - The block entity from BEFORE the block is broken (can be null)\n+\t * <li> block - The block instance of the block that is being broken</ul>\n+\t */\n+\tpublic static final Event<BeforeBreakBlockCallback> BEFORE = EventFactory.createArrayBacked(BeforeBreakBlockCallback.class,\n+\t\t\t(listeners) -> (world, player, pos, state, entity, block) -> {\n+\t\t\t\tfor (BeforeBreakBlockCallback event : listeners) {\n+\t\t\t\t\tActionResult result = event.beforeBlockBreak(world, player, pos, state, entity, block);\n+\n+\t\t\t\t\tif (result != ActionResult.FAIL) {\n+\t\t\t\t\t\treturn result;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\treturn ActionResult.FAIL;\n+\t\t\t}\n+\t);\n+\n+\t/**\n+\t * Callback after a block is broken.\n+\t * Called on both Client and Server\n+\t *\n+\t * <p>Fields:\n+\t * <ul><li> world - The world where the block was broken\n+\t * <li> player - The player who broke the block\n+\t * <li> pos - The position where the block was broken\n+\t * <li> state - The block state from AFTER the block was broken\n+\t * <li> entity - The block entity of the broken block (can be null)\n+\t * <li> block - The block instance of the block that was broken</ul>\n+\t */\n+\tpublic static final Event<AfterBreakBlockCallback> AFTER = EventFactory.createArrayBacked(AfterBreakBlockCallback.class,\n+\t\t\t(listeners) -> (world, player, pos, state, entity, block) -> {\n+\t\t\t\tfor (AfterBreakBlockCallback event : listeners) {\n+\t\t\t\t\tevent.afterBlockBreak(world, player, pos, state, entity, block);\n+\t\t\t\t}\n+\t\t\t}\n+\t);\n+\n+\t@FunctionalInterface\n+\tpublic interface BeforeBreakBlockCallback {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35509367dbbe84f6aa04cafecb8b899ad241c680"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDAzNzk0Mg==", "bodyText": "will it be weird if you run post block break in the client but not pre block break? I would just not call it in the client or make a new callback especially for the client since you are calling World#getBlockEntity", "url": "https://github.com/FabricMC/fabric/pull/980#discussion_r464037942", "createdAt": "2020-08-02T06:22:45Z", "author": {"login": "shedaniel"}, "path": "fabric-events-interaction-v0/src/main/java/net/fabricmc/fabric/mixin/event/interaction/MixinClientPlayerInteractionManager.java", "diffHunk": "@@ -141,4 +146,9 @@ public void interactEntityAtLocation(PlayerEntity player, Entity entity, EntityH\n \t\t\treturn;\n \t\t}\n \t}\n+\n+\t@Inject(at = @At(value = \"INVOKE\", target = \"Lnet/minecraft/block/Block;onBroken(Lnet/minecraft/world/WorldAccess;Lnet/minecraft/util/math/BlockPos;Lnet/minecraft/block/BlockState;)V\"), method = \"breakBlock\", locals = LocalCapture.CAPTURE_FAILHARD)\n+\tprivate void onBlockBroken(BlockPos pos, CallbackInfoReturnable<Boolean> cir, World world, BlockState state, Block block, FluidState fluidState, boolean bl) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35509367dbbe84f6aa04cafecb8b899ad241c680"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDAzNzk0NA==", "bodyText": "we don't need the extra block probably", "url": "https://github.com/FabricMC/fabric/pull/980#discussion_r464037944", "createdAt": "2020-08-02T06:22:49Z", "author": {"login": "shedaniel"}, "path": "fabric-events-interaction-v0/src/main/java/net/fabricmc/fabric/api/event/player/BlockBreakEvents.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.event.player;\n+\n+import net.minecraft.block.Block;\n+import net.minecraft.block.BlockState;\n+import net.minecraft.block.entity.BlockEntity;\n+import net.minecraft.entity.player.PlayerEntity;\n+import net.minecraft.util.ActionResult;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.world.World;\n+\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+\n+public class BlockBreakEvents {\n+\t/**\n+\t * Callback before a block is broken.\n+\t * Only called on the server, however updates are synced with the client.\n+\t *\n+\t * <p>Upon return:\n+\t * <ul><li>SUCCESS/PASS/CONSUME continues the default code for breaking the block\n+\t * <li>FAIL cancels the block breaking action</ul>\n+\t *\n+\t * <p>Fields:\n+\t * <ul><li> world - The world at which the block is being broken\n+\t * <li> player - The player who is breaking the block\n+\t * <li> pos - The position at which the block is being broken\n+\t * <li> state - The block state from BEFORE the block is broken\n+\t * <li> entity - The block entity from BEFORE the block is broken (can be null)\n+\t * <li> block - The block instance of the block that is being broken</ul>\n+\t */\n+\tpublic static final Event<BeforeBreakBlockCallback> BEFORE = EventFactory.createArrayBacked(BeforeBreakBlockCallback.class,\n+\t\t\t(listeners) -> (world, player, pos, state, entity, block) -> {\n+\t\t\t\tfor (BeforeBreakBlockCallback event : listeners) {\n+\t\t\t\t\tActionResult result = event.beforeBlockBreak(world, player, pos, state, entity, block);\n+\n+\t\t\t\t\tif (result != ActionResult.FAIL) {\n+\t\t\t\t\t\treturn result;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\treturn ActionResult.FAIL;\n+\t\t\t}\n+\t);\n+\n+\t/**\n+\t * Callback after a block is broken.\n+\t * Called on both Client and Server\n+\t *\n+\t * <p>Fields:\n+\t * <ul><li> world - The world where the block was broken\n+\t * <li> player - The player who broke the block\n+\t * <li> pos - The position where the block was broken\n+\t * <li> state - The block state from AFTER the block was broken\n+\t * <li> entity - The block entity of the broken block (can be null)\n+\t * <li> block - The block instance of the block that was broken</ul>\n+\t */\n+\tpublic static final Event<AfterBreakBlockCallback> AFTER = EventFactory.createArrayBacked(AfterBreakBlockCallback.class,\n+\t\t\t(listeners) -> (world, player, pos, state, entity, block) -> {\n+\t\t\t\tfor (AfterBreakBlockCallback event : listeners) {\n+\t\t\t\t\tevent.afterBlockBreak(world, player, pos, state, entity, block);\n+\t\t\t\t}\n+\t\t\t}\n+\t);\n+\n+\t@FunctionalInterface\n+\tpublic interface BeforeBreakBlockCallback {\n+\t\tActionResult beforeBlockBreak(World world, PlayerEntity player, BlockPos pos, BlockState state, /* Nullable */ BlockEntity entity, Block block);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35509367dbbe84f6aa04cafecb8b899ad241c680"}, "originalPosition": 83}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5NjY0OTE4", "url": "https://github.com/FabricMC/fabric/pull/980#pullrequestreview-459664918", "createdAt": "2020-08-02T17:21:07Z", "commit": {"oid": "35509367dbbe84f6aa04cafecb8b899ad241c680"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxNzoyMTowN1rOG6mh3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxNzoyOTowMlrOG6mkqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDEwMTg1NQ==", "bodyText": "Yeet Callback from the interface names since the parent class has Events in the name", "url": "https://github.com/FabricMC/fabric/pull/980#discussion_r464101855", "createdAt": "2020-08-02T17:21:07Z", "author": {"login": "i509VCB"}, "path": "fabric-events-interaction-v0/src/main/java/net/fabricmc/fabric/api/event/player/BlockBreakEvents.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.event.player;\n+\n+import net.minecraft.block.Block;\n+import net.minecraft.block.BlockState;\n+import net.minecraft.block.entity.BlockEntity;\n+import net.minecraft.entity.player.PlayerEntity;\n+import net.minecraft.util.ActionResult;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.world.World;\n+\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+\n+public class BlockBreakEvents {\n+\t/**\n+\t * Callback before a block is broken.\n+\t * Only called on the server, however updates are synced with the client.\n+\t *\n+\t * <p>Upon return:\n+\t * <ul><li>SUCCESS/PASS/CONSUME continues the default code for breaking the block\n+\t * <li>FAIL cancels the block breaking action</ul>\n+\t *\n+\t * <p>Fields:\n+\t * <ul><li> world - The world at which the block is being broken\n+\t * <li> player - The player who is breaking the block\n+\t * <li> pos - The position at which the block is being broken\n+\t * <li> state - The block state from BEFORE the block is broken\n+\t * <li> entity - The block entity from BEFORE the block is broken (can be null)\n+\t * <li> block - The block instance of the block that is being broken</ul>\n+\t */\n+\tpublic static final Event<BeforeBreakBlockCallback> BEFORE = EventFactory.createArrayBacked(BeforeBreakBlockCallback.class,\n+\t\t\t(listeners) -> (world, player, pos, state, entity, block) -> {\n+\t\t\t\tfor (BeforeBreakBlockCallback event : listeners) {\n+\t\t\t\t\tActionResult result = event.beforeBlockBreak(world, player, pos, state, entity, block);\n+\n+\t\t\t\t\tif (result != ActionResult.FAIL) {\n+\t\t\t\t\t\treturn result;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\treturn ActionResult.FAIL;\n+\t\t\t}\n+\t);\n+\n+\t/**\n+\t * Callback after a block is broken.\n+\t * Called on both Client and Server\n+\t *\n+\t * <p>Fields:\n+\t * <ul><li> world - The world where the block was broken\n+\t * <li> player - The player who broke the block\n+\t * <li> pos - The position where the block was broken\n+\t * <li> state - The block state from AFTER the block was broken\n+\t * <li> entity - The block entity of the broken block (can be null)\n+\t * <li> block - The block instance of the block that was broken</ul>\n+\t */\n+\tpublic static final Event<AfterBreakBlockCallback> AFTER = EventFactory.createArrayBacked(AfterBreakBlockCallback.class,\n+\t\t\t(listeners) -> (world, player, pos, state, entity, block) -> {\n+\t\t\t\tfor (AfterBreakBlockCallback event : listeners) {\n+\t\t\t\t\tevent.afterBlockBreak(world, player, pos, state, entity, block);\n+\t\t\t\t}\n+\t\t\t}\n+\t);\n+\n+\t@FunctionalInterface\n+\tpublic interface BeforeBreakBlockCallback {\n+\t\tActionResult beforeBlockBreak(World world, PlayerEntity player, BlockPos pos, BlockState state, /* Nullable */ BlockEntity entity, Block block);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface AfterBreakBlockCallback {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35509367dbbe84f6aa04cafecb8b899ad241c680"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDEwMjE1Ng==", "bodyText": "Yeet the Block off the end. It's negligable the time you'll save by getting the block instance from the block state, but I'd say it's worth making the method signature slightly cleaner.", "url": "https://github.com/FabricMC/fabric/pull/980#discussion_r464102156", "createdAt": "2020-08-02T17:24:35Z", "author": {"login": "i509VCB"}, "path": "fabric-events-interaction-v0/src/main/java/net/fabricmc/fabric/api/event/player/BlockBreakEvents.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.event.player;\n+\n+import net.minecraft.block.Block;\n+import net.minecraft.block.BlockState;\n+import net.minecraft.block.entity.BlockEntity;\n+import net.minecraft.entity.player.PlayerEntity;\n+import net.minecraft.util.ActionResult;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.world.World;\n+\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+\n+public class BlockBreakEvents {\n+\t/**\n+\t * Callback before a block is broken.\n+\t * Only called on the server, however updates are synced with the client.\n+\t *\n+\t * <p>Upon return:\n+\t * <ul><li>SUCCESS/PASS/CONSUME continues the default code for breaking the block\n+\t * <li>FAIL cancels the block breaking action</ul>\n+\t *\n+\t * <p>Fields:\n+\t * <ul><li> world - The world at which the block is being broken\n+\t * <li> player - The player who is breaking the block\n+\t * <li> pos - The position at which the block is being broken\n+\t * <li> state - The block state from BEFORE the block is broken\n+\t * <li> entity - The block entity from BEFORE the block is broken (can be null)\n+\t * <li> block - The block instance of the block that is being broken</ul>\n+\t */\n+\tpublic static final Event<BeforeBreakBlockCallback> BEFORE = EventFactory.createArrayBacked(BeforeBreakBlockCallback.class,\n+\t\t\t(listeners) -> (world, player, pos, state, entity, block) -> {\n+\t\t\t\tfor (BeforeBreakBlockCallback event : listeners) {\n+\t\t\t\t\tActionResult result = event.beforeBlockBreak(world, player, pos, state, entity, block);\n+\n+\t\t\t\t\tif (result != ActionResult.FAIL) {\n+\t\t\t\t\t\treturn result;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\treturn ActionResult.FAIL;\n+\t\t\t}\n+\t);\n+\n+\t/**\n+\t * Callback after a block is broken.\n+\t * Called on both Client and Server\n+\t *\n+\t * <p>Fields:\n+\t * <ul><li> world - The world where the block was broken\n+\t * <li> player - The player who broke the block\n+\t * <li> pos - The position where the block was broken\n+\t * <li> state - The block state from AFTER the block was broken\n+\t * <li> entity - The block entity of the broken block (can be null)\n+\t * <li> block - The block instance of the block that was broken</ul>\n+\t */\n+\tpublic static final Event<AfterBreakBlockCallback> AFTER = EventFactory.createArrayBacked(AfterBreakBlockCallback.class,\n+\t\t\t(listeners) -> (world, player, pos, state, entity, block) -> {\n+\t\t\t\tfor (AfterBreakBlockCallback event : listeners) {\n+\t\t\t\t\tevent.afterBlockBreak(world, player, pos, state, entity, block);\n+\t\t\t\t}\n+\t\t\t}\n+\t);\n+\n+\t@FunctionalInterface\n+\tpublic interface BeforeBreakBlockCallback {\n+\t\tActionResult beforeBlockBreak(World world, PlayerEntity player, BlockPos pos, BlockState state, /* Nullable */ BlockEntity entity, Block block);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface AfterBreakBlockCallback {\n+\t\tvoid afterBlockBreak(World world, PlayerEntity player, BlockPos pos, BlockState state, /* Nullable */ BlockEntity entity, Block block);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35509367dbbe84f6aa04cafecb8b899ad241c680"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDEwMjIzOA==", "bodyText": "final with private constructor please", "url": "https://github.com/FabricMC/fabric/pull/980#discussion_r464102238", "createdAt": "2020-08-02T17:25:16Z", "author": {"login": "i509VCB"}, "path": "fabric-events-interaction-v0/src/main/java/net/fabricmc/fabric/api/event/player/BlockBreakEvents.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.event.player;\n+\n+import net.minecraft.block.Block;\n+import net.minecraft.block.BlockState;\n+import net.minecraft.block.entity.BlockEntity;\n+import net.minecraft.entity.player.PlayerEntity;\n+import net.minecraft.util.ActionResult;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.world.World;\n+\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+\n+public class BlockBreakEvents {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35509367dbbe84f6aa04cafecb8b899ad241c680"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDEwMjU3MA==", "bodyText": "I think the reason for these packets is to tell the client what the neighboring blocks actually are (since the client also calculates this).", "url": "https://github.com/FabricMC/fabric/pull/980#discussion_r464102570", "createdAt": "2020-08-02T17:29:02Z", "author": {"login": "i509VCB"}, "path": "fabric-events-interaction-v0/src/main/java/net/fabricmc/fabric/mixin/event/interaction/MixinServerPlayerInteractionManager.java", "diffHunk": "@@ -81,4 +82,28 @@ public void interactItem(ServerPlayerEntity player, World world, ItemStack stack\n \t\t\treturn;\n \t\t}\n \t}\n+\n+\t@Inject(at = @At(value = \"INVOKE\", target = \"Lnet/minecraft/block/Block;onBreak(Lnet/minecraft/world/World;Lnet/minecraft/util/math/BlockPos;Lnet/minecraft/block/BlockState;Lnet/minecraft/entity/player/PlayerEntity;)V\"), method = \"tryBreakBlock\", locals = LocalCapture.CAPTURE_FAILHARD, cancellable = true)\n+\tprivate void breakBlock(BlockPos pos, CallbackInfoReturnable<Boolean> cir, BlockState state, BlockEntity entity, Block block) {\n+\t\tActionResult result = BlockBreakEvents.BEFORE.invoker().beforeBlockBreak(this.player, pos, state, entity, block);\n+\n+\t\tif (result == ActionResult.FAIL) {\n+\t\t\tBlockPos cornerPos = pos.add(-1, -1, -1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDAxODcwNQ=="}, "originalCommit": {"oid": "c37539787f4ca20ae8baadf45a26bad38b957ebf"}, "originalPosition": 40}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5Njc2NzA3", "url": "https://github.com/FabricMC/fabric/pull/980#pullrequestreview-459676707", "createdAt": "2020-08-02T20:33:29Z", "commit": {"oid": "35509367dbbe84f6aa04cafecb8b899ad241c680"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQyMDozMzozMFrOG6nq2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQyMDozNzo1OFrOG6nsxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDEyMDUzOQ==", "bodyText": "Document on the method in the functional interface, not here. This is an absolute mess", "url": "https://github.com/FabricMC/fabric/pull/980#discussion_r464120539", "createdAt": "2020-08-02T20:33:30Z", "author": {"login": "liach"}, "path": "fabric-events-interaction-v0/src/main/java/net/fabricmc/fabric/api/event/player/BlockBreakEvents.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.event.player;\n+\n+import net.minecraft.block.Block;\n+import net.minecraft.block.BlockState;\n+import net.minecraft.block.entity.BlockEntity;\n+import net.minecraft.entity.player.PlayerEntity;\n+import net.minecraft.util.ActionResult;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.world.World;\n+\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+\n+public class BlockBreakEvents {\n+\t/**\n+\t * Callback before a block is broken.\n+\t * Only called on the server, however updates are synced with the client.\n+\t *\n+\t * <p>Upon return:\n+\t * <ul><li>SUCCESS/PASS/CONSUME continues the default code for breaking the block\n+\t * <li>FAIL cancels the block breaking action</ul>\n+\t *\n+\t * <p>Fields:\n+\t * <ul><li> world - The world at which the block is being broken\n+\t * <li> player - The player who is breaking the block\n+\t * <li> pos - The position at which the block is being broken\n+\t * <li> state - The block state from BEFORE the block is broken\n+\t * <li> entity - The block entity from BEFORE the block is broken (can be null)\n+\t * <li> block - The block instance of the block that is being broken</ul>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35509367dbbe84f6aa04cafecb8b899ad241c680"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDEyMDY1OA==", "bodyText": "Same, document on method in functional interface.", "url": "https://github.com/FabricMC/fabric/pull/980#discussion_r464120658", "createdAt": "2020-08-02T20:34:05Z", "author": {"login": "liach"}, "path": "fabric-events-interaction-v0/src/main/java/net/fabricmc/fabric/api/event/player/BlockBreakEvents.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.event.player;\n+\n+import net.minecraft.block.Block;\n+import net.minecraft.block.BlockState;\n+import net.minecraft.block.entity.BlockEntity;\n+import net.minecraft.entity.player.PlayerEntity;\n+import net.minecraft.util.ActionResult;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.world.World;\n+\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+\n+public class BlockBreakEvents {\n+\t/**\n+\t * Callback before a block is broken.\n+\t * Only called on the server, however updates are synced with the client.\n+\t *\n+\t * <p>Upon return:\n+\t * <ul><li>SUCCESS/PASS/CONSUME continues the default code for breaking the block\n+\t * <li>FAIL cancels the block breaking action</ul>\n+\t *\n+\t * <p>Fields:\n+\t * <ul><li> world - The world at which the block is being broken\n+\t * <li> player - The player who is breaking the block\n+\t * <li> pos - The position at which the block is being broken\n+\t * <li> state - The block state from BEFORE the block is broken\n+\t * <li> entity - The block entity from BEFORE the block is broken (can be null)\n+\t * <li> block - The block instance of the block that is being broken</ul>\n+\t */\n+\tpublic static final Event<BeforeBreakBlockCallback> BEFORE = EventFactory.createArrayBacked(BeforeBreakBlockCallback.class,\n+\t\t\t(listeners) -> (world, player, pos, state, entity, block) -> {\n+\t\t\t\tfor (BeforeBreakBlockCallback event : listeners) {\n+\t\t\t\t\tActionResult result = event.beforeBlockBreak(world, player, pos, state, entity, block);\n+\n+\t\t\t\t\tif (result != ActionResult.FAIL) {\n+\t\t\t\t\t\treturn result;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\treturn ActionResult.FAIL;\n+\t\t\t}\n+\t);\n+\n+\t/**\n+\t * Callback after a block is broken.\n+\t * Called on both Client and Server\n+\t *\n+\t * <p>Fields:\n+\t * <ul><li> world - The world where the block was broken\n+\t * <li> player - The player who broke the block\n+\t * <li> pos - The position where the block was broken\n+\t * <li> state - The block state from AFTER the block was broken\n+\t * <li> entity - The block entity of the broken block (can be null)\n+\t * <li> block - The block instance of the block that was broken</ul>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35509367dbbe84f6aa04cafecb8b899ad241c680"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDEyMDcyNQ==", "bodyText": "Yes, just call this After. We know this is a callback, and this is in BlockBreakEvents so BreakBlock is redundant context as well.", "url": "https://github.com/FabricMC/fabric/pull/980#discussion_r464120725", "createdAt": "2020-08-02T20:34:46Z", "author": {"login": "liach"}, "path": "fabric-events-interaction-v0/src/main/java/net/fabricmc/fabric/api/event/player/BlockBreakEvents.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.event.player;\n+\n+import net.minecraft.block.Block;\n+import net.minecraft.block.BlockState;\n+import net.minecraft.block.entity.BlockEntity;\n+import net.minecraft.entity.player.PlayerEntity;\n+import net.minecraft.util.ActionResult;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.world.World;\n+\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+\n+public class BlockBreakEvents {\n+\t/**\n+\t * Callback before a block is broken.\n+\t * Only called on the server, however updates are synced with the client.\n+\t *\n+\t * <p>Upon return:\n+\t * <ul><li>SUCCESS/PASS/CONSUME continues the default code for breaking the block\n+\t * <li>FAIL cancels the block breaking action</ul>\n+\t *\n+\t * <p>Fields:\n+\t * <ul><li> world - The world at which the block is being broken\n+\t * <li> player - The player who is breaking the block\n+\t * <li> pos - The position at which the block is being broken\n+\t * <li> state - The block state from BEFORE the block is broken\n+\t * <li> entity - The block entity from BEFORE the block is broken (can be null)\n+\t * <li> block - The block instance of the block that is being broken</ul>\n+\t */\n+\tpublic static final Event<BeforeBreakBlockCallback> BEFORE = EventFactory.createArrayBacked(BeforeBreakBlockCallback.class,\n+\t\t\t(listeners) -> (world, player, pos, state, entity, block) -> {\n+\t\t\t\tfor (BeforeBreakBlockCallback event : listeners) {\n+\t\t\t\t\tActionResult result = event.beforeBlockBreak(world, player, pos, state, entity, block);\n+\n+\t\t\t\t\tif (result != ActionResult.FAIL) {\n+\t\t\t\t\t\treturn result;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\treturn ActionResult.FAIL;\n+\t\t\t}\n+\t);\n+\n+\t/**\n+\t * Callback after a block is broken.\n+\t * Called on both Client and Server\n+\t *\n+\t * <p>Fields:\n+\t * <ul><li> world - The world where the block was broken\n+\t * <li> player - The player who broke the block\n+\t * <li> pos - The position where the block was broken\n+\t * <li> state - The block state from AFTER the block was broken\n+\t * <li> entity - The block entity of the broken block (can be null)\n+\t * <li> block - The block instance of the block that was broken</ul>\n+\t */\n+\tpublic static final Event<AfterBreakBlockCallback> AFTER = EventFactory.createArrayBacked(AfterBreakBlockCallback.class,\n+\t\t\t(listeners) -> (world, player, pos, state, entity, block) -> {\n+\t\t\t\tfor (AfterBreakBlockCallback event : listeners) {\n+\t\t\t\t\tevent.afterBlockBreak(world, player, pos, state, entity, block);\n+\t\t\t\t}\n+\t\t\t}\n+\t);\n+\n+\t@FunctionalInterface\n+\tpublic interface BeforeBreakBlockCallback {\n+\t\tActionResult beforeBlockBreak(World world, PlayerEntity player, BlockPos pos, BlockState state, /* Nullable */ BlockEntity entity, Block block);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface AfterBreakBlockCallback {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDEwMTg1NQ=="}, "originalCommit": {"oid": "35509367dbbe84f6aa04cafecb8b899ad241c680"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDEyMTAyOQ==", "bodyText": "Instead of doing this loop, add a Cancellation sub functioal interface that allow mods to handle custom server-side block break cancellation logic. In this setup, you only consider vanilla redstone but disregard other mods that can have a bigger volume of influence.\nhttps://github.com/FabricMC/fabric/pull/980/files#r463989517\nPreferably, this loop should be moved to an event handler listening to the cancellation event than left in this mixin body.", "url": "https://github.com/FabricMC/fabric/pull/980#discussion_r464121029", "createdAt": "2020-08-02T20:37:58Z", "author": {"login": "liach"}, "path": "fabric-events-interaction-v0/src/main/java/net/fabricmc/fabric/mixin/event/interaction/MixinServerPlayerInteractionManager.java", "diffHunk": "@@ -81,4 +86,28 @@ public void interactItem(ServerPlayerEntity player, World world, ItemStack stack\n \t\t\treturn;\n \t\t}\n \t}\n+\n+\t@Inject(at = @At(value = \"INVOKE\", target = \"Lnet/minecraft/block/Block;onBreak(Lnet/minecraft/world/World;Lnet/minecraft/util/math/BlockPos;Lnet/minecraft/block/BlockState;Lnet/minecraft/entity/player/PlayerEntity;)V\"), method = \"tryBreakBlock\", locals = LocalCapture.CAPTURE_FAILHARD, cancellable = true)\n+\tprivate void breakBlock(BlockPos pos, CallbackInfoReturnable<Boolean> cir, BlockState state, BlockEntity entity, Block block) {\n+\t\tActionResult result = BlockBreakEvents.BEFORE.invoker().beforeBlockBreak(this.world, this.player, pos, state, entity, block);\n+\n+\t\tif (result == ActionResult.FAIL) {\n+\t\t\tBlockPos cornerPos = pos.add(-1, -1, -1);\n+\n+\t\t\tfor (int x = 0; x < 3; x++) {\n+\t\t\t\tfor (int y = 0; y < 3; y++) {\n+\t\t\t\t\tfor (int z = 0; z < 3; z++) {\n+\t\t\t\t\t\tthis.player.networkHandler.sendPacket(new BlockUpdateS2CPacket(world, cornerPos.add(x, y, z)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35509367dbbe84f6aa04cafecb8b899ad241c680"}, "originalPosition": 35}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c6c8990db9659a947c952e5fdab2da45dbd1439f", "author": {"user": {"login": "Geometrically", "name": "Geometrically"}}, "url": "https://github.com/FabricMC/fabric/commit/c6c8990db9659a947c952e5fdab2da45dbd1439f", "committedDate": "2020-08-03T17:18:49Z", "message": "Add cancelation event and move javadocs"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwMjAzOTg2", "url": "https://github.com/FabricMC/fabric/pull/980#pullrequestreview-460203986", "createdAt": "2020-08-03T17:22:08Z", "commit": {"oid": "c6c8990db9659a947c952e5fdab2da45dbd1439f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwMjA1MDI1", "url": "https://github.com/FabricMC/fabric/pull/980#pullrequestreview-460205025", "createdAt": "2020-08-03T17:23:41Z", "commit": {"oid": "c6c8990db9659a947c952e5fdab2da45dbd1439f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwMjAzMjg4", "url": "https://github.com/FabricMC/fabric/pull/980#pullrequestreview-460203288", "createdAt": "2020-08-03T17:21:02Z", "commit": {"oid": "c6c8990db9659a947c952e5fdab2da45dbd1439f"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxNzoyMTowM1rOG7B_xQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxNzoyMTowM1rOG7B_xQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU1MTg3Nw==", "bodyText": "Please move the fields onto the method javadoc. It's going to be easier to read that way.", "url": "https://github.com/FabricMC/fabric/pull/980#discussion_r464551877", "createdAt": "2020-08-03T17:21:03Z", "author": {"login": "i509VCB"}, "path": "fabric-events-interaction-v0/src/main/java/net/fabricmc/fabric/api/event/player/BlockBreakEvents.java", "diffHunk": "@@ -70,21 +100,23 @@\n \t * <li> entity - The block entity of the broken block (can be null)\n \t * <li> block - The block instance of the block that was broken</ul>\n \t */\n-\tpublic static final Event<AfterBreakBlockCallback> AFTER = EventFactory.createArrayBacked(AfterBreakBlockCallback.class,\n-\t\t\t(listeners) -> (world, player, pos, state, entity, block) -> {\n-\t\t\t\tfor (AfterBreakBlockCallback event : listeners) {\n-\t\t\t\t\tevent.afterBlockBreak(world, player, pos, state, entity, block);\n-\t\t\t\t}\n-\t\t\t}\n-\t);\n-\n \t@FunctionalInterface\n-\tpublic interface BeforeBreakBlockCallback {\n-\t\tActionResult beforeBlockBreak(World world, PlayerEntity player, BlockPos pos, BlockState state, /* Nullable */ BlockEntity entity, Block block);\n+\tpublic interface After {\n+\t\tvoid afterBlockBreak(World world, PlayerEntity player, BlockPos pos, BlockState state, /* Nullable */ BlockEntity entity);\n \t}\n \n+\t/* Called when a block break has been canceled\n+\t *\n+\t * <p>Fields:\n+\t * <ul><li> world - The world where the block was going to be broken\n+\t * <li> player - The player was going to break the block\n+\t * <li> pos - The position where the block was going to be broken\n+\t * <li> state - The block state of the block that was going to be broken\n+\t * <li> entity - The block entity of the block that was going to be broken (can be null)\n+\t * <li> block - The block instance of the block that was going to be broken</ul>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6c8990db9659a947c952e5fdab2da45dbd1439f"}, "originalPosition": 125}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2d81e83a379aa66281bca815a9c7493c363f7baa", "author": {"user": {"login": "Geometrically", "name": "Geometrically"}}, "url": "https://github.com/FabricMC/fabric/commit/2d81e83a379aa66281bca815a9c7493c363f7baa", "committedDate": "2020-08-03T18:07:36Z", "message": "Move JavaDoc + Make success have same function as pass"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eb4bcf3d5fa5d679e351ba52b3bdf48c81729089", "author": {"user": {"login": "Geometrically", "name": "Geometrically"}}, "url": "https://github.com/FabricMC/fabric/commit/eb4bcf3d5fa5d679e351ba52b3bdf48c81729089", "committedDate": "2020-08-03T18:29:25Z", "message": "Fix success bug"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwMjUyMDcw", "url": "https://github.com/FabricMC/fabric/pull/980#pullrequestreview-460252070", "createdAt": "2020-08-03T18:32:17Z", "commit": {"oid": "2d81e83a379aa66281bca815a9c7493c363f7baa"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxODozMjoxN1rOG7EX6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxODozNjowNlrOG7Ee3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU5MDgyNg==", "bodyText": "Why even make this event cancellable? We alreday have the attack block callback that provides a better UX for preventing the breaking of blocks.\nI do see the need for a BlockBreakEvent that happens once the block is definitely going to be broken.", "url": "https://github.com/FabricMC/fabric/pull/980#discussion_r464590826", "createdAt": "2020-08-03T18:32:17Z", "author": {"login": "modmuss50"}, "path": "fabric-events-interaction-v0/src/main/java/net/fabricmc/fabric/api/event/player/BlockBreakEvents.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.event.player;\n+\n+import net.minecraft.block.BlockState;\n+import net.minecraft.block.entity.BlockEntity;\n+import net.minecraft.entity.player.PlayerEntity;\n+import net.minecraft.util.ActionResult;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.world.World;\n+\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+\n+public final class BlockBreakEvents {\n+\tprivate BlockBreakEvents() { }\n+\n+\t/**\n+\t * Callback before a block is broken.\n+\t * Only called on the server, however updates are synced with the client.\n+\t *\n+\t * <p>Upon return:\n+\t * <ul><li>SUCCESS/PASS passes on the callback to the next listener\n+\t * <li>CONSUME continues the default code for breaking the block and ignores all other listeners\n+\t * <li>FAIL cancels the block breaking action</ul>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d81e83a379aa66281bca815a9c7493c363f7baa"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU5MTE0NQ==", "bodyText": "Humm, really not a fan of this...", "url": "https://github.com/FabricMC/fabric/pull/980#discussion_r464591145", "createdAt": "2020-08-03T18:33:03Z", "author": {"login": "modmuss50"}, "path": "fabric-events-interaction-v0/src/main/java/net/fabricmc/fabric/api/event/player/BlockBreakEvents.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.event.player;\n+\n+import net.minecraft.block.BlockState;\n+import net.minecraft.block.entity.BlockEntity;\n+import net.minecraft.entity.player.PlayerEntity;\n+import net.minecraft.util.ActionResult;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.world.World;\n+\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+\n+public final class BlockBreakEvents {\n+\tprivate BlockBreakEvents() { }\n+\n+\t/**\n+\t * Callback before a block is broken.\n+\t * Only called on the server, however updates are synced with the client.\n+\t *\n+\t * <p>Upon return:\n+\t * <ul><li>SUCCESS/PASS passes on the callback to the next listener\n+\t * <li>CONSUME continues the default code for breaking the block and ignores all other listeners\n+\t * <li>FAIL cancels the block breaking action</ul>\n+\t */\n+\tpublic static final Event<Before> BEFORE = EventFactory.createArrayBacked(Before.class,\n+\t\t\t(listeners) -> (world, player, pos, state, entity) -> {\n+\t\t\t\tfor (Before event : listeners) {\n+\t\t\t\t\tActionResult result = event.beforeBlockBreak(world, player, pos, state, entity);\n+\n+\t\t\t\t\tif (result != ActionResult.PASS) {\n+\t\t\t\t\t\treturn result;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\treturn ActionResult.PASS;\n+\t\t\t}\n+\t);\n+\n+\t/*\n+\t * Callback after a block is broken.\n+\t * Called on the Server only\n+\t */\n+\tpublic static final Event<After> AFTER = EventFactory.createArrayBacked(After.class,\n+\t\t\t(listeners) -> (world, player, pos, state, entity) -> {\n+\t\t\t\tfor (After event : listeners) {\n+\t\t\t\t\tevent.afterBlockBreak(world, player, pos, state, entity);\n+\t\t\t\t}\n+\t\t\t}\n+\t);\n+\n+\t/*\n+\t * Callback when a block break has been canceled\n+\t * Called on the Server only\n+\t */\n+\tpublic static final Event<Cancel> CANCEL = EventFactory.createArrayBacked(Cancel.class,\n+\t\t\t(listeners) -> (world, player, pos, state, entity) -> {\n+\t\t\t\tfor (Cancel event : listeners) {\n+\t\t\t\t\tevent.onBlockBreakCancel(world, player, pos, state, entity);\n+\t\t\t\t}\n+\t\t\t}\n+\t);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d81e83a379aa66281bca815a9c7493c363f7baa"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU5MTQzOA==", "bodyText": "the params are messsed up here.", "url": "https://github.com/FabricMC/fabric/pull/980#discussion_r464591438", "createdAt": "2020-08-03T18:33:44Z", "author": {"login": "modmuss50"}, "path": "fabric-events-interaction-v0/src/main/java/net/fabricmc/fabric/api/event/player/BlockBreakEvents.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.event.player;\n+\n+import net.minecraft.block.BlockState;\n+import net.minecraft.block.entity.BlockEntity;\n+import net.minecraft.entity.player.PlayerEntity;\n+import net.minecraft.util.ActionResult;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.world.World;\n+\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+\n+public final class BlockBreakEvents {\n+\tprivate BlockBreakEvents() { }\n+\n+\t/**\n+\t * Callback before a block is broken.\n+\t * Only called on the server, however updates are synced with the client.\n+\t *\n+\t * <p>Upon return:\n+\t * <ul><li>SUCCESS/PASS passes on the callback to the next listener\n+\t * <li>CONSUME continues the default code for breaking the block and ignores all other listeners\n+\t * <li>FAIL cancels the block breaking action</ul>\n+\t */\n+\tpublic static final Event<Before> BEFORE = EventFactory.createArrayBacked(Before.class,\n+\t\t\t(listeners) -> (world, player, pos, state, entity) -> {\n+\t\t\t\tfor (Before event : listeners) {\n+\t\t\t\t\tActionResult result = event.beforeBlockBreak(world, player, pos, state, entity);\n+\n+\t\t\t\t\tif (result != ActionResult.PASS) {\n+\t\t\t\t\t\treturn result;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\treturn ActionResult.PASS;\n+\t\t\t}\n+\t);\n+\n+\t/*\n+\t * Callback after a block is broken.\n+\t * Called on the Server only\n+\t */\n+\tpublic static final Event<After> AFTER = EventFactory.createArrayBacked(After.class,\n+\t\t\t(listeners) -> (world, player, pos, state, entity) -> {\n+\t\t\t\tfor (After event : listeners) {\n+\t\t\t\t\tevent.afterBlockBreak(world, player, pos, state, entity);\n+\t\t\t\t}\n+\t\t\t}\n+\t);\n+\n+\t/*\n+\t * Callback when a block break has been canceled\n+\t * Called on the Server only\n+\t */\n+\tpublic static final Event<Cancel> CANCEL = EventFactory.createArrayBacked(Cancel.class,\n+\t\t\t(listeners) -> (world, player, pos, state, entity) -> {\n+\t\t\t\tfor (Cancel event : listeners) {\n+\t\t\t\t\tevent.onBlockBreakCancel(world, player, pos, state, entity);\n+\t\t\t\t}\n+\t\t\t}\n+\t);\n+\n+\t@FunctionalInterface\n+\tpublic interface Before {\n+\t\t/* Called before a block is broken\n+\t\t *\n+\t\t * <p>Fields:\n+\t\t * <ul><li> world - The world at which the block is being broken\n+\t\t * <li> player - The player who is breaking the block\n+\t\t * <li> pos - The position at which the block is being broken\n+\t\t * <li> state - The block state from BEFORE the block is broken\n+\t\t * <li> entity - The block entity from BEFORE the block is broken (can be null)\n+\t\t */\n+\t\tActionResult beforeBlockBreak(World world, PlayerEntity player, BlockPos pos, BlockState state, /* Nullable */ BlockEntity entity);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface After {\n+\t\t/* Called after a block is broken\n+\t\t *\n+\t\t * <p>Fields:\n+\t\t * <ul><li> world - The world where the block was broken\n+\t\t * <li> player - The player who broke the block\n+\t\t * <li> pos - The position where the block was broken\n+\t\t * <li> state - The block state from AFTER the block was broken\n+\t\t * <li> entity - The block entity of the broken block (can be null)\n+\t\t * <li> block - The block instance of the block that was broken</ul>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d81e83a379aa66281bca815a9c7493c363f7baa"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU5MTQ5OA==", "bodyText": "and here, no block", "url": "https://github.com/FabricMC/fabric/pull/980#discussion_r464591498", "createdAt": "2020-08-03T18:33:53Z", "author": {"login": "modmuss50"}, "path": "fabric-events-interaction-v0/src/main/java/net/fabricmc/fabric/api/event/player/BlockBreakEvents.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.event.player;\n+\n+import net.minecraft.block.BlockState;\n+import net.minecraft.block.entity.BlockEntity;\n+import net.minecraft.entity.player.PlayerEntity;\n+import net.minecraft.util.ActionResult;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.world.World;\n+\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+\n+public final class BlockBreakEvents {\n+\tprivate BlockBreakEvents() { }\n+\n+\t/**\n+\t * Callback before a block is broken.\n+\t * Only called on the server, however updates are synced with the client.\n+\t *\n+\t * <p>Upon return:\n+\t * <ul><li>SUCCESS/PASS passes on the callback to the next listener\n+\t * <li>CONSUME continues the default code for breaking the block and ignores all other listeners\n+\t * <li>FAIL cancels the block breaking action</ul>\n+\t */\n+\tpublic static final Event<Before> BEFORE = EventFactory.createArrayBacked(Before.class,\n+\t\t\t(listeners) -> (world, player, pos, state, entity) -> {\n+\t\t\t\tfor (Before event : listeners) {\n+\t\t\t\t\tActionResult result = event.beforeBlockBreak(world, player, pos, state, entity);\n+\n+\t\t\t\t\tif (result != ActionResult.PASS) {\n+\t\t\t\t\t\treturn result;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\treturn ActionResult.PASS;\n+\t\t\t}\n+\t);\n+\n+\t/*\n+\t * Callback after a block is broken.\n+\t * Called on the Server only\n+\t */\n+\tpublic static final Event<After> AFTER = EventFactory.createArrayBacked(After.class,\n+\t\t\t(listeners) -> (world, player, pos, state, entity) -> {\n+\t\t\t\tfor (After event : listeners) {\n+\t\t\t\t\tevent.afterBlockBreak(world, player, pos, state, entity);\n+\t\t\t\t}\n+\t\t\t}\n+\t);\n+\n+\t/*\n+\t * Callback when a block break has been canceled\n+\t * Called on the Server only\n+\t */\n+\tpublic static final Event<Cancel> CANCEL = EventFactory.createArrayBacked(Cancel.class,\n+\t\t\t(listeners) -> (world, player, pos, state, entity) -> {\n+\t\t\t\tfor (Cancel event : listeners) {\n+\t\t\t\t\tevent.onBlockBreakCancel(world, player, pos, state, entity);\n+\t\t\t\t}\n+\t\t\t}\n+\t);\n+\n+\t@FunctionalInterface\n+\tpublic interface Before {\n+\t\t/* Called before a block is broken\n+\t\t *\n+\t\t * <p>Fields:\n+\t\t * <ul><li> world - The world at which the block is being broken\n+\t\t * <li> player - The player who is breaking the block\n+\t\t * <li> pos - The position at which the block is being broken\n+\t\t * <li> state - The block state from BEFORE the block is broken\n+\t\t * <li> entity - The block entity from BEFORE the block is broken (can be null)\n+\t\t */\n+\t\tActionResult beforeBlockBreak(World world, PlayerEntity player, BlockPos pos, BlockState state, /* Nullable */ BlockEntity entity);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface After {\n+\t\t/* Called after a block is broken\n+\t\t *\n+\t\t * <p>Fields:\n+\t\t * <ul><li> world - The world where the block was broken\n+\t\t * <li> player - The player who broke the block\n+\t\t * <li> pos - The position where the block was broken\n+\t\t * <li> state - The block state from AFTER the block was broken\n+\t\t * <li> entity - The block entity of the broken block (can be null)\n+\t\t * <li> block - The block instance of the block that was broken</ul>\n+\t\t */\n+\t\tvoid afterBlockBreak(World world, PlayerEntity player, BlockPos pos, BlockState state, /* Nullable */ BlockEntity entity);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface Cancel {\n+\t\t/* Called when a block break has been canceled\n+\t\t *\n+\t\t * <p>Fields:\n+\t\t * <ul><li> world - The world where the block was going to be broken\n+\t\t * <li> player - The player was going to break the block\n+\t\t * <li> pos - The position where the block was going to be broken\n+\t\t * <li> state - The block state of the block that was going to be broken\n+\t\t * <li> entity - The block entity of the block that was going to be broken (can be null)\n+\t\t * <li> block - The block instance of the block that was going to be broken</ul>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d81e83a379aa66281bca815a9c7493c363f7baa"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU5MTU4NQ==", "bodyText": "Do we need this if you pass the world and pos? I dont think so.", "url": "https://github.com/FabricMC/fabric/pull/980#discussion_r464591585", "createdAt": "2020-08-03T18:34:06Z", "author": {"login": "modmuss50"}, "path": "fabric-events-interaction-v0/src/main/java/net/fabricmc/fabric/api/event/player/BlockBreakEvents.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.event.player;\n+\n+import net.minecraft.block.BlockState;\n+import net.minecraft.block.entity.BlockEntity;\n+import net.minecraft.entity.player.PlayerEntity;\n+import net.minecraft.util.ActionResult;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.world.World;\n+\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+\n+public final class BlockBreakEvents {\n+\tprivate BlockBreakEvents() { }\n+\n+\t/**\n+\t * Callback before a block is broken.\n+\t * Only called on the server, however updates are synced with the client.\n+\t *\n+\t * <p>Upon return:\n+\t * <ul><li>SUCCESS/PASS passes on the callback to the next listener\n+\t * <li>CONSUME continues the default code for breaking the block and ignores all other listeners\n+\t * <li>FAIL cancels the block breaking action</ul>\n+\t */\n+\tpublic static final Event<Before> BEFORE = EventFactory.createArrayBacked(Before.class,\n+\t\t\t(listeners) -> (world, player, pos, state, entity) -> {\n+\t\t\t\tfor (Before event : listeners) {\n+\t\t\t\t\tActionResult result = event.beforeBlockBreak(world, player, pos, state, entity);\n+\n+\t\t\t\t\tif (result != ActionResult.PASS) {\n+\t\t\t\t\t\treturn result;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\treturn ActionResult.PASS;\n+\t\t\t}\n+\t);\n+\n+\t/*\n+\t * Callback after a block is broken.\n+\t * Called on the Server only\n+\t */\n+\tpublic static final Event<After> AFTER = EventFactory.createArrayBacked(After.class,\n+\t\t\t(listeners) -> (world, player, pos, state, entity) -> {\n+\t\t\t\tfor (After event : listeners) {\n+\t\t\t\t\tevent.afterBlockBreak(world, player, pos, state, entity);\n+\t\t\t\t}\n+\t\t\t}\n+\t);\n+\n+\t/*\n+\t * Callback when a block break has been canceled\n+\t * Called on the Server only\n+\t */\n+\tpublic static final Event<Cancel> CANCEL = EventFactory.createArrayBacked(Cancel.class,\n+\t\t\t(listeners) -> (world, player, pos, state, entity) -> {\n+\t\t\t\tfor (Cancel event : listeners) {\n+\t\t\t\t\tevent.onBlockBreakCancel(world, player, pos, state, entity);\n+\t\t\t\t}\n+\t\t\t}\n+\t);\n+\n+\t@FunctionalInterface\n+\tpublic interface Before {\n+\t\t/* Called before a block is broken\n+\t\t *\n+\t\t * <p>Fields:\n+\t\t * <ul><li> world - The world at which the block is being broken\n+\t\t * <li> player - The player who is breaking the block\n+\t\t * <li> pos - The position at which the block is being broken\n+\t\t * <li> state - The block state from BEFORE the block is broken\n+\t\t * <li> entity - The block entity from BEFORE the block is broken (can be null)\n+\t\t */\n+\t\tActionResult beforeBlockBreak(World world, PlayerEntity player, BlockPos pos, BlockState state, /* Nullable */ BlockEntity entity);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface After {\n+\t\t/* Called after a block is broken\n+\t\t *\n+\t\t * <p>Fields:\n+\t\t * <ul><li> world - The world where the block was broken\n+\t\t * <li> player - The player who broke the block\n+\t\t * <li> pos - The position where the block was broken\n+\t\t * <li> state - The block state from AFTER the block was broken\n+\t\t * <li> entity - The block entity of the broken block (can be null)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d81e83a379aa66281bca815a9c7493c363f7baa"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU5MTY0OQ==", "bodyText": "same again here I dont think we need this?", "url": "https://github.com/FabricMC/fabric/pull/980#discussion_r464591649", "createdAt": "2020-08-03T18:34:13Z", "author": {"login": "modmuss50"}, "path": "fabric-events-interaction-v0/src/main/java/net/fabricmc/fabric/api/event/player/BlockBreakEvents.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.event.player;\n+\n+import net.minecraft.block.BlockState;\n+import net.minecraft.block.entity.BlockEntity;\n+import net.minecraft.entity.player.PlayerEntity;\n+import net.minecraft.util.ActionResult;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.world.World;\n+\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+\n+public final class BlockBreakEvents {\n+\tprivate BlockBreakEvents() { }\n+\n+\t/**\n+\t * Callback before a block is broken.\n+\t * Only called on the server, however updates are synced with the client.\n+\t *\n+\t * <p>Upon return:\n+\t * <ul><li>SUCCESS/PASS passes on the callback to the next listener\n+\t * <li>CONSUME continues the default code for breaking the block and ignores all other listeners\n+\t * <li>FAIL cancels the block breaking action</ul>\n+\t */\n+\tpublic static final Event<Before> BEFORE = EventFactory.createArrayBacked(Before.class,\n+\t\t\t(listeners) -> (world, player, pos, state, entity) -> {\n+\t\t\t\tfor (Before event : listeners) {\n+\t\t\t\t\tActionResult result = event.beforeBlockBreak(world, player, pos, state, entity);\n+\n+\t\t\t\t\tif (result != ActionResult.PASS) {\n+\t\t\t\t\t\treturn result;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\treturn ActionResult.PASS;\n+\t\t\t}\n+\t);\n+\n+\t/*\n+\t * Callback after a block is broken.\n+\t * Called on the Server only\n+\t */\n+\tpublic static final Event<After> AFTER = EventFactory.createArrayBacked(After.class,\n+\t\t\t(listeners) -> (world, player, pos, state, entity) -> {\n+\t\t\t\tfor (After event : listeners) {\n+\t\t\t\t\tevent.afterBlockBreak(world, player, pos, state, entity);\n+\t\t\t\t}\n+\t\t\t}\n+\t);\n+\n+\t/*\n+\t * Callback when a block break has been canceled\n+\t * Called on the Server only\n+\t */\n+\tpublic static final Event<Cancel> CANCEL = EventFactory.createArrayBacked(Cancel.class,\n+\t\t\t(listeners) -> (world, player, pos, state, entity) -> {\n+\t\t\t\tfor (Cancel event : listeners) {\n+\t\t\t\t\tevent.onBlockBreakCancel(world, player, pos, state, entity);\n+\t\t\t\t}\n+\t\t\t}\n+\t);\n+\n+\t@FunctionalInterface\n+\tpublic interface Before {\n+\t\t/* Called before a block is broken\n+\t\t *\n+\t\t * <p>Fields:\n+\t\t * <ul><li> world - The world at which the block is being broken\n+\t\t * <li> player - The player who is breaking the block\n+\t\t * <li> pos - The position at which the block is being broken\n+\t\t * <li> state - The block state from BEFORE the block is broken\n+\t\t * <li> entity - The block entity from BEFORE the block is broken (can be null)\n+\t\t */\n+\t\tActionResult beforeBlockBreak(World world, PlayerEntity player, BlockPos pos, BlockState state, /* Nullable */ BlockEntity entity);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface After {\n+\t\t/* Called after a block is broken\n+\t\t *\n+\t\t * <p>Fields:\n+\t\t * <ul><li> world - The world where the block was broken\n+\t\t * <li> player - The player who broke the block\n+\t\t * <li> pos - The position where the block was broken\n+\t\t * <li> state - The block state from AFTER the block was broken\n+\t\t * <li> entity - The block entity of the broken block (can be null)\n+\t\t * <li> block - The block instance of the block that was broken</ul>\n+\t\t */\n+\t\tvoid afterBlockBreak(World world, PlayerEntity player, BlockPos pos, BlockState state, /* Nullable */ BlockEntity entity);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface Cancel {\n+\t\t/* Called when a block break has been canceled\n+\t\t *\n+\t\t * <p>Fields:\n+\t\t * <ul><li> world - The world where the block was going to be broken\n+\t\t * <li> player - The player was going to break the block\n+\t\t * <li> pos - The position where the block was going to be broken\n+\t\t * <li> state - The block state of the block that was going to be broken\n+\t\t * <li> entity - The block entity of the block that was going to be broken (can be null)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d81e83a379aa66281bca815a9c7493c363f7baa"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU5MTg1Mw==", "bodyText": "Why 3 interfaces? these all seem the same to me? Just make it one?", "url": "https://github.com/FabricMC/fabric/pull/980#discussion_r464591853", "createdAt": "2020-08-03T18:34:38Z", "author": {"login": "modmuss50"}, "path": "fabric-events-interaction-v0/src/main/java/net/fabricmc/fabric/api/event/player/BlockBreakEvents.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.event.player;\n+\n+import net.minecraft.block.BlockState;\n+import net.minecraft.block.entity.BlockEntity;\n+import net.minecraft.entity.player.PlayerEntity;\n+import net.minecraft.util.ActionResult;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.world.World;\n+\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+\n+public final class BlockBreakEvents {\n+\tprivate BlockBreakEvents() { }\n+\n+\t/**\n+\t * Callback before a block is broken.\n+\t * Only called on the server, however updates are synced with the client.\n+\t *\n+\t * <p>Upon return:\n+\t * <ul><li>SUCCESS/PASS passes on the callback to the next listener\n+\t * <li>CONSUME continues the default code for breaking the block and ignores all other listeners\n+\t * <li>FAIL cancels the block breaking action</ul>\n+\t */\n+\tpublic static final Event<Before> BEFORE = EventFactory.createArrayBacked(Before.class,\n+\t\t\t(listeners) -> (world, player, pos, state, entity) -> {\n+\t\t\t\tfor (Before event : listeners) {\n+\t\t\t\t\tActionResult result = event.beforeBlockBreak(world, player, pos, state, entity);\n+\n+\t\t\t\t\tif (result != ActionResult.PASS) {\n+\t\t\t\t\t\treturn result;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\treturn ActionResult.PASS;\n+\t\t\t}\n+\t);\n+\n+\t/*\n+\t * Callback after a block is broken.\n+\t * Called on the Server only\n+\t */\n+\tpublic static final Event<After> AFTER = EventFactory.createArrayBacked(After.class,\n+\t\t\t(listeners) -> (world, player, pos, state, entity) -> {\n+\t\t\t\tfor (After event : listeners) {\n+\t\t\t\t\tevent.afterBlockBreak(world, player, pos, state, entity);\n+\t\t\t\t}\n+\t\t\t}\n+\t);\n+\n+\t/*\n+\t * Callback when a block break has been canceled\n+\t * Called on the Server only\n+\t */\n+\tpublic static final Event<Cancel> CANCEL = EventFactory.createArrayBacked(Cancel.class,\n+\t\t\t(listeners) -> (world, player, pos, state, entity) -> {\n+\t\t\t\tfor (Cancel event : listeners) {\n+\t\t\t\t\tevent.onBlockBreakCancel(world, player, pos, state, entity);\n+\t\t\t\t}\n+\t\t\t}\n+\t);\n+\n+\t@FunctionalInterface\n+\tpublic interface Before {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d81e83a379aa66281bca815a9c7493c363f7baa"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU5MjE4Ng==", "bodyText": "Yeah, really not a fan of this, ill need to look at the vanilla code but there has to be a better way. atleast add a comment saying what it does.", "url": "https://github.com/FabricMC/fabric/pull/980#discussion_r464592186", "createdAt": "2020-08-03T18:35:13Z", "author": {"login": "modmuss50"}, "path": "fabric-events-interaction-v0/src/main/java/net/fabricmc/fabric/mixin/event/interaction/MixinServerPlayerInteractionManager.java", "diffHunk": "@@ -81,4 +86,30 @@ public void interactItem(ServerPlayerEntity player, World world, ItemStack stack\n \t\t\treturn;\n \t\t}\n \t}\n+\n+\t@Inject(at = @At(value = \"INVOKE\", target = \"Lnet/minecraft/block/Block;onBreak(Lnet/minecraft/world/World;Lnet/minecraft/util/math/BlockPos;Lnet/minecraft/block/BlockState;Lnet/minecraft/entity/player/PlayerEntity;)V\"), method = \"tryBreakBlock\", locals = LocalCapture.CAPTURE_FAILHARD, cancellable = true)\n+\tprivate void breakBlock(BlockPos pos, CallbackInfoReturnable<Boolean> cir, BlockState state, BlockEntity entity, Block block) {\n+\t\tActionResult result = BlockBreakEvents.BEFORE.invoker().beforeBlockBreak(this.world, this.player, pos, state, entity);\n+\n+\t\tif (result == ActionResult.FAIL) {\n+\t\t\tBlockBreakEvents.CANCEL.invoker().onBlockBreakCancel(this.world, this.player, pos, state, entity);\n+\n+\t\t\tBlockPos cornerPos = pos.add(-1, -1, -1);\n+\n+\t\t\tfor (int x = 0; x < 3; x++) {\n+\t\t\t\tfor (int y = 0; y < 3; y++) {\n+\t\t\t\t\tfor (int z = 0; z < 3; z++) {\n+\t\t\t\t\t\tthis.player.networkHandler.sendPacket(new BlockUpdateS2CPacket(world, cornerPos.add(x, y, z)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d81e83a379aa66281bca815a9c7493c363f7baa"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU5MjYwNQ==", "bodyText": "Whats the use case for this?", "url": "https://github.com/FabricMC/fabric/pull/980#discussion_r464592605", "createdAt": "2020-08-03T18:36:06Z", "author": {"login": "modmuss50"}, "path": "fabric-events-interaction-v0/src/main/java/net/fabricmc/fabric/api/event/player/BlockBreakEvents.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.event.player;\n+\n+import net.minecraft.block.BlockState;\n+import net.minecraft.block.entity.BlockEntity;\n+import net.minecraft.entity.player.PlayerEntity;\n+import net.minecraft.util.ActionResult;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.world.World;\n+\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+\n+public final class BlockBreakEvents {\n+\tprivate BlockBreakEvents() { }\n+\n+\t/**\n+\t * Callback before a block is broken.\n+\t * Only called on the server, however updates are synced with the client.\n+\t *\n+\t * <p>Upon return:\n+\t * <ul><li>SUCCESS/PASS passes on the callback to the next listener\n+\t * <li>CONSUME continues the default code for breaking the block and ignores all other listeners\n+\t * <li>FAIL cancels the block breaking action</ul>\n+\t */\n+\tpublic static final Event<Before> BEFORE = EventFactory.createArrayBacked(Before.class,\n+\t\t\t(listeners) -> (world, player, pos, state, entity) -> {\n+\t\t\t\tfor (Before event : listeners) {\n+\t\t\t\t\tActionResult result = event.beforeBlockBreak(world, player, pos, state, entity);\n+\n+\t\t\t\t\tif (result != ActionResult.PASS) {\n+\t\t\t\t\t\treturn result;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\treturn ActionResult.PASS;\n+\t\t\t}\n+\t);\n+\n+\t/*\n+\t * Callback after a block is broken.\n+\t * Called on the Server only\n+\t */\n+\tpublic static final Event<After> AFTER = EventFactory.createArrayBacked(After.class,\n+\t\t\t(listeners) -> (world, player, pos, state, entity) -> {\n+\t\t\t\tfor (After event : listeners) {\n+\t\t\t\t\tevent.afterBlockBreak(world, player, pos, state, entity);\n+\t\t\t\t}\n+\t\t\t}\n+\t);\n+\n+\t/*\n+\t * Callback when a block break has been canceled", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d81e83a379aa66281bca815a9c7493c363f7baa"}, "originalPosition": 68}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ba58c66061a306d34fd1013d35ce88e8364749c4", "author": {"user": {"login": "Geometrically", "name": "Geometrically"}}, "url": "https://github.com/FabricMC/fabric/commit/ba58c66061a306d34fd1013d35ce88e8364749c4", "committedDate": "2020-08-03T18:54:52Z", "message": "Fix documentation again, change approach"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7174955516e8f3ca264cfa48963f74f3cadba82e", "author": {"user": {"login": "Geometrically", "name": "Geometrically"}}, "url": "https://github.com/FabricMC/fabric/commit/7174955516e8f3ca264cfa48963f74f3cadba82e", "committedDate": "2020-08-03T19:41:56Z", "message": "Fix checkstyle"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMTY3Mjcz", "url": "https://github.com/FabricMC/fabric/pull/980#pullrequestreview-461167273", "createdAt": "2020-08-04T20:55:25Z", "commit": {"oid": "7174955516e8f3ca264cfa48963f74f3cadba82e"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMDo1NToyNVrOG7xLGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMTowNDoyNFrOG7xcxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTMyNDgyNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t/* Called before a block is broken\n          \n          \n            \n            \t\t *\n          \n          \n            \n            \t\t * <p>Fields:\n          \n          \n            \n            \t\t * <ul><li> world - The world at which the block is being broken\n          \n          \n            \n            \t\t * <li> player - The player who is breaking the block\n          \n          \n            \n            \t\t * <li> pos - The position at which the block is being broken\n          \n          \n            \n            \t\t * <li> state - The block state from BEFORE the block is broken\n          \n          \n            \n            \t\t * <li> entity - The block entity from BEFORE the block is broken (can be null)\n          \n          \n            \n            \t\t */\n          \n          \n            \n            \t\t/**\n          \n          \n            \n            \t\t * Called before a block is broken and allows cancelling the block breaking.\n          \n          \n            \n            \t\t *\n          \n          \n            \n            \t\t * <p>Implementations should not modify the world or assume the block break has completed or failed.</p>\n          \n          \n            \n            \t\t *\n          \n          \n            \n            \t\t * @param world the world in which the block is broken\n          \n          \n            \n            \t\t * @param player the player breaking the block\n          \n          \n            \n            \t\t * @param pos the position at which the block is broken\n          \n          \n            \n            \t\t * @param state the block state <strong>before</strong> the block is broken\n          \n          \n            \n            \t\t * @param entity the block entity <strong>before</strong> the block is broken, can be {@code null}\n          \n          \n            \n            \t\t * @return {@code false} to cancel block breaking action, or {@code true} to pass to next listener\n          \n          \n            \n            \t\t */", "url": "https://github.com/FabricMC/fabric/pull/980#discussion_r465324826", "createdAt": "2020-08-04T20:55:25Z", "author": {"login": "liach"}, "path": "fabric-events-interaction-v0/src/main/java/net/fabricmc/fabric/api/event/player/BlockBreakEvents.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.event.player;\n+\n+import net.minecraft.block.BlockState;\n+import net.minecraft.block.entity.BlockEntity;\n+import net.minecraft.entity.player.PlayerEntity;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.world.World;\n+\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+\n+public final class BlockBreakEvents {\n+\tprivate BlockBreakEvents() { }\n+\n+\t/**\n+\t * Callback before a block is broken.\n+\t * Only called on the server, however updates are synced with the client.\n+\t *\n+\t * <p>Upon return:\n+\t * <ul><li>`true` passes on the callback to the next listener\n+\t * <li>`false` cancels the block breaking action</ul>\n+\t */\n+\tpublic static final Event<Before> BEFORE = EventFactory.createArrayBacked(Before.class,\n+\t\t\t(listeners) -> (world, player, pos, state, entity) -> {\n+\t\t\t\tfor (Before event : listeners) {\n+\t\t\t\t\tboolean result = event.beforeBlockBreak(world, player, pos, state, entity);\n+\n+\t\t\t\t\tif (!result) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t);\n+\n+\t/*\n+\t * Callback after a block is broken.\n+\t * Called on the Server only\n+\t */\n+\tpublic static final Event<After> AFTER = EventFactory.createArrayBacked(After.class,\n+\t\t\t(listeners) -> (world, player, pos, state, entity) -> {\n+\t\t\t\tfor (After event : listeners) {\n+\t\t\t\t\tevent.afterBlockBreak(world, player, pos, state, entity);\n+\t\t\t\t}\n+\t\t\t}\n+\t);\n+\n+\t/*\n+\t * Callback when a block break has been canceled\n+\t * Called on the Server only\n+\t */\n+\tpublic static final Event<Cancel> CANCEL = EventFactory.createArrayBacked(Cancel.class,\n+\t\t\t(listeners) -> (world, player, pos, state, entity) -> {\n+\t\t\t\tfor (Cancel event : listeners) {\n+\t\t\t\t\tevent.onBlockBreakCancel(world, player, pos, state, entity);\n+\t\t\t\t}\n+\t\t\t}\n+\t);\n+\n+\t@FunctionalInterface\n+\tpublic interface Before {\n+\t\t/* Called before a block is broken\n+\t\t *\n+\t\t * <p>Fields:\n+\t\t * <ul><li> world - The world at which the block is being broken\n+\t\t * <li> player - The player who is breaking the block\n+\t\t * <li> pos - The position at which the block is being broken\n+\t\t * <li> state - The block state from BEFORE the block is broken\n+\t\t * <li> entity - The block entity from BEFORE the block is broken (can be null)\n+\t\t */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7174955516e8f3ca264cfa48963f74f3cadba82e"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTMyNTk5Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t/* Called after a block is broken\n          \n          \n            \n            \t\t *\n          \n          \n            \n            \t\t * <p>Fields:\n          \n          \n            \n            \t\t * <ul><li> world - The world where the block was broken\n          \n          \n            \n            \t\t * <li> player - The player who broke the block\n          \n          \n            \n            \t\t * <li> pos - The position where the block was broken\n          \n          \n            \n            \t\t * <li> state - The block state from AFTER the block was broken\n          \n          \n            \n            \t\t * <li> entity - The block entity of the broken block (can be null)\n          \n          \n            \n            \t\t/**\n          \n          \n            \n            \t\t * Called after a block is successfully broken.\n          \n          \n            \n            \t\t *\n          \n          \n            \n            \t\t * @param world the world where the block was broken\n          \n          \n            \n            \t\t * @param player the player who broke the block\n          \n          \n            \n            \t\t * @param pos the position where the block was broken\n          \n          \n            \n            \t\t * @param state the block state <strong>after</strong> the block was broken\n          \n          \n            \n            \t\t * @param entity the block entity of the broken block, can be {@code null}", "url": "https://github.com/FabricMC/fabric/pull/980#discussion_r465325992", "createdAt": "2020-08-04T20:57:26Z", "author": {"login": "liach"}, "path": "fabric-events-interaction-v0/src/main/java/net/fabricmc/fabric/api/event/player/BlockBreakEvents.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.event.player;\n+\n+import net.minecraft.block.BlockState;\n+import net.minecraft.block.entity.BlockEntity;\n+import net.minecraft.entity.player.PlayerEntity;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.world.World;\n+\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+\n+public final class BlockBreakEvents {\n+\tprivate BlockBreakEvents() { }\n+\n+\t/**\n+\t * Callback before a block is broken.\n+\t * Only called on the server, however updates are synced with the client.\n+\t *\n+\t * <p>Upon return:\n+\t * <ul><li>`true` passes on the callback to the next listener\n+\t * <li>`false` cancels the block breaking action</ul>\n+\t */\n+\tpublic static final Event<Before> BEFORE = EventFactory.createArrayBacked(Before.class,\n+\t\t\t(listeners) -> (world, player, pos, state, entity) -> {\n+\t\t\t\tfor (Before event : listeners) {\n+\t\t\t\t\tboolean result = event.beforeBlockBreak(world, player, pos, state, entity);\n+\n+\t\t\t\t\tif (!result) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t);\n+\n+\t/*\n+\t * Callback after a block is broken.\n+\t * Called on the Server only\n+\t */\n+\tpublic static final Event<After> AFTER = EventFactory.createArrayBacked(After.class,\n+\t\t\t(listeners) -> (world, player, pos, state, entity) -> {\n+\t\t\t\tfor (After event : listeners) {\n+\t\t\t\t\tevent.afterBlockBreak(world, player, pos, state, entity);\n+\t\t\t\t}\n+\t\t\t}\n+\t);\n+\n+\t/*\n+\t * Callback when a block break has been canceled\n+\t * Called on the Server only\n+\t */\n+\tpublic static final Event<Cancel> CANCEL = EventFactory.createArrayBacked(Cancel.class,\n+\t\t\t(listeners) -> (world, player, pos, state, entity) -> {\n+\t\t\t\tfor (Cancel event : listeners) {\n+\t\t\t\t\tevent.onBlockBreakCancel(world, player, pos, state, entity);\n+\t\t\t\t}\n+\t\t\t}\n+\t);\n+\n+\t@FunctionalInterface\n+\tpublic interface Before {\n+\t\t/* Called before a block is broken\n+\t\t *\n+\t\t * <p>Fields:\n+\t\t * <ul><li> world - The world at which the block is being broken\n+\t\t * <li> player - The player who is breaking the block\n+\t\t * <li> pos - The position at which the block is being broken\n+\t\t * <li> state - The block state from BEFORE the block is broken\n+\t\t * <li> entity - The block entity from BEFORE the block is broken (can be null)\n+\t\t */\n+\t\tboolean beforeBlockBreak(World world, PlayerEntity player, BlockPos pos, BlockState state, /* Nullable */ BlockEntity entity);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface After {\n+\t\t/* Called after a block is broken\n+\t\t *\n+\t\t * <p>Fields:\n+\t\t * <ul><li> world - The world where the block was broken\n+\t\t * <li> player - The player who broke the block\n+\t\t * <li> pos - The position where the block was broken\n+\t\t * <li> state - The block state from AFTER the block was broken\n+\t\t * <li> entity - The block entity of the broken block (can be null)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7174955516e8f3ca264cfa48963f74f3cadba82e"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTMyNjg0NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t/* Called when a block break has been canceled\n          \n          \n            \n            \t\t *\n          \n          \n            \n            \t\t * <p>Fields:\n          \n          \n            \n            \t\t * <ul><li> world - The world where the block was going to be broken\n          \n          \n            \n            \t\t * <li> player - The player was going to break the block\n          \n          \n            \n            \t\t * <li> pos - The position where the block was going to be broken\n          \n          \n            \n            \t\t * <li> state - The block state of the block that was going to be broken\n          \n          \n            \n            \t\t * <li> entity - The block entity of the block that was going to be broken (can be null)\n          \n          \n            \n            \t\t/**\n          \n          \n            \n            \t\t * Called when a block break has been canceled.\n          \n          \n            \n            \t\t *\n          \n          \n            \n            \t\t * @param world the world where the block was going to be broken\n          \n          \n            \n            \t\t * @param player the player who was going to break the block\n          \n          \n            \n            \t\t * @param pos the position where the block was going to be broken\n          \n          \n            \n            \t\t * @param state the block state of the block that was going to be broken\n          \n          \n            \n            \t\t * @param entity the block entity of the block that was going to be broken, can be {@code null}", "url": "https://github.com/FabricMC/fabric/pull/980#discussion_r465326844", "createdAt": "2020-08-04T20:59:15Z", "author": {"login": "liach"}, "path": "fabric-events-interaction-v0/src/main/java/net/fabricmc/fabric/api/event/player/BlockBreakEvents.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.event.player;\n+\n+import net.minecraft.block.BlockState;\n+import net.minecraft.block.entity.BlockEntity;\n+import net.minecraft.entity.player.PlayerEntity;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.world.World;\n+\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+\n+public final class BlockBreakEvents {\n+\tprivate BlockBreakEvents() { }\n+\n+\t/**\n+\t * Callback before a block is broken.\n+\t * Only called on the server, however updates are synced with the client.\n+\t *\n+\t * <p>Upon return:\n+\t * <ul><li>`true` passes on the callback to the next listener\n+\t * <li>`false` cancels the block breaking action</ul>\n+\t */\n+\tpublic static final Event<Before> BEFORE = EventFactory.createArrayBacked(Before.class,\n+\t\t\t(listeners) -> (world, player, pos, state, entity) -> {\n+\t\t\t\tfor (Before event : listeners) {\n+\t\t\t\t\tboolean result = event.beforeBlockBreak(world, player, pos, state, entity);\n+\n+\t\t\t\t\tif (!result) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t);\n+\n+\t/*\n+\t * Callback after a block is broken.\n+\t * Called on the Server only\n+\t */\n+\tpublic static final Event<After> AFTER = EventFactory.createArrayBacked(After.class,\n+\t\t\t(listeners) -> (world, player, pos, state, entity) -> {\n+\t\t\t\tfor (After event : listeners) {\n+\t\t\t\t\tevent.afterBlockBreak(world, player, pos, state, entity);\n+\t\t\t\t}\n+\t\t\t}\n+\t);\n+\n+\t/*\n+\t * Callback when a block break has been canceled\n+\t * Called on the Server only\n+\t */\n+\tpublic static final Event<Cancel> CANCEL = EventFactory.createArrayBacked(Cancel.class,\n+\t\t\t(listeners) -> (world, player, pos, state, entity) -> {\n+\t\t\t\tfor (Cancel event : listeners) {\n+\t\t\t\t\tevent.onBlockBreakCancel(world, player, pos, state, entity);\n+\t\t\t\t}\n+\t\t\t}\n+\t);\n+\n+\t@FunctionalInterface\n+\tpublic interface Before {\n+\t\t/* Called before a block is broken\n+\t\t *\n+\t\t * <p>Fields:\n+\t\t * <ul><li> world - The world at which the block is being broken\n+\t\t * <li> player - The player who is breaking the block\n+\t\t * <li> pos - The position at which the block is being broken\n+\t\t * <li> state - The block state from BEFORE the block is broken\n+\t\t * <li> entity - The block entity from BEFORE the block is broken (can be null)\n+\t\t */\n+\t\tboolean beforeBlockBreak(World world, PlayerEntity player, BlockPos pos, BlockState state, /* Nullable */ BlockEntity entity);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface After {\n+\t\t/* Called after a block is broken\n+\t\t *\n+\t\t * <p>Fields:\n+\t\t * <ul><li> world - The world where the block was broken\n+\t\t * <li> player - The player who broke the block\n+\t\t * <li> pos - The position where the block was broken\n+\t\t * <li> state - The block state from AFTER the block was broken\n+\t\t * <li> entity - The block entity of the broken block (can be null)\n+\t\t */\n+\t\tvoid afterBlockBreak(World world, PlayerEntity player, BlockPos pos, BlockState state, /* Nullable */ BlockEntity entity);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface Cancel {\n+\t\t/* Called when a block break has been canceled\n+\t\t *\n+\t\t * <p>Fields:\n+\t\t * <ul><li> world - The world where the block was going to be broken\n+\t\t * <li> player - The player was going to break the block\n+\t\t * <li> pos - The position where the block was going to be broken\n+\t\t * <li> state - The block state of the block that was going to be broken\n+\t\t * <li> entity - The block entity of the block that was going to be broken (can be null)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7174955516e8f3ca264cfa48963f74f3cadba82e"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTMyNzcxMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t/*\n          \n          \n            \n            \t * Callback when a block break has been canceled\n          \n          \n            \n            \t * Called on the Server only\n          \n          \n            \n            \t/**\n          \n          \n            \n            \t * Callback when a block break has been canceled.\n          \n          \n            \n            \t * \n          \n          \n            \n            \t * <p>Called on the logical server only. May be used to send packets to revert client-side block changes.</p>", "url": "https://github.com/FabricMC/fabric/pull/980#discussion_r465327713", "createdAt": "2020-08-04T21:00:54Z", "author": {"login": "liach"}, "path": "fabric-events-interaction-v0/src/main/java/net/fabricmc/fabric/api/event/player/BlockBreakEvents.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.event.player;\n+\n+import net.minecraft.block.BlockState;\n+import net.minecraft.block.entity.BlockEntity;\n+import net.minecraft.entity.player.PlayerEntity;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.world.World;\n+\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+\n+public final class BlockBreakEvents {\n+\tprivate BlockBreakEvents() { }\n+\n+\t/**\n+\t * Callback before a block is broken.\n+\t * Only called on the server, however updates are synced with the client.\n+\t *\n+\t * <p>Upon return:\n+\t * <ul><li>`true` passes on the callback to the next listener\n+\t * <li>`false` cancels the block breaking action</ul>\n+\t */\n+\tpublic static final Event<Before> BEFORE = EventFactory.createArrayBacked(Before.class,\n+\t\t\t(listeners) -> (world, player, pos, state, entity) -> {\n+\t\t\t\tfor (Before event : listeners) {\n+\t\t\t\t\tboolean result = event.beforeBlockBreak(world, player, pos, state, entity);\n+\n+\t\t\t\t\tif (!result) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t);\n+\n+\t/*\n+\t * Callback after a block is broken.\n+\t * Called on the Server only\n+\t */\n+\tpublic static final Event<After> AFTER = EventFactory.createArrayBacked(After.class,\n+\t\t\t(listeners) -> (world, player, pos, state, entity) -> {\n+\t\t\t\tfor (After event : listeners) {\n+\t\t\t\t\tevent.afterBlockBreak(world, player, pos, state, entity);\n+\t\t\t\t}\n+\t\t\t}\n+\t);\n+\n+\t/*\n+\t * Callback when a block break has been canceled\n+\t * Called on the Server only", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7174955516e8f3ca264cfa48963f74f3cadba82e"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTMyNzk1MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t/*\n          \n          \n            \n            \t * Callback after a block is broken.\n          \n          \n            \n            \t * Called on the Server only\n          \n          \n            \n            \t */\n          \n          \n            \n            \t/**\n          \n          \n            \n            \t * Callback after a block is broken.\n          \n          \n            \n            \t * \n          \n          \n            \n            \t * <p>Called on the Server only.</p>\n          \n          \n            \n            \t */", "url": "https://github.com/FabricMC/fabric/pull/980#discussion_r465327951", "createdAt": "2020-08-04T21:01:24Z", "author": {"login": "liach"}, "path": "fabric-events-interaction-v0/src/main/java/net/fabricmc/fabric/api/event/player/BlockBreakEvents.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.event.player;\n+\n+import net.minecraft.block.BlockState;\n+import net.minecraft.block.entity.BlockEntity;\n+import net.minecraft.entity.player.PlayerEntity;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.world.World;\n+\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+\n+public final class BlockBreakEvents {\n+\tprivate BlockBreakEvents() { }\n+\n+\t/**\n+\t * Callback before a block is broken.\n+\t * Only called on the server, however updates are synced with the client.\n+\t *\n+\t * <p>Upon return:\n+\t * <ul><li>`true` passes on the callback to the next listener\n+\t * <li>`false` cancels the block breaking action</ul>\n+\t */\n+\tpublic static final Event<Before> BEFORE = EventFactory.createArrayBacked(Before.class,\n+\t\t\t(listeners) -> (world, player, pos, state, entity) -> {\n+\t\t\t\tfor (Before event : listeners) {\n+\t\t\t\t\tboolean result = event.beforeBlockBreak(world, player, pos, state, entity);\n+\n+\t\t\t\t\tif (!result) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t);\n+\n+\t/*\n+\t * Callback after a block is broken.\n+\t * Called on the Server only\n+\t */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7174955516e8f3ca264cfa48963f74f3cadba82e"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTMyOTM1MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * <p>Upon return:\n          \n          \n            \n            \t * <ul><li>`true` passes on the callback to the next listener\n          \n          \n            \n            \t * <li>`false` cancels the block breaking action</ul>\n          \n          \n            \n            \t * <p>If any listener cancels a block breaking action, that block breaking\n          \n          \n            \n            \t * action is cancelled and {@link CANCEL} event is fired. Otherwise, the\n          \n          \n            \n            \t * {@link AFTER} event is fired.</p>\n          \n      \n    \n    \n  \n\nReturn value described in method already", "url": "https://github.com/FabricMC/fabric/pull/980#discussion_r465329351", "createdAt": "2020-08-04T21:04:24Z", "author": {"login": "liach"}, "path": "fabric-events-interaction-v0/src/main/java/net/fabricmc/fabric/api/event/player/BlockBreakEvents.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.event.player;\n+\n+import net.minecraft.block.BlockState;\n+import net.minecraft.block.entity.BlockEntity;\n+import net.minecraft.entity.player.PlayerEntity;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.world.World;\n+\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+\n+public final class BlockBreakEvents {\n+\tprivate BlockBreakEvents() { }\n+\n+\t/**\n+\t * Callback before a block is broken.\n+\t * Only called on the server, however updates are synced with the client.\n+\t *\n+\t * <p>Upon return:\n+\t * <ul><li>`true` passes on the callback to the next listener\n+\t * <li>`false` cancels the block breaking action</ul>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7174955516e8f3ca264cfa48963f74f3cadba82e"}, "originalPosition": 37}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b7a1d42389d51183c51aaa313741d908cee458c4", "author": {"user": {"login": "Geometrically", "name": "Geometrically"}}, "url": "https://github.com/FabricMC/fabric/commit/b7a1d42389d51183c51aaa313741d908cee458c4", "committedDate": "2020-08-04T21:08:03Z", "message": "Update fabric-events-interaction-v0/src/main/java/net/fabricmc/fabric/api/event/player/BlockBreakEvents.java\n\nCo-authored-by: liach <7806504+liach@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6bc1f00eb978244b76b0de1761481b291fdef168", "author": {"user": {"login": "Geometrically", "name": "Geometrically"}}, "url": "https://github.com/FabricMC/fabric/commit/6bc1f00eb978244b76b0de1761481b291fdef168", "committedDate": "2020-08-04T21:08:11Z", "message": "Update fabric-events-interaction-v0/src/main/java/net/fabricmc/fabric/api/event/player/BlockBreakEvents.java\n\nCo-authored-by: liach <7806504+liach@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f7edf7527baf4c080588d3fafff43eab52684f83", "author": {"user": {"login": "Geometrically", "name": "Geometrically"}}, "url": "https://github.com/FabricMC/fabric/commit/f7edf7527baf4c080588d3fafff43eab52684f83", "committedDate": "2020-08-04T21:08:22Z", "message": "Update fabric-events-interaction-v0/src/main/java/net/fabricmc/fabric/api/event/player/BlockBreakEvents.java\n\nCo-authored-by: liach <7806504+liach@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c1ba20c50d8b53cfce37dc0919beb85484f6bd03", "author": {"user": {"login": "Geometrically", "name": "Geometrically"}}, "url": "https://github.com/FabricMC/fabric/commit/c1ba20c50d8b53cfce37dc0919beb85484f6bd03", "committedDate": "2020-08-04T21:08:32Z", "message": "Update fabric-events-interaction-v0/src/main/java/net/fabricmc/fabric/api/event/player/BlockBreakEvents.java\n\nCo-authored-by: liach <7806504+liach@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dd887c8c97b9c915c3e2dd744de6258a50f2a7f9", "author": {"user": {"login": "Geometrically", "name": "Geometrically"}}, "url": "https://github.com/FabricMC/fabric/commit/dd887c8c97b9c915c3e2dd744de6258a50f2a7f9", "committedDate": "2020-08-04T21:08:41Z", "message": "Update fabric-events-interaction-v0/src/main/java/net/fabricmc/fabric/api/event/player/BlockBreakEvents.java\n\nCo-authored-by: liach <7806504+liach@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "49039a3c83cd696b02cbcc6120a83dd194b20749", "author": {"user": {"login": "Geometrically", "name": "Geometrically"}}, "url": "https://github.com/FabricMC/fabric/commit/49039a3c83cd696b02cbcc6120a83dd194b20749", "committedDate": "2020-08-04T21:08:49Z", "message": "Update fabric-events-interaction-v0/src/main/java/net/fabricmc/fabric/api/event/player/BlockBreakEvents.java\n\nCo-authored-by: liach <7806504+liach@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8df6d36e2a57987499863b9343f9fb659e20a9c8", "author": {"user": {"login": "Geometrically", "name": "Geometrically"}}, "url": "https://github.com/FabricMC/fabric/commit/8df6d36e2a57987499863b9343f9fb659e20a9c8", "committedDate": "2020-08-04T21:16:22Z", "message": "Fix checkstyle"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMTgwODY5", "url": "https://github.com/FabricMC/fabric/pull/980#pullrequestreview-461180869", "createdAt": "2020-08-04T21:16:20Z", "commit": {"oid": "49039a3c83cd696b02cbcc6120a83dd194b20749"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMToxNjoyMFrOG7xzrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMToxNjoyNVrOG7xz1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTMzNTIxMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * \n          \n          \n            \n            \t *", "url": "https://github.com/FabricMC/fabric/pull/980#discussion_r465335213", "createdAt": "2020-08-04T21:16:20Z", "author": {"login": "liach"}, "path": "fabric-events-interaction-v0/src/main/java/net/fabricmc/fabric/api/event/player/BlockBreakEvents.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.event.player;\n+\n+import net.minecraft.block.BlockState;\n+import net.minecraft.block.entity.BlockEntity;\n+import net.minecraft.entity.player.PlayerEntity;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.world.World;\n+\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+\n+public final class BlockBreakEvents {\n+\tprivate BlockBreakEvents() { }\n+\n+\t/**\n+\t * Callback before a block is broken.\n+\t * Only called on the server, however updates are synced with the client.\n+\t *\n+\t * <p>If any listener cancels a block breaking action, that block breaking\n+\t * action is cancelled and {@link CANCEL} event is fired. Otherwise, the\n+\t * {@link AFTER} event is fired.</p>\n+\t */\n+\tpublic static final Event<Before> BEFORE = EventFactory.createArrayBacked(Before.class,\n+\t\t\t(listeners) -> (world, player, pos, state, entity) -> {\n+\t\t\t\tfor (Before event : listeners) {\n+\t\t\t\t\tboolean result = event.beforeBlockBreak(world, player, pos, state, entity);\n+\n+\t\t\t\t\tif (!result) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t);\n+\n+\t/**\n+\t * Callback after a block is broken.\n+\t * ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49039a3c83cd696b02cbcc6120a83dd194b20749"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTMzNTI1Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * \n          \n          \n            \n            \t *", "url": "https://github.com/FabricMC/fabric/pull/980#discussion_r465335253", "createdAt": "2020-08-04T21:16:25Z", "author": {"login": "liach"}, "path": "fabric-events-interaction-v0/src/main/java/net/fabricmc/fabric/api/event/player/BlockBreakEvents.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.event.player;\n+\n+import net.minecraft.block.BlockState;\n+import net.minecraft.block.entity.BlockEntity;\n+import net.minecraft.entity.player.PlayerEntity;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.world.World;\n+\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+\n+public final class BlockBreakEvents {\n+\tprivate BlockBreakEvents() { }\n+\n+\t/**\n+\t * Callback before a block is broken.\n+\t * Only called on the server, however updates are synced with the client.\n+\t *\n+\t * <p>If any listener cancels a block breaking action, that block breaking\n+\t * action is cancelled and {@link CANCEL} event is fired. Otherwise, the\n+\t * {@link AFTER} event is fired.</p>\n+\t */\n+\tpublic static final Event<Before> BEFORE = EventFactory.createArrayBacked(Before.class,\n+\t\t\t(listeners) -> (world, player, pos, state, entity) -> {\n+\t\t\t\tfor (Before event : listeners) {\n+\t\t\t\t\tboolean result = event.beforeBlockBreak(world, player, pos, state, entity);\n+\n+\t\t\t\t\tif (!result) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t);\n+\n+\t/**\n+\t * Callback after a block is broken.\n+\t * \n+\t * <p>Called on the Server only.</p>\n+\t */\n+\tpublic static final Event<After> AFTER = EventFactory.createArrayBacked(After.class,\n+\t\t\t(listeners) -> (world, player, pos, state, entity) -> {\n+\t\t\t\tfor (After event : listeners) {\n+\t\t\t\t\tevent.afterBlockBreak(world, player, pos, state, entity);\n+\t\t\t\t}\n+\t\t\t}\n+\t);\n+\n+\t/**\n+\t * Callback when a block break has been canceled.\n+\t * ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49039a3c83cd696b02cbcc6120a83dd194b20749"}, "originalPosition": 68}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMTgyNzIw", "url": "https://github.com/FabricMC/fabric/pull/980#pullrequestreview-461182720", "createdAt": "2020-08-04T21:19:31Z", "commit": {"oid": "8df6d36e2a57987499863b9343f9fb659e20a9c8"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "da0c4f43b351eb40bbd9131c5591b4b33a9cc7be", "author": {"user": {"login": "Geometrically", "name": "Geometrically"}}, "url": "https://github.com/FabricMC/fabric/commit/da0c4f43b351eb40bbd9131c5591b4b33a9cc7be", "committedDate": "2020-08-05T19:55:54Z", "message": "Rename stuff"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxOTg3MDIy", "url": "https://github.com/FabricMC/fabric/pull/980#pullrequestreview-461987022", "createdAt": "2020-08-05T20:09:38Z", "commit": {"oid": "da0c4f43b351eb40bbd9131c5591b4b33a9cc7be"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYyNzY2Nzcw", "url": "https://github.com/FabricMC/fabric/pull/980#pullrequestreview-462766770", "createdAt": "2020-08-06T18:18:15Z", "commit": {"oid": "da0c4f43b351eb40bbd9131c5591b4b33a9cc7be"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxODoxODoxNVrOG8_BuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxODoyNjowOFrOG8_SsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYwMDM3Ng==", "bodyText": "Wouldn't it be more useful to provide the state of the block that was broken as anyone who wants to query the currently state can get it from the world.\nOr is this a mistake in javadoc as the the state from impl seems to be from local capture", "url": "https://github.com/FabricMC/fabric/pull/980#discussion_r466600376", "createdAt": "2020-08-06T18:18:15Z", "author": {"login": "i509VCB"}, "path": "fabric-events-interaction-v0/src/main/java/net/fabricmc/fabric/api/event/player/PlayerBlockBreakEvents.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.event.player;\n+\n+import net.minecraft.block.BlockState;\n+import net.minecraft.block.entity.BlockEntity;\n+import net.minecraft.entity.player.PlayerEntity;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.world.World;\n+\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+\n+public final class PlayerBlockBreakEvents {\n+\tprivate PlayerBlockBreakEvents() { }\n+\n+\t/**\n+\t * Callback before a block is broken.\n+\t * Only called on the server, however updates are synced with the client.\n+\t *\n+\t * <p>If any listener cancels a block breaking action, that block breaking\n+\t * action is cancelled and {@link CANCELED} event is fired. Otherwise, the\n+\t * {@link AFTER} event is fired.</p>\n+\t */\n+\tpublic static final Event<Before> BEFORE = EventFactory.createArrayBacked(Before.class,\n+\t\t\t(listeners) -> (world, player, pos, state, entity) -> {\n+\t\t\t\tfor (Before event : listeners) {\n+\t\t\t\t\tboolean result = event.beforeBlockBreak(world, player, pos, state, entity);\n+\n+\t\t\t\t\tif (!result) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t);\n+\n+\t/**\n+\t * Callback after a block is broken.\n+\t *\n+\t * <p>Called on the Server only.</p>\n+\t */\n+\tpublic static final Event<After> AFTER = EventFactory.createArrayBacked(After.class,\n+\t\t\t(listeners) -> (world, player, pos, state, entity) -> {\n+\t\t\t\tfor (After event : listeners) {\n+\t\t\t\t\tevent.afterBlockBreak(world, player, pos, state, entity);\n+\t\t\t\t}\n+\t\t\t}\n+\t);\n+\n+\t/**\n+\t * Callback when a block break has been canceled.\n+\t *\n+\t * <p>Called on the logical server only. May be used to send packets to revert client-side block changes.</p>\n+\t */\n+\tpublic static final Event<Canceled> CANCELED = EventFactory.createArrayBacked(Canceled.class,\n+\t\t\t(listeners) -> (world, player, pos, state, entity) -> {\n+\t\t\t\tfor (Canceled event : listeners) {\n+\t\t\t\t\tevent.onBlockBreakCancel(world, player, pos, state, entity);\n+\t\t\t\t}\n+\t\t\t}\n+\t);\n+\n+\t@FunctionalInterface\n+\tpublic interface Before {\n+\t\t/**\n+\t\t * Called before a block is broken and allows cancelling the block breaking.\n+\t\t *\n+\t\t * <p>Implementations should not modify the world or assume the block break has completed or failed.</p>\n+\t\t *\n+\t\t * @param world the world in which the block is broken\n+\t\t * @param player the player breaking the block\n+\t\t * @param pos the position at which the block is broken\n+\t\t * @param state the block state <strong>before</strong> the block is broken\n+\t\t * @param entity the block entity <strong>before</strong> the block is broken, can be {@code null}\n+\t\t * @return {@code false} to cancel block breaking action, or {@code true} to pass to next listener\n+\t\t */\n+\t\tboolean beforeBlockBreak(World world, PlayerEntity player, BlockPos pos, BlockState state, /* Nullable */ BlockEntity entity);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface After {\n+\t\t/**\n+\t\t * Called after a block is successfully broken.\n+\t\t *\n+\t\t * @param world the world where the block was broken\n+\t\t * @param player the player who broke the block\n+\t\t * @param pos the position where the block was broken\n+\t\t * @param state the block state <strong>after</strong> the block was broken", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da0c4f43b351eb40bbd9131c5591b4b33a9cc7be"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYwMjM5MQ==", "bodyText": "Parameter should be blockEntity  on all of these methods", "url": "https://github.com/FabricMC/fabric/pull/980#discussion_r466602391", "createdAt": "2020-08-06T18:22:03Z", "author": {"login": "i509VCB"}, "path": "fabric-events-interaction-v0/src/main/java/net/fabricmc/fabric/api/event/player/PlayerBlockBreakEvents.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.event.player;\n+\n+import net.minecraft.block.BlockState;\n+import net.minecraft.block.entity.BlockEntity;\n+import net.minecraft.entity.player.PlayerEntity;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.world.World;\n+\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+\n+public final class PlayerBlockBreakEvents {\n+\tprivate PlayerBlockBreakEvents() { }\n+\n+\t/**\n+\t * Callback before a block is broken.\n+\t * Only called on the server, however updates are synced with the client.\n+\t *\n+\t * <p>If any listener cancels a block breaking action, that block breaking\n+\t * action is cancelled and {@link CANCELED} event is fired. Otherwise, the\n+\t * {@link AFTER} event is fired.</p>\n+\t */\n+\tpublic static final Event<Before> BEFORE = EventFactory.createArrayBacked(Before.class,\n+\t\t\t(listeners) -> (world, player, pos, state, entity) -> {\n+\t\t\t\tfor (Before event : listeners) {\n+\t\t\t\t\tboolean result = event.beforeBlockBreak(world, player, pos, state, entity);\n+\n+\t\t\t\t\tif (!result) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t);\n+\n+\t/**\n+\t * Callback after a block is broken.\n+\t *\n+\t * <p>Called on the Server only.</p>\n+\t */\n+\tpublic static final Event<After> AFTER = EventFactory.createArrayBacked(After.class,\n+\t\t\t(listeners) -> (world, player, pos, state, entity) -> {\n+\t\t\t\tfor (After event : listeners) {\n+\t\t\t\t\tevent.afterBlockBreak(world, player, pos, state, entity);\n+\t\t\t\t}\n+\t\t\t}\n+\t);\n+\n+\t/**\n+\t * Callback when a block break has been canceled.\n+\t *\n+\t * <p>Called on the logical server only. May be used to send packets to revert client-side block changes.</p>\n+\t */\n+\tpublic static final Event<Canceled> CANCELED = EventFactory.createArrayBacked(Canceled.class,\n+\t\t\t(listeners) -> (world, player, pos, state, entity) -> {\n+\t\t\t\tfor (Canceled event : listeners) {\n+\t\t\t\t\tevent.onBlockBreakCancel(world, player, pos, state, entity);\n+\t\t\t\t}\n+\t\t\t}\n+\t);\n+\n+\t@FunctionalInterface\n+\tpublic interface Before {\n+\t\t/**\n+\t\t * Called before a block is broken and allows cancelling the block breaking.\n+\t\t *\n+\t\t * <p>Implementations should not modify the world or assume the block break has completed or failed.</p>\n+\t\t *\n+\t\t * @param world the world in which the block is broken\n+\t\t * @param player the player breaking the block\n+\t\t * @param pos the position at which the block is broken\n+\t\t * @param state the block state <strong>before</strong> the block is broken\n+\t\t * @param entity the block entity <strong>before</strong> the block is broken, can be {@code null}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da0c4f43b351eb40bbd9131c5591b4b33a9cc7be"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYwMzA1NQ==", "bodyText": "Geo, you need to still explain why the packets are sent if the event is canclled.", "url": "https://github.com/FabricMC/fabric/pull/980#discussion_r466603055", "createdAt": "2020-08-06T18:23:10Z", "author": {"login": "i509VCB"}, "path": "fabric-events-interaction-v0/src/main/java/net/fabricmc/fabric/mixin/event/interaction/MixinServerPlayerInteractionManager.java", "diffHunk": "@@ -81,4 +86,30 @@ public void interactItem(ServerPlayerEntity player, World world, ItemStack stack\n \t\t\treturn;\n \t\t}\n \t}\n+\n+\t@Inject(at = @At(value = \"INVOKE\", target = \"Lnet/minecraft/block/Block;onBreak(Lnet/minecraft/world/World;Lnet/minecraft/util/math/BlockPos;Lnet/minecraft/block/BlockState;Lnet/minecraft/entity/player/PlayerEntity;)V\"), method = \"tryBreakBlock\", locals = LocalCapture.CAPTURE_FAILHARD, cancellable = true)\n+\tprivate void breakBlock(BlockPos pos, CallbackInfoReturnable<Boolean> cir, BlockState state, BlockEntity entity, Block block) {\n+\t\tActionResult result = BlockBreakEvents.BEFORE.invoker().beforeBlockBreak(this.world, this.player, pos, state, entity);\n+\n+\t\tif (result == ActionResult.FAIL) {\n+\t\t\tBlockBreakEvents.CANCEL.invoker().onBlockBreakCancel(this.world, this.player, pos, state, entity);\n+\n+\t\t\tBlockPos cornerPos = pos.add(-1, -1, -1);\n+\n+\t\t\tfor (int x = 0; x < 3; x++) {\n+\t\t\t\tfor (int y = 0; y < 3; y++) {\n+\t\t\t\t\tfor (int z = 0; z < 3; z++) {\n+\t\t\t\t\t\tthis.player.networkHandler.sendPacket(new BlockUpdateS2CPacket(world, cornerPos.add(x, y, z)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU5MjE4Ng=="}, "originalCommit": {"oid": "2d81e83a379aa66281bca815a9c7493c363f7baa"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYwMzkyMg==", "bodyText": "Since the cancel event is fired first before the normal vanilla packet, wouldn't this cause a double update on some blocks?\nMaybe only call vanilla logic if the result of cancel even explicitly says to fallback to vanilla logic (likely true return value).", "url": "https://github.com/FabricMC/fabric/pull/980#discussion_r466603922", "createdAt": "2020-08-06T18:24:45Z", "author": {"login": "i509VCB"}, "path": "fabric-events-interaction-v0/src/main/java/net/fabricmc/fabric/mixin/event/interaction/MixinServerPlayerInteractionManager.java", "diffHunk": "@@ -81,4 +86,30 @@ public void interactItem(ServerPlayerEntity player, World world, ItemStack stack\n \t\t\treturn;\n \t\t}\n \t}\n+\n+\t@Inject(at = @At(value = \"INVOKE\", target = \"Lnet/minecraft/block/Block;onBreak(Lnet/minecraft/world/World;Lnet/minecraft/util/math/BlockPos;Lnet/minecraft/block/BlockState;Lnet/minecraft/entity/player/PlayerEntity;)V\"), method = \"tryBreakBlock\", locals = LocalCapture.CAPTURE_FAILHARD, cancellable = true)\n+\tprivate void breakBlock(BlockPos pos, CallbackInfoReturnable<Boolean> cir, BlockState state, BlockEntity entity, Block block) {\n+\t\tboolean result = PlayerBlockBreakEvents.BEFORE.invoker().beforeBlockBreak(this.world, this.player, pos, state, entity);\n+\n+\t\tif (!result) {\n+\t\t\tPlayerBlockBreakEvents.CANCELED.invoker().onBlockBreakCancel(this.world, this.player, pos, state, entity);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da0c4f43b351eb40bbd9131c5591b4b33a9cc7be"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYwNDcyMA==", "bodyText": "I'd argue this should be named PlayerBreakBlockTests since we can introduce more entrypoints for future events.", "url": "https://github.com/FabricMC/fabric/pull/980#discussion_r466604720", "createdAt": "2020-08-06T18:26:08Z", "author": {"login": "i509VCB"}, "path": "fabric-events-interaction-v0/src/testmod/java/net/fabricmc/fabric/test/event/interaction/InteractionEventsTest.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.test.event.interaction;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import net.minecraft.block.Blocks;\n+\n+import net.fabricmc.api.ModInitializer;\n+import net.fabricmc.fabric.api.event.player.PlayerBlockBreakEvents;\n+\n+public class InteractionEventsTest implements ModInitializer {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da0c4f43b351eb40bbd9131c5591b4b33a9cc7be"}, "originalPosition": 27}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d95bb88eb184b0c811295b1052f969c89e8440e5", "author": {"user": {"login": "Geometrically", "name": "Geometrically"}}, "url": "https://github.com/FabricMC/fabric/commit/d95bb88eb184b0c811295b1052f969c89e8440e5", "committedDate": "2020-08-07T15:43:37Z", "message": "fixes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzOTIyMDkw", "url": "https://github.com/FabricMC/fabric/pull/980#pullrequestreview-463922090", "createdAt": "2020-08-10T01:04:35Z", "commit": {"oid": "d95bb88eb184b0c811295b1052f969c89e8440e5"}, "state": "APPROVED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQwMTowNDozNVrOG9_PfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQwMTowNjozM1rOG9_QUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY1MjQ3Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * <p>Called on the Server only.</p>\n          \n          \n            \n            \t * <p>Only called on a logical server.\n          \n      \n    \n    \n  \n\nYou can omit the closing </p> in the style but it isn't required of course", "url": "https://github.com/FabricMC/fabric/pull/980#discussion_r467652477", "createdAt": "2020-08-10T01:04:35Z", "author": {"login": "i509VCB"}, "path": "fabric-events-interaction-v0/src/main/java/net/fabricmc/fabric/api/event/player/PlayerBlockBreakEvents.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.event.player;\n+\n+import net.minecraft.block.BlockState;\n+import net.minecraft.block.entity.BlockEntity;\n+import net.minecraft.entity.player.PlayerEntity;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.world.World;\n+\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+\n+public final class PlayerBlockBreakEvents {\n+\tprivate PlayerBlockBreakEvents() { }\n+\n+\t/**\n+\t * Callback before a block is broken.\n+\t * Only called on the server, however updates are synced with the client.\n+\t *\n+\t * <p>If any listener cancels a block breaking action, that block breaking\n+\t * action is cancelled and {@link CANCELED} event is fired. Otherwise, the\n+\t * {@link AFTER} event is fired.</p>\n+\t */\n+\tpublic static final Event<Before> BEFORE = EventFactory.createArrayBacked(Before.class,\n+\t\t\t(listeners) -> (world, player, pos, state, entity) -> {\n+\t\t\t\tfor (Before event : listeners) {\n+\t\t\t\t\tboolean result = event.beforeBlockBreak(world, player, pos, state, entity);\n+\n+\t\t\t\t\tif (!result) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t);\n+\n+\t/**\n+\t * Callback after a block is broken.\n+\t *\n+\t * <p>Called on the Server only.</p>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d95bb88eb184b0c811295b1052f969c89e8440e5"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY1MjUzNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * <p>Called on the logical server only. May be used to send packets to revert client-side block changes.</p>\n          \n          \n            \n            \t * <p>Only called on a logical server. May be used to send packets to revert client-side block changes.", "url": "https://github.com/FabricMC/fabric/pull/980#discussion_r467652537", "createdAt": "2020-08-10T01:05:08Z", "author": {"login": "i509VCB"}, "path": "fabric-events-interaction-v0/src/main/java/net/fabricmc/fabric/api/event/player/PlayerBlockBreakEvents.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.event.player;\n+\n+import net.minecraft.block.BlockState;\n+import net.minecraft.block.entity.BlockEntity;\n+import net.minecraft.entity.player.PlayerEntity;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.world.World;\n+\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+\n+public final class PlayerBlockBreakEvents {\n+\tprivate PlayerBlockBreakEvents() { }\n+\n+\t/**\n+\t * Callback before a block is broken.\n+\t * Only called on the server, however updates are synced with the client.\n+\t *\n+\t * <p>If any listener cancels a block breaking action, that block breaking\n+\t * action is cancelled and {@link CANCELED} event is fired. Otherwise, the\n+\t * {@link AFTER} event is fired.</p>\n+\t */\n+\tpublic static final Event<Before> BEFORE = EventFactory.createArrayBacked(Before.class,\n+\t\t\t(listeners) -> (world, player, pos, state, entity) -> {\n+\t\t\t\tfor (Before event : listeners) {\n+\t\t\t\t\tboolean result = event.beforeBlockBreak(world, player, pos, state, entity);\n+\n+\t\t\t\t\tif (!result) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t);\n+\n+\t/**\n+\t * Callback after a block is broken.\n+\t *\n+\t * <p>Called on the Server only.</p>\n+\t */\n+\tpublic static final Event<After> AFTER = EventFactory.createArrayBacked(After.class,\n+\t\t\t(listeners) -> (world, player, pos, state, entity) -> {\n+\t\t\t\tfor (After event : listeners) {\n+\t\t\t\t\tevent.afterBlockBreak(world, player, pos, state, entity);\n+\t\t\t\t}\n+\t\t\t}\n+\t);\n+\n+\t/**\n+\t * Callback when a block break has been canceled.\n+\t *\n+\t * <p>Called on the logical server only. May be used to send packets to revert client-side block changes.</p>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d95bb88eb184b0c811295b1052f969c89e8440e5"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY1MjYxNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t * @param blockEntity  entity the block entity of the block that was going to be broken, can be {@code null}\n          \n          \n            \n            \t\t * @param blockEntity the block entity of the block that was going to be broken, can be {@code null}", "url": "https://github.com/FabricMC/fabric/pull/980#discussion_r467652617", "createdAt": "2020-08-10T01:05:41Z", "author": {"login": "i509VCB"}, "path": "fabric-events-interaction-v0/src/main/java/net/fabricmc/fabric/api/event/player/PlayerBlockBreakEvents.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.event.player;\n+\n+import net.minecraft.block.BlockState;\n+import net.minecraft.block.entity.BlockEntity;\n+import net.minecraft.entity.player.PlayerEntity;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.world.World;\n+\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+\n+public final class PlayerBlockBreakEvents {\n+\tprivate PlayerBlockBreakEvents() { }\n+\n+\t/**\n+\t * Callback before a block is broken.\n+\t * Only called on the server, however updates are synced with the client.\n+\t *\n+\t * <p>If any listener cancels a block breaking action, that block breaking\n+\t * action is cancelled and {@link CANCELED} event is fired. Otherwise, the\n+\t * {@link AFTER} event is fired.</p>\n+\t */\n+\tpublic static final Event<Before> BEFORE = EventFactory.createArrayBacked(Before.class,\n+\t\t\t(listeners) -> (world, player, pos, state, entity) -> {\n+\t\t\t\tfor (Before event : listeners) {\n+\t\t\t\t\tboolean result = event.beforeBlockBreak(world, player, pos, state, entity);\n+\n+\t\t\t\t\tif (!result) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t);\n+\n+\t/**\n+\t * Callback after a block is broken.\n+\t *\n+\t * <p>Called on the Server only.</p>\n+\t */\n+\tpublic static final Event<After> AFTER = EventFactory.createArrayBacked(After.class,\n+\t\t\t(listeners) -> (world, player, pos, state, entity) -> {\n+\t\t\t\tfor (After event : listeners) {\n+\t\t\t\t\tevent.afterBlockBreak(world, player, pos, state, entity);\n+\t\t\t\t}\n+\t\t\t}\n+\t);\n+\n+\t/**\n+\t * Callback when a block break has been canceled.\n+\t *\n+\t * <p>Called on the logical server only. May be used to send packets to revert client-side block changes.</p>\n+\t */\n+\tpublic static final Event<Canceled> CANCELED = EventFactory.createArrayBacked(Canceled.class,\n+\t\t\t(listeners) -> (world, player, pos, state, entity) -> {\n+\t\t\t\tfor (Canceled event : listeners) {\n+\t\t\t\t\tevent.onBlockBreakCancel(world, player, pos, state, entity);\n+\t\t\t\t}\n+\t\t\t}\n+\t);\n+\n+\t@FunctionalInterface\n+\tpublic interface Before {\n+\t\t/**\n+\t\t * Called before a block is broken and allows cancelling the block breaking.\n+\t\t *\n+\t\t * <p>Implementations should not modify the world or assume the block break has completed or failed.</p>\n+\t\t *\n+\t\t * @param world the world in which the block is broken\n+\t\t * @param player the player breaking the block\n+\t\t * @param pos the position at which the block is broken\n+\t\t * @param state the block state <strong>before</strong> the block is broken\n+\t\t * @param blockEntity the block entity <strong>before</strong> the block is broken, can be {@code null}\n+\t\t * @return {@code false} to cancel block breaking action, or {@code true} to pass to next listener\n+\t\t */\n+\t\tboolean beforeBlockBreak(World world, PlayerEntity player, BlockPos pos, BlockState state, /* Nullable */ BlockEntity blockEntity);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface After {\n+\t\t/**\n+\t\t * Called after a block is successfully broken.\n+\t\t *\n+\t\t * @param world the world where the block was broken\n+\t\t * @param player the player who broke the block\n+\t\t * @param pos the position where the block was broken\n+\t\t * @param state the block state <strong>before</strong> the block was broken\n+\t\t * @param blockEntity the block entity of the broken block, can be {@code null}\n+\t\t */\n+\t\tvoid afterBlockBreak(World world, PlayerEntity player, BlockPos pos, BlockState state, /* Nullable */ BlockEntity blockEntity);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface Canceled {\n+\t\t/**\n+\t\t * Called when a block break has been canceled.\n+\t\t *\n+\t\t * @param world the world where the block was going to be broken\n+\t\t * @param player the player who was going to break the block\n+\t\t * @param pos the position where the block was going to be broken\n+\t\t * @param state the block state of the block that was going to be broken\n+\t\t * @param blockEntity  entity the block entity of the block that was going to be broken, can be {@code null}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d95bb88eb184b0c811295b1052f969c89e8440e5"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY1MjY5MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t* It is in a 3x3 area due to how vanilla redstone handles updates, as it considers\n          \n          \n            \n            \t\t* This covers a 3x3 area due to how vanilla redstone handles updates, as it considers", "url": "https://github.com/FabricMC/fabric/pull/980#discussion_r467652690", "createdAt": "2020-08-10T01:06:33Z", "author": {"login": "i509VCB"}, "path": "fabric-events-interaction-v0/src/main/java/net/fabricmc/fabric/impl/event/interaction/InteractionEventsRouter.java", "diffHunk": "@@ -41,5 +45,22 @@ public void onInitialize() {\n \n \t\t\treturn ActionResult.PASS;\n \t\t});\n+\n+\t\t/*\n+\t\t* This code is for telling the client that the block wasn't actually broken.\n+\t\t* It is in a 3x3 area due to how vanilla redstone handles updates, as it considers", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d95bb88eb184b0c811295b1052f969c89e8440e5"}, "originalPosition": 21}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "94437bb441fe8bd7ebe852b8560d01a9eb697d3f", "author": {"user": {"login": "Geometrically", "name": "Geometrically"}}, "url": "https://github.com/FabricMC/fabric/commit/94437bb441fe8bd7ebe852b8560d01a9eb697d3f", "committedDate": "2020-08-10T01:10:22Z", "message": "Update fabric-events-interaction-v0/src/main/java/net/fabricmc/fabric/api/event/player/PlayerBlockBreakEvents.java\n\nCo-authored-by: i509VCB <i509vcb@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7c486a335ec54dd33bc9281f291f11d1d9683c18", "author": {"user": {"login": "Geometrically", "name": "Geometrically"}}, "url": "https://github.com/FabricMC/fabric/commit/7c486a335ec54dd33bc9281f291f11d1d9683c18", "committedDate": "2020-08-10T01:10:35Z", "message": "Update fabric-events-interaction-v0/src/main/java/net/fabricmc/fabric/api/event/player/PlayerBlockBreakEvents.java\n\nCo-authored-by: i509VCB <i509vcb@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f62b978c6fec1cf526fb47b1e2b3eef0565f7ed6", "author": {"user": {"login": "Geometrically", "name": "Geometrically"}}, "url": "https://github.com/FabricMC/fabric/commit/f62b978c6fec1cf526fb47b1e2b3eef0565f7ed6", "committedDate": "2020-08-10T01:10:43Z", "message": "Update fabric-events-interaction-v0/src/main/java/net/fabricmc/fabric/impl/event/interaction/InteractionEventsRouter.java\n\nCo-authored-by: i509VCB <i509vcb@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1f752be122e0643bf89d5f2399c9d2b466f5f244", "author": {"user": {"login": "Geometrically", "name": "Geometrically"}}, "url": "https://github.com/FabricMC/fabric/commit/1f752be122e0643bf89d5f2399c9d2b466f5f244", "committedDate": "2020-08-10T01:10:59Z", "message": "Update fabric-events-interaction-v0/src/main/java/net/fabricmc/fabric/api/event/player/PlayerBlockBreakEvents.java\n\nCo-authored-by: i509VCB <i509vcb@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1NTQwODY1", "url": "https://github.com/FabricMC/fabric/pull/980#pullrequestreview-465540865", "createdAt": "2020-08-12T01:58:42Z", "commit": {"oid": "1f752be122e0643bf89d5f2399c9d2b466f5f244"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "34108255e77e11438696096b2a61c9c8655c1f9c", "author": {"user": {"login": "Geometrically", "name": "Geometrically"}}, "url": "https://github.com/FabricMC/fabric/commit/34108255e77e11438696096b2a61c9c8655c1f9c", "committedDate": "2020-08-12T03:46:49Z", "message": "Rename Canceled Event Method Name"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1NjUxMDYz", "url": "https://github.com/FabricMC/fabric/pull/980#pullrequestreview-465651063", "createdAt": "2020-08-12T07:19:37Z", "commit": {"oid": "34108255e77e11438696096b2a61c9c8655c1f9c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1NzUwODk1", "url": "https://github.com/FabricMC/fabric/pull/980#pullrequestreview-465750895", "createdAt": "2020-08-12T09:36:18Z", "commit": {"oid": "34108255e77e11438696096b2a61c9c8655c1f9c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3NTIyNzM2", "url": "https://github.com/FabricMC/fabric/pull/980#pullrequestreview-467522736", "createdAt": "2020-08-14T12:06:10Z", "commit": {"oid": "34108255e77e11438696096b2a61c9c8655c1f9c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3NjQxMjc3", "url": "https://github.com/FabricMC/fabric/pull/980#pullrequestreview-467641277", "createdAt": "2020-08-14T14:52:24Z", "commit": {"oid": "34108255e77e11438696096b2a61c9c8655c1f9c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5NDQ2MzQy", "url": "https://github.com/FabricMC/fabric/pull/980#pullrequestreview-469446342", "createdAt": "2020-08-18T13:19:18Z", "commit": {"oid": "34108255e77e11438696096b2a61c9c8655c1f9c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxODUzMTI2", "url": "https://github.com/FabricMC/fabric/pull/980#pullrequestreview-471853126", "createdAt": "2020-08-20T17:54:48Z", "commit": {"oid": "34108255e77e11438696096b2a61c9c8655c1f9c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3221, "cost": 1, "resetAt": "2021-11-01T14:20:25Z"}}}