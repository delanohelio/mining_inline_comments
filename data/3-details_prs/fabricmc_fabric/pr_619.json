{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE2NDkwMzIx", "number": 619, "title": "Lifecycle Events V1 [1.15]", "bodyText": "1.16 Sister PR is #681\nNow includes Chunk and (Block)Entity (un)load events as well.\nCreates a new module fabric-lifecycle-events-v1\nThis also creates fabric-item-api-v1 for the ItemTooltipCallback that doesn't belong in the lifecycle module.\nLegacy events have been deprecated and verified that they still work.\n(Un)Load events have been tested, but still converting them to fabric's testing format and cleaning up some of the tracking mechanism in testing.\nEdit 1:\nLifecycle events have been moved to either ServerXYZEvents or ClientXYZEvents depending on whether the event fires on a logical client or server. Note events defined in ClientXYZEvents are client only.\nRenamed Events:\n\n\nServerStartCallback -> ServerLifecycleEvents.SERVER_STARTED\n\n\nServerStopCallback -> ServerLifecycleEvents.SERVER_STOPPING\n\n\nServerTickCallback -> ServerTickEvents.END_SERVER_TICK\n\n\nWorldTickCallback: This has been split up to correspond with the logical world type.\n\nServerWorld -> ServerTickEvents.END_WORLD_TICK\nClientWorld -> ClientTickEvents.END_WORLD_TICK\n\n\n\nClientTickCallback -> ClientTickEvents.END_CLIENT_TICK\n\n\nItemTooltipCallback -> Moved to fabric-item-api-v1\n\n\nNew Events (Client & Server):\n\n\nEntity Load\n\nClientEntityEvents.LOAD_ENTITY\nServerEntityEvents.LOAD_ENTITY\n\n\n\nBlockEntity Load\n\nClientBlockEntityEvents.LOAD_BLOCK_ENTITY\nServerBlockEntityEvents.LOAD_BLOCK_ENTITY\n\n\n\nBlockEntity Unload\n\nClientBlockEntityEvents.UNLOAD_BLOCK_ENTITY\nServerBlockEntityEvents.UNLOAD_BLOCK_ENTITY\n\n\n\nChunk Load\n\nClientChunkEvents.LOAD_CHUNK\nServerChunkEvents.LOAD_CHUNK\n\n\n\nChunk Unload\n\nClientChunkEvents.UNLOAD_CHUNK\nServerChunkEvents.UNLOAD_CHUNK\n\n\n\nTicking\n\nClientTickEvents.START_CLIENT_TICK\nClientTickEvents.START_WORLD_TICK\n\n\n\nNew Events (Server)\n\n\nServer Stopped\n\nServerLifecycleEvents.SERVER_STOPPED (Called the instant after the server has completely stopped. This is the last event called on a dedicated server before the process closes.)\n\n\n\nTicking\n\nServerTickEvents.START_SERVER_TICK\nServerTickEvents.START_WORLD_TICK\n\n\n\nNew Events (Client)\n\nClientEntityEvents.UNLOAD_ENTITY (This is client only since tracking entity unloads on a server is too unreliable).\nClientLifecycleEvents.CLIENT_STARTED (Called when the client is about to tick for the first time)\nClientLifecycleEvents.CLIENT_STOPPING (Called when the client begins to stop. (Called before the client's player is disconnected if in game))\n\nA few more thing to do:\n- Add tick events to correspond to the beginning of a tick on a client, server and world\n- Docs. Lots of them", "createdAt": "2020-05-12T05:15:00Z", "url": "https://github.com/FabricMC/fabric/pull/619", "merged": true, "mergeCommit": {"oid": "2f23104bdd45dd034f584a7bb7d26b1e9fd32b36"}, "closed": true, "closedAt": "2020-06-25T21:28:50Z", "author": {"login": "i509VCB"}, "timelineItems": {"totalCount": 52, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcge1nBAFqTQwOTc1NDc1OQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcsjClZgFqTQzMzU0OTQzMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA5NzU0NzU5", "url": "https://github.com/FabricMC/fabric/pull/619#pullrequestreview-409754759", "createdAt": "2020-05-12T07:07:11Z", "commit": {"oid": "f4bfead302a597dc0caba69f9e8f2d62f3218e9e"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwNzowNzoxMVrOGT43sA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwNzowNzoxMVrOGT43sA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwNzg4OA==", "bodyText": "Should we still have this in its own separate EVENT class, since it looks like we're going in the direction of having classes that define lots of different events?", "url": "https://github.com/FabricMC/fabric/pull/619#discussion_r423507888", "createdAt": "2020-05-12T07:07:11Z", "author": {"login": "LemmaEOF"}, "path": "fabric-generic-events-v1/src/main/java/net/fabricmc/fabric/api/client/event/generic/v1/item/ItemTooltipCallback.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.client.event.generic.v1.item;\n+\n+import java.util.List;\n+\n+import net.minecraft.client.item.TooltipContext;\n+import net.minecraft.item.ItemStack;\n+import net.minecraft.text.Text;\n+\n+import net.fabricmc.api.EnvType;\n+import net.fabricmc.api.Environment;\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+\n+@Environment(EnvType.CLIENT)\n+public interface ItemTooltipCallback {\n+\t/**\n+\t * Fired after the game has appended all base tooltip lines to the list.\n+\t */\n+\tEvent<ItemTooltipCallback> EVENT = EventFactory.createArrayBacked(ItemTooltipCallback.class, callbacks -> (stack, context, lines) -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4bfead302a597dc0caba69f9e8f2d62f3218e9e"}, "originalPosition": 35}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA5ODIxOTg3", "url": "https://github.com/FabricMC/fabric/pull/619#pullrequestreview-409821987", "createdAt": "2020-05-12T08:38:16Z", "commit": {"oid": "f4bfead302a597dc0caba69f9e8f2d62f3218e9e"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwODozODoxNlrOGT8Igg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwODo0Nzo1MFrOGT8h2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU2MTM0Ng==", "bodyText": "Imo for that you can do EntityUnloadCallback and ClientEvents.ENTITY_UNLOAD where\nEntityUnloadCallback ENTITY_UNLOAD = EventFactory.createArrayBacked(xxx); in ClientEvents class", "url": "https://github.com/FabricMC/fabric/pull/619#discussion_r423561346", "createdAt": "2020-05-12T08:38:16Z", "author": {"login": "liach"}, "path": "fabric-generic-events-v1/src/main/java/net/fabricmc/fabric/api/client/event/generic/v1/item/ItemTooltipCallback.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.client.event.generic.v1.item;\n+\n+import java.util.List;\n+\n+import net.minecraft.client.item.TooltipContext;\n+import net.minecraft.item.ItemStack;\n+import net.minecraft.text.Text;\n+\n+import net.fabricmc.api.EnvType;\n+import net.fabricmc.api.Environment;\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+\n+@Environment(EnvType.CLIENT)\n+public interface ItemTooltipCallback {\n+\t/**\n+\t * Fired after the game has appended all base tooltip lines to the list.\n+\t */\n+\tEvent<ItemTooltipCallback> EVENT = EventFactory.createArrayBacked(ItemTooltipCallback.class, callbacks -> (stack, context, lines) -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwNzg4OA=="}, "originalCommit": {"oid": "f4bfead302a597dc0caba69f9e8f2d62f3218e9e"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU2MTc2Mg==", "bodyText": "Also how is this a \"generic event\"?", "url": "https://github.com/FabricMC/fabric/pull/619#discussion_r423561762", "createdAt": "2020-05-12T08:38:53Z", "author": {"login": "liach"}, "path": "fabric-generic-events-v1/src/main/java/net/fabricmc/fabric/api/client/event/generic/v1/item/ItemTooltipCallback.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.client.event.generic.v1.item;\n+\n+import java.util.List;\n+\n+import net.minecraft.client.item.TooltipContext;\n+import net.minecraft.item.ItemStack;\n+import net.minecraft.text.Text;\n+\n+import net.fabricmc.api.EnvType;\n+import net.fabricmc.api.Environment;\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+\n+@Environment(EnvType.CLIENT)\n+public interface ItemTooltipCallback {\n+\t/**\n+\t * Fired after the game has appended all base tooltip lines to the list.\n+\t */\n+\tEvent<ItemTooltipCallback> EVENT = EventFactory.createArrayBacked(ItemTooltipCallback.class, callbacks -> (stack, context, lines) -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwNzg4OA=="}, "originalCommit": {"oid": "f4bfead302a597dc0caba69f9e8f2d62f3218e9e"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU2MjYzMg==", "bodyText": "any point of getting the profiler before the profiler enabled check?", "url": "https://github.com/FabricMC/fabric/pull/619#discussion_r423562632", "createdAt": "2020-05-12T08:40:07Z", "author": {"login": "liach"}, "path": "fabric-lifecycle-events-v1/src/main/java/net/fabricmc/fabric/api/client/event/lifecycle/v1/ClientLifecycleEvents.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.client.event.lifecycle.v1;\n+\n+import net.minecraft.client.MinecraftClient;\n+import net.minecraft.client.world.ClientWorld;\n+import net.minecraft.util.profiler.Profiler;\n+\n+import net.fabricmc.api.EnvType;\n+import net.fabricmc.api.Environment;\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.GameTickCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.block.entity.BlockEntityLoadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.block.entity.BlockEntityUnloadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.chunk.ChunkLoadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.chunk.ChunkUnloadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.entity.EntityLoadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.entity.EntityUnloadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.world.WorldTickCallback;\n+\n+@Environment(EnvType.CLIENT)\n+public final class ClientLifecycleEvents {\n+\tprivate ClientLifecycleEvents() {\n+\t}\n+\n+\tpublic static final Event<GameTickCallback<MinecraftClient>> CLIENT_TICK = EventFactory.createArrayBacked(GameTickCallback.class, callbacks -> client -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = client.getProfiler();\n+\t\t\tprofiler.push(\"fabricServerTick\");\n+\n+\t\t\tfor (GameTickCallback<MinecraftClient> event : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(event));\n+\t\t\t\tevent.onTick(client);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (GameTickCallback<MinecraftClient> event : callbacks) {\n+\t\t\t\tevent.onTick(client);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\tpublic static final Event<WorldTickCallback<ClientWorld>> WORLD_TICK = EventFactory.createArrayBacked(WorldTickCallback.class, callbacks -> world -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = world.getProfiler();\n+\t\t\tprofiler.push(\"fabricClientWorldTick\");\n+\n+\t\t\tfor (WorldTickCallback<ClientWorld> callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.onTick(world);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (WorldTickCallback<ClientWorld> callback : callbacks) {\n+\t\t\t\tcallback.onTick(world);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\tpublic static final Event<ChunkLoadCallback<ClientWorld>> CHUNK_LOAD = EventFactory.createArrayBacked(ChunkLoadCallback.class, callbacks -> (clientWorld, chunk) -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tProfiler profiler = clientWorld.getProfiler();\n+\t\t\tprofiler.push(\"fabricClientChunkLoad\");\n+\n+\t\t\tfor (ChunkLoadCallback<ClientWorld> callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.onChunkLoad(clientWorld, chunk);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (ChunkLoadCallback<ClientWorld> callback : callbacks) {\n+\t\t\t\tcallback.onChunkLoad(clientWorld, chunk);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\tpublic static final Event<ChunkUnloadCallback<ClientWorld>> CHUNK_UNLOAD = EventFactory.createArrayBacked(ChunkUnloadCallback.class, callbacks -> (clientWorld, chunk) -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tProfiler profiler = clientWorld.getProfiler();\n+\t\t\tprofiler.push(\"fabricClientChunkUnload\");\n+\n+\t\t\tfor (ChunkUnloadCallback<ClientWorld> callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.onChunkUnload(clientWorld, chunk);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (ChunkUnloadCallback<ClientWorld> callback : callbacks) {\n+\t\t\t\tcallback.onChunkUnload(clientWorld, chunk);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\tpublic static final Event<BlockEntityLoadCallback<ClientWorld>> BLOCK_ENTITY_LOAD = EventFactory.createArrayBacked(BlockEntityLoadCallback.class, callbacks -> (blockEntity, world) -> {\n+\t\tfinal Profiler profiler = world.getProfiler();\n+\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tprofiler.push(\"fabricClientBlockEntityLoad\");\n+\n+\t\t\tfor (BlockEntityLoadCallback<ClientWorld> callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.onLoadBlockEntity(blockEntity, world);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (BlockEntityLoadCallback<ClientWorld> callback : callbacks) {\n+\t\t\t\tcallback.onLoadBlockEntity(blockEntity, world);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\tpublic static final Event<BlockEntityUnloadCallback<ClientWorld>> BLOCK_ENTITY_UNLOAD = EventFactory.createArrayBacked(BlockEntityUnloadCallback.class, callbacks -> (blockEntity, world) -> {\n+\t\tfinal Profiler profiler = world.getProfiler();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4bfead302a597dc0caba69f9e8f2d62f3218e9e"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU2MzAyMQ==", "bodyText": "yes, you do it like this, only get profiler after the isProfilingEnabled check", "url": "https://github.com/FabricMC/fabric/pull/619#discussion_r423563021", "createdAt": "2020-05-12T08:40:41Z", "author": {"login": "liach"}, "path": "fabric-lifecycle-events-v1/src/main/java/net/fabricmc/fabric/api/event/lifecycle/v1/ServerLifecycleEvents.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.event.lifecycle.v1;\n+\n+import net.minecraft.server.MinecraftServer;\n+import net.minecraft.server.world.ServerWorld;\n+import net.minecraft.util.profiler.Profiler;\n+\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.block.entity.BlockEntityLoadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.block.entity.BlockEntityUnloadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.chunk.ChunkLoadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.chunk.ChunkUnloadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.entity.EntityLoadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.entity.EntityUnloadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.world.WorldTickCallback;\n+\n+public final class ServerLifecycleEvents {\n+\tprivate ServerLifecycleEvents() {\n+\t}\n+\n+\tpublic static final Event<GameTickCallback<MinecraftServer>> SERVER_TICK = EventFactory.createArrayBacked(GameTickCallback.class, callbacks -> server -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = server.getProfiler();\n+\t\t\tprofiler.push(\"fabricServerTick\");\n+\n+\t\t\tfor (GameTickCallback<MinecraftServer> event : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(event));\n+\t\t\t\tevent.onTick(server);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (GameTickCallback<MinecraftServer> event : callbacks) {\n+\t\t\t\tevent.onTick(server);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\tpublic static final Event<WorldTickCallback<ServerWorld>> WORLD_TICK = EventFactory.createArrayBacked(WorldTickCallback.class, callbacks -> world -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = world.getProfiler();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4bfead302a597dc0caba69f9e8f2d62f3218e9e"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU2NzgzNA==", "bodyText": "Maybe lifecycle?", "url": "https://github.com/FabricMC/fabric/pull/619#discussion_r423567834", "createdAt": "2020-05-12T08:47:50Z", "author": {"login": "liach"}, "path": "fabric-lifecycle-events-v1/src/main/java/net/fabricmc/fabric/api/event/lifecycle/v1/ServerLifecycleCallback.java", "diffHunk": "@@ -0,0 +1,26 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.event.lifecycle.v1;\n+\n+import net.minecraft.server.MinecraftServer;\n+\n+/**\n+ * A callback which is invoked when the server advances in it's lifecycle.\n+ */\n+public interface ServerLifecycleCallback {\n+\tvoid onChangeLifecycle(MinecraftServer server);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4bfead302a597dc0caba69f9e8f2d62f3218e9e"}, "originalPosition": 25}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEwMjc0NjAw", "url": "https://github.com/FabricMC/fabric/pull/619#pullrequestreview-410274600", "createdAt": "2020-05-12T17:39:18Z", "commit": {"oid": "f4bfead302a597dc0caba69f9e8f2d62f3218e9e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxNzozOToxOVrOGURvwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxNzozOToxOVrOGURvwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzkxNTQ1Ng==", "bodyText": "do we already tick twice per tick for worlds? once for server and once for client?", "url": "https://github.com/FabricMC/fabric/pull/619#discussion_r423915456", "createdAt": "2020-05-12T17:39:19Z", "author": {"login": "shedaniel"}, "path": "fabric-events-lifecycle-v0/src/main/java/net/fabricmc/fabric/impl/event/lifecycle/client/LegacyClientEventInvokers.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.impl.event.lifecycle.client;\n+\n+import net.fabricmc.api.ClientModInitializer;\n+import net.fabricmc.fabric.api.event.client.ClientTickCallback;\n+import net.fabricmc.fabric.api.event.client.ItemTooltipCallback;\n+import net.fabricmc.fabric.api.event.world.WorldTickCallback;\n+import net.fabricmc.fabric.api.client.event.lifecycle.v1.ClientLifecycleEvents;\n+\n+public class LegacyClientEventInvokers implements ClientModInitializer {\n+\t@Override\n+\tpublic void onInitializeClient() {\n+\t\t// Allows deprecated events to still be invoked by the newer implementations\n+\t\tClientLifecycleEvents.CLIENT_TICK.register(ClientTickCallback.EVENT.invoker()::tick);\n+\t\tClientLifecycleEvents.WORLD_TICK.register(WorldTickCallback.EVENT.invoker()::tick);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4bfead302a597dc0caba69f9e8f2d62f3218e9e"}, "originalPosition": 30}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEwMjY1OTYz", "url": "https://github.com/FabricMC/fabric/pull/619#pullrequestreview-410265963", "createdAt": "2020-05-12T17:28:23Z", "commit": {"oid": "f4bfead302a597dc0caba69f9e8f2d62f3218e9e"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxNzoyODoyM1rOGURU_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxNzo0MjowNlrOGUR2Rg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzkwODYwNw==", "bodyText": "The invokers of all of the above legacy events are being captured here, which is invalid. That is, for each event here, the value of EVENT.invoker() is only evaluated in this method, where the callback is being registered for the replacement event, and not each time the new event is invoked. The Event class allows the value of invoker() to change when new listeners are registered.\nFor the array-based events which all of fabric API uses, the invoker is updated each time a new listener is registered, which means this will fail to notify any listeners that are registered after this initializer is called.\nThis will have to be changed to evaluate the value of invoker() each time the event is called, probably with an explicit lambda instead of a method reference.", "url": "https://github.com/FabricMC/fabric/pull/619#discussion_r423908607", "createdAt": "2020-05-12T17:28:23Z", "author": {"login": "JamiesWhiteShirt"}, "path": "fabric-events-lifecycle-v0/src/main/java/net/fabricmc/fabric/impl/event/lifecycle/client/LegacyClientEventInvokers.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.impl.event.lifecycle.client;\n+\n+import net.fabricmc.api.ClientModInitializer;\n+import net.fabricmc.fabric.api.event.client.ClientTickCallback;\n+import net.fabricmc.fabric.api.event.client.ItemTooltipCallback;\n+import net.fabricmc.fabric.api.event.world.WorldTickCallback;\n+import net.fabricmc.fabric.api.client.event.lifecycle.v1.ClientLifecycleEvents;\n+\n+public class LegacyClientEventInvokers implements ClientModInitializer {\n+\t@Override\n+\tpublic void onInitializeClient() {\n+\t\t// Allows deprecated events to still be invoked by the newer implementations\n+\t\tClientLifecycleEvents.CLIENT_TICK.register(ClientTickCallback.EVENT.invoker()::tick);\n+\t\tClientLifecycleEvents.WORLD_TICK.register(WorldTickCallback.EVENT.invoker()::tick);\n+\t\t// This is part of generic events now.\n+\t\tnet.fabricmc.fabric.api.client.event.generic.v1.item.ItemTooltipCallback.EVENT.register(ItemTooltipCallback.EVENT.invoker()::getTooltip);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4bfead302a597dc0caba69f9e8f2d62f3218e9e"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzkxNzEyNg==", "bodyText": "We might want to impose a stricter order for when the SERVER_STOP and ENTITY_UNLOAD/BLOCK_ENTITY_UNLOAD events are called. Let's say a mod registers a listener for both SERVER_STOP and ENTITY_UNLOAD/BLOCK_ENTITY_UNLOAD. Depending on whether the mod gets to register its SERVER_STOP event listener before or after this listener (which may be nondeterministic), it will have its SERVER_STOP event listener called either before or after all the ENTITY_UNLOAD/BLOCK_ENTITY_UNLOAD events are invoked.\nI imagine a mod might use these events to free resources, and might want to use some server-bound resource which is freed when the SERVER_STOP event is called when entities and block entities are unloaded. Having all the entities and block entities unload before the server is unloaded would make the most sense.", "url": "https://github.com/FabricMC/fabric/pull/619#discussion_r423917126", "createdAt": "2020-05-12T17:42:06Z", "author": {"login": "JamiesWhiteShirt"}, "path": "fabric-lifecycle-events-v1/src/main/java/net/fabricmc/fabric/impl/event/lifecycle/LifecycleInternalListeners.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.impl.event.lifecycle;\n+\n+import java.util.List;\n+\n+import net.minecraft.block.entity.BlockEntity;\n+import net.minecraft.entity.Entity;\n+import net.minecraft.server.world.ServerWorld;\n+\n+import net.fabricmc.api.ModInitializer;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.ServerLifecycleEvents;\n+\n+public class LifecycleInternalListeners implements ModInitializer {\n+\t@Override\n+\tpublic void onInitialize() {\n+\t\tServerLifecycleEvents.SERVER_STOP.register(server -> {\n+\t\t\t// We use the server shutdown to unload all entities and block entities so their events are fired.\n+\t\t\tfor (ServerWorld world : server.getWorlds()) {\n+\t\t\t\tfinal List<Entity> entities = world.getEntities(null, entity -> true); // Get every single entity in the world\n+\n+\t\t\t\tfor (Entity entity : entities) {\n+\t\t\t\t\tServerLifecycleEvents.ENTITY_UNLOAD.invoker().onEntityUnload(entity, world);\n+\t\t\t\t}\n+\n+\t\t\t\tfor (BlockEntity blockEntity : world.blockEntities) {\n+\t\t\t\t\tServerLifecycleEvents.BLOCK_ENTITY_UNLOAD.invoker().onUnloadBlockEntity(blockEntity, world);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t});", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4bfead302a597dc0caba69f9e8f2d62f3218e9e"}, "originalPosition": 44}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEyMDY0ODU4", "url": "https://github.com/FabricMC/fabric/pull/619#pullrequestreview-412064858", "createdAt": "2020-05-14T18:12:02Z", "commit": {"oid": "3113d7498922655d42738f74351b02fc318ae4f9"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxODoxMjowMlrOGVoh3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxODoxMjowMlrOGVoh3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTMzNzMwOA==", "bodyText": "Gradle has a lifecycle that is like a info for logging. This current name is acceptable.", "url": "https://github.com/FabricMC/fabric/pull/619#discussion_r425337308", "createdAt": "2020-05-14T18:12:02Z", "author": {"login": "liach"}, "path": "fabric-lifecycle-events-v1/src/main/java/net/fabricmc/fabric/api/event/lifecycle/v1/ServerLifecycleCallback.java", "diffHunk": "@@ -0,0 +1,26 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.event.lifecycle.v1;\n+\n+import net.minecraft.server.MinecraftServer;\n+\n+/**\n+ * A callback which is invoked when the server advances in it's lifecycle.\n+ */\n+public interface ServerLifecycleCallback {\n+\tvoid onChangeLifecycle(MinecraftServer server);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU2NzgzNA=="}, "originalCommit": {"oid": "f4bfead302a597dc0caba69f9e8f2d62f3218e9e"}, "originalPosition": 25}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEyOTEyOTI5", "url": "https://github.com/FabricMC/fabric/pull/619#pullrequestreview-412912929", "createdAt": "2020-05-15T19:28:37Z", "commit": {"oid": "8c3997b74f3bf9498698f861320fe4c92e91ebe7"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMzgxNzgx", "url": "https://github.com/FabricMC/fabric/pull/619#pullrequestreview-421381781", "createdAt": "2020-05-30T06:05:16Z", "commit": {"oid": "7ff8f37602c3d0ef884187041fcb291c1a70687a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0ODg2Njcx", "url": "https://github.com/FabricMC/fabric/pull/619#pullrequestreview-424886671", "createdAt": "2020-06-04T22:48:33Z", "commit": {"oid": "3180af925a4e314bf325498692eac40951bb84f7"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMjo0ODozM1rOGfajOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMzoxNTozMVrOGfbEyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU5NDA0Mw==", "bodyText": "These all need more specific documentation, the various ticks all last quite a while. It may even be necessary to have separate events for start and end, e.g. end of world tick may be used to start async computations for the next tick.", "url": "https://github.com/FabricMC/fabric/pull/619#discussion_r435594043", "createdAt": "2020-06-04T22:48:33Z", "author": {"login": "sfPlayer1"}, "path": "fabric-lifecycle-events-v1/src/main/java/net/fabricmc/fabric/api/client/event/lifecycle/v1/ClientLifecycleEvents.java", "diffHunk": "@@ -0,0 +1,235 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.client.event.lifecycle.v1;\n+\n+import net.minecraft.client.MinecraftClient;\n+import net.minecraft.client.world.ClientWorld;\n+import net.minecraft.util.profiler.Profiler;\n+\n+import net.fabricmc.api.EnvType;\n+import net.fabricmc.api.Environment;\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.GameLifecycleCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.GameTickCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.block.entity.BlockEntityLoadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.block.entity.BlockEntityUnloadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.chunk.ChunkLoadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.chunk.ChunkUnloadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.entity.EntityLoadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.entity.EntityUnloadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.world.WorldTickCallback;\n+\n+@Environment(EnvType.CLIENT)\n+public final class ClientLifecycleEvents {\n+\tprivate ClientLifecycleEvents() {\n+\t}\n+\n+\t/**\n+\t * Called when a client ticks.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3180af925a4e314bf325498692eac40951bb84f7"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU5ODk1Nw==", "bodyText": "For load/unload the timing is crucial and should be explained. Ideally all load events occur after the subject has been added to the world/chunk with the world+chunk being normally usable and obtainable via MinecraftServer. This ensures that e.g. an area search can be done without fragile postponing workarounds. Unload should happen while still reachable for similar reasons.\nAdditionally, access to the de-/serialization phases would be useful such that custom data can be embedded in the vanilla nbt tree as it gets read or written. It is useful for persistent data attachments to chunk or world, e.g. to store worldgen metadata for retrogen implementations.", "url": "https://github.com/FabricMC/fabric/pull/619#discussion_r435598957", "createdAt": "2020-06-04T23:03:22Z", "author": {"login": "sfPlayer1"}, "path": "fabric-lifecycle-events-v1/src/main/java/net/fabricmc/fabric/api/client/event/lifecycle/v1/ClientLifecycleEvents.java", "diffHunk": "@@ -0,0 +1,235 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.client.event.lifecycle.v1;\n+\n+import net.minecraft.client.MinecraftClient;\n+import net.minecraft.client.world.ClientWorld;\n+import net.minecraft.util.profiler.Profiler;\n+\n+import net.fabricmc.api.EnvType;\n+import net.fabricmc.api.Environment;\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.GameLifecycleCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.GameTickCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.block.entity.BlockEntityLoadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.block.entity.BlockEntityUnloadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.chunk.ChunkLoadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.chunk.ChunkUnloadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.entity.EntityLoadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.entity.EntityUnloadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.world.WorldTickCallback;\n+\n+@Environment(EnvType.CLIENT)\n+public final class ClientLifecycleEvents {\n+\tprivate ClientLifecycleEvents() {\n+\t}\n+\n+\t/**\n+\t * Called when a client ticks.\n+\t */\n+\tpublic static final Event<GameTickCallback<MinecraftClient>> CLIENT_TICK = EventFactory.createArrayBacked(GameTickCallback.class, callbacks -> client -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = client.getProfiler();\n+\t\t\tprofiler.push(\"fabricServerTick\");\n+\n+\t\t\tfor (GameTickCallback<MinecraftClient> event : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(event));\n+\t\t\t\tevent.onTick(client);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (GameTickCallback<MinecraftClient> event : callbacks) {\n+\t\t\t\tevent.onTick(client);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when a ClientWorld ticks.\n+\t */\n+\tpublic static final Event<WorldTickCallback<ClientWorld>> WORLD_TICK = EventFactory.createArrayBacked(WorldTickCallback.class, callbacks -> world -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = world.getProfiler();\n+\t\t\tprofiler.push(\"fabricClientWorldTick\");\n+\n+\t\t\tfor (WorldTickCallback<ClientWorld> callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.onTick(world);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (WorldTickCallback<ClientWorld> callback : callbacks) {\n+\t\t\t\tcallback.onTick(world);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when a chunk is loaded into a ClientWorld.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3180af925a4e314bf325498692eac40951bb84f7"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU5OTI5NQ==", "bodyText": "These lack documentation, not sure what they are supposed to do?", "url": "https://github.com/FabricMC/fabric/pull/619#discussion_r435599295", "createdAt": "2020-06-04T23:04:24Z", "author": {"login": "sfPlayer1"}, "path": "fabric-lifecycle-events-v1/src/main/java/net/fabricmc/fabric/api/client/event/lifecycle/v1/ClientLifecycleEvents.java", "diffHunk": "@@ -0,0 +1,235 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.client.event.lifecycle.v1;\n+\n+import net.minecraft.client.MinecraftClient;\n+import net.minecraft.client.world.ClientWorld;\n+import net.minecraft.util.profiler.Profiler;\n+\n+import net.fabricmc.api.EnvType;\n+import net.fabricmc.api.Environment;\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.GameLifecycleCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.GameTickCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.block.entity.BlockEntityLoadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.block.entity.BlockEntityUnloadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.chunk.ChunkLoadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.chunk.ChunkUnloadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.entity.EntityLoadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.entity.EntityUnloadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.world.WorldTickCallback;\n+\n+@Environment(EnvType.CLIENT)\n+public final class ClientLifecycleEvents {\n+\tprivate ClientLifecycleEvents() {\n+\t}\n+\n+\t/**\n+\t * Called when a client ticks.\n+\t */\n+\tpublic static final Event<GameTickCallback<MinecraftClient>> CLIENT_TICK = EventFactory.createArrayBacked(GameTickCallback.class, callbacks -> client -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = client.getProfiler();\n+\t\t\tprofiler.push(\"fabricServerTick\");\n+\n+\t\t\tfor (GameTickCallback<MinecraftClient> event : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(event));\n+\t\t\t\tevent.onTick(client);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (GameTickCallback<MinecraftClient> event : callbacks) {\n+\t\t\t\tevent.onTick(client);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when a ClientWorld ticks.\n+\t */\n+\tpublic static final Event<WorldTickCallback<ClientWorld>> WORLD_TICK = EventFactory.createArrayBacked(WorldTickCallback.class, callbacks -> world -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = world.getProfiler();\n+\t\t\tprofiler.push(\"fabricClientWorldTick\");\n+\n+\t\t\tfor (WorldTickCallback<ClientWorld> callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.onTick(world);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (WorldTickCallback<ClientWorld> callback : callbacks) {\n+\t\t\t\tcallback.onTick(world);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when a chunk is loaded into a ClientWorld.\n+\t */\n+\tpublic static final Event<ChunkLoadCallback<ClientWorld>> CHUNK_LOAD = EventFactory.createArrayBacked(ChunkLoadCallback.class, callbacks -> (clientWorld, chunk) -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tProfiler profiler = clientWorld.getProfiler();\n+\t\t\tprofiler.push(\"fabricClientChunkLoad\");\n+\n+\t\t\tfor (ChunkLoadCallback<ClientWorld> callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.onChunkLoad(clientWorld, chunk);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (ChunkLoadCallback<ClientWorld> callback : callbacks) {\n+\t\t\t\tcallback.onChunkLoad(clientWorld, chunk);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when a chunk is unloaded from a ClientWorld.\n+\t */\n+\tpublic static final Event<ChunkUnloadCallback<ClientWorld>> CHUNK_UNLOAD = EventFactory.createArrayBacked(ChunkUnloadCallback.class, callbacks -> (clientWorld, chunk) -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = clientWorld.getProfiler();\n+\t\t\tprofiler.push(\"fabricClientChunkUnload\");\n+\n+\t\t\tfor (ChunkUnloadCallback<ClientWorld> callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.onChunkUnload(clientWorld, chunk);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (ChunkUnloadCallback<ClientWorld> callback : callbacks) {\n+\t\t\t\tcallback.onChunkUnload(clientWorld, chunk);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when a BlockEntity is loaded into a ClientWorld.\n+\t */\n+\tpublic static final Event<BlockEntityLoadCallback<ClientWorld>> BLOCK_ENTITY_LOAD = EventFactory.createArrayBacked(BlockEntityLoadCallback.class, callbacks -> (blockEntity, world) -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = world.getProfiler();\n+\t\t\tprofiler.push(\"fabricClientBlockEntityLoad\");\n+\n+\t\t\tfor (BlockEntityLoadCallback<ClientWorld> callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.onLoadBlockEntity(blockEntity, world);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (BlockEntityLoadCallback<ClientWorld> callback : callbacks) {\n+\t\t\t\tcallback.onLoadBlockEntity(blockEntity, world);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when a BlockEntity is unloaded from a ClientWorld.\n+\t */\n+\tpublic static final Event<BlockEntityUnloadCallback<ClientWorld>> BLOCK_ENTITY_UNLOAD = EventFactory.createArrayBacked(BlockEntityUnloadCallback.class, callbacks -> (blockEntity, world) -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = world.getProfiler();\n+\t\t\tprofiler.push(\"fabricClientBlockEntityUnload\");\n+\n+\t\t\tfor (BlockEntityUnloadCallback<ClientWorld> callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.onUnloadBlockEntity(blockEntity, world);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (BlockEntityUnloadCallback<ClientWorld> callback : callbacks) {\n+\t\t\t\tcallback.onUnloadBlockEntity(blockEntity, world);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when an Entity is loaded into a ClientWorld.\n+\t */\n+\tpublic static final Event<EntityLoadCallback<ClientWorld>> ENTITY_LOAD = EventFactory.createArrayBacked(EntityLoadCallback.class, callbacks -> (entity, world) -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = world.getProfiler();\n+\t\t\tprofiler.push(\"fabricClientEntityLoad\");\n+\n+\t\t\tfor (EntityLoadCallback<ClientWorld> callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.onEntityLoad(entity, world);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (EntityLoadCallback<ClientWorld> callback : callbacks) {\n+\t\t\t\tcallback.onEntityLoad(entity, world);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when an Entity is unloaded from a ClientWorld.\n+\t */\n+\tpublic static final Event<EntityUnloadCallback<ClientWorld>> ENTITY_UNLOAD = EventFactory.createArrayBacked(EntityUnloadCallback.class, callbacks -> (entity, world) -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = world.getProfiler();\n+\t\t\tprofiler.push(\"fabricClientEntityLoad\");\n+\n+\t\t\tfor (EntityUnloadCallback<ClientWorld> callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.onEntityUnload(entity, world);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (EntityUnloadCallback<ClientWorld> callback : callbacks) {\n+\t\t\t\tcallback.onEntityUnload(entity, world);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\tpublic static final Event<GameLifecycleCallback<MinecraftClient>> CLIENT_STARTING = EventFactory.createArrayBacked(GameLifecycleCallback.class, callbacks -> client -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3180af925a4e314bf325498692eac40951bb84f7"}, "originalPosition": 218}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwMDY0MA==", "bodyText": "I'd use two instances without generics for ease of use. It may be worthwhile to organize the events+callbacks differently, maybe an outer class like ClientTickEvents that holds both the event fields and callbacks as nested classes? Similar for others, ClientLifecycleEvents is getting big and the many trivial top level callback interfaces are getting a bit too spread out.", "url": "https://github.com/FabricMC/fabric/pull/619#discussion_r435600640", "createdAt": "2020-06-04T23:08:53Z", "author": {"login": "sfPlayer1"}, "path": "fabric-lifecycle-events-v1/src/main/java/net/fabricmc/fabric/api/event/lifecycle/v1/GameLifecycleCallback.java", "diffHunk": "@@ -0,0 +1,24 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.event.lifecycle.v1;\n+\n+/**\n+ * A callback which is invoked when the game's engine advances in it's lifecycle.\n+ */\n+public interface GameLifecycleCallback<T> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3180af925a4e314bf325498692eac40951bb84f7"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwMTAxNQ==", "bodyText": "Same with this generic parameter, also avoids implementing e.g. chunk+world tick handlers in the same class.", "url": "https://github.com/FabricMC/fabric/pull/619#discussion_r435601015", "createdAt": "2020-06-04T23:10:09Z", "author": {"login": "sfPlayer1"}, "path": "fabric-lifecycle-events-v1/src/main/java/net/fabricmc/fabric/api/event/lifecycle/v1/GameTickCallback.java", "diffHunk": "@@ -0,0 +1,21 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.event.lifecycle.v1;\n+\n+public interface GameTickCallback<T> {\n+\tvoid onTick(T game);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3180af925a4e314bf325498692eac40951bb84f7"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwMTM1Mw==", "bodyText": "\".. and it is about to tick for the first time\" maybe? assuming that's correct?", "url": "https://github.com/FabricMC/fabric/pull/619#discussion_r435601353", "createdAt": "2020-06-04T23:11:11Z", "author": {"login": "sfPlayer1"}, "path": "fabric-lifecycle-events-v1/src/main/java/net/fabricmc/fabric/api/event/lifecycle/v1/ServerLifecycleEvents.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.event.lifecycle.v1;\n+\n+import net.minecraft.server.MinecraftServer;\n+import net.minecraft.server.world.ServerWorld;\n+import net.minecraft.util.profiler.Profiler;\n+\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.block.entity.BlockEntityLoadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.block.entity.BlockEntityUnloadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.chunk.ChunkLoadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.chunk.ChunkUnloadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.entity.EntityLoadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.world.WorldTickCallback;\n+import net.fabricmc.fabric.impl.lifecycle.ServerLifecycleInternals;\n+\n+public final class ServerLifecycleEvents {\n+\tprivate ServerLifecycleEvents() {\n+\t}\n+\n+\t/**\n+\t * Called when a server ticks.\n+\t */\n+\tpublic static final Event<GameTickCallback<MinecraftServer>> SERVER_TICK = EventFactory.createArrayBacked(GameTickCallback.class, callbacks -> server -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = server.getProfiler();\n+\t\t\tprofiler.push(\"fabricServerTick\");\n+\n+\t\t\tfor (GameTickCallback<MinecraftServer> event : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(event));\n+\t\t\t\tevent.onTick(server);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (GameTickCallback<MinecraftServer> event : callbacks) {\n+\t\t\t\tevent.onTick(server);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when a ServerWorld ticks.\n+\t */\n+\tpublic static final Event<WorldTickCallback<ServerWorld>> WORLD_TICK = EventFactory.createArrayBacked(WorldTickCallback.class, callbacks -> world -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = world.getProfiler();\n+\t\t\tprofiler.push(\"fabricServerWorldTick_\" + world.dimension.getType().toString());\n+\n+\t\t\tfor (WorldTickCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.onTick(world);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (WorldTickCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tcallback.onTick(world);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when an chunk is loaded into a ServerWorld.\n+\t */\n+\tpublic static final Event<ChunkLoadCallback<ServerWorld>> CHUNK_LOAD = EventFactory.createArrayBacked(ChunkLoadCallback.class, callbacks -> (serverWorld, chunk) -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = serverWorld.getProfiler();\n+\t\t\tprofiler.push(\"fabricServerChunkLoad\");\n+\n+\t\t\tfor (ChunkLoadCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.onChunkLoad(serverWorld, chunk);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (ChunkLoadCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tcallback.onChunkLoad(serverWorld, chunk);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when an chunk is unloaded from a ServerWorld.\n+\t */\n+\tpublic static final Event<ChunkUnloadCallback<ServerWorld>> CHUNK_UNLOAD = EventFactory.createArrayBacked(ChunkUnloadCallback.class, callbacks -> (serverWorld, chunk) -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = serverWorld.getProfiler();\n+\t\t\tprofiler.push(\"fabricServerChunkUnload\");\n+\n+\t\t\tfor (ChunkUnloadCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.onChunkUnload(serverWorld, chunk);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (ChunkUnloadCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tcallback.onChunkUnload(serverWorld, chunk);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when an BlockEntity is loaded into a ServerWorld.\n+\t */\n+\tpublic static final Event<BlockEntityLoadCallback<ServerWorld>> BLOCK_ENTITY_LOAD = EventFactory.createArrayBacked(BlockEntityLoadCallback.class, callbacks -> (blockEntity, world) -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = world.getProfiler();\n+\t\t\tprofiler.push(\"fabricServerBlockEntityLoad\");\n+\n+\t\t\tfor (BlockEntityLoadCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.onLoadBlockEntity(blockEntity, world);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (BlockEntityLoadCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tcallback.onLoadBlockEntity(blockEntity, world);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when an BlockEntity is unloaded from a ServerWorld.\n+\t */\n+\tpublic static final Event<BlockEntityUnloadCallback<ServerWorld>> BLOCK_ENTITY_UNLOAD = EventFactory.createArrayBacked(BlockEntityUnloadCallback.class, callbacks -> (blockEntity, world) -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = world.getProfiler();\n+\t\t\tprofiler.push(\"fabricServerBlockEntityUnload\");\n+\n+\t\t\tfor (BlockEntityUnloadCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.onUnloadBlockEntity(blockEntity, world);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (BlockEntityUnloadCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tcallback.onUnloadBlockEntity(blockEntity, world);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when an Entity is loaded into a ServerWorld.\n+\t *\n+\t * <p>Note there is no corresponding unload event because entity unloads cannot be reliably tracked.\n+\t */\n+\tpublic static final Event<EntityLoadCallback<ServerWorld>> ENTITY_LOAD = EventFactory.createArrayBacked(EntityLoadCallback.class, callbacks -> (entity, world) -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = world.getProfiler();\n+\t\t\tprofiler.push(\"fabricServerEntityLoad\");\n+\n+\t\t\tfor (EntityLoadCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.onEntityLoad(entity, world);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (EntityLoadCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tcallback.onEntityLoad(entity, world);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when the server has started. At this stage, all worlds are live.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3180af925a4e314bf325498692eac40951bb84f7"}, "originalPosition": 194}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwMTk4Mg==", "bodyText": "This could clarify what stopping means, especially with the client having a less permanent stop (in a way).", "url": "https://github.com/FabricMC/fabric/pull/619#discussion_r435601982", "createdAt": "2020-06-04T23:13:10Z", "author": {"login": "sfPlayer1"}, "path": "fabric-lifecycle-events-v1/src/main/java/net/fabricmc/fabric/api/event/lifecycle/v1/ServerLifecycleEvents.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.event.lifecycle.v1;\n+\n+import net.minecraft.server.MinecraftServer;\n+import net.minecraft.server.world.ServerWorld;\n+import net.minecraft.util.profiler.Profiler;\n+\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.block.entity.BlockEntityLoadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.block.entity.BlockEntityUnloadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.chunk.ChunkLoadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.chunk.ChunkUnloadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.entity.EntityLoadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.world.WorldTickCallback;\n+import net.fabricmc.fabric.impl.lifecycle.ServerLifecycleInternals;\n+\n+public final class ServerLifecycleEvents {\n+\tprivate ServerLifecycleEvents() {\n+\t}\n+\n+\t/**\n+\t * Called when a server ticks.\n+\t */\n+\tpublic static final Event<GameTickCallback<MinecraftServer>> SERVER_TICK = EventFactory.createArrayBacked(GameTickCallback.class, callbacks -> server -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = server.getProfiler();\n+\t\t\tprofiler.push(\"fabricServerTick\");\n+\n+\t\t\tfor (GameTickCallback<MinecraftServer> event : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(event));\n+\t\t\t\tevent.onTick(server);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (GameTickCallback<MinecraftServer> event : callbacks) {\n+\t\t\t\tevent.onTick(server);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when a ServerWorld ticks.\n+\t */\n+\tpublic static final Event<WorldTickCallback<ServerWorld>> WORLD_TICK = EventFactory.createArrayBacked(WorldTickCallback.class, callbacks -> world -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = world.getProfiler();\n+\t\t\tprofiler.push(\"fabricServerWorldTick_\" + world.dimension.getType().toString());\n+\n+\t\t\tfor (WorldTickCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.onTick(world);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (WorldTickCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tcallback.onTick(world);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when an chunk is loaded into a ServerWorld.\n+\t */\n+\tpublic static final Event<ChunkLoadCallback<ServerWorld>> CHUNK_LOAD = EventFactory.createArrayBacked(ChunkLoadCallback.class, callbacks -> (serverWorld, chunk) -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = serverWorld.getProfiler();\n+\t\t\tprofiler.push(\"fabricServerChunkLoad\");\n+\n+\t\t\tfor (ChunkLoadCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.onChunkLoad(serverWorld, chunk);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (ChunkLoadCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tcallback.onChunkLoad(serverWorld, chunk);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when an chunk is unloaded from a ServerWorld.\n+\t */\n+\tpublic static final Event<ChunkUnloadCallback<ServerWorld>> CHUNK_UNLOAD = EventFactory.createArrayBacked(ChunkUnloadCallback.class, callbacks -> (serverWorld, chunk) -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = serverWorld.getProfiler();\n+\t\t\tprofiler.push(\"fabricServerChunkUnload\");\n+\n+\t\t\tfor (ChunkUnloadCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.onChunkUnload(serverWorld, chunk);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (ChunkUnloadCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tcallback.onChunkUnload(serverWorld, chunk);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when an BlockEntity is loaded into a ServerWorld.\n+\t */\n+\tpublic static final Event<BlockEntityLoadCallback<ServerWorld>> BLOCK_ENTITY_LOAD = EventFactory.createArrayBacked(BlockEntityLoadCallback.class, callbacks -> (blockEntity, world) -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = world.getProfiler();\n+\t\t\tprofiler.push(\"fabricServerBlockEntityLoad\");\n+\n+\t\t\tfor (BlockEntityLoadCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.onLoadBlockEntity(blockEntity, world);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (BlockEntityLoadCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tcallback.onLoadBlockEntity(blockEntity, world);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when an BlockEntity is unloaded from a ServerWorld.\n+\t */\n+\tpublic static final Event<BlockEntityUnloadCallback<ServerWorld>> BLOCK_ENTITY_UNLOAD = EventFactory.createArrayBacked(BlockEntityUnloadCallback.class, callbacks -> (blockEntity, world) -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = world.getProfiler();\n+\t\t\tprofiler.push(\"fabricServerBlockEntityUnload\");\n+\n+\t\t\tfor (BlockEntityUnloadCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.onUnloadBlockEntity(blockEntity, world);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (BlockEntityUnloadCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tcallback.onUnloadBlockEntity(blockEntity, world);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when an Entity is loaded into a ServerWorld.\n+\t *\n+\t * <p>Note there is no corresponding unload event because entity unloads cannot be reliably tracked.\n+\t */\n+\tpublic static final Event<EntityLoadCallback<ServerWorld>> ENTITY_LOAD = EventFactory.createArrayBacked(EntityLoadCallback.class, callbacks -> (entity, world) -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = world.getProfiler();\n+\t\t\tprofiler.push(\"fabricServerEntityLoad\");\n+\n+\t\t\tfor (EntityLoadCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.onEntityLoad(entity, world);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (EntityLoadCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tcallback.onEntityLoad(entity, world);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when the server has started. At this stage, all worlds are live.\n+\t */\n+\tpublic static final Event<GameLifecycleCallback<MinecraftServer>> SERVER_STARTED = EventFactory.createArrayBacked(GameLifecycleCallback.class, (callbacks) -> (server) -> {\n+\t\tfor (GameLifecycleCallback<MinecraftServer> callback : callbacks) {\n+\t\t\tcallback.onChangeLifecycle(server);\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when the server has started stopping. All worlds are still present.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3180af925a4e314bf325498692eac40951bb84f7"}, "originalPosition": 203}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwMjYzNA==", "bodyText": "While this is useful and sometimes not truly avoidable, I am not sure if we want to reinforce the notion that there's only one server. There should at least be a strong recommendation to always use world.getServer and other context specific approaches instead.", "url": "https://github.com/FabricMC/fabric/pull/619#discussion_r435602634", "createdAt": "2020-06-04T23:15:31Z", "author": {"login": "sfPlayer1"}, "path": "fabric-lifecycle-events-v1/src/main/java/net/fabricmc/fabric/api/event/lifecycle/v1/ServerLifecycleEvents.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.event.lifecycle.v1;\n+\n+import net.minecraft.server.MinecraftServer;\n+import net.minecraft.server.world.ServerWorld;\n+import net.minecraft.util.profiler.Profiler;\n+\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.block.entity.BlockEntityLoadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.block.entity.BlockEntityUnloadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.chunk.ChunkLoadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.chunk.ChunkUnloadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.entity.EntityLoadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.world.WorldTickCallback;\n+import net.fabricmc.fabric.impl.lifecycle.ServerLifecycleInternals;\n+\n+public final class ServerLifecycleEvents {\n+\tprivate ServerLifecycleEvents() {\n+\t}\n+\n+\t/**\n+\t * Called when a server ticks.\n+\t */\n+\tpublic static final Event<GameTickCallback<MinecraftServer>> SERVER_TICK = EventFactory.createArrayBacked(GameTickCallback.class, callbacks -> server -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = server.getProfiler();\n+\t\t\tprofiler.push(\"fabricServerTick\");\n+\n+\t\t\tfor (GameTickCallback<MinecraftServer> event : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(event));\n+\t\t\t\tevent.onTick(server);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (GameTickCallback<MinecraftServer> event : callbacks) {\n+\t\t\t\tevent.onTick(server);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when a ServerWorld ticks.\n+\t */\n+\tpublic static final Event<WorldTickCallback<ServerWorld>> WORLD_TICK = EventFactory.createArrayBacked(WorldTickCallback.class, callbacks -> world -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = world.getProfiler();\n+\t\t\tprofiler.push(\"fabricServerWorldTick_\" + world.dimension.getType().toString());\n+\n+\t\t\tfor (WorldTickCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.onTick(world);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (WorldTickCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tcallback.onTick(world);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when an chunk is loaded into a ServerWorld.\n+\t */\n+\tpublic static final Event<ChunkLoadCallback<ServerWorld>> CHUNK_LOAD = EventFactory.createArrayBacked(ChunkLoadCallback.class, callbacks -> (serverWorld, chunk) -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = serverWorld.getProfiler();\n+\t\t\tprofiler.push(\"fabricServerChunkLoad\");\n+\n+\t\t\tfor (ChunkLoadCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.onChunkLoad(serverWorld, chunk);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (ChunkLoadCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tcallback.onChunkLoad(serverWorld, chunk);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when an chunk is unloaded from a ServerWorld.\n+\t */\n+\tpublic static final Event<ChunkUnloadCallback<ServerWorld>> CHUNK_UNLOAD = EventFactory.createArrayBacked(ChunkUnloadCallback.class, callbacks -> (serverWorld, chunk) -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = serverWorld.getProfiler();\n+\t\t\tprofiler.push(\"fabricServerChunkUnload\");\n+\n+\t\t\tfor (ChunkUnloadCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.onChunkUnload(serverWorld, chunk);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (ChunkUnloadCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tcallback.onChunkUnload(serverWorld, chunk);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when an BlockEntity is loaded into a ServerWorld.\n+\t */\n+\tpublic static final Event<BlockEntityLoadCallback<ServerWorld>> BLOCK_ENTITY_LOAD = EventFactory.createArrayBacked(BlockEntityLoadCallback.class, callbacks -> (blockEntity, world) -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = world.getProfiler();\n+\t\t\tprofiler.push(\"fabricServerBlockEntityLoad\");\n+\n+\t\t\tfor (BlockEntityLoadCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.onLoadBlockEntity(blockEntity, world);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (BlockEntityLoadCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tcallback.onLoadBlockEntity(blockEntity, world);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when an BlockEntity is unloaded from a ServerWorld.\n+\t */\n+\tpublic static final Event<BlockEntityUnloadCallback<ServerWorld>> BLOCK_ENTITY_UNLOAD = EventFactory.createArrayBacked(BlockEntityUnloadCallback.class, callbacks -> (blockEntity, world) -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = world.getProfiler();\n+\t\t\tprofiler.push(\"fabricServerBlockEntityUnload\");\n+\n+\t\t\tfor (BlockEntityUnloadCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.onUnloadBlockEntity(blockEntity, world);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (BlockEntityUnloadCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tcallback.onUnloadBlockEntity(blockEntity, world);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when an Entity is loaded into a ServerWorld.\n+\t *\n+\t * <p>Note there is no corresponding unload event because entity unloads cannot be reliably tracked.\n+\t */\n+\tpublic static final Event<EntityLoadCallback<ServerWorld>> ENTITY_LOAD = EventFactory.createArrayBacked(EntityLoadCallback.class, callbacks -> (entity, world) -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = world.getProfiler();\n+\t\t\tprofiler.push(\"fabricServerEntityLoad\");\n+\n+\t\t\tfor (EntityLoadCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.onEntityLoad(entity, world);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (EntityLoadCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tcallback.onEntityLoad(entity, world);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when the server has started. At this stage, all worlds are live.\n+\t */\n+\tpublic static final Event<GameLifecycleCallback<MinecraftServer>> SERVER_STARTED = EventFactory.createArrayBacked(GameLifecycleCallback.class, (callbacks) -> (server) -> {\n+\t\tfor (GameLifecycleCallback<MinecraftServer> callback : callbacks) {\n+\t\t\tcallback.onChangeLifecycle(server);\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when the server has started stopping. All worlds are still present.\n+\t */\n+\tpublic static final Event<GameLifecycleCallback<MinecraftServer>> SERVER_STOPPING = EventFactory.createArrayBacked(GameLifecycleCallback.class, (callbacks) -> (server) -> {\n+\t\tfor (GameLifecycleCallback<MinecraftServer> callback : callbacks) {\n+\t\t\tcallback.onChangeLifecycle(server);\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when the server has stopped. All worlds have been closed and all (block)entities and players have been unloaded.\n+\t */\n+\tpublic static final Event<GameLifecycleCallback<MinecraftServer>> SERVER_STOPPED = EventFactory.createArrayBacked(GameLifecycleCallback.class, callbacks -> server -> {\n+\t\tfor (GameLifecycleCallback<MinecraftServer> callback : callbacks) {\n+\t\t\tcallback.onChangeLifecycle(server);\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Gets the currently running server.\n+\t *\n+\t * <p>The server instance returned SHOULD NOT be cached! Call the method every time you need the server.\n+\t *\n+\t * @return the currently running server\n+\t * @throws IllegalStateException if the server is not available\n+\t */\n+\tpublic static MinecraftServer getCurrentServer() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3180af925a4e314bf325498692eac40951bb84f7"}, "originalPosition": 228}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1Nzc2MDQx", "url": "https://github.com/FabricMC/fabric/pull/619#pullrequestreview-425776041", "createdAt": "2020-06-06T23:43:40Z", "commit": {"oid": "d9dcda0789f23b4df8b2da290ead333af2a93217"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQyMzo0Mzo0MFrOGgGNJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQyMzo0Mzo0MFrOGgGNJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMwOTI4Nw==", "bodyText": "just do @Deprecated", "url": "https://github.com/FabricMC/fabric/pull/619#discussion_r436309287", "createdAt": "2020-06-06T23:43:40Z", "author": {"login": "liach"}, "path": "fabric-lifecycle-events-v1/src/main/java/net/fabricmc/fabric/api/event/lifecycle/v1/ServerLifecycleEvents.java", "diffHunk": "@@ -61,17 +61,17 @@ private ServerLifecycleEvents() {\n \t});\n \n \t/**\n-\t * Gets the currently running server.\n+\t * Gets the currently running primary server.\n \t *\n-\t * <p><b>Use of this method is highly impractical and not recommended since there is no real restriction on whether the game engine could run multiple servers concurrently.</b>\n+\t * <p><b>Use of this method is highly discouraged and not recommended since there is no real restriction on whether the game engine could run multiple servers concurrently.</b>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9dcda0789f23b4df8b2da290ead333af2a93217"}, "originalPosition": 8}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxMDY1NTE5", "url": "https://github.com/FabricMC/fabric/pull/619#pullrequestreview-431065519", "createdAt": "2020-06-15T23:46:01Z", "commit": {"oid": "046fa8ca53afe6a2d2e837cf9a44fe235d7f58f8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQyMzo0NjowMVrOGkGYWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQyMzo0NjowMVrOGkGYWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwNjQ1Nw==", "bodyText": "After thinking a bit, I am going to drop these methods.", "url": "https://github.com/FabricMC/fabric/pull/619#discussion_r440506457", "createdAt": "2020-06-15T23:46:01Z", "author": {"login": "i509VCB"}, "path": "fabric-lifecycle-events-v1/src/main/java/net/fabricmc/fabric/api/event/lifecycle/v1/ServerLifecycleEvents.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.event.lifecycle.v1;\n+\n+import net.minecraft.server.MinecraftServer;\n+import net.minecraft.server.world.ServerWorld;\n+\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+import net.fabricmc.fabric.impl.lifecycle.ServerLifecycleInternals;\n+\n+public final class ServerLifecycleEvents {\n+\tprivate ServerLifecycleEvents() {\n+\t}\n+\n+\t/**\n+\t * Called when a Minecraft server has started and is about to tick for the first time.\n+\t *\n+\t * <p>At this stage, all worlds are live.\n+\t */\n+\tpublic static final Event<ServerLifecycleEvents.LifecycleCallback> SERVER_STARTED = EventFactory.createArrayBacked(ServerLifecycleEvents.LifecycleCallback.class, (callbacks) -> (server) -> {\n+\t\tfor (ServerLifecycleEvents.LifecycleCallback callback : callbacks) {\n+\t\t\tcallback.onChangeLifecycle(server);\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when a Minecraft server has started shutting down.\n+\t * This occurs before the server's network channel is closed and before any players are disconnected.\n+\t *\n+\t * <p>For example, an integrated server will begin stopping, but it's client may continue to run.\n+\t *\n+\t * <p>All worlds are still present and can be modified.\n+\t */\n+\tpublic static final Event<ServerLifecycleEvents.LifecycleCallback> SERVER_STOPPING = EventFactory.createArrayBacked(ServerLifecycleEvents.LifecycleCallback.class, (callbacks) -> (server) -> {\n+\t\tfor (ServerLifecycleEvents.LifecycleCallback callback : callbacks) {\n+\t\t\tcallback.onChangeLifecycle(server);\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when a Minecraft server has stopped.\n+\t * All worlds have been closed and all (block)entities and players have been unloaded.\n+\t *\n+\t * <p>For example, an {@link net.fabricmc.api.EnvType#CLIENT integrated server} will begin stopping, but it's client may continue to run.\n+\t * Meanwhile for a {@link net.fabricmc.api.EnvType#SERVER dedicated server}, this will be the last event called.\n+\t */\n+\tpublic static final Event<ServerLifecycleEvents.LifecycleCallback> SERVER_STOPPED = EventFactory.createArrayBacked(ServerLifecycleEvents.LifecycleCallback.class, callbacks -> server -> {\n+\t\tfor (ServerLifecycleEvents.LifecycleCallback callback : callbacks) {\n+\t\t\tcallback.onChangeLifecycle(server);\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Gets the currently running primary server.\n+\t *\n+\t * <p><b>Use of this method is highly discouraged and not recommended since there is no real restriction on whether the game engine could run multiple servers concurrently.</b>\n+\t * One should attempt to obtain the server instance from a {@link ServerWorld server world} or via other means.\n+\t *\n+\t * <p>The server instance returned SHOULD NOT be cached! Call the method every time you need the server.\n+\t *\n+\t * @return the currently running server\n+\t * @throws IllegalStateException if the server is not available\n+\t */\n+\t@Deprecated\n+\tpublic static MinecraftServer getPrimaryServer() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "046fa8ca53afe6a2d2e837cf9a44fe235d7f58f8"}, "originalPosition": 80}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c4b25c4552e6ded3eedbabd02d999fd8731d92f6", "author": {"user": {"login": "i509VCB", "name": null}}, "url": "https://github.com/FabricMC/fabric/commit/c4b25c4552e6ded3eedbabd02d999fd8731d92f6", "committedDate": "2020-06-16T02:39:44Z", "message": "Lifecycle Events V1\n\nNow includes Chunk and (Block)Entity (un)load events"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1367a39e53949a907a69e30adb860854e935fdf5", "author": {"user": {"login": "i509VCB", "name": null}}, "url": "https://github.com/FabricMC/fabric/commit/1367a39e53949a907a69e30adb860854e935fdf5", "committedDate": "2020-06-16T02:39:44Z", "message": "Add some tests to verify worlds are ticking in the log"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8fa596bc50ff3958e5dfabc7be503d72e7fce366", "author": {"user": {"login": "i509VCB", "name": null}}, "url": "https://github.com/FabricMC/fabric/commit/8fa596bc50ff3958e5dfabc7be503d72e7fce366", "committedDate": "2020-06-16T02:39:44Z", "message": "Lambda boogaloo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b3ad317ace70e240775ab86c428119fb86135ada", "author": {"user": {"login": "i509VCB", "name": null}}, "url": "https://github.com/FabricMC/fabric/commit/b3ad317ace70e240775ab86c428119fb86135ada", "committedDate": "2020-06-16T02:39:45Z", "message": "Add some docs. Distinguish between a server starting to stop and server which has stopped."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "500a72e8e83c914b39f3755bc2fac815737c4fba", "author": {"user": {"login": "i509VCB", "name": null}}, "url": "https://github.com/FabricMC/fabric/commit/500a72e8e83c914b39f3755bc2fac815737c4fba", "committedDate": "2020-06-16T02:39:45Z", "message": "Split up test mods, some tweaks to (block)entity (un)load events.\n\nBind the ServerWorld being closed during shutdown to unload (block)entities."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a9c22feecdc6fe638b9340609cb416aa173913c6", "author": {"user": {"login": "i509VCB", "name": null}}, "url": "https://github.com/FabricMC/fabric/commit/a9c22feecdc6fe638b9340609cb416aa173913c6", "committedDate": "2020-06-16T02:39:45Z", "message": "Shift around a few profiler variables and finalize"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "33a92e87c85da8e7730f5b7b0d55e8963f4dab6f", "author": {"user": {"login": "i509VCB", "name": null}}, "url": "https://github.com/FabricMC/fabric/commit/33a92e87c85da8e7730f5b7b0d55e8963f4dab6f", "committedDate": "2020-06-16T02:39:45Z", "message": "Complete the tests, Block entities on server should be reliably tracked now.\n\nEntities on the server obviously still need to be wrangled."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "afa3483bad1b4bc3e5fe3c7985d9517878d8c6e5", "author": {"user": {"login": "i509VCB", "name": null}}, "url": "https://github.com/FabricMC/fabric/commit/afa3483bad1b4bc3e5fe3c7985d9517878d8c6e5", "committedDate": "2020-06-16T02:39:45Z", "message": "Drop Server Entity Unload callback.\n\nBelieve me, this was a hard decision but it stands on the fact that about 20-40% of entities silently unload without going through the proper \"unloadEntity\" method in ServerWorld. No amount of debug hacks, double tracking unload events and even replacing the entity maps do not fix this issue. So I have decided to drop this from the feature set."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e2f7c9f7fda2a4ceb7617d77462c2503bbd62c4a", "author": {"user": {"login": "i509VCB", "name": null}}, "url": "https://github.com/FabricMC/fabric/commit/e2f7c9f7fda2a4ceb7617d77462c2503bbd62c4a", "committedDate": "2020-06-16T02:39:45Z", "message": "checkstyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c0c4f00ada859be89a4e3395609e15ff26c1d44a", "author": {"user": {"login": "i509VCB", "name": null}}, "url": "https://github.com/FabricMC/fabric/commit/c0c4f00ada859be89a4e3395609e15ff26c1d44a", "committedDate": "2020-06-16T02:39:47Z", "message": "generic-events -> item-api"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c78c53c1c27dbe8439f4c91b5b08cdd09e577b71", "author": {"user": {"login": "i509VCB", "name": null}}, "url": "https://github.com/FabricMC/fabric/commit/c78c53c1c27dbe8439f4c91b5b08cdd09e577b71", "committedDate": "2020-06-16T02:39:47Z", "message": "Server start -> Server started"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4c15b7d1e9f6dd82a5ec5b043c0d3b8247fc2a7c", "author": {"user": {"login": "i509VCB", "name": null}}, "url": "https://github.com/FabricMC/fabric/commit/4c15b7d1e9f6dd82a5ec5b043c0d3b8247fc2a7c", "committedDate": "2020-06-16T02:39:47Z", "message": "Allow getting current server from Lifecycle\n\nPeople have asked for this, but it is not encouraged for obvious reasons. Should be staged well enough to revert if we decide to."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "203d95884f06030d5d25c807782ff5d6503199dc", "author": {"user": {"login": "i509VCB", "name": null}}, "url": "https://github.com/FabricMC/fabric/commit/203d95884f06030d5d25c807782ff5d6503199dc", "committedDate": "2020-06-16T02:39:47Z", "message": "checkstyle lol"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fe4803963f26946682017f9d36898c05f8c42258", "author": {"user": {"login": "i509VCB", "name": null}}, "url": "https://github.com/FabricMC/fabric/commit/fe4803963f26946682017f9d36898c05f8c42258", "committedDate": "2020-06-16T02:39:47Z", "message": "update injection name"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5acbe34ea600c0b6c37af73670984f342e9f7f95", "author": {"user": {"login": "i509VCB", "name": null}}, "url": "https://github.com/FabricMC/fabric/commit/5acbe34ea600c0b6c37af73670984f342e9f7f95", "committedDate": "2020-06-16T02:39:47Z", "message": "Checkstyle lol: Redundant modifiers"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2c2780026c3b5cd0c0d744f88bd3c727135da2b4", "author": {"user": {"login": "i509VCB", "name": null}}, "url": "https://github.com/FabricMC/fabric/commit/2c2780026c3b5cd0c0d744f88bd3c727135da2b4", "committedDate": "2020-06-16T02:39:48Z", "message": "Add client starting, stopping and stopped callbacks."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "53c4e71c3bec6de4a828652ec85f5c4df6718d50", "author": {"user": {"login": "i509VCB", "name": null}}, "url": "https://github.com/FabricMC/fabric/commit/53c4e71c3bec6de4a828652ec85f5c4df6718d50", "committedDate": "2020-06-16T02:39:48Z", "message": "Loicenses"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ae655e5275f5492b75279943a05475c186055d2d", "author": {"user": {"login": "i509VCB", "name": null}}, "url": "https://github.com/FabricMC/fabric/commit/ae655e5275f5492b75279943a05475c186055d2d", "committedDate": "2020-06-16T02:39:48Z", "message": "Reorganize so each event category has it's own class.\n\nAlso this collapses the pretty widely reaching interfaces into more specific inner classes to avoid issues with generics."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e4579679f02d43dbf5210ac0dc17eb8b96a2f166", "author": {"user": {"login": "i509VCB", "name": null}}, "url": "https://github.com/FabricMC/fabric/commit/e4579679f02d43dbf5210ac0dc17eb8b96a2f166", "committedDate": "2020-06-16T02:39:48Z", "message": "Some docs and slight name changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "030a5095cf57f51ed424561bf8e6acca5b013251", "author": {"user": {"login": "i509VCB", "name": null}}, "url": "https://github.com/FabricMC/fabric/commit/030a5095cf57f51ed424561bf8e6acca5b013251", "committedDate": "2020-06-16T02:39:48Z", "message": "Add start tick callbacks to worlds, server and client"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0a4d752cf8cbbf2b2e05a53900cd6d41087122a5", "author": {"user": {"login": "i509VCB", "name": null}}, "url": "https://github.com/FabricMC/fabric/commit/0a4d752cf8cbbf2b2e05a53900cd6d41087122a5", "committedDate": "2020-06-16T02:39:48Z", "message": "Enhance some client related docs to life cycle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "628d4a41e95ec9a419e02883b59da8fda04f8c2b", "author": {"user": {"login": "i509VCB", "name": null}}, "url": "https://github.com/FabricMC/fabric/commit/628d4a41e95ec9a419e02883b59da8fda04f8c2b", "committedDate": "2020-06-16T02:39:48Z", "message": "Deprecate for reasons of discouraging singletonish server getter methods in lifecycle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "34b3c3c85fb8c8ca2ebce51b1899c610a096704e", "author": {"user": {"login": "i509VCB", "name": null}}, "url": "https://github.com/FabricMC/fabric/commit/34b3c3c85fb8c8ca2ebce51b1899c610a096704e", "committedDate": "2020-06-16T02:39:48Z", "message": "Add some description related to integrated server on server stopping."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "abf04bfafd3d900a4a04e7e9851c0df27a0ee79f", "author": {"user": {"login": "i509VCB", "name": null}}, "url": "https://github.com/FabricMC/fabric/commit/abf04bfafd3d900a4a04e7e9851c0df27a0ee79f", "committedDate": "2020-06-16T02:39:48Z", "message": "Add small test to verify tick starts are right spot of load"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "77ee4ab8e8ec24e6587664c7a727dedb18474955", "author": {"user": {"login": "i509VCB", "name": null}}, "url": "https://github.com/FabricMC/fabric/commit/77ee4ab8e8ec24e6587664c7a727dedb18474955", "committedDate": "2020-06-16T02:39:49Z", "message": "Docs and a tiny bit more testing."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "90dbb2c4e235b2eb06eba840081ae4c9b1313df0", "author": {"user": {"login": "i509VCB", "name": null}}, "url": "https://github.com/FabricMC/fabric/commit/90dbb2c4e235b2eb06eba840081ae4c9b1313df0", "committedDate": "2020-06-16T02:39:49Z", "message": "Try clarifying client docs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d25c6b16b8d4e00888a9750b3b1b2af3ce9f1e53", "author": {"user": {"login": "i509VCB", "name": null}}, "url": "https://github.com/FabricMC/fabric/commit/d25c6b16b8d4e00888a9750b3b1b2af3ce9f1e53", "committedDate": "2020-06-16T02:39:49Z", "message": "Drop a slightly unnessecary event"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0b884f022df534a3efe69f0a1e662635c290c085", "author": {"user": {"login": "i509VCB", "name": null}}, "url": "https://github.com/FabricMC/fabric/commit/0b884f022df534a3efe69f0a1e662635c290c085", "committedDate": "2020-06-16T02:39:49Z", "message": "Actually call and implement START_SERVER_TICK event"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6599a110201a0a482003e3d652bc9e6d08046ba4", "author": {"user": {"login": "i509VCB", "name": null}}, "url": "https://github.com/FabricMC/fabric/commit/6599a110201a0a482003e3d652bc9e6d08046ba4", "committedDate": "2020-06-16T02:39:49Z", "message": "Remove non-existent test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "15c3bccb6d790937ba470d2979356883275bd7c4", "author": {"user": {"login": "i509VCB", "name": null}}, "url": "https://github.com/FabricMC/fabric/commit/15c3bccb6d790937ba470d2979356883275bd7c4", "committedDate": "2020-06-16T02:39:49Z", "message": "again"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8c187dd160015b7a4e689f6990c94228a959a7d2", "author": {"user": {"login": "i509VCB", "name": null}}, "url": "https://github.com/FabricMC/fabric/commit/8c187dd160015b7a4e689f6990c94228a959a7d2", "committedDate": "2020-06-16T02:39:49Z", "message": "Refer to minecraft itself in client lifecycle docs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ff486728a95e09cfec0bd43c33985cb1646650ba", "author": {"user": {"login": "i509VCB", "name": null}}, "url": "https://github.com/FabricMC/fabric/commit/ff486728a95e09cfec0bd43c33985cb1646650ba", "committedDate": "2020-06-16T02:39:49Z", "message": "Refer to Minecraft itself within ServerLifecycleEvents"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "046fa8ca53afe6a2d2e837cf9a44fe235d7f58f8", "author": {"user": {"login": "i509VCB", "name": null}}, "url": "https://github.com/FabricMC/fabric/commit/046fa8ca53afe6a2d2e837cf9a44fe235d7f58f8", "committedDate": "2020-06-11T19:30:58Z", "message": "Refer to Minecraft itself within ServerLifecycleEvents"}, "afterCommit": {"oid": "ff486728a95e09cfec0bd43c33985cb1646650ba", "author": {"user": {"login": "i509VCB", "name": null}}, "url": "https://github.com/FabricMC/fabric/commit/ff486728a95e09cfec0bd43c33985cb1646650ba", "committedDate": "2020-06-16T02:39:49Z", "message": "Refer to Minecraft itself within ServerLifecycleEvents"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c84f36209d0072ab9c4083c0bf111917720d54e1", "author": {"user": {"login": "i509VCB", "name": null}}, "url": "https://github.com/FabricMC/fabric/commit/c84f36209d0072ab9c4083c0bf111917720d54e1", "committedDate": "2020-06-16T04:47:58Z", "message": "Remove primary server getters"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b226b21df1ad95edf2e381cc180525a37e9d64af", "author": {"user": {"login": "i509VCB", "name": null}}, "url": "https://github.com/FabricMC/fabric/commit/b226b21df1ad95edf2e381cc180525a37e9d64af", "committedDate": "2020-06-16T04:52:52Z", "message": "IJ DO YOU SPEAK RESOLVING IMPORTS\n\n(cherry picked from commit c9257e8a11d8361469349f4171263121bb111af7)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a5112223ca4505fb7777b1ef53d3478d0155079d", "author": {"user": {"login": "i509VCB", "name": null}}, "url": "https://github.com/FabricMC/fabric/commit/a5112223ca4505fb7777b1ef53d3478d0155079d", "committedDate": "2020-06-16T06:00:04Z", "message": "Prune the tests that shouldn't exist"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f708519af80db1cc8297cfc017ffcb47afbf8cca", "author": {"user": {"login": "i509VCB", "name": null}}, "url": "https://github.com/FabricMC/fabric/commit/f708519af80db1cc8297cfc017ffcb47afbf8cca", "committedDate": "2020-06-17T06:33:18Z", "message": "Listen here checkstyle you bugger\n\n(cherry picked from commit 9701bba4002cec089c9d3738b1f226128078c130)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3431c0d894309f137f39f288174a5d14c6423cee", "author": {"user": {"login": "i509VCB", "name": null}}, "url": "https://github.com/FabricMC/fabric/commit/3431c0d894309f137f39f288174a5d14c6423cee", "committedDate": "2020-06-18T00:52:20Z", "message": "Split up events to individual interfaces. Make Chunk events use WorldChunk instead."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyODk1MzQ4", "url": "https://github.com/FabricMC/fabric/pull/619#pullrequestreview-432895348", "createdAt": "2020-06-18T02:19:52Z", "commit": {"oid": "3431c0d894309f137f39f288174a5d14c6423cee"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyOTE4NTk1", "url": "https://github.com/FabricMC/fabric/pull/619#pullrequestreview-432918595", "createdAt": "2020-06-18T03:39:15Z", "commit": {"oid": "3431c0d894309f137f39f288174a5d14c6423cee"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMzozOToxNVrOGlegWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMzozOToxNVrOGlegWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTk1MDI5OQ==", "bodyText": "clientStopping.onClientStopping etc sounds weird \ud83e\udd14", "url": "https://github.com/FabricMC/fabric/pull/619#discussion_r441950299", "createdAt": "2020-06-18T03:39:15Z", "author": {"login": "liach"}, "path": "fabric-lifecycle-events-v1/src/main/java/net/fabricmc/fabric/api/client/event/lifecycle/v1/ClientLifecycleEvents.java", "diffHunk": "@@ -33,9 +33,9 @@ private ClientLifecycleEvents() {\n \t *\n \t * <p>This occurs while the splash screen is displayed.\n \t */\n-\tpublic static final Event<ClientLifecycleCallback> CLIENT_STARTED = EventFactory.createArrayBacked(ClientLifecycleCallback.class, callbacks -> client -> {\n-\t\tfor (ClientLifecycleCallback callback : callbacks) {\n-\t\t\tcallback.onChangeLifecycle(client);\n+\tpublic static final Event<ClientStarted> CLIENT_STARTED = EventFactory.createArrayBacked(ClientStarted.class, callbacks -> client -> {\n+\t\tfor (ClientStarted callback : callbacks) {\n+\t\t\tcallback.onClientStarted(client);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3431c0d894309f137f39f288174a5d14c6423cee"}, "originalPosition": 9}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNTQ0NDQ4", "url": "https://github.com/FabricMC/fabric/pull/619#pullrequestreview-433544448", "createdAt": "2020-06-18T18:31:42Z", "commit": {"oid": "3431c0d894309f137f39f288174a5d14c6423cee"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNTQ5NDMw", "url": "https://github.com/FabricMC/fabric/pull/619#pullrequestreview-433549430", "createdAt": "2020-06-18T18:38:55Z", "commit": {"oid": "3431c0d894309f137f39f288174a5d14c6423cee"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxODozODo1NVrOGl7nEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxODozODo1NVrOGl7nEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQyNzE1NQ==", "bodyText": "Not sure if we really need a whole module just for ItemTooltipCallback", "url": "https://github.com/FabricMC/fabric/pull/619#discussion_r442427155", "createdAt": "2020-06-18T18:38:55Z", "author": {"login": "modmuss50"}, "path": "fabric-item-api-v1/build.gradle", "diffHunk": "@@ -0,0 +1,6 @@\n+archivesBaseName = \"fabric-item-api-v1\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3431c0d894309f137f39f288174a5d14c6423cee"}, "originalPosition": 1}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3442, "cost": 1, "resetAt": "2021-11-01T14:20:25Z"}}}