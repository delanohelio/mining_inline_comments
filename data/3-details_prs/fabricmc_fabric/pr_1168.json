{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIyNzA2NzEw", "number": 1168, "title": "Fix MC-202036 - Shifting biome IDs", "bodyText": "This is loosly bassed off the existing registrys sync stuff, but just the required bits, and trying to be minimal. I have tried to leave some comments explainng whats doing what, hopefully its fairly easy to follow.\nThis is missing the backing up of the data files, do we still need/want this? (Minecraft does appear to show a warning screen with an option to backup if changing this stuff?)\nI look forward to your reviews and testing.", "createdAt": "2020-11-17T21:06:34Z", "url": "https://github.com/FabricMC/fabric/pull/1168", "merged": true, "mergeCommit": {"oid": "0f03523de57dc9c12e1a9f1e7ff69d80b95a8593"}, "closed": true, "closedAt": "2020-11-21T18:32:21Z", "author": {"login": "modmuss50"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABddgEAxgH2gAyNTIyNzA2NzEwOjk4NzZmN2YwODg4Mzg5M2VjNmNiOWM4NmVhZGI5ZGNhNWU2ODBhNDA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdeseEpAFqTUzNTk2ODQ1Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "9876f7f08883893ec6cb9c86eadb9dca5e680a40", "author": {"user": {"login": "modmuss50", "name": "modmuss50"}}, "url": "https://github.com/FabricMC/fabric/commit/9876f7f08883893ec6cb9c86eadb9dca5e680a40", "committedDate": "2020-11-17T21:02:23Z", "message": "First pass on PersistentDynamicRegistryHandler, not tested"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyODEzNjQ1", "url": "https://github.com/FabricMC/fabric/pull/1168#pullrequestreview-532813645", "createdAt": "2020-11-17T21:08:36Z", "commit": {"oid": "9876f7f08883893ec6cb9c86eadb9dca5e680a40"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMTowODozN1rOH1LiMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMTowODozN1rOH1LiMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUyNTU1NA==", "bodyText": "Just a few locals ;)", "url": "https://github.com/FabricMC/fabric/pull/1168#discussion_r525525554", "createdAt": "2020-11-17T21:08:37Z", "author": {"login": "modmuss50"}, "path": "fabric-registry-sync-v0/src/main/java/net/fabricmc/fabric/mixin/registry/sync/MixinMain.java", "diffHunk": "@@ -0,0 +1,40 @@\n+package net.fabricmc.fabric.mixin.registry.sync;\n+\n+import java.io.File;\n+import java.nio.file.Path;\n+import java.util.concurrent.CompletableFuture;\n+\n+import joptsimple.OptionParser;\n+import joptsimple.OptionSet;\n+import joptsimple.OptionSpec;\n+import com.mojang.authlib.GameProfileRepository;\n+import com.mojang.authlib.minecraft.MinecraftSessionService;\n+import com.mojang.authlib.yggdrasil.YggdrasilAuthenticationService;\n+import org.spongepowered.asm.mixin.Mixin;\n+import org.spongepowered.asm.mixin.injection.At;\n+import org.spongepowered.asm.mixin.injection.Inject;\n+import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;\n+import org.spongepowered.asm.mixin.injection.callback.LocalCapture;\n+\n+import net.minecraft.resource.DataPackSettings;\n+import net.minecraft.resource.ResourcePackManager;\n+import net.minecraft.resource.ServerResourceManager;\n+import net.minecraft.server.Main;\n+import net.minecraft.server.dedicated.EulaReader;\n+import net.minecraft.server.dedicated.ServerPropertiesLoader;\n+import net.minecraft.util.UserCache;\n+import net.minecraft.util.dynamic.RegistryOps;\n+import net.minecraft.util.registry.DynamicRegistryManager;\n+import net.minecraft.world.level.storage.LevelStorage;\n+\n+import net.fabricmc.fabric.impl.registry.sync.PersistentDynamicRegistryHandler;\n+\n+@Mixin(Main.class)\n+public class MixinMain {\n+\t@SuppressWarnings(\"rawtypes\")\n+\t@Inject(method = \"main\", at = @At(value = \"INVOKE_ASSIGN\", target = \"Lnet/minecraft/util/dynamic/RegistryOps;of(Lcom/mojang/serialization/DynamicOps;Lnet/minecraft/resource/ResourceManager;Lnet/minecraft/util/registry/DynamicRegistryManager$Impl;)Lnet/minecraft/util/dynamic/RegistryOps;\"), locals = LocalCapture.CAPTURE_FAILHARD)\n+\tprivate static void main(String[] args, CallbackInfo ci, OptionParser optionParser, OptionSpec optionSpec, OptionSpec optionSpec2, OptionSpec optionSpec3, OptionSpec optionSpec4, OptionSpec optionSpec5, OptionSpec optionSpec6, OptionSpec optionSpec7, OptionSpec optionSpec8, OptionSpec optionSpec9, OptionSpec optionSpec10, OptionSpec optionSpec11, OptionSpec optionSpec12, OptionSpec optionSpec13, OptionSpec optionSpec14, OptionSet optionSet, DynamicRegistryManager.Impl impl, Path path, ServerPropertiesLoader serverPropertiesLoader, Path path2, EulaReader eulaReader, File file, YggdrasilAuthenticationService yggdrasilAuthenticationService, MinecraftSessionService minecraftSessionService, GameProfileRepository gameProfileRepository, UserCache userCache, String string, LevelStorage levelStorage, LevelStorage.Session session, DataPackSettings dataPackSettings, boolean bl, ResourcePackManager resourcePackManager, DataPackSettings dataPackSettings2, CompletableFuture completableFuture, ServerResourceManager serverResourceManager2, RegistryOps registryOps) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9876f7f08883893ec6cb9c86eadb9dca5e680a40"}, "originalPosition": 36}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyODM0NTY4", "url": "https://github.com/FabricMC/fabric/pull/1168#pullrequestreview-532834568", "createdAt": "2020-11-17T21:39:14Z", "commit": {"oid": "9876f7f08883893ec6cb9c86eadb9dca5e680a40"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMTozOToxNFrOH1MiHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMTo0MTo1MFrOH1MnkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU0MTkxOQ==", "bodyText": "Maybe put the ID of the registry in the exception", "url": "https://github.com/FabricMC/fabric/pull/1168#discussion_r525541919", "createdAt": "2020-11-17T21:39:14Z", "author": {"login": "i509VCB"}, "path": "fabric-registry-sync-v0/src/main/java/net/fabricmc/fabric/impl/registry/sync/PersistentDynamicRegistryHandler.java", "diffHunk": "@@ -0,0 +1,138 @@\n+package net.fabricmc.fabric.impl.registry.sync;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+\n+import net.minecraft.nbt.CompoundTag;\n+import net.minecraft.nbt.NbtIo;\n+import net.minecraft.util.Identifier;\n+import net.minecraft.util.registry.DynamicRegistryManager;\n+import net.minecraft.util.registry.MutableRegistry;\n+import net.minecraft.util.registry.Registry;\n+\n+public class PersistentDynamicRegistryHandler {\n+\tprivate static final Logger LOGGER = LogManager.getLogger();\n+\n+\tpublic static void remapDynamicRegistries(DynamicRegistryManager.Impl dynamicRegistryManager, Path saveDir) {\n+\t\tLOGGER.debug(\"Starting registry remap\");\n+\n+\t\tCompoundTag registryData;\n+\n+\t\ttry {\n+\t\t\tregistryData = remapDynamicRegistries(dynamicRegistryManager, readCompoundTag(getDataPath(saveDir)));\n+\t\t} catch (RemapException | IOException e) {\n+\t\t\t// TODO try the backups here?\n+\t\t\tthrow new RuntimeException(e);\n+\t\t}\n+\n+\t\twriteCompoundTag(registryData, getDataPath(saveDir));\n+\t}\n+\n+\t@NotNull\n+\tprivate static CompoundTag remapDynamicRegistries(DynamicRegistryManager.Impl dynamicRegistryManager, @Nullable CompoundTag existingTag) throws RemapException {\n+\t\tCompoundTag registries = new CompoundTag();\n+\n+\t\t// For now we only care about biomes, but lets keep our options open\n+\t\tMutableRegistry<?> registry = dynamicRegistryManager.get(Registry.BIOME_KEY);\n+\t\tCompoundTag biomeIdMap = remapRegistry(Registry.BIOME_KEY.getValue(), registry, existingTag);\n+\t\tregistries.put(Registry.BIOME_KEY.getValue().toString(), biomeIdMap);\n+\n+\t\tCompoundTag outputTag = new CompoundTag();\n+\t\toutputTag.putInt(\"version\", 1);\n+\t\toutputTag.put(\"registries\", registries);\n+\t\treturn registries;\n+\t}\n+\n+\t/**\n+\t * Remaps a registry if existing data is passed in.\n+\t * Then writes out the ids in the registry (remapped or a new world).\n+\t * Keeps hold of the orphaned registry entries as to not overwrite them.\n+\t */\n+\t@SuppressWarnings(\"unchecked\")\n+\tprivate static CompoundTag remapRegistry(Identifier registryId, MutableRegistry registry, @Nullable CompoundTag existingTag) throws RemapException {\n+\t\tif (!(registry instanceof RemappableRegistry)) {\n+\t\t\tthrow new UnsupportedOperationException(\"Cannot remap un re-mappable registry\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9876f7f08883893ec6cb9c86eadb9dca5e680a40"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU0MzAxMA==", "bodyText": "o p t i o n s p e c", "url": "https://github.com/FabricMC/fabric/pull/1168#discussion_r525543010", "createdAt": "2020-11-17T21:41:16Z", "author": {"login": "i509VCB"}, "path": "fabric-registry-sync-v0/src/main/java/net/fabricmc/fabric/mixin/registry/sync/MixinMain.java", "diffHunk": "@@ -0,0 +1,40 @@\n+package net.fabricmc.fabric.mixin.registry.sync;\n+\n+import java.io.File;\n+import java.nio.file.Path;\n+import java.util.concurrent.CompletableFuture;\n+\n+import joptsimple.OptionParser;\n+import joptsimple.OptionSet;\n+import joptsimple.OptionSpec;\n+import com.mojang.authlib.GameProfileRepository;\n+import com.mojang.authlib.minecraft.MinecraftSessionService;\n+import com.mojang.authlib.yggdrasil.YggdrasilAuthenticationService;\n+import org.spongepowered.asm.mixin.Mixin;\n+import org.spongepowered.asm.mixin.injection.At;\n+import org.spongepowered.asm.mixin.injection.Inject;\n+import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;\n+import org.spongepowered.asm.mixin.injection.callback.LocalCapture;\n+\n+import net.minecraft.resource.DataPackSettings;\n+import net.minecraft.resource.ResourcePackManager;\n+import net.minecraft.resource.ServerResourceManager;\n+import net.minecraft.server.Main;\n+import net.minecraft.server.dedicated.EulaReader;\n+import net.minecraft.server.dedicated.ServerPropertiesLoader;\n+import net.minecraft.util.UserCache;\n+import net.minecraft.util.dynamic.RegistryOps;\n+import net.minecraft.util.registry.DynamicRegistryManager;\n+import net.minecraft.world.level.storage.LevelStorage;\n+\n+import net.fabricmc.fabric.impl.registry.sync.PersistentDynamicRegistryHandler;\n+\n+@Mixin(Main.class)\n+public class MixinMain {\n+\t@SuppressWarnings(\"rawtypes\")\n+\t@Inject(method = \"main\", at = @At(value = \"INVOKE_ASSIGN\", target = \"Lnet/minecraft/util/dynamic/RegistryOps;of(Lcom/mojang/serialization/DynamicOps;Lnet/minecraft/resource/ResourceManager;Lnet/minecraft/util/registry/DynamicRegistryManager$Impl;)Lnet/minecraft/util/dynamic/RegistryOps;\"), locals = LocalCapture.CAPTURE_FAILHARD)\n+\tprivate static void main(String[] args, CallbackInfo ci, OptionParser optionParser, OptionSpec optionSpec, OptionSpec optionSpec2, OptionSpec optionSpec3, OptionSpec optionSpec4, OptionSpec optionSpec5, OptionSpec optionSpec6, OptionSpec optionSpec7, OptionSpec optionSpec8, OptionSpec optionSpec9, OptionSpec optionSpec10, OptionSpec optionSpec11, OptionSpec optionSpec12, OptionSpec optionSpec13, OptionSpec optionSpec14, OptionSet optionSet, DynamicRegistryManager.Impl impl, Path path, ServerPropertiesLoader serverPropertiesLoader, Path path2, EulaReader eulaReader, File file, YggdrasilAuthenticationService yggdrasilAuthenticationService, MinecraftSessionService minecraftSessionService, GameProfileRepository gameProfileRepository, UserCache userCache, String string, LevelStorage levelStorage, LevelStorage.Session session, DataPackSettings dataPackSettings, boolean bl, ResourcePackManager resourcePackManager, DataPackSettings dataPackSettings2, CompletableFuture completableFuture, ServerResourceManager serverResourceManager2, RegistryOps registryOps) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUyNTU1NA=="}, "originalCommit": {"oid": "9876f7f08883893ec6cb9c86eadb9dca5e680a40"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU0MzMxMg==", "bodyText": "Maybe quote what player said about this injection here on discord?", "url": "https://github.com/FabricMC/fabric/pull/1168#discussion_r525543312", "createdAt": "2020-11-17T21:41:50Z", "author": {"login": "i509VCB"}, "path": "fabric-registry-sync-v0/src/main/java/net/fabricmc/fabric/mixin/registry/sync/client/MixinMinecraftClient.java", "diffHunk": "@@ -44,4 +56,17 @@ public void disconnectAfter(Screen screen_1, CallbackInfo info) {\n \t\t\tFABRIC_LOGGER.warn(\"Failed to unmap Fabric registries!\", e);\n \t\t}\n \t}\n+\n+\t@Inject(method = \"createSaveProperties\", at = @At(value = \"INVOKE_ASSIGN\", target = \"Lnet/minecraft/util/dynamic/RegistryOps;of(Lcom/mojang/serialization/DynamicOps;Lnet/minecraft/resource/ResourceManager;Lnet/minecraft/util/registry/DynamicRegistryManager$Impl;)Lnet/minecraft/util/dynamic/RegistryOps;\"))\n+\tprivate static void createSaveProperties(LevelStorage.Session session, DynamicRegistryManager.Impl impl, ResourceManager resourceManager, DataPackSettings dataPackSettings, CallbackInfoReturnable<SaveProperties> cir) {\n+\t\tPath saveDir = ((AccessorLevelStorageSession) session).getDirectory();\n+\t\tPersistentDynamicRegistryHandler.remapDynamicRegistries(impl, saveDir);\n+\t}\n+\n+\t// synthetic in method_29607\n+\t@Inject(method = \"method_31125\", at = @At(value = \"INVOKE_ASSIGN\", target = \"Lnet/minecraft/util/dynamic/RegistryOps;of(Lcom/mojang/serialization/DynamicOps;Lnet/minecraft/resource/ResourceManager;Lnet/minecraft/util/registry/DynamicRegistryManager$Impl;)Lnet/minecraft/util/dynamic/RegistryOps;\"))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9876f7f08883893ec6cb9c86eadb9dca5e680a40"}, "originalPosition": 42}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b33b50a67418baccae967869557cf24709c2c078", "author": {"user": {"login": "modmuss50", "name": "modmuss50"}}, "url": "https://github.com/FabricMC/fabric/commit/b33b50a67418baccae967869557cf24709c2c078", "committedDate": "2020-11-18T20:01:16Z", "message": "Extra debugging + fix it not working"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "145b8306b66958e8ec0b9642aa47e8973db91483", "author": {"user": {"login": "modmuss50", "name": "modmuss50"}}, "url": "https://github.com/FabricMC/fabric/commit/145b8306b66958e8ec0b9642aa47e8973db91483", "committedDate": "2020-11-18T20:24:08Z", "message": "Fix build"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3a83d4adfc9db78a0fe095a1fec8a2bafd50f3ff", "author": {"user": {"login": "modmuss50", "name": "modmuss50"}}, "url": "https://github.com/FabricMC/fabric/commit/3a83d4adfc9db78a0fe095a1fec8a2bafd50f3ff", "committedDate": "2020-11-18T20:28:26Z", "message": "Minor tweaks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2b8a25496995114b2daaf749ecd79d33ddd54f2e", "author": {"user": {"login": "modmuss50", "name": "modmuss50"}}, "url": "https://github.com/FabricMC/fabric/commit/2b8a25496995114b2daaf749ecd79d33ddd54f2e", "committedDate": "2020-11-18T20:35:44Z", "message": "checkstyle ;)"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM0Nzg1MzE1", "url": "https://github.com/FabricMC/fabric/pull/1168#pullrequestreview-534785315", "createdAt": "2020-11-19T19:36:00Z", "commit": {"oid": "2b8a25496995114b2daaf749ecd79d33ddd54f2e"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxOTozNjowMFrOH2ujHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxOTozODo1N1rOH2upYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE0NzgwNg==", "bodyText": "This completely ignores outputTag. I'd move the version wrapping to read/writeCompoundTag.", "url": "https://github.com/FabricMC/fabric/pull/1168#discussion_r527147806", "createdAt": "2020-11-19T19:36:00Z", "author": {"login": "sfPlayer1"}, "path": "fabric-registry-sync-v0/src/main/java/net/fabricmc/fabric/impl/registry/sync/PersistentDynamicRegistryHandler.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.impl.registry.sync;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+\n+import net.minecraft.nbt.CompoundTag;\n+import net.minecraft.nbt.NbtIo;\n+import net.minecraft.util.Identifier;\n+import net.minecraft.util.registry.DynamicRegistryManager;\n+import net.minecraft.util.registry.MutableRegistry;\n+import net.minecraft.util.registry.Registry;\n+\n+public class PersistentDynamicRegistryHandler {\n+\tprivate static final Logger LOGGER = LogManager.getLogger();\n+\n+\tpublic static void remapDynamicRegistries(DynamicRegistryManager.Impl dynamicRegistryManager, Path saveDir) {\n+\t\tLOGGER.debug(\"Starting registry remap\");\n+\n+\t\tCompoundTag registryData;\n+\n+\t\ttry {\n+\t\t\tregistryData = remapDynamicRegistries(dynamicRegistryManager, readCompoundTag(getDataPath(saveDir)));\n+\t\t} catch (RemapException | IOException e) {\n+\t\t\t// TODO try the backups here?\n+\t\t\tthrow new RuntimeException(e);\n+\t\t}\n+\n+\t\twriteCompoundTag(registryData, getDataPath(saveDir));\n+\t}\n+\n+\t@NotNull\n+\tprivate static CompoundTag remapDynamicRegistries(DynamicRegistryManager.Impl dynamicRegistryManager, @Nullable CompoundTag existingTag) throws RemapException {\n+\t\tCompoundTag registries = new CompoundTag();\n+\n+\t\t// For now we only care about biomes, but lets keep our options open\n+\t\tCompoundTag biomeRegistryData = null;\n+\n+\t\tif (existingTag != null) {\n+\t\t\tbiomeRegistryData = existingTag.getCompound(Registry.BIOME_KEY.getValue().toString());\n+\t\t}\n+\n+\t\tMutableRegistry<?> registry = dynamicRegistryManager.get(Registry.BIOME_KEY);\n+\t\tCompoundTag biomeIdMap = remapRegistry(Registry.BIOME_KEY.getValue(), registry, biomeRegistryData);\n+\t\tregistries.put(Registry.BIOME_KEY.getValue().toString(), biomeIdMap);\n+\n+\t\tCompoundTag outputTag = new CompoundTag();\n+\t\toutputTag.putInt(\"version\", 1);\n+\t\toutputTag.put(\"registries\", registries);\n+\t\treturn registries;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b8a25496995114b2daaf749ecd79d33ddd54f2e"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE0ODY0OA==", "bodyText": "It may be desirable to fix the bug with vanilla datapacks too?", "url": "https://github.com/FabricMC/fabric/pull/1168#discussion_r527148648", "createdAt": "2020-11-19T19:37:32Z", "author": {"login": "sfPlayer1"}, "path": "fabric-registry-sync-v0/src/main/java/net/fabricmc/fabric/impl/registry/sync/PersistentDynamicRegistryHandler.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.impl.registry.sync;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+\n+import net.minecraft.nbt.CompoundTag;\n+import net.minecraft.nbt.NbtIo;\n+import net.minecraft.util.Identifier;\n+import net.minecraft.util.registry.DynamicRegistryManager;\n+import net.minecraft.util.registry.MutableRegistry;\n+import net.minecraft.util.registry.Registry;\n+\n+public class PersistentDynamicRegistryHandler {\n+\tprivate static final Logger LOGGER = LogManager.getLogger();\n+\n+\tpublic static void remapDynamicRegistries(DynamicRegistryManager.Impl dynamicRegistryManager, Path saveDir) {\n+\t\tLOGGER.debug(\"Starting registry remap\");\n+\n+\t\tCompoundTag registryData;\n+\n+\t\ttry {\n+\t\t\tregistryData = remapDynamicRegistries(dynamicRegistryManager, readCompoundTag(getDataPath(saveDir)));\n+\t\t} catch (RemapException | IOException e) {\n+\t\t\t// TODO try the backups here?\n+\t\t\tthrow new RuntimeException(e);\n+\t\t}\n+\n+\t\twriteCompoundTag(registryData, getDataPath(saveDir));\n+\t}\n+\n+\t@NotNull\n+\tprivate static CompoundTag remapDynamicRegistries(DynamicRegistryManager.Impl dynamicRegistryManager, @Nullable CompoundTag existingTag) throws RemapException {\n+\t\tCompoundTag registries = new CompoundTag();\n+\n+\t\t// For now we only care about biomes, but lets keep our options open\n+\t\tCompoundTag biomeRegistryData = null;\n+\n+\t\tif (existingTag != null) {\n+\t\t\tbiomeRegistryData = existingTag.getCompound(Registry.BIOME_KEY.getValue().toString());\n+\t\t}\n+\n+\t\tMutableRegistry<?> registry = dynamicRegistryManager.get(Registry.BIOME_KEY);\n+\t\tCompoundTag biomeIdMap = remapRegistry(Registry.BIOME_KEY.getValue(), registry, biomeRegistryData);\n+\t\tregistries.put(Registry.BIOME_KEY.getValue().toString(), biomeIdMap);\n+\n+\t\tCompoundTag outputTag = new CompoundTag();\n+\t\toutputTag.putInt(\"version\", 1);\n+\t\toutputTag.put(\"registries\", registries);\n+\t\treturn registries;\n+\t}\n+\n+\t/**\n+\t * Remaps a registry if existing data is passed in.\n+\t * Then writes out the ids in the registry (remapped or a new world).\n+\t * Keeps hold of the orphaned registry entries as to not overwrite them.\n+\t */\n+\tprivate static <T> CompoundTag remapRegistry(Identifier registryId, MutableRegistry<T> registry, @Nullable CompoundTag existingTag) throws RemapException {\n+\t\tif (!(registry instanceof RemappableRegistry)) {\n+\t\t\tthrow new UnsupportedOperationException(\"Cannot remap un re-mappable registry: \" + registryId.toString());\n+\t\t}\n+\n+\t\tboolean isModded = registry.getIds().stream().anyMatch(id -> !id.getNamespace().equals(\"minecraft\"));\n+\n+\t\t// The current registry might not be modded, but we might have previous changed vanilla ids that we should try and remap\n+\t\tif (existingTag != null && !isModded) {\n+\t\t\tisModded = existingTag.getKeys().stream()\n+\t\t\t\t\t.map(existingTag::getString)\n+\t\t\t\t\t.map(Identifier::new)\n+\t\t\t\t\t.anyMatch(id -> !id.getNamespace().equals(\"minecraft\"));\n+\t\t}\n+\n+\t\tif (LOGGER.isDebugEnabled()) {\n+\t\t\tif (existingTag == null) {\n+\t\t\t\tLOGGER.debug(\"No existing data found, assuming new registry with {} entries. modded = {}\", registry.getIds().size(), isModded);\n+\t\t\t} else {\n+\t\t\t\tLOGGER.debug(\"Existing registry data found. modded = {}\", isModded);\n+\n+\t\t\t\tfor (T entry : registry) {\n+\t\t\t\t\t//noinspection unchecked\n+\t\t\t\t\tIdentifier id = registry.getId(entry);\n+\t\t\t\t\tint rawId = registry.getRawId(entry);\n+\n+\t\t\t\t\tif (id == null) continue;\n+\n+\t\t\t\t\tif (existingTag.getKeys().contains(id.toString())) {\n+\t\t\t\t\t\tint existingRawId = existingTag.getInt(id.toString());\n+\n+\t\t\t\t\t\tif (rawId != existingRawId) {\n+\t\t\t\t\t\t\tLOGGER.debug(\"Remapping {} {} -> {}\", id.toString(), rawId, existingRawId);\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tLOGGER.debug(\"Using existing id for {} {}\", id.toString(), rawId);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tLOGGER.debug(\"Found new registry entry {}\", id.toString());\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\t// If we have some existing ids and the registry contains modded/datapack entries we remap the registry with those\n+\t\tif (existingTag != null && isModded) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b8a25496995114b2daaf749ecd79d33ddd54f2e"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE0OTQwOA==", "bodyText": "Do we want to validate rawId too? (skip < 0)", "url": "https://github.com/FabricMC/fabric/pull/1168#discussion_r527149408", "createdAt": "2020-11-19T19:38:57Z", "author": {"login": "sfPlayer1"}, "path": "fabric-registry-sync-v0/src/main/java/net/fabricmc/fabric/impl/registry/sync/PersistentDynamicRegistryHandler.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.impl.registry.sync;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+\n+import net.minecraft.nbt.CompoundTag;\n+import net.minecraft.nbt.NbtIo;\n+import net.minecraft.util.Identifier;\n+import net.minecraft.util.registry.DynamicRegistryManager;\n+import net.minecraft.util.registry.MutableRegistry;\n+import net.minecraft.util.registry.Registry;\n+\n+public class PersistentDynamicRegistryHandler {\n+\tprivate static final Logger LOGGER = LogManager.getLogger();\n+\n+\tpublic static void remapDynamicRegistries(DynamicRegistryManager.Impl dynamicRegistryManager, Path saveDir) {\n+\t\tLOGGER.debug(\"Starting registry remap\");\n+\n+\t\tCompoundTag registryData;\n+\n+\t\ttry {\n+\t\t\tregistryData = remapDynamicRegistries(dynamicRegistryManager, readCompoundTag(getDataPath(saveDir)));\n+\t\t} catch (RemapException | IOException e) {\n+\t\t\t// TODO try the backups here?\n+\t\t\tthrow new RuntimeException(e);\n+\t\t}\n+\n+\t\twriteCompoundTag(registryData, getDataPath(saveDir));\n+\t}\n+\n+\t@NotNull\n+\tprivate static CompoundTag remapDynamicRegistries(DynamicRegistryManager.Impl dynamicRegistryManager, @Nullable CompoundTag existingTag) throws RemapException {\n+\t\tCompoundTag registries = new CompoundTag();\n+\n+\t\t// For now we only care about biomes, but lets keep our options open\n+\t\tCompoundTag biomeRegistryData = null;\n+\n+\t\tif (existingTag != null) {\n+\t\t\tbiomeRegistryData = existingTag.getCompound(Registry.BIOME_KEY.getValue().toString());\n+\t\t}\n+\n+\t\tMutableRegistry<?> registry = dynamicRegistryManager.get(Registry.BIOME_KEY);\n+\t\tCompoundTag biomeIdMap = remapRegistry(Registry.BIOME_KEY.getValue(), registry, biomeRegistryData);\n+\t\tregistries.put(Registry.BIOME_KEY.getValue().toString(), biomeIdMap);\n+\n+\t\tCompoundTag outputTag = new CompoundTag();\n+\t\toutputTag.putInt(\"version\", 1);\n+\t\toutputTag.put(\"registries\", registries);\n+\t\treturn registries;\n+\t}\n+\n+\t/**\n+\t * Remaps a registry if existing data is passed in.\n+\t * Then writes out the ids in the registry (remapped or a new world).\n+\t * Keeps hold of the orphaned registry entries as to not overwrite them.\n+\t */\n+\tprivate static <T> CompoundTag remapRegistry(Identifier registryId, MutableRegistry<T> registry, @Nullable CompoundTag existingTag) throws RemapException {\n+\t\tif (!(registry instanceof RemappableRegistry)) {\n+\t\t\tthrow new UnsupportedOperationException(\"Cannot remap un re-mappable registry: \" + registryId.toString());\n+\t\t}\n+\n+\t\tboolean isModded = registry.getIds().stream().anyMatch(id -> !id.getNamespace().equals(\"minecraft\"));\n+\n+\t\t// The current registry might not be modded, but we might have previous changed vanilla ids that we should try and remap\n+\t\tif (existingTag != null && !isModded) {\n+\t\t\tisModded = existingTag.getKeys().stream()\n+\t\t\t\t\t.map(existingTag::getString)\n+\t\t\t\t\t.map(Identifier::new)\n+\t\t\t\t\t.anyMatch(id -> !id.getNamespace().equals(\"minecraft\"));\n+\t\t}\n+\n+\t\tif (LOGGER.isDebugEnabled()) {\n+\t\t\tif (existingTag == null) {\n+\t\t\t\tLOGGER.debug(\"No existing data found, assuming new registry with {} entries. modded = {}\", registry.getIds().size(), isModded);\n+\t\t\t} else {\n+\t\t\t\tLOGGER.debug(\"Existing registry data found. modded = {}\", isModded);\n+\n+\t\t\t\tfor (T entry : registry) {\n+\t\t\t\t\t//noinspection unchecked\n+\t\t\t\t\tIdentifier id = registry.getId(entry);\n+\t\t\t\t\tint rawId = registry.getRawId(entry);\n+\n+\t\t\t\t\tif (id == null) continue;\n+\n+\t\t\t\t\tif (existingTag.getKeys().contains(id.toString())) {\n+\t\t\t\t\t\tint existingRawId = existingTag.getInt(id.toString());\n+\n+\t\t\t\t\t\tif (rawId != existingRawId) {\n+\t\t\t\t\t\t\tLOGGER.debug(\"Remapping {} {} -> {}\", id.toString(), rawId, existingRawId);\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tLOGGER.debug(\"Using existing id for {} {}\", id.toString(), rawId);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tLOGGER.debug(\"Found new registry entry {}\", id.toString());\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\t// If we have some existing ids and the registry contains modded/datapack entries we remap the registry with those\n+\t\tif (existingTag != null && isModded) {\n+\t\t\tLOGGER.debug(\"Remapping {} with {} entries\", registryId, registry.getIds().size());\n+\t\t\tObject2IntMap<Identifier> idMap = new Object2IntOpenHashMap<>();\n+\n+\t\t\tfor (String key : existingTag.getKeys()) {\n+\t\t\t\tidMap.put(new Identifier(key), existingTag.getInt(key));\n+\t\t\t}\n+\n+\t\t\t((RemappableRegistry) registry).remap(registryId.toString(), idMap, RemappableRegistry.RemapMode.AUTHORITATIVE);\n+\t\t} else {\n+\t\t\tLOGGER.debug(\"Skipping remap of {}\", registryId);\n+\t\t}\n+\n+\t\t// Now start to build up what we are going to save out\n+\t\tCompoundTag registryTag = new CompoundTag();\n+\n+\t\t// Save all ids as they appear in the remapped, or new registry to disk even if not modded.\n+\t\tfor (T entry : registry) {\n+\t\t\t//noinspection unchecked\n+\t\t\tIdentifier id = registry.getId(entry);\n+\n+\t\t\tif (id == null) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\tint rawId = registry.getRawId(entry);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b8a25496995114b2daaf749ecd79d33ddd54f2e"}, "originalPosition": 153}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6ddde2ee51d972b43222a0c76dc0e215fe1cbd3a", "author": {"user": {"login": "modmuss50", "name": "modmuss50"}}, "url": "https://github.com/FabricMC/fabric/commit/6ddde2ee51d972b43222a0c76dc0e215fe1cbd3a", "committedDate": "2020-11-20T19:54:53Z", "message": "Improve comments + fix issues with tag reading/writing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f8dc85628a718803640695f67d71df9674bb2700", "author": {"user": {"login": "modmuss50", "name": "modmuss50"}}, "url": "https://github.com/FabricMC/fabric/commit/f8dc85628a718803640695f67d71df9674bb2700", "committedDate": "2020-11-21T12:58:52Z", "message": "Simplify mixin"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM1OTY4NDUy", "url": "https://github.com/FabricMC/fabric/pull/1168#pullrequestreview-535968452", "createdAt": "2020-11-21T14:03:38Z", "commit": {"oid": "f8dc85628a718803640695f67d71df9674bb2700"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3483, "cost": 1, "resetAt": "2021-11-01T14:20:25Z"}}}