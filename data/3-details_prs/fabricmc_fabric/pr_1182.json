{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI3MzA1MDI4", "number": 1182, "title": "Add WorldRenderEvents", "bodyText": "WorldRenderer.render is complicated and extensive but many mods need to target it for rendering.  This PR makes injection into world rendering more convenient and promotes compatibility.\nIt also solves the problem of Canvas or a similar mod replacing all or large chunks of vanilla code and thereby breaking mixin targets. A mod that breaks the mixin targets simply needs to invoke the event handlers itself at the appropriate time.\nThese events are based on my experience of adding Canvas compatibility hooks for about a dozen mods via reflection hacks.  (Sadly necessary because these events don't exist yet.) Many common use cases should be covered.\nThese events are also a useful extension point for third-party renderers.  For example, when Canvas is active  the VertexConsumerProvider instance exposed in the event context can be cast to an extended interface with additional functionality.\nThat said, these events are self-contained and have no dependency on Indigo, Canvas or the renderer API more generally.", "createdAt": "2020-11-25T09:29:55Z", "url": "https://github.com/FabricMC/fabric/pull/1182", "merged": true, "mergeCommit": {"oid": "c26373137e06bd0bc0298622eb2712381b86c3d1"}, "closed": true, "closedAt": "2020-12-30T16:44:24Z", "author": {"login": "grondag"}, "timelineItems": {"totalCount": 31, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdf6rw5gH2gAyNTI3MzA1MDI4OmUyYTZlYzI4MWI0YWYxMjU2NTM2ZWE2YWRhOTNmOWUyYWFlMDljNGQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdpeEA6AFqTU1ODczMTYyOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "e2a6ec281b4af1256536ea6ada93f9e2aae09c4d", "author": {"user": {"login": "grondag", "name": null}}, "url": "https://github.com/FabricMC/fabric/commit/e2a6ec281b4af1256536ea6ada93f9e2aae09c4d", "committedDate": "2020-11-25T09:11:11Z", "message": "Add WorldRenderEvents"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM4Mzg0MzYw", "url": "https://github.com/FabricMC/fabric/pull/1182#pullrequestreview-538384360", "createdAt": "2020-11-25T11:04:30Z", "commit": {"oid": "e2a6ec281b4af1256536ea6ada93f9e2aae09c4d"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxMTowNDozMFrOH5uPpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxMTowNDozMFrOH5uPpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDI4ODU0OQ==", "bodyText": "Typo", "url": "https://github.com/FabricMC/fabric/pull/1182#discussion_r530288549", "createdAt": "2020-11-25T11:04:30Z", "author": {"login": "ramidzkh"}, "path": "fabric-rendering-v1/src/main/java/net/fabricmc/fabric/mixin/client/rendering/MixinWorldRenderer.java", "diffHunk": "@@ -17,16 +17,152 @@\n package net.fabricmc.fabric.mixin.client.rendering;\n \n import org.spongepowered.asm.mixin.Mixin;\n+import org.spongepowered.asm.mixin.Shadow;\n import org.spongepowered.asm.mixin.injection.At;\n+import org.spongepowered.asm.mixin.injection.At.Shift;\n import org.spongepowered.asm.mixin.injection.Inject;\n import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;\n \n+import net.minecraft.block.BlockState;\n+import net.minecraft.client.MinecraftClient;\n+import net.minecraft.client.gl.ShaderEffect;\n+import net.minecraft.client.render.BufferBuilderStorage;\n+import net.minecraft.client.render.Camera;\n+import net.minecraft.client.render.Frustum;\n+import net.minecraft.client.render.GameRenderer;\n+import net.minecraft.client.render.LightmapTextureManager;\n+import net.minecraft.client.render.VertexConsumer;\n import net.minecraft.client.render.WorldRenderer;\n+import net.minecraft.client.util.math.MatrixStack;\n+import net.minecraft.client.world.ClientWorld;\n+import net.minecraft.entity.Entity;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.util.math.Matrix4f;\n \n import net.fabricmc.fabric.api.client.rendering.v1.InvalidateRenderStateCallback;\n+import net.fabricmc.fabric.api.client.rendering.v1.WorldRenderEvents;\n+import net.fabricmc.fabric.impl.client.rendering.WorldRenderContextImpl;\n \n @Mixin(WorldRenderer.class)\n public abstract class MixinWorldRenderer {\n+\t@Shadow private BufferBuilderStorage bufferBuilders;\n+\t@Shadow private ClientWorld world;\n+\t@Shadow private ShaderEffect transparencyShader;\n+\t@Shadow private MinecraftClient client;\n+\tprivate final WorldRenderContextImpl context = new WorldRenderContextImpl();\n+\tprivate boolean didRenderParticles;\n+\n+\t@Inject(method = \"render\", at = @At(\"HEAD\"))\n+\tprivate void beforeRender(MatrixStack matrices, float tickDelta, long limitTime, boolean renderBlockOutline, Camera camera, GameRenderer gameRenderer, LightmapTextureManager lightmapTextureManager, Matrix4f matrix4f, CallbackInfo ci) {\n+\t\tcontext.prepare((WorldRenderer) (Object) this, matrices, tickDelta, limitTime, renderBlockOutline, camera, gameRenderer, lightmapTextureManager, matrix4f, bufferBuilders.getEntityVertexConsumers(), world.getProfiler(), transparencyShader != null, world);\n+\t\tWorldRenderEvents.START.invoker().onStart(context);\n+\t\tdidRenderParticles = false;\n+\t}\n+\n+\t@Inject(method = \"setupTerrain\", at = @At(\"RETURN\"))\n+\tprivate void afterTerrainSetup(Camera camera, Frustum frustum, boolean hasForcedFrustum, int frame, boolean spectator, CallbackInfo ci) {\n+\t\tcontext.setFrustum(frustum);\n+\t\tWorldRenderEvents.AFTER_SETUP.invoker().afterSetup(context);\n+\t}\n+\n+\t@Inject(\n+\t\t\tmethod = \"render\",\n+\t\t\tat = @At(\n+\t\t\t\tvalue = \"INVOKE\",\n+\t\t\t\ttarget = \"Lnet/minecraft/client/render/WorldRenderer;renderLayer(Lnet/minecraft/client/render/RenderLayer;Lnet/minecraft/client/util/math/MatrixStack;DDD)V\",\n+\t\t\t\tordinal = 2,\n+\t\t\t\tshift = Shift.AFTER\n+\t\t\t)\n+\t)\n+\tprivate void afterTerrainSolid(CallbackInfo ci) {\n+\t\tWorldRenderEvents.BEFORE_ENTITIES.invoker().beforeEntities(context);\n+\t}\n+\n+\t@Inject(method = \"render\", at = @At(value = \"CONSTANT\", args = \"stringValue=blockentities\", ordinal = 0))\n+\tprivate void afterEntities(CallbackInfo ci) {\n+\t\tWorldRenderEvents.AFTER_ENTITIES.invoker().afterEntities(context);\n+\t}\n+\n+\t@Inject(\n+\t\t\tmethod = \"render\",\n+\t\t\tat = @At(\n+\t\t\t\tvalue = \"FIELD\",\n+\t\t\t\ttarget = \"Lnet/minecraft/client/MinecraftClient;crosshairTarget:Lnet/minecraft/util/hit/HitResult;\",\n+\t\t\t\tshift = At.Shift.AFTER,\n+\t\t\t\tordinal = 1\n+\t\t\t)\n+\t)\n+\tprivate void beforeRenderOutline(CallbackInfo ci) {\n+\t\tcontext.setHitResult(client.crosshairTarget);\n+\t\tWorldRenderEvents.BEFORE_BLOCK_OUTLINE.invoker().beforeBlockOutline(context);\n+\t}\n+\n+\t@Inject(method = \"drawBlockOutline\", at = @At(\"HEAD\"), cancellable = true)\n+\tprivate void onDrawBlockOutline(MatrixStack matrixStack, VertexConsumer vertexConsumer, Entity entity, double cameraX, double cameraY, double cameraZ, BlockPos blockPos, BlockState blockState, CallbackInfo ci) {\n+\t\tif (context.didCancelDefaultBlockOutline()) {\n+\t\t\t// Was cancelled before we got here, so does not count as\n+\t\t\t// cancelled in later events, per contract of the API.\n+\t\t\tcontext.resetDefaultBlockOutline();\n+\t\t\tci.cancel();\n+\t\t} else {\n+\t\t\tcontext.prepareBlockOutline(vertexConsumer, entity, cameraX, cameraY, cameraZ, blockPos, blockState);\n+\t\t\tWorldRenderEvents.BLOCK_OUTLINE.invoker().onBlockOutline(context);\n+\n+\t\t\t// If default outline render was cancelled we leave that indicator intact\n+\t\t\tif (context.didCancelDefaultBlockOutline()) {\n+\t\t\t\tci.cancel();\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@Inject(\n+\t\t\tmethod = \"render\",\n+\t\t\tat = @At(\n+\t\t\t\tvalue = \"INVOKE\",\n+\t\t\t\ttarget = \"Lnet/minecraft/client/render/debug/DebugRenderer;render(Lnet/minecraft/client/util/math/MatrixStack;Lnet/minecraft/client/render/VertexConsumerProvider$Immediate;DDD)V\",\n+\t\t\t\tordinal = 0\n+\t\t\t)\n+\t)\n+\tprivate void beforeDebugRender(CallbackInfo ci) {\n+\t\tWorldRenderEvents.BEFORE_DEBUG_RENDER.invoker().beforeDebugRender(context);\n+\t}\n+\n+\t@Inject(\n+\t\t\tmethod = \"render\",\n+\t\t\tat = @At(\n+\t\t\t\tvalue = \"INVOKE\",\n+\t\t\t\ttarget = \"Lnet/minecraft/client/particle/ParticleManager;renderParticles(Lnet/minecraft/client/util/math/MatrixStack;Lnet/minecraft/client/render/VertexConsumerProvider$Immediate;Lnet/minecraft/client/render/LightmapTextureManager;Lnet/minecraft/client/render/Camera;F)V\"\n+\t\t\t)\n+\t)\n+\tprivate void onRenderParticles(CallbackInfo ci) {\n+\t\t// set a flag so we know the next pushMatrix call is after particles\n+\t\tdidRenderParticles = true;\n+\t}\n+\n+\t@Inject(method = \"render\", at = @At(value = \"INVOKE\", target = \"Lcom/mojang/blaze3d/systems/RenderSystem;pushMatrix()V\"))\n+\tprivate void beforeClouds(CallbackInfo ci) {\n+\t\tif (didRenderParticles) {\n+\t\t\tdidRenderParticles = false;\n+\t\t\tWorldRenderEvents.AFTER_TRANSLUCENT.invoker().afterTranslucent(context);\n+\t\t}\n+\t}\n+\n+\t@Inject(\n+\t\t\tmethod = \"render\",\n+\t\t\tat = @At(\n+\t\t\t\tvalue = \"INVOKE\",\n+\t\t\t\ttarget = \"Lnet/minecraft/client/render/WorldRenderer;renderChunkDebugInfo(Lnet/minecraft/client/render/Camera;)V\"\n+\t\t\t)\n+\t)\n+\tprivate void onChunkDebugRender(CallbackInfo ci) {\n+\t\tWorldRenderEvents.LAST.invoker().onLast(context);\n+\t}\n+\n+\t@Inject(method = \"render\", at = @At(\"RETURN\"))\n+\tprivate void afternRender(CallbackInfo ci) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2a6ec281b4af1256536ea6ada93f9e2aae09c4d"}, "originalPosition": 146}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM4Mzg3MjM2", "url": "https://github.com/FabricMC/fabric/pull/1182#pullrequestreview-538387236", "createdAt": "2020-11-25T11:08:02Z", "commit": {"oid": "e2a6ec281b4af1256536ea6ada93f9e2aae09c4d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxMTowODowMlrOH5uYUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxMTowODowMlrOH5uYUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDI5MDc3MQ==", "bodyText": "typo", "url": "https://github.com/FabricMC/fabric/pull/1182#discussion_r530290771", "createdAt": "2020-11-25T11:08:02Z", "author": {"login": "BoogieMonster1O1"}, "path": "fabric-rendering-v1/src/main/java/net/fabricmc/fabric/api/client/rendering/v1/WorldRenderContext.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.client.rendering.v1;\n+\n+import org.jetbrains.annotations.Nullable;\n+\n+import net.minecraft.block.BlockState;\n+import net.minecraft.client.MinecraftClient;\n+import net.minecraft.client.render.Camera;\n+import net.minecraft.client.render.Frustum;\n+import net.minecraft.client.render.GameRenderer;\n+import net.minecraft.client.render.LightmapTextureManager;\n+import net.minecraft.client.render.VertexConsumer;\n+import net.minecraft.client.render.VertexConsumerProvider;\n+import net.minecraft.client.render.WorldRenderer;\n+import net.minecraft.client.util.math.MatrixStack;\n+import net.minecraft.client.world.ClientWorld;\n+import net.minecraft.entity.Entity;\n+import net.minecraft.util.hit.HitResult;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.util.math.Matrix4f;\n+import net.minecraft.util.profiler.Profiler;\n+\n+/**\n+ * Except as noted below, the properties exposed here match the parameters passed to\n+ * {@link WorldRenderer#render(MatrixStack, float, long, boolean, Camera, GameRenderer, LightmapTextureManager, Matrix4f)}.\n+ */\n+public interface WorldRenderContext {\n+\t/**\n+\t * The world renderer instance doing the rendering and invoking the event.\n+\t *\n+\t * @return WorldRenderer instance invoking the event\n+\t */\n+\tWorldRenderer worldRenderer();\n+\n+\tMatrixStack matrixStack();\n+\n+\tfloat tickDelta();\n+\n+\tlong limitTime();\n+\n+\tboolean blockOutlines();\n+\n+\tCamera camera();\n+\n+\tGameRenderer gameRenderer();\n+\n+\tLightmapTextureManager lightmapTextureManager();\n+\n+\tMatrix4f projectionMatrix();\n+\n+\t/**\n+\t * Convenient access to {WorldRenderer.world}.\n+\t *\n+\t * @return world renderer's client world instance\n+\t */\n+\tClientWorld world();\n+\n+\t/**\n+\t * Convenient access to game performance profiler.\n+\t *\n+\t * @return the active profiler\n+\t */\n+\tProfiler profiler();\n+\n+\t/**\n+\t * Test to know if \"fabulous\" graphics mode is enabled.\n+\t *\n+\t * <p>Use this for renders that need to render on top of all translucency to activate or deactivate different\n+\t * event handlers to get optimal depth testing results. When fabulous is off, it may be better to render\n+\t * during {@code WorldRenderLastCallback} after clouds and weather are drawn. Conversely, when fabulous mode is on,\n+\t * it may be better to draw during {@code WorldRenderPostTranslucentCallback}, before the fabulous mode composite\n+\t * shader runs, depending on which translucent buffer is being targeted.\n+\t *\n+\t * @return {@code true} when \"fabulous\" graphics mode is enabled.\n+\t */\n+\tboolean advancedTranslucency();\n+\n+\tpublic interface Drawable {\n+\t\t/**\n+\t\t * The {@code VertexConsumerProvider} instance being used by the world renderer for most non-terrain renders.\n+\t\t * Generally this will be better for most use cases because quads for the same layer can be buffered\n+\t\t * incrementally and then drawn all at once by the world renderer.\n+\t\t *\n+\t\t * <p>IMPORTANT - all vertex coordinates sent to consumers should be relative to the camera to\n+\t\t * be consistent with other quads emitted by the world renderer and other mods.  If this isn't\n+\t\t * possible, caller should use a separate \"immediate\" instance.\n+\t\t *\n+\t\t * <p>This property is not exposed before {@link WorldRenderEvents#BEFORE_ENTITIES} or after\n+\t\t * {@link WorldRenderEvents#BEFORE_DEBUG_RENDER} because the consumer buffers are not available before or\n+\t\t * drawn after that in vanilla world rendering.  Renders that cannot draw in one of the supported events\n+\t\t * must be drawn directly to the frame buffer, preferably in {@link WorldRenderEvents#LAST} to avoid being\n+\t\t * overdrawn or cleared.\n+\t\t */\n+\t\tVertexConsumerProvider consumers();\n+\t}\n+\n+\t/**\n+\t * Conveys WorldRenderer state to event handlers after invocation.\n+\t * Includes view frustum, which is not available then.\n+\t */\n+\tpublic interface AfterFrustum {\n+\t\tFrustum frustum();\n+\t}\n+\n+\t/**\n+\t * Used in the block breaking callback to convey information on\n+\t * ray trace hit and accept cancellation of default outline render.\n+\t */\n+\tpublic interface PreBlockOutline {\n+\t\t/**\n+\t\t * The game object currently under the crosshair target. Normally\n+\t\t * equivalent to {@link MinecraftClient#crosshairTarget}.\n+\t\t * Provided for convenience.\n+\t\t */\n+\t\t@Nullable HitResult hitResult();\n+\n+\t\t/**\n+\t\t * Call to prevent the default block outline from rendering.\n+\t\t * Use this for event handlers that fully replace the vanilla\n+\t\t * block outline render.\n+\t\t *\n+\t\t * <p>The effect of this method depends on the event from which it is called:\n+\t\t *\n+\t\t * <p>In {@code BEFORE_BLOCK_RENDER} this prevents invocation of\n+\t\t * the {@code BLOCK_RENDER} event and {@link AfterBlockOutline#didCancelDefaultBlockOutline()}\n+\t\t * will be {@code false} in later-stage event invocations. It (obviously)\n+\t\t * also prevents the default outline render from running.\n+\t\t *\n+\t\t * <p>In {@code BLOCK_REDER} this prevents the default outline render", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2a6ec281b4af1256536ea6ada93f9e2aae09c4d"}, "originalPosition": 144}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM4NDE0MzQ0", "url": "https://github.com/FabricMC/fabric/pull/1182#pullrequestreview-538414344", "createdAt": "2020-11-25T11:45:16Z", "commit": {"oid": "e2a6ec281b4af1256536ea6ada93f9e2aae09c4d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxMTo0NToxNlrOH5vuVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxMTo0NToxNlrOH5vuVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDMxMjc5MQ==", "bodyText": "Typo :)", "url": "https://github.com/FabricMC/fabric/pull/1182#discussion_r530312791", "createdAt": "2020-11-25T11:45:16Z", "author": {"login": "leocth"}, "path": "fabric-rendering-v1/src/main/java/net/fabricmc/fabric/api/client/rendering/v1/WorldRenderContext.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.client.rendering.v1;\n+\n+import org.jetbrains.annotations.Nullable;\n+\n+import net.minecraft.block.BlockState;\n+import net.minecraft.client.MinecraftClient;\n+import net.minecraft.client.render.Camera;\n+import net.minecraft.client.render.Frustum;\n+import net.minecraft.client.render.GameRenderer;\n+import net.minecraft.client.render.LightmapTextureManager;\n+import net.minecraft.client.render.VertexConsumer;\n+import net.minecraft.client.render.VertexConsumerProvider;\n+import net.minecraft.client.render.WorldRenderer;\n+import net.minecraft.client.util.math.MatrixStack;\n+import net.minecraft.client.world.ClientWorld;\n+import net.minecraft.entity.Entity;\n+import net.minecraft.util.hit.HitResult;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.util.math.Matrix4f;\n+import net.minecraft.util.profiler.Profiler;\n+\n+/**\n+ * Except as noted below, the properties exposed here match the parameters passed to\n+ * {@link WorldRenderer#render(MatrixStack, float, long, boolean, Camera, GameRenderer, LightmapTextureManager, Matrix4f)}.\n+ */\n+public interface WorldRenderContext {\n+\t/**\n+\t * The world renderer instance doing the rendering and invoking the event.\n+\t *\n+\t * @return WorldRenderer instance invoking the event\n+\t */\n+\tWorldRenderer worldRenderer();\n+\n+\tMatrixStack matrixStack();\n+\n+\tfloat tickDelta();\n+\n+\tlong limitTime();\n+\n+\tboolean blockOutlines();\n+\n+\tCamera camera();\n+\n+\tGameRenderer gameRenderer();\n+\n+\tLightmapTextureManager lightmapTextureManager();\n+\n+\tMatrix4f projectionMatrix();\n+\n+\t/**\n+\t * Convenient access to {WorldRenderer.world}.\n+\t *\n+\t * @return world renderer's client world instance\n+\t */\n+\tClientWorld world();\n+\n+\t/**\n+\t * Convenient access to game performance profiler.\n+\t *\n+\t * @return the active profiler\n+\t */\n+\tProfiler profiler();\n+\n+\t/**\n+\t * Test to know if \"fabulous\" graphics mode is enabled.\n+\t *\n+\t * <p>Use this for renders that need to render on top of all translucency to activate or deactivate different\n+\t * event handlers to get optimal depth testing results. When fabulous is off, it may be better to render\n+\t * during {@code WorldRenderLastCallback} after clouds and weather are drawn. Conversely, when fabulous mode is on,\n+\t * it may be better to draw during {@code WorldRenderPostTranslucentCallback}, before the fabulous mode composite\n+\t * shader runs, depending on which translucent buffer is being targeted.\n+\t *\n+\t * @return {@code true} when \"fabulous\" graphics mode is enabled.\n+\t */\n+\tboolean advancedTranslucency();\n+\n+\tpublic interface Drawable {\n+\t\t/**\n+\t\t * The {@code VertexConsumerProvider} instance being used by the world renderer for most non-terrain renders.\n+\t\t * Generally this will be better for most use cases because quads for the same layer can be buffered\n+\t\t * incrementally and then drawn all at once by the world renderer.\n+\t\t *\n+\t\t * <p>IMPORTANT - all vertex coordinates sent to consumers should be relative to the camera to\n+\t\t * be consistent with other quads emitted by the world renderer and other mods.  If this isn't\n+\t\t * possible, caller should use a separate \"immediate\" instance.\n+\t\t *\n+\t\t * <p>This property is not exposed before {@link WorldRenderEvents#BEFORE_ENTITIES} or after\n+\t\t * {@link WorldRenderEvents#BEFORE_DEBUG_RENDER} because the consumer buffers are not available before or\n+\t\t * drawn after that in vanilla world rendering.  Renders that cannot draw in one of the supported events\n+\t\t * must be drawn directly to the frame buffer, preferably in {@link WorldRenderEvents#LAST} to avoid being\n+\t\t * overdrawn or cleared.\n+\t\t */\n+\t\tVertexConsumerProvider consumers();\n+\t}\n+\n+\t/**\n+\t * Conveys WorldRenderer state to event handlers after invocation.\n+\t * Includes view frustum, which is not available then.\n+\t */\n+\tpublic interface AfterFrustum {\n+\t\tFrustum frustum();\n+\t}\n+\n+\t/**\n+\t * Used in the block breaking callback to convey information on\n+\t * ray trace hit and accept cancellation of default outline render.\n+\t */\n+\tpublic interface PreBlockOutline {\n+\t\t/**\n+\t\t * The game object currently under the crosshair target. Normally\n+\t\t * equivalent to {@link MinecraftClient#crosshairTarget}.\n+\t\t * Provided for convenience.\n+\t\t */\n+\t\t@Nullable HitResult hitResult();\n+\n+\t\t/**\n+\t\t * Call to prevent the default block outline from rendering.\n+\t\t * Use this for event handlers that fully replace the vanilla\n+\t\t * block outline render.\n+\t\t *\n+\t\t * <p>The effect of this method depends on the event from which it is called:\n+\t\t *\n+\t\t * <p>In {@code BEFORE_BLOCK_RENDER} this prevents invocation of\n+\t\t * the {@code BLOCK_RENDER} event and {@link AfterBlockOutline#didCancelDefaultBlockOutline()}\n+\t\t * will be {@code false} in later-stage event invocations. It (obviously)\n+\t\t * also prevents the default outline render from running.\n+\t\t *\n+\t\t * <p>In {@code BLOCK_REDER} this prevents the default outline render\n+\t\t * from running and {@link AfterBlockOutline#didCancelDefaultBlockOutline()}\n+\t\t * will be {@code true} in later-stage event invocations.\n+\t\t *\n+\t\t * <p>In both cases, this method is idempotent - calling it from more\n+\t\t * than one event subscriber has the same effect as calling it once.\n+\t\t * All event handlers within the same event invocation will always\n+\t\t * execute and the cancellation status cannot be inspected during the\n+\t\t * block outline render events.\n+\t\t */\n+\t\tvoid cancelDefaultBlockOutline();\n+\t}\n+\n+\t/**\n+\t * Used in {@code BLOCK_OUTLINE} to convey the parameters normally sent to\n+\t * {@code Worldrenderer.drawBlockOutline}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2a6ec281b4af1256536ea6ada93f9e2aae09c4d"}, "originalPosition": 159}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bfeeffa72cb53676a7f849ba488574474df9b6c7", "author": {"user": {"login": "grondag", "name": null}}, "url": "https://github.com/FabricMC/fabric/commit/bfeeffa72cb53676a7f849ba488574474df9b6c7", "committedDate": "2020-11-25T16:15:14Z", "message": "Fix typos"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQwMTk5MzQz", "url": "https://github.com/FabricMC/fabric/pull/1182#pullrequestreview-540199343", "createdAt": "2020-11-27T21:53:49Z", "commit": {"oid": "bfeeffa72cb53676a7f849ba488574474df9b6c7"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QyMTo1Mzo0OVrOH7KH9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QyMTo1Mzo0OVrOH7KH9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTc5MzkwOA==", "bodyText": "Add @unique on added fields.", "url": "https://github.com/FabricMC/fabric/pull/1182#discussion_r531793908", "createdAt": "2020-11-27T21:53:49Z", "author": {"login": "modmuss50"}, "path": "fabric-rendering-v1/src/main/java/net/fabricmc/fabric/mixin/client/rendering/MixinWorldRenderer.java", "diffHunk": "@@ -17,16 +17,152 @@\n package net.fabricmc.fabric.mixin.client.rendering;\n \n import org.spongepowered.asm.mixin.Mixin;\n+import org.spongepowered.asm.mixin.Shadow;\n import org.spongepowered.asm.mixin.injection.At;\n+import org.spongepowered.asm.mixin.injection.At.Shift;\n import org.spongepowered.asm.mixin.injection.Inject;\n import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;\n \n+import net.minecraft.block.BlockState;\n+import net.minecraft.client.MinecraftClient;\n+import net.minecraft.client.gl.ShaderEffect;\n+import net.minecraft.client.render.BufferBuilderStorage;\n+import net.minecraft.client.render.Camera;\n+import net.minecraft.client.render.Frustum;\n+import net.minecraft.client.render.GameRenderer;\n+import net.minecraft.client.render.LightmapTextureManager;\n+import net.minecraft.client.render.VertexConsumer;\n import net.minecraft.client.render.WorldRenderer;\n+import net.minecraft.client.util.math.MatrixStack;\n+import net.minecraft.client.world.ClientWorld;\n+import net.minecraft.entity.Entity;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.util.math.Matrix4f;\n \n import net.fabricmc.fabric.api.client.rendering.v1.InvalidateRenderStateCallback;\n+import net.fabricmc.fabric.api.client.rendering.v1.WorldRenderEvents;\n+import net.fabricmc.fabric.impl.client.rendering.WorldRenderContextImpl;\n \n @Mixin(WorldRenderer.class)\n public abstract class MixinWorldRenderer {\n+\t@Shadow private BufferBuilderStorage bufferBuilders;\n+\t@Shadow private ClientWorld world;\n+\t@Shadow private ShaderEffect transparencyShader;\n+\t@Shadow private MinecraftClient client;\n+\tprivate final WorldRenderContextImpl context = new WorldRenderContextImpl();\n+\tprivate boolean didRenderParticles;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bfeeffa72cb53676a7f849ba488574474df9b6c7"}, "originalPosition": 37}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQwMjAwNzUw", "url": "https://github.com/FabricMC/fabric/pull/1182#pullrequestreview-540200750", "createdAt": "2020-11-27T22:03:03Z", "commit": {"oid": "bfeeffa72cb53676a7f849ba488574474df9b6c7"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QyMjowMzowM1rOH7KNqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QyMjoxMDoyNVrOH7KSRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTc5NTM2OQ==", "bodyText": "AfterBlockOutline?", "url": "https://github.com/FabricMC/fabric/pull/1182#discussion_r531795369", "createdAt": "2020-11-27T22:03:03Z", "author": {"login": "i509VCB"}, "path": "fabric-rendering-v1/src/main/java/net/fabricmc/fabric/api/client/rendering/v1/WorldRenderEvents.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.client.rendering.v1;\n+\n+import net.minecraft.client.render.WorldRenderer;\n+\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+\n+/**\n+ * Mods should use these events to introduce custom rendering during {@link WorldRenderer#render(net.minecraft.client.util.math.MatrixStack, float, long, boolean, net.minecraft.client.render.Camera, net.minecraft.client.render.GameRenderer, net.minecraft.client.render.LightmapTextureManager, net.minecraft.util.math.Matrix4f)}\n+ * without adding complicated and conflict-prone injections there.  Using these events also enables 3rd-party renderers\n+ * that make large-scale changes to rendering maintain compatibility by calling any broken even invokers directly.\n+ *\n+ * <p>These events are not dependent on the Fabric rendering API or Indigo but work when those are present.\n+ */\n+public final class WorldRenderEvents {\n+\tprivate WorldRenderEvents() { }\n+\n+\t/**\n+\t * Called before world rendering executes. Input parameters are available but frustum is not.\n+\t * Use this event instead of injecting to the HEAD of {@link WorldRenderer#render} to avoid\n+\t * compatibility problems with 3rd-party renderer implementations.\n+\t *\n+\t * <p>Use for setup of state that is needed during the world render call that\n+\t * does not depend on the view frustum.\n+\t */\n+\tpublic static final Event<Start> START = EventFactory.createArrayBacked(Start.class, callbacks -> context -> {\n+\t\tfor (final Start callback : callbacks) {\n+\t\t\tcallback.onStart(context);\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called after view Frustum is computed and all render chunks to be rendered are\n+\t * identified and rebuilt but before chunks are uploaded to GPU.\n+\t *\n+\t * <p>Use for setup of state that depends on view frustum.\n+\t */\n+\tpublic static final Event<AfterSetup> AFTER_SETUP = EventFactory.createArrayBacked(AfterSetup.class, callbacks -> context -> {\n+\t\tfor (final AfterSetup callback : callbacks) {\n+\t\t\tcallback.afterSetup(context);\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called after the Solid, Cutout and Cutout Mipped terrain layers have been output to the framebuffer.\n+\t *\n+\t * <p>Use to render non-translucent terrain to the framebuffer.\n+\t *\n+\t * <p>Note that 3rd-party renderers may combine these passes or otherwise alter the\n+\t * rendering pipeline for sake of performance or features. This can break direct writes to the\n+\t * framebuffer.  Use this event for cases that cannot be satisfied by FabricBakedModel,\n+\t * BlockEntityRenderer or other existing abstraction. If at all possible, use an existing terrain\n+\t * RenderLayer instead of outputting to the framebuffer directly with GL calls.\n+\t *\n+\t * <p>The consumer is responsible for setup and tear down of GL state appropriate for the intended output.\n+\t *\n+\t * <p>Because solid and cutout quads are depth-tested, order of output does not matter except to improve\n+\t * culling performance, which should not be significant after primary terrain rendering. This means\n+\t * mods that currently hook calls to individual render layers can simply execute them all at once when\n+\t * the event is called.\n+\t *\n+\t * <p>This event fires before entities and block entities are rendered and may be useful to prepare them.\n+\t */\n+\tpublic static final Event<BeforeEntities> BEFORE_ENTITIES = EventFactory.createArrayBacked(BeforeEntities.class, callbacks -> context -> {\n+\t\tfor (final BeforeEntities callback : callbacks) {\n+\t\t\tcallback.beforeEntities(context);\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called after entities are rendered and solid entity layers\n+\t * have been drawn to the main frame buffer target, before\n+\t * block entity rendering begins.\n+\t *\n+\t * <p>Use for global block entity render setup, or\n+\t * to append block-related quads to the entity consumers using the\n+\t * {@VertexConsumerProvider} from the provided context. This\n+\t * will generally give better (if not perfect) results\n+\t * for non-terrain translucency vs. drawing directly later on.\n+\t */\n+\tpublic static final Event<AfterEntities> AFTER_ENTITIES = EventFactory.createArrayBacked(AfterEntities.class, callbacks -> context -> {\n+\t\tfor (final AfterEntities callback : callbacks) {\n+\t\t\tcallback.afterEntities(context);\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called before default block outline rendering and before checks are\n+\t * done to determine if it should happen. Can optionally cancel the default\n+\t * rendering but all event handlers will always be called.\n+\t *\n+\t * <p>Use this to decorate or replace the default block outline rendering\n+\t * for specific modded blocks or when the need for a block outline render\n+\t * would not be detected.  Normally, outline rendering will not happen for\n+\t * entities or other game objects that do not register a block-type hit.\n+\t *\n+\t * <p>Canceling the default block outline render has no effect on other\n+\t * event subscribers - all subscribers will always be called. Generally, modded\n+\t * block outline renders are specific to that mod's content or additive\n+\t * and thus should not interfere with each other.\n+\t *\n+\t * <p>This event should NOT be used for general-purpose replacement of\n+\t * the default block outline rendering because it will interfere with mod-specific\n+\t * renders.  Mods that replace the default block outline should instead\n+\t * subscribe to {@link #BLOCK_OUTLINE}.\n+\t */\n+\tpublic static final Event<BeforeBlockOutline> BEFORE_BLOCK_OUTLINE = EventFactory.createArrayBacked(BeforeBlockOutline.class, callbacks -> context -> {\n+\t\tfor (final BeforeBlockOutline callback : callbacks) {\n+\t\t\tcallback.beforeBlockOutline(context);\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called after block outline render checks are made and before the\n+\t * default block outline render runs.  Will NOT be called if the default outline\n+\t * render was cancelled in {@link #BEFORE_BLOCK_OUTLINE}.\n+\t *\n+\t * <p>Use this to replace the default block outline rendering entirely.\n+\t * Canceling the default outline render here avoids interfering\n+\t * with mod-specific outline renders that cannot be well-handled by a\n+\t * general-purpose outline renderer.\n+\t *\n+\t * <p>Default block outline rendering does not have to happen here.  If a custom\n+\t * default outline effect benefits from being drawn at a later stage it can\n+\t * be cancelled here and then drawn in {@link #AFTER_TRANSLUCENT} or {@link #LAST}\n+\t * if desired. To facilitate this pattern, those events can check\n+\t * {@link WorldRenderContext.AfterBlockOutline#didCancelDefaultBlockOutline()}.\n+\t */\n+\tpublic static final Event<BlockOutline> BLOCK_OUTLINE = EventFactory.createArrayBacked(BlockOutline.class, callbacks -> context -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bfeeffa72cb53676a7f849ba488574474df9b6c7"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTc5NjU0OA==", "bodyText": "Could all the classes be marked as client only? @Environment(EnvType.CLIENT)", "url": "https://github.com/FabricMC/fabric/pull/1182#discussion_r531796548", "createdAt": "2020-11-27T22:10:25Z", "author": {"login": "i509VCB"}, "path": "fabric-rendering-v1/src/main/java/net/fabricmc/fabric/api/client/rendering/v1/WorldRenderContext.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.client.rendering.v1;\n+\n+import org.jetbrains.annotations.Nullable;\n+\n+import net.minecraft.block.BlockState;\n+import net.minecraft.client.MinecraftClient;\n+import net.minecraft.client.render.Camera;\n+import net.minecraft.client.render.Frustum;\n+import net.minecraft.client.render.GameRenderer;\n+import net.minecraft.client.render.LightmapTextureManager;\n+import net.minecraft.client.render.VertexConsumer;\n+import net.minecraft.client.render.VertexConsumerProvider;\n+import net.minecraft.client.render.WorldRenderer;\n+import net.minecraft.client.util.math.MatrixStack;\n+import net.minecraft.client.world.ClientWorld;\n+import net.minecraft.entity.Entity;\n+import net.minecraft.util.hit.HitResult;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.util.math.Matrix4f;\n+import net.minecraft.util.profiler.Profiler;\n+\n+/**\n+ * Except as noted below, the properties exposed here match the parameters passed to\n+ * {@link WorldRenderer#render(MatrixStack, float, long, boolean, Camera, GameRenderer, LightmapTextureManager, Matrix4f)}.\n+ */\n+public interface WorldRenderContext {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bfeeffa72cb53676a7f849ba488574474df9b6c7"}, "originalPosition": 42}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQwMjEwNzI3", "url": "https://github.com/FabricMC/fabric/pull/1182#pullrequestreview-540210727", "createdAt": "2020-11-27T23:30:56Z", "commit": {"oid": "bfeeffa72cb53676a7f849ba488574474df9b6c7"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QyMzozMDo1NlrOH7K7Pw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QyMzozNjo0OFrOH7K97Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTgwNzAzOQ==", "bodyText": "I think the naming should be more explicit being like getWorldRenderer.", "url": "https://github.com/FabricMC/fabric/pull/1182#discussion_r531807039", "createdAt": "2020-11-27T23:30:56Z", "author": {"login": "i509VCB"}, "path": "fabric-rendering-v1/src/main/java/net/fabricmc/fabric/api/client/rendering/v1/WorldRenderContext.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.client.rendering.v1;\n+\n+import org.jetbrains.annotations.Nullable;\n+\n+import net.minecraft.block.BlockState;\n+import net.minecraft.client.MinecraftClient;\n+import net.minecraft.client.render.Camera;\n+import net.minecraft.client.render.Frustum;\n+import net.minecraft.client.render.GameRenderer;\n+import net.minecraft.client.render.LightmapTextureManager;\n+import net.minecraft.client.render.VertexConsumer;\n+import net.minecraft.client.render.VertexConsumerProvider;\n+import net.minecraft.client.render.WorldRenderer;\n+import net.minecraft.client.util.math.MatrixStack;\n+import net.minecraft.client.world.ClientWorld;\n+import net.minecraft.entity.Entity;\n+import net.minecraft.util.hit.HitResult;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.util.math.Matrix4f;\n+import net.minecraft.util.profiler.Profiler;\n+\n+/**\n+ * Except as noted below, the properties exposed here match the parameters passed to\n+ * {@link WorldRenderer#render(MatrixStack, float, long, boolean, Camera, GameRenderer, LightmapTextureManager, Matrix4f)}.\n+ */\n+public interface WorldRenderContext {\n+\t/**\n+\t * The world renderer instance doing the rendering and invoking the event.\n+\t *\n+\t * @return WorldRenderer instance invoking the event\n+\t */\n+\tWorldRenderer worldRenderer();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bfeeffa72cb53676a7f849ba488574474df9b6c7"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTgwNzEyNQ==", "bodyText": "shouldCancelDefaultBlockOutline", "url": "https://github.com/FabricMC/fabric/pull/1182#discussion_r531807125", "createdAt": "2020-11-27T23:31:43Z", "author": {"login": "i509VCB"}, "path": "fabric-rendering-v1/src/main/java/net/fabricmc/fabric/api/client/rendering/v1/WorldRenderContext.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.client.rendering.v1;\n+\n+import org.jetbrains.annotations.Nullable;\n+\n+import net.minecraft.block.BlockState;\n+import net.minecraft.client.MinecraftClient;\n+import net.minecraft.client.render.Camera;\n+import net.minecraft.client.render.Frustum;\n+import net.minecraft.client.render.GameRenderer;\n+import net.minecraft.client.render.LightmapTextureManager;\n+import net.minecraft.client.render.VertexConsumer;\n+import net.minecraft.client.render.VertexConsumerProvider;\n+import net.minecraft.client.render.WorldRenderer;\n+import net.minecraft.client.util.math.MatrixStack;\n+import net.minecraft.client.world.ClientWorld;\n+import net.minecraft.entity.Entity;\n+import net.minecraft.util.hit.HitResult;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.util.math.Matrix4f;\n+import net.minecraft.util.profiler.Profiler;\n+\n+/**\n+ * Except as noted below, the properties exposed here match the parameters passed to\n+ * {@link WorldRenderer#render(MatrixStack, float, long, boolean, Camera, GameRenderer, LightmapTextureManager, Matrix4f)}.\n+ */\n+public interface WorldRenderContext {\n+\t/**\n+\t * The world renderer instance doing the rendering and invoking the event.\n+\t *\n+\t * @return WorldRenderer instance invoking the event\n+\t */\n+\tWorldRenderer worldRenderer();\n+\n+\tMatrixStack matrixStack();\n+\n+\tfloat tickDelta();\n+\n+\tlong limitTime();\n+\n+\tboolean blockOutlines();\n+\n+\tCamera camera();\n+\n+\tGameRenderer gameRenderer();\n+\n+\tLightmapTextureManager lightmapTextureManager();\n+\n+\tMatrix4f projectionMatrix();\n+\n+\t/**\n+\t * Convenient access to {WorldRenderer.world}.\n+\t *\n+\t * @return world renderer's client world instance\n+\t */\n+\tClientWorld world();\n+\n+\t/**\n+\t * Convenient access to game performance profiler.\n+\t *\n+\t * @return the active profiler\n+\t */\n+\tProfiler profiler();\n+\n+\t/**\n+\t * Test to know if \"fabulous\" graphics mode is enabled.\n+\t *\n+\t * <p>Use this for renders that need to render on top of all translucency to activate or deactivate different\n+\t * event handlers to get optimal depth testing results. When fabulous is off, it may be better to render\n+\t * during {@code WorldRenderLastCallback} after clouds and weather are drawn. Conversely, when fabulous mode is on,\n+\t * it may be better to draw during {@code WorldRenderPostTranslucentCallback}, before the fabulous mode composite\n+\t * shader runs, depending on which translucent buffer is being targeted.\n+\t *\n+\t * @return {@code true} when \"fabulous\" graphics mode is enabled.\n+\t */\n+\tboolean advancedTranslucency();\n+\n+\tpublic interface Drawable {\n+\t\t/**\n+\t\t * The {@code VertexConsumerProvider} instance being used by the world renderer for most non-terrain renders.\n+\t\t * Generally this will be better for most use cases because quads for the same layer can be buffered\n+\t\t * incrementally and then drawn all at once by the world renderer.\n+\t\t *\n+\t\t * <p>IMPORTANT - all vertex coordinates sent to consumers should be relative to the camera to\n+\t\t * be consistent with other quads emitted by the world renderer and other mods.  If this isn't\n+\t\t * possible, caller should use a separate \"immediate\" instance.\n+\t\t *\n+\t\t * <p>This property is not exposed before {@link WorldRenderEvents#BEFORE_ENTITIES} or after\n+\t\t * {@link WorldRenderEvents#BEFORE_DEBUG_RENDER} because the consumer buffers are not available before or\n+\t\t * drawn after that in vanilla world rendering.  Renders that cannot draw in one of the supported events\n+\t\t * must be drawn directly to the frame buffer, preferably in {@link WorldRenderEvents#LAST} to avoid being\n+\t\t * overdrawn or cleared.\n+\t\t */\n+\t\tVertexConsumerProvider consumers();\n+\t}\n+\n+\t/**\n+\t * Conveys WorldRenderer state to event handlers after invocation.\n+\t * Includes view frustum, which is not available then.\n+\t */\n+\tpublic interface AfterFrustum {\n+\t\tFrustum frustum();\n+\t}\n+\n+\t/**\n+\t * Used in the block breaking callback to convey information on\n+\t * ray trace hit and accept cancellation of default outline render.\n+\t */\n+\tpublic interface PreBlockOutline {\n+\t\t/**\n+\t\t * The game object currently under the crosshair target. Normally\n+\t\t * equivalent to {@link MinecraftClient#crosshairTarget}.\n+\t\t * Provided for convenience.\n+\t\t */\n+\t\t@Nullable HitResult hitResult();\n+\n+\t\t/**\n+\t\t * Call to prevent the default block outline from rendering.\n+\t\t * Use this for event handlers that fully replace the vanilla\n+\t\t * block outline render.\n+\t\t *\n+\t\t * <p>The effect of this method depends on the event from which it is called:\n+\t\t *\n+\t\t * <p>In {@code BEFORE_BLOCK_RENDER} this prevents invocation of\n+\t\t * the {@code BLOCK_RENDER} event and {@link AfterBlockOutline#didCancelDefaultBlockOutline()}\n+\t\t * will be {@code false} in later-stage event invocations. It (obviously)\n+\t\t * also prevents the default outline render from running.\n+\t\t *\n+\t\t * <p>In {@code BLOCK_RENDER} this prevents the default outline render\n+\t\t * from running and {@link AfterBlockOutline#didCancelDefaultBlockOutline()}\n+\t\t * will be {@code true} in later-stage event invocations.\n+\t\t *\n+\t\t * <p>In both cases, this method is idempotent - calling it from more\n+\t\t * than one event subscriber has the same effect as calling it once.\n+\t\t * All event handlers within the same event invocation will always\n+\t\t * execute and the cancellation status cannot be inspected during the\n+\t\t * block outline render events.\n+\t\t */\n+\t\tvoid cancelDefaultBlockOutline();\n+\t}\n+\n+\t/**\n+\t * Used in {@code BLOCK_OUTLINE} to convey the parameters normally sent to\n+\t * {@code WorldRenderer.drawBlockOutline}.\n+\t */\n+\tpublic interface BlockOutline {\n+\t\tVertexConsumer vertexConsumer();\n+\n+\t\tEntity entity();\n+\n+\t\tdouble cameraX();\n+\n+\t\tdouble cameraY();\n+\n+\t\tdouble cameraZ();\n+\n+\t\tBlockPos blockPos();\n+\n+\t\tBlockState blockState();\n+\t}\n+\n+\t/**\n+\t * Used after the block outline events to test if {@link #cancelDefaultBlockOutline()}\n+\t * was called during the {@code BLOCK_OUTLINE} event.\n+\t */\n+\tpublic interface AfterBlockOutline {\n+\t\t/**\n+\t\t * Tests if the default block outline render was cancelled in the {@code BLOCK_OUTLINE} event.\n+\t\t *\n+\t\t * <p>Will NOT be true if the outline was cancelled during {@code BEFORE_BLOCK_OUTLINE}.\n+\t\t *\n+\t\t * @return {@code true} if the default block outline render was cancelled in the {@code BLOCK_OUTLINE} event.\n+\t\t */\n+\t\tboolean didCancelDefaultBlockOutline();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bfeeffa72cb53676a7f849ba488574474df9b6c7"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTgwNzMwNg==", "bodyText": "I feel the Context on the end of these nested interfaces may be redundant. At the same time WorldRenderContext.Frustrum could be a bit weird, so this needs a bit of an evaluation.", "url": "https://github.com/FabricMC/fabric/pull/1182#discussion_r531807306", "createdAt": "2020-11-27T23:33:38Z", "author": {"login": "i509VCB"}, "path": "fabric-rendering-v1/src/main/java/net/fabricmc/fabric/api/client/rendering/v1/WorldRenderContext.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.client.rendering.v1;\n+\n+import org.jetbrains.annotations.Nullable;\n+\n+import net.minecraft.block.BlockState;\n+import net.minecraft.client.MinecraftClient;\n+import net.minecraft.client.render.Camera;\n+import net.minecraft.client.render.Frustum;\n+import net.minecraft.client.render.GameRenderer;\n+import net.minecraft.client.render.LightmapTextureManager;\n+import net.minecraft.client.render.VertexConsumer;\n+import net.minecraft.client.render.VertexConsumerProvider;\n+import net.minecraft.client.render.WorldRenderer;\n+import net.minecraft.client.util.math.MatrixStack;\n+import net.minecraft.client.world.ClientWorld;\n+import net.minecraft.entity.Entity;\n+import net.minecraft.util.hit.HitResult;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.util.math.Matrix4f;\n+import net.minecraft.util.profiler.Profiler;\n+\n+/**\n+ * Except as noted below, the properties exposed here match the parameters passed to\n+ * {@link WorldRenderer#render(MatrixStack, float, long, boolean, Camera, GameRenderer, LightmapTextureManager, Matrix4f)}.\n+ */\n+public interface WorldRenderContext {\n+\t/**\n+\t * The world renderer instance doing the rendering and invoking the event.\n+\t *\n+\t * @return WorldRenderer instance invoking the event\n+\t */\n+\tWorldRenderer worldRenderer();\n+\n+\tMatrixStack matrixStack();\n+\n+\tfloat tickDelta();\n+\n+\tlong limitTime();\n+\n+\tboolean blockOutlines();\n+\n+\tCamera camera();\n+\n+\tGameRenderer gameRenderer();\n+\n+\tLightmapTextureManager lightmapTextureManager();\n+\n+\tMatrix4f projectionMatrix();\n+\n+\t/**\n+\t * Convenient access to {WorldRenderer.world}.\n+\t *\n+\t * @return world renderer's client world instance\n+\t */\n+\tClientWorld world();\n+\n+\t/**\n+\t * Convenient access to game performance profiler.\n+\t *\n+\t * @return the active profiler\n+\t */\n+\tProfiler profiler();\n+\n+\t/**\n+\t * Test to know if \"fabulous\" graphics mode is enabled.\n+\t *\n+\t * <p>Use this for renders that need to render on top of all translucency to activate or deactivate different\n+\t * event handlers to get optimal depth testing results. When fabulous is off, it may be better to render\n+\t * during {@code WorldRenderLastCallback} after clouds and weather are drawn. Conversely, when fabulous mode is on,\n+\t * it may be better to draw during {@code WorldRenderPostTranslucentCallback}, before the fabulous mode composite\n+\t * shader runs, depending on which translucent buffer is being targeted.\n+\t *\n+\t * @return {@code true} when \"fabulous\" graphics mode is enabled.\n+\t */\n+\tboolean advancedTranslucency();\n+\n+\tpublic interface Drawable {\n+\t\t/**\n+\t\t * The {@code VertexConsumerProvider} instance being used by the world renderer for most non-terrain renders.\n+\t\t * Generally this will be better for most use cases because quads for the same layer can be buffered\n+\t\t * incrementally and then drawn all at once by the world renderer.\n+\t\t *\n+\t\t * <p>IMPORTANT - all vertex coordinates sent to consumers should be relative to the camera to\n+\t\t * be consistent with other quads emitted by the world renderer and other mods.  If this isn't\n+\t\t * possible, caller should use a separate \"immediate\" instance.\n+\t\t *\n+\t\t * <p>This property is not exposed before {@link WorldRenderEvents#BEFORE_ENTITIES} or after\n+\t\t * {@link WorldRenderEvents#BEFORE_DEBUG_RENDER} because the consumer buffers are not available before or\n+\t\t * drawn after that in vanilla world rendering.  Renders that cannot draw in one of the supported events\n+\t\t * must be drawn directly to the frame buffer, preferably in {@link WorldRenderEvents#LAST} to avoid being\n+\t\t * overdrawn or cleared.\n+\t\t */\n+\t\tVertexConsumerProvider consumers();\n+\t}\n+\n+\t/**\n+\t * Conveys WorldRenderer state to event handlers after invocation.\n+\t * Includes view frustum, which is not available then.\n+\t */\n+\tpublic interface AfterFrustum {\n+\t\tFrustum frustum();\n+\t}\n+\n+\t/**\n+\t * Used in the block breaking callback to convey information on\n+\t * ray trace hit and accept cancellation of default outline render.\n+\t */\n+\tpublic interface PreBlockOutline {\n+\t\t/**\n+\t\t * The game object currently under the crosshair target. Normally\n+\t\t * equivalent to {@link MinecraftClient#crosshairTarget}.\n+\t\t * Provided for convenience.\n+\t\t */\n+\t\t@Nullable HitResult hitResult();\n+\n+\t\t/**\n+\t\t * Call to prevent the default block outline from rendering.\n+\t\t * Use this for event handlers that fully replace the vanilla\n+\t\t * block outline render.\n+\t\t *\n+\t\t * <p>The effect of this method depends on the event from which it is called:\n+\t\t *\n+\t\t * <p>In {@code BEFORE_BLOCK_RENDER} this prevents invocation of\n+\t\t * the {@code BLOCK_RENDER} event and {@link AfterBlockOutline#didCancelDefaultBlockOutline()}\n+\t\t * will be {@code false} in later-stage event invocations. It (obviously)\n+\t\t * also prevents the default outline render from running.\n+\t\t *\n+\t\t * <p>In {@code BLOCK_RENDER} this prevents the default outline render\n+\t\t * from running and {@link AfterBlockOutline#didCancelDefaultBlockOutline()}\n+\t\t * will be {@code true} in later-stage event invocations.\n+\t\t *\n+\t\t * <p>In both cases, this method is idempotent - calling it from more\n+\t\t * than one event subscriber has the same effect as calling it once.\n+\t\t * All event handlers within the same event invocation will always\n+\t\t * execute and the cancellation status cannot be inspected during the\n+\t\t * block outline render events.\n+\t\t */\n+\t\tvoid cancelDefaultBlockOutline();\n+\t}\n+\n+\t/**\n+\t * Used in {@code BLOCK_OUTLINE} to convey the parameters normally sent to\n+\t * {@code WorldRenderer.drawBlockOutline}.\n+\t */\n+\tpublic interface BlockOutline {\n+\t\tVertexConsumer vertexConsumer();\n+\n+\t\tEntity entity();\n+\n+\t\tdouble cameraX();\n+\n+\t\tdouble cameraY();\n+\n+\t\tdouble cameraZ();\n+\n+\t\tBlockPos blockPos();\n+\n+\t\tBlockState blockState();\n+\t}\n+\n+\t/**\n+\t * Used after the block outline events to test if {@link #cancelDefaultBlockOutline()}\n+\t * was called during the {@code BLOCK_OUTLINE} event.\n+\t */\n+\tpublic interface AfterBlockOutline {\n+\t\t/**\n+\t\t * Tests if the default block outline render was cancelled in the {@code BLOCK_OUTLINE} event.\n+\t\t *\n+\t\t * <p>Will NOT be true if the outline was cancelled during {@code BEFORE_BLOCK_OUTLINE}.\n+\t\t *\n+\t\t * @return {@code true} if the default block outline render was cancelled in the {@code BLOCK_OUTLINE} event.\n+\t\t */\n+\t\tboolean didCancelDefaultBlockOutline();\n+\t}\n+\n+\tpublic interface FrustumContext extends WorldRenderContext, AfterFrustum { }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bfeeffa72cb53676a7f849ba488574474df9b6c7"}, "originalPosition": 192}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTgwNzQyNA==", "bodyText": "Considering the FrustrumContext is only used twice, it may be neater to just specify the method across both interface impls. May want to consider this as to reduce the amount of interfaces sub implementing eachother.", "url": "https://github.com/FabricMC/fabric/pull/1182#discussion_r531807424", "createdAt": "2020-11-27T23:34:26Z", "author": {"login": "i509VCB"}, "path": "fabric-rendering-v1/src/main/java/net/fabricmc/fabric/api/client/rendering/v1/WorldRenderContext.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.client.rendering.v1;\n+\n+import org.jetbrains.annotations.Nullable;\n+\n+import net.minecraft.block.BlockState;\n+import net.minecraft.client.MinecraftClient;\n+import net.minecraft.client.render.Camera;\n+import net.minecraft.client.render.Frustum;\n+import net.minecraft.client.render.GameRenderer;\n+import net.minecraft.client.render.LightmapTextureManager;\n+import net.minecraft.client.render.VertexConsumer;\n+import net.minecraft.client.render.VertexConsumerProvider;\n+import net.minecraft.client.render.WorldRenderer;\n+import net.minecraft.client.util.math.MatrixStack;\n+import net.minecraft.client.world.ClientWorld;\n+import net.minecraft.entity.Entity;\n+import net.minecraft.util.hit.HitResult;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.util.math.Matrix4f;\n+import net.minecraft.util.profiler.Profiler;\n+\n+/**\n+ * Except as noted below, the properties exposed here match the parameters passed to\n+ * {@link WorldRenderer#render(MatrixStack, float, long, boolean, Camera, GameRenderer, LightmapTextureManager, Matrix4f)}.\n+ */\n+public interface WorldRenderContext {\n+\t/**\n+\t * The world renderer instance doing the rendering and invoking the event.\n+\t *\n+\t * @return WorldRenderer instance invoking the event\n+\t */\n+\tWorldRenderer worldRenderer();\n+\n+\tMatrixStack matrixStack();\n+\n+\tfloat tickDelta();\n+\n+\tlong limitTime();\n+\n+\tboolean blockOutlines();\n+\n+\tCamera camera();\n+\n+\tGameRenderer gameRenderer();\n+\n+\tLightmapTextureManager lightmapTextureManager();\n+\n+\tMatrix4f projectionMatrix();\n+\n+\t/**\n+\t * Convenient access to {WorldRenderer.world}.\n+\t *\n+\t * @return world renderer's client world instance\n+\t */\n+\tClientWorld world();\n+\n+\t/**\n+\t * Convenient access to game performance profiler.\n+\t *\n+\t * @return the active profiler\n+\t */\n+\tProfiler profiler();\n+\n+\t/**\n+\t * Test to know if \"fabulous\" graphics mode is enabled.\n+\t *\n+\t * <p>Use this for renders that need to render on top of all translucency to activate or deactivate different\n+\t * event handlers to get optimal depth testing results. When fabulous is off, it may be better to render\n+\t * during {@code WorldRenderLastCallback} after clouds and weather are drawn. Conversely, when fabulous mode is on,\n+\t * it may be better to draw during {@code WorldRenderPostTranslucentCallback}, before the fabulous mode composite\n+\t * shader runs, depending on which translucent buffer is being targeted.\n+\t *\n+\t * @return {@code true} when \"fabulous\" graphics mode is enabled.\n+\t */\n+\tboolean advancedTranslucency();\n+\n+\tpublic interface Drawable {\n+\t\t/**\n+\t\t * The {@code VertexConsumerProvider} instance being used by the world renderer for most non-terrain renders.\n+\t\t * Generally this will be better for most use cases because quads for the same layer can be buffered\n+\t\t * incrementally and then drawn all at once by the world renderer.\n+\t\t *\n+\t\t * <p>IMPORTANT - all vertex coordinates sent to consumers should be relative to the camera to\n+\t\t * be consistent with other quads emitted by the world renderer and other mods.  If this isn't\n+\t\t * possible, caller should use a separate \"immediate\" instance.\n+\t\t *\n+\t\t * <p>This property is not exposed before {@link WorldRenderEvents#BEFORE_ENTITIES} or after\n+\t\t * {@link WorldRenderEvents#BEFORE_DEBUG_RENDER} because the consumer buffers are not available before or\n+\t\t * drawn after that in vanilla world rendering.  Renders that cannot draw in one of the supported events\n+\t\t * must be drawn directly to the frame buffer, preferably in {@link WorldRenderEvents#LAST} to avoid being\n+\t\t * overdrawn or cleared.\n+\t\t */\n+\t\tVertexConsumerProvider consumers();\n+\t}\n+\n+\t/**\n+\t * Conveys WorldRenderer state to event handlers after invocation.\n+\t * Includes view frustum, which is not available then.\n+\t */\n+\tpublic interface AfterFrustum {\n+\t\tFrustum frustum();\n+\t}\n+\n+\t/**\n+\t * Used in the block breaking callback to convey information on\n+\t * ray trace hit and accept cancellation of default outline render.\n+\t */\n+\tpublic interface PreBlockOutline {\n+\t\t/**\n+\t\t * The game object currently under the crosshair target. Normally\n+\t\t * equivalent to {@link MinecraftClient#crosshairTarget}.\n+\t\t * Provided for convenience.\n+\t\t */\n+\t\t@Nullable HitResult hitResult();\n+\n+\t\t/**\n+\t\t * Call to prevent the default block outline from rendering.\n+\t\t * Use this for event handlers that fully replace the vanilla\n+\t\t * block outline render.\n+\t\t *\n+\t\t * <p>The effect of this method depends on the event from which it is called:\n+\t\t *\n+\t\t * <p>In {@code BEFORE_BLOCK_RENDER} this prevents invocation of\n+\t\t * the {@code BLOCK_RENDER} event and {@link AfterBlockOutline#didCancelDefaultBlockOutline()}\n+\t\t * will be {@code false} in later-stage event invocations. It (obviously)\n+\t\t * also prevents the default outline render from running.\n+\t\t *\n+\t\t * <p>In {@code BLOCK_RENDER} this prevents the default outline render\n+\t\t * from running and {@link AfterBlockOutline#didCancelDefaultBlockOutline()}\n+\t\t * will be {@code true} in later-stage event invocations.\n+\t\t *\n+\t\t * <p>In both cases, this method is idempotent - calling it from more\n+\t\t * than one event subscriber has the same effect as calling it once.\n+\t\t * All event handlers within the same event invocation will always\n+\t\t * execute and the cancellation status cannot be inspected during the\n+\t\t * block outline render events.\n+\t\t */\n+\t\tvoid cancelDefaultBlockOutline();\n+\t}\n+\n+\t/**\n+\t * Used in {@code BLOCK_OUTLINE} to convey the parameters normally sent to\n+\t * {@code WorldRenderer.drawBlockOutline}.\n+\t */\n+\tpublic interface BlockOutline {\n+\t\tVertexConsumer vertexConsumer();\n+\n+\t\tEntity entity();\n+\n+\t\tdouble cameraX();\n+\n+\t\tdouble cameraY();\n+\n+\t\tdouble cameraZ();\n+\n+\t\tBlockPos blockPos();\n+\n+\t\tBlockState blockState();\n+\t}\n+\n+\t/**\n+\t * Used after the block outline events to test if {@link #cancelDefaultBlockOutline()}\n+\t * was called during the {@code BLOCK_OUTLINE} event.\n+\t */\n+\tpublic interface AfterBlockOutline {\n+\t\t/**\n+\t\t * Tests if the default block outline render was cancelled in the {@code BLOCK_OUTLINE} event.\n+\t\t *\n+\t\t * <p>Will NOT be true if the outline was cancelled during {@code BEFORE_BLOCK_OUTLINE}.\n+\t\t *\n+\t\t * @return {@code true} if the default block outline render was cancelled in the {@code BLOCK_OUTLINE} event.\n+\t\t */\n+\t\tboolean didCancelDefaultBlockOutline();\n+\t}\n+\n+\tpublic interface FrustumContext extends WorldRenderContext, AfterFrustum { }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bfeeffa72cb53676a7f849ba488574474df9b6c7"}, "originalPosition": 192}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTgwNzcyNQ==", "bodyText": "Player raised a concern here about this context in use mixing up the cancellation + notification handling.", "url": "https://github.com/FabricMC/fabric/pull/1182#discussion_r531807725", "createdAt": "2020-11-27T23:36:48Z", "author": {"login": "i509VCB"}, "path": "fabric-rendering-v1/src/main/java/net/fabricmc/fabric/api/client/rendering/v1/WorldRenderContext.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.client.rendering.v1;\n+\n+import org.jetbrains.annotations.Nullable;\n+\n+import net.minecraft.block.BlockState;\n+import net.minecraft.client.MinecraftClient;\n+import net.minecraft.client.render.Camera;\n+import net.minecraft.client.render.Frustum;\n+import net.minecraft.client.render.GameRenderer;\n+import net.minecraft.client.render.LightmapTextureManager;\n+import net.minecraft.client.render.VertexConsumer;\n+import net.minecraft.client.render.VertexConsumerProvider;\n+import net.minecraft.client.render.WorldRenderer;\n+import net.minecraft.client.util.math.MatrixStack;\n+import net.minecraft.client.world.ClientWorld;\n+import net.minecraft.entity.Entity;\n+import net.minecraft.util.hit.HitResult;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.util.math.Matrix4f;\n+import net.minecraft.util.profiler.Profiler;\n+\n+/**\n+ * Except as noted below, the properties exposed here match the parameters passed to\n+ * {@link WorldRenderer#render(MatrixStack, float, long, boolean, Camera, GameRenderer, LightmapTextureManager, Matrix4f)}.\n+ */\n+public interface WorldRenderContext {\n+\t/**\n+\t * The world renderer instance doing the rendering and invoking the event.\n+\t *\n+\t * @return WorldRenderer instance invoking the event\n+\t */\n+\tWorldRenderer worldRenderer();\n+\n+\tMatrixStack matrixStack();\n+\n+\tfloat tickDelta();\n+\n+\tlong limitTime();\n+\n+\tboolean blockOutlines();\n+\n+\tCamera camera();\n+\n+\tGameRenderer gameRenderer();\n+\n+\tLightmapTextureManager lightmapTextureManager();\n+\n+\tMatrix4f projectionMatrix();\n+\n+\t/**\n+\t * Convenient access to {WorldRenderer.world}.\n+\t *\n+\t * @return world renderer's client world instance\n+\t */\n+\tClientWorld world();\n+\n+\t/**\n+\t * Convenient access to game performance profiler.\n+\t *\n+\t * @return the active profiler\n+\t */\n+\tProfiler profiler();\n+\n+\t/**\n+\t * Test to know if \"fabulous\" graphics mode is enabled.\n+\t *\n+\t * <p>Use this for renders that need to render on top of all translucency to activate or deactivate different\n+\t * event handlers to get optimal depth testing results. When fabulous is off, it may be better to render\n+\t * during {@code WorldRenderLastCallback} after clouds and weather are drawn. Conversely, when fabulous mode is on,\n+\t * it may be better to draw during {@code WorldRenderPostTranslucentCallback}, before the fabulous mode composite\n+\t * shader runs, depending on which translucent buffer is being targeted.\n+\t *\n+\t * @return {@code true} when \"fabulous\" graphics mode is enabled.\n+\t */\n+\tboolean advancedTranslucency();\n+\n+\tpublic interface Drawable {\n+\t\t/**\n+\t\t * The {@code VertexConsumerProvider} instance being used by the world renderer for most non-terrain renders.\n+\t\t * Generally this will be better for most use cases because quads for the same layer can be buffered\n+\t\t * incrementally and then drawn all at once by the world renderer.\n+\t\t *\n+\t\t * <p>IMPORTANT - all vertex coordinates sent to consumers should be relative to the camera to\n+\t\t * be consistent with other quads emitted by the world renderer and other mods.  If this isn't\n+\t\t * possible, caller should use a separate \"immediate\" instance.\n+\t\t *\n+\t\t * <p>This property is not exposed before {@link WorldRenderEvents#BEFORE_ENTITIES} or after\n+\t\t * {@link WorldRenderEvents#BEFORE_DEBUG_RENDER} because the consumer buffers are not available before or\n+\t\t * drawn after that in vanilla world rendering.  Renders that cannot draw in one of the supported events\n+\t\t * must be drawn directly to the frame buffer, preferably in {@link WorldRenderEvents#LAST} to avoid being\n+\t\t * overdrawn or cleared.\n+\t\t */\n+\t\tVertexConsumerProvider consumers();\n+\t}\n+\n+\t/**\n+\t * Conveys WorldRenderer state to event handlers after invocation.\n+\t * Includes view frustum, which is not available then.\n+\t */\n+\tpublic interface AfterFrustum {\n+\t\tFrustum frustum();\n+\t}\n+\n+\t/**\n+\t * Used in the block breaking callback to convey information on\n+\t * ray trace hit and accept cancellation of default outline render.\n+\t */\n+\tpublic interface PreBlockOutline {\n+\t\t/**\n+\t\t * The game object currently under the crosshair target. Normally\n+\t\t * equivalent to {@link MinecraftClient#crosshairTarget}.\n+\t\t * Provided for convenience.\n+\t\t */\n+\t\t@Nullable HitResult hitResult();\n+\n+\t\t/**\n+\t\t * Call to prevent the default block outline from rendering.\n+\t\t * Use this for event handlers that fully replace the vanilla\n+\t\t * block outline render.\n+\t\t *\n+\t\t * <p>The effect of this method depends on the event from which it is called:\n+\t\t *\n+\t\t * <p>In {@code BEFORE_BLOCK_RENDER} this prevents invocation of\n+\t\t * the {@code BLOCK_RENDER} event and {@link AfterBlockOutline#didCancelDefaultBlockOutline()}\n+\t\t * will be {@code false} in later-stage event invocations. It (obviously)\n+\t\t * also prevents the default outline render from running.\n+\t\t *\n+\t\t * <p>In {@code BLOCK_RENDER} this prevents the default outline render\n+\t\t * from running and {@link AfterBlockOutline#didCancelDefaultBlockOutline()}\n+\t\t * will be {@code true} in later-stage event invocations.\n+\t\t *\n+\t\t * <p>In both cases, this method is idempotent - calling it from more\n+\t\t * than one event subscriber has the same effect as calling it once.\n+\t\t * All event handlers within the same event invocation will always\n+\t\t * execute and the cancellation status cannot be inspected during the\n+\t\t * block outline render events.\n+\t\t */\n+\t\tvoid cancelDefaultBlockOutline();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bfeeffa72cb53676a7f849ba488574474df9b6c7"}, "originalPosition": 154}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "caaffdddb3a90c20843f32d4704ab1128c6c10a0", "author": {"user": {"login": "grondag", "name": null}}, "url": "https://github.com/FabricMC/fabric/commit/caaffdddb3a90c20843f32d4704ab1128c6c10a0", "committedDate": "2020-11-28T20:23:22Z", "message": "Incorporate PR feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d44ecf2ff94a2b2d94946539ac57d719921d0498", "author": {"user": {"login": "grondag", "name": null}}, "url": "https://github.com/FabricMC/fabric/commit/d44ecf2ff94a2b2d94946539ac57d719921d0498", "committedDate": "2020-12-16T04:57:46Z", "message": "Simplify context and block outline events"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cb4cbec2ad0f7be5eabf52cd4ae0c3b157eef232", "author": {"user": {"login": "grondag", "name": null}}, "url": "https://github.com/FabricMC/fabric/commit/cb4cbec2ad0f7be5eabf52cd4ae0c3b157eef232", "committedDate": "2020-12-16T05:11:11Z", "message": "Update implementation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9663839baab54e18179d85297d791f5c87a38767", "author": {"user": {"login": "grondag", "name": null}}, "url": "https://github.com/FabricMC/fabric/commit/9663839baab54e18179d85297d791f5c87a38767", "committedDate": "2020-12-16T05:49:39Z", "message": "Ensure the BLOCK_OUTLINE mixin does nothing if BEFORE_BLOCK_OUTLINE mixin is disabled"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUzNDkzODk0", "url": "https://github.com/FabricMC/fabric/pull/1182#pullrequestreview-553493894", "createdAt": "2020-12-16T09:21:18Z", "commit": {"oid": "d44ecf2ff94a2b2d94946539ac57d719921d0498"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwOToyMToxOFrOIG7hbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwOToyMToxOFrOIG7hbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDEzNzU4Mw==", "bodyText": "Is there a reason you are specifying the empty invoker impl for the events?", "url": "https://github.com/FabricMC/fabric/pull/1182#discussion_r544137583", "createdAt": "2020-12-16T09:21:18Z", "author": {"login": "i509VCB"}, "path": "fabric-rendering-v1/src/main/java/net/fabricmc/fabric/api/client/rendering/v1/WorldRenderEvents.java", "diffHunk": "@@ -213,7 +237,7 @@ private WorldRenderEvents() { }\n \t * down transient state in event handlers or as a hook that precedes hand/held item\n \t * and GUI rendering.\n \t */\n-\tpublic static final Event<End> END = EventFactory.createArrayBacked(End.class, callbacks -> context -> {\n+\tpublic static final Event<End> END = EventFactory.createArrayBacked(End.class, context -> { }, callbacks -> context -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d44ecf2ff94a2b2d94946539ac57d719921d0498"}, "originalPosition": 168}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUzNTkzMzg5", "url": "https://github.com/FabricMC/fabric/pull/1182#pullrequestreview-553593389", "createdAt": "2020-12-16T11:25:01Z", "commit": {"oid": "9663839baab54e18179d85297d791f5c87a38767"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUzNzgyNzYy", "url": "https://github.com/FabricMC/fabric/pull/1182#pullrequestreview-553782762", "createdAt": "2020-12-16T15:10:47Z", "commit": {"oid": "9663839baab54e18179d85297d791f5c87a38767"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b3fd84ca9f46cf93ff0ba1ba2abc2f93cec8e471", "author": {"user": {"login": "grondag", "name": null}}, "url": "https://github.com/FabricMC/fabric/commit/b3fd84ca9f46cf93ff0ba1ba2abc2f93cec8e471", "committedDate": "2020-12-16T16:26:31Z", "message": "Document event order in class header"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUzODk3NjQ2", "url": "https://github.com/FabricMC/fabric/pull/1182#pullrequestreview-553897646", "createdAt": "2020-12-16T17:03:18Z", "commit": {"oid": "b3fd84ca9f46cf93ff0ba1ba2abc2f93cec8e471"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxNzowMzoxOFrOIHPqtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxNzowNDowNVrOIHPs3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDQ2NzYzNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * that make large-scale changes to rendering maintain compatibility by calling any broken even invokers directly.\n          \n          \n            \n             * that make large-scale changes to rendering maintain compatibility by calling any broken event invokers directly.", "url": "https://github.com/FabricMC/fabric/pull/1182#discussion_r544467636", "createdAt": "2020-12-16T17:03:18Z", "author": {"login": "Juuxel"}, "path": "fabric-rendering-v1/src/main/java/net/fabricmc/fabric/api/client/rendering/v1/WorldRenderEvents.java", "diffHunk": "@@ -0,0 +1,317 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.client.rendering.v1;\n+\n+import org.jetbrains.annotations.Nullable;\n+\n+import net.minecraft.client.MinecraftClient;\n+import net.minecraft.client.render.WorldRenderer;\n+import net.minecraft.util.hit.HitResult;\n+\n+import net.fabricmc.api.EnvType;\n+import net.fabricmc.api.Environment;\n+import net.fabricmc.fabric.api.client.rendering.v1.WorldRenderContext.BlockOutlineContext;\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+\n+/**\n+ * Mods should use these events to introduce custom rendering during {@link WorldRenderer#render(net.minecraft.client.util.math.MatrixStack, float, long, boolean, net.minecraft.client.render.Camera, net.minecraft.client.render.GameRenderer, net.minecraft.client.render.LightmapTextureManager, net.minecraft.util.math.Matrix4f)}\n+ * without adding complicated and conflict-prone injections there.  Using these events also enables 3rd-party renderers\n+ * that make large-scale changes to rendering maintain compatibility by calling any broken even invokers directly.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3fd84ca9f46cf93ff0ba1ba2abc2f93cec8e471"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDQ2ODE4OA==", "bodyText": "I don't think the @Environment propagates to nested types, so this needs it as well.", "url": "https://github.com/FabricMC/fabric/pull/1182#discussion_r544468188", "createdAt": "2020-12-16T17:04:05Z", "author": {"login": "Juuxel"}, "path": "fabric-rendering-v1/src/main/java/net/fabricmc/fabric/api/client/rendering/v1/WorldRenderContext.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.client.rendering.v1;\n+\n+import org.jetbrains.annotations.Nullable;\n+\n+import net.minecraft.block.BlockState;\n+import net.minecraft.client.render.Camera;\n+import net.minecraft.client.render.Frustum;\n+import net.minecraft.client.render.GameRenderer;\n+import net.minecraft.client.render.LightmapTextureManager;\n+import net.minecraft.client.render.VertexConsumer;\n+import net.minecraft.client.render.VertexConsumerProvider;\n+import net.minecraft.client.render.WorldRenderer;\n+import net.minecraft.client.util.math.MatrixStack;\n+import net.minecraft.client.world.ClientWorld;\n+import net.minecraft.entity.Entity;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.util.math.Matrix4f;\n+import net.minecraft.util.profiler.Profiler;\n+\n+import net.fabricmc.api.EnvType;\n+import net.fabricmc.api.Environment;\n+\n+/**\n+ * Except as noted below, the properties exposed here match the parameters passed to\n+ * {@link WorldRenderer#render(MatrixStack, float, long, boolean, Camera, GameRenderer, LightmapTextureManager, Matrix4f)}.\n+ */\n+@Environment(EnvType.CLIENT)\n+public interface WorldRenderContext {\n+\t/**\n+\t * The world renderer instance doing the rendering and invoking the event.\n+\t *\n+\t * @return WorldRenderer instance invoking the event\n+\t */\n+\tWorldRenderer worldRenderer();\n+\n+\tMatrixStack matrixStack();\n+\n+\tfloat tickDelta();\n+\n+\tlong limitTime();\n+\n+\tboolean blockOutlines();\n+\n+\tCamera camera();\n+\n+\tGameRenderer gameRenderer();\n+\n+\tLightmapTextureManager lightmapTextureManager();\n+\n+\tMatrix4f projectionMatrix();\n+\n+\t/**\n+\t * Convenient access to {WorldRenderer.world}.\n+\t *\n+\t * @return world renderer's client world instance\n+\t */\n+\tClientWorld world();\n+\n+\t/**\n+\t * Convenient access to game performance profiler.\n+\t *\n+\t * @return the active profiler\n+\t */\n+\tProfiler profiler();\n+\n+\t/**\n+\t * Test to know if \"fabulous\" graphics mode is enabled.\n+\t *\n+\t * <p>Use this for renders that need to render on top of all translucency to activate or deactivate different\n+\t * event handlers to get optimal depth testing results. When fabulous is off, it may be better to render\n+\t * during {@code WorldRenderLastCallback} after clouds and weather are drawn. Conversely, when fabulous mode is on,\n+\t * it may be better to draw during {@code WorldRenderPostTranslucentCallback}, before the fabulous mode composite\n+\t * shader runs, depending on which translucent buffer is being targeted.\n+\t *\n+\t * @return {@code true} when \"fabulous\" graphics mode is enabled.\n+\t */\n+\tboolean advancedTranslucency();\n+\n+\t/**\n+\t * The {@code VertexConsumerProvider} instance being used by the world renderer for most non-terrain renders.\n+\t * Generally this will be better for most use cases because quads for the same layer can be buffered\n+\t * incrementally and then drawn all at once by the world renderer.\n+\t *\n+\t * <p>IMPORTANT - all vertex coordinates sent to consumers should be relative to the camera to\n+\t * be consistent with other quads emitted by the world renderer and other mods.  If this isn't\n+\t * possible, caller should use a separate \"immediate\" instance.\n+\t *\n+\t * <p>This property is {@code null} before {@link WorldRenderEvents#BEFORE_ENTITIES} and after\n+\t * {@link WorldRenderEvents#BEFORE_DEBUG_RENDER} because the consumer buffers are not available before or\n+\t * drawn after that in vanilla world rendering.  Renders that cannot draw in one of the supported events\n+\t * must be drawn directly to the frame buffer, preferably in {@link WorldRenderEvents#LAST} to avoid being\n+\t * overdrawn or cleared.\n+\t */\n+\t@Nullable VertexConsumerProvider consumers();\n+\n+\t/**\n+\t * View frustum, after it is initialized. Will be {@code null} during\n+\t * {@link WorldRenderEvents#START}.\n+\t */\n+\t@Nullable Frustum frustum();\n+\n+\t/**\n+\t * Used in {@code BLOCK_OUTLINE} to convey the parameters normally sent to\n+\t * {@code WorldRenderer.drawBlockOutline}.\n+\t */\n+\tpublic interface BlockOutlineContext {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3fd84ca9f46cf93ff0ba1ba2abc2f93cec8e471"}, "originalPosition": 122}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "665af331d5a316104a92f66c07aa15ee77871b43", "author": {"user": {"login": "grondag", "name": null}}, "url": "https://github.com/FabricMC/fabric/commit/665af331d5a316104a92f66c07aa15ee77871b43", "committedDate": "2020-12-16T17:17:58Z", "message": "Update fabric-rendering-v1/src/main/java/net/fabricmc/fabric/api/client/rendering/v1/WorldRenderEvents.java\n\nCo-authored-by: Juuxel <6596629+Juuxel@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "834c9f07470999dd4e297184ab7dd3e690dff93f", "author": {"user": {"login": "grondag", "name": null}}, "url": "https://github.com/FabricMC/fabric/commit/834c9f07470999dd4e297184ab7dd3e690dff93f", "committedDate": "2020-12-16T17:19:49Z", "message": "Add environment tag to nested type"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eb8a366ce321e2d20cecef6c2128ec0d620b287b", "author": {"user": {"login": "grondag", "name": null}}, "url": "https://github.com/FabricMC/fabric/commit/eb8a366ce321e2d20cecef6c2128ec0d620b287b", "committedDate": "2020-12-16T17:20:00Z", "message": "Merge branch 'WorldRenderEvents' of https://github.com/grondag/fabric into WorldRenderEvents"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0MDczOTA1", "url": "https://github.com/FabricMC/fabric/pull/1182#pullrequestreview-554073905", "createdAt": "2020-12-16T20:51:44Z", "commit": {"oid": "eb8a366ce321e2d20cecef6c2128ec0d620b287b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0MzM0NzYx", "url": "https://github.com/FabricMC/fabric/pull/1182#pullrequestreview-554334761", "createdAt": "2020-12-17T07:23:25Z", "commit": {"oid": "eb8a366ce321e2d20cecef6c2128ec0d620b287b"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0dd3702a9d8c419d85112771288d9649a5b36bc4", "author": {"user": {"login": "grondag", "name": null}}, "url": "https://github.com/FabricMC/fabric/commit/0dd3702a9d8c419d85112771288d9649a5b36bc4", "committedDate": "2020-12-18T01:11:58Z", "message": "More envionment tags"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1MjA2MDY2", "url": "https://github.com/FabricMC/fabric/pull/1182#pullrequestreview-555206066", "createdAt": "2020-12-18T06:47:23Z", "commit": {"oid": "0dd3702a9d8c419d85112771288d9649a5b36bc4"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1OTQwODA0", "url": "https://github.com/FabricMC/fabric/pull/1182#pullrequestreview-555940804", "createdAt": "2020-12-19T13:12:38Z", "commit": {"oid": "0dd3702a9d8c419d85112771288d9649a5b36bc4"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3NjQ0MDE0", "url": "https://github.com/FabricMC/fabric/pull/1182#pullrequestreview-557644014", "createdAt": "2020-12-23T05:11:35Z", "commit": {"oid": "0dd3702a9d8c419d85112771288d9649a5b36bc4"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU4MjgxMjU3", "url": "https://github.com/FabricMC/fabric/pull/1182#pullrequestreview-558281257", "createdAt": "2020-12-24T00:16:57Z", "commit": {"oid": "0dd3702a9d8c419d85112771288d9649a5b36bc4"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU4NDQxODk4", "url": "https://github.com/FabricMC/fabric/pull/1182#pullrequestreview-558441898", "createdAt": "2020-12-24T10:02:37Z", "commit": {"oid": "0dd3702a9d8c419d85112771288d9649a5b36bc4"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU4NTAwODQx", "url": "https://github.com/FabricMC/fabric/pull/1182#pullrequestreview-558500841", "createdAt": "2020-12-24T13:11:41Z", "commit": {"oid": "0dd3702a9d8c419d85112771288d9649a5b36bc4"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU4NzMwMDUy", "url": "https://github.com/FabricMC/fabric/pull/1182#pullrequestreview-558730052", "createdAt": "2020-12-25T01:12:27Z", "commit": {"oid": "0dd3702a9d8c419d85112771288d9649a5b36bc4"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU4NzMxNjI4", "url": "https://github.com/FabricMC/fabric/pull/1182#pullrequestreview-558731628", "createdAt": "2020-12-25T01:29:40Z", "commit": {"oid": "0dd3702a9d8c419d85112771288d9649a5b36bc4"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3507, "cost": 1, "resetAt": "2021-11-01T14:20:25Z"}}}