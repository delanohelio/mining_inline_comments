{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc1NzU4MzE3", "number": 1052, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxOTo0NDoyMlrOEecs2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNjoxNzoyNlrOEim2Rg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMzYyOTY5OnYy", "diffSide": "RIGHT", "path": "fabric-registry-sync-v0/src/main/java/net/fabricmc/fabric/mixin/registry/sync/AccessorRegistry.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxOTo0NDoyMlrOHKGyyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQyMzozNjozM1rOHNdxHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM1OTExMg==", "bodyText": "Would prefer this having an actual name", "url": "https://github.com/FabricMC/fabric/pull/1052#discussion_r480359112", "createdAt": "2020-08-31T19:44:22Z", "author": {"login": "NeusFear"}, "path": "fabric-registry-sync-v0/src/main/java/net/fabricmc/fabric/mixin/registry/sync/AccessorRegistry.java", "diffHunk": "@@ -32,4 +34,10 @@\n \n \t@Accessor()\n \tRegistryKey<Registry<T>> getRegistryKey();\n+\n+\t/**\n+\t * Gets the lifecycle of a registry entry.\n+\t */\n+\t@Invoker\n+\tLifecycle callMethod_31139(T object);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b861300bd7ea77e5ec28fa6fd54355d608a7532"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM4ODc4NA==", "bodyText": "It is mapped in newer Yarn versions (getEntryLifecycle), but not in the one in fabric-api sadly.", "url": "https://github.com/FabricMC/fabric/pull/1052#discussion_r480388784", "createdAt": "2020-08-31T20:44:56Z", "author": {"login": "shartte"}, "path": "fabric-registry-sync-v0/src/main/java/net/fabricmc/fabric/mixin/registry/sync/AccessorRegistry.java", "diffHunk": "@@ -32,4 +34,10 @@\n \n \t@Accessor()\n \tRegistryKey<Registry<T>> getRegistryKey();\n+\n+\t/**\n+\t * Gets the lifecycle of a registry entry.\n+\t */\n+\t@Invoker\n+\tLifecycle callMethod_31139(T object);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM1OTExMg=="}, "originalCommit": {"oid": "7b861300bd7ea77e5ec28fa6fd54355d608a7532"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg3MzczMw==", "bodyText": "So we can keep track of this, the hash for the commit is FabricMC/yarn@577ff9c which should be represented by yarn version 1.16.2+build.43", "url": "https://github.com/FabricMC/fabric/pull/1052#discussion_r483873733", "createdAt": "2020-09-04T22:55:57Z", "author": {"login": "Vaerian"}, "path": "fabric-registry-sync-v0/src/main/java/net/fabricmc/fabric/mixin/registry/sync/AccessorRegistry.java", "diffHunk": "@@ -32,4 +34,10 @@\n \n \t@Accessor()\n \tRegistryKey<Registry<T>> getRegistryKey();\n+\n+\t/**\n+\t * Gets the lifecycle of a registry entry.\n+\t */\n+\t@Invoker\n+\tLifecycle callMethod_31139(T object);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM1OTExMg=="}, "originalCommit": {"oid": "7b861300bd7ea77e5ec28fa6fd54355d608a7532"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg4MTIxMA==", "bodyText": "Nvm I was literally just gonna ask you to change it as you pushed that commit lol", "url": "https://github.com/FabricMC/fabric/pull/1052#discussion_r483881210", "createdAt": "2020-09-04T23:36:19Z", "author": {"login": "Vaerian"}, "path": "fabric-registry-sync-v0/src/main/java/net/fabricmc/fabric/mixin/registry/sync/AccessorRegistry.java", "diffHunk": "@@ -32,4 +34,10 @@\n \n \t@Accessor()\n \tRegistryKey<Registry<T>> getRegistryKey();\n+\n+\t/**\n+\t * Gets the lifecycle of a registry entry.\n+\t */\n+\t@Invoker\n+\tLifecycle callMethod_31139(T object);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM1OTExMg=="}, "originalCommit": {"oid": "7b861300bd7ea77e5ec28fa6fd54355d608a7532"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg4MTI0NQ==", "bodyText": "Since fabric-api's mappings were updated, I was able to change this to its real name.", "url": "https://github.com/FabricMC/fabric/pull/1052#discussion_r483881245", "createdAt": "2020-09-04T23:36:33Z", "author": {"login": "shartte"}, "path": "fabric-registry-sync-v0/src/main/java/net/fabricmc/fabric/mixin/registry/sync/AccessorRegistry.java", "diffHunk": "@@ -32,4 +34,10 @@\n \n \t@Accessor()\n \tRegistryKey<Registry<T>> getRegistryKey();\n+\n+\t/**\n+\t * Gets the lifecycle of a registry entry.\n+\t */\n+\t@Invoker\n+\tLifecycle callMethod_31139(T object);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM1OTExMg=="}, "originalCommit": {"oid": "7b861300bd7ea77e5ec28fa6fd54355d608a7532"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyNTYzNzQ0OnYy", "diffSide": "RIGHT", "path": "fabric-registry-sync-v0/src/main/java/net/fabricmc/fabric/impl/registry/sync/DynamicRegistrySync.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQyMzozODowN1rOHNdyIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQyMzozODowN1rOHNdyIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg4MTUwNg==", "bodyText": "Literally my only gripe is that this uses the word \"we\" I'd try to change it to something using 3rd person language", "url": "https://github.com/FabricMC/fabric/pull/1052#discussion_r483881506", "createdAt": "2020-09-04T23:38:07Z", "author": {"login": "Vaerian"}, "path": "fabric-registry-sync-v0/src/main/java/net/fabricmc/fabric/impl/registry/sync/DynamicRegistrySync.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.impl.registry.sync;\n+\n+import com.mojang.serialization.Lifecycle;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import net.minecraft.util.registry.BuiltinRegistries;\n+import net.minecraft.util.registry.DynamicRegistryManager;\n+import net.minecraft.util.registry.MutableRegistry;\n+import net.minecraft.util.registry.Registry;\n+import net.minecraft.util.registry.RegistryKey;\n+\n+import net.fabricmc.fabric.api.event.registry.RegistryEntryAddedCallback;\n+import net.fabricmc.fabric.mixin.registry.sync.AccessorRegistry;\n+\n+/**\n+ * Handles synchronising changes to the built-in registries into the dynamic registry manager's template manager,\n+ * in case it gets classloaded early.\n+ */\n+public class DynamicRegistrySync {\n+\tprivate static final Logger LOGGER = LogManager.getLogger();\n+\n+\t/**\n+\t * Sets up a synchronisation that will propagate added entries to the given dynamic registry manager, which\n+\t * should be the <em>built-in</em> manager. It is never destroyed. We don't ever have to unregister", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e98bf71fa873812ba87fa1b06ad5856e687f8fa0"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NzIzNTI2OnYy", "diffSide": "RIGHT", "path": "fabric-registry-sync-v0/src/testmod/java/net/fabricmc/fabric/test/registry/sync/RegistrySyncTest.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNjoxNzoyNlrOHQlSlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xM1QxNjozMToxMlrOHQ9q_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE1MDIzMQ==", "bodyText": "I'd probably throw assertion errors here and for the couple of exceptions below.", "url": "https://github.com/FabricMC/fabric/pull/1052#discussion_r487150231", "createdAt": "2020-09-11T16:17:26Z", "author": {"login": "i509VCB"}, "path": "fabric-registry-sync-v0/src/testmod/java/net/fabricmc/fabric/test/registry/sync/RegistrySyncTest.java", "diffHunk": "@@ -69,4 +77,53 @@ public void onInitialize() {\n \t\tValidate.isTrue(RegistryAttributeHolder.get(fabricRegistry).hasAttribute(RegistryAttribute.SYNCED));\n \t\tValidate.isTrue(!RegistryAttributeHolder.get(fabricRegistry).hasAttribute(RegistryAttribute.PERSISTED));\n \t}\n+\n+\t/**\n+\t * Tests that built-in registries are properly synchronized even after the dynamic reigstry managers have been\n+\t * class-loaded.\n+\t */\n+\tprivate void testBuiltInRegistrySync() {\n+\t\tSystem.out.println(\"Checking built-in registry sync...\");\n+\n+\t\t// Register a configured feature before force-loading the dynamic registry manager\n+\t\tConfiguredFeature<DefaultFeatureConfig, ?> cf1 = Feature.BASALT_PILLAR.configure(DefaultFeatureConfig.INSTANCE);\n+\t\tIdentifier f1Id = new Identifier(\"registry_sync\", \"f1\");\n+\t\tRegistry.register(BuiltinRegistries.CONFIGURED_FEATURE, f1Id, cf1);\n+\n+\t\t// Force-Initialize the dynamic registry manager, doing this in a Mod initializer would cause\n+\t\t// further registrations into BuiltInRegistries to _NOT_ propagate into DynamicRegistryManager.BUILTIN\n+\t\tcheckFeature(DynamicRegistryManager.create(), f1Id);\n+\n+\t\tConfiguredFeature<DefaultFeatureConfig, ?> cf2 = Feature.DESERT_WELL.configure(DefaultFeatureConfig.INSTANCE);\n+\t\tIdentifier f2Id = new Identifier(\"registry_sync\", \"f2\");\n+\t\tRegistry.register(BuiltinRegistries.CONFIGURED_FEATURE, f2Id, cf2);\n+\n+\t\tDynamicRegistryManager.Impl impl2 = DynamicRegistryManager.create();\n+\t\tcheckFeature(impl2, f1Id);\n+\t\tcheckFeature(impl2, f2Id);\n+\t}\n+\n+\tprivate void checkFeature(DynamicRegistryManager manager, Identifier id) {\n+\t\tMutableRegistry<ConfiguredFeature<?, ?>> registry = manager.get(Registry.CONFIGURED_FEATURE_WORLDGEN);\n+\n+\t\tConfiguredFeature<?, ?> builtInEntry = BuiltinRegistries.CONFIGURED_FEATURE.get(id);\n+\n+\t\tif (builtInEntry == null) {\n+\t\t\tthrow new IllegalStateException(\"Expected built-in entry to exist for: \" + id);\n+\t\t}\n+\n+\t\tConfiguredFeature<?, ?> entry = registry.get(id);\n+\n+\t\tif (entry == null) {\n+\t\t\tthrow new IllegalStateException(\"Expected dynamic registry to contain entry \" + id);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e98bf71fa873812ba87fa1b06ad5856e687f8fa0"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE1NzY1Mg==", "bodyText": "Aren't those usually reserved for the assert keyword though?", "url": "https://github.com/FabricMC/fabric/pull/1052#discussion_r487157652", "createdAt": "2020-09-11T16:31:17Z", "author": {"login": "shartte"}, "path": "fabric-registry-sync-v0/src/testmod/java/net/fabricmc/fabric/test/registry/sync/RegistrySyncTest.java", "diffHunk": "@@ -69,4 +77,53 @@ public void onInitialize() {\n \t\tValidate.isTrue(RegistryAttributeHolder.get(fabricRegistry).hasAttribute(RegistryAttribute.SYNCED));\n \t\tValidate.isTrue(!RegistryAttributeHolder.get(fabricRegistry).hasAttribute(RegistryAttribute.PERSISTED));\n \t}\n+\n+\t/**\n+\t * Tests that built-in registries are properly synchronized even after the dynamic reigstry managers have been\n+\t * class-loaded.\n+\t */\n+\tprivate void testBuiltInRegistrySync() {\n+\t\tSystem.out.println(\"Checking built-in registry sync...\");\n+\n+\t\t// Register a configured feature before force-loading the dynamic registry manager\n+\t\tConfiguredFeature<DefaultFeatureConfig, ?> cf1 = Feature.BASALT_PILLAR.configure(DefaultFeatureConfig.INSTANCE);\n+\t\tIdentifier f1Id = new Identifier(\"registry_sync\", \"f1\");\n+\t\tRegistry.register(BuiltinRegistries.CONFIGURED_FEATURE, f1Id, cf1);\n+\n+\t\t// Force-Initialize the dynamic registry manager, doing this in a Mod initializer would cause\n+\t\t// further registrations into BuiltInRegistries to _NOT_ propagate into DynamicRegistryManager.BUILTIN\n+\t\tcheckFeature(DynamicRegistryManager.create(), f1Id);\n+\n+\t\tConfiguredFeature<DefaultFeatureConfig, ?> cf2 = Feature.DESERT_WELL.configure(DefaultFeatureConfig.INSTANCE);\n+\t\tIdentifier f2Id = new Identifier(\"registry_sync\", \"f2\");\n+\t\tRegistry.register(BuiltinRegistries.CONFIGURED_FEATURE, f2Id, cf2);\n+\n+\t\tDynamicRegistryManager.Impl impl2 = DynamicRegistryManager.create();\n+\t\tcheckFeature(impl2, f1Id);\n+\t\tcheckFeature(impl2, f2Id);\n+\t}\n+\n+\tprivate void checkFeature(DynamicRegistryManager manager, Identifier id) {\n+\t\tMutableRegistry<ConfiguredFeature<?, ?>> registry = manager.get(Registry.CONFIGURED_FEATURE_WORLDGEN);\n+\n+\t\tConfiguredFeature<?, ?> builtInEntry = BuiltinRegistries.CONFIGURED_FEATURE.get(id);\n+\n+\t\tif (builtInEntry == null) {\n+\t\t\tthrow new IllegalStateException(\"Expected built-in entry to exist for: \" + id);\n+\t\t}\n+\n+\t\tConfiguredFeature<?, ?> entry = registry.get(id);\n+\n+\t\tif (entry == null) {\n+\t\t\tthrow new IllegalStateException(\"Expected dynamic registry to contain entry \" + id);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE1MDIzMQ=="}, "originalCommit": {"oid": "e98bf71fa873812ba87fa1b06ad5856e687f8fa0"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU0OTY5Mg==", "bodyText": "\ud83e\udd26 Ah heh, this is the testmod...\nI mean, I see your point now, but also think it probably doesnt matter for the testmod.", "url": "https://github.com/FabricMC/fabric/pull/1052#discussion_r487549692", "createdAt": "2020-09-13T16:31:12Z", "author": {"login": "shartte"}, "path": "fabric-registry-sync-v0/src/testmod/java/net/fabricmc/fabric/test/registry/sync/RegistrySyncTest.java", "diffHunk": "@@ -69,4 +77,53 @@ public void onInitialize() {\n \t\tValidate.isTrue(RegistryAttributeHolder.get(fabricRegistry).hasAttribute(RegistryAttribute.SYNCED));\n \t\tValidate.isTrue(!RegistryAttributeHolder.get(fabricRegistry).hasAttribute(RegistryAttribute.PERSISTED));\n \t}\n+\n+\t/**\n+\t * Tests that built-in registries are properly synchronized even after the dynamic reigstry managers have been\n+\t * class-loaded.\n+\t */\n+\tprivate void testBuiltInRegistrySync() {\n+\t\tSystem.out.println(\"Checking built-in registry sync...\");\n+\n+\t\t// Register a configured feature before force-loading the dynamic registry manager\n+\t\tConfiguredFeature<DefaultFeatureConfig, ?> cf1 = Feature.BASALT_PILLAR.configure(DefaultFeatureConfig.INSTANCE);\n+\t\tIdentifier f1Id = new Identifier(\"registry_sync\", \"f1\");\n+\t\tRegistry.register(BuiltinRegistries.CONFIGURED_FEATURE, f1Id, cf1);\n+\n+\t\t// Force-Initialize the dynamic registry manager, doing this in a Mod initializer would cause\n+\t\t// further registrations into BuiltInRegistries to _NOT_ propagate into DynamicRegistryManager.BUILTIN\n+\t\tcheckFeature(DynamicRegistryManager.create(), f1Id);\n+\n+\t\tConfiguredFeature<DefaultFeatureConfig, ?> cf2 = Feature.DESERT_WELL.configure(DefaultFeatureConfig.INSTANCE);\n+\t\tIdentifier f2Id = new Identifier(\"registry_sync\", \"f2\");\n+\t\tRegistry.register(BuiltinRegistries.CONFIGURED_FEATURE, f2Id, cf2);\n+\n+\t\tDynamicRegistryManager.Impl impl2 = DynamicRegistryManager.create();\n+\t\tcheckFeature(impl2, f1Id);\n+\t\tcheckFeature(impl2, f2Id);\n+\t}\n+\n+\tprivate void checkFeature(DynamicRegistryManager manager, Identifier id) {\n+\t\tMutableRegistry<ConfiguredFeature<?, ?>> registry = manager.get(Registry.CONFIGURED_FEATURE_WORLDGEN);\n+\n+\t\tConfiguredFeature<?, ?> builtInEntry = BuiltinRegistries.CONFIGURED_FEATURE.get(id);\n+\n+\t\tif (builtInEntry == null) {\n+\t\t\tthrow new IllegalStateException(\"Expected built-in entry to exist for: \" + id);\n+\t\t}\n+\n+\t\tConfiguredFeature<?, ?> entry = registry.get(id);\n+\n+\t\tif (entry == null) {\n+\t\t\tthrow new IllegalStateException(\"Expected dynamic registry to contain entry \" + id);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE1MDIzMQ=="}, "originalCommit": {"oid": "e98bf71fa873812ba87fa1b06ad5856e687f8fa0"}, "originalPosition": 72}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3455, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}