{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQwODYzMjY4", "number": 848, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwMjoxOTozNVrOENHeeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMVQxODo0NDowMFrOENhdKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMTg5NDMyOnYy", "diffSide": "RIGHT", "path": "fabric-lifecycle-events-v1/src/main/java/net/fabricmc/fabric/mixin/event/lifecycle/MinecraftServerMixin.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwMjoxOTozNVrOGvntSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQyMToxNzo1OVrOGwF5cg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU4NjgyNQ==", "bodyText": "I highly doubt the function passed to exceptionally runs on completable future's default executor's thread than on the server thread.", "url": "https://github.com/FabricMC/fabric/pull/848#discussion_r452586825", "createdAt": "2020-07-10T02:19:35Z", "author": {"login": "liach"}, "path": "fabric-lifecycle-events-v1/src/main/java/net/fabricmc/fabric/mixin/event/lifecycle/MinecraftServerMixin.java", "diffHunk": "@@ -73,4 +89,33 @@ private void closeWorld(CallbackInfo ci, Iterator<ServerWorld> worlds, ServerWor\n \t\t\tServerBlockEntityEvents.BLOCK_ENTITY_UNLOAD.invoker().onUnload(blockEntity, serverWorld);\n \t\t}\n \t}\n+\n+\t// The locals you have to manage for an inject are insane. And do it twice. A redirect is much cleaner.\n+\t// Here is what it looks like with an inject: https://gist.github.com/i509VCB/f80077cc536eb4dba62b794eba5611c1\n+\t@Redirect(method = \"createWorlds\", at = @At(value = \"INVOKE\", target = \"Ljava/util/Map;put(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\"))\n+\tprivate <K, V> V onLoadWorld(Map<K, V> worlds, K registryKey, V serverWorld) {\n+\t\tfinal V result = worlds.put(registryKey, serverWorld);\n+\t\tServerWorldEvents.LOAD.invoker().onWorldLoad((MinecraftServer) (Object) this, (ServerWorld) serverWorld);\n+\n+\t\treturn result;\n+\t}\n+\n+\t@Inject(method = \"reloadResources\", at = @At(\"HEAD\"))\n+\tprivate void beforeResourceReload(Collection<String> collection, CallbackInfoReturnable<CompletableFuture<Void>> cir) {\n+\t\tServerLifecycleEvents.START_DATA_PACK_RELOAD.invoker().startDataPackReload((MinecraftServer) (Object) this, this.serverResourceManager);\n+\t}\n+\n+\t@Inject(method = \"method_29440(Ljava/util/Collection;Lnet/minecraft/resource/ServerResourceManager;)V\", at = @At(\"TAIL\"))\n+\tprivate void afterResourceReload(Collection<String> enabledPacks, ServerResourceManager serverResourceManager, CallbackInfo ci) {\n+\t\tServerLifecycleEvents.END_DATA_PACK_RELOAD.invoker().endDataPackReload((MinecraftServer) (Object) this, this.serverResourceManager, true);\n+\t}\n+\n+\t@Inject(method = \"reloadResources\", at = @At(\"TAIL\"))\n+\tprivate void addResourceReloadFailureCallback(Collection<String> collection, CallbackInfoReturnable<CompletableFuture<Void>> cir) {\n+\t\t// Hook into fail\n+\t\tcir.getReturnValue().exceptionally(throwable -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9097c148da72e7311ab00635a1d2cad54942e061"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU5OTA2MA==", "bodyText": "I actually tested that, it does run on server thread.", "url": "https://github.com/FabricMC/fabric/pull/848#discussion_r452599060", "createdAt": "2020-07-10T03:10:52Z", "author": {"login": "i509VCB"}, "path": "fabric-lifecycle-events-v1/src/main/java/net/fabricmc/fabric/mixin/event/lifecycle/MinecraftServerMixin.java", "diffHunk": "@@ -73,4 +89,33 @@ private void closeWorld(CallbackInfo ci, Iterator<ServerWorld> worlds, ServerWor\n \t\t\tServerBlockEntityEvents.BLOCK_ENTITY_UNLOAD.invoker().onUnload(blockEntity, serverWorld);\n \t\t}\n \t}\n+\n+\t// The locals you have to manage for an inject are insane. And do it twice. A redirect is much cleaner.\n+\t// Here is what it looks like with an inject: https://gist.github.com/i509VCB/f80077cc536eb4dba62b794eba5611c1\n+\t@Redirect(method = \"createWorlds\", at = @At(value = \"INVOKE\", target = \"Ljava/util/Map;put(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\"))\n+\tprivate <K, V> V onLoadWorld(Map<K, V> worlds, K registryKey, V serverWorld) {\n+\t\tfinal V result = worlds.put(registryKey, serverWorld);\n+\t\tServerWorldEvents.LOAD.invoker().onWorldLoad((MinecraftServer) (Object) this, (ServerWorld) serverWorld);\n+\n+\t\treturn result;\n+\t}\n+\n+\t@Inject(method = \"reloadResources\", at = @At(\"HEAD\"))\n+\tprivate void beforeResourceReload(Collection<String> collection, CallbackInfoReturnable<CompletableFuture<Void>> cir) {\n+\t\tServerLifecycleEvents.START_DATA_PACK_RELOAD.invoker().startDataPackReload((MinecraftServer) (Object) this, this.serverResourceManager);\n+\t}\n+\n+\t@Inject(method = \"method_29440(Ljava/util/Collection;Lnet/minecraft/resource/ServerResourceManager;)V\", at = @At(\"TAIL\"))\n+\tprivate void afterResourceReload(Collection<String> enabledPacks, ServerResourceManager serverResourceManager, CallbackInfo ci) {\n+\t\tServerLifecycleEvents.END_DATA_PACK_RELOAD.invoker().endDataPackReload((MinecraftServer) (Object) this, this.serverResourceManager, true);\n+\t}\n+\n+\t@Inject(method = \"reloadResources\", at = @At(\"TAIL\"))\n+\tprivate void addResourceReloadFailureCallback(Collection<String> collection, CallbackInfoReturnable<CompletableFuture<Void>> cir) {\n+\t\t// Hook into fail\n+\t\tcir.getReturnValue().exceptionally(throwable -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU4NjgyNQ=="}, "originalCommit": {"oid": "9097c148da72e7311ab00635a1d2cad54942e061"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYwMDU2OA==", "bodyText": "I actually tested that\n\nThis sure runs on server thread if the completable future is completed. but if it isn't completed at that time, think something wrong will happen. Java only added a safe version of exceptionally exceptionallyAsync in 12\nhttps://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/concurrent/CompletionStage.html#exceptionallyAsync(java.util.function.Function,java.util.concurrent.Executor)\nAs a result you should use handleAsync instead https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/concurrent/CompletionStage.html#handleAsync(java.util.function.BiFunction,java.util.concurrent.Executor)\nsee https://stackoverflow.com/questions/38254268/completablefuture-exceptionally-with-executor", "url": "https://github.com/FabricMC/fabric/pull/848#discussion_r452600568", "createdAt": "2020-07-10T03:17:54Z", "author": {"login": "liach"}, "path": "fabric-lifecycle-events-v1/src/main/java/net/fabricmc/fabric/mixin/event/lifecycle/MinecraftServerMixin.java", "diffHunk": "@@ -73,4 +89,33 @@ private void closeWorld(CallbackInfo ci, Iterator<ServerWorld> worlds, ServerWor\n \t\t\tServerBlockEntityEvents.BLOCK_ENTITY_UNLOAD.invoker().onUnload(blockEntity, serverWorld);\n \t\t}\n \t}\n+\n+\t// The locals you have to manage for an inject are insane. And do it twice. A redirect is much cleaner.\n+\t// Here is what it looks like with an inject: https://gist.github.com/i509VCB/f80077cc536eb4dba62b794eba5611c1\n+\t@Redirect(method = \"createWorlds\", at = @At(value = \"INVOKE\", target = \"Ljava/util/Map;put(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\"))\n+\tprivate <K, V> V onLoadWorld(Map<K, V> worlds, K registryKey, V serverWorld) {\n+\t\tfinal V result = worlds.put(registryKey, serverWorld);\n+\t\tServerWorldEvents.LOAD.invoker().onWorldLoad((MinecraftServer) (Object) this, (ServerWorld) serverWorld);\n+\n+\t\treturn result;\n+\t}\n+\n+\t@Inject(method = \"reloadResources\", at = @At(\"HEAD\"))\n+\tprivate void beforeResourceReload(Collection<String> collection, CallbackInfoReturnable<CompletableFuture<Void>> cir) {\n+\t\tServerLifecycleEvents.START_DATA_PACK_RELOAD.invoker().startDataPackReload((MinecraftServer) (Object) this, this.serverResourceManager);\n+\t}\n+\n+\t@Inject(method = \"method_29440(Ljava/util/Collection;Lnet/minecraft/resource/ServerResourceManager;)V\", at = @At(\"TAIL\"))\n+\tprivate void afterResourceReload(Collection<String> enabledPacks, ServerResourceManager serverResourceManager, CallbackInfo ci) {\n+\t\tServerLifecycleEvents.END_DATA_PACK_RELOAD.invoker().endDataPackReload((MinecraftServer) (Object) this, this.serverResourceManager, true);\n+\t}\n+\n+\t@Inject(method = \"reloadResources\", at = @At(\"TAIL\"))\n+\tprivate void addResourceReloadFailureCallback(Collection<String> collection, CallbackInfoReturnable<CompletableFuture<Void>> cir) {\n+\t\t// Hook into fail\n+\t\tcir.getReturnValue().exceptionally(throwable -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU4NjgyNQ=="}, "originalCommit": {"oid": "9097c148da72e7311ab00635a1d2cad54942e061"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYwNzQxNQ==", "bodyText": "So handleAsync actually reduces the amount of injects we need by one. Should this be using the future's current thread or the server thread? (within handleAsync as the executor)", "url": "https://github.com/FabricMC/fabric/pull/848#discussion_r452607415", "createdAt": "2020-07-10T03:48:18Z", "author": {"login": "i509VCB"}, "path": "fabric-lifecycle-events-v1/src/main/java/net/fabricmc/fabric/mixin/event/lifecycle/MinecraftServerMixin.java", "diffHunk": "@@ -73,4 +89,33 @@ private void closeWorld(CallbackInfo ci, Iterator<ServerWorld> worlds, ServerWor\n \t\t\tServerBlockEntityEvents.BLOCK_ENTITY_UNLOAD.invoker().onUnload(blockEntity, serverWorld);\n \t\t}\n \t}\n+\n+\t// The locals you have to manage for an inject are insane. And do it twice. A redirect is much cleaner.\n+\t// Here is what it looks like with an inject: https://gist.github.com/i509VCB/f80077cc536eb4dba62b794eba5611c1\n+\t@Redirect(method = \"createWorlds\", at = @At(value = \"INVOKE\", target = \"Ljava/util/Map;put(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\"))\n+\tprivate <K, V> V onLoadWorld(Map<K, V> worlds, K registryKey, V serverWorld) {\n+\t\tfinal V result = worlds.put(registryKey, serverWorld);\n+\t\tServerWorldEvents.LOAD.invoker().onWorldLoad((MinecraftServer) (Object) this, (ServerWorld) serverWorld);\n+\n+\t\treturn result;\n+\t}\n+\n+\t@Inject(method = \"reloadResources\", at = @At(\"HEAD\"))\n+\tprivate void beforeResourceReload(Collection<String> collection, CallbackInfoReturnable<CompletableFuture<Void>> cir) {\n+\t\tServerLifecycleEvents.START_DATA_PACK_RELOAD.invoker().startDataPackReload((MinecraftServer) (Object) this, this.serverResourceManager);\n+\t}\n+\n+\t@Inject(method = \"method_29440(Ljava/util/Collection;Lnet/minecraft/resource/ServerResourceManager;)V\", at = @At(\"TAIL\"))\n+\tprivate void afterResourceReload(Collection<String> enabledPacks, ServerResourceManager serverResourceManager, CallbackInfo ci) {\n+\t\tServerLifecycleEvents.END_DATA_PACK_RELOAD.invoker().endDataPackReload((MinecraftServer) (Object) this, this.serverResourceManager, true);\n+\t}\n+\n+\t@Inject(method = \"reloadResources\", at = @At(\"TAIL\"))\n+\tprivate void addResourceReloadFailureCallback(Collection<String> collection, CallbackInfoReturnable<CompletableFuture<Void>> cir) {\n+\t\t// Hook into fail\n+\t\tcir.getReturnValue().exceptionally(throwable -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU4NjgyNQ=="}, "originalCommit": {"oid": "9097c148da72e7311ab00635a1d2cad54942e061"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA4MTQ1OA==", "bodyText": "Handle async with server executor would probably be executed 1 tick after the reload is done given how server task scheduling works, but should be safe if we look at data packs' functions (\"minecraft:load\" function tag is executed 1 tick late too) \ud83d\udc4d so your current work should be great", "url": "https://github.com/FabricMC/fabric/pull/848#discussion_r453081458", "createdAt": "2020-07-10T21:17:59Z", "author": {"login": "liach"}, "path": "fabric-lifecycle-events-v1/src/main/java/net/fabricmc/fabric/mixin/event/lifecycle/MinecraftServerMixin.java", "diffHunk": "@@ -73,4 +89,33 @@ private void closeWorld(CallbackInfo ci, Iterator<ServerWorld> worlds, ServerWor\n \t\t\tServerBlockEntityEvents.BLOCK_ENTITY_UNLOAD.invoker().onUnload(blockEntity, serverWorld);\n \t\t}\n \t}\n+\n+\t// The locals you have to manage for an inject are insane. And do it twice. A redirect is much cleaner.\n+\t// Here is what it looks like with an inject: https://gist.github.com/i509VCB/f80077cc536eb4dba62b794eba5611c1\n+\t@Redirect(method = \"createWorlds\", at = @At(value = \"INVOKE\", target = \"Ljava/util/Map;put(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\"))\n+\tprivate <K, V> V onLoadWorld(Map<K, V> worlds, K registryKey, V serverWorld) {\n+\t\tfinal V result = worlds.put(registryKey, serverWorld);\n+\t\tServerWorldEvents.LOAD.invoker().onWorldLoad((MinecraftServer) (Object) this, (ServerWorld) serverWorld);\n+\n+\t\treturn result;\n+\t}\n+\n+\t@Inject(method = \"reloadResources\", at = @At(\"HEAD\"))\n+\tprivate void beforeResourceReload(Collection<String> collection, CallbackInfoReturnable<CompletableFuture<Void>> cir) {\n+\t\tServerLifecycleEvents.START_DATA_PACK_RELOAD.invoker().startDataPackReload((MinecraftServer) (Object) this, this.serverResourceManager);\n+\t}\n+\n+\t@Inject(method = \"method_29440(Ljava/util/Collection;Lnet/minecraft/resource/ServerResourceManager;)V\", at = @At(\"TAIL\"))\n+\tprivate void afterResourceReload(Collection<String> enabledPacks, ServerResourceManager serverResourceManager, CallbackInfo ci) {\n+\t\tServerLifecycleEvents.END_DATA_PACK_RELOAD.invoker().endDataPackReload((MinecraftServer) (Object) this, this.serverResourceManager, true);\n+\t}\n+\n+\t@Inject(method = \"reloadResources\", at = @At(\"TAIL\"))\n+\tprivate void addResourceReloadFailureCallback(Collection<String> collection, CallbackInfoReturnable<CompletableFuture<Void>> cir) {\n+\t\t// Hook into fail\n+\t\tcir.getReturnValue().exceptionally(throwable -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU4NjgyNQ=="}, "originalCommit": {"oid": "9097c148da72e7311ab00635a1d2cad54942e061"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyNjE1MDgzOnYy", "diffSide": "RIGHT", "path": "fabric-lifecycle-events-v1/src/main/java/net/fabricmc/fabric/mixin/event/lifecycle/MinecraftServerMixin.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMVQxODo0NDowMFrOGwOiCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMVQxODo1MDoxM1rOGwOj-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzIyMjkyMQ==", "bodyText": "Doesn't that @At need a remap = false so that the mixin AP doesn't complain?", "url": "https://github.com/FabricMC/fabric/pull/848#discussion_r453222921", "createdAt": "2020-07-11T18:44:00Z", "author": {"login": "Juuxel"}, "path": "fabric-lifecycle-events-v1/src/main/java/net/fabricmc/fabric/mixin/event/lifecycle/MinecraftServerMixin.java", "diffHunk": "@@ -73,4 +89,28 @@ private void closeWorld(CallbackInfo ci, Iterator<ServerWorld> worlds, ServerWor\n \t\t\tServerBlockEntityEvents.BLOCK_ENTITY_UNLOAD.invoker().onUnload(blockEntity, serverWorld);\n \t\t}\n \t}\n+\n+\t// The locals you have to manage for an inject are insane. And do it twice. A redirect is much cleaner.\n+\t// Here is what it looks like with an inject: https://gist.github.com/i509VCB/f80077cc536eb4dba62b794eba5611c1\n+\t@Redirect(method = \"createWorlds\", at = @At(value = \"INVOKE\", target = \"Ljava/util/Map;put(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\"))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec5435801caba381fc0cff8271e441e500243bba"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzIyMzQxOQ==", "bodyText": "Probably a larger issue tbf since the mixin ap screechs on half the modules", "url": "https://github.com/FabricMC/fabric/pull/848#discussion_r453223419", "createdAt": "2020-07-11T18:50:13Z", "author": {"login": "i509VCB"}, "path": "fabric-lifecycle-events-v1/src/main/java/net/fabricmc/fabric/mixin/event/lifecycle/MinecraftServerMixin.java", "diffHunk": "@@ -73,4 +89,28 @@ private void closeWorld(CallbackInfo ci, Iterator<ServerWorld> worlds, ServerWor\n \t\t\tServerBlockEntityEvents.BLOCK_ENTITY_UNLOAD.invoker().onUnload(blockEntity, serverWorld);\n \t\t}\n \t}\n+\n+\t// The locals you have to manage for an inject are insane. And do it twice. A redirect is much cleaner.\n+\t// Here is what it looks like with an inject: https://gist.github.com/i509VCB/f80077cc536eb4dba62b794eba5611c1\n+\t@Redirect(method = \"createWorlds\", at = @At(value = \"INVOKE\", target = \"Ljava/util/Map;put(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\"))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzIyMjkyMQ=="}, "originalCommit": {"oid": "ec5435801caba381fc0cff8271e441e500243bba"}, "originalPosition": 51}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3393, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}