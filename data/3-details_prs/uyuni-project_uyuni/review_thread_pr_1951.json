{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc5NDE3MDIw", "number": 1951, "reviewThreads": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQwODowNzo1MFrODimaMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxNDo1ODoyN1rODlE6_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NjA3NDc1OnYy", "diffSide": "RIGHT", "path": "schema/spacewalk/common/tables/suseRecurringAction.sql", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQwODowNzo1MFrOFt7_8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMzo1NjoxM1rOFuG8yA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzcxMzI2Nw==", "bodyText": "postgresql syntax please.", "url": "https://github.com/uyuni-project/uyuni/pull/1951#discussion_r383713267", "createdAt": "2020-02-25T08:07:50Z", "author": {"login": "mcalmer"}, "path": "schema/spacewalk/common/tables/suseRecurringAction.sql", "diffHunk": "@@ -0,0 +1,24 @@\n+CREATE TABLE suseRecurringAction\n+(\n+  id                number NOT NULL\n+                    CONSTRAINT suse_recurring_action_id_pk PRIMARY KEY,\n+  target_type        VARCHAR2(32) NOT NULL,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8d0642fabf68c3f35dc41105506dfd8d9d0f5b7"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg5MjY4MA==", "bodyText": "Done ;-)", "url": "https://github.com/uyuni-project/uyuni/pull/1951#discussion_r383892680", "createdAt": "2020-02-25T13:56:13Z", "author": {"login": "parlt91"}, "path": "schema/spacewalk/common/tables/suseRecurringAction.sql", "diffHunk": "@@ -0,0 +1,24 @@\n+CREATE TABLE suseRecurringAction\n+(\n+  id                number NOT NULL\n+                    CONSTRAINT suse_recurring_action_id_pk PRIMARY KEY,\n+  target_type        VARCHAR2(32) NOT NULL,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzcxMzI2Nw=="}, "originalCommit": {"oid": "a8d0642fabf68c3f35dc41105506dfd8d9d0f5b7"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NjQ0NjE0OnYy", "diffSide": "RIGHT", "path": "java/code/src/com/redhat/rhn/domain/recurringactions/GroupRecurringAction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQwOTo1Njo0MlrOFt_mww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQwOTo1Njo0MlrOFt_mww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc3MjM1NQ==", "bodyText": "Nit: I'd suggest a clearer phrasing here. When I see Recurring Action group, then I think about groups of recurring actions, not about a recurring action for group. I'd be more for \"Recurring Action for server group implementation\", or similar.", "url": "https://github.com/uyuni-project/uyuni/pull/1951#discussion_r383772355", "createdAt": "2020-02-25T09:56:42Z", "author": {"login": "hustodemon"}, "path": "java/code/src/com/redhat/rhn/domain/recurringactions/GroupRecurringAction.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.redhat.rhn.domain.recurringactions;\n+\n+import com.redhat.rhn.domain.server.MinionServer;\n+import com.redhat.rhn.domain.server.ServerGroup;\n+import com.redhat.rhn.domain.server.ServerGroupFactory;\n+\n+import com.suse.manager.utils.MinionServerUtils;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import javax.persistence.DiscriminatorValue;\n+import javax.persistence.Entity;\n+import javax.persistence.JoinColumn;\n+import javax.persistence.ManyToOne;\n+\n+/**\n+ * Recurring Action group implementation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fb55f8d79b8b2bb580836a6968d9dd99a940933"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NjQ0ODY3OnYy", "diffSide": "RIGHT", "path": "java/code/src/com/redhat/rhn/domain/recurringactions/test/RecurringActionFactoryTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQwOTo1NzoxOVrOFt_oRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQwOTo1NzoxOVrOFt_oRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc3Mjc0Mg==", "bodyText": "This could be simplified by using ServerGroupTestUtils.createManaged(user) to create a group.", "url": "https://github.com/uyuni-project/uyuni/pull/1951#discussion_r383772742", "createdAt": "2020-02-25T09:57:19Z", "author": {"login": "hustodemon"}, "path": "java/code/src/com/redhat/rhn/domain/recurringactions/test/RecurringActionFactoryTest.java", "diffHunk": "@@ -0,0 +1,52 @@\n+package com.redhat.rhn.domain.recurringactions.test;\n+\n+import com.redhat.rhn.domain.org.OrgFactory;\n+import com.redhat.rhn.domain.recurringactions.GroupRecurringAction;\n+import com.redhat.rhn.domain.recurringactions.MinionRecurringAction;\n+import com.redhat.rhn.domain.recurringactions.OrgRecurringAction;\n+import com.redhat.rhn.domain.recurringactions.RecurringActionFactory;\n+import com.redhat.rhn.domain.server.ServerGroupFactory;\n+import com.redhat.rhn.domain.server.test.MinionServerFactoryTest;\n+import com.redhat.rhn.testing.BaseTestCaseWithUser;\n+import com.redhat.rhn.testing.ServerGroupTestUtils;\n+import com.redhat.rhn.testing.TestUtils;\n+\n+import java.util.List;\n+\n+public class RecurringActionFactoryTest extends BaseTestCaseWithUser {\n+\n+    public void testListMinionRecurringAction() throws Exception {\n+        var action = new MinionRecurringAction();\n+        var minion = MinionServerFactoryTest.createTestMinionServer(user);\n+        action.setMinion(minion);\n+        RecurringActionFactory.save(action);\n+\n+        assertEquals(List.of(action), RecurringActionFactory.listMinionRecurringActions(minion.getId()));\n+    }\n+\n+    public void testListGroupRecurringAction() {\n+        var action = new GroupRecurringAction();\n+        var group = ServerGroupFactory.create(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fb55f8d79b8b2bb580836a6968d9dd99a940933"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NjQ1Mzg0OnYy", "diffSide": "RIGHT", "path": "java/code/src/com/redhat/rhn/manager/recurringactions/RecurringActionManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQwOTo1ODo0NVrOFt_rjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQwOTo1ODo0NVrOFt_rjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc3MzU4MA==", "bodyText": "Small nitpick: using INSTANCE for singletons seems to be more frequent in the code. Consider using it too.", "url": "https://github.com/uyuni-project/uyuni/pull/1951#discussion_r383773580", "createdAt": "2020-02-25T09:58:45Z", "author": {"login": "hustodemon"}, "path": "java/code/src/com/redhat/rhn/manager/recurringactions/RecurringActionManager.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.redhat.rhn.manager.recurringactions;\n+\n+import com.redhat.rhn.common.hibernate.LookupException;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.domain.recurringactions.GroupRecurringAction;\n+import com.redhat.rhn.domain.recurringactions.MinionRecurringAction;\n+import com.redhat.rhn.domain.recurringactions.OrgRecurringAction;\n+import com.redhat.rhn.domain.recurringactions.RecurringActionFactory;\n+import com.redhat.rhn.domain.role.RoleFactory;\n+import com.redhat.rhn.domain.server.MinionServer;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.EntityNotExistsException;\n+import com.redhat.rhn.manager.system.ServerGroupManager;\n+import com.redhat.rhn.manager.system.SystemManager;\n+import com.redhat.rhn.taskomatic.TaskomaticApi;\n+import com.redhat.rhn.taskomatic.TaskomaticApiException;\n+\n+import java.util.List;\n+\n+/**\n+ * RecurringActionManager\n+ * @version $Rev$\n+ */\n+public class RecurringActionManager {\n+\n+    private static  TaskomaticApi taskomaticApi = new TaskomaticApi();\n+    private static final RecurringActionManager MANAGER = new RecurringActionManager();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fb55f8d79b8b2bb580836a6968d9dd99a940933"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NjQ1NjEzOnYy", "diffSide": "RIGHT", "path": "java/code/src/com/redhat/rhn/domain/recurringactions/test/RecurringActionFactoryTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQwOTo1OToxN1rOFt_s7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQwOTo1OToxN1rOFt_s7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc3MzkzNA==", "bodyText": "Nit: plural.", "url": "https://github.com/uyuni-project/uyuni/pull/1951#discussion_r383773934", "createdAt": "2020-02-25T09:59:17Z", "author": {"login": "hustodemon"}, "path": "java/code/src/com/redhat/rhn/domain/recurringactions/test/RecurringActionFactoryTest.java", "diffHunk": "@@ -0,0 +1,52 @@\n+package com.redhat.rhn.domain.recurringactions.test;\n+\n+import com.redhat.rhn.domain.org.OrgFactory;\n+import com.redhat.rhn.domain.recurringactions.GroupRecurringAction;\n+import com.redhat.rhn.domain.recurringactions.MinionRecurringAction;\n+import com.redhat.rhn.domain.recurringactions.OrgRecurringAction;\n+import com.redhat.rhn.domain.recurringactions.RecurringActionFactory;\n+import com.redhat.rhn.domain.server.ServerGroupFactory;\n+import com.redhat.rhn.domain.server.test.MinionServerFactoryTest;\n+import com.redhat.rhn.testing.BaseTestCaseWithUser;\n+import com.redhat.rhn.testing.ServerGroupTestUtils;\n+import com.redhat.rhn.testing.TestUtils;\n+\n+import java.util.List;\n+\n+public class RecurringActionFactoryTest extends BaseTestCaseWithUser {\n+\n+    public void testListMinionRecurringAction() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fb55f8d79b8b2bb580836a6968d9dd99a940933"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NjQ1OTUzOnYy", "diffSide": "RIGHT", "path": "java/code/src/com/redhat/rhn/manager/recurringactions/RecurringActionManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMDowMDoxMlrOFt_vGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMDowMDoxMlrOFt_vGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc3NDQ5MA==", "bodyText": "Please use the plural in the name (as we do in the Factory class, after all): listMinionRecurringActions. The same goes for the rest of the list* methods in this class.", "url": "https://github.com/uyuni-project/uyuni/pull/1951#discussion_r383774490", "createdAt": "2020-02-25T10:00:12Z", "author": {"login": "hustodemon"}, "path": "java/code/src/com/redhat/rhn/manager/recurringactions/RecurringActionManager.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.redhat.rhn.manager.recurringactions;\n+\n+import com.redhat.rhn.common.hibernate.LookupException;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.domain.recurringactions.GroupRecurringAction;\n+import com.redhat.rhn.domain.recurringactions.MinionRecurringAction;\n+import com.redhat.rhn.domain.recurringactions.OrgRecurringAction;\n+import com.redhat.rhn.domain.recurringactions.RecurringActionFactory;\n+import com.redhat.rhn.domain.role.RoleFactory;\n+import com.redhat.rhn.domain.server.MinionServer;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.EntityNotExistsException;\n+import com.redhat.rhn.manager.system.ServerGroupManager;\n+import com.redhat.rhn.manager.system.SystemManager;\n+import com.redhat.rhn.taskomatic.TaskomaticApi;\n+import com.redhat.rhn.taskomatic.TaskomaticApiException;\n+\n+import java.util.List;\n+\n+/**\n+ * RecurringActionManager\n+ * @version $Rev$\n+ */\n+public class RecurringActionManager {\n+\n+    private static  TaskomaticApi taskomaticApi = new TaskomaticApi();\n+    private static final RecurringActionManager MANAGER = new RecurringActionManager();\n+\n+    /**\n+     * Set the {@link TaskomaticApi} instance to use. Only needed for unit tests.\n+     * @param taskomaticApiIn the {@link TaskomaticApi}\n+     */\n+    public static void setTaskomaticApi(TaskomaticApi taskomaticApiIn) {\n+        taskomaticApi = taskomaticApiIn;\n+    }\n+    /**\n+     * Singleton Instance to get manager object\n+     * @return an instance of the manager\n+     */\n+    public static RecurringActionManager getInstance() {\n+        return MANAGER;\n+    }\n+\n+    /**\n+     * Private constructor.\n+     */\n+    private RecurringActionManager() {\n+    }\n+\n+    /**\n+     * Create a new minion recurring action\n+     *\n+     * @param minionId id of the minion\n+     * @param cron the cron expression\n+     * @param testMode if test mode\n+     * @param active is is active\n+     * @param user the user\n+     * @throws TaskomaticApiException if TaskoSchedule creation fails\n+     */\n+    public static void createMinionRecurringAction(long minionId, String cron, boolean testMode,\n+                                                   boolean active, User user) throws TaskomaticApiException {\n+        if (!SystemManager.isAvailableToUser(user, minionId)) {\n+            throw new PermissionException(\"Minion not accessible to user\");\n+        }\n+        MinionServer minion = MinionServerFactory.lookupById(minionId)\n+                .orElseThrow(() -> new EntityNotExistsException(MinionServer.class, minionId));\n+        MinionRecurringAction action = new MinionRecurringAction(testMode, active, minion);\n+        RecurringActionFactory.save(action);\n+\n+        taskomaticApi.scheduleSatBunch(user, action.computeTaskoScheduleName(), \"recurring-state-apply-bunch\", cron);\n+    }\n+\n+    /**\n+     * List minion recurring action with minion id\n+     *\n+     * @param minionId id of the minion\n+     * @param user the user\n+     * @return list of minion recurring actions\n+     */\n+    public static List<MinionRecurringAction> listMinionRecurringAction(long minionId, User user) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fb55f8d79b8b2bb580836a6968d9dd99a940933"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NjQ2MTU4OnYy", "diffSide": "RIGHT", "path": "java/code/src/com/redhat/rhn/manager/recurringactions/test/RecurringActionManagerTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMDowMDo0MlrOFt_wRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMDowMDo0MlrOFt_wRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc3NDc4OA==", "bodyText": "Please use plural here too.", "url": "https://github.com/uyuni-project/uyuni/pull/1951#discussion_r383774788", "createdAt": "2020-02-25T10:00:42Z", "author": {"login": "hustodemon"}, "path": "java/code/src/com/redhat/rhn/manager/recurringactions/test/RecurringActionManagerTest.java", "diffHunk": "@@ -0,0 +1,120 @@\n+package com.redhat.rhn.manager.recurringactions.test;\n+\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.domain.org.Org;\n+import com.redhat.rhn.domain.recurringactions.GroupRecurringAction;\n+import com.redhat.rhn.domain.recurringactions.MinionRecurringAction;\n+import com.redhat.rhn.domain.recurringactions.OrgRecurringAction;\n+import com.redhat.rhn.domain.recurringactions.RecurringActionFactory;\n+import com.redhat.rhn.domain.role.RoleFactory;\n+import com.redhat.rhn.domain.server.ManagedServerGroup;\n+import com.redhat.rhn.domain.server.test.MinionServerFactoryTest;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.recurringactions.RecurringActionManager;\n+import com.redhat.rhn.manager.system.ServerGroupManager;\n+import com.redhat.rhn.taskomatic.TaskomaticApi;\n+import com.redhat.rhn.testing.BaseTestCaseWithUser;\n+import com.redhat.rhn.testing.ServerGroupTestUtils;\n+import com.redhat.rhn.testing.UserTestUtils;\n+\n+import org.jmock.Expectations;\n+import org.jmock.Mockery;\n+import org.jmock.integration.junit3.JUnit3Mockery;\n+import org.jmock.lib.concurrent.Synchroniser;\n+import org.jmock.lib.legacy.ClassImposteriser;\n+\n+import java.util.List;\n+\n+public class RecurringActionManagerTest extends BaseTestCaseWithUser {\n+\n+    private static final Mockery CONTEXT = new JUnit3Mockery() {{\n+        setThreadingPolicy(new Synchroniser());\n+    }};\n+\n+    private Org anotherOrg;\n+    private User anotherUser;\n+\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        user.addPermanentRole(RoleFactory.ORG_ADMIN);\n+        anotherOrg = UserTestUtils.createNewOrgFull(\"anotherOrg\");\n+        anotherUser = UserTestUtils.createUser(\"anotherUser\", anotherOrg.getId());\n+    }\n+\n+    public void testCreateMinionRecurringAction() throws Exception {\n+        CONTEXT.setImposteriser(ClassImposteriser.INSTANCE);\n+        TaskomaticApi taskomaticMock = CONTEXT.mock(TaskomaticApi.class);\n+        RecurringActionManager.setTaskomaticApi(taskomaticMock);\n+\n+        var minion = MinionServerFactoryTest.createTestMinionServer(user);\n+\n+        CONTEXT.checking(new Expectations() { {\n+            allowing(taskomaticMock).scheduleSatBunch(with(any(User.class)), with(any(String.class)), with(any(String.class)), with(any(String.class)));\n+        } });\n+\n+        try {\n+            RecurringActionManager.createMinionRecurringAction(minion.getId(), \"\", false, false, anotherUser);\n+            fail(\"User shouldn't have access\");\n+        }\n+        catch (PermissionException e) {\n+            // no-op\n+        }\n+\n+        RecurringActionManager.createMinionRecurringAction(minion.getId(), \"\", false, false, user);\n+        assertNotEmpty(RecurringActionFactory.listMinionRecurringActions(minion.getId()));\n+    }\n+\n+    public void testListMinionRecurringAction() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fb55f8d79b8b2bb580836a6968d9dd99a940933"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NjQ3MTkxOnYy", "diffSide": "RIGHT", "path": "java/code/src/com/redhat/rhn/manager/recurringactions/RecurringActionManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMDowMzozM1rOFt_2eQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMDowMzozM1rOFt_2eQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc3NjM3Nw==", "bodyText": "You could pass the cause exception to the newly created PermissionException as follows:\nPermissionException(\"User does not have access to group\", e);", "url": "https://github.com/uyuni-project/uyuni/pull/1951#discussion_r383776377", "createdAt": "2020-02-25T10:03:33Z", "author": {"login": "hustodemon"}, "path": "java/code/src/com/redhat/rhn/manager/recurringactions/RecurringActionManager.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.redhat.rhn.manager.recurringactions;\n+\n+import com.redhat.rhn.common.hibernate.LookupException;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.domain.recurringactions.GroupRecurringAction;\n+import com.redhat.rhn.domain.recurringactions.MinionRecurringAction;\n+import com.redhat.rhn.domain.recurringactions.OrgRecurringAction;\n+import com.redhat.rhn.domain.recurringactions.RecurringActionFactory;\n+import com.redhat.rhn.domain.role.RoleFactory;\n+import com.redhat.rhn.domain.server.MinionServer;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.EntityNotExistsException;\n+import com.redhat.rhn.manager.system.ServerGroupManager;\n+import com.redhat.rhn.manager.system.SystemManager;\n+import com.redhat.rhn.taskomatic.TaskomaticApi;\n+import com.redhat.rhn.taskomatic.TaskomaticApiException;\n+\n+import java.util.List;\n+\n+/**\n+ * RecurringActionManager\n+ * @version $Rev$\n+ */\n+public class RecurringActionManager {\n+\n+    private static  TaskomaticApi taskomaticApi = new TaskomaticApi();\n+    private static final RecurringActionManager MANAGER = new RecurringActionManager();\n+\n+    /**\n+     * Set the {@link TaskomaticApi} instance to use. Only needed for unit tests.\n+     * @param taskomaticApiIn the {@link TaskomaticApi}\n+     */\n+    public static void setTaskomaticApi(TaskomaticApi taskomaticApiIn) {\n+        taskomaticApi = taskomaticApiIn;\n+    }\n+    /**\n+     * Singleton Instance to get manager object\n+     * @return an instance of the manager\n+     */\n+    public static RecurringActionManager getInstance() {\n+        return MANAGER;\n+    }\n+\n+    /**\n+     * Private constructor.\n+     */\n+    private RecurringActionManager() {\n+    }\n+\n+    /**\n+     * Create a new minion recurring action\n+     *\n+     * @param minionId id of the minion\n+     * @param cron the cron expression\n+     * @param testMode if test mode\n+     * @param active is is active\n+     * @param user the user\n+     * @throws TaskomaticApiException if TaskoSchedule creation fails\n+     */\n+    public static void createMinionRecurringAction(long minionId, String cron, boolean testMode,\n+                                                   boolean active, User user) throws TaskomaticApiException {\n+        if (!SystemManager.isAvailableToUser(user, minionId)) {\n+            throw new PermissionException(\"Minion not accessible to user\");\n+        }\n+        MinionServer minion = MinionServerFactory.lookupById(minionId)\n+                .orElseThrow(() -> new EntityNotExistsException(MinionServer.class, minionId));\n+        MinionRecurringAction action = new MinionRecurringAction(testMode, active, minion);\n+        RecurringActionFactory.save(action);\n+\n+        taskomaticApi.scheduleSatBunch(user, action.computeTaskoScheduleName(), \"recurring-state-apply-bunch\", cron);\n+    }\n+\n+    /**\n+     * List minion recurring action with minion id\n+     *\n+     * @param minionId id of the minion\n+     * @param user the user\n+     * @return list of minion recurring actions\n+     */\n+    public static List<MinionRecurringAction> listMinionRecurringAction(long minionId, User user) {\n+        if (!SystemManager.isAvailableToUser(user, minionId)) {\n+            throw new PermissionException(\"Minion not accessible to user\");\n+        }\n+        return RecurringActionFactory.listMinionRecurringActions(minionId);\n+    }\n+\n+    /**\n+     * List group recurring action with group id\n+     *\n+     * @param groupId id of the group\n+     * @param user the user\n+     * @return list of group recurring actions\n+     */\n+    public static List<GroupRecurringAction> listGroupRecurringAction(long groupId, User user) {\n+        ServerGroupManager groupManager = ServerGroupManager.getInstance();\n+        if (!user.hasRole(RoleFactory.SYSTEM_GROUP_ADMIN)) {\n+            throw new PermissionException(\"User does not have access to group\");\n+        }\n+        try {\n+            groupManager.lookup(groupId, user);\n+            return RecurringActionFactory.listGroupRecurringActions(groupId);\n+        }\n+        catch (LookupException e) {\n+            throw new PermissionException(\"User does not have access to group\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fb55f8d79b8b2bb580836a6968d9dd99a940933"}, "originalPosition": 120}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NjQ5MzI3OnYy", "diffSide": "RIGHT", "path": "java/code/src/com/redhat/rhn/manager/recurringactions/RecurringActionManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMDowOToyNlrOFuADSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMDowOToyNlrOFuADSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc3OTY1Nw==", "bodyText": "Hmm, I think the presence lookup could confuse the readers a bit. Could you add here an explicit comment, that we're doing it for permission checking?", "url": "https://github.com/uyuni-project/uyuni/pull/1951#discussion_r383779657", "createdAt": "2020-02-25T10:09:26Z", "author": {"login": "hustodemon"}, "path": "java/code/src/com/redhat/rhn/manager/recurringactions/RecurringActionManager.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.redhat.rhn.manager.recurringactions;\n+\n+import com.redhat.rhn.common.hibernate.LookupException;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.domain.recurringactions.GroupRecurringAction;\n+import com.redhat.rhn.domain.recurringactions.MinionRecurringAction;\n+import com.redhat.rhn.domain.recurringactions.OrgRecurringAction;\n+import com.redhat.rhn.domain.recurringactions.RecurringActionFactory;\n+import com.redhat.rhn.domain.role.RoleFactory;\n+import com.redhat.rhn.domain.server.MinionServer;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.EntityNotExistsException;\n+import com.redhat.rhn.manager.system.ServerGroupManager;\n+import com.redhat.rhn.manager.system.SystemManager;\n+import com.redhat.rhn.taskomatic.TaskomaticApi;\n+import com.redhat.rhn.taskomatic.TaskomaticApiException;\n+\n+import java.util.List;\n+\n+/**\n+ * RecurringActionManager\n+ * @version $Rev$\n+ */\n+public class RecurringActionManager {\n+\n+    private static  TaskomaticApi taskomaticApi = new TaskomaticApi();\n+    private static final RecurringActionManager MANAGER = new RecurringActionManager();\n+\n+    /**\n+     * Set the {@link TaskomaticApi} instance to use. Only needed for unit tests.\n+     * @param taskomaticApiIn the {@link TaskomaticApi}\n+     */\n+    public static void setTaskomaticApi(TaskomaticApi taskomaticApiIn) {\n+        taskomaticApi = taskomaticApiIn;\n+    }\n+    /**\n+     * Singleton Instance to get manager object\n+     * @return an instance of the manager\n+     */\n+    public static RecurringActionManager getInstance() {\n+        return MANAGER;\n+    }\n+\n+    /**\n+     * Private constructor.\n+     */\n+    private RecurringActionManager() {\n+    }\n+\n+    /**\n+     * Create a new minion recurring action\n+     *\n+     * @param minionId id of the minion\n+     * @param cron the cron expression\n+     * @param testMode if test mode\n+     * @param active is is active\n+     * @param user the user\n+     * @throws TaskomaticApiException if TaskoSchedule creation fails\n+     */\n+    public static void createMinionRecurringAction(long minionId, String cron, boolean testMode,\n+                                                   boolean active, User user) throws TaskomaticApiException {\n+        if (!SystemManager.isAvailableToUser(user, minionId)) {\n+            throw new PermissionException(\"Minion not accessible to user\");\n+        }\n+        MinionServer minion = MinionServerFactory.lookupById(minionId)\n+                .orElseThrow(() -> new EntityNotExistsException(MinionServer.class, minionId));\n+        MinionRecurringAction action = new MinionRecurringAction(testMode, active, minion);\n+        RecurringActionFactory.save(action);\n+\n+        taskomaticApi.scheduleSatBunch(user, action.computeTaskoScheduleName(), \"recurring-state-apply-bunch\", cron);\n+    }\n+\n+    /**\n+     * List minion recurring action with minion id\n+     *\n+     * @param minionId id of the minion\n+     * @param user the user\n+     * @return list of minion recurring actions\n+     */\n+    public static List<MinionRecurringAction> listMinionRecurringAction(long minionId, User user) {\n+        if (!SystemManager.isAvailableToUser(user, minionId)) {\n+            throw new PermissionException(\"Minion not accessible to user\");\n+        }\n+        return RecurringActionFactory.listMinionRecurringActions(minionId);\n+    }\n+\n+    /**\n+     * List group recurring action with group id\n+     *\n+     * @param groupId id of the group\n+     * @param user the user\n+     * @return list of group recurring actions\n+     */\n+    public static List<GroupRecurringAction> listGroupRecurringAction(long groupId, User user) {\n+        ServerGroupManager groupManager = ServerGroupManager.getInstance();\n+        if (!user.hasRole(RoleFactory.SYSTEM_GROUP_ADMIN)) {\n+            throw new PermissionException(\"User does not have access to group\");\n+        }\n+        try {\n+            groupManager.lookup(groupId, user);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fb55f8d79b8b2bb580836a6968d9dd99a940933"}, "originalPosition": 116}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NjQ5NzM5OnYy", "diffSide": "RIGHT", "path": "java/code/src/com/redhat/rhn/manager/recurringactions/RecurringActionManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMDoxMDo0OVrOFuAGHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMDoxMDo0OVrOFuAGHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc4MDM4MA==", "bodyText": "Suggestion: instead of isAvailableUser, we could use ensureAvailableToUser. With this we'll get a more detailed exception info:\n        try {\n            SystemManager.ensureAvailableToUser(user, minionId);\n        }\n        catch (LookupException e) {\n            throw new PermissionException(\"Minion not accessible to user\", e);\n        }", "url": "https://github.com/uyuni-project/uyuni/pull/1951#discussion_r383780380", "createdAt": "2020-02-25T10:10:49Z", "author": {"login": "hustodemon"}, "path": "java/code/src/com/redhat/rhn/manager/recurringactions/RecurringActionManager.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.redhat.rhn.manager.recurringactions;\n+\n+import com.redhat.rhn.common.hibernate.LookupException;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.domain.recurringactions.GroupRecurringAction;\n+import com.redhat.rhn.domain.recurringactions.MinionRecurringAction;\n+import com.redhat.rhn.domain.recurringactions.OrgRecurringAction;\n+import com.redhat.rhn.domain.recurringactions.RecurringActionFactory;\n+import com.redhat.rhn.domain.role.RoleFactory;\n+import com.redhat.rhn.domain.server.MinionServer;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.EntityNotExistsException;\n+import com.redhat.rhn.manager.system.ServerGroupManager;\n+import com.redhat.rhn.manager.system.SystemManager;\n+import com.redhat.rhn.taskomatic.TaskomaticApi;\n+import com.redhat.rhn.taskomatic.TaskomaticApiException;\n+\n+import java.util.List;\n+\n+/**\n+ * RecurringActionManager\n+ * @version $Rev$\n+ */\n+public class RecurringActionManager {\n+\n+    private static  TaskomaticApi taskomaticApi = new TaskomaticApi();\n+    private static final RecurringActionManager MANAGER = new RecurringActionManager();\n+\n+    /**\n+     * Set the {@link TaskomaticApi} instance to use. Only needed for unit tests.\n+     * @param taskomaticApiIn the {@link TaskomaticApi}\n+     */\n+    public static void setTaskomaticApi(TaskomaticApi taskomaticApiIn) {\n+        taskomaticApi = taskomaticApiIn;\n+    }\n+    /**\n+     * Singleton Instance to get manager object\n+     * @return an instance of the manager\n+     */\n+    public static RecurringActionManager getInstance() {\n+        return MANAGER;\n+    }\n+\n+    /**\n+     * Private constructor.\n+     */\n+    private RecurringActionManager() {\n+    }\n+\n+    /**\n+     * Create a new minion recurring action\n+     *\n+     * @param minionId id of the minion\n+     * @param cron the cron expression\n+     * @param testMode if test mode\n+     * @param active is is active\n+     * @param user the user\n+     * @throws TaskomaticApiException if TaskoSchedule creation fails\n+     */\n+    public static void createMinionRecurringAction(long minionId, String cron, boolean testMode,\n+                                                   boolean active, User user) throws TaskomaticApiException {\n+        if (!SystemManager.isAvailableToUser(user, minionId)) {\n+            throw new PermissionException(\"Minion not accessible to user\");\n+        }\n+        MinionServer minion = MinionServerFactory.lookupById(minionId)\n+                .orElseThrow(() -> new EntityNotExistsException(MinionServer.class, minionId));\n+        MinionRecurringAction action = new MinionRecurringAction(testMode, active, minion);\n+        RecurringActionFactory.save(action);\n+\n+        taskomaticApi.scheduleSatBunch(user, action.computeTaskoScheduleName(), \"recurring-state-apply-bunch\", cron);\n+    }\n+\n+    /**\n+     * List minion recurring action with minion id\n+     *\n+     * @param minionId id of the minion\n+     * @param user the user\n+     * @return list of minion recurring actions\n+     */\n+    public static List<MinionRecurringAction> listMinionRecurringAction(long minionId, User user) {\n+        if (!SystemManager.isAvailableToUser(user, minionId)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fb55f8d79b8b2bb580836a6968d9dd99a940933"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NjUwNTkwOnYy", "diffSide": "RIGHT", "path": "java/code/src/com/redhat/rhn/manager/recurringactions/test/RecurringActionManagerTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMDoxMzoxOVrOFuALWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMDoxMzoxOVrOFuALWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc4MTcyMA==", "bodyText": "This doesn't seem to be needed, as it's done in setUp already.", "url": "https://github.com/uyuni-project/uyuni/pull/1951#discussion_r383781720", "createdAt": "2020-02-25T10:13:19Z", "author": {"login": "hustodemon"}, "path": "java/code/src/com/redhat/rhn/manager/recurringactions/test/RecurringActionManagerTest.java", "diffHunk": "@@ -0,0 +1,120 @@\n+package com.redhat.rhn.manager.recurringactions.test;\n+\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.domain.org.Org;\n+import com.redhat.rhn.domain.recurringactions.GroupRecurringAction;\n+import com.redhat.rhn.domain.recurringactions.MinionRecurringAction;\n+import com.redhat.rhn.domain.recurringactions.OrgRecurringAction;\n+import com.redhat.rhn.domain.recurringactions.RecurringActionFactory;\n+import com.redhat.rhn.domain.role.RoleFactory;\n+import com.redhat.rhn.domain.server.ManagedServerGroup;\n+import com.redhat.rhn.domain.server.test.MinionServerFactoryTest;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.recurringactions.RecurringActionManager;\n+import com.redhat.rhn.manager.system.ServerGroupManager;\n+import com.redhat.rhn.taskomatic.TaskomaticApi;\n+import com.redhat.rhn.testing.BaseTestCaseWithUser;\n+import com.redhat.rhn.testing.ServerGroupTestUtils;\n+import com.redhat.rhn.testing.UserTestUtils;\n+\n+import org.jmock.Expectations;\n+import org.jmock.Mockery;\n+import org.jmock.integration.junit3.JUnit3Mockery;\n+import org.jmock.lib.concurrent.Synchroniser;\n+import org.jmock.lib.legacy.ClassImposteriser;\n+\n+import java.util.List;\n+\n+public class RecurringActionManagerTest extends BaseTestCaseWithUser {\n+\n+    private static final Mockery CONTEXT = new JUnit3Mockery() {{\n+        setThreadingPolicy(new Synchroniser());\n+    }};\n+\n+    private Org anotherOrg;\n+    private User anotherUser;\n+\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        user.addPermanentRole(RoleFactory.ORG_ADMIN);\n+        anotherOrg = UserTestUtils.createNewOrgFull(\"anotherOrg\");\n+        anotherUser = UserTestUtils.createUser(\"anotherUser\", anotherOrg.getId());\n+    }\n+\n+    public void testCreateMinionRecurringAction() throws Exception {\n+        CONTEXT.setImposteriser(ClassImposteriser.INSTANCE);\n+        TaskomaticApi taskomaticMock = CONTEXT.mock(TaskomaticApi.class);\n+        RecurringActionManager.setTaskomaticApi(taskomaticMock);\n+\n+        var minion = MinionServerFactoryTest.createTestMinionServer(user);\n+\n+        CONTEXT.checking(new Expectations() { {\n+            allowing(taskomaticMock).scheduleSatBunch(with(any(User.class)), with(any(String.class)), with(any(String.class)), with(any(String.class)));\n+        } });\n+\n+        try {\n+            RecurringActionManager.createMinionRecurringAction(minion.getId(), \"\", false, false, anotherUser);\n+            fail(\"User shouldn't have access\");\n+        }\n+        catch (PermissionException e) {\n+            // no-op\n+        }\n+\n+        RecurringActionManager.createMinionRecurringAction(minion.getId(), \"\", false, false, user);\n+        assertNotEmpty(RecurringActionFactory.listMinionRecurringActions(minion.getId()));\n+    }\n+\n+    public void testListMinionRecurringAction() throws Exception {\n+        var minion = MinionServerFactoryTest.createTestMinionServer(user);\n+        var action = new MinionRecurringAction();\n+        action.setMinion(minion);\n+        RecurringActionFactory.save(action);\n+\n+        assertEquals(List.of(action), RecurringActionManager.listMinionRecurringAction(minion.getId(), user));\n+\n+        try{\n+            RecurringActionManager.listMinionRecurringAction(minion.getId(), anotherUser);\n+            fail(\"User shouldn't have access\");\n+        }\n+        catch (PermissionException e) {\n+            // no-op\n+        }\n+    }\n+\n+    public void testListGroupRecurringAction() throws Exception {\n+        ServerGroupManager manager = ServerGroupManager.getInstance();\n+        ManagedServerGroup group = ServerGroupTestUtils.createManaged(user);\n+\n+        var action = new GroupRecurringAction();\n+        action.setGroup(group);\n+        RecurringActionFactory.save(action);\n+\n+        assertTrue(manager.canAccess(user, group));\n+        assertEquals(List.of(action), RecurringActionManager.listGroupRecurringAction(group.getId(), user));\n+\n+        try{\n+            RecurringActionManager.listGroupRecurringAction(group.getId(), anotherUser);\n+            fail(\"User shouldn't have access\");\n+        }\n+        catch (PermissionException e) {\n+            // no-op\n+        }\n+    }\n+\n+    public void testListOrgRecurringAction() throws Exception {\n+        var action = new OrgRecurringAction();\n+        action.setOrg(user.getOrg());\n+        RecurringActionFactory.save(action);\n+\n+        UserTestUtils.addUserRole(user, RoleFactory.ORG_ADMIN);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fb55f8d79b8b2bb580836a6968d9dd99a940933"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NzA2Njk5OnYy", "diffSide": "RIGHT", "path": "java/code/src/com/redhat/rhn/domain/recurringactions/test/RecurringActionFactoryTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMzowOTozN1rOFuFaKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMzowOTozN1rOFuFaKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg2NzQzMg==", "bodyText": "There is two testListMinionRecurringActions tests. We should alter the existing one", "url": "https://github.com/uyuni-project/uyuni/pull/1951#discussion_r383867432", "createdAt": "2020-02-25T13:09:37Z", "author": {"login": "parlt91"}, "path": "java/code/src/com/redhat/rhn/domain/recurringactions/test/RecurringActionFactoryTest.java", "diffHunk": "@@ -23,7 +23,43 @@ public void testListMinionRecurringActions() throws Exception {\n         assertEquals(List.of(action), RecurringActionFactory.listMinionRecurringActions(minion.getId()));\n     }\n \n-    public void testListGroupRecurringActions() {\n+    public void testListMinionRecurringActions() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0ce6a9cec53c6e1fbbe797ee859444cbd3d1ab6"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMTQ2MjE3OnYy", "diffSide": "RIGHT", "path": "java/code/src/com/suse/manager/webui/controllers/RecurringActionController.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxMjoxNjoyNVrOFxq-dg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxMjoxNjoyNVrOFxq-dg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzYyODY2Mg==", "bodyText": "please update the Year", "url": "https://github.com/uyuni-project/uyuni/pull/1951#discussion_r387628662", "createdAt": "2020-03-04T12:16:25Z", "author": {"login": "mcalmer"}, "path": "java/code/src/com/suse/manager/webui/controllers/RecurringActionController.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/**\n+ * Copyright (c) 2015 SUSE LLC", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6003577e55e14d6dd15d65702e2178c938edf22e"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMTQ3ODgxOnYy", "diffSide": "RIGHT", "path": "schema/spacewalk/common/tables/suseRecurringAction.sql", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxMjoyMjowNlrOFxrIpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxMjoyMjowNlrOFxrIpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzYzMTI3MQ==", "bodyText": "AFAIK minion_id, group_id or org_id can be NULL. Postgresql unique indexes do not work well with NULL columns.\nThis requires special handling.\nExample: schema/spacewalk/postgres/tables/rhnContentSourceSsl_index.sql", "url": "https://github.com/uyuni-project/uyuni/pull/1951#discussion_r387631271", "createdAt": "2020-03-04T12:22:06Z", "author": {"login": "mcalmer"}, "path": "schema/spacewalk/common/tables/suseRecurringAction.sql", "diffHunk": "@@ -0,0 +1,47 @@\n+CREATE TABLE suseRecurringAction\n+(\n+  id                NUMERIC NOT NULL\n+                    CONSTRAINT suse_recurring_action_id_pk PRIMARY KEY,\n+  target_type       VARCHAR(32) NOT NULL,\n+  name              VARCHAR(256) NOT NULL,\n+  cron_expr         VARCHAR(32) NOT NULL,\n+  minion_id         NUMERIC\n+                    CONSTRAINT suse_rec_action_minion_fk\n+                      REFERENCES suseMinionInfo(server_id)\n+                      ON DELETE CASCADE,\n+  group_id          NUMERIC\n+                    CONSTRAINT suse_rec_action_group_fk\n+                      REFERENCES rhnServerGroup(id)\n+                      ON DELETE CASCADE,\n+  org_id            NUMERIC\n+                    CONSTRAINT suse_rec_action_org_fk\n+                      REFERENCES web_customer(id)\n+                      ON DELETE CASCADE,\n+  creator_id        NUMERIC\n+                    CONSTRAINT suse_rec_action_creator_fk\n+                      REFERENCES web_contact(id)\n+                      ON DELETE CASCADE,\n+  active            CHAR(1) DEFAULT ('Y') NOT NULL,\n+  test_mode         CHAR(1) DEFAULT ('Y') NOT NULL,\n+  created           TIMESTAMP WITH TIME ZONE\n+                      DEFAULT (current_timestamp)\n+                      NOT NULL,\n+  modified          TIMESTAMP WITH TIME ZONE\n+                      DEFAULT (current_timestamp)\n+                      NOT NULL\n+);\n+\n+CREATE SEQUENCE suse_recurring_action_id_seq;\n+\n+CREATE INDEX suse_rec_action_type\n+    ON suseRecurringAction(target_type);\n+\n+CREATE UNIQUE INDEX suse_rec_action_name_minion_uq\n+    ON suseRecurringAction(name, minion_id);\n+\n+CREATE UNIQUE INDEX suse_rec_action_name_grp_uq\n+    ON suseRecurringAction(name, group_id);\n+\n+CREATE UNIQUE INDEX suse_rec_action_name_org_uq\n+    ON suseRecurringAction(name, org_id);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6003577e55e14d6dd15d65702e2178c938edf22e"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMjAzNDAzOnYy", "diffSide": "RIGHT", "path": "schema/spacewalk/postgres/tables/suseRecurringAction_index.sql", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxNDo1NTo1NVrOFxwfLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxNDo1NTo1NVrOFxwfLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzcxODk1OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                WHERE group_id IS NULL AND org_id IS NULL;\n          \n          \n            \n                WHERE group_id IS NULL AND org_id IS NULL AND minion_id IS NOT NULL;", "url": "https://github.com/uyuni-project/uyuni/pull/1951#discussion_r387718959", "createdAt": "2020-03-04T14:55:55Z", "author": {"login": "mcalmer"}, "path": "schema/spacewalk/postgres/tables/suseRecurringAction_index.sql", "diffHunk": "@@ -0,0 +1,28 @@\n+-- oracle equivalent source none\n+--\n+-- Copyright (c) 2020 SUSE LLC\n+--\n+-- This software is licensed to you under the GNU General Public License,\n+-- version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+-- implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+-- FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+-- along with this software; if not, see\n+-- http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+--\n+-- Red Hat trademarks are not licensed under GPLv2. No permission is\n+-- granted to use or replicate Red Hat trademarks that are incorporated\n+-- in this software or its documentation.\n+--\n+\n+CREATE UNIQUE INDEX suse_rec_action_name_minion_uq\n+    ON suseRecurringAction(name, minion_id)\n+    WHERE group_id IS NULL AND org_id IS NULL;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e72e001f134b48561b698d36f17c9754c67f9db0"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMjAzOTg4OnYy", "diffSide": "RIGHT", "path": "schema/spacewalk/postgres/tables/suseRecurringAction_index.sql", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxNDo1NzoxOVrOFxwitg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxNDo1NzoxOVrOFxwitg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzcxOTg2Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                WHERE minion_id IS NULL AND org_id IS NULL;\n          \n          \n            \n                WHERE minion_id IS NULL AND org_id IS NULL AND group_id IS NOT NULL;", "url": "https://github.com/uyuni-project/uyuni/pull/1951#discussion_r387719862", "createdAt": "2020-03-04T14:57:19Z", "author": {"login": "mcalmer"}, "path": "schema/spacewalk/postgres/tables/suseRecurringAction_index.sql", "diffHunk": "@@ -0,0 +1,28 @@\n+-- oracle equivalent source none\n+--\n+-- Copyright (c) 2020 SUSE LLC\n+--\n+-- This software is licensed to you under the GNU General Public License,\n+-- version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+-- implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+-- FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+-- along with this software; if not, see\n+-- http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+--\n+-- Red Hat trademarks are not licensed under GPLv2. No permission is\n+-- granted to use or replicate Red Hat trademarks that are incorporated\n+-- in this software or its documentation.\n+--\n+\n+CREATE UNIQUE INDEX suse_rec_action_name_minion_uq\n+    ON suseRecurringAction(name, minion_id)\n+    WHERE group_id IS NULL AND org_id IS NULL;\n+\n+CREATE UNIQUE INDEX suse_rec_action_name_grp_uq\n+    ON suseRecurringAction(name, group_id)\n+    WHERE minion_id IS NULL AND org_id IS NULL;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e72e001f134b48561b698d36f17c9754c67f9db0"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMjA0MTA5OnYy", "diffSide": "RIGHT", "path": "schema/spacewalk/postgres/tables/suseRecurringAction_index.sql", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxNDo1NzozNFrOFxwjeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxNDo1NzozNFrOFxwjeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzcyMDA1Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                WHERE minion_id IS NULL AND group_id IS NULL;\n          \n          \n            \n                WHERE minion_id IS NULL AND group_id IS NULL AND org_id IS NOT NULL;", "url": "https://github.com/uyuni-project/uyuni/pull/1951#discussion_r387720056", "createdAt": "2020-03-04T14:57:34Z", "author": {"login": "mcalmer"}, "path": "schema/spacewalk/postgres/tables/suseRecurringAction_index.sql", "diffHunk": "@@ -0,0 +1,28 @@\n+-- oracle equivalent source none\n+--\n+-- Copyright (c) 2020 SUSE LLC\n+--\n+-- This software is licensed to you under the GNU General Public License,\n+-- version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+-- implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+-- FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+-- along with this software; if not, see\n+-- http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+--\n+-- Red Hat trademarks are not licensed under GPLv2. No permission is\n+-- granted to use or replicate Red Hat trademarks that are incorporated\n+-- in this software or its documentation.\n+--\n+\n+CREATE UNIQUE INDEX suse_rec_action_name_minion_uq\n+    ON suseRecurringAction(name, minion_id)\n+    WHERE group_id IS NULL AND org_id IS NULL;\n+\n+CREATE UNIQUE INDEX suse_rec_action_name_grp_uq\n+    ON suseRecurringAction(name, group_id)\n+    WHERE minion_id IS NULL AND org_id IS NULL;\n+\n+CREATE UNIQUE INDEX suse_rec_action_name_org_uq\n+    ON suseRecurringAction(name, org_id)\n+    WHERE minion_id IS NULL AND group_id IS NULL;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e72e001f134b48561b698d36f17c9754c67f9db0"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMjA0NTQyOnYy", "diffSide": "RIGHT", "path": "schema/spacewalk/upgrade/susemanager-schema-4.1.3-to-susemanager-schema-4.1.4/010-schedule-recurring-actions.sql", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxNDo1ODoyN1rOFxwl8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxNjoyNToxMFrOFx0RWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzcyMDY5MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            CREATE UNIQUE INDEX IF NOT EXISTS suse_rec_action_name_minion_uq\n          \n          \n            \n                ON suseRecurringAction(name, minion_id)\n          \n          \n            \n                WHERE group_id IS NULL AND org_id IS NULL;\n          \n          \n            \n            \n          \n          \n            \n            CREATE UNIQUE INDEX IF NOT EXISTS suse_rec_action_name_grp_uq\n          \n          \n            \n                ON suseRecurringAction(name, group_id)\n          \n          \n            \n                WHERE minion_id IS NULL AND org_id IS NULL;\n          \n          \n            \n            \n          \n          \n            \n            CREATE UNIQUE INDEX IF NOT EXISTS suse_rec_action_name_org_uq\n          \n          \n            \n                ON suseRecurringAction(name, org_id)\n          \n          \n            \n                WHERE minion_id IS NULL AND group_id IS NULL;\n          \n          \n            \n            CREATE UNIQUE INDEX IF NOT EXISTS suse_rec_action_name_minion_uq\n          \n          \n            \n                ON suseRecurringAction(name, minion_id)\n          \n          \n            \n                WHERE group_id IS NULL AND org_id IS NULL AND minion_id IS NOT NULL;\n          \n          \n            \n            \n          \n          \n            \n            CREATE UNIQUE INDEX IF NOT EXISTS suse_rec_action_name_grp_uq\n          \n          \n            \n                ON suseRecurringAction(name, group_id)\n          \n          \n            \n                WHERE minion_id IS NULL AND org_id IS NULL AND group_id IS NOT NULL;\n          \n          \n            \n            \n          \n          \n            \n            CREATE UNIQUE INDEX IF NOT EXISTS suse_rec_action_name_org_uq\n          \n          \n            \n                ON suseRecurringAction(name, org_id)\n          \n          \n            \n                WHERE minion_id IS NULL AND group_id IS NULL AND org_id IS NOT NULL;", "url": "https://github.com/uyuni-project/uyuni/pull/1951#discussion_r387720691", "createdAt": "2020-03-04T14:58:27Z", "author": {"login": "mcalmer"}, "path": "schema/spacewalk/upgrade/susemanager-schema-4.1.3-to-susemanager-schema-4.1.4/010-schedule-recurring-actions.sql", "diffHunk": "@@ -9,3 +9,54 @@ WHERE NOT EXISTS ( SELECT 1 FROM rhnTaskoTask WHERE name = 'recurring-state-appl\n INSERT INTO rhnTaskoTemplate (id, bunch_id, task_id, ordering, start_if)\n SELECT sequence_nextval('rhn_tasko_template_id_seq'), ( SELECT id FROM rhnTaskoBunch WHERE name = 'recurring-state-apply-bunch' ), ( SELECT id FROM rhnTaskoTask WHERE name = 'recurring-state-apply' ), 0, null\n WHERE NOT EXISTS ( SELECT 1 FROM rhnTaskoTemplate WHERE bunch_id = ( SELECT id FROM rhnTaskoBunch WHERE name = 'recurring-state-apply-bunch' ) );\n+\n+CREATE TABLE IF NOT EXISTS suseRecurringAction\n+(\n+  id                NUMERIC NOT NULL\n+                    CONSTRAINT suse_recurring_action_id_pk PRIMARY KEY,\n+  target_type       VARCHAR(32) NOT NULL,\n+  name              VARCHAR(256) NOT NULL,\n+  cron_expr         VARCHAR(32) NOT NULL,\n+  minion_id         NUMERIC\n+                    CONSTRAINT suse_rec_action_minion_fk\n+                      REFERENCES suseMinionInfo(server_id)\n+                      ON DELETE CASCADE,\n+  group_id          NUMERIC\n+                    CONSTRAINT suse_rec_action_group_fk\n+                      REFERENCES rhnServerGroup(id)\n+                      ON DELETE CASCADE,\n+  org_id            NUMERIC\n+                    CONSTRAINT suse_rec_action_org_fk\n+                      REFERENCES web_customer(id)\n+                      ON DELETE CASCADE,\n+  creator_id        NUMERIC\n+                    CONSTRAINT suse_rec_action_creator_fk\n+                      REFERENCES web_contact(id)\n+                      ON DELETE CASCADE,\n+  active            CHAR(1) DEFAULT ('Y') NOT NULL,\n+  test_mode         CHAR(1) DEFAULT ('Y') NOT NULL,\n+  created           TIMESTAMP WITH TIME ZONE\n+                      DEFAULT (current_timestamp)\n+                      NOT NULL,\n+  modified          TIMESTAMP WITH TIME ZONE\n+                      DEFAULT (current_timestamp)\n+                      NOT NULL\n+);\n+\n+CREATE SEQUENCE IF NOT EXISTS suse_recurring_action_id_seq;\n+\n+CREATE INDEX IF NOT EXISTS suse_rec_action_type\n+    ON suseRecurringAction(target_type);\n+\n+CREATE UNIQUE INDEX IF NOT EXISTS suse_rec_action_name_minion_uq\n+    ON suseRecurringAction(name, minion_id)\n+    WHERE group_id IS NULL AND org_id IS NULL;\n+\n+CREATE UNIQUE INDEX IF NOT EXISTS suse_rec_action_name_grp_uq\n+    ON suseRecurringAction(name, group_id)\n+    WHERE minion_id IS NULL AND org_id IS NULL;\n+\n+CREATE UNIQUE INDEX IF NOT EXISTS suse_rec_action_name_org_uq\n+    ON suseRecurringAction(name, org_id)\n+    WHERE minion_id IS NULL AND group_id IS NULL;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e72e001f134b48561b698d36f17c9754c67f9db0"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzc4MDk1NQ==", "bodyText": "Thanks for the update!", "url": "https://github.com/uyuni-project/uyuni/pull/1951#discussion_r387780955", "createdAt": "2020-03-04T16:25:10Z", "author": {"login": "parlt91"}, "path": "schema/spacewalk/upgrade/susemanager-schema-4.1.3-to-susemanager-schema-4.1.4/010-schedule-recurring-actions.sql", "diffHunk": "@@ -9,3 +9,54 @@ WHERE NOT EXISTS ( SELECT 1 FROM rhnTaskoTask WHERE name = 'recurring-state-appl\n INSERT INTO rhnTaskoTemplate (id, bunch_id, task_id, ordering, start_if)\n SELECT sequence_nextval('rhn_tasko_template_id_seq'), ( SELECT id FROM rhnTaskoBunch WHERE name = 'recurring-state-apply-bunch' ), ( SELECT id FROM rhnTaskoTask WHERE name = 'recurring-state-apply' ), 0, null\n WHERE NOT EXISTS ( SELECT 1 FROM rhnTaskoTemplate WHERE bunch_id = ( SELECT id FROM rhnTaskoBunch WHERE name = 'recurring-state-apply-bunch' ) );\n+\n+CREATE TABLE IF NOT EXISTS suseRecurringAction\n+(\n+  id                NUMERIC NOT NULL\n+                    CONSTRAINT suse_recurring_action_id_pk PRIMARY KEY,\n+  target_type       VARCHAR(32) NOT NULL,\n+  name              VARCHAR(256) NOT NULL,\n+  cron_expr         VARCHAR(32) NOT NULL,\n+  minion_id         NUMERIC\n+                    CONSTRAINT suse_rec_action_minion_fk\n+                      REFERENCES suseMinionInfo(server_id)\n+                      ON DELETE CASCADE,\n+  group_id          NUMERIC\n+                    CONSTRAINT suse_rec_action_group_fk\n+                      REFERENCES rhnServerGroup(id)\n+                      ON DELETE CASCADE,\n+  org_id            NUMERIC\n+                    CONSTRAINT suse_rec_action_org_fk\n+                      REFERENCES web_customer(id)\n+                      ON DELETE CASCADE,\n+  creator_id        NUMERIC\n+                    CONSTRAINT suse_rec_action_creator_fk\n+                      REFERENCES web_contact(id)\n+                      ON DELETE CASCADE,\n+  active            CHAR(1) DEFAULT ('Y') NOT NULL,\n+  test_mode         CHAR(1) DEFAULT ('Y') NOT NULL,\n+  created           TIMESTAMP WITH TIME ZONE\n+                      DEFAULT (current_timestamp)\n+                      NOT NULL,\n+  modified          TIMESTAMP WITH TIME ZONE\n+                      DEFAULT (current_timestamp)\n+                      NOT NULL\n+);\n+\n+CREATE SEQUENCE IF NOT EXISTS suse_recurring_action_id_seq;\n+\n+CREATE INDEX IF NOT EXISTS suse_rec_action_type\n+    ON suseRecurringAction(target_type);\n+\n+CREATE UNIQUE INDEX IF NOT EXISTS suse_rec_action_name_minion_uq\n+    ON suseRecurringAction(name, minion_id)\n+    WHERE group_id IS NULL AND org_id IS NULL;\n+\n+CREATE UNIQUE INDEX IF NOT EXISTS suse_rec_action_name_grp_uq\n+    ON suseRecurringAction(name, group_id)\n+    WHERE minion_id IS NULL AND org_id IS NULL;\n+\n+CREATE UNIQUE INDEX IF NOT EXISTS suse_rec_action_name_org_uq\n+    ON suseRecurringAction(name, org_id)\n+    WHERE minion_id IS NULL AND group_id IS NULL;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzcyMDY5MQ=="}, "originalCommit": {"oid": "e72e001f134b48561b698d36f17c9754c67f9db0"}, "originalPosition": 53}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 187, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}