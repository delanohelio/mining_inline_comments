{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYwMDUxODU1", "number": 1769, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxNzowOTozOVrODXl5zw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxNzoyNTozN1rODXmMVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2MDY0ODQ3OnYy", "diffSide": "RIGHT", "path": "susemanager-utils/mgr-libmod/mgrlibmod/mllib.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxNzowOTozOVrOFc-EAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxOTowMTo1MFrOFdBN4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkyMTI4MQ==", "bodyText": "This should be el8, not e18 (stands for Enterprise Linux 8).\nThe module named \"platform\" is a pseudo-module to specify the actual OS in the modules world. So if a module depends on platform:el8, it just means it's built for RHEL 8.\nI'm not completely happy hardcoding this here, the values will surely change in the future.", "url": "https://github.com/uyuni-project/uyuni/pull/1769#discussion_r365921281", "createdAt": "2020-01-13T17:09:39Z", "author": {"login": "cbbayburt"}, "path": "susemanager-utils/mgr-libmod/mgrlibmod/mllib.py", "diffHunk": "@@ -0,0 +1,330 @@\n+\"\"\"\n+libmod operations\n+\"\"\"\n+import os\n+import gzip\n+import json\n+import argparse\n+import binascii\n+\n+from typing import Any, Dict, List, Set\n+from mgrlibmod import mltypes\n+\n+import gi  # type: ignore\n+\n+gi.require_version(\"Modulemd\", \"2.0\")\n+from gi.repository import Modulemd  # type: ignore\n+\n+\n+class MLLibmodProc:\n+    \"\"\"\n+    Libmod process.\n+    \"\"\"\n+\n+    RESERVED_STREAMS = [\"platform\"]\n+\n+    def __init__(self, metadata: List[str]):\n+        \"\"\"\n+        __init__\n+\n+        :param metadata: paths of the metadata.\n+        :type metadata: List[str]\n+        \"\"\"\n+        self.metadata = metadata\n+        self._mod_index: Modulemd.ModuleIndex = None\n+        assert gi is not None and Modulemd is not None, \"No libmodulemd found\"\n+        self._enabled_stream_modules: Dict = {}\n+\n+    def _is_stream_enabled(self, s_type: mltypes.MLStreamType) -> bool:\n+        \"\"\"\n+        _is_stream_enabled -- returns True if stream is enabled. NOTE: \"platform\" is always enabled.\n+\n+        :param s_type: stream type object\n+        :type s_type: MLStreamType\n+        :return: True, if stream is enabled.\n+        :rtype: bool\n+        \"\"\"\n+        return s_type.name in self._enabled_stream_modules\n+\n+    def _is_meta_compressed(self, path: str) -> bool:\n+        \"\"\"\n+        _is_meta_compressed -- detect if metafile is plain text YAML or compressed.\n+\n+        :param path: path to the meta file.\n+        :type path: str\n+        :return: True, if meta is GNU Zip compressed.\n+        :rtype: bool\n+        \"\"\"\n+        with open(path, \"rb\") as metafile:\n+            return binascii.hexlify(metafile.read(2)) == b\"1f8b\"  # Almost reliable :-)\n+\n+    def enable_stream(self, s_obj) -> None:\n+        self._enabled_stream_modules[s_obj.get_module_name()] = s_obj\n+\n+    def disable(self, name: str) -> None:\n+        if name not in MLLibmodProc.RESERVED_STREAMS:\n+            self._enabled_stream_modules.pop(name, None)\n+\n+    def get_module_streams(self, name: str) -> List:\n+        if self._mod_index is None:\n+            self.index_modules()\n+        assert self._mod_index is not None, \"Unable to get module streams: module index not found\"\n+\n+        streams: Set = set()\n+        module = self._mod_index.get_module(name)\n+        if module:\n+            for s_obj in module.get_all_streams():\n+                streams.add(s_obj.get_stream_name())\n+\n+        return list(streams)\n+\n+    def get_stream_contexts(self, s_type: mltypes.MLStreamType) -> List:\n+        if self._mod_index is None:\n+            self.index_modules()\n+        assert self._mod_index is not None, \"Unable to get stream contexts: module index not found\"\n+        contexts: List = []\n+        module = self._mod_index.get_module(s_type.name)\n+        if module:\n+            for stream in module.get_all_streams():\n+                if stream.get_stream_name() == s_type.stream:\n+                    contexts.append(stream)\n+\n+        return contexts\n+\n+    def get_stream_dependencies(self, ctx: Modulemd.ModuleStreamV2) -> List[str]:\n+        \"\"\"\n+        get_stream_dependencies -- get stream dependencies.\n+\n+        :param ctx: module stream context\n+        :type ctx: Modulemd.ModuleStreamV2\n+        :return: list of dependency names.\n+        :rtype: List[str]\n+        \"\"\"\n+        deps: List[str] = []\n+        s_deps: List[Modulemd.Dependencies] = ctx.get_dependencies() or []\n+        dep: Modulemd.Dependencies\n+        for dep in s_deps:\n+            deps.extend(dep.get_runtime_modules())\n+\n+        return deps\n+\n+    def index_modules(self) -> None:\n+        \"\"\"\n+        index_modules -- loads given metadata and indexes modules from there.\n+        \"\"\"\n+        if self._mod_index is None:\n+            mgr: Modulemd.ModuleIndex = Modulemd.ModuleIndexMerger.new()\n+            for path in self.metadata:\n+                idx = Modulemd.ModuleIndex.new()\n+                if self._is_meta_compressed(path):\n+                    with gzip.open(path) as gzmeta:\n+                        idx.update_from_string(gzmeta.read().decode(\"utf-8\"), True)\n+                else:\n+                    idx.update_from_file(path, True)\n+                mgr.associate_index(idx, 0)\n+            self._mod_index = mgr.resolve()\n+\n+    def get_default_stream(self, name: str):\n+        assert self._mod_index is not None, \"Unable to access module index when resolving default stream\"\n+        module = self._mod_index.get_module(name)\n+        if not module:\n+            raise ValueError(\"Module {} not found\".format(name))\n+        defaults = module.get_detaults()\n+        if defaults:\n+            return defaults.get_default_stream()\n+\n+        return module.get_all_streams()[0].get_stream_name()\n+\n+    def get_dep_streams(self, s_obj):\n+        dep = s_obj.get_dependencies()[0]  # XXX: Why just always first?\n+        all_deps = []  # type: ignore\n+        for m in dep.get_runtime_modules():\n+            deps = dep.get_runtime_streams(m)\n+            if deps:\n+                all_deps.append((m, deps[0],))  # XXX: why just first?\n+        return all_deps\n+\n+    def get_actual_stream(self, name: str):\n+        if name == \"platform\":\n+            return \"e18\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ebdd689746282209a2f297b258eef746e0c5d7f3"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk3Mjk2Mw==", "bodyText": "Of course. But it is WP. I will surely update this better, once it works at all properly.", "url": "https://github.com/uyuni-project/uyuni/pull/1769#discussion_r365972963", "createdAt": "2020-01-13T19:01:50Z", "author": {"login": "isbm"}, "path": "susemanager-utils/mgr-libmod/mgrlibmod/mllib.py", "diffHunk": "@@ -0,0 +1,330 @@\n+\"\"\"\n+libmod operations\n+\"\"\"\n+import os\n+import gzip\n+import json\n+import argparse\n+import binascii\n+\n+from typing import Any, Dict, List, Set\n+from mgrlibmod import mltypes\n+\n+import gi  # type: ignore\n+\n+gi.require_version(\"Modulemd\", \"2.0\")\n+from gi.repository import Modulemd  # type: ignore\n+\n+\n+class MLLibmodProc:\n+    \"\"\"\n+    Libmod process.\n+    \"\"\"\n+\n+    RESERVED_STREAMS = [\"platform\"]\n+\n+    def __init__(self, metadata: List[str]):\n+        \"\"\"\n+        __init__\n+\n+        :param metadata: paths of the metadata.\n+        :type metadata: List[str]\n+        \"\"\"\n+        self.metadata = metadata\n+        self._mod_index: Modulemd.ModuleIndex = None\n+        assert gi is not None and Modulemd is not None, \"No libmodulemd found\"\n+        self._enabled_stream_modules: Dict = {}\n+\n+    def _is_stream_enabled(self, s_type: mltypes.MLStreamType) -> bool:\n+        \"\"\"\n+        _is_stream_enabled -- returns True if stream is enabled. NOTE: \"platform\" is always enabled.\n+\n+        :param s_type: stream type object\n+        :type s_type: MLStreamType\n+        :return: True, if stream is enabled.\n+        :rtype: bool\n+        \"\"\"\n+        return s_type.name in self._enabled_stream_modules\n+\n+    def _is_meta_compressed(self, path: str) -> bool:\n+        \"\"\"\n+        _is_meta_compressed -- detect if metafile is plain text YAML or compressed.\n+\n+        :param path: path to the meta file.\n+        :type path: str\n+        :return: True, if meta is GNU Zip compressed.\n+        :rtype: bool\n+        \"\"\"\n+        with open(path, \"rb\") as metafile:\n+            return binascii.hexlify(metafile.read(2)) == b\"1f8b\"  # Almost reliable :-)\n+\n+    def enable_stream(self, s_obj) -> None:\n+        self._enabled_stream_modules[s_obj.get_module_name()] = s_obj\n+\n+    def disable(self, name: str) -> None:\n+        if name not in MLLibmodProc.RESERVED_STREAMS:\n+            self._enabled_stream_modules.pop(name, None)\n+\n+    def get_module_streams(self, name: str) -> List:\n+        if self._mod_index is None:\n+            self.index_modules()\n+        assert self._mod_index is not None, \"Unable to get module streams: module index not found\"\n+\n+        streams: Set = set()\n+        module = self._mod_index.get_module(name)\n+        if module:\n+            for s_obj in module.get_all_streams():\n+                streams.add(s_obj.get_stream_name())\n+\n+        return list(streams)\n+\n+    def get_stream_contexts(self, s_type: mltypes.MLStreamType) -> List:\n+        if self._mod_index is None:\n+            self.index_modules()\n+        assert self._mod_index is not None, \"Unable to get stream contexts: module index not found\"\n+        contexts: List = []\n+        module = self._mod_index.get_module(s_type.name)\n+        if module:\n+            for stream in module.get_all_streams():\n+                if stream.get_stream_name() == s_type.stream:\n+                    contexts.append(stream)\n+\n+        return contexts\n+\n+    def get_stream_dependencies(self, ctx: Modulemd.ModuleStreamV2) -> List[str]:\n+        \"\"\"\n+        get_stream_dependencies -- get stream dependencies.\n+\n+        :param ctx: module stream context\n+        :type ctx: Modulemd.ModuleStreamV2\n+        :return: list of dependency names.\n+        :rtype: List[str]\n+        \"\"\"\n+        deps: List[str] = []\n+        s_deps: List[Modulemd.Dependencies] = ctx.get_dependencies() or []\n+        dep: Modulemd.Dependencies\n+        for dep in s_deps:\n+            deps.extend(dep.get_runtime_modules())\n+\n+        return deps\n+\n+    def index_modules(self) -> None:\n+        \"\"\"\n+        index_modules -- loads given metadata and indexes modules from there.\n+        \"\"\"\n+        if self._mod_index is None:\n+            mgr: Modulemd.ModuleIndex = Modulemd.ModuleIndexMerger.new()\n+            for path in self.metadata:\n+                idx = Modulemd.ModuleIndex.new()\n+                if self._is_meta_compressed(path):\n+                    with gzip.open(path) as gzmeta:\n+                        idx.update_from_string(gzmeta.read().decode(\"utf-8\"), True)\n+                else:\n+                    idx.update_from_file(path, True)\n+                mgr.associate_index(idx, 0)\n+            self._mod_index = mgr.resolve()\n+\n+    def get_default_stream(self, name: str):\n+        assert self._mod_index is not None, \"Unable to access module index when resolving default stream\"\n+        module = self._mod_index.get_module(name)\n+        if not module:\n+            raise ValueError(\"Module {} not found\".format(name))\n+        defaults = module.get_detaults()\n+        if defaults:\n+            return defaults.get_default_stream()\n+\n+        return module.get_all_streams()[0].get_stream_name()\n+\n+    def get_dep_streams(self, s_obj):\n+        dep = s_obj.get_dependencies()[0]  # XXX: Why just always first?\n+        all_deps = []  # type: ignore\n+        for m in dep.get_runtime_modules():\n+            deps = dep.get_runtime_streams(m)\n+            if deps:\n+                all_deps.append((m, deps[0],))  # XXX: why just first?\n+        return all_deps\n+\n+    def get_actual_stream(self, name: str):\n+        if name == \"platform\":\n+            return \"e18\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkyMTI4MQ=="}, "originalCommit": {"oid": "ebdd689746282209a2f297b258eef746e0c5d7f3"}, "originalPosition": 149}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2MDY4OTM4OnYy", "diffSide": "RIGHT", "path": "susemanager-utils/mgr-libmod/mgrlibmod/mllib.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxNzoyMzoyMVrOFc-dVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxODo1ODowOVrOFdBHmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkyNzc2Ng==", "bodyText": "get_dependencies() returns a Modulemd.Dependencies object wrapped in a list, rather than returning a list of dependencies directly. And this list is always a 1 element array. But I guess it wouldn't hurt to foolproof this by looping to operate on the whole array (there's no info on this in the API docs)", "url": "https://github.com/uyuni-project/uyuni/pull/1769#discussion_r365927766", "createdAt": "2020-01-13T17:23:21Z", "author": {"login": "cbbayburt"}, "path": "susemanager-utils/mgr-libmod/mgrlibmod/mllib.py", "diffHunk": "@@ -0,0 +1,330 @@\n+\"\"\"\n+libmod operations\n+\"\"\"\n+import os\n+import gzip\n+import json\n+import argparse\n+import binascii\n+\n+from typing import Any, Dict, List, Set\n+from mgrlibmod import mltypes\n+\n+import gi  # type: ignore\n+\n+gi.require_version(\"Modulemd\", \"2.0\")\n+from gi.repository import Modulemd  # type: ignore\n+\n+\n+class MLLibmodProc:\n+    \"\"\"\n+    Libmod process.\n+    \"\"\"\n+\n+    RESERVED_STREAMS = [\"platform\"]\n+\n+    def __init__(self, metadata: List[str]):\n+        \"\"\"\n+        __init__\n+\n+        :param metadata: paths of the metadata.\n+        :type metadata: List[str]\n+        \"\"\"\n+        self.metadata = metadata\n+        self._mod_index: Modulemd.ModuleIndex = None\n+        assert gi is not None and Modulemd is not None, \"No libmodulemd found\"\n+        self._enabled_stream_modules: Dict = {}\n+\n+    def _is_stream_enabled(self, s_type: mltypes.MLStreamType) -> bool:\n+        \"\"\"\n+        _is_stream_enabled -- returns True if stream is enabled. NOTE: \"platform\" is always enabled.\n+\n+        :param s_type: stream type object\n+        :type s_type: MLStreamType\n+        :return: True, if stream is enabled.\n+        :rtype: bool\n+        \"\"\"\n+        return s_type.name in self._enabled_stream_modules\n+\n+    def _is_meta_compressed(self, path: str) -> bool:\n+        \"\"\"\n+        _is_meta_compressed -- detect if metafile is plain text YAML or compressed.\n+\n+        :param path: path to the meta file.\n+        :type path: str\n+        :return: True, if meta is GNU Zip compressed.\n+        :rtype: bool\n+        \"\"\"\n+        with open(path, \"rb\") as metafile:\n+            return binascii.hexlify(metafile.read(2)) == b\"1f8b\"  # Almost reliable :-)\n+\n+    def enable_stream(self, s_obj) -> None:\n+        self._enabled_stream_modules[s_obj.get_module_name()] = s_obj\n+\n+    def disable(self, name: str) -> None:\n+        if name not in MLLibmodProc.RESERVED_STREAMS:\n+            self._enabled_stream_modules.pop(name, None)\n+\n+    def get_module_streams(self, name: str) -> List:\n+        if self._mod_index is None:\n+            self.index_modules()\n+        assert self._mod_index is not None, \"Unable to get module streams: module index not found\"\n+\n+        streams: Set = set()\n+        module = self._mod_index.get_module(name)\n+        if module:\n+            for s_obj in module.get_all_streams():\n+                streams.add(s_obj.get_stream_name())\n+\n+        return list(streams)\n+\n+    def get_stream_contexts(self, s_type: mltypes.MLStreamType) -> List:\n+        if self._mod_index is None:\n+            self.index_modules()\n+        assert self._mod_index is not None, \"Unable to get stream contexts: module index not found\"\n+        contexts: List = []\n+        module = self._mod_index.get_module(s_type.name)\n+        if module:\n+            for stream in module.get_all_streams():\n+                if stream.get_stream_name() == s_type.stream:\n+                    contexts.append(stream)\n+\n+        return contexts\n+\n+    def get_stream_dependencies(self, ctx: Modulemd.ModuleStreamV2) -> List[str]:\n+        \"\"\"\n+        get_stream_dependencies -- get stream dependencies.\n+\n+        :param ctx: module stream context\n+        :type ctx: Modulemd.ModuleStreamV2\n+        :return: list of dependency names.\n+        :rtype: List[str]\n+        \"\"\"\n+        deps: List[str] = []\n+        s_deps: List[Modulemd.Dependencies] = ctx.get_dependencies() or []\n+        dep: Modulemd.Dependencies\n+        for dep in s_deps:\n+            deps.extend(dep.get_runtime_modules())\n+\n+        return deps\n+\n+    def index_modules(self) -> None:\n+        \"\"\"\n+        index_modules -- loads given metadata and indexes modules from there.\n+        \"\"\"\n+        if self._mod_index is None:\n+            mgr: Modulemd.ModuleIndex = Modulemd.ModuleIndexMerger.new()\n+            for path in self.metadata:\n+                idx = Modulemd.ModuleIndex.new()\n+                if self._is_meta_compressed(path):\n+                    with gzip.open(path) as gzmeta:\n+                        idx.update_from_string(gzmeta.read().decode(\"utf-8\"), True)\n+                else:\n+                    idx.update_from_file(path, True)\n+                mgr.associate_index(idx, 0)\n+            self._mod_index = mgr.resolve()\n+\n+    def get_default_stream(self, name: str):\n+        assert self._mod_index is not None, \"Unable to access module index when resolving default stream\"\n+        module = self._mod_index.get_module(name)\n+        if not module:\n+            raise ValueError(\"Module {} not found\".format(name))\n+        defaults = module.get_detaults()\n+        if defaults:\n+            return defaults.get_default_stream()\n+\n+        return module.get_all_streams()[0].get_stream_name()\n+\n+    def get_dep_streams(self, s_obj):\n+        dep = s_obj.get_dependencies()[0]  # XXX: Why just always first?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ebdd689746282209a2f297b258eef746e0c5d7f3"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk3MTM1NA==", "bodyText": "Yeah, I already figured that out, actually. And yes, I am looping it over, because who knows. Just need to push. :-)", "url": "https://github.com/uyuni-project/uyuni/pull/1769#discussion_r365971354", "createdAt": "2020-01-13T18:58:09Z", "author": {"login": "isbm"}, "path": "susemanager-utils/mgr-libmod/mgrlibmod/mllib.py", "diffHunk": "@@ -0,0 +1,330 @@\n+\"\"\"\n+libmod operations\n+\"\"\"\n+import os\n+import gzip\n+import json\n+import argparse\n+import binascii\n+\n+from typing import Any, Dict, List, Set\n+from mgrlibmod import mltypes\n+\n+import gi  # type: ignore\n+\n+gi.require_version(\"Modulemd\", \"2.0\")\n+from gi.repository import Modulemd  # type: ignore\n+\n+\n+class MLLibmodProc:\n+    \"\"\"\n+    Libmod process.\n+    \"\"\"\n+\n+    RESERVED_STREAMS = [\"platform\"]\n+\n+    def __init__(self, metadata: List[str]):\n+        \"\"\"\n+        __init__\n+\n+        :param metadata: paths of the metadata.\n+        :type metadata: List[str]\n+        \"\"\"\n+        self.metadata = metadata\n+        self._mod_index: Modulemd.ModuleIndex = None\n+        assert gi is not None and Modulemd is not None, \"No libmodulemd found\"\n+        self._enabled_stream_modules: Dict = {}\n+\n+    def _is_stream_enabled(self, s_type: mltypes.MLStreamType) -> bool:\n+        \"\"\"\n+        _is_stream_enabled -- returns True if stream is enabled. NOTE: \"platform\" is always enabled.\n+\n+        :param s_type: stream type object\n+        :type s_type: MLStreamType\n+        :return: True, if stream is enabled.\n+        :rtype: bool\n+        \"\"\"\n+        return s_type.name in self._enabled_stream_modules\n+\n+    def _is_meta_compressed(self, path: str) -> bool:\n+        \"\"\"\n+        _is_meta_compressed -- detect if metafile is plain text YAML or compressed.\n+\n+        :param path: path to the meta file.\n+        :type path: str\n+        :return: True, if meta is GNU Zip compressed.\n+        :rtype: bool\n+        \"\"\"\n+        with open(path, \"rb\") as metafile:\n+            return binascii.hexlify(metafile.read(2)) == b\"1f8b\"  # Almost reliable :-)\n+\n+    def enable_stream(self, s_obj) -> None:\n+        self._enabled_stream_modules[s_obj.get_module_name()] = s_obj\n+\n+    def disable(self, name: str) -> None:\n+        if name not in MLLibmodProc.RESERVED_STREAMS:\n+            self._enabled_stream_modules.pop(name, None)\n+\n+    def get_module_streams(self, name: str) -> List:\n+        if self._mod_index is None:\n+            self.index_modules()\n+        assert self._mod_index is not None, \"Unable to get module streams: module index not found\"\n+\n+        streams: Set = set()\n+        module = self._mod_index.get_module(name)\n+        if module:\n+            for s_obj in module.get_all_streams():\n+                streams.add(s_obj.get_stream_name())\n+\n+        return list(streams)\n+\n+    def get_stream_contexts(self, s_type: mltypes.MLStreamType) -> List:\n+        if self._mod_index is None:\n+            self.index_modules()\n+        assert self._mod_index is not None, \"Unable to get stream contexts: module index not found\"\n+        contexts: List = []\n+        module = self._mod_index.get_module(s_type.name)\n+        if module:\n+            for stream in module.get_all_streams():\n+                if stream.get_stream_name() == s_type.stream:\n+                    contexts.append(stream)\n+\n+        return contexts\n+\n+    def get_stream_dependencies(self, ctx: Modulemd.ModuleStreamV2) -> List[str]:\n+        \"\"\"\n+        get_stream_dependencies -- get stream dependencies.\n+\n+        :param ctx: module stream context\n+        :type ctx: Modulemd.ModuleStreamV2\n+        :return: list of dependency names.\n+        :rtype: List[str]\n+        \"\"\"\n+        deps: List[str] = []\n+        s_deps: List[Modulemd.Dependencies] = ctx.get_dependencies() or []\n+        dep: Modulemd.Dependencies\n+        for dep in s_deps:\n+            deps.extend(dep.get_runtime_modules())\n+\n+        return deps\n+\n+    def index_modules(self) -> None:\n+        \"\"\"\n+        index_modules -- loads given metadata and indexes modules from there.\n+        \"\"\"\n+        if self._mod_index is None:\n+            mgr: Modulemd.ModuleIndex = Modulemd.ModuleIndexMerger.new()\n+            for path in self.metadata:\n+                idx = Modulemd.ModuleIndex.new()\n+                if self._is_meta_compressed(path):\n+                    with gzip.open(path) as gzmeta:\n+                        idx.update_from_string(gzmeta.read().decode(\"utf-8\"), True)\n+                else:\n+                    idx.update_from_file(path, True)\n+                mgr.associate_index(idx, 0)\n+            self._mod_index = mgr.resolve()\n+\n+    def get_default_stream(self, name: str):\n+        assert self._mod_index is not None, \"Unable to access module index when resolving default stream\"\n+        module = self._mod_index.get_module(name)\n+        if not module:\n+            raise ValueError(\"Module {} not found\".format(name))\n+        defaults = module.get_detaults()\n+        if defaults:\n+            return defaults.get_default_stream()\n+\n+        return module.get_all_streams()[0].get_stream_name()\n+\n+    def get_dep_streams(self, s_obj):\n+        dep = s_obj.get_dependencies()[0]  # XXX: Why just always first?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkyNzc2Ng=="}, "originalCommit": {"oid": "ebdd689746282209a2f297b258eef746e0c5d7f3"}, "originalPosition": 139}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2MDY5NTg5OnYy", "diffSide": "RIGHT", "path": "susemanager-utils/mgr-libmod/mgrlibmod/mllib.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxNzoyNTozN1rOFc-hcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxODo1OTozOVrOFdBKdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkyODgxNw==", "bodyText": "we're calling get_runtime_streams(m) per module, and by definition, there cannot be more than 1 stream enabled for a module at the same time. Therefore, it's not possible for a module to depend on multiple streams of a same module. So in the end, this should also always be a 1 element array.\nBut again, I'm not against foolproofing this either.", "url": "https://github.com/uyuni-project/uyuni/pull/1769#discussion_r365928817", "createdAt": "2020-01-13T17:25:37Z", "author": {"login": "cbbayburt"}, "path": "susemanager-utils/mgr-libmod/mgrlibmod/mllib.py", "diffHunk": "@@ -0,0 +1,330 @@\n+\"\"\"\n+libmod operations\n+\"\"\"\n+import os\n+import gzip\n+import json\n+import argparse\n+import binascii\n+\n+from typing import Any, Dict, List, Set\n+from mgrlibmod import mltypes\n+\n+import gi  # type: ignore\n+\n+gi.require_version(\"Modulemd\", \"2.0\")\n+from gi.repository import Modulemd  # type: ignore\n+\n+\n+class MLLibmodProc:\n+    \"\"\"\n+    Libmod process.\n+    \"\"\"\n+\n+    RESERVED_STREAMS = [\"platform\"]\n+\n+    def __init__(self, metadata: List[str]):\n+        \"\"\"\n+        __init__\n+\n+        :param metadata: paths of the metadata.\n+        :type metadata: List[str]\n+        \"\"\"\n+        self.metadata = metadata\n+        self._mod_index: Modulemd.ModuleIndex = None\n+        assert gi is not None and Modulemd is not None, \"No libmodulemd found\"\n+        self._enabled_stream_modules: Dict = {}\n+\n+    def _is_stream_enabled(self, s_type: mltypes.MLStreamType) -> bool:\n+        \"\"\"\n+        _is_stream_enabled -- returns True if stream is enabled. NOTE: \"platform\" is always enabled.\n+\n+        :param s_type: stream type object\n+        :type s_type: MLStreamType\n+        :return: True, if stream is enabled.\n+        :rtype: bool\n+        \"\"\"\n+        return s_type.name in self._enabled_stream_modules\n+\n+    def _is_meta_compressed(self, path: str) -> bool:\n+        \"\"\"\n+        _is_meta_compressed -- detect if metafile is plain text YAML or compressed.\n+\n+        :param path: path to the meta file.\n+        :type path: str\n+        :return: True, if meta is GNU Zip compressed.\n+        :rtype: bool\n+        \"\"\"\n+        with open(path, \"rb\") as metafile:\n+            return binascii.hexlify(metafile.read(2)) == b\"1f8b\"  # Almost reliable :-)\n+\n+    def enable_stream(self, s_obj) -> None:\n+        self._enabled_stream_modules[s_obj.get_module_name()] = s_obj\n+\n+    def disable(self, name: str) -> None:\n+        if name not in MLLibmodProc.RESERVED_STREAMS:\n+            self._enabled_stream_modules.pop(name, None)\n+\n+    def get_module_streams(self, name: str) -> List:\n+        if self._mod_index is None:\n+            self.index_modules()\n+        assert self._mod_index is not None, \"Unable to get module streams: module index not found\"\n+\n+        streams: Set = set()\n+        module = self._mod_index.get_module(name)\n+        if module:\n+            for s_obj in module.get_all_streams():\n+                streams.add(s_obj.get_stream_name())\n+\n+        return list(streams)\n+\n+    def get_stream_contexts(self, s_type: mltypes.MLStreamType) -> List:\n+        if self._mod_index is None:\n+            self.index_modules()\n+        assert self._mod_index is not None, \"Unable to get stream contexts: module index not found\"\n+        contexts: List = []\n+        module = self._mod_index.get_module(s_type.name)\n+        if module:\n+            for stream in module.get_all_streams():\n+                if stream.get_stream_name() == s_type.stream:\n+                    contexts.append(stream)\n+\n+        return contexts\n+\n+    def get_stream_dependencies(self, ctx: Modulemd.ModuleStreamV2) -> List[str]:\n+        \"\"\"\n+        get_stream_dependencies -- get stream dependencies.\n+\n+        :param ctx: module stream context\n+        :type ctx: Modulemd.ModuleStreamV2\n+        :return: list of dependency names.\n+        :rtype: List[str]\n+        \"\"\"\n+        deps: List[str] = []\n+        s_deps: List[Modulemd.Dependencies] = ctx.get_dependencies() or []\n+        dep: Modulemd.Dependencies\n+        for dep in s_deps:\n+            deps.extend(dep.get_runtime_modules())\n+\n+        return deps\n+\n+    def index_modules(self) -> None:\n+        \"\"\"\n+        index_modules -- loads given metadata and indexes modules from there.\n+        \"\"\"\n+        if self._mod_index is None:\n+            mgr: Modulemd.ModuleIndex = Modulemd.ModuleIndexMerger.new()\n+            for path in self.metadata:\n+                idx = Modulemd.ModuleIndex.new()\n+                if self._is_meta_compressed(path):\n+                    with gzip.open(path) as gzmeta:\n+                        idx.update_from_string(gzmeta.read().decode(\"utf-8\"), True)\n+                else:\n+                    idx.update_from_file(path, True)\n+                mgr.associate_index(idx, 0)\n+            self._mod_index = mgr.resolve()\n+\n+    def get_default_stream(self, name: str):\n+        assert self._mod_index is not None, \"Unable to access module index when resolving default stream\"\n+        module = self._mod_index.get_module(name)\n+        if not module:\n+            raise ValueError(\"Module {} not found\".format(name))\n+        defaults = module.get_detaults()\n+        if defaults:\n+            return defaults.get_default_stream()\n+\n+        return module.get_all_streams()[0].get_stream_name()\n+\n+    def get_dep_streams(self, s_obj):\n+        dep = s_obj.get_dependencies()[0]  # XXX: Why just always first?\n+        all_deps = []  # type: ignore\n+        for m in dep.get_runtime_modules():\n+            deps = dep.get_runtime_streams(m)\n+            if deps:\n+                all_deps.append((m, deps[0],))  # XXX: why just first?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ebdd689746282209a2f297b258eef746e0c5d7f3"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk3MjA4NQ==", "bodyText": "Yeah, let's foolproof. Usually the foo[idx] code in Python world considered evil, unless you really know what you are doing. E.g. in unit tests it is OK, but in code like that, maybe OK. I am still wondering why they are returning array with one element than just element... Having for loops all over the place is also not great. Maybe I can wrap that thing into a property, so we don't have loops but we don't access that by an index either.", "url": "https://github.com/uyuni-project/uyuni/pull/1769#discussion_r365972085", "createdAt": "2020-01-13T18:59:39Z", "author": {"login": "isbm"}, "path": "susemanager-utils/mgr-libmod/mgrlibmod/mllib.py", "diffHunk": "@@ -0,0 +1,330 @@\n+\"\"\"\n+libmod operations\n+\"\"\"\n+import os\n+import gzip\n+import json\n+import argparse\n+import binascii\n+\n+from typing import Any, Dict, List, Set\n+from mgrlibmod import mltypes\n+\n+import gi  # type: ignore\n+\n+gi.require_version(\"Modulemd\", \"2.0\")\n+from gi.repository import Modulemd  # type: ignore\n+\n+\n+class MLLibmodProc:\n+    \"\"\"\n+    Libmod process.\n+    \"\"\"\n+\n+    RESERVED_STREAMS = [\"platform\"]\n+\n+    def __init__(self, metadata: List[str]):\n+        \"\"\"\n+        __init__\n+\n+        :param metadata: paths of the metadata.\n+        :type metadata: List[str]\n+        \"\"\"\n+        self.metadata = metadata\n+        self._mod_index: Modulemd.ModuleIndex = None\n+        assert gi is not None and Modulemd is not None, \"No libmodulemd found\"\n+        self._enabled_stream_modules: Dict = {}\n+\n+    def _is_stream_enabled(self, s_type: mltypes.MLStreamType) -> bool:\n+        \"\"\"\n+        _is_stream_enabled -- returns True if stream is enabled. NOTE: \"platform\" is always enabled.\n+\n+        :param s_type: stream type object\n+        :type s_type: MLStreamType\n+        :return: True, if stream is enabled.\n+        :rtype: bool\n+        \"\"\"\n+        return s_type.name in self._enabled_stream_modules\n+\n+    def _is_meta_compressed(self, path: str) -> bool:\n+        \"\"\"\n+        _is_meta_compressed -- detect if metafile is plain text YAML or compressed.\n+\n+        :param path: path to the meta file.\n+        :type path: str\n+        :return: True, if meta is GNU Zip compressed.\n+        :rtype: bool\n+        \"\"\"\n+        with open(path, \"rb\") as metafile:\n+            return binascii.hexlify(metafile.read(2)) == b\"1f8b\"  # Almost reliable :-)\n+\n+    def enable_stream(self, s_obj) -> None:\n+        self._enabled_stream_modules[s_obj.get_module_name()] = s_obj\n+\n+    def disable(self, name: str) -> None:\n+        if name not in MLLibmodProc.RESERVED_STREAMS:\n+            self._enabled_stream_modules.pop(name, None)\n+\n+    def get_module_streams(self, name: str) -> List:\n+        if self._mod_index is None:\n+            self.index_modules()\n+        assert self._mod_index is not None, \"Unable to get module streams: module index not found\"\n+\n+        streams: Set = set()\n+        module = self._mod_index.get_module(name)\n+        if module:\n+            for s_obj in module.get_all_streams():\n+                streams.add(s_obj.get_stream_name())\n+\n+        return list(streams)\n+\n+    def get_stream_contexts(self, s_type: mltypes.MLStreamType) -> List:\n+        if self._mod_index is None:\n+            self.index_modules()\n+        assert self._mod_index is not None, \"Unable to get stream contexts: module index not found\"\n+        contexts: List = []\n+        module = self._mod_index.get_module(s_type.name)\n+        if module:\n+            for stream in module.get_all_streams():\n+                if stream.get_stream_name() == s_type.stream:\n+                    contexts.append(stream)\n+\n+        return contexts\n+\n+    def get_stream_dependencies(self, ctx: Modulemd.ModuleStreamV2) -> List[str]:\n+        \"\"\"\n+        get_stream_dependencies -- get stream dependencies.\n+\n+        :param ctx: module stream context\n+        :type ctx: Modulemd.ModuleStreamV2\n+        :return: list of dependency names.\n+        :rtype: List[str]\n+        \"\"\"\n+        deps: List[str] = []\n+        s_deps: List[Modulemd.Dependencies] = ctx.get_dependencies() or []\n+        dep: Modulemd.Dependencies\n+        for dep in s_deps:\n+            deps.extend(dep.get_runtime_modules())\n+\n+        return deps\n+\n+    def index_modules(self) -> None:\n+        \"\"\"\n+        index_modules -- loads given metadata and indexes modules from there.\n+        \"\"\"\n+        if self._mod_index is None:\n+            mgr: Modulemd.ModuleIndex = Modulemd.ModuleIndexMerger.new()\n+            for path in self.metadata:\n+                idx = Modulemd.ModuleIndex.new()\n+                if self._is_meta_compressed(path):\n+                    with gzip.open(path) as gzmeta:\n+                        idx.update_from_string(gzmeta.read().decode(\"utf-8\"), True)\n+                else:\n+                    idx.update_from_file(path, True)\n+                mgr.associate_index(idx, 0)\n+            self._mod_index = mgr.resolve()\n+\n+    def get_default_stream(self, name: str):\n+        assert self._mod_index is not None, \"Unable to access module index when resolving default stream\"\n+        module = self._mod_index.get_module(name)\n+        if not module:\n+            raise ValueError(\"Module {} not found\".format(name))\n+        defaults = module.get_detaults()\n+        if defaults:\n+            return defaults.get_default_stream()\n+\n+        return module.get_all_streams()[0].get_stream_name()\n+\n+    def get_dep_streams(self, s_obj):\n+        dep = s_obj.get_dependencies()[0]  # XXX: Why just always first?\n+        all_deps = []  # type: ignore\n+        for m in dep.get_runtime_modules():\n+            deps = dep.get_runtime_streams(m)\n+            if deps:\n+                all_deps.append((m, deps[0],))  # XXX: why just first?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkyODgxNw=="}, "originalCommit": {"oid": "ebdd689746282209a2f297b258eef746e0c5d7f3"}, "originalPosition": 144}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 197, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}