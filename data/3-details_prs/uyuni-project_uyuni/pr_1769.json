{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYwMDUxODU1", "number": 1769, "title": "mgr-libmod", "bodyText": "What does this PR change?\nImplements https://github.com/SUSE/spacewalk/issues/10092\n\n DONE\n\nDocumentation\n\n\nNo documentation needed: add explanation. This can't be used if there is a GUI diff\n\n\ndoc-susemanager PR or issue was created (GitHub automatic link expected below)\n\n\n DONE\n\n\nTest coverage\n\n\nNo tests: add explanation\n\n\nUnit tests were added\n\n\nCucumber tests were added\n\n\n DONE\n\n\nLinks\nFixes #\nTracks # add downstream PR, if any\n\n DONE\n\nChangelogs\nIf you don't need a changelog check, please mark this checkbox:\n\n No changelog needed\n\nIf you uncheck the checkbox after the PR is created, you will need to re-run changelog_test (see below)\nRe-run a test\nIf you need to re-run a test, please mark the related checkbox, it will be unchecked automatically once it has re-run:\n\n Re-run test \"changelog_test\"\n Re-run test \"backend_unittests_pgsql\"\n Re-run test \"java_lint_checkstyle\"\n Re-run test \"java_pgsql_tests\"\n Re-run test \"ruby_rubocop\"\n Re-run test \"schema_migration_test_oracle\"\n Re-run test \"schema_migration_test_pgsql\"\n Re-run test \"susemanager_unittests\"\n Re-run test \"javascript_lint\"\n Re-run test \"spacecmd_unittests\"", "createdAt": "2020-01-07T15:50:59Z", "url": "https://github.com/uyuni-project/uyuni/pull/1769", "merged": true, "mergeCommit": {"oid": "30f0c4e6f6af6b4fcb9249849fd1b5086b2bf71f"}, "closed": true, "closedAt": "2020-02-07T14:34:25Z", "author": {"login": "isbm"}, "timelineItems": {"totalCount": 58, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb4CxA1AH2gAyMzYwMDUxODU1OmY2NjM0YTcxOGIxN2ZmNDc5ODBkNjU4MjNmZTlmNDJkNzIzODZhMWM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcCASnkAFqTM1NTE5NjIyNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "f6634a718b17ff47980d65823fe9f42d72386a1c", "author": {"user": null}, "url": "https://github.com/uyuni-project/uyuni/commit/f6634a718b17ff47980d65823fe9f42d72386a1c", "committedDate": "2020-01-07T15:48:02Z", "message": "Add setup.py"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0e61e54e463d6c08a40db4c7a4dc2265551cf39b", "author": {"user": null}, "url": "https://github.com/uyuni-project/uyuni/commit/0e61e54e463d6c08a40db4c7a4dc2265551cf39b", "committedDate": "2020-01-07T15:48:53Z", "message": "Define package name"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7dbb8f965a7bdac7572b6273209c04e62193619d", "author": {"user": null}, "url": "https://github.com/uyuni-project/uyuni/commit/7dbb8f965a7bdac7572b6273209c04e62193619d", "committedDate": "2020-01-07T15:49:09Z", "message": "Add package type input"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "55dee6207bb3abbccf3ac37eecc8789ad0e49a09", "author": {"user": null}, "url": "https://github.com/uyuni-project/uyuni/commit/55dee6207bb3abbccf3ac37eecc8789ad0e49a09", "committedDate": "2020-01-07T15:49:19Z", "message": "Add main script (initial)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1cb7efb046a819747a725c045e9dfe413e02c914", "author": {"user": null}, "url": "https://github.com/uyuni-project/uyuni/commit/1cb7efb046a819747a725c045e9dfe413e02c914", "committedDate": "2020-01-07T16:06:04Z", "message": "Update docstrings"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d680b1f3fdfdc29ed9371d0e3fe003cdbb0012e6", "author": {"user": null}, "url": "https://github.com/uyuni-project/uyuni/commit/d680b1f3fdfdc29ed9371d0e3fe003cdbb0012e6", "committedDate": "2020-01-08T14:03:44Z", "message": "Add JSON input example"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "527d905c5fd7a1ebd96342c92c49dfe38773d0eb", "author": {"user": null}, "url": "https://github.com/uyuni-project/uyuni/commit/527d905c5fd7a1ebd96342c92c49dfe38773d0eb", "committedDate": "2020-01-08T14:05:34Z", "message": "Add simple CLI app"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cfca447bc4eb9c4aacef6c1610584c8c5bb62e43", "author": {"user": null}, "url": "https://github.com/uyuni-project/uyuni/commit/cfca447bc4eb9c4aacef6c1610584c8c5bb62e43", "committedDate": "2020-01-08T16:37:39Z", "message": "Update input and response types"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "498c9d52b3e405eab6257894442d46b2032fcdd1", "author": {"user": null}, "url": "https://github.com/uyuni-project/uyuni/commit/498c9d52b3e405eab6257894442d46b2032fcdd1", "committedDate": "2020-01-09T10:31:07Z", "message": "Update input samples"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4dbff7fb0d18a4a2bd773c5efbd5dc8b789c8b15", "author": {"user": null}, "url": "https://github.com/uyuni-project/uyuni/commit/4dbff7fb0d18a4a2bd773c5efbd5dc8b789c8b15", "committedDate": "2020-01-09T10:51:22Z", "message": "Add YAML samples, update input requests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8318c153fc871a35c0bd802d5d369d4f7696775b", "author": {"user": null}, "url": "https://github.com/uyuni-project/uyuni/commit/8318c153fc871a35c0bd802d5d369d4f7696775b", "committedDate": "2020-01-09T14:21:31Z", "message": "User pure STDIN for the input so the arguments may be used"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9c7e76dc2b0b4c84353f12d4733280078ab4fa03", "author": {"user": null}, "url": "https://github.com/uyuni-project/uyuni/commit/9c7e76dc2b0b4c84353f12d4733280078ab4fa03", "committedDate": "2020-01-09T14:22:31Z", "message": "Add get_function method for the input type"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0ac6190a56c8a018af1035bbb0dc17642c2d5b28", "author": {"user": null}, "url": "https://github.com/uyuni-project/uyuni/commit/0ac6190a56c8a018af1035bbb0dc17642c2d5b28", "committedDate": "2020-01-09T14:23:08Z", "message": "Fix type for get_streams method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b5711f2e91673508583e6483bd1d154e130946d1", "author": {"user": null}, "url": "https://github.com/uyuni-project/uyuni/commit/b5711f2e91673508583e6483bd1d154e130946d1", "committedDate": "2020-01-09T14:23:28Z", "message": "Formatting autofixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bceb694f01765a596639c39302ad912ca63bf3df", "author": {"user": null}, "url": "https://github.com/uyuni-project/uyuni/commit/bceb694f01765a596639c39302ad912ca63bf3df", "committedDate": "2020-01-09T14:24:06Z", "message": "Add resolver process class"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "034863be5b584f5e87f6b8f00c2b0468b2794367", "author": {"user": null}, "url": "https://github.com/uyuni-project/uyuni/commit/034863be5b584f5e87f6b8f00c2b0468b2794367", "committedDate": "2020-01-09T14:24:30Z", "message": "Reorganise main lib class for the CLI app"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4a3708cf2c95f2b34f3650f3ce6455213fbc568a", "author": {"user": null}, "url": "https://github.com/uyuni-project/uyuni/commit/4a3708cf2c95f2b34f3650f3ce6455213fbc568a", "committedDate": "2020-01-10T11:07:37Z", "message": "Add stream type"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3f675b24ac744e5e8673af213add427843dc0f79", "author": {"user": null}, "url": "https://github.com/uyuni-project/uyuni/commit/3f675b24ac744e5e8673af213add427843dc0f79", "committedDate": "2020-01-10T14:37:00Z", "message": "Print pretty formatted output"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "16e13c2abcd27bbd3a44be708859869300974b6a", "author": {"user": null}, "url": "https://github.com/uyuni-project/uyuni/commit/16e13c2abcd27bbd3a44be708859869300974b6a", "committedDate": "2020-01-10T14:37:37Z", "message": "Fix typo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8eb816d3a930c385158e2267e8da047aeded13b9", "author": {"user": null}, "url": "https://github.com/uyuni-project/uyuni/commit/8eb816d3a930c385158e2267e8da047aeded13b9", "committedDate": "2020-01-10T14:38:02Z", "message": "Add serialisable replacement for Set type."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ebdd689746282209a2f297b258eef746e0c5d7f3", "author": {"user": null}, "url": "https://github.com/uyuni-project/uyuni/commit/ebdd689746282209a2f297b258eef746e0c5d7f3", "committedDate": "2020-01-10T14:38:35Z", "message": "Add initial implementation of the dep resolver"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQxOTk5ODcz", "url": "https://github.com/uyuni-project/uyuni/pull/1769#pullrequestreview-341999873", "createdAt": "2020-01-13T17:09:39Z", "commit": {"oid": "ebdd689746282209a2f297b258eef746e0c5d7f3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxNzowOTozOVrOFc-EAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxNzowOTozOVrOFc-EAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkyMTI4MQ==", "bodyText": "This should be el8, not e18 (stands for Enterprise Linux 8).\nThe module named \"platform\" is a pseudo-module to specify the actual OS in the modules world. So if a module depends on platform:el8, it just means it's built for RHEL 8.\nI'm not completely happy hardcoding this here, the values will surely change in the future.", "url": "https://github.com/uyuni-project/uyuni/pull/1769#discussion_r365921281", "createdAt": "2020-01-13T17:09:39Z", "author": {"login": "cbbayburt"}, "path": "susemanager-utils/mgr-libmod/mgrlibmod/mllib.py", "diffHunk": "@@ -0,0 +1,330 @@\n+\"\"\"\n+libmod operations\n+\"\"\"\n+import os\n+import gzip\n+import json\n+import argparse\n+import binascii\n+\n+from typing import Any, Dict, List, Set\n+from mgrlibmod import mltypes\n+\n+import gi  # type: ignore\n+\n+gi.require_version(\"Modulemd\", \"2.0\")\n+from gi.repository import Modulemd  # type: ignore\n+\n+\n+class MLLibmodProc:\n+    \"\"\"\n+    Libmod process.\n+    \"\"\"\n+\n+    RESERVED_STREAMS = [\"platform\"]\n+\n+    def __init__(self, metadata: List[str]):\n+        \"\"\"\n+        __init__\n+\n+        :param metadata: paths of the metadata.\n+        :type metadata: List[str]\n+        \"\"\"\n+        self.metadata = metadata\n+        self._mod_index: Modulemd.ModuleIndex = None\n+        assert gi is not None and Modulemd is not None, \"No libmodulemd found\"\n+        self._enabled_stream_modules: Dict = {}\n+\n+    def _is_stream_enabled(self, s_type: mltypes.MLStreamType) -> bool:\n+        \"\"\"\n+        _is_stream_enabled -- returns True if stream is enabled. NOTE: \"platform\" is always enabled.\n+\n+        :param s_type: stream type object\n+        :type s_type: MLStreamType\n+        :return: True, if stream is enabled.\n+        :rtype: bool\n+        \"\"\"\n+        return s_type.name in self._enabled_stream_modules\n+\n+    def _is_meta_compressed(self, path: str) -> bool:\n+        \"\"\"\n+        _is_meta_compressed -- detect if metafile is plain text YAML or compressed.\n+\n+        :param path: path to the meta file.\n+        :type path: str\n+        :return: True, if meta is GNU Zip compressed.\n+        :rtype: bool\n+        \"\"\"\n+        with open(path, \"rb\") as metafile:\n+            return binascii.hexlify(metafile.read(2)) == b\"1f8b\"  # Almost reliable :-)\n+\n+    def enable_stream(self, s_obj) -> None:\n+        self._enabled_stream_modules[s_obj.get_module_name()] = s_obj\n+\n+    def disable(self, name: str) -> None:\n+        if name not in MLLibmodProc.RESERVED_STREAMS:\n+            self._enabled_stream_modules.pop(name, None)\n+\n+    def get_module_streams(self, name: str) -> List:\n+        if self._mod_index is None:\n+            self.index_modules()\n+        assert self._mod_index is not None, \"Unable to get module streams: module index not found\"\n+\n+        streams: Set = set()\n+        module = self._mod_index.get_module(name)\n+        if module:\n+            for s_obj in module.get_all_streams():\n+                streams.add(s_obj.get_stream_name())\n+\n+        return list(streams)\n+\n+    def get_stream_contexts(self, s_type: mltypes.MLStreamType) -> List:\n+        if self._mod_index is None:\n+            self.index_modules()\n+        assert self._mod_index is not None, \"Unable to get stream contexts: module index not found\"\n+        contexts: List = []\n+        module = self._mod_index.get_module(s_type.name)\n+        if module:\n+            for stream in module.get_all_streams():\n+                if stream.get_stream_name() == s_type.stream:\n+                    contexts.append(stream)\n+\n+        return contexts\n+\n+    def get_stream_dependencies(self, ctx: Modulemd.ModuleStreamV2) -> List[str]:\n+        \"\"\"\n+        get_stream_dependencies -- get stream dependencies.\n+\n+        :param ctx: module stream context\n+        :type ctx: Modulemd.ModuleStreamV2\n+        :return: list of dependency names.\n+        :rtype: List[str]\n+        \"\"\"\n+        deps: List[str] = []\n+        s_deps: List[Modulemd.Dependencies] = ctx.get_dependencies() or []\n+        dep: Modulemd.Dependencies\n+        for dep in s_deps:\n+            deps.extend(dep.get_runtime_modules())\n+\n+        return deps\n+\n+    def index_modules(self) -> None:\n+        \"\"\"\n+        index_modules -- loads given metadata and indexes modules from there.\n+        \"\"\"\n+        if self._mod_index is None:\n+            mgr: Modulemd.ModuleIndex = Modulemd.ModuleIndexMerger.new()\n+            for path in self.metadata:\n+                idx = Modulemd.ModuleIndex.new()\n+                if self._is_meta_compressed(path):\n+                    with gzip.open(path) as gzmeta:\n+                        idx.update_from_string(gzmeta.read().decode(\"utf-8\"), True)\n+                else:\n+                    idx.update_from_file(path, True)\n+                mgr.associate_index(idx, 0)\n+            self._mod_index = mgr.resolve()\n+\n+    def get_default_stream(self, name: str):\n+        assert self._mod_index is not None, \"Unable to access module index when resolving default stream\"\n+        module = self._mod_index.get_module(name)\n+        if not module:\n+            raise ValueError(\"Module {} not found\".format(name))\n+        defaults = module.get_detaults()\n+        if defaults:\n+            return defaults.get_default_stream()\n+\n+        return module.get_all_streams()[0].get_stream_name()\n+\n+    def get_dep_streams(self, s_obj):\n+        dep = s_obj.get_dependencies()[0]  # XXX: Why just always first?\n+        all_deps = []  # type: ignore\n+        for m in dep.get_runtime_modules():\n+            deps = dep.get_runtime_streams(m)\n+            if deps:\n+                all_deps.append((m, deps[0],))  # XXX: why just first?\n+        return all_deps\n+\n+    def get_actual_stream(self, name: str):\n+        if name == \"platform\":\n+            return \"e18\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ebdd689746282209a2f297b258eef746e0c5d7f3"}, "originalPosition": 149}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyMDA4NDgx", "url": "https://github.com/uyuni-project/uyuni/pull/1769#pullrequestreview-342008481", "createdAt": "2020-01-13T17:23:21Z", "commit": {"oid": "ebdd689746282209a2f297b258eef746e0c5d7f3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxNzoyMzoyMVrOFc-dVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxNzoyMzoyMVrOFc-dVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkyNzc2Ng==", "bodyText": "get_dependencies() returns a Modulemd.Dependencies object wrapped in a list, rather than returning a list of dependencies directly. And this list is always a 1 element array. But I guess it wouldn't hurt to foolproof this by looping to operate on the whole array (there's no info on this in the API docs)", "url": "https://github.com/uyuni-project/uyuni/pull/1769#discussion_r365927766", "createdAt": "2020-01-13T17:23:21Z", "author": {"login": "cbbayburt"}, "path": "susemanager-utils/mgr-libmod/mgrlibmod/mllib.py", "diffHunk": "@@ -0,0 +1,330 @@\n+\"\"\"\n+libmod operations\n+\"\"\"\n+import os\n+import gzip\n+import json\n+import argparse\n+import binascii\n+\n+from typing import Any, Dict, List, Set\n+from mgrlibmod import mltypes\n+\n+import gi  # type: ignore\n+\n+gi.require_version(\"Modulemd\", \"2.0\")\n+from gi.repository import Modulemd  # type: ignore\n+\n+\n+class MLLibmodProc:\n+    \"\"\"\n+    Libmod process.\n+    \"\"\"\n+\n+    RESERVED_STREAMS = [\"platform\"]\n+\n+    def __init__(self, metadata: List[str]):\n+        \"\"\"\n+        __init__\n+\n+        :param metadata: paths of the metadata.\n+        :type metadata: List[str]\n+        \"\"\"\n+        self.metadata = metadata\n+        self._mod_index: Modulemd.ModuleIndex = None\n+        assert gi is not None and Modulemd is not None, \"No libmodulemd found\"\n+        self._enabled_stream_modules: Dict = {}\n+\n+    def _is_stream_enabled(self, s_type: mltypes.MLStreamType) -> bool:\n+        \"\"\"\n+        _is_stream_enabled -- returns True if stream is enabled. NOTE: \"platform\" is always enabled.\n+\n+        :param s_type: stream type object\n+        :type s_type: MLStreamType\n+        :return: True, if stream is enabled.\n+        :rtype: bool\n+        \"\"\"\n+        return s_type.name in self._enabled_stream_modules\n+\n+    def _is_meta_compressed(self, path: str) -> bool:\n+        \"\"\"\n+        _is_meta_compressed -- detect if metafile is plain text YAML or compressed.\n+\n+        :param path: path to the meta file.\n+        :type path: str\n+        :return: True, if meta is GNU Zip compressed.\n+        :rtype: bool\n+        \"\"\"\n+        with open(path, \"rb\") as metafile:\n+            return binascii.hexlify(metafile.read(2)) == b\"1f8b\"  # Almost reliable :-)\n+\n+    def enable_stream(self, s_obj) -> None:\n+        self._enabled_stream_modules[s_obj.get_module_name()] = s_obj\n+\n+    def disable(self, name: str) -> None:\n+        if name not in MLLibmodProc.RESERVED_STREAMS:\n+            self._enabled_stream_modules.pop(name, None)\n+\n+    def get_module_streams(self, name: str) -> List:\n+        if self._mod_index is None:\n+            self.index_modules()\n+        assert self._mod_index is not None, \"Unable to get module streams: module index not found\"\n+\n+        streams: Set = set()\n+        module = self._mod_index.get_module(name)\n+        if module:\n+            for s_obj in module.get_all_streams():\n+                streams.add(s_obj.get_stream_name())\n+\n+        return list(streams)\n+\n+    def get_stream_contexts(self, s_type: mltypes.MLStreamType) -> List:\n+        if self._mod_index is None:\n+            self.index_modules()\n+        assert self._mod_index is not None, \"Unable to get stream contexts: module index not found\"\n+        contexts: List = []\n+        module = self._mod_index.get_module(s_type.name)\n+        if module:\n+            for stream in module.get_all_streams():\n+                if stream.get_stream_name() == s_type.stream:\n+                    contexts.append(stream)\n+\n+        return contexts\n+\n+    def get_stream_dependencies(self, ctx: Modulemd.ModuleStreamV2) -> List[str]:\n+        \"\"\"\n+        get_stream_dependencies -- get stream dependencies.\n+\n+        :param ctx: module stream context\n+        :type ctx: Modulemd.ModuleStreamV2\n+        :return: list of dependency names.\n+        :rtype: List[str]\n+        \"\"\"\n+        deps: List[str] = []\n+        s_deps: List[Modulemd.Dependencies] = ctx.get_dependencies() or []\n+        dep: Modulemd.Dependencies\n+        for dep in s_deps:\n+            deps.extend(dep.get_runtime_modules())\n+\n+        return deps\n+\n+    def index_modules(self) -> None:\n+        \"\"\"\n+        index_modules -- loads given metadata and indexes modules from there.\n+        \"\"\"\n+        if self._mod_index is None:\n+            mgr: Modulemd.ModuleIndex = Modulemd.ModuleIndexMerger.new()\n+            for path in self.metadata:\n+                idx = Modulemd.ModuleIndex.new()\n+                if self._is_meta_compressed(path):\n+                    with gzip.open(path) as gzmeta:\n+                        idx.update_from_string(gzmeta.read().decode(\"utf-8\"), True)\n+                else:\n+                    idx.update_from_file(path, True)\n+                mgr.associate_index(idx, 0)\n+            self._mod_index = mgr.resolve()\n+\n+    def get_default_stream(self, name: str):\n+        assert self._mod_index is not None, \"Unable to access module index when resolving default stream\"\n+        module = self._mod_index.get_module(name)\n+        if not module:\n+            raise ValueError(\"Module {} not found\".format(name))\n+        defaults = module.get_detaults()\n+        if defaults:\n+            return defaults.get_default_stream()\n+\n+        return module.get_all_streams()[0].get_stream_name()\n+\n+    def get_dep_streams(self, s_obj):\n+        dep = s_obj.get_dependencies()[0]  # XXX: Why just always first?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ebdd689746282209a2f297b258eef746e0c5d7f3"}, "originalPosition": 139}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyMDA5ODU5", "url": "https://github.com/uyuni-project/uyuni/pull/1769#pullrequestreview-342009859", "createdAt": "2020-01-13T17:25:37Z", "commit": {"oid": "ebdd689746282209a2f297b258eef746e0c5d7f3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxNzoyNTozN1rOFc-hcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxNzoyNTozN1rOFc-hcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkyODgxNw==", "bodyText": "we're calling get_runtime_streams(m) per module, and by definition, there cannot be more than 1 stream enabled for a module at the same time. Therefore, it's not possible for a module to depend on multiple streams of a same module. So in the end, this should also always be a 1 element array.\nBut again, I'm not against foolproofing this either.", "url": "https://github.com/uyuni-project/uyuni/pull/1769#discussion_r365928817", "createdAt": "2020-01-13T17:25:37Z", "author": {"login": "cbbayburt"}, "path": "susemanager-utils/mgr-libmod/mgrlibmod/mllib.py", "diffHunk": "@@ -0,0 +1,330 @@\n+\"\"\"\n+libmod operations\n+\"\"\"\n+import os\n+import gzip\n+import json\n+import argparse\n+import binascii\n+\n+from typing import Any, Dict, List, Set\n+from mgrlibmod import mltypes\n+\n+import gi  # type: ignore\n+\n+gi.require_version(\"Modulemd\", \"2.0\")\n+from gi.repository import Modulemd  # type: ignore\n+\n+\n+class MLLibmodProc:\n+    \"\"\"\n+    Libmod process.\n+    \"\"\"\n+\n+    RESERVED_STREAMS = [\"platform\"]\n+\n+    def __init__(self, metadata: List[str]):\n+        \"\"\"\n+        __init__\n+\n+        :param metadata: paths of the metadata.\n+        :type metadata: List[str]\n+        \"\"\"\n+        self.metadata = metadata\n+        self._mod_index: Modulemd.ModuleIndex = None\n+        assert gi is not None and Modulemd is not None, \"No libmodulemd found\"\n+        self._enabled_stream_modules: Dict = {}\n+\n+    def _is_stream_enabled(self, s_type: mltypes.MLStreamType) -> bool:\n+        \"\"\"\n+        _is_stream_enabled -- returns True if stream is enabled. NOTE: \"platform\" is always enabled.\n+\n+        :param s_type: stream type object\n+        :type s_type: MLStreamType\n+        :return: True, if stream is enabled.\n+        :rtype: bool\n+        \"\"\"\n+        return s_type.name in self._enabled_stream_modules\n+\n+    def _is_meta_compressed(self, path: str) -> bool:\n+        \"\"\"\n+        _is_meta_compressed -- detect if metafile is plain text YAML or compressed.\n+\n+        :param path: path to the meta file.\n+        :type path: str\n+        :return: True, if meta is GNU Zip compressed.\n+        :rtype: bool\n+        \"\"\"\n+        with open(path, \"rb\") as metafile:\n+            return binascii.hexlify(metafile.read(2)) == b\"1f8b\"  # Almost reliable :-)\n+\n+    def enable_stream(self, s_obj) -> None:\n+        self._enabled_stream_modules[s_obj.get_module_name()] = s_obj\n+\n+    def disable(self, name: str) -> None:\n+        if name not in MLLibmodProc.RESERVED_STREAMS:\n+            self._enabled_stream_modules.pop(name, None)\n+\n+    def get_module_streams(self, name: str) -> List:\n+        if self._mod_index is None:\n+            self.index_modules()\n+        assert self._mod_index is not None, \"Unable to get module streams: module index not found\"\n+\n+        streams: Set = set()\n+        module = self._mod_index.get_module(name)\n+        if module:\n+            for s_obj in module.get_all_streams():\n+                streams.add(s_obj.get_stream_name())\n+\n+        return list(streams)\n+\n+    def get_stream_contexts(self, s_type: mltypes.MLStreamType) -> List:\n+        if self._mod_index is None:\n+            self.index_modules()\n+        assert self._mod_index is not None, \"Unable to get stream contexts: module index not found\"\n+        contexts: List = []\n+        module = self._mod_index.get_module(s_type.name)\n+        if module:\n+            for stream in module.get_all_streams():\n+                if stream.get_stream_name() == s_type.stream:\n+                    contexts.append(stream)\n+\n+        return contexts\n+\n+    def get_stream_dependencies(self, ctx: Modulemd.ModuleStreamV2) -> List[str]:\n+        \"\"\"\n+        get_stream_dependencies -- get stream dependencies.\n+\n+        :param ctx: module stream context\n+        :type ctx: Modulemd.ModuleStreamV2\n+        :return: list of dependency names.\n+        :rtype: List[str]\n+        \"\"\"\n+        deps: List[str] = []\n+        s_deps: List[Modulemd.Dependencies] = ctx.get_dependencies() or []\n+        dep: Modulemd.Dependencies\n+        for dep in s_deps:\n+            deps.extend(dep.get_runtime_modules())\n+\n+        return deps\n+\n+    def index_modules(self) -> None:\n+        \"\"\"\n+        index_modules -- loads given metadata and indexes modules from there.\n+        \"\"\"\n+        if self._mod_index is None:\n+            mgr: Modulemd.ModuleIndex = Modulemd.ModuleIndexMerger.new()\n+            for path in self.metadata:\n+                idx = Modulemd.ModuleIndex.new()\n+                if self._is_meta_compressed(path):\n+                    with gzip.open(path) as gzmeta:\n+                        idx.update_from_string(gzmeta.read().decode(\"utf-8\"), True)\n+                else:\n+                    idx.update_from_file(path, True)\n+                mgr.associate_index(idx, 0)\n+            self._mod_index = mgr.resolve()\n+\n+    def get_default_stream(self, name: str):\n+        assert self._mod_index is not None, \"Unable to access module index when resolving default stream\"\n+        module = self._mod_index.get_module(name)\n+        if not module:\n+            raise ValueError(\"Module {} not found\".format(name))\n+        defaults = module.get_detaults()\n+        if defaults:\n+            return defaults.get_default_stream()\n+\n+        return module.get_all_streams()[0].get_stream_name()\n+\n+    def get_dep_streams(self, s_obj):\n+        dep = s_obj.get_dependencies()[0]  # XXX: Why just always first?\n+        all_deps = []  # type: ignore\n+        for m in dep.get_runtime_modules():\n+            deps = dep.get_runtime_streams(m)\n+            if deps:\n+                all_deps.append((m, deps[0],))  # XXX: why just first?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ebdd689746282209a2f297b258eef746e0c5d7f3"}, "originalPosition": 144}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "964c731f5335ae44c13d49b49ead330122d16fc1", "author": {"user": null}, "url": "https://github.com/uyuni-project/uyuni/commit/964c731f5335ae44c13d49b49ead330122d16fc1", "committedDate": "2020-01-14T16:56:22Z", "message": "Add module_packages function request"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "059ba956edf5717efb09e2254a3c9c6df7a01230", "author": {"user": null}, "url": "https://github.com/uyuni-project/uyuni/commit/059ba956edf5717efb09e2254a3c9c6df7a01230", "committedDate": "2020-01-14T16:56:47Z", "message": "Fix a typo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "79fc0df8c4d1e70f25b6395b6f2da76e75c14b87", "author": {"user": null}, "url": "https://github.com/uyuni-project/uyuni/commit/79fc0df8c4d1e70f25b6395b6f2da76e75c14b87", "committedDate": "2020-01-14T16:57:13Z", "message": "Implement module lister"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aec64c1e14758da904ec2a5ff82543f000e624f2", "author": {"user": null}, "url": "https://github.com/uyuni-project/uyuni/commit/aec64c1e14758da904ec2a5ff82543f000e624f2", "committedDate": "2020-01-14T16:57:42Z", "message": "Update list_packages response format"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "05aaf314c63b7948ec48e4db34d74f3e2b15aa7e", "author": {"user": null}, "url": "https://github.com/uyuni-project/uyuni/commit/05aaf314c63b7948ec48e4db34d74f3e2b15aa7e", "committedDate": "2020-01-14T16:58:01Z", "message": "Lintfix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ada174cfc9c58a2fb962872a062b6b928145ccc6", "author": {"user": null}, "url": "https://github.com/uyuni-project/uyuni/commit/ada174cfc9c58a2fb962872a062b6b928145ccc6", "committedDate": "2020-01-14T16:58:19Z", "message": "Add return type, update docstring"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1cc24c866165c434d5991c26706bf56374597c88", "author": {"user": null}, "url": "https://github.com/uyuni-project/uyuni/commit/1cc24c866165c434d5991c26706bf56374597c88", "committedDate": "2020-01-15T16:47:34Z", "message": "Add apis and selected artifacts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "afbd955e07f628224b1db2ea9a0a4e61e2cd0080", "author": {"user": null}, "url": "https://github.com/uyuni-project/uyuni/commit/afbd955e07f628224b1db2ea9a0a4e61e2cd0080", "committedDate": "2020-01-16T11:05:29Z", "message": "Use module name instead of artifact's one"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "674bcece25166336cadfeef0a13493fb74791dfe", "author": {"user": null}, "url": "https://github.com/uyuni-project/uyuni/commit/674bcece25166336cadfeef0a13493fb74791dfe", "committedDate": "2020-01-29T15:55:38Z", "message": "Stage all packages known to the stream, filter-out source packages"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5114879434e2762c32d911936114a1ebb21109ca", "author": {"user": null}, "url": "https://github.com/uyuni-project/uyuni/commit/5114879434e2762c32d911936114a1ebb21109ca", "committedDate": "2020-01-29T16:47:42Z", "message": "Fix typo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0d28a7616177f5a1e63926ab93addfc768cbf0a3", "author": {"user": null}, "url": "https://github.com/uyuni-project/uyuni/commit/0d28a7616177f5a1e63926ab93addfc768cbf0a3", "committedDate": "2020-01-29T16:48:33Z", "message": "Remove restriction on streams in input type"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "da8e9784e22af6c303d2536893c20f4a84f8c663", "author": {"user": null}, "url": "https://github.com/uyuni-project/uyuni/commit/da8e9784e22af6c303d2536893c20f4a84f8c663", "committedDate": "2020-01-29T16:49:34Z", "message": "Write error notification to the STDERR"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ae89ea16f8ab1020f6cf8bd7cc11c13c9b5f6ca7", "author": {"user": null}, "url": "https://github.com/uyuni-project/uyuni/commit/ae89ea16f8ab1020f6cf8bd7cc11c13c9b5f6ca7", "committedDate": "2020-01-29T16:50:04Z", "message": "Refactor \"api_provides\" method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d88f6b40f2ef9151d856417b4d2c58116a94db7b", "author": {"user": null}, "url": "https://github.com/uyuni-project/uyuni/commit/d88f6b40f2ef9151d856417b4d2c58116a94db7b", "committedDate": "2020-01-30T13:14:14Z", "message": "Show all selected stream contexts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "25692b573ff030583392eaa075e81c6d784dc336", "author": {"user": null}, "url": "https://github.com/uyuni-project/uyuni/commit/25692b573ff030583392eaa075e81c6d784dc336", "committedDate": "2020-01-30T16:31:00Z", "message": "Process multiple streams update"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "47f6d32e795528c4c1c6d5ba26da72f7f44c7e6a", "author": {"user": null}, "url": "https://github.com/uyuni-project/uyuni/commit/47f6d32e795528c4c1c6d5ba26da72f7f44c7e6a", "committedDate": "2020-01-30T16:31:20Z", "message": "Remove comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "462f859116fa1f98aebd5b3240c3f9b860f21d55", "author": {"user": null}, "url": "https://github.com/uyuni-project/uyuni/commit/462f859116fa1f98aebd5b3240c3f9b860f21d55", "committedDate": "2020-02-06T14:52:28Z", "message": "Add initial unit test for mlstreamlib"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2b885e976318662df20ca4821e2d3805567dbd53", "author": {"user": null}, "url": "https://github.com/uyuni-project/uyuni/commit/2b885e976318662df20ca4821e2d3805567dbd53", "committedDate": "2020-02-06T15:44:37Z", "message": "Add unit test for meta is compressed"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c925d9d4ca616d69f79ef6e965d0ae87d4cc602e", "author": {"user": null}, "url": "https://github.com/uyuni-project/uyuni/commit/c925d9d4ca616d69f79ef6e965d0ae87d4cc602e", "committedDate": "2020-02-06T15:44:51Z", "message": "add unit test for enabling stream"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "39b3a8308c5c1438eddf95004e1bfee1b47bffea", "author": {"user": null}, "url": "https://github.com/uyuni-project/uyuni/commit/39b3a8308c5c1438eddf95004e1bfee1b47bffea", "committedDate": "2020-02-06T15:47:17Z", "message": "Update doscstrings"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "49e4628b9c99d703970dda0d56cb3997e4042447", "author": {"user": null}, "url": "https://github.com/uyuni-project/uyuni/commit/49e4628b9c99d703970dda0d56cb3997e4042447", "committedDate": "2020-02-06T15:49:52Z", "message": "Add unit test for disable stream"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "12045c8d9c15b6dcaed94bf71901b408d6a6a12e", "author": {"user": null}, "url": "https://github.com/uyuni-project/uyuni/commit/12045c8d9c15b6dcaed94bf71901b408d6a6a12e", "committedDate": "2020-02-07T10:00:35Z", "message": "Add initial commit to the version"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f0684498de205d1f9291ffebe0f6715770256e08", "author": {"user": null}, "url": "https://github.com/uyuni-project/uyuni/commit/f0684498de205d1f9291ffebe0f6715770256e08", "committedDate": "2020-02-07T10:02:26Z", "message": "Add initial version of spec"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5153d8ec2d9ceeb696a8ba2099df4439bfa46ea0", "author": {"user": null}, "url": "https://github.com/uyuni-project/uyuni/commit/5153d8ec2d9ceeb696a8ba2099df4439bfa46ea0", "committedDate": "2020-02-07T10:09:16Z", "message": "Remove %files from spec"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4e09a51fa54fb6ec5d46a23459201fec11983391", "author": {"user": null}, "url": "https://github.com/uyuni-project/uyuni/commit/4e09a51fa54fb6ec5d46a23459201fec11983391", "committedDate": "2020-02-07T10:14:35Z", "message": "Automatic commit of package [mgr-libmod] release [0.2-1]."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c76ecaf4c080697d93e10be10b7969471f42e90b", "author": {"user": null}, "url": "https://github.com/uyuni-project/uyuni/commit/c76ecaf4c080697d93e10be10b7969471f42e90b", "committedDate": "2020-02-07T11:02:19Z", "message": "Add license file"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b3806be90e09a5d0ef2c21e6776db8c610177d7d", "author": {"user": null}, "url": "https://github.com/uyuni-project/uyuni/commit/b3806be90e09a5d0ef2c21e6776db8c610177d7d", "committedDate": "2020-02-07T12:02:01Z", "message": "Remove license"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8903f448831c4ae7777ddcc93735cb7b80a90813", "author": {"user": null}, "url": "https://github.com/uyuni-project/uyuni/commit/8903f448831c4ae7777ddcc93735cb7b80a90813", "committedDate": "2020-02-07T13:50:01Z", "message": "fix shebang for the main exec"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "88a9b45604e34e291b2062d10912bb44b996b918", "author": {"user": null}, "url": "https://github.com/uyuni-project/uyuni/commit/88a9b45604e34e291b2062d10912bb44b996b918", "committedDate": "2020-02-07T14:10:59Z", "message": "Update example documentation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "18d3bc801fe7f0f676c16c5149bcaba31bb7f430", "author": {"user": null}, "url": "https://github.com/uyuni-project/uyuni/commit/18d3bc801fe7f0f676c16c5149bcaba31bb7f430", "committedDate": "2020-02-07T14:11:29Z", "message": "Add list of supported functions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f1118a916956da5583cc8a337ec3aab70320ad3b", "author": {"user": null}, "url": "https://github.com/uyuni-project/uyuni/commit/f1118a916956da5583cc8a337ec3aab70320ad3b", "committedDate": "2020-02-07T14:15:48Z", "message": "Add license file"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1bb0b1aca55846048fd034f5de04a334918cf43d", "author": {"user": null}, "url": "https://github.com/uyuni-project/uyuni/commit/1bb0b1aca55846048fd034f5de04a334918cf43d", "committedDate": "2020-02-07T14:20:17Z", "message": "Update spec"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0f1f3ce41ed1d3dd09eab3c2d990e90fc8b0fb24", "author": {"user": null}, "url": "https://github.com/uyuni-project/uyuni/commit/0f1f3ce41ed1d3dd09eab3c2d990e90fc8b0fb24", "committedDate": "2020-02-07T14:23:13Z", "message": "Add license to the spec"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU1MTk2MjI0", "url": "https://github.com/uyuni-project/uyuni/pull/1769#pullrequestreview-355196224", "createdAt": "2020-02-07T14:34:16Z", "commit": {"oid": "0f1f3ce41ed1d3dd09eab3c2d990e90fc8b0fb24"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1706, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}